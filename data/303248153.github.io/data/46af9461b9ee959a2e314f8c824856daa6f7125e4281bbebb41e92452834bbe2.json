{
  "Source": "303248153.github.io",
  "Title": "CoreCLR源码探索(二) new是什么",
  "Link": "https://303248153.github.io/coreclr-02/",
  "Content": "\u003carticle class=\"post\"\u003e\n  \u003ch1\u003eCoreCLR源码探索(二) new是什么\u003c/h1\u003e\n\n  \u003cdiv class=\"entry\"\u003e\n    \u003cp\u003e前一篇我们看到了CoreCLR中对Object的定义，这一篇我们将会看CoreCLR中对new的定义和处理\nnew对于.Net程序员们来说同样是耳熟能详的关键词，我们每天都会用到new，然而new究竟是什么？\u003c/p\u003e\n\n\u003cp\u003e因为篇幅限制和避免难度跳的太高，这一篇将不会详细讲解以下的内容，请耐心等待后续的文章\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eGC如何分配内存\u003c/li\u003e\n  \u003cli\u003eJIT如何解析IL\u003c/li\u003e\n  \u003cli\u003eJIT如何生成机器码\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"使用到的名词和缩写\"\u003e使用到的名词和缩写\u003c/h3\u003e\n\n\u003cp\u003e以下的内容将会使用到一些名词和缩写，如果碰到看不懂的可以到这里来对照\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-plain\"\u003eBasicBlock: 在同一个分支(Branch)的一群指令，使用双向链表连接\nGenTree: 语句树，节点类型以GT开头\nImportation: 从BasicBlock生成GenTree的过程\nLowering: 具体化语句树，让语句树的各个节点可以明确的转换到机器码\nSSA: Static Single Assignment\nR2R: Ready To Run\nPhases: JIT编译IL到机器码经过的各个阶段\nJIT: Just In Time\nCEE: CLR Execute Engine\nee: Execute Engine\nEH: Exception Handling\nCor: CoreCLR\ncomp: Compiler\nfg: FlowGraph\nimp: Import\nLDLOCA: Load Local Variable\ngt: Generate\nhlp: Help\nFtn: Function\nMP: Multi Process\nCER: Constrained Execution Regions\nTLS: Thread Local Storage\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch3 id=\"net中的三种new\"\u003e.Net中的三种new\u003c/h3\u003e\n\n\u003cp\u003e请看图中的代码和生成的IL，我们可以看到尽管同样是new，却生成了三种不同的IL代码\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175554385-146908324.jpg\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20170109175602369-306882902.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对class的new，IL指令是newobj\u003c/li\u003e\n  \u003cli\u003e对array的new，IL指令是newarr\u003c/li\u003e\n  \u003cli\u003e对struct的new，因为myStruct已经在本地变量里面了，new的时候仅仅是调用ldloca加载然后调用构造函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e我们先来看newobj和newarr这两个指令在coreclr中是怎么定义的\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/opcode.def#L153\u003c/p\u003e\n\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eOPDEF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCEE_NEWOBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;newobj\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eVarPop\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePushRef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eInlineMethod\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eIObjModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xFF\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x73\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCALL\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003eOPDEF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCEE_NEWARR\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;newarr\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePopI\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePushRef\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eInlineType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eIObjModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xFF\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x8D\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXT\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到这两个指令的定义，名称分别是CEE_NEWOBJ和CEE_NEWARR，请记住这两个名称\u003c/p\u003e\n\n\u003ch3 id=\"第一种new对class的new生成了什么机器码\"\u003e第一种new(对class的new)生成了什么机器码\u003c/h3\u003e\n\n\u003cp\u003e接下来我们将看看coreclr是如何把CEE_NEWOBJ指令变为机器码的\n在讲解之前请先大概了解JIT的工作流程，JIT编译按函数为单位，当调用函数时会自动触发JIT编译\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e把函数的IL转换为BasicBlock(基本代码块)\u003c/li\u003e\n  \u003cli\u003e从BasicBlock(基本代码块)生成GenTree(语句树)\u003c/li\u003e\n  \u003cli\u003e对GenTree(语句树)进行Morph(变形)\u003c/li\u003e\n  \u003cli\u003e对GenTree(语句树)进行Lowering(具体化)\u003c/li\u003e\n  \u003cli\u003e根据GenTree(语句树)生成机器码\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面的代码虽然进过努力的提取，但仍然比较长，请耐心阅读\u003c/p\u003e\n\n\u003cp\u003e我们从JIT的入口函数开始看，这个函数会被EE(运行引擎)调用\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/corjit.h#L350\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/ee_il_dll.cpp#L279\n注: 按微软文档中说CILJit是32位上的实现，PreJit是64位上的实现，但实际我找不到PreJit在哪里\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eCorJitResult\u003c/span\u003e \u003cspan class=\"n\"\u003eCILJit\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecompileMethod\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eICorJitInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_METHOD_INFO\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBYTE\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"n\"\u003eentryAddress\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eULONG\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003enativeSizeOfCode\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eassert\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eILCode\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejitNativeCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emethodHandle\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003escope\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enativeSizeOfCode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                           \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ejitFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eCorJitResult\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ejitNativeCode是一个负责使用JIT编译单个函数的静态函数，会在内部为编译的函数创建单独的Compiler实例\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.cpp#L6075\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ejitNativeCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_METHOD_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003emethodHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"n\"\u003eCORINFO_MODULE_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003eclassPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"n\"\u003eCOMP_HANDLE\u003c/span\u003e           \u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"n\"\u003eCORINFO_METHOD_INFO\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e  \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e                \u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"n\"\u003eULONG\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e                \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"n\"\u003eJitFlags\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e             \u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                  \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e                 \u003cspan class=\"n\"\u003einlineInfoPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epComp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompInit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003einlineInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epComp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ejitFallbackCompile\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ejitFallbackCompile\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// Now generate the code\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epComp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eclassPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                   \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eCompiler::compCompile是Compiler类提供的入口函数，作用同样是编译函数\n注意这个函数有7个参数，等一会还会有一个同名但只有3个参数的函数\n这个函数主要调用了Compiler::compCompileHelper函数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.cpp#L4693\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_METHOD_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003emethodHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"n\"\u003eCORINFO_MODULE_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003eclassPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"n\"\u003eCOMP_HANDLE\u003c/span\u003e           \u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"n\"\u003eCORINFO_METHOD_INFO\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e  \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e                \u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"n\"\u003eULONG\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e                \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                          \u003cspan class=\"n\"\u003eJitFlags\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e             \u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epThis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompileHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eclassPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                                      \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                                      \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003einstVerInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eparam\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e让我们继续看Compiler::compCompileHelper\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.cpp#L5294\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompileHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_MODULE_HANDLE\u003c/span\u003e            \u003cspan class=\"n\"\u003eclassPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eCOMP_HANDLE\u003c/span\u003e                      \u003cspan class=\"n\"\u003ecompHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eCORINFO_METHOD_INFO\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e             \u003cspan class=\"n\"\u003emethodInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e                           \u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eULONG\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e                           \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eJitFlags\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e                        \u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eCorInfoInstantiationVerification\u003c/span\u003e \u003cspan class=\"n\"\u003einstVerInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 初始化本地变量表\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elvaInitTypeRef\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 查找所有BasicBlock\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efgFindBasicBlocks\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 调用3个参数的compCompile函数，注意不是7个函数的compCompile函数\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ecompCompile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eCORJIT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在到了3个参数的compCompile，这个函数被微软认为是JIT最被感兴趣的入口函数\n你可以额外阅读一下微软的\u003ca href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md\"\u003eJIT介绍文档\u003c/a\u003e\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.cpp#L4078\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e//*********************************************************************************************\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// #Phases\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// This is the most interesting \u0026#39;toplevel\u0026#39; function in the JIT.  It goes through the operations of\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// importing, morphing, optimizations and code generation.  This is called from the EE through the\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// code:CILJit::compileMethod function.\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// For an overview of the structure of the JIT, see:\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//   https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eULONG\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eJitFlags\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ecompileFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 转换BasicBlock(基本代码块)到GenTree(语句树)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efgImport\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 这里会进行各个处理步骤(Phases)，如Inline和优化等\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 转换GT_ALLOCOBJ节点到GT_CALL节点(分配内存=调用帮助函数)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eObjectAllocator\u003c/span\u003e \u003cspan class=\"n\"\u003eobjectAllocator\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eobjectAllocator\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 创建本地变量表和计算各个变量的引用计数\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elvaMarkLocalVars\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 具体化语句树\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eLowering\u003c/span\u003e \u003cspan class=\"n\"\u003elower\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003em_pLinearScan\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// PHASE_LOWERING\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elower\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 生成机器码\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ecodeGen\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egenGenerateCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emethodCodePtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emethodCodeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e到这里你应该大概知道JIT在总体上做了什么事情\n接下来我们来看Compiler::fgImport函数，这个函数负责把BasicBlock(基本代码块)转换到GenTree(语句树)\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/flowgraph.cpp#L6663\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003efgImport\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eimpImport\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efgFirstBB\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看Compiler::impImport\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/importer.cpp#L9207\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eimpImport\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBasicBlock\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003emethod\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/* Import blocks in the worker-list until there are no more */\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eimpPendingList\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePendingDsc\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003edsc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eimpPendingList\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eimpPendingList\u003c/span\u003e  \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eimpPendingList\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epdNext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* Now import the block */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eimpImportBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edsc\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epdBB\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看Compiler::impImportBlock\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/importer.cpp#L15321\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e//***************************************************************\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// Import the instructions for the given basic block.  Perform\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// verification, throwing an exception on failure.  Push any successor blocks that are enabled for the first\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// time, or whose verification pre-state is changed.\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eimpImportBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBasicBlock\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eblock\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epThis\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eimpImportBlockCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epParam\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eblock\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在接下来的Compiler::impImportBlockCode函数里面我们终于可以看到对CEE_NEWOBJ指令的处理了\n这个函数有5000多行，推荐直接搜索case CEE_NEWOBJ来看以下的部分\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/importer.cpp#L9207\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/*****************************************************************************\n *  Import the instr for the given basic block\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eimpImportBlockCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBasicBlock\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eblock\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 处理CEE_NEWOBJ指令\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eCEE_NEWOBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 在这里微软给出了有三种情况\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 一种是对象是array，一种是对象有活动的长度（例如string），一种是普通的class\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 在这里我们只分析第三种情况\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// There are three different cases for new\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Object size is variable (depends on arguments)\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e//      1) Object is an array (arrays treated specially by the EE)\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e//      2) Object is some other variable sized object (e.g. String)\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e//      3) Class Size can be determined beforehand (normal case)\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// In the first case, we need to call a NEWOBJ helper (multinewarray)\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// in the second case we call the constructor with a \u0026#39;0\u0026#39; this pointer\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// In the third case we alloc the memory, then call the constuctor\u003c/span\u003e\n        \n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 创建一个GT_ALLOCOBJ类型的GenTree(语句树)节点，用于分配内存\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eop1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egtNewAllocObjNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompHnd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eresolvedToken\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompMethodHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n                                \u003cspan class=\"n\"\u003eresolvedToken\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehClass\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eTYP_REF\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eop1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 因为GT_ALLOCOBJ仅负责分配内存，我们还需要调用构造函数\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 这里复用了CEE_CALL指令的处理\u003c/span\u003e\n        \u003cspan class=\"k\"\u003egoto\u003c/span\u003e \u003cspan class=\"n\"\u003eCALL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"nl\"\u003eCALL:\u003c/span\u003e \u003cspan class=\"c1\"\u003e// memberRef should be set.\u003c/span\u003e\n        \n            \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// 创建一个GT_CALL类型的GenTree(语句树)节点，用于调用构造函数\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ecallTyp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eimpImportCall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eopcode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eresolvedToken\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003econstraintCall\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003econstrainedResolvedToken\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003enullptr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                    \u003cspan class=\"n\"\u003enewObjThisPtr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eprefixFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecallInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eopcodeOffs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e请记住上面代码中新建的两个GenTree(语句树)节点\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e节点GT_ALLOCOBJ用于分配内存\u003c/li\u003e\n  \u003cli\u003e节点GT_CALL用于调用构造函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在上面的代码我们可以看到在生成GT_ALLOCOBJ类型的节点时还传入了一个newHelper参数，这个newHelper正是分配内存函数的一个标识(索引值)\n在CoreCLR中有很多HelperFunc(帮助函数)供JIT生成的代码调用\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp#L5894\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003eCEEInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_RESOLVED_TOKEN\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epResolvedToken\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_METHOD_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003ecallerHandle\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eVMClsHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAsMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetNewHelperStatic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e看CEEInfo::getNewHelperStatic\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp#L5941\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003eCEEInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewHelperStatic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 这里有很多判断，例如是否是Com对象或拥有析构函数，默认会返回CORINFO_HELP_NEWFAST\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// Slow helper is the default\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_HELP_NEWFAST\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e到这里，我们可以知道新建的两个节点带有以下的信息\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eGT_ALLOCOBJ节点\n    \u003cul\u003e\n      \u003cli\u003e分配内存的帮助函数标识，默认是CORINFO_HELP_NEWFAST\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eGT_CALL节点\n    \u003cul\u003e\n      \u003cli\u003e构造函数的句柄\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在使用fgImport生成了GenTree(语句树)以后，还不能直接用这个树来生成机器代码，需要经过很多步的变换\n其中的一步变换会把GT_ALLOCOBJ节点转换为GT_CALL节点，因为分配内存实际上是一个对JIT专用的帮助函数的调用\n这个变换在ObjectAllocator中实现，ObjectAllocator是JIT编译过程中的一个阶段(Phase)\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/objectalloc.cpp#L27\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eObjectAllocator\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eDoPhase\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMorphAllocObjNodes\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMorphAllocObjNodes用于查找所有节点，如果是GT_ALLOCOBJ则进行转换\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/objectalloc.cpp#L63\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eObjectAllocator\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMorphAllocObjNodes\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGenTreeStmt\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003estmt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eblock\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efirstStmt\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"n\"\u003estmt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003estmt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estmt\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtNextStmt\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003ecanonicalAllocObjFound\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eop2\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eOperGet\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eGT_ALLOCOBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ecanonicalAllocObjFound\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003etrue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecanonicalAllocObjFound\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eop2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eMorphAllocObjNodeIntoHelperCall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003easAllocObj\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMorphAllocObjNodeIntoHelperCall的定义\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/objectalloc.cpp#L152\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// MorphAllocObjNodeIntoHelperCall: Morph a GT_ALLOCOBJ node into an\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//                                  allocation helper call.\u003c/span\u003e\n\u003cspan class=\"n\"\u003eGenTreePtr\u003c/span\u003e \u003cspan class=\"n\"\u003eObjectAllocator\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eMorphAllocObjNodeIntoHelperCall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGenTreeAllocObj\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eallocObj\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eGenTreePtr\u003c/span\u003e \u003cspan class=\"n\"\u003ehelperCall\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecomp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efgMorphIntoHelperCall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eallocObj\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eallocObj\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtNewHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecomp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtNewArgList\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eop1\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ehelperCall\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003efgMorphIntoHelperCall的定义\n这个函数转换GT_ALLOCOBJ节点到GT_CALL节点，并且获取指向分配内存的函数的指针\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/morph.cpp#L61\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eGenTreePtr\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003efgMorphIntoHelperCall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGenTreePtr\u003c/span\u003e \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eGenTreeArgList\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eChangeOper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGT_CALL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtFlags\u003c/span\u003e \u003cspan class=\"o\"\u003e|=\u003c/span\u003e \u003cspan class=\"n\"\u003eGTF_CALL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 如果GT_ALLOCOBJ中帮助函数的标识是CORINFO_HELP_NEWFAST，这里就是eeFindHelper(CORINFO_HELP_NEWFAST)\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// eeFindHelper会把帮助函数的表示转换为帮助函数的句柄\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtCall\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egtCallType\u003c/span\u003e            \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCT_HELPER\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtCall\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egtCallMethHnd\u003c/span\u003e         \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eeeFindHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ehelper\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etree\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efgMorphArgs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAsCall\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003etree\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e到这里，我们可以知道新建的两个节点变成了这样\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eGT_CALL节点 (调用帮助函数)\n    \u003cul\u003e\n      \u003cli\u003e分配内存的帮助函数的句柄\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eGT_CALL节点 (调用Managed函数)\n    \u003cul\u003e\n      \u003cli\u003e构造函数的句柄\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e接下来JIT还会对GenTree(语句树)做出大量处理，这里省略说明，接下来我们来看机器码的生成\n函数CodeGen::genCallInstruction负责把GT_CALL节点转换为汇编\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/codegenxarch.cpp#L5934\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// Produce code for a GT_CALL node\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCodeGen\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egenCallInstruction\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGenTreePtr\u003c/span\u003e \u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecallType\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eCT_HELPER\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 把句柄转换为帮助函数的句柄，默认是CORINFO_HELP_NEWFAST\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ehelperNum\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eeeGetHelperNum\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emethHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 获取指向帮助函数的指针\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 这里等于调用compiler-\u0026gt;compGetHelperFtn(CORINFO_HELP_NEWFAST, ...)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompGetHelperFtn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ehelperNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epAddr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 调用普通函数\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Direct call to a non-virtual user function.\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egtDirectCallAddress\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们来看下compGetHelperFtn究竟把CORINFO_HELP_NEWFAST转换到了什么函数\ncompGetHelperFtn的定义\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.hpp#L1907\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecompGetHelperFtn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003eftnNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e        \u003cspan class=\"cm\"\u003e/* IN  */\u003c/span\u003e\n                                 \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e          \u003cspan class=\"n\"\u003eppIndirection\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* OUT */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompHnd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egetHelperFtn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eftnNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eppIndirection\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003egetHelperFtn的定义\n这里我们可以看到获取了hlpDynamicFuncTable这个函数表中的函数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp#L10369\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eCEEJitInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egetHelperFtn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e    \u003cspan class=\"n\"\u003eftnNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e         \u003cspan class=\"cm\"\u003e/* IN  */\u003c/span\u003e\n                               \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e**\u003c/span\u003e            \u003cspan class=\"n\"\u003eppIndirection\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \u003cspan class=\"cm\"\u003e/* OUT */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epfnHelper\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehlpDynamicFuncTable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003edynamicFtnNum\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003epfnHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLPVOID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eGetEEFuncEntryPoint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epfnHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ehlpDynamicFuncTable函数表使用了jithelpers.h中的定义，其中CORINFO_HELP_NEWFAST对应的函数如下\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/jithelpers.h#L78\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eJITHELPER\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_HELP_NEWFAST\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e                     \u003cspan class=\"n\"\u003eJIT_New\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e    \u003cspan class=\"n\"\u003eCORINFO_HELP_SIG_REG_ONLY\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到对应了JIT_New，这个就是JIT生成的代码调用分配内存的函数了，JIT_New的定义如下\n需要注意的是函数表中的JIT_New在满足一定条件时会被替换为更快的实现，但作用和JIT_New是一样的，这一块将在后面提及\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jithelpers.cpp#L2908\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eHCIMPL1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eJIT_New\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_CLASS_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003etypeHnd_\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etypeHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAsMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// AllocateObject是分配内存的函数，这个函数供CoreCLR的内部代码或非托管代码调用\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// JIT_New是对这个函数的一个包装，仅供JIT生成的代码调用\u003c/span\u003e\n    \u003cspan class=\"n\"\u003enewobj\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocateObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOBJECTREFToObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewobj\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003eHCIMPLEND\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\nJIT从CEE_NEWOBJ生成了两段代码，一段是调用JIT_New函数分配内存的代码，一段是调用构造函数的代码\u003c/p\u003e\n\n\u003ch3 id=\"第二种new对array的new生成了什么机器码\"\u003e第二种new(对array的new)生成了什么机器码\u003c/h3\u003e\n\n\u003cp\u003e我们来看一下CEE_NEWARR指令是怎样处理的，因为前面已经花了很大篇幅介绍对CEE_NEWOBJ的处理，这里仅列出不同的部分\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/importer.cpp#L13334\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/*****************************************************************************\n *  Import the instr for the given basic block\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eimpImportBlockCode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBasicBlock\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eblock\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 处理CEE_NEWARR指令\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eCEE_NEWARR\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eargs\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egtNewArgList\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eop1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eop2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// 生成GT_CALL类型的节点调用帮助函数\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* Create a call to \u0026#39;new\u0026#39; */\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Note that this only works for shared generic code because the same helper is used for all\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// reference array types\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eop1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egtNewHelperCallNode\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einfo\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecompCompHnd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewArrHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eresolvedToken\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehClass\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eTYP_REF\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到CEE_NEWARR直接生成了GT_CALL节点，不像CEE_NEWOBJ需要进一步的转换\ngetNewArrHelper返回了调用的帮助函数，我们来看一下getNewArrHelper\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp#L6035\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/***********************************************************************/\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// \u0026lt;REVIEW\u0026gt; this only works for shared generic code because all the\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// helpers are actually the same. If they were different then things might\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// break because the same helper would end up getting used for different but\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// representation-compatible arrays (e.g. one with a default constructor\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// and one without) \u0026lt;/REVIEW\u0026gt;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003eCEEInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewArrHelper\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_CLASS_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003earrayClsHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eTypeHandle\u003c/span\u003e \u003cspan class=\"n\"\u003earrayType\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earrayClsHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003egetNewArrHelperStatic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earrayType\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看getNewArrHelperStatic，我们可以看到一般情况下会返回CORINFO_HELP_NEWARR_1_OBJ\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp#L6060\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eCorInfoHelpFunc\u003c/span\u003e \u003cspan class=\"n\"\u003eCEEInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egetNewArrHelperStatic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTypeHandle\u003c/span\u003e \u003cspan class=\"n\"\u003eclsHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCorTypeInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eIsGenericVariable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eelemType\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_HELP_NEWARR_1_OBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCorTypeInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eIsObjRef\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eelemType\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// It is an array of object refs\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_HELP_NEWARR_1_OBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// These cases always must use the slow helper\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eCORINFO_HELP_NEWARR_1_OBJ对应的函数如下\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/jithelpers.h#L86\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eDYNAMICJITHELPER\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_HELP_NEWARR_1_OBJ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eJIT_NewArr1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eCORINFO_HELP_SIG_REG_ONLY\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到对应了JIT_NewArr1这个包装给JIT调用的帮助函数\n和JIT_New一样，在满足一定条件时会被替换为更快的实现\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jithelpers.cpp#L3303\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eHCIMPL2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eJIT_NewArr1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCORINFO_CLASS_HANDLE\u003c/span\u003e \u003cspan class=\"n\"\u003earrayTypeHnd_\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eINT_PTR\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eCorElementType\u003c/span\u003e \u003cspan class=\"n\"\u003eelemType\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayClassRef\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetArrayElementTypeHandle\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eGetSignatureCorElementType\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eCorTypeInfo\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eIsPrimitiveType\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eelemType\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 如果类型是基元类型(int, double等)则使用更快的FastAllocatePrimitiveArray函数\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enewArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eFastAllocatePrimitiveArray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epArrayClassRef\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ebAllocateInLargeHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 默认使用AllocateArrayEx函数\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eINT32\u003c/span\u003e \u003cspan class=\"n\"\u003esize32\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eINT32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enewArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocateArrayEx\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etypeHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003esize32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eOBJECTREFToObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enewArray\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003eHCIMPLEND\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\nJIT从CEE_NEWARR只生成了一段代码，就是调用JIT_NewArr1函数的代码\u003c/p\u003e\n\n\u003ch3 id=\"第三种new对struct的new生成了什么机器码\"\u003e第三种new(对struct的new)生成了什么机器码\u003c/h3\u003e\n\n\u003cp\u003e这种new会在栈(stack)分配内存，所以不需要调用任何分配内存的函数\n在一开始的例子中，myStruct在编译时就已经定义为一个本地变量，对本地变量的需要的内存会在函数刚进入的时候一并分配\n这里我们先来看本地变量所需要的内存是怎么计算的\u003c/p\u003e\n\n\u003cp\u003e先看Compiler::lvaAssignVirtualFrameOffsetsToLocals\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/lclvars.cpp#L4863\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/*****************************************************************************\n *  lvaAssignVirtualFrameOffsetsToLocals() : Assign virtual stack offsets to\n *  locals, temps, and anything else.  These will all be negative offsets\n *  (stack grows down) relative to the virtual \u0026#39;0\u0026#39;/return address\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003elvaAssignVirtualFrameOffsetsToLocals\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecur\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ealloc_order\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ecur\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"n\"\u003ecur\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elclNum\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evarDsc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elvaTable\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003elclNum\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003elvaCount\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003elclNum\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evarDsc\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// Reserve the stack space for this variable\u003c/span\u003e\n            \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elvaAllocLocalAndSetVirtualOffset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elclNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elvaLclSize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elclNum\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看Compiler::lvaAllocLocalAndSetVirtualOffset\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/lclvars.cpp#L5537\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003elvaAllocLocalAndSetVirtualOffset\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003elclNum\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/* Reserve space on the stack by bumping the frame size */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elvaIncrementFrameSize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e \u003cspan class=\"o\"\u003e-=\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elvaTable\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003elclNum\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003elvStkOffs\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003estkOffs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看Compiler::lvaIncrementFrameSize\n我们可以看到最终会加到compLclFrameSize这个变量中，这个变量就是当前函数总共需要在栈(Stack)分配的内存大小\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/lclvars.cpp#L3528\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003elvaIncrementFrameSize\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eMAX_FrameSize\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003ecompLclFrameSize\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eMAX_FrameSize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eBADCODE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Frame size overflow\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ecompLclFrameSize\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在来看生成机器码的代码，在栈分配内存的代码会在CodeGen::genFnProlog生成\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/codegencommon.cpp#L8140\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCodeGen\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egenFnProlog\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// ARM64和其他平台的调用时机不一样，但是参数一样\u003c/span\u003e\n    \u003cspan class=\"n\"\u003egenAllocLclFrame\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecompiler\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompLclFrameSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003einitReg\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003einitRegZeroed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eintRegState\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ersCalleeRegArgMaskLiveIn\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看CodeGen::genAllocLclFrame，这里就是分配栈内存的代码了，简单的rsp(esp)减去了frameSize\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/codegencommon.cpp#L5846\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/*-----------------------------------------------------------------------------\n *\n *  Probe the stack and allocate the local stack frame: subtract from SP.\n *  On ARM64, this only does the probing; allocating the frame is done when callee-saved registers are saved.\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eCodeGen\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003egenAllocLclFrame\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003eframeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eregNumber\u003c/span\u003e \u003cspan class=\"n\"\u003einitReg\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epInitRegZeroed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eregMaskTP\u003c/span\u003e \u003cspan class=\"n\"\u003emaskArgRegsLiveIn\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e//      sub esp, frameSize   6\u003c/span\u003e\n    \u003cspan class=\"n\"\u003einst_RV_IV\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eINS_sub\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eREG_SPBASE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eframeSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eEA_PTRSIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\nJIT对struct的new会生成统一在栈分配内存的代码，所以你在IL中看不到new struct的指令\n调用构造函数的代码会从后面的call指令生成\u003c/p\u003e\n\n\u003ch3 id=\"第一种new对class的new做了什么\"\u003e第一种new(对class的new)做了什么\u003c/h3\u003e\n\n\u003cp\u003e从上面的分析我们可以知道第一种new先调用JIT_New分配内存，然后调用构造函数\n在上面JIT_New的源代码中可以看到，JIT_New内部调用了AllocateObject\u003c/p\u003e\n\n\u003cp\u003e先看AllocateObject函数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/gchelpers.cpp#L931\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// AllocateObject will throw OutOfMemoryException so don\u0026#39;t need to check\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// for NULL return value from it.\u003c/span\u003e\n\u003cspan class=\"n\"\u003eOBJECTREF\u003c/span\u003e \u003cspan class=\"nf\"\u003eAllocateObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifdef FEATURE_COMINTEROP\n\u003c/span\u003e                         \u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003efHandleCom\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif\n\u003c/span\u003e    \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eObject\u003c/span\u003e     \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 如果类型有重要的析构函数，预编译所有相关的函数(详细可以搜索CER)\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 同一个类型只会处理一次\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHasCriticalFinalizer\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ePrepareCriticalFinalizerObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseSize\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetBaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 调用gc的帮助函数分配内存，如果需要向8对齐则调用AllocAlign8，否则调用Alloc\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eRequiresAlign8\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocAlign8\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                          \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHasFinalizer\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\n                                          \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eContainsPointers\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\n                                          \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIsValueType\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                                    \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHasFinalizer\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e\n                                    \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eContainsPointers\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 检查同步块索引(SyncBlock)是否为0\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// verify zero\u0026#39;d memory (at least for sync block)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eHasEmptySyncBlockInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 设置类型信息(MethodTable)\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003ebaseSize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eLARGE_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTableForLargeObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eGCHeap\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eGetGCHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ePublishObject\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eBYTE\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eUNCHECKED_OBJECTREF_TO_OBJECTREF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eoref\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看Alloc函数\n源代码:\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// There are only three ways to get into allocate an object.\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//     * Call optimized helpers that were generated on the fly. This is how JIT compiled code does most\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//         allocations, however they fall back code:Alloc, when for all but the most common code paths. These\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//         helpers are NOT used if profiler has asked to track GC allocation (see code:TrackAllocations)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//     * Call code:Alloc - When the jit helpers fall back, or we do allocations within the runtime code\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//         itself, we ultimately call here.\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//     * Call code:AllocLHeap - Used very rarely to force allocation to be on the large object heap.\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//     \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// While this is a choke point into allocating an object, it is primitive (it does not want to know about\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// MethodTable and thus does not initialize that poitner. It also does not know if the object is finalizable\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// or contains pointers. Thus we quickly wrap this function in more user-friendly ones that know about\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// MethodTables etc. (see code:FastAllocatePrimitiveArray code:AllocateArrayEx code:AllocateObject)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// You can get an exhaustive list of code sites that allocate GC objects by finding all calls to\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// code:ProfilerObjectAllocatedCallback (since the profiler has to hook them all).\u003c/span\u003e\n\u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nf\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBOOL\u003c/span\u003e \u003cspan class=\"n\"\u003ebFinalize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBOOL\u003c/span\u003e \u003cspan class=\"n\"\u003ebContainsPointers\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// We don\u0026#39;t want to throw an SO during the GC, so make sure we have plenty\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// of stack before calling in.\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eINTERIOR_STACK_PROBE_FOR\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetThread\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"k\"\u003estatic_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDEFAULT_ENTRY_PROBE_AMOUNT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mf\"\u003e1.5\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGCHeapUtilities\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eUseAllocationContexts\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eretVal\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGCHeapUtilities\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eGetGCHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eGetThreadAllocContext\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eretVal\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGCHeapUtilities\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eGetGCHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eretVal\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eThrowOutOfMemory\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eEND_INTERIOR_STACK_PROBE\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eretVal\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\n第一种new做的事情主要有\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e调用JIT_New\n    \u003cul\u003e\n      \u003cli\u003e从GCHeap中申请一块内存\u003c/li\u003e\n      \u003cli\u003e设置类型信息(MethodTable)\u003c/li\u003e\n      \u003cli\u003e同步块索引默认为0，不需要设置\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e调用构造函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"第二种new对array的new做了什么\"\u003e第二种new(对array的new)做了什么\u003c/h3\u003e\n\n\u003cp\u003e第二种new只调用了JIT_NewArr1，从上面JIT_NewArr1的源代码可以看到\n如果元素的类型是基元类型(int, double等)则会调用FastAllocatePrimitiveArray，否则会调用AllocateArrayEx\u003c/p\u003e\n\n\u003cp\u003e先看FastAllocatePrimitiveArray函数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/gchelpers.cpp#L563\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/*\n * Allocates a single dimensional array of primitive types.\n */\u003c/span\u003e\n\u003cspan class=\"n\"\u003eOBJECTREF\u003c/span\u003e   \u003cspan class=\"nf\"\u003eFastAllocatePrimitiveArray\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e \u003cspan class=\"n\"\u003ecElements\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBOOL\u003c/span\u003e \u003cspan class=\"n\"\u003ebAllocateInLargeHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 检查元素数量不能大于一个硬性限制\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eSIZE_T\u003c/span\u003e \u003cspan class=\"n\"\u003ecomponentSize\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetComponentSize\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecElements\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eMaxArrayLength\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecomponentSize\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eThrowOutOfMemory\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 检查总大小不能溢出\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eS_SIZE_T\u003c/span\u003e \u003cspan class=\"n\"\u003esafeTotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eS_SIZE_T\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecElements\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eS_SIZE_T\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecomponentSize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eS_SIZE_T\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetBaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esafeTotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIsOverflow\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eThrowOutOfMemory\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esafeTotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 调用gc的帮助函数分配内存\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebAllocateInLargeHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocLHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eArrayTypeDesc\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epArrayR8TypeDesc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eg_pPredefinedArrayTypes\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eELEMENT_TYPE_R8\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDATA_ALIGNMENT\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayR8TypeDesc\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayR8TypeDesc\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eLARGE_OBJECT_SIZE\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// Creation of an array of doubles, not in the large object heap.\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// We want to align the doubles to 8 byte boundaries, but the GC gives us pointers aligned\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// to 4 bytes only (on 32 bit platforms). To align, we ask for 12 bytes more to fill with a\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// dummy object.\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// If the GC gives us a 8 byte aligned address, we use it for the array and place the dummy\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// object after the array, otherwise we put the dummy object first, shifting the base of\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// the array to an 8 byte aligned address.\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// Note: on 64 bit platforms, the GC always returns 8 byte aligned addresses, and we don\u0026#39;t\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// execute this code because DATA_ALIGNMENT \u0026lt; sizeof(double) is false.\u003c/span\u003e\n\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eDATA_ALIGNMENT\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eDATA_ALIGNMENT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// used to change alignment\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetComponentSize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eg_pObjectClass\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetBaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n            \u003cspan class=\"n\"\u003eObject\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eorDummyObject\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eorDummyObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMIN_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eorDummyObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(((\u003c/span\u003e\u003cspan class=\"kt\"\u003esize_t\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eorDummyObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eg_pObjectClass\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ebPublish\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eLARGE_OBJECT_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 设置类型信息(MethodTable)\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// Initialize Object\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003epMT\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 设置数组长度\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003em_NumComponents\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecElements\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eObjectToOBJECTREF\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eorObject\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再看AllocateArrayEx函数，这个函数比起上面的函数多出了对多维数组的处理\nJIT_NewArr1调用AllocateArrayEx时传了3个参数，剩下2个参数是可选参数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/gchelpers.cpp#L282\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// Handles arrays of arbitrary dimensions\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// If dwNumArgs is set to greater than 1 for a SZARRAY this function will recursively \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// allocate sub-arrays and fill them in.  \u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// For arrays with lower bounds, pBounds is \u0026lt;lower bound 1\u0026gt;, \u0026lt;count 1\u0026gt;, \u0026lt;lower bound 2\u0026gt;, ...\u003c/span\u003e\n\u003cspan class=\"n\"\u003eOBJECTREF\u003c/span\u003e \u003cspan class=\"nf\"\u003eAllocateArrayEx\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTypeHandle\u003c/span\u003e \u003cspan class=\"n\"\u003earrayType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eINT32\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epArgs\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e \u003cspan class=\"n\"\u003edwNumArgs\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBOOL\u003c/span\u003e \u003cspan class=\"n\"\u003ebAllocateInLargeHeap\u003c/span\u003e \n                          \u003cspan class=\"n\"\u003eDEBUG_ARG\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBOOL\u003c/span\u003e \u003cspan class=\"n\"\u003ebDontSetAppDomain\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 调用gc的帮助函数分配内存\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebAllocateInLargeHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocLHeap\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eContainsPointers\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 设置类型信息(MethodTable)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTableForLargeObject\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifdef FEATURE_64BIT_ALIGNMENT\n\u003c/span\u003e        \u003cspan class=\"n\"\u003eMethodTable\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epElementMT\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003earrayDesc\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetTypeParam\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eGetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epElementMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eRequiresAlign8\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003epElementMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIsValueType\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// This platform requires that certain fields are 8-byte aligned (and the runtime doesn\u0026#39;t provide\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// this guarantee implicitly, e.g. on 32-bit platforms). Since it\u0026#39;s the array payload, not the\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// header that requires alignment we need to be careful. However it just so happens that all the\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// cases we care about (single and multi-dim arrays of value types) have an even number of DWORDs\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// in their headers so the alignment requirements for the header and the payload are the same.\u003c/span\u003e\n            \u003cspan class=\"n\"\u003e_ASSERTE\u003c/span\u003e\u003cspan class=\"p\"\u003e(((\u003c/span\u003e\u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eGetBaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eSIZEOF_OBJHEADER\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAllocAlign8\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eContainsPointers\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif\n\u003c/span\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eArrayBase\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etotalSize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eFALSE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eContainsPointers\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 设置类型信息(MethodTable)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eSetMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epArrayMT\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \n    \u003cspan class=\"c1\"\u003e// 设置数组长度\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// Initialize Object\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003em_NumComponents\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecElements\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 省略部分代码......\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eObjectToOBJECTREF\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eorArray\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\n第二种new做的事情主要有\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e调用JIT_NewArr1\n    \u003cul\u003e\n      \u003cli\u003e从GCHeap中申请一块内存\u003c/li\u003e\n      \u003cli\u003e设置类型信息(MethodTable)\u003c/li\u003e\n      \u003cli\u003e设置数组长度(m_NumComponents)\u003c/li\u003e\n      \u003cli\u003e不会调用构造函数，所以所有内容都会为0（所有成员都会为默认值）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"第三种new对struct的new做了什么\"\u003e第三种new(对struct的new)做了什么\u003c/h3\u003e\n\n\u003cp\u003e对struct的new不会从GCHeap申请内存，也不会设置类型信息(MethodTable)，所以可以直接进入总结\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e总结:\u003c/strong\u003e\n第三种new做的事情主要有\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e在进入函数时统一从栈(Stack)分配内存\n    \u003cul\u003e\n      \u003cli\u003e分配的内存不会包含同步块索引(SyncBlock)和类型信息(MethodTable)\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e调用构造函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"验证第一种new对class的new\"\u003e验证第一种new(对class的new)\u003c/h3\u003e\n\n\u003cp\u003e打开VS反汇编和内存窗口，让我们来看看第一种new实际做了什么事情\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175631135-1012741628.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e第一种new的反汇编结果如下，一共有两个call\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e00007FF919570B53  mov         rcx,7FF9194161A0h  // 设置第一个参数(指向MethodTable的指针)\n00007FF919570B5D  call        00007FF97905E350  // 调用分配内存的函数，默认是JIT_New\n00007FF919570B62  mov         qword ptr [rbp+38h],rax  // 把地址设置到临时变量(rbp+38)\n00007FF919570B66  mov         r8,37BFC73068h  \n00007FF919570B70  mov         r8,qword ptr [r8]  // 设置第三个参数(\u0026#34;hello\u0026#34;)\n00007FF919570B73  mov         rcx,qword ptr [rbp+38h]  // 设置第一个参数(this)\n00007FF919570B77  mov         edx,12345678h  // 设置第二个参数(0x12345678)\n00007FF919570B7C  call        00007FF9195700B8  // 调用构造函数\n00007FF919570B81  mov         rcx,qword ptr [rbp+38h]  \n00007FF919570B85  mov         qword ptr [rbp+50h],rcx  // 把临时变量复制到myClass变量中\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e第一个call是分配内存使用的帮助函数，默认调用JIT_New\n但是这里实际调用的不是JIT_New而是JIT_TrialAllocSFastMP_InlineGetThread函数，这是一个优化版本允许分配上下文中快速分配内存\n我们来看一下JIT_TrialAllocSFastMP_InlineGetThread函数的定义\n\u003cimg src=\"881857-20170109175639431-1227468600.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/amd64/JitHelpers_InlineGetThread.asm#L59\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e; IN: rcx: MethodTable*\n; OUT: rax: new object\nLEAF_ENTRY JIT_TrialAllocSFastMP_InlineGetThread, _TEXT\n        mov     edx, [rcx + OFFSET__MethodTable__m_BaseSize] // 从MethodTable获取需要分配的内存大小，放到edx\n\n        ; m_BaseSize is guaranteed to be a multiple of 8.\n        PATCHABLE_INLINE_GETTHREAD r11, JIT_TrialAllocSFastMP_InlineGetThread__PatchTLSOffset\n        mov     r10, [r11 + OFFSET__Thread__m_alloc_context__alloc_limit] // 获取分配上下文的限制地址，放到r10\n        mov     rax, [r11 + OFFSET__Thread__m_alloc_context__alloc_ptr] // 获取分配上下文的当前地址，放到rax\n\n        add     rdx, rax // 地址 + 需要分配的内存大小，放到rdx\n\n        cmp     rdx, r10 // 判断是否可以从分配上下文分配内存\n        ja      AllocFailed // if (rdx \u0026gt; r10)\n\n        mov     [r11 + OFFSET__Thread__m_alloc_context__alloc_ptr], rdx // 设置新的当前地址\n        mov     [rax], rcx // 给刚刚分配到的内存设置MethodTable\n\nifdef _DEBUG\n        call    DEBUG_TrialAllocSetAppDomain_NoScratchArea\nendif ; _DEBUG\n\n        ret // 分配成功，返回\n\n    AllocFailed:\n        jmp     JIT_NEW // 分配失败，调用默认的JIT_New函数\nLEAF_END JIT_TrialAllocSFastMP_InlineGetThread, _TEXT\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e可以当分配上下文未用完时会从分配上下文中分配，但用完时会调用JIT_New做更多的处理\n第二个call调用构造函数，call的地址和下面的地址不一致可能是因为中间有一层包装，目前还未解明包装中的处理\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175648150-302502498.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e最后一个call调用的是JIT_WriteBarrier\u003c/p\u003e\n\n\u003ch3 id=\"验证第二种new对array的new\"\u003e验证第二种new(对array的new)\u003c/h3\u003e\n\n\u003cp\u003e反汇编可以看到第二种new只有一个call\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175716088-1846490302.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e00007FF919570B93  mov         rcx,7FF9195B4CFAh  // 设置第一个参数(指向MethodTable的指针)\n00007FF919570B9D  mov         edx,378h  // 设置第二个参数(数组的大小)\n00007FF919570BA2  call        00007FF97905E440  // 调用分配内存的函数，默认是JIT_NewArr1\n00007FF919570BA7  mov         qword ptr [rbp+30h],rax  // 设置到临时变量(rbp+30)\n00007FF919570BAB  mov         rcx,qword ptr [rbp+30h]  \n00007FF919570BAF  mov         qword ptr [rbp+48h],rcx  // 把临时变量复制到myArray变量中\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003ecall实际调用的是JIT_NewArr1VC_MP_InlineGetThread这个函数\n和JIT_TrialAllocSFastMP_InlineGetThread一样，同样是从分配上下文中快速分配内存的函数\n源代码: https://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/amd64/JitHelpers_InlineGetThread.asm#L207\n具体代码这里就不再分析，有兴趣的可以去阅读上面的源代码\u003c/p\u003e\n\n\u003ch3 id=\"验证第三种new对struct的new\"\u003e验证第三种new(对struct的new)\u003c/h3\u003e\n\n\u003cp\u003e对struct的new会在函数进入的时候从栈分配内存，这里是减少rsp寄存器(栈顶)的值\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175726213-1345406093.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e00007FF919570B22  push        rsi  // 保存原rsi\n00007FF919570B23  sub         rsp,60h  // 从栈分配内存\n00007FF919570B27  mov         rbp,rsp  // 复制值到rbp\n00007FF919570B2A  mov         rsi,rcx  // 保存原rcx到rsi\n00007FF919570B2D  lea         rdi,[rbp+28h]  // rdi = rbp+28，有28个字节需要清零\n00007FF919570B31  mov         ecx,0Eh  // rcx = 14 (计数)\n00007FF919570B36  xor         eax,eax  // eax = 0\n00007FF919570B38  rep stos    dword ptr [rdi]  // 把eax的值(short)设置到rdi直到rcx为0，总共清空14*2=28个字节\n00007FF919570B3A  mov         rcx,rsi  // 恢复原rcx\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e因为分配的内存已经在栈里面，后面只需要直接调构造函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175734666-559744820.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e00007FF919570BBD  lea         rcx,[rbp+40h]  // 第一个参数 (this)\n00007FF919570BC1  mov         edx,55667788h  // 第二个参数 (0x55667788)\n00007FF919570BC6  call        00007FF9195700A0 // 调用构造函数\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e构造函数的反编译\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175741510-1082605316.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e中间有一个call 00007FF97942E260调用的是JIT_DbgIsJustMyCode\u003c/p\u003e\n\n\u003cp\u003e在函数结束时会自动释放从栈分配的内存，在最后会让rsp = rbp + 0x60，这样rsp就恢复原值了\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170109175752463-190531647.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"参考\"\u003e参考\u003c/h3\u003e\n\n\u003cp\u003ehttp://stackoverflow.com/questions/1255803/does-the-net-clr-jit-compile-every-method-every-time\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/gchelpers.h\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/gchelpers.cpp#L986\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jithelpers.cpp#L2908\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterface.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/jitinterfacegen.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/vm/amd64/JitHelpers_InlineGetThread.asm\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/gc/gcinterface.h#L230\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/gc/gc.h\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/gc/gc.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/opcode.def#L153\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/readytorunhelpers.h#L46\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/readytorun.h#L236\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/corinfo.h##L1147\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/corjit.h#L350\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/ee_il_dll.cpp#L279\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/inc/jithelpers.h\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.hpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.h\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/compiler.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/flowgraph.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/importer.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/gentree.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/objectalloc.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/morph.cpp\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/src/jit/codegenxarch.cpp#L8404\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/botr/ryujit-overview.md\nhttps://github.com/dotnet/coreclr/blob/master/Documentation/building/viewing-jit-dumps.md\nhttps://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md\nhttps://en.wikipedia.org/wiki/Basic_block\nhttps://en.wikipedia.org/wiki/Control_flow_graph\nhttps://en.wikipedia.org/wiki/Static_single_assignment_form\nhttps://msdn.microsoft.com/en-us/library/windows/hardware/ff561499(v=vs.85).aspx\nhttps://msdn.microsoft.com/en-us/library/ms228973(v=vs.110).aspx\nhttps://msdn.microsoft.com/en-us/library/system.runtime.constrainedexecution.criticalfinalizerobject(v=vs.110).aspx\nhttps://msdn.microsoft.com/en-us/library/system.runtime.interopservices.safehandle(v=vs.110).aspx\nhttps://msdn.microsoft.com/en-us/library/system.runtime.interopservices.criticalhandle(v=vs.110).aspx\nhttps://dotnet.myget.org/feed/dotnet-core/package/nuget/runtime.win7-x64.Microsoft.NETCore.Runtime.CoreCLR\nhttp://www.codemachine.com/article_x64deepdive.html\u003c/p\u003e\n\n\u003cp\u003e这一篇相对前一篇多了很多c++和汇编代码，也在表面上涉及到了JIT，你们可能会说看不懂\n这是正常的，我也不是完全看懂这篇提到的所有处理\n欢迎大神们勘误，也欢迎小白们提问\u003c/p\u003e\n\n\u003cp\u003e接下来我会重点分析GC分配内存的算法，敬请期待\u003c/p\u003e\n\n  \u003c/div\u003e\n\n  \u003cdiv class=\"date\"\u003e\n    Written on March 26, 2021\n  \u003c/div\u003e\n\n  \n\u003c/article\u003e",
  "Date": "2021-03-26T00:00:00Z",
  "Author": "老农的博客"
}