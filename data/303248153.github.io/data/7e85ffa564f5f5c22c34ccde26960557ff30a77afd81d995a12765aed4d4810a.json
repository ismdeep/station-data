{
  "Source": "303248153.github.io",
  "Title": "CoreCLR源码探索(一) Object是什么",
  "Link": "https://303248153.github.io/coreclr-01/",
  "Content": "\u003carticle class=\"post\"\u003e\n  \u003ch1\u003eCoreCLR源码探索(一) Object是什么\u003c/h1\u003e\n\n  \u003cdiv class=\"entry\"\u003e\n    \u003cp\u003e.Net程序员们每天都在和Object在打交道\n如果你问一个.Net程序员什么是Object，他可能会信誓旦旦的告诉你”Object还不简单吗，就是所有类型的基类”\n这个答案是对的，但是不足以说明Object真正是什么\u003c/p\u003e\n\n\u003cp\u003e在这篇文章我们将会通过阅读CoreCLR的源代码了解Object在内存中的结构和实际到内存中瞧瞧Object\u003c/p\u003e\n\n\u003ch3 id=\"勘误\"\u003e勘误\u003c/h3\u003e\n\n\u003cp\u003e通过更多的测试我发现了以下的错误，在此做出纠正，请之前的读者见谅\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eObject前面的不是指向ObjHeader的指针而是ObjHeader自身\u003c/li\u003e\n  \u003cli\u003eGC Pinned保存在ObjHeader(SyncBlock)而不是MethodTable\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"object在内存中的结构\"\u003eObject在内存中的结构\u003c/h3\u003e\n\n\u003cp\u003e为了便于理解后面的内容，我先用一张图说明Object在内存中的结构\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170106090220816-706277753.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e.Net中的Object包含了这三个部分\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对象头部(只包含了同步索引块)\u003c/li\u003e\n  \u003cli\u003e指向类型信息的指针\u003c/li\u003e\n  \u003cli\u003e字段内容\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e微软有一张更全的图（说明的是.Net Framework的结构，但是基本和.Net Core一样)\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"https://i.stack.imgur.com/J5TZJ.gif\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"object的源代码解析\"\u003eObject的源代码解析\u003c/h3\u003e\n\n\u003cp\u003eObject的定义(摘要)\n源代码: https://github.com/dotnet/coreclr/blob/master/src/vm/object.h\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eObject\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003ePTR_MethodTable\u003c/span\u003e \u003cspan class=\"n\"\u003em_pMethTab\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ePTR_MethodTable的定义，DPTR是一个指针的包装类，你可以先理解为MethodTable*的等价\n源代码: https://github.com/dotnet/coreclr/blob/master/src/vm/common.h\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003etypedef\u003c/span\u003e \u003cspan class=\"n\"\u003eDPTR\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ePTR_MethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在Object的定义中我们只看到了一个成员，这个成员就是\u003cstrong\u003e指向类型信息的指针\u003c/strong\u003e，那其他两个部分呢？\u003c/p\u003e\n\n\u003cp\u003e这是获取\u003cstrong\u003e指向头部的指针\u003c/strong\u003e的函数，我们可以看到对象头部刚好放在了Object的前面\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ePTR_ObjHeader\u003c/span\u003e \u003cspan class=\"nf\"\u003eGetHeader\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eLIMITED_METHOD_DAC_CONTRACT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003edac_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ePTR_ObjHeader\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这是获取\u003cstrong\u003e字段内容\u003c/strong\u003e的函数，我们可以看到字段内容刚好放在了Object的后面\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ePTR_BYTE\u003c/span\u003e \u003cspan class=\"nf\"\u003eGetData\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eLIMITED_METHOD_CONTRACT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eSUPPORTS_DAC\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003edac_cast\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003ePTR_BYTE\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eObject\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到Object中虽然只定义了\u003cstrong\u003e指向类型信息的指针\u003c/strong\u003e，但运行时候前面会带\u003cstrong\u003e对象头部\u003c/strong\u003e，并且后面会带\u003cstrong\u003e字段内容\u003c/strong\u003e\nObject结构比较特殊，所以这个对象的生成也需要特殊的处理，关于Object的生成我将在后面的篇幅中介绍\u003c/p\u003e\n\n\u003cp\u003eObject中定义的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003em_pMethTab\u003c/code\u003e还保存了额外的信息，因为这是一个指针值，所以总会以4或者8对齐，这样最后两个bit会总是为0\n.Net利用了最后一个闲置的bit，用于保存GC Marking(GC标记对象是否存活)，关于这里我也将在后面的篇幅中介绍\u003c/p\u003e\n\n\u003ch3 id=\"objheader的源代码解析\"\u003eObjHeader的源代码解析\u003c/h3\u003e\n\n\u003cp\u003eObjHeader的定义(摘要)\n源代码: https://github.com/dotnet/coreclr/blob/master/src/vm/syncblk.h\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eObjHeader\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// !!! Notice: m_SyncBlockValue *MUST* be the last field in ObjHeader.\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifdef _WIN64\n\u003c/span\u003e\t\u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e    \u003cspan class=\"n\"\u003em_alignpad\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif // _WIN64\n\u003c/span\u003e\t\n\t\u003cspan class=\"n\"\u003eVolatile\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em_SyncBlockValue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"c1\"\u003e// the Index and the Bits\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003em_alignpad\u003c/code\u003e是用于对齐的（让\u003ccode class=\"language-plaintext highlighter-rouge\"\u003em_SyncBlockValue\u003c/code\u003e在后面4位），值应该为0\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003em_SyncBlockValue\u003c/code\u003e的前6位是标记，后面26位是对应的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlockCache\u003c/code\u003e中的索引\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e的作用简单的来说就是用于线程同步的，例如下面的代码会用到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-c# highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eobj\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003eobject\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"k\"\u003elock\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eobj\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eObjHeader\u003c/code\u003e只包含了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e，所以你可以看到有的讲解Object结构的文章中会用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e代替\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eObjHeader\u003c/code\u003e\n关于\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSyncBlock\u003c/code\u003e更具体的讲解还可以\u003ca href=\"https://msdn.microsoft.com/zh-cn/library/aa686043.aspx\"\u003e查看这篇文章\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"methodtable的源代码解析\"\u003eMethodTable的源代码解析\u003c/h3\u003e\n\n\u003cp\u003eMethodTable的定义(摘要)\n源代码: https://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.h\u003c/p\u003e\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eMethodTable\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// Low WORD is component size for array and string types (HasComponentSize() returns true).\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// Used for flags otherwise.\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_dwFlags\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"c1\"\u003e// Base size of instance of this class when allocated on the heap\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eDWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_BaseSize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"n\"\u003eWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_wFlags2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"c1\"\u003e// Class token if it fits into 16-bits. If this is (WORD)-1, the class token is stored in the TokenOverflow optional member.\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_wToken\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"c1\"\u003e// \u0026lt;NICE\u0026gt; In the normal cases we shouldn\u0026#39;t need a full word for each of these \u0026lt;/NICE\u0026gt;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_wNumVirtuals\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eWORD\u003c/span\u003e \u003cspan class=\"n\"\u003em_wNumInterfaces\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\u003cspan class=\"cp\"\u003e#ifdef _DEBUG\n\u003c/span\u003e\t\u003cspan class=\"n\"\u003eLPCUTF8\u003c/span\u003e \u003cspan class=\"n\"\u003edebug_m_szClassName\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif //_DEBUG\n\u003c/span\u003e\t\n\t\u003cspan class=\"c1\"\u003e// Parent PTR_MethodTable if enum_flag_HasIndirectParent is not set. Pointer to indirection cell\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// if enum_flag_enum_flag_HasIndirectParent is set. The indirection is offset by offsetof(MethodTable, m_pParentMethodTable).\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// It allows casting helpers to go through parent chain natually. Casting helper do not need need the explicit check\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// for enum_flag_HasIndirectParentMethodTable.\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eTADDR\u003c/span\u003e \u003cspan class=\"n\"\u003em_pParentMethodTable\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"n\"\u003ePTR_Module\u003c/span\u003e \u003cspan class=\"n\"\u003em_pLoaderModule\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// LoaderModule. It is equal to the ZapModule in ngened images\u003c/span\u003e\n\t\n\t\u003cspan class=\"n\"\u003ePTR_MethodTableWriteableData\u003c/span\u003e \u003cspan class=\"n\"\u003em_pWriteableData\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"k\"\u003eunion\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eEEClass\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e   \u003cspan class=\"n\"\u003em_pEEClass\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eTADDR\u003c/span\u003e       \u003cspan class=\"n\"\u003em_pCanonMT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\t\n\t\u003cspan class=\"c1\"\u003e// m_pPerInstInfo and m_pInterfaceMap have to be at fixed offsets because of performance sensitive \u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// JITed code and JIT helpers. However, they are frequently not present. The space is used by other\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// multipurpose slots on first come first served basis if the fixed ones are not present. The other \u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// multipurpose are DispatchMapSlot, NonVirtualSlots, ModuleOverride (see enum_flag_MultipurposeSlotsMask).\u003c/span\u003e\n\t\u003cspan class=\"c1\"\u003e// The multipurpose slots that do not fit are stored after vtable slots.\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003eunion\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003ePTR_Dictionary\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e    \u003cspan class=\"n\"\u003em_pPerInstInfo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eTADDR\u003c/span\u003e               \u003cspan class=\"n\"\u003em_ElementTypeHnd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eTADDR\u003c/span\u003e               \u003cspan class=\"n\"\u003em_pMultipurposeSlot1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\t\n\t\u003cspan class=\"k\"\u003eunion\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eInterfaceInfo_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e   \u003cspan class=\"n\"\u003em_pInterfaceMap\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"n\"\u003eTADDR\u003c/span\u003e               \u003cspan class=\"n\"\u003em_pMultipurposeSlot2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\t\n\t\u003cspan class=\"c1\"\u003e// 接下来还有一堆OPTIONAL_MEMBERS，这里省去介绍\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里的字段非常多，我将会在后面的篇幅一一讲解，这里先说明MethodTable中大概有什么信息\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e类型的标记，例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eStaticsMask_Dynamic\u003c/code\u003e和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eStaticsMask_Generics\u003c/code\u003e等 (m_dwFlags)\n    \u003cul\u003e\n      \u003cli\u003e如果类型是字符串或数组还会保存每个元素的大小(ComponentSize)，例如string是2 int[100]是4\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e类型需要分配的内存大小 (m_BaseSize)\u003c/li\u003e\n  \u003cli\u003e类型信息，例如有哪些成员和是否接口等等 (m_pCanonMT)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可以看出这个类型就是用于保存类型信息的，反射和动态Cast都需要依赖它\u003c/p\u003e\n\n\u003ch3 id=\"实际查看内存中的object\"\u003e实际查看内存中的Object\u003c/h3\u003e\n\n\u003cp\u003e对Object的初步分析完了，可分析对了吗？让我们来实际检查一下内存中Object是什么样子的\nVisualStudio有反编译和查看内存的功能，如下图\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145414128-271279163.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里我定义了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyClass\u003c/code\u003e和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyStruct\u003c/code\u003e类型，先看\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eConsole.WriteLine(myClass)\u003c/code\u003e\n这里把第一个参数设置到rcx并且调用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eConsole.WriteLine\u003c/code\u003e函数，为什么是rcx请看查看参考链接中对\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efastcall\u003c/code\u003e的介绍\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erbp + 0x50 = 0x1fc8fde110\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145431253-1346954077.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e跳到内存中以后可以看到选中的这8byte是指向对象的指针，让我们继续跳到0x1fcad88390\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145438409-917046318.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里我们可以看到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyClass\u003c/code\u003e实例的真面目了，选中的8byte是指向\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMethodTable\u003c/code\u003e的指针\n后面分别是指向StringMember的指针和IntMember的内容\n在这里ObjHeader中的同步索引块值是0，这是正常的，微软在代码中有注释\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eThis is often zero\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145447050-2078607922.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里是StringMember指向的内容，分别是指向\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMethodTable\u003c/code\u003e的指针，字符串长度和字符串内容\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145505409-548234168.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyClass\u003c/code\u003e的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMethodTable\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003em_BaseSize\u003c/code\u003e是32\n有兴趣的可以去和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMethodTable\u003c/code\u003e的成员一一对照，这里我就不跟下去了\n让我们再看下struct是怎么处理的\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145511597-1550756255.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到只是简单的把值复制到了堆栈空间中（rbp是当前frame的堆栈基础地址)\n让我们再来看下\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eConsole.WriteLine\u003c/code\u003e对于struct是怎么处理的，这里的处理相当有趣\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145522378-151906875.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e因为需要装箱，首先会要来一个箱子，箱子放在了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erbp+30h\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145637003-1172385741.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e把\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyStruct\u003c/code\u003e中的值复制到了箱子中，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erax+8\u003c/code\u003e的8是把值复制到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMethodTable\u003c/code\u003e之后\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145650816-2002416271.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e复制后，接下来把这个箱子传给\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eConsole.WriteLine\u003c/code\u003e就和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMyClass\u003c/code\u003e一样了\u003c/p\u003e\n\n\u003cp\u003e另外再附一张实际查看\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eComponentSize\u003c/code\u003e的图\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170103145748800-361801018.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"彩蛋\"\u003e彩蛋\u003c/h3\u003e\n\n\u003cp\u003e看完了.Net中对Object的定义，让我们再看下Python中对Object的定义\n源代码: https://github.com/python/cpython/blob/master/Include/object.h\u003c/p\u003e\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#define PyObject_HEAD PyObject ob_base; // 每个子类都需要把这个放在最开头\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003etypedef\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_object\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifdef Py_TRACE_REFS\n\u003c/span\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_object\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003e_ob_next\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// Heap中的前一个对象\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_object\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003e_ob_prev\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// Heap中的后一个对象\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif\n\u003c/span\u003e\t\u003cspan class=\"n\"\u003ePy_ssize_t\u003c/span\u003e \u003cspan class=\"n\"\u003eob_refcnt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 引用计数\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e_typeobject\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eob_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 指向类型信息\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"n\"\u003ePyObject\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e定义不一样，但是作用还是类似的\u003c/p\u003e\n\n\u003ch3 id=\"参考\"\u003e参考\u003c/h3\u003e\n\n\u003cp\u003ehttp://stackoverflow.com/questions/20033353/clr-implementation-of-virtual-method-calls-via-pointer-to-base-class\nhttp://stackoverflow.com/questions/9808982/clr-implementation-of-virtual-method-calls-to-interface-members\nhttp://stackoverflow.com/questions/1589669/overhead-of-a-net-array\nhttps://en.wikipedia.org/wiki/X86_calling_conventions\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/object.inl\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/object.h\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/object.cpp\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/syncblk.h\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/syncblk.cpp\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.inl\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.h\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/methodtable.cpp\nhttps://github.com/dotnet/coreclr/blob/master/src/vm/class.h\nhttps://github.com/dotnet/coreclr/blob/master/src/inc/daccess.h\nhttps://github.com/dotnet/coreclr/blob/master/src/debug/daccess/dacfn.cpp\u003c/p\u003e\n\n\u003ch3 id=\"写在最后\"\u003e写在最后\u003c/h3\u003e\n\n\u003cp\u003e因为是刚开始阅读coreclr的代码，如果有误请在留言中指出\n接下来有时间我将会着重阅读和介绍这些内容\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eObject的生成和销毁\u003c/li\u003e\n  \u003cli\u003e\u003cdel\u003eObject继承的原理(MethodTable)\u003c/del\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cdel\u003eObject同步的原理(ObjHeader, SyncBlock)\u003c/del\u003e\u003c/li\u003e\n  \u003cli\u003eGC的工作方式\u003c/li\u003e\n  \u003cli\u003e\u003cdel\u003eDACCESS\u003c/del\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e敬请期待\u003c/p\u003e\n\n\u003cp\u003e2017-11-03更新: 这个系列暂时会停止更新, 很可惜上面的3项不能介绍它们了\u003c/p\u003e\n\n  \u003c/div\u003e\n\n  \u003cdiv class=\"date\"\u003e\n    Written on March 26, 2021\n  \u003c/div\u003e\n\n  \n\u003c/article\u003e",
  "Date": "2021-03-26T00:00:00Z",
  "Author": "老农的博客"
}