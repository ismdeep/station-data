{
  "Source": "303248153.github.io",
  "Title": "CoreCLR源码探索(五) GC内存收集器的内部实现 调试篇",
  "Link": "https://303248153.github.io/coreclr-05/",
  "Content": "\u003carticle class=\"post\"\u003e\n  \u003ch1\u003eCoreCLR源码探索(五) GC内存收集器的内部实现 调试篇\u003c/h1\u003e\n\n  \u003cdiv class=\"entry\"\u003e\n    \u003cp\u003e在上一篇中我分析了CoreCLR中GC的内部处理，\n在这一篇我将使用LLDB实际跟踪CoreCLR中GC，关于如何使用LLDB调试CoreCLR的介绍可以看:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e微软官方的文档，\u003ca href=\"https://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/building/debugging-instructions.md\"\u003e地址\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e我在第3篇中的介绍，\u003ca href=\"https://303248153.github.io/coreclr-03/\"\u003e地址\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eLLDB官方的入门文档，\u003ca href=\"http://lldb.llvm.org/tutorial.html\"\u003e地址\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"源代码\"\u003e源代码\u003c/h1\u003e\n\n\u003cp\u003e本篇跟踪程序的源代码如下:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"nn\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"nn\"\u003eSystem.Runtime.InteropServices\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"nn\"\u003eConsoleApplication\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eProgram\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassA\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassB\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eClassC\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \n        \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassA\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassB\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n            \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"nf\"\u003eClassC\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \n            \u003cspan class=\"n\"\u003eGCHandle\u003c/span\u003e \u003cspan class=\"n\"\u003ehandle\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGCHandle\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eAlloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eGCHandleType\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ePinned\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eIntPtr\u003c/span\u003e \u003cspan class=\"n\"\u003eaddress\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehandle\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eAddrOfPinnedObject\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eaddress\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \n            \u003cspan class=\"n\"\u003eGC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eCollect\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;first collect completed\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \n            \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eGC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eCollect\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;second collect completed\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \n            \u003cspan class=\"n\"\u003eGC\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eCollect\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;third collect completed\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"准备调试\"\u003e准备调试\u003c/h1\u003e\n\n\u003cp\u003e环境和我的第三篇文章一样，都是ubuntu 16.04 LTS，首先需要发布程序:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003edotnet publish\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e发布程序后，把自己编译的coreclr文件覆盖到发布目录中:\n复制\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecoreclr/bin/Product/Linux.x64.Debug\u003c/code\u003e下的文件到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e程序目录/bin/Debug/netcoreapp1.1/ubuntu.16.04-x64/publish\u003c/code\u003e下。\n请不要设置开启服务器GC，一来是这篇文章分析的是工作站GC的处理，二来开启服务器GC很容易导致调试时死锁。\u003c/p\u003e\n\n\u003ch1 id=\"进入调试\"\u003e进入调试\u003c/h1\u003e\n\n\u003cp\u003e准备工作完成以后就可以进入调试了\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nb\"\u003ecd \u003c/span\u003e程序目录/bin/Debug/netcoreapp1.1/ubuntu.16.04-x64/publish\nlldb-3.6 程序名称\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150540514-2003111457.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e首先设置gc主函数的断点，然后运行程序\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb gc1\nr\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150554608-942408327.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e我们停在了gc1函数，现在可以用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebt\u003c/code\u003e来看调用来源\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150605311-637737769.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这次是手动触发GC，调用来源中包含了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGCInterface::Collect\u003c/code\u003e和JIT生成的函数\u003c/p\u003e\n\n\u003cp\u003e需要显示当前的本地变量可以用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efr v\u003c/code\u003e，需要打印变量或者表达式可以用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ep\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150618639-1538665614.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e现在用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003en\u003c/code\u003e来步过，用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es\u003c/code\u003e来步进继续跟踪代码\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150626686-2097504150.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"进入标记阶段\"\u003e进入标记阶段\u003c/h1\u003e\n\n\u003cp\u003e在上图的位置中用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es\u003c/code\u003e命令即可进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emark_phase\u003c/code\u003e，继续步过到下图的位置\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150635576-1025637981.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这时先让我们看下堆中的对象，加载CoreCLR提供的LLDB插件\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eplugin load libsosplugin.so\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e插件提供的命令可以查看\u003ca href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/building/debugging-instructions.md\"\u003e这里的文档\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edumpheap\u003c/code\u003e查看堆中的状态\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150645983-1940192312.jpg\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20170327150653779-1991529799.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edso\u003c/code\u003e查看堆和寄存器中引用的对象\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150704029-337803725.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edumpobj\u003c/code\u003e查看对象的信息\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150712764-92525502.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在这一轮gc中对象a b c都会存活下来，\n可能你会对为什么b能存活下来感到惊讶，对象b的引用分配在栈上，即时生命周期过了也不一定会失效(rsp不会移回去)\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebr s \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e Promote \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;(long)*ppObject == 0x00007fff5c01a2b8\u0026#34;\u003c/span\u003e \u003cspan class=\"c\"\u003e# -n 名称 -c 条件\u003c/span\u003e\nc \u003cspan class=\"c\"\u003e# 继续执行\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150722733-1153459070.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来步进\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emark_object_simple\u003c/code\u003e函数，然后步进\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egc_mark1\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150730983-456732699.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eme re \u003cspan class=\"nt\"\u003e-s8\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c3\u003c/span\u003e \u003cspan class=\"nt\"\u003e-fx\u003c/span\u003e o \u003cspan class=\"c\"\u003e# 显示地址中的内存，8个字节一组，3组，hex格式，地址是o\u003c/span\u003e\np \u003cspan class=\"o\"\u003e((\u003c/span\u003eCObjectHeader\u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003eo\u003cspan class=\"o\"\u003e)\u003c/span\u003e-\u0026gt;IsMarked\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"c\"\u003e# 显示对象是否标记存活\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以清楚的看到标记对象存活设置了MethodTable的指针\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e|= 1\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e现在给\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePinObject\u003c/code\u003e下断点\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebr s \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e PinObject \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;(long)*pObjRef == 0x00007fff5c01a1a0\u0026#34;\u003c/span\u003e\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150744279-1187585068.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到只是调用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePromote\u003c/code\u003e然后传入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGC_CALL_PINNED\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e继续步进到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif (flags \u0026amp; GC_CALL_PINNED)\u003c/code\u003e下的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epin_object\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150756061-1183158491.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到pinned标记设置在同步索引块中\u003c/p\u003e\n\n\u003ch1 id=\"进入计划阶段\"\u003e进入计划阶段\u003c/h1\u003e\n\n\u003cp\u003e进入计划阶段后首先打印一下各个代的状态\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ep generation_table\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使用这个命令可以看到gen 0 ~ gen 3的状态，最后一个元素是空元素不用在意\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150807576-14706205.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e继续步过下去到下图的这一段\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327150822311-1458862172.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在这里我们找到了一个plug的开始，然后枚举已标记的对象，下图是擦除marked和pinned标记的代码\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151708576-1995706652.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在这里我们找到了一个plug的结束\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151716670-1809927679.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如果是Full GC或者不升代，在处理第一个plug之前就会设置gen 2的计划代边界\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151724670-1761834416.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e模拟压缩的地址\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151731436-2111095827.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如果x越过原来的gen 0的边界，设置gen 1的计划代边界(原gen 1的对象变gen 2)，\n如果不升代这里也会设置gen 0的计划代边界\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151739326-1514510968.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e模拟压缩后把原地址与压缩到的地址的偏移值存到plug信息(plug前的一块内存)中\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151746733-27150397.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e构建plug树\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151758045-1504996083.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e设置brick表，这个plug树跨了6个brick\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151805483-1833992159.jpg\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20170327151812858-1308203743.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如果升代，模拟压缩全部完成后设置gen 0的计划代边界\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151819951-200071078.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来如果不动里面的变量，将会进入清扫阶段(不满足进入压缩阶段的条件)\u003c/p\u003e\n\n\u003ch1 id=\"进入清扫阶段\"\u003e进入清扫阶段\u003c/h1\u003e\n\n\u003cp\u003e这次为了观察对象c如何被清扫，我们进入第二次gc的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emake_free_lists\u003c/code\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb make_free_lists\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e处理当前brick中的plug树\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151831545-581575177.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e前面看到的对象c的地址是0x00007fff5c01a2e8，这里我们就看对象c后面的plug是如何处理的\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebr s \u003cspan class=\"nt\"\u003e-f\u003c/span\u003e gc.cpp \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e 23070 \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;(long)tree \u0026gt; 0x00007fff5c01a2e8\u0026#34;\u003c/span\u003e\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到plug 0x00007fff5c01a300前面的空余空间中包含了对象c，空余空间的开始地址就是对象c\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151840654-289207868.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来就是在这片空余空间中创建free object和加到free list了，\n这里的大小不足(\u0026lt; min_free_list)所以只会创建free object不会加到free list中\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151847248-1101059016.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e设置代边界，之前计划阶段模拟的计划代边界不会被使用\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151855561-1506792143.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e清扫阶段完成后这次的gc的主要工作就完成了，接下来让我们看重定位阶段和压缩阶段\u003c/p\u003e\n\n\u003ch1 id=\"进入重定位阶段\"\u003e进入重定位阶段\u003c/h1\u003e\n\n\u003cp\u003e使用上面的程序让计划阶段选择压缩，需要修改变量，这里重新运行程序并使用以下命令\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb gc.cpp:22489\nc\nexpr should_compact = true\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151910326-1240659156.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003en\u003c/code\u003e步过到下图的位置，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es\u003c/code\u003e步进到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_phase\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151918342-302181678.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e到这个位置可以看到用了和标记阶段一样的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGcScanRoots\u003c/code\u003e函数，但是传入的不是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePromote\u003c/code\u003e而是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRelocate\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151925873-1573681889.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来下断点进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRelocate\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb Relocate\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGCHeap::Relocate\u003c/code\u003e函数不会重定位子对象，只是用来重定位来源于根对象的引用\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151935170-1308223849.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e一直走到这个位置然后进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egc_heap::relocate_address\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151941983-1033940802.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e根据原地址和brick table找到对应的plug树\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151949233-358850978.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e搜索plug树中old_address所属的plug\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327151957170-1287768781.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e根据plug中的reloc修改指针地址\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152034154-905231710.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e现在再来看relocate_survivors函数，这个函数用于重定位存活下来的对象中的引用\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb relocate_survivors\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152042514-1364300546.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来会枚举并处理brick，走到这里进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_survivors_in_brick\u003c/code\u003e函数，这个函数处理单个brick中的plug树\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152050811-1996307669.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e递归处理plug树种的各个节点\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152058217-517735462.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e走到这里进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_survivors_in_plug\u003c/code\u003e函数，这个函数处理单个plug中的对象\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152106076-1133803952.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e图中的这个plug结尾被下一个plug覆盖过，需要特殊处理，这里继续进入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_shortened_survivor_helper\u003c/code\u003e函数\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152114436-1321958538.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e当前是unpinned plug，下一个plug是pinned plug\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152121514-1817932039.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e枚举处理plug中的各个对象\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152130233-957936957.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如果这个对象结尾未被覆盖，则调用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_obj_helper\u003c/code\u003e重定位对象中的各个成员\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152138498-1158822354.jpg\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20170327152145358-114497160.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如果对象结尾被覆盖了，则调用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_shortened_obj_helper\u003c/code\u003e重定位对象中的各个成员\n在这里成员如果被覆盖会调用reloc_ref_in_shortened_obj修改备份数据中的成员，但是因为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ego_through_object_nostart\u003c/code\u003e是一个macro这里无法调试内部的代码\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152152514-1505387317.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来我们观察对象a的地址是否改变了\u003c/p\u003e\n\n\u003cp\u003e重新运行并修改\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eshould_compact\u003c/code\u003e变量\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb gc.cpp:22489\nr\nexpr should_compact = true\nplugin load libsosplugin.so\ndso\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到对象a的地址在0x00007fff5c01a2b8，接下来给\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erelocate_address\u003c/code\u003e函数下断点\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152202295-291880707.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebr s -n relocate_address -c \u0026#34;(long)(*pold_address) == 0x00007fff5c01a2b8\u0026#34;\nc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152210326-1348102643.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e我们可以看到地址由0x00007fff5c01a2b8变成了0x00007fff5c0091b8\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152217623-666214638.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来一直跳回plan_phase，下图可以看到重定位阶段完成以后新的地址上仍无对象，重定位阶段只是修改了地址并未复制内存，直到压缩阶段完成以后对象才会在新的地址\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152224779-776605027.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来看压缩阶段\u003c/p\u003e\n\n\u003ch1 id=\"进入压缩阶段\"\u003e进入压缩阶段\u003c/h1\u003e\n\n\u003cp\u003e在重定位阶段完成以后走到下图的位置，步进即可进入压缩阶段\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152304967-446062627.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e枚举brick table\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152313311-1914247365.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e处理单个brick table中的plug树\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152320623-1581021506.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e根据下一个tree的gap计算last_plug的大小\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152328920-820362514.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e处理单个plug中的对象\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152338858-927202393.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e上面的last_plug是pinned plug所以不移动，这里找了另外一个会移动的plug\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152349170-1079129531.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e下图可以看到整个plug都被复制到新的地址\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152358170-980128447.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里再找一个结尾被覆盖过的plug看看是怎么处理的\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152409045-1973170047.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e首先把被覆盖的结尾大小加回去\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152417061-1012921117.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e然后把被覆盖的内容临时恢复回去\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152424389-1614209682.jpg\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20170327152432733-1924735399.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e复制完再把覆盖的内容交换回来，因为下一个plug还需要用\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20170327152441154-176489810.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e最终在recover_saved_pinned_info会全部恢复回去\u003c/p\u003e\n\n\u003ch1 id=\"参考链接\"\u003e参考链接\u003c/h1\u003e\n\n\u003cp\u003ehttps://github.com/dotnet/coreclr/blob/master/Documentation/botr/garbage-collection.md\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/building/linux-instructions.md\nhttps://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/building/debugging-instructions.md\nhttp://lldb.llvm.org/tutorial.html\nhttp://lldb.llvm.org/lldb-gdb.html\u003c/p\u003e\n\n\u003ch1 id=\"写在最后\"\u003e写在最后\u003c/h1\u003e\n\n\u003cp\u003e这一篇中我列出了几个gc中比较关键的部分，但是还有成千上百处可以探讨的部分，\n如果你有兴趣可以自己试着用lldb调试CoreCLR，可以学到很多文档和书籍之外的知识，\n特别是对于CoreCLR这种文档少注释也少的项目，掌握调试工具可以大幅减少理解代码所需的时间\u003c/p\u003e\n\n\u003cp\u003e写完这一篇我将暂停研究GC，下一篇开始会介绍JIT相关的内容，敬请期待\u003c/p\u003e\n\n  \u003c/div\u003e\n\n  \u003cdiv class=\"date\"\u003e\n    Written on March 26, 2021\n  \u003c/div\u003e\n\n  \n\u003c/article\u003e",
  "Date": "2021-03-26T00:00:00Z",
  "Author": "老农的博客"
}