{
  "Source": "303248153.github.io",
  "Title": "CoreCLR源码探索(七) JIT的工作原理(入门篇)",
  "Link": "https://303248153.github.io/coreclr-07/",
  "Content": "\u003carticle class=\"post\"\u003e\n  \u003ch1\u003eCoreCLR源码探索(七) JIT的工作原理(入门篇)\u003c/h1\u003e\n\n  \u003cdiv class=\"entry\"\u003e\n    \u003cp\u003e很多C#的初学者都会有这么一个疑问, .Net程序代码是如何被机器加载执行的?\n最简单的解答是, C#会通过编译器(CodeDom, Roslyn)编译成IL代码,\n然后CLR(.Net Framework, .Net Core, Mono)会把这些IL代码编译成目标机器的机器代码并执行.\n相信大多数的C#的书籍都是这样一笔带过的.\n这篇和下篇文章会深入讲解JIT的具体工作流程,\n和前面的\u003ca href=\"https://303248153.github.io/coreclr-03/\"\u003eGC篇\u003c/a\u003e一样, 实现中的很多细节都是无标准文档的, 用搜索引擎不会找到它们相关的资料.\u003c/p\u003e\n\n\u003cp\u003e因为内容相当多, 讲解JIT的文章将会分为两篇.\n第一篇是入门篇, 看过这个系列之前的文章和CLR via C#, 了解一些编译原理的都可以看的明白.\n第二篇是详解篇, 会分析JIT的具体实现流程, 算法和数据结构.\u003c/p\u003e\n\n\u003cp\u003e这篇的内容是基于CoreCLR 1.1.0分析的, 其他CLR中的实现不一定和这篇分析的实现完全一样.\n微软最近提供了一篇\u003ca href=\"https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md\"\u003eJIT入门文档\u003c/a\u003e,\n尽管里面写的相当潦草但是仍有很大的参考价值, 推荐同时参考这个文档.\u003c/p\u003e\n\n\u003ch1 id=\"jit的作用介绍\"\u003eJIT的作用介绍\u003c/h1\u003e\n\n\u003cp\u003e相信很多C#程序员都知道, 我们编写的C#代码在经过编译后得出的exe或dll里面包含的并不是机器代码,\n而是一种中间代码, 也称为MSIL(简称IL).\nMSIL可以在不同的系统或者平台上执行, CLR中执行它们的模块就是这篇要讲的JIT.\u003c/p\u003e\n\n\u003cp\u003e如图所示\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171020085650334-654730236.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eCoreCLR中的JIT代号是RyuJIT, RyuJIT可以把MSIL翻译为X86, X64或者ARM的机器代码.\u003c/p\u003e\n\n\u003cp\u003e使用JIT的好处有\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e同一个程序集可以在不同平台上运行\u003c/li\u003e\n  \u003cli\u003e减少编译时间(编译到MSIL的时间比编译到机器代码的时间要短很多)\u003c/li\u003e\n  \u003cli\u003e可以根据目标平台选择最优的代码(例如只在支持AVX指令的CPU使用AVX指令)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e使用JIT的坏处有\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e增加运行负担\u003c/li\u003e\n  \u003cli\u003e不能执行过多的优化(否则将会增加更多的运行负担)\u003c/li\u003e\n  \u003cli\u003e部分平台上无法使用(例如iOS)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e为了解决这些坏处而出现的技术有NGEN, AOT, CoreRT等, 但是使用它们以后同时也就失去了使用JIT的好处.\u003c/p\u003e\n\n\u003ch1 id=\"jit的流程总览\"\u003eJIT的流程总览\u003c/h1\u003e\n\n\u003cp\u003e以下的图片来源于微软提供的\u003ca href=\"tps://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.m\"\u003eJIT入门文档\u003c/a\u003e:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018170911021-270571488.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e总体上来说RyuJIT可以分为两个部分.\n前端: 也就是图上的第一行, 负责把MSIL转换为JIT中的内部表现(IR)并且执行优化.\n后端: 也就是图上的第二行, 负责准备生产机器代码, 分配寄存器等与平台相关的处理.\u003c/p\u003e\n\n\u003cp\u003e具体的步骤可以分为:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018170923474-101412584.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e前端的步骤有(导入MSIL和优化):\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018170934115-1960918074.png\" alt=\"\"/\u003e\n\u003cimg src=\"881857-20171018170939677-1803666129.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e后端的步骤有(平台相关的处理):\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018170949615-116222337.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"jit的流程实例\"\u003eJIT的流程实例\u003c/h1\u003e\n\n\u003cp\u003e只看上面的图你可能会一头雾水, 我们来看看实际的流程.\n为了更容易理解这里我使用的是Debug模式.\n以下的内容来源于CoreCLR的输出, 设置环境变量”COMPlus_JitDump=Main”并且使用Debug版的CoreCLR即可得到.\u003c/p\u003e\n\n\u003cp\u003e首先是C#代码, 非常简单的循环3次并且输出到控制台.\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"nn\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eusing\u003c/span\u003e \u003cspan class=\"nn\"\u003eSystem.Runtime.InteropServices\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003enamespace\u003c/span\u003e \u003cspan class=\"nn\"\u003eConsoleApplication\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eProgram\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eMain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003estring\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003eargs\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e经过编译后会生成以下的IL, 下面我标记了运行堆栈的状态和简单的注释.\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eIL to import:\nIL_0000  00                nop\nIL_0001  16                ldc.i4.0                  ; 运行堆栈 [ 0 ]\nIL_0002  0a                stloc.0                   ; 运行堆栈 [ ], 保存到本地变量0 (x = 0)\nIL_0003  2b 0d             br.s         13 (IL_0012) ; 跳转到IL_0012\nIL_0005  00                nop\nIL_0006  06                ldloc.0                   ; 运行堆栈 [ x ]\nIL_0007  28 0c 00 00 0a    call         0xA00000C    ; 运行堆栈 [ ], 调用Console.WriteLine, 这里的0xA00000C是token\nIL_000c  00                nop\nIL_000d  00                nop         \nIL_000e  06                ldloc.0                   ; 运行堆栈 [ x ]\nIL_000f  17                ldc.i4.1                  ; 运行堆栈 [ x, 1 ]\nIL_0010  58                add                       ; 运行堆栈 [ x+1 ]\nIL_0011  0a                stloc.0                   ; 运行堆栈 [ ], 保存到本地变量0 (x = x + 1)\nIL_0012  06                ldloc.0                   ; 运行堆栈 [ x ]\nIL_0013  19                ldc.i4.3                  ; 运行堆栈 [ x, 3 ]\nIL_0014  fe 04             clt                       ; 运行堆栈 [ x\u0026lt;3 ]\nIL_0016  0b                stloc.1                   ; 运行堆栈 [ ], 保存到本地变量1 (tmp = x \u0026lt; 3)\nIL_0017  07                ldloc.1                   ; 运行堆栈 [ tmp ]\nIL_0018  2d eb             brtrue.s     -21 (IL_0005); 运行堆栈 [ ], 如果tmp为true则跳转到IL_0005\nIL_001a  2a                ret                       ; 从函数返回\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eRyuJIT的前端会把IL导入为中间表现(IR), 如下\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eImporting BB02 (PC=000) of \u0026#39;ConsoleApplication.Program:Main(ref)\u0026#39;\n    [ 0]   0 (0x000) nop\n\n               [000004] ------------             *  stmtExpr  void  (IL 0x000...  ???)\n               [000003] ------------             \\--*  no_op     void  \n\n    [ 0]   1 (0x001) ldc.i4.0 0\n    [ 1]   2 (0x002) stloc.0\n\n               [000008] ------------             *  stmtExpr  void  (IL 0x001...  ???)\n               [000005] ------------             |  /--*  const     int    0\n               [000007] -A----------             \\--*  =         int   \n               [000006] D------N----                \\--*  lclVar    int    V01 loc0         \n\n    [ 0]   3 (0x003) br.s\n\n               [000010] ------------             *  stmtExpr  void  (IL 0x003...  ???)\n               [000009] ------------             \\--*  nop       void  \n\nImporting BB03 (PC=005) of \u0026#39;ConsoleApplication.Program:Main(ref)\u0026#39;\n    [ 0]   5 (0x005) nop\n\n               [000025] ------------             *  stmtExpr  void  (IL 0x005...  ???)\n               [000024] ------------             \\--*  no_op     void  \n\n    [ 0]   6 (0x006) ldloc.0\n    [ 1]   7 (0x007) call 0A00000C\n\n               [000029] ------------             *  stmtExpr  void  (IL 0x006...  ???)\n               [000027] --C-G-------             \\--*  call      void   System.Console.WriteLine\n               [000026] ------------ arg0           \\--*  lclVar    int    V01 loc0         \n\n    [ 0]  12 (0x00c) nop\n\n               [000031] ------------             *  stmtExpr  void  (IL 0x00C...  ???)\n               [000030] ------------             \\--*  no_op     void  \n\n    [ 0]  13 (0x00d) nop\n\n               [000033] ------------             *  stmtExpr  void  (IL 0x00D...  ???)\n               [000032] ------------             \\--*  no_op     void  \n\n    [ 0]  14 (0x00e) ldloc.0\n    [ 1]  15 (0x00f) ldc.i4.1 1\n    [ 2]  16 (0x010) add\n    [ 1]  17 (0x011) stloc.0\n\n               [000039] ------------             *  stmtExpr  void  (IL 0x00E...  ???)\n               [000035] ------------             |     /--*  const     int    1\n               [000036] ------------             |  /--*  +         int   \n               [000034] ------------             |  |  \\--*  lclVar    int    V01 loc0         \n               [000038] -A----------             \\--*  =         int   \n               [000037] D------N----                \\--*  lclVar    int    V01 loc0         \n\nImporting BB04 (PC=018) of \u0026#39;ConsoleApplication.Program:Main(ref)\u0026#39;\n    [ 0]  18 (0x012) ldloc.0\n    [ 1]  19 (0x013) ldc.i4.3 3\n    [ 2]  20 (0x014) clt\n    [ 1]  22 (0x016) stloc.1\n\n               [000017] ------------             *  stmtExpr  void  (IL 0x012...  ???)\n               [000013] ------------             |     /--*  const     int    3\n               [000014] ------------             |  /--*  \u0026lt;         int   \n               [000012] ------------             |  |  \\--*  lclVar    int    V01 loc0         \n               [000016] -A----------             \\--*  =         int   \n               [000015] D------N----                \\--*  lclVar    int    V02 loc1         \n\n    [ 0]  23 (0x017) ldloc.1\n    [ 1]  24 (0x018) brtrue.s\n\n               [000022] ------------             *  stmtExpr  void  (IL 0x017...  ???)\n               [000021] ------------             \\--*  jmpTrue   void  \n               [000019] ------------                |  /--*  const     int    0\n               [000020] ------------                \\--*  !=        int   \n               [000018] ------------                   \\--*  lclVar    int    V02 loc1         \n\nImporting BB05 (PC=026) of \u0026#39;ConsoleApplication.Program:Main(ref)\u0026#39;\n    [ 0]  26 (0x01a) ret\n\n               [000042] ------------             *  stmtExpr  void  (IL 0x01A...  ???)\n               [000041] ------------             \\--*  return    void  \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到IL被分成了好几组(BB02~BB05), 这里的BB是BasicBlock的缩写,\n一个BasicBlock中有多个语句(Statement), 一个语句就是一棵树(GenTree).\u003c/p\u003e\n\n\u003cp\u003e上面的文本对应了以下的结构(又称HIR结构):\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171002052-454073754.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBasicBlock: 保存了一组语句, BasicBlock内原则上跳转指令只会出现在最后一个语句\nStatement: 一个语句就是一棵树, 在内部Statement也是一个GenTree的子类(GenTreeStmt)\nGenTree: 组成树的节点, 有很多不同的类型例如GenTreeUnOp(unary op), GenTreeIntCon(int constant)\u003c/p\u003e\n\n\u003cp\u003e有人可能会好奇为什么上面的BasicBlock从02开始, 这是因为01是内部用的block, 里面会保存函数开始时运行的内部处理.\u003c/p\u003e\n\n\u003cp\u003e接下来RyuJIT的前端会不断的修改HIR结构, 做出各种变形和优化:\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eTrees before IR Rationalize\n\n-------------------------------------------------------------------------------------------------------------------------------------\nBBnum         descAddr ref try hnd preds           weight   [IL range]      [jump]      [EH region]         [flags]\n-------------------------------------------------------------------------------------------------------------------------------------\nBB01 [00000000024701F8]  1                              1   [???..???)                                     i internal label target \nBB02 [0000000002473350]  1       BB01                   1   [???..???)-\u0026gt; BB04 ( cond )                     internal \nBB03 [0000000002473460]  1       BB02                   0.5 [???..???)                                     internal \nBB04 [0000000002473240]  2       BB02,BB03              1   [???..???)                                     i internal label target \nBB05 [0000000002470470]  1       BB04                   1   [000..005)-\u0026gt; BB07 (always)                     i \nBB06 [0000000002470580]  1       BB07                   1   [005..012)                                     i label target gcsafe bwd \nBB07 [0000000002470690]  2       BB05,BB06              1   [012..01A)-\u0026gt; BB06 ( cond )                     i label target bwd \nBB08 [00000000024707A0]  1       BB07                   1   [01A..01B)        (return)                     i \n-------------------------------------------------------------------------------------------------------------------------------------\n\n------------ BB01 [???..???), preds={} succs={BB02}\n\n***** BB01, stmt 1\n     (  0,  0) [000001] ------------             *  stmtExpr  void  (IL   ???...  ???)\nN001 (  0,  0) [000000] ------------             \\--*  nop       void  \n\n------------ BB02 [???..???) -\u0026gt; BB04 (cond), preds={BB01} succs={BB03,BB04}\n\n***** BB02, stmt 2\n     (  9, 16) [000055] ------------             *  stmtExpr  void  (IL   ???...  ???)\nN005 (  9, 16) [000054] ------------             \\--*  jmpTrue   void  \nN003 (  1,  1) [000045] ------------                |  /--*  const     int    0\nN004 (  7, 14) [000046] J------N----                \\--*  ==        int   \nN002 (  5, 12) [000044] ------------                   \\--*  indir     int   \nN001 (  3, 10) [000043] ------------                      \\--*  const(h)  long   0x7f95ea870610 token\n\n------------ BB03 [???..???), preds={BB02} succs={BB04}\n\n***** BB03, stmt 3\n     ( 14,  5) [000056] ------------             *  stmtExpr  void  (IL   ???...  ???)\nN001 ( 14,  5) [000047] --C-G-?-----             \\--*  call help void   HELPER.CORINFO_HELP_DBG_IS_JUST_MY_CODE\n\n------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}\n\n------------ BB05 [000..005) -\u0026gt; BB07 (always), preds={BB04} succs={BB07}\n\n***** BB05, stmt 4\n     (  1,  1) [000004] ------------             *  stmtExpr  void  (IL 0x000...0x000)\nN001 (  1,  1) [000003] ------------             \\--*  no_op     void  \n\n***** BB05, stmt 5\n     (  1,  3) [000008] ------------             *  stmtExpr  void  (IL 0x001...0x002)\nN001 (  1,  1) [000005] ------------             |  /--*  const     int    0\nN003 (  1,  3) [000007] -A------R---             \\--*  =         int   \nN002 (  1,  1) [000006] D------N----                \\--*  lclVar    int    V01 loc0         \n\n***** BB05, stmt 6\n     (  0,  0) [000010] ------------             *  stmtExpr  void  (IL 0x003...0x003)\nN001 (  0,  0) [000009] ------------             \\--*  nop       void  \n\n------------ BB06 [005..012), preds={BB07} succs={BB07}\n\n***** BB06, stmt 7\n     (  1,  1) [000025] ------------             *  stmtExpr  void  (IL 0x005...0x005)\nN001 (  1,  1) [000024] ------------             \\--*  no_op     void  \n\n***** BB06, stmt 8\n     ( 15,  7) [000029] ------------             *  stmtExpr  void  (IL 0x006...0x00C)\nN005 ( 15,  7) [000027] --C-G-------             \\--*  call      void   System.Console.WriteLine\nN003 (  1,  1) [000026] ------------ arg0 in rdi    \\--*  lclVar    int    V01 loc0         \n\n***** BB06, stmt 9\n     (  1,  1) [000031] ------------             *  stmtExpr  void  (IL 0x00C...  ???)\nN001 (  1,  1) [000030] ------------             \\--*  no_op     void  \n\n***** BB06, stmt 10\n     (  1,  1) [000033] ------------             *  stmtExpr  void  (IL 0x00D...0x00D)\nN001 (  1,  1) [000032] ------------             \\--*  no_op     void  \n\n***** BB06, stmt 11\n     (  3,  3) [000039] ------------             *  stmtExpr  void  (IL 0x00E...0x011)\nN002 (  1,  1) [000035] ------------             |     /--*  const     int    1\nN003 (  3,  3) [000036] ------------             |  /--*  +         int   \nN001 (  1,  1) [000034] ------------             |  |  \\--*  lclVar    int    V01 loc0         \nN005 (  3,  3) [000038] -A------R---             \\--*  =         int   \nN004 (  1,  1) [000037] D------N----                \\--*  lclVar    int    V01 loc0         \n\n------------ BB07 [012..01A) -\u0026gt; BB06 (cond), preds={BB05,BB06} succs={BB08,BB06}\n\n***** BB07, stmt 12\n     ( 10,  6) [000017] ------------             *  stmtExpr  void  (IL 0x012...0x016)\nN002 (  1,  1) [000013] ------------             |     /--*  const     int    3\nN003 (  6,  3) [000014] ------------             |  /--*  \u0026lt;         int   \nN001 (  1,  1) [000012] ------------             |  |  \\--*  lclVar    int    V01 loc0         \nN005 ( 10,  6) [000016] -A------R---             \\--*  =         int   \nN004 (  3,  2) [000015] D------N----                \\--*  lclVar    int    V02 loc1         \n\n***** BB07, stmt 13\n     (  7,  6) [000022] ------------             *  stmtExpr  void  (IL 0x017...0x018)\nN004 (  7,  6) [000021] ------------             \\--*  jmpTrue   void  \nN002 (  1,  1) [000019] ------------                |  /--*  const     int    0\nN003 (  5,  4) [000020] J------N----                \\--*  !=        int   \nN001 (  3,  2) [000018] ------------                   \\--*  lclVar    int    V02 loc1         \n\n------------ BB08 [01A..01B) (return), preds={BB07} succs={}\n\n***** BB08, stmt 14\n     (  0,  0) [000042] ------------             *  stmtExpr  void  (IL 0x01A...0x01A)\nN001 (  0,  0) [000041] ------------             \\--*  return    void\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上面的内容目前可以不用理解, 我贴出来只是为了说明HIR结构经过了转换和变形.\u003c/p\u003e\n\n\u003cp\u003e接下来就会进入RyuJIT的后端, RyuJIT的后端会根据HIR结构生成LIR结构:\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eTrees after IR Rationalize\n\n-------------------------------------------------------------------------------------------------------------------------------------\nBBnum         descAddr ref try hnd preds           weight   [IL range]      [jump]      [EH region]         [flags]\n-------------------------------------------------------------------------------------------------------------------------------------\nBB01 [00000000024701F8]  1                              1   [???..???)                                     i internal label target LIR \nBB02 [0000000002473350]  1       BB01                   1   [???..???)-\u0026gt; BB04 ( cond )                     internal LIR \nBB03 [0000000002473460]  1       BB02                   0.5 [???..???)                                     internal LIR \nBB04 [0000000002473240]  2       BB02,BB03              1   [???..???)                                     i internal label target LIR \nBB05 [0000000002470470]  1       BB04                   1   [000..005)-\u0026gt; BB07 (always)                     i LIR \nBB06 [0000000002470580]  1       BB07                   1   [005..012)                                     i label target gcsafe bwd LIR \nBB07 [0000000002470690]  2       BB05,BB06              1   [012..01A)-\u0026gt; BB06 ( cond )                     i label target bwd LIR \nBB08 [00000000024707A0]  1       BB07                   1   [01A..01B)        (return)                     i LIR \n-------------------------------------------------------------------------------------------------------------------------------------\n\n------------ BB01 [???..???), preds={} succs={BB02}\nN001 (  0,  0) [000000] ------------                nop       void  \n\n\n------------ BB02 [???..???) -\u0026gt; BB04 (cond), preds={BB01} succs={BB03,BB04}\nN001 (  3, 10) [000043] ------------       t43 =    const(h)  long   0x7f95ea870610 token\n\n                                                 /--*  t43    long   \nN002 (  5, 12) [000044] ------------       t44 = *  indir     int   \n\nN003 (  1,  1) [000045] ------------       t45 =    const     int    0\n\n                                                 /--*  t44    int    \n                                                 +--*  t45    int    \nN004 (  7, 14) [000046] J------N----       t46 = *  ==        int   \n\n                                                 /--*  t46    int    \nN005 (  9, 16) [000054] ------------             *  jmpTrue   void  \n\n\n------------ BB03 [???..???), preds={BB02} succs={BB04}\nN001 ( 14,  5) [000047] --C-G-?-----                call help void   HELPER.CORINFO_HELP_DBG_IS_JUST_MY_CODE\n\n\n------------ BB04 [???..???), preds={BB02,BB03} succs={BB05}\n\n------------ BB05 [000..005) -\u0026gt; BB07 (always), preds={BB04} succs={BB07}\n     (  1,  1) [000004] ------------                il_offset void   IL offset: 0\n\nN001 (  1,  1) [000003] ------------                no_op     void  \n\n     (  1,  3) [000008] ------------                il_offset void   IL offset: 1\n\nN001 (  1,  1) [000005] ------------        t5 =    const     int    0\n\n                                                 /--*  t5     int    \nN003 (  1,  3) [000007] DA----------             *  st.lclVar int    V01 loc0         \n\n     (  0,  0) [000010] ------------                il_offset void   IL offset: 3\n\nN001 (  0,  0) [000009] ------------                nop       void  \n\n\n------------ BB06 [005..012), preds={BB07} succs={BB07}\n     (  1,  1) [000025] ------------                il_offset void   IL offset: 5\n\nN001 (  1,  1) [000024] ------------                no_op     void  \n\n     ( 15,  7) [000029] ------------                il_offset void   IL offset: 6\n\nN003 (  1,  1) [000026] ------------       t26 =    lclVar    int    V01 loc0         \n\n                                                 /--*  t26    int    arg0 in rdi\nN005 ( 15,  7) [000027] --C-G-------             *  call      void   System.Console.WriteLine\n\n     (  1,  1) [000031] ------------                il_offset void   IL offset: 12\n\nN001 (  1,  1) [000030] ------------                no_op     void  \n\n     (  1,  1) [000033] ------------                il_offset void   IL offset: 13\n\nN001 (  1,  1) [000032] ------------                no_op     void  \n\n     (  3,  3) [000039] ------------                il_offset void   IL offset: 14\n\nN001 (  1,  1) [000034] ------------       t34 =    lclVar    int    V01 loc0         \n\nN002 (  1,  1) [000035] ------------       t35 =    const     int    1\n\n                                                 /--*  t34    int    \n                                                 +--*  t35    int    \nN003 (  3,  3) [000036] ------------       t36 = *  +         int   \n\n                                                 /--*  t36    int    \nN005 (  3,  3) [000038] DA----------             *  st.lclVar int    V01 loc0         \n\n\n------------ BB07 [012..01A) -\u0026gt; BB06 (cond), preds={BB05,BB06} succs={BB08,BB06}\n     ( 10,  6) [000017] ------------                il_offset void   IL offset: 18\n\nN001 (  1,  1) [000012] ------------       t12 =    lclVar    int    V01 loc0         \n\nN002 (  1,  1) [000013] ------------       t13 =    const     int    3\n\n                                                 /--*  t12    int    \n                                                 +--*  t13    int    \nN003 (  6,  3) [000014] ------------       t14 = *  \u0026lt;         int   \n\n                                                 /--*  t14    int    \nN005 ( 10,  6) [000016] DA----------             *  st.lclVar int    V02 loc1         \n\n     (  7,  6) [000022] ------------                il_offset void   IL offset: 23\n\nN001 (  3,  2) [000018] ------------       t18 =    lclVar    int    V02 loc1         \n\nN002 (  1,  1) [000019] ------------       t19 =    const     int    0\n\n                                                 /--*  t18    int    \n                                                 +--*  t19    int    \nN003 (  5,  4) [000020] J------N----       t20 = *  !=        int   \n\n                                                 /--*  t20    int    \nN004 (  7,  6) [000021] ------------             *  jmpTrue   void  \n\n\n------------ BB08 [01A..01B) (return), preds={BB07} succs={}\n     (  0,  0) [000042] ------------                il_offset void   IL offset: 26\n\nN001 (  0,  0) [000041] ------------                return    void\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我们可以看到在LIR结构里, BasicBlock包含的是GenTree节点的有序列表, 原来是树结构的节点现在都连成了一串.\nLIR结构跟最终生成的机器代码结构非常的相似.\u003c/p\u003e\n\n\u003cp\u003e接下来RyuJIT的后端会给LIR结构中的GenTree节点分配寄存器, 并且根据LIR结构生成汇编指令列表:\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eInstructions as they come out of the scheduler\n\nG_M21556_IG01:        ; func=00, offs=000000H, size=0016H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, nogc \u0026lt;-- Prolog IG\nIN001b: 000000 55                   push     rbp\nIN001c: 000001 4883EC10             sub      rsp, 16\nIN001d: 000005 488D6C2410           lea      rbp, [rsp+10H]\nIN001e: 00000A 33C0                 xor      rax, rax\nIN001f: 00000C 8945F4               mov      dword ptr [rbp-0CH], eax\nIN0020: 00000F 8945F0               mov      dword ptr [rbp-10H], eax\nIN0021: 000012 48897DF8             mov      gword ptr [rbp-08H], rdi\n\nG_M21556_IG02:        ; func=00, offs=000016H, size=0014H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, isz\nIN0001: 000016 48B8100687EA957F0000 mov      rax, 0x7F95EA870610\nIN0002: 000020 833800               cmp      dword ptr [rax], 0\nIN0003: 000023 7405                 je       SHORT G_M21556_IG03\n[02479BA8] ptr arg pop  0\nIN0004: 000025 E8D6E0B578           call     CORINFO_HELP_DBG_IS_JUST_MY_CODE\n\nG_M21556_IG03:        ; func=00, offs=00002AH, size=0009H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, isz\nIN0005: 00002A 90                   nop      \nIN0006: 00002B 33FF                 xor      edi, edi\nIN0007: 00002D 897DF4               mov      dword ptr [rbp-0CH], edi\nIN0008: 000030 90                   nop      \nIN0009: 000031 EB13                 jmp      SHORT G_M21556_IG05\n\nG_M21556_IG04:        ; func=00, offs=000033H, size=0013H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref\nIN000a: 000033 90                   nop      \nIN000b: 000034 8B7DF4               mov      edi, dword ptr [rbp-0CH]\n[02479BC0] ptr arg pop  0\nIN000c: 000037 E864F7FFFF           call     System.Console:WriteLine(int)\nIN000d: 00003C 90                   nop      \nIN000e: 00003D 90                   nop      \nIN000f: 00003E 8B45F4               mov      eax, dword ptr [rbp-0CH]\nIN0010: 000041 FFC0                 inc      eax\nIN0011: 000043 8945F4               mov      dword ptr [rbp-0CH], eax\n\nG_M21556_IG05:        ; func=00, offs=000046H, size=0019H, gcrefRegs=00000000 {}, byrefRegs=00000000 {}, byref, isz\nIN0012: 000046 8B7DF4               mov      edi, dword ptr [rbp-0CH]\nIN0013: 000049 83FF03               cmp      edi, 3\nIN0014: 00004C 400F9CC7             setl     dil\nIN0015: 000050 400FB6FF             movzx    rdi, dil\nIN0016: 000054 897DF0               mov      dword ptr [rbp-10H], edi\nIN0017: 000057 8B7DF0               mov      edi, dword ptr [rbp-10H]\nIN0018: 00005A 85FF                 test     edi, edi\nIN0019: 00005C 75D5                 jne      SHORT G_M21556_IG04\nIN001a: 00005E 90                   nop      \n\nG_M21556_IG06:        ; func=00, offs=00005FH, size=0006H, epilog, nogc, emitadd\nIN0022: 00005F 488D6500             lea      rsp, [rbp]\nIN0023: 000063 5D                   pop      rbp\nIN0024: 000064 C3                   ret      \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后Emitter把这些指令编码成机器代码就完成了JIT的编译工作.\u003c/p\u003e\n\n\u003ch1 id=\"jit的数据结构\"\u003eJIT的数据结构\u003c/h1\u003e\n\n\u003cp\u003e以下的图片来源于微软提供的\u003ca href=\"tps://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.m\"\u003eJIT入门文档\u003c/a\u003e:\u003c/p\u003e\n\n\u003cp\u003e第一张是HIR的数据结构\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171015099-1039055213.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e第二张是LIR的数据结构\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171023427-554503621.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e第三张是CoreCLR中实际的数据结构(HIR和LIR会共用GenTree节点).\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171028334-88323564.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"jit的触发\"\u003eJIT的触发\u003c/h1\u003e\n\n\u003cp\u003e在相当多的.NET书籍中都提到过, CLR中的JIT是懒编译的, 那么具体是如何实现的?\nJIT针对每个函数都会提供一个”桩”(Stub), 第一次调用时会触发JIT编译, 第二次调用时会跳转到第一次的编译结果.\n流程参考下图:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171038427-47061114.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eJIT之前的桩(例子)\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0x7fff7c21f5a8: e8 2b 6c fe ff     callq  0x7fff7c2061d8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eJIT之后的桩(例子)\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0x7fff7c21f5a8: e9 a3 87 3a 00     jmp    0x7fff7c5c7d50\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e具体的汇编代码分析我会在下一篇中给出, 目前你只需要理解”桩”起到的是一个路由的作用.\u003c/p\u003e\n\n\u003cp\u003e目前的CoreCLR触发了JIT编译后, 会在\u003cstrong\u003e当前线程\u003c/strong\u003e中执行JIT编译.\n如果多个线程同时调用了一个未JIT的函数, 其中一个线程会执行编译, 其他线程会等待编译完成.\nCoreCLR会对正在JIT编译的函数分配一个线程锁(ListLockEntry)来实现这一点.\u003c/p\u003e\n\n\u003cp\u003eJIT会为准备的函数创建一个Compiler实例, Compiler实例储存了BasicBlock列表等编译时需要的信息.\n一个正在编译的函数对应一个Compiler实例, 函数编译后Compiler实例会被销毁.\u003c/p\u003e\n\n\u003cp\u003e接下来我会对JIT的各项步骤进行一个简单的说明.\u003c/p\u003e\n\n\u003ch1 id=\"frontend\"\u003eFrontend\u003c/h1\u003e\n\n\u003ch3 id=\"importer\"\u003eImporter\u003c/h3\u003e\n\n\u003cp\u003eImporter负责读取和解析IL(byte array), 并根据IL生成JIT使用的内部表现IR(BasicBlock, Statement, GenTree).\nBasicBlock会根据它们的跳转类型连接成一个图(graph).\u003c/p\u003e\n\n\u003cp\u003e第一个BasicBlock是内部使用的, 会添加一些函数进入的初始化处理(但不要和汇编中的prolog混淆).\u003c/p\u003e\n\n\u003cp\u003e下图是Importer的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171050990-1998870058.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"inliner\"\u003eInliner\u003c/h3\u003e\n\n\u003cp\u003e如果函数符合内联的条件, 则Inliner会把函数的IR嵌入到它的调用端函数(callsite), 并且对本地变量和参数进行修整.\n执行内联后接下来的步骤将在调用端函数中完成.\u003c/p\u003e\n\n\u003cp\u003e内联的条件有很多, 判断逻辑也相当的复杂, 这里我只列出一部分:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e未开启优化时不内联\u003c/li\u003e\n  \u003cli\u003e函数是尾调用则不内联\u003c/li\u003e\n  \u003cli\u003e函数是虚函数时不内敛\u003c/li\u003e\n  \u003cli\u003e函数是helper call时不内联\u003c/li\u003e\n  \u003cli\u003e函数是indirect call时(编译时无法确认地址)时不内联\u003c/li\u003e\n  \u003cli\u003e未设置COMPlus_AggressiveInlining环境变量且函数在catch或者filter中时不内联\u003c/li\u003e\n  \u003cli\u003e之前尝试内联失败时不内联\u003c/li\u003e\n  \u003cli\u003e同步函数(CORINFO_FLG_SYNCH)不内联\u003c/li\u003e\n  \u003cli\u003e函数需要安全检查(CORINFO_FLG_SECURITYCHECK)时不内联\u003c/li\u003e\n  \u003cli\u003e如果函数有例外处理器则不内联\u003c/li\u003e\n  \u003cli\u003e函数无内容(大小=0)则不内联\u003c/li\u003e\n  \u003cli\u003e函数参数是vararg时不内联\u003c/li\u003e\n  \u003cli\u003e函数中的本地变量数量大于MAX_INL_LCLS(32)时不内联\u003c/li\u003e\n  \u003cli\u003e函数中的参数数量大于MAX_INL_LCLS时不内联\u003c/li\u003e\n  \u003cli\u003e函数中的本地变量(包含内部变量)有512个以上, 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e如果出现循环inline, 例如A inline B, B inline A, 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e如果层数大于InlineStrategy::IMPLEMENTATION_MAX_INLINE_DEPTH(1000), 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e如果函数有返回类型但无返回表达式(包含throw), 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e如果初始化内联函数所在的class失败, 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e如果内联函数估算体积 \u0026gt; 调用函数的指令体积 * 系数(DetermineMultiplier), 则标记内联失败\u003c/li\u003e\n  \u003cli\u003e等等\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下图是Inliner的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171100521-794837589.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"morph\"\u003eMorph\u003c/h3\u003e\n\n\u003cp\u003eMorph会对Importer导入的HIR进行变形, 这个步骤包含了很多处理, 这里我只列出一部分:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在第一个BasicBlock插入内部使用的代码\u003c/li\u003e\n  \u003cli\u003e删除无法到达的BasicBlock(死代码)\u003c/li\u003e\n  \u003cli\u003e如果有多个return block并且需要合并, 则生成一个新的return block并且让原来的block指向它\u003c/li\u003e\n  \u003cli\u003e对本地的struct变量进行promotion, 把各个字段提取出来作为单独的变量\u003c/li\u003e\n  \u003cli\u003e对各个节点进行修改\n    \u003cul\u003e\n      \u003cli\u003e标记节点是否需要检查null\u003c/li\u003e\n      \u003cli\u003e标记节点是否需要检查边界\u003c/li\u003e\n      \u003cli\u003e根据节点添加断言\n        \u003cul\u003e\n          \u003cli\u003e例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea = 5\u003c/code\u003e即可断言a等于5, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb = new X()\u003c/code\u003e即可断言\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb != null\u003c/code\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e需要时添加cast\u003c/li\u003e\n      \u003cli\u003e对于平台不支持的操作转换为helper call, 例如(1f+1f)转换为float_add(1f, 1f)\u003c/li\u003e\n      \u003cli\u003e进行简单的优化, 例如(常量+常量)转换为(常量)\u003c/li\u003e\n      \u003cli\u003e转换一些表达式, 例如(1 op 2 == 0)转换为(1 (rev op) 2)\u003c/li\u003e\n      \u003cli\u003e如果表达式带有溢出检查(checked), 则添加对应的throw block, 只添加一次\u003c/li\u003e\n      \u003cli\u003e添加检查数组边界的代码\u003c/li\u003e\n      \u003cli\u003e尾调用(tail call)优化\u003c/li\u003e\n      \u003cli\u003e等等\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e经过Morph变形后的HIR将会包含更多信息, 对IL中隐式的处理(例如边界检查和溢出检查)也添加了显式的代码(GenTree).\u003c/p\u003e\n\n\u003cp\u003e下图是Morph的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171110459-2142623924.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e图中的comma表示的是逗号式, 例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(X(), 123)\u003c/code\u003e这个式会先评价\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eX()\u003c/code\u003e然后结果使用123,\n上图中的comma会先把数组保存到一个临时变量, 执行边界检查, 然后再访问数组中的元素然后输出到控制台.\u003c/p\u003e\n\n\u003ch3 id=\"flowgraph-analysis\"\u003eFlowgraph Analysis\u003c/h3\u003e\n\n\u003cp\u003eFlowgraph Analysis会对BasicBlock进行流程分析,\n找出BasicBlock有哪些前任block(predecessor)和后继block(successor), 并且标记BasicBlock的引用次数.\u003c/p\u003e\n\n\u003cp\u003e如果一个block是多个block的跳转目标, 则这个block有多个preds,\n如果一个block的跳转类型是jtrue(条件成立时跳转到目标block, 否则到下一个block), 则这个block有两个succs.\u003c/p\u003e\n\n\u003cp\u003e并且计算DOM(dominator)树,\n例如出现 A -\u0026gt; B, A -\u0026gt; C, B -\u0026gt; D, C -\u0026gt; D, 则D的dominator不是B或C而是A, 表示执行D必须经过A,\n参考\u003ca href=\"https://en.wikipedia.org/wiki/Dominator_(graph_theory)\"\u003eWikipedia\u003c/a\u003e和\u003ca href=\"https://www.cs.rice.edu/~keith/EMBED/dom.pdf\"\u003e论文\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171119974-1389563809.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e例如在这张图中:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eblock 1的preds是[], succs是[2]\u003c/li\u003e\n  \u003cli\u003eblock 2的preds是[1, 5], succs是[3, 4, 6]\u003c/li\u003e\n  \u003cli\u003eblock 3的preds是[2], succs是[5]\u003c/li\u003e\n  \u003cli\u003eblock 4的preds是[2], succs是[5]\u003c/li\u003e\n  \u003cli\u003eblock 5的preds是[3, 4], succs是[2]\u003c/li\u003e\n  \u003cli\u003eblock 6的preds是[2], succs是[]\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e计算出来的DOM(dominator)树为:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171129021-148487134.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e然后会根据流程分析的结果进行一些优化:\u003c/p\u003e\n\n\u003cp\u003e优化 while 到 do while:\n优化前 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp test;          loop: ...; test: cond; jtrue loop;\u003c/code\u003e\n优化后 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econd; jfalse done; loop: ...; test: cond; jtrue loop; done: ...;\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e优化循环中数组的边界检查:\n优化前 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efor (var x = 0; x \u0026lt; a.Length; ++x) { b[x] = a[x]; },\u003c/code\u003e\n优化后\u003c/p\u003e\n\n\u003cdiv class=\"language-c++ highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLength\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003enull\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLength\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLength\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"k\"\u003edo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// no bounds check\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// no bounds check\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLength\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\u003cspan class=\"k\"\u003edo\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\t\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLength\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\t\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e优化次数是常量的循环:\n优化前 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efor (var x = 0; x \u0026lt; 3; ++x) { DoSomething(); }\u003c/code\u003e\n优化后 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDoSomething(); DoSomething(); DoSomething();\u003c/code\u003e\n注意循环次数过多或者循环中的代码过长则不会执行这项优化.\u003c/p\u003e\n\n\u003ch3 id=\"lclvar-sorting--tree-ordering\"\u003eLclVar sorting \u0026amp; Tree Ordering\u003c/h3\u003e\n\n\u003cp\u003e这个步骤会标记函数中本地变量的引用计数, 并且按引用计数排序本地变量表.\n然后会对tree的运行运行顺序执行标记, 例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea() + b()\u003c/code\u003e, 会标记\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea()\u003c/code\u003e先于\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb()\u003c/code\u003e执行.\n(与C, C++不同, .Net中对操作参数的运行顺序有很严格的规定, 例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea+b\u003c/code\u003e和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef(a, b)\u003c/code\u003e的运行顺序都是已规定的)\u003c/p\u003e\n\n\u003cp\u003e经过运行顺序标记后其实就已经形成了LIR结构.\nLIR结构中无语句(Statement)节点, 语句节点经过在后面的Rationalization后会变为IL_OFFSET节点, 用于对应的IL偏移值,\n最终VisualStudio等IDE可以根据\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e机器代码地址=\u0026gt;IL偏移值=\u0026gt;C#代码偏移值\u003c/code\u003e来下断点和调试.\u003c/p\u003e\n\n\u003cp\u003e下图是Tree Ordering的实例, 红线表示连接下一个节点:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171138006-58838255.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"optimize\"\u003eOptimize\u003c/h1\u003e\n\n\u003ch3 id=\"ssa--vn\"\u003eSSA \u0026amp; VN\u003c/h3\u003e\n\n\u003cp\u003eRyuJIT为了实现更好的优化, 会对GenTree节点分配\u003ca href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\"\u003eSSA\u003c/a\u003e序号和\u003ca href=\"https://en.wikipedia.org/wiki/Global_value_numbering\"\u003eVN\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e要说明什么是SSA, 可以拿\u003ca href=\"https://en.wikipedia.org/wiki/Static_single_assignment_form\"\u003eWikipedia上的代码\u003c/a\u003e做例子:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171148115-2057306438.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里有4个BasicBlock和3个变量(x, y, w), 变量的值会随着执行而改变,\n我们很难确定两个时点的y是否同一个y, 这为代码优化带来了障碍.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171157177-1001089272.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e为了解决这个问题我们为每个变量都标记一个版本号, 修改一次它的值就会出现一个新的版本.\n这就是SSA(Static single assignment form), 一个变量+版本只能有一个值, 这时我们可以很简单的确定两个时点的y是否同一个y.\n但是上图有一个问题, 最后一个BasicBlock使用的y在编译时是无法确定来源于哪个版本的.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171203365-50100994.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e为了解决这个问题, SSA引入了Φ(Phi)函数, 最后一个BasicBlock的开头添加一个新的版本\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ey3 = Φ(y1, y2)\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e而VN(Value Number)则是基于SSA的标记, 会根据给GenTree分配一个唯一的ID, 例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex = 3\u003c/code\u003e和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ew = 3\u003c/code\u003e时, x和w的VN会相等.\u003c/p\u003e\n\n\u003cp\u003e下图是标记SSA和VN的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171212599-809861991.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"loop-optimizations\"\u003eLoop Optimizations\u003c/h3\u003e\n\n\u003cp\u003e上面的”Flowgraph Analysis”提到的针对循环的一些优化, 在生成了SSA和VN以后我们可以做出进一步的优化.\u003c/p\u003e\n\n\u003cp\u003e例如这样的循环:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eSomeFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e*\u003c/span\u003e \u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea * 3\u003c/code\u003e这个表达式, 它每次循环都是一样的并且无副作用, 也就是我们可以提取(hoist)它到循环外面:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eSomeFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e*\u003c/span\u003e \u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"m\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e++\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eConsole\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nf\"\u003eWriteLine\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etmp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这样\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea * 3\u003c/code\u003e我们就只需要计算一次了, 但需要注意的是这种优化会增加一个临时变量, 所以实际\u003cstrong\u003e不一定会执行\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"copy-propagation\"\u003eCopy Propagation\u003c/h3\u003e\n\n\u003cp\u003e这项优化会替换具有相同VN的本地变量,\n例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evar tmp = a; var b = tmp + 1;\u003c/code\u003e, 因为我们确定tmp和a的值(VN)是一致的, 可以优化为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evar b = a + 1\u003c/code\u003e.\n在执行这项优化后, 多余的临时变量将不再需要, 例如上面的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etmp\u003c/code\u003e变量如果引用计数为0即可删除.\u003c/p\u003e\n\n\u003ch3 id=\"cse\"\u003eCSE\u003c/h3\u003e\n\n\u003cp\u003e这项优化会替换具有相同VN的\u003cstrong\u003e表达式\u003c/strong\u003e, 比起\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCopy Propagation\u003c/code\u003e这项优化的效果更强大.\n例如:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eSomeFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea + 5\u003c/code\u003e这个表达式出现了两次, 这两次对应的GenTree的VN都是一样的,\n因为它们无副作用(不会修改到全局状态), JIT可以把这段代码优化为:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"nf\"\u003eSomeFunction\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"p\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etmp\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e和上面的Loop Optimizations一样, 这种优化会增加一个临时变量, 所以实际\u003cstrong\u003e不一定会执行\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"assertion-propagation\"\u003eAssertion Propagation\u003c/h3\u003e\n\n\u003cp\u003e在上面的Morph中JIT根据语句添加了一些断言, 在生成VN后JIT可以传播这些断言.\n例如:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// x确定为1\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e传播断言后:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// x确定为1\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ey\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"m\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// y确定为3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"range-check-elimination\"\u003eRange Check Elimination\u003c/h3\u003e\n\n\u003cp\u003e因为断言已经传播, 这项优化可以根据断言和VN来判断哪些数组的边界检查是多余的.\n例如:\u003c/p\u003e\n\n\u003cdiv class=\"language-csharp highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003elength\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"m\"\u003e99\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// a的长度确定为100\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 确定访问不会越界, 所以这里的边界检查可以去掉\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"backend\"\u003eBackend\u003c/h1\u003e\n\n\u003ch3 id=\"rationalization\"\u003eRationalization\u003c/h3\u003e\n\n\u003cp\u003e这个步骤会正式把HIR转换为LIR, 后面的步骤使用的都是LIR形式.\n前面的HIR中存在着一些问题, 例如ASG(=)节点:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171221959-2011838068.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e看出问题了吗?\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elclVar\u003c/code\u003e在LIR中如果不访问后面的节点, 无法确定是\u003cstrong\u003e读取变量\u003c/strong\u003e还是\u003cstrong\u003e写入变量\u003c/strong\u003e.\nRationalizer会修改这些有问题的GenTree, 让后面的处理更加简单.\n上面的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elclVar =\u003c/code\u003e会修改为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003est.lclVar\u003c/code\u003e, 与\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elclVar\u003c/code\u003e区别开来.\u003c/p\u003e\n\n\u003ch3 id=\"lowering\"\u003eLowering\u003c/h3\u003e\n\n\u003cp\u003e这个步骤会修改LIR中的GenTree节点, 让它更接近最终生成的机器代码形式.\u003c/p\u003e\n\n\u003cp\u003e以下是部分会转换的GenTree节点:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eARR_LENGTH(获取数组长度), 会转换为IND(arr + ArrLenOffset), IND相当于C中的deref(*ptr)\u003c/li\u003e\n  \u003cli\u003e计算式, 可能时转换为LEA, 例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e((v07 \u0026lt;\u0026lt; 2) + v01) + 16\u003c/code\u003e可以转换为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elea(v01 + v07*4 + 16)\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eLONG, 如果当前cpu是x86(32位)则需要分为两个变量操作\u003c/li\u003e\n  \u003cli\u003eSWITCH, 切割SWITCH到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif else\u003c/code\u003e和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp jumpTable[x-offset]\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eCALL, 对于参数添加putarg节点(指定需要放到哪个寄存器或者推入堆栈)\u003c/li\u003e\n  \u003cli\u003eSTMT, 转换为IL_OFFSET, 让机器代码地址跟IL偏移值可以对应起来\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在完成了对GenTree节点的修改后, Lowering会对每个节点确定来源(src)和目标(dst)的寄存器数量.\n例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elclVar\u003c/code\u003e节点需要一个目标寄存器, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elclVar + lclVar\u003c/code\u003e节点需要两个来源寄存器和一个目标寄存器.\u003c/p\u003e\n\n\u003cp\u003e除了设置需要的寄存器数量外, Lowering还会标记哪些节点是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003econtained\u003c/code\u003e,\n标记为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003econtained\u003c/code\u003e的节点代表它是上级节点的一部分, 生成指令时不需要针对\u003ccode class=\"language-plaintext highlighter-rouge\"\u003econtained\u003c/code\u003e节点单独生成.\n典型的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003econtained\u003c/code\u003e节点是常量, 例如\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb = a + 1\u003c/code\u003e可以生成\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eadd rbx, 1; mov rdi, rbx;\u003c/code\u003e, 这里的1并不需要一条单独的指令.\u003c/p\u003e\n\n\u003cp\u003e下图是Lowering的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171238365-1515982750.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"lsra\"\u003eLSRA\u003c/h3\u003e\n\n\u003cp\u003e在Lowering确认了寄存器需求以后, JIT还需要给这些节点实际的分配寄存器.\n分配寄存器的算法有\u003ca href=\"https://en.wikipedia.org/wiki/Graph_coloring\"\u003eGraph coloring\u003c/a\u003e和\u003ca href=\"https://www.usenix.org/legacy/events/vee05/full_papers/p132-wimmer.pdf\"\u003eLSRA\u003c/a\u003e等, RyuJIT使用的是LSRA, 和论文中的算法很相似.\n使用LSRA算法可以让JIT中分配寄存器所需的计算量更少, 但是分配的结果(执行效率)会比Graph coloring差一些.\u003c/p\u003e\n\n\u003cp\u003e在LSRA中有以下概念:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eRefPosition: 记录定义或使用变量的位置, 如果是Def或者Use则有所属的Interval\u003c/li\u003e\n  \u003cli\u003eInterval: 同一个变量对应的使用期间, 包含多个RefPosition\u003c/li\u003e\n  \u003cli\u003eLocationInfo: 代码位置, 在构建时会对LIR中的GenTree分配位置, 位置总会+2\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下图是LSRA的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171250474-1099732361.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在这张图中, Interval 0~2 是本地变量, 这里只有V01被使用, Interval 3~4是虚拟变量, 用于表示函数返回的结果或传入的参数.\u003c/p\u003e\n\n\u003cp\u003eDEF表示Interval被写入, USE表示Interval被读取,\nKill无对应的Interval, 只用于表示指定的寄存器的值是否在某个位置后被破坏,\nFixedReg也无对应的Interval, 只用于表示对应的位置使用了固定的寄存器.\u003c/p\u003e\n\n\u003cp\u003e在确认Interval和RefPosition后, LSRA会开始分配寄存器,\n一个寄存器在同一时间只能被一个Interval使用, 图上的寄存器都未出现Interval重叠的情况,\n如果出现Interval重叠, 寄存器中的值会保存(spill)到堆栈上的变量.\n\u003cstrong\u003e如果一个变量从未被spill, 则该变量可以不使用堆栈保存\u003c/strong\u003e, 如图上的V01可以一直存在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erbx\u003c/code\u003e中, 不需要保存在内存里,\n这可以带来很大幅度的性能提升.\u003c/p\u003e\n\n\u003cp\u003eLSRA会积极的使用Callee Saved Register(RBX, RBP, R12, R13, R14, R15)暂存变量,\n这些寄存器在调用(call)其它函数后原来的值仍然会被保留, 不需要spill.\u003c/p\u003e\n\n\u003ch3 id=\"codegen\"\u003eCodeGen\u003c/h3\u003e\n\n\u003cp\u003e在以上步骤都完成后, JIT会根据cpu平台(x86, x64, arm)生成不一样的汇编指令.\u003c/p\u003e\n\n\u003cp\u003e在CodeGen中有以下概念:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003einstrDesc: 汇编指令的数据, 一个instrDesc实例对应一条汇编指令\u003c/li\u003e\n  \u003cli\u003einsGroup: 汇编指令的组, 一个insGroup包含一个或多个instrDesc, 跳转指令的目标只能是IG的第一条指令\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下图是CodeGen的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171300865-1208396172.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如图所示, CodeGen会按LIR中的节点和LSRA分配的寄存器信息生成汇编指令, 并且会对指令进行分组储存在不同的IG中.\n进入函数的prolog和离开函数的epilog指令也会在这里添加.\nCodeGen还会对汇编指令的大小进行估算, 确定最多需要分配多少内存才可以编码这些指令.\u003c/p\u003e\n\n\u003ch3 id=\"emiiter\"\u003eEmiiter\u003c/h3\u003e\n\n\u003cp\u003e在最后, Emiiter会从LoaderHeap中分配内存, 并且根据instrDesc编码机器代码.\u003c/p\u003e\n\n\u003cp\u003e下图是Emitter的实例:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171311631-790566433.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e除了写入机器代码外, Emiiter还会写入以下的信息:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ephdrDebugInfo: 包含了机器代码地址到IL偏移值的索引\u003c/li\u003e\n  \u003cli\u003ephdrJitEHInfo: 包含了函数中的例外信息\u003c/li\u003e\n  \u003cli\u003ephdrJitGCInfo: 包含了函数中需要GC扫描的变量的信息\u003c/li\u003e\n  \u003cli\u003eunindInfos: 包含了函数的堆栈回滚信息(在什么位置使用了多大的堆栈空间)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e最终写入的函数在内存中的结构如下:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171321381-1322853419.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e机器代码的前面是函数头信息(CodeHeader), 函数头信息指向真正的函数头信息(RealCodeHeader), 真正的头信息中包含了上面提到的信息.\n我们可以实际在Visual Studio中确认这一点:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171329271-1854550097.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e图中的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x7ffa46d0d898\u003c/code\u003e就是CodeHeader的内容, 也是指向RealCodeHeader的指针.\n后面的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e55 57 56 ...\u003c/code\u003e是机器代码, 表示\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epush rbp; push rdi; push rsi; ...\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"881857-20171018171335709-554953081.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e打开\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x7ffa46d0d898\u003c/code\u003e可以看到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRealCodeHeader\u003c/code\u003e的内容.\u003c/p\u003e\n\n\u003ch1 id=\"参考链接\"\u003e参考链接\u003c/h1\u003e\n\n\u003cul\u003e\n  \u003cli\u003ehttps://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md\u003c/li\u003e\n  \u003cli\u003ehttps://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/botr/ryujit-overview.md\u003c/li\u003e\n  \u003cli\u003ehttps://github.com/dotnet/coreclr/blob/release/1.1.0/Documentation/building/viewing-jit-dumps.md\u003c/li\u003e\n  \u003cli\u003ehttps://en.wikipedia.org/wiki/Dominator_(graph_theory)\u003c/li\u003e\n  \u003cli\u003ehttps://www.cs.rice.edu/~keith/EMBED/dom.pdf\u003c/li\u003e\n  \u003cli\u003ehttps://en.wikipedia.org/wiki/Static_single_assignment_form\u003c/li\u003e\n  \u003cli\u003ehttps://en.wikipedia.org/wiki/Global_value_numbering\u003c/li\u003e\n  \u003cli\u003ehttps://en.wikipedia.org/wiki/Graph_coloring\u003c/li\u003e\n  \u003cli\u003ehttps://www.usenix.org/legacy/events/vee05/full_papers/p132-wimmer.pdf\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这篇是JIT的入门+科普教程, 为了让内容更加易懂我省略了大量的实现细节, 也没有贴出CoreCLR中的代码.\n在下一篇我将结合CoreCLR中的代码讲解JIT的具体工作流程, 内容会比这一篇难很多, 绝大多数C#程序员只要理解这一篇就很足够了.\u003c/p\u003e\n\n  \u003c/div\u003e\n\n  \u003cdiv class=\"date\"\u003e\n    Written on March 26, 2021\n  \u003c/div\u003e\n\n  \n\u003c/article\u003e",
  "Date": "2021-03-26T00:00:00Z",
  "Author": "老农的博客"
}