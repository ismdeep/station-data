{
  "Source": "akarin.dev",
  "Title": "Hashids 算法和实现原理介绍",
  "Link": "https://akarin.dev/2021/02/26/hashids-description/",
  "Content": "\u003carticle class=\"mdui-p-a-3 mdui-card-content mdui-typo\"\u003e\u003cp\u003eHashids 是一个小巧的开源库，几乎所有的编程语言都有相应的实现，可以将一个或多个非负整数编码成看上去比较随机的短字符串。按照\u003ca href=\"https://hashids.org/\" target=\"_blank\" rel=\"noopener\"\u003e官网\u003c/a\u003e上的例子，\u003ccode\u003e347\u003c/code\u003e 可以编码成 \u003ccode\u003eyr8\u003c/code\u003e，\u003ccode\u003e[27, 986]\u003c/code\u003e 可以编码成 \u003ccode\u003e3kTMd\u003c/code\u003e，编码结果会根据初始化时的设置而不同，但只要\u003cstrong\u003e保持设置相同\u003c/strong\u003e就可以将编码后的字符串\u003cstrong\u003e解码恢复成原来的数值\u003c/strong\u003e。\u003c/p\u003e\u003cp\u003e这类算法一般可以用在数据库的自增 ID 上，如果需要把它写在 URL 或者 API 请求之类的地方展示出来但又不想轻易地被爬虫爬一遍的话……\u003c/p\u003e\u003cp\u003e例如以前屑站使用 AV 号对视频进行编号，实际上也是一个自增 ID，于是写个请求 \u003ccode\u003ehttp://acg.tv/av{i}\u003c/code\u003e 的爬虫，然后将 \u003ccode\u003ei\u003c/code\u003e 的值设为 0、1、2……如此一直爬下去，就可以获取到屑站所有视频的数据。后来屑站实装了 BV 号，av170001 变成了 BV17x411W7Kc，一时看不出规律，写爬虫就不怎么方便了。这个 BV 号就是对 AV 号使用 Hashids 类算法编码的结果。\u003c/p\u003e\u003cp\u003e\u003cem\u003e不过 BV 号实装后没多久就有人翻出了 \u003ca href=\"https://www.zhihu.com/question/381784377/answer/1099438784\" target=\"_blank\" rel=\"noopener\"\u003eAV 号和 BV 号互转的算法\u003c/a\u003e，并且 AV 号仍然可以照常使用，所以折腾出 BV 号这东西的意义嘛……另外 av99999999 之后的视频的 AV 号就\u003cstrong\u003e不再自增\u003c/strong\u003e而是\u003cstrong\u003e随机生成\u003c/strong\u003e了，真正起到反爬虫作用的其实是这个才对。\u003c/em\u003e\u003c/p\u003e\u003cp\u003e又比如你写了一个论坛，帖子的 ID 一般就是自增的。直接将自增 ID 展示出来的话，所有人都可以很容易地算出这个论坛每天发了多少帖子，由此继续分析用户活跃程度之类的……就像下面这样，注意写着 No. 的地方：\u003c/p\u003e\u003cfigure class=\"akarin-blurred-container\"\u003e\u003cdiv style=\"padding-bottom:min(calc(100%/1637*758),758px,480px)\"\u003e\u003c/div\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded\" data-src=\"https://p.sda1.dev/12/9100ab9c46b45700cc9159334ec85ce4/ut-Q4J-V.png\" data-src-avif=\"https://vfile.meituan.net/mmdb/aa3f214a61541fc3f703bc57bf524b8f99487.jpg\" data-src-webp=\"https://p.sda1.dev/12/d96e21c28417a0952f5a4537eacc3bce/Q6bE2pMp.webp\"/\u003e \u003cimg class=\"mdui-hoverable mdui-img-rounded akarin-blurred\" src=\"data:image/jpeg;base64,/9j/2wBDAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/2wBDAQgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/wAARCAAPACADASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAwQCBQYH/8QAKBAAAQQBAQUJAAAAAAAAAAAAAQACAxEEQRIhMTJhExRDcXKhsdHh/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAP/xAAaEQEAAwEBAQAAAAAAAAAAAAABAAIRAzFh/9oADAMBAAIRAxEAPwDsb8qFk0guMiyN76Q++xVYdDVHxP1I5FmaT1O+SlWg1rwdr5ocaoOsPV3wl+3KiItz2M67e72KO3Jh223OyrrmP2s4QVLHB7Yceca9QoNcFl7AC/J//9k\"/\u003e\u003cnoscript\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid\" src=\"https://p.sda1.dev/12/9100ab9c46b45700cc9159334ec85ce4/ut-Q4J-V.png\" alt=\"undefined\" title=\"undefined\"\u003e\u003c/noscript\u003e\u003c/figure\u003e\u003cp\u003e\u003cem\u003eA 岛默许了这个统计，而且使用自增 ID 的串号表示回复和引用本身就是 A 岛社区文化的重要一部分，\u003cdel\u003e比叔叔把已是屑站象征之一的 AV 号雪藏掉不知道高到哪里去了\u003c/del\u003e。当然对这个串号使用爬虫（又称“爬岛”）还是不允许的。\u003c/em\u003e\u003c/p\u003e\u003cp\u003eHashids 可以自定义编码时用到的字符表（默认是大小写字母数字，但是使用任意 Unicode 字符例如汉字和 emoji 也是可以的），还可以设置编码后字符串的最小长度（默认不设置，设置后编码得到的字符串长度小于此值则会用一定方式填充），另外还有叫 salt 的设定，设置不同的 salt 也会影响编码结果（就像加盐的 hash 算法那样？！）。可以在\u003ca href=\"https://jsbin.com/kebobahude/edit?html,js,console\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e随意尝试～\u003c/p\u003e\u003ch1 id=\"Hashids-真的属于-hash-算法吗？\"\u003e\u003ca href=\"#Hashids-真的属于-hash-算法吗？\" class=\"headerlink\" title=\"Hashids 真的属于 hash 算法吗？\"\u003e\u003c/a\u003eHashids 真的属于 hash 算法吗？\u003c/h1\u003e\u003cp\u003e虽然 Hashids 的名字里面就写着 hash，而且设置里也用上了 salt 这种确实和 hash 算法有关的词，但是它真的是一个 hash 算法吗……找出 hash 算法的定义来对比一下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e给定原始数据，很容易可以计算出对应的 hash 值。显然成立。\u003c/li\u003e\u003cli\u003e即使原始数据出现很小的差异，对应的 hash 值也会有巨大的变化，尽量不要产生碰撞。在上面的“随意尝试”里就可以看出确实会产生巨大变化（虽然某些地方的变化并不大……），而且按照 Hashids 的原理（稍后说明）冲突是完全不可能产生的。\u003c/li\u003e\u003cli\u003e给定 hash 值，反过来计算原始数据是很难的。嗯？Hashids 编码得到的字符串是可以恢复的啊？\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e最后一条定义说明了 Hashids 实际上并不是一个严格意义上的 hash 算法。虽然各种真正的 hash 算法（例如 \u003ca href=\"https://zh.wikipedia.org/wiki/Bcrypt\" target=\"_blank\" rel=\"noopener\"\u003ebcrypt\u003c/a\u003e 或者各种 \u003ca href=\"https://zh.wikipedia.org/wiki/%E5%AF%86%E9%92%A5%E6%95%A3%E5%88%97%E6%B6%88%E6%81%AF%E8%AE%A4%E8%AF%81%E7%A0%81\" target=\"_blank\" rel=\"noopener\"\u003eHMAC\u003c/a\u003e）都有 salt 的设定，但是就算知道了 salt 也很难恢复出原始数据，而 Hashids 的这个 salt 嘛……完全相反，所以它起到的更像是加密算法中密钥的作用。\u003c/p\u003e\u003cp\u003e实际上 Hashids 是使用进制转换的方式对数值进行编码的，将一般的数转换为十进制是固定使用数字 \u003ccode\u003e0-9\u003c/code\u003e，十六进制是数字 \u003ccode\u003e0-9a-f\u003c/code\u003e，而 Hashids 要转换到几进制和设置的字符表的长度有关，\u003cstrong\u003e对每个数的每一位使用的“数字”是根据输入数值和设置的 salt 按照一些规则打乱字符表得到的\u003c/strong\u003e，所以 Hashids 更像是一种多表代换密码，就像维吉尼亚密码那样，虽然每个字符都使用简单的凯撒密码加密，但是 offset 不同，于是攻击难度稍微提高了。\u003c/p\u003e\u003cp\u003e就算是在这里把 Hashids 当成加密算法，它的强度也不算太高，绝对不是密码学上安全的算法，所以\u003cstrong\u003e严禁将 Hashids 用于加密机密数据，更不要真的像使用 hash 算法一样把它用于保存密码。\u003c/strong\u003e按照\u003ca href=\"https://carnage.github.io/2015/08/cryptanalysis-of-hashids\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e的分析，在使用选择明文攻击、字符表等设置使用默认值但不知道 salt 的情况下，通过解一组方程分析 salt 的前三个字符有大概 200 种可能，这个数量已经大大低于暴力破解需要尝试的次数了。\u003c/p\u003e\u003cp\u003e为什么设计这个算法的人选用了 hash 和 salt 之类的名词？按照\u003ca href=\"https://hashids.org/#why-hashids\" target=\"_blank\" rel=\"noopener\"\u003e官网上的说明\u003c/a\u003e，因为对一般人来说，它看起来像 hash，走路像 hash，叫声像 hash，那么它就是……⊂彡☆))д`)\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eWhy “hashids”?\u003c/p\u003e\u003cp\u003eOriginally the project \u003cstrong\u003ereferred to generated ids as hashes, and obviously the name hashids has the word hash in it\u003c/strong\u003e. Technically, these generated ids cannot be called hashes since a cryptographic hash has one-way mapping (cannot be decrypted).\u003c/p\u003e\u003cp\u003eHowever, when people search for a solution, like a “youtube hash” or “bitly short id”, they usually \u003cstrong\u003edon’t really care of the technical details\u003c/strong\u003e. So hashids stuck as a term — an algorithm to obfuscate numbers.\u003c/p\u003e\u003c/blockquote\u003e\u003cfigure class=\"akarin-blurred-container\"\u003e\u003cdiv style=\"padding-bottom:min(calc(100%/664*493),493px,480px)\"\u003e\u003c/div\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded\" data-src=\"https://p.sda1.dev/12/2ba066d73298f9705dbaeb08ca4bcc89/mRAQGV5H.jpg\" data-src-avif=\"https://vfile.meituan.net/mmdb/d634d60ebe06feb4793ba06f3c7e91076047.jpg\" data-src-webp=\"https://p.sda1.dev/12/c7f2390a9afd1ddc0c3231deed88a5f9/XSpAU-lx.jpg\"/\u003e \u003cimg class=\"mdui-hoverable mdui-img-rounded akarin-blurred\" src=\"data:image/jpeg;base64,/9j/2wBDAAgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/2wBDAQgICAgJCAkKCgkNDgwODRMREBARExwUFhQWFBwrGx8bGx8bKyYuJSMlLiZENS8vNUROQj5CTl9VVV93cXecnNH/wAARCAAYACADASIAAhEBAxEB/8QAGgAAAgIDAAAAAAAAAAAAAAAAAAYBBQMEB//EACYQAAICAgEDAwUBAAAAAAAAAAECAxEEBQASIjEjQVEGFTJSgpH/xAAYAQACAwAAAAAAAAAAAAAAAAAEBQECA//EAB0RAAIDAAIDAAAAAAAAAAAAAAECAAMRBCExQVH/2gAMAwEAAhEDEQA/AO7EhQSSAB5J4n7fYbGTMxRr8lI4Im6pSRZkP618cv5gczPbDsiKGNZJj+xckKg/yzzSbGuaOCfWSh+0deNbwsSV9yBXk+fjhFDUIdsBJ+ehMbRawxMEmbeKsDNFjF5fZCwUH+uJSfXm2g2kWNm62BIndVI7romrDcbM/CWHFxZxBJC0lhopCCyn+SRxU22LBPjdUiW0bKyH3BvjCqjivWXVOjvmDPbcrhWMfZcyfC2eYItTlzCaSEFgvp0FrqBA4QbbMkPdpctPSLmwbFNVfjRJ4cOJ4fMmRsHmZsaTSZbJZp+k0aNDlTGBkbPAX7FmwouS4ZyOylU0XseDfDhywdwMDECQVUnSBP/Z\"/\u003e\u003cnoscript\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid\" src=\"https://p.sda1.dev/12/2ba066d73298f9705dbaeb08ca4bcc89/mRAQGV5H.jpg\" alt=\"undefined\" title=\"undefined\"\u003e\u003c/noscript\u003e\u003c/figure\u003e\u003chr/\u003e\u003cp\u003e从这里开始就是介绍 Hashids 的比较详细的实现细节了。在此之前我 Google 了一下介绍 Hashids 的文章，基本上都是简单介绍一下它的主要用途是混淆自增 ID，然后就是一大堆复制粘贴的用法示例了，偶尔有几篇提到了“进制转换”不过也并不是很详细……所以接下来我会参考 \u003ca href=\"https://github.com/niieani/hashids.js/blob/master/lib/hashids.ts\" target=\"_blank\" rel=\"noopener\"\u003eTypeScript/JavaScript 版实现的源码\u003c/a\u003e详细介绍一下编码和解码的原理（其它语言的实现应该也是类似的）。\u003c/p\u003e\u003cp\u003e如果只是想要简单了解 Hashids 原理的话，可以直接阅读\u003ca href=\"https://hashids.org/#how-does-it-work\" target=\"_blank\" rel=\"noopener\"\u003e官网上的介绍\u003c/a\u003e，简略介绍了进制转换等各种涉及到的步骤。想要了解更多细节的话就继续往下翻吧～\u003c/p\u003e\u003chr/\u003e\u003ch1 id=\"算法的初始化\"\u003e\u003ca href=\"#算法的初始化\" class=\"headerlink\" title=\"算法的初始化\"\u003e\u003c/a\u003e算法的初始化\u003c/h1\u003e\u003cp\u003e所有的编码和解码都是使用同一个 Hashids 对象的实例，在创建这个实例时进行算法的初始化，一般情况下需要输入以下参数：\u003c/p\u003e\u003cul\u003e\u003cli\u003esalt：一个可以包含任意字符的字符串，对之后打乱字符表的结果有影响。默认是留空。\u003c/li\u003e\u003cli\u003eminLength：最小长度，编码得到的字符串长度小于此值则会用一定方式填充。默认是留空。\u003c/li\u003e\u003cli\u003ealphabet：初始字符表，不能有重复字符，编码结果只可能含有这里的字符，即使字符相同顺序不同也会改变结果，长度至少为 16。默认是 \u003ccode\u003ea-zA-Z1234567890\u003c/code\u003e 一共 62 个字符。\u003c/li\u003e\u003cli\u003eseps：编码中用于分隔各个数值的字符（稍后说明 x2），必须是 alphabet 的子集，但是不要求字符不重复，顺序也会影响结果。默认是 \u003ccode\u003ecfhistuCFHISTU\u003c/code\u003e，原作者的想法是使用这些字母做分隔符可以\u003ca href=\"https://hashids.org/#cursing\" target=\"_blank\" rel=\"noopener\"\u003e避免编码结果中出现粗鄙之语\u003c/a\u003e。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cem\u003e实际上 JS 版实现会\u003ca href=\"https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L50\" target=\"_blank\" rel=\"noopener\"\u003e自动处理\u003c/a\u003e字符表去重、“不能重复”和“子集”之类的要求。\u003c/em\u003e\u003c/p\u003e\u003cp\u003e初始化以后就可以进行编码了。\u003c/p\u003e\u003cpre class=\"language-javascript line-numbers\" data-language=\"javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e hashids \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eHashids\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// salt\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e\u0026#39;@salt!\u0026#39;\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// minLength\u003c/span\u003e\n    \u003cspan class=\"token number\"\u003e24\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// alphabet: use default\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eundefined\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// seps\u003c/span\u003e\n    \u003cspan class=\"token string\"\u003e\u0026#39;SEPS\u0026#39;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\nconsole\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elog\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehashids\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eencode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e114514\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e1919810\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e893\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e931\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e// tY8p8oMWMb76xOS3Jh4uvs2x\u003c/span\u003e\nconsole\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elog\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehashids\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003edecode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e\u0026#39;tY8p8oMWMb76xOS3Jh4uvs2x\u0026#39;\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e// [114514, 1919810, 893, 931]\u003c/span\u003e\u003cspan class=\"line-numbers-rows\" aria-hidden=\"true\"\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e编码后的字符串，看上去是一堆没什么规律的字母数字，实际上可以分成几个部分。例如上面得到的字符串 \u003cspan style=\"color:#e77\"\u003etY8\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ep\u003c/span\u003e\u003cspan style=\"color:#f80\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003eoMWM\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eb\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e76xO\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eS\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e3J\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eh\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e4u\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ev\u003c/span\u003e\u003cspan style=\"color:#e77\"\u003es2x\u003c/span\u003e 就可以分为用不同颜色表示的以下部分：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cspan style=\"color:#9c6\"\u003e单个数值编码后的值\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color:#273\"\u003eseperator，也就是不同数值之间的分隔符\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color:#f80\"\u003elottery，用于在编码过程中打乱字符表\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color:#63b\"\u003eguard，用于分隔编码部分和填充部分\u003c/span\u003e\u003c/li\u003e\u003cli\u003e\u003cspan style=\"color:#e77\"\u003e编码后字符串左右两边的填充\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e前三个是实际的编码部分，后两个用于填充，只有设置了最小长度的情况下才有可能出现在编码结果中。\u003c/p\u003e\u003cp\u003eHashids 算法中经常需要打乱字符串中的字符，使用的都是下面这个\u003ca href=\"https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L302\" target=\"_blank\" rel=\"noopener\"\u003e稍有修改的 Fisher–Yates Shuffle 洗牌算法\u003c/a\u003e，除了要打乱的字符串（拆成了包含所有字符的数组）这里还有另一个参数也叫 salt（留空则直接原样返回不打乱），只要字符串和 salt 相同就可以保证打乱结果相同……所以这个 salt 起的明明是随机数生成器中种子的作用吧！(╯‵□′)╯︵┻━┻ \u003cstrong\u003e为了不与一开始输入的 salt 混淆，之后就用 seed 表示打乱时的这个 salt 参数好了。\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"language-javascript line-numbers\" data-language=\"javascript\"\u003e\u003ccode class=\"language-javascript\"\u003e\u003cspan class=\"token keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"token function\"\u003eshuffle\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token parameter\"\u003ealphabetChars\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e saltChars\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003esaltChars\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e===\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e alphabetChars\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e integer\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e transformed \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e alphabetChars\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eslice\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e v \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e p \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003elet\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e transformed\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i \u003cspan class=\"token operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e i\u003cspan class=\"token operator\"\u003e--\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"token comment\"\u003e// 在原始的Fisher-Yates Shuffled里，j是0-i范围的一个随机数\u003c/span\u003e\n        v \u003cspan class=\"token operator\"\u003e%=\u003c/span\u003e saltChars\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003elength\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        p \u003cspan class=\"token operator\"\u003e+=\u003c/span\u003e integer \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e saltChars\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ev\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecodePointAt\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e j \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003einteger \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e v \u003cspan class=\"token operator\"\u003e+\u003c/span\u003e p\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e%\u003c/span\u003e i\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n        v\u003cspan class=\"token operator\"\u003e++\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003etransformed\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e transformed\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ej\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003etransformed\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ej\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e transformed\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ei\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e transformed\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"line-numbers-rows\" aria-hidden=\"true\"\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003cspan\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在上面的例子里，一开始的时候输入了 \u003ccode\u003eSEPS\u003c/code\u003e 四个字符作为 seps，先从输入的字符表中去掉这几个字符（没有了 E、P、S 这三个大写字母，此时还剩下 \u003ccode\u003e62 - 3 = 59\u003c/code\u003e 个字符），然后以 salt 作为 seed 将 seps 打乱一次，打乱结果为 \u003ccode\u003eSSEP\u003c/code\u003e。但是上面的编码结果中还出现了这些字符之外的 seperator（b 和 h），这是因为 Hashids 要求 seps 的字符数量必须不少于字符表长度的 1/3.5（向上取整），所以这里需要 \u003ccode\u003eMath.ceil(59 / 3.5) = 17\u003c/code\u003e 个字符作为 seps，不足的 13 个字符从字符表的前几个字符中取出来，接到 seps 后面补充数量。\u003c/p\u003e\u003cp\u003e补充之后，最后的 seps 字符列表就是 \u003ccode\u003eSSEPabcdefghijklm\u003c/code\u003e（后面的 \u003ccode\u003ea-m\u003c/code\u003e 是从字符表中取出的），字符表是 \u003ccode\u003enopqrstuvwxyzABCDFGHIJKLMNOQRTUVWXYZ1234567890\u003c/code\u003e（前面的 \u003ccode\u003ea-m\u003c/code\u003e 被取走了，还有 \u003ccode\u003e59 - 13 - 46\u003c/code\u003e 个字符）。\u003c/p\u003e\u003cp\u003e如果设置了编码后字符串的最小长度的话，编码后可能会需要进行填充。Hashids 通过在实际的编码部分左右各放置一个 guard 字符的方式将编码部分和填充部分分开。guards 也是从字符表中取出的，并不能手动设置，字符数量是字符表长度的 1/12（向上取整）。在这里就需要取出 \u003ccode\u003eMath.ceil(46 / 12) = 4\u003c/code\u003e 个字符。\u003c/p\u003e\u003cp\u003e先以 salt 作为 seed 将当前的字符表打乱一次，字符表变成了 \u003ccode\u003evpnz0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3\u003c/code\u003e，然后取出字符表的前 4 个字符 \u003ccode\u003evpnz\u003c/code\u003e 作为 guards，字符表中剩下 \u003ccode\u003e0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3\u003c/code\u003e 一共 42 个字符，这些字符会出现在编码结果的除 seperator 和 guard 以外的所有部分中。\u003c/p\u003e\u003cp\u003e最后用一个流程图来概括以上的初始化过程：\u003c/p\u003e\u003cfigure class=\"akarin-blurred-container\"\u003e\u003cdiv style=\"padding-bottom:min(calc(100%/961*301),301px,480px)\"\u003e\u003c/div\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded\" data-src=\"https://svgshare.com/i/aFA.svg\"/\u003e \u003cimg class=\"mdui-hoverable mdui-img-rounded akarin-blurred\" src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAKBAMAAAAnY0GXAAAAMFBMVEX////6+fj1+Pi04PUdouP0ttfK4rHJ6fibyWx3xuxtsCrj8NZAsefZBXbnYqngM48tZA+eAAAAA3RSTlP//vftCFu/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVR42mNQYEACTIJCDALIAowZSWgCHUoMioJAISaoMCMDE4PqfQETZyCb04XBxJ2xK4lBNUhA2QgowG7MoGzEmMbEoBAKErApAAoAtWzbxKB6D6iF2eUQUAtQYNUmiKEMmhBTGYHuUIAaD3MaAF2qD29a1slhAAAAAElFTkSuQmCC\"/\u003e\u003cnoscript\u003e\u003cimg class=\"mdui-hoverable mdui-img-rounded mdui-center mdui-img-fluid\" src=\"https://svgshare.com/i/aFA.svg\" alt=\"undefined\" title=\"undefined\"\u003e\u003c/noscript\u003e\u003c/figure\u003e\u003ch1 id=\"对输入的数进行编码\"\u003e\u003ca href=\"#对输入的数进行编码\" class=\"headerlink\" title=\"对输入的数进行编码\"\u003e\u003c/a\u003e对输入的数进行编码\u003c/h1\u003e\u003cp\u003e初始化以后就可以将输入的整数编码了，编码期间使用的字符表 alphabet 是从初始化后的 Hashids 对象里复制的，虽然会涉及多次打乱字符表的操作但是并不会改变原对象的字符表，解码的时候也是一样的。\u003c/p\u003e\u003cp\u003e可能是为了添加更多的随机性，Hashids 算法在编码过程中设置了一个称为 lottery 的字符。对于每个输入的第 a 个数 b（a 是从 0 开始计数的），计算 \u003ccode\u003eb % (100 + a)\u003c/code\u003e 的和（记为 numbersIdInt，后面还会用到），则 \u003ccode\u003ealphabet[numbersIdInt % alphabet.length]\u003c/code\u003e 就是 lottery 字符。\u003c/p\u003e\u003cp\u003e在上面的例子中，初始化以后的 alphabet 是 \u003ccode\u003e0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3\u003c/code\u003e，对 \u003ccode\u003e[114514, 1919810, 893, 931]\u003c/code\u003e 编码得到的 lottery 是 8 也就是 \u003ccode\u003ealphabet[13]\u003c/code\u003e，是根据以下过程算出的：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e114514 % 100 = 14\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003e1919810 % 101 = 2\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003e893 % 102 = 77\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003e931 % 103 = 4\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003enumbersIdInt = 14 + 2 + 77 + 4 = 97\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003elotteryIndex = 97 % 42 = 13\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e然后就是对每个数编码了。前面提过 Hashids 的编码原理是进制转换，现在 alphabet 有 42 个字符，相当于将各个数转换为 42 进制。Hashids 又有多表代换的特征，表现在编码每个数之前 alphabet 都会使用 \u003ccode\u003elottery + salt + alphabet\u003c/code\u003e 作为 seed 被打乱一次（取代之前的 alphabet），于是每个数在进制转换时使用的“数字”都是不一样的。\u003c/p\u003e\u003cp\u003e如果编码的不是最后一个数，编码后还要添加一个 seperator，计算方法是：对于第 a 个数 b，编码后的第一个字符的 Unicode 码点是 c，则需要添加的 seperator 是 \u003ccode\u003eseps[a % (b + c) % seps.length]\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e例如，上面的例子中编码的过程：\u003c/p\u003e\u003cul\u003e\u003cli\u003e使用 seed \u003ccode\u003e8@salt!0xJYw6Q1TLNqH8WGuRB5ZMKOAroCFtD74IU2ysX9V3\u003c/code\u003e 打乱字符表得到 \u003ccode\u003e8ouNLs4OK5V9wA613QqG7XMYZ0JRTFy2BCHItUWxrD\u003c/code\u003e\u003c/li\u003e\u003cli\u003e进制转换的结果是 \u003ccode\u003e114514 = 1 * 42 ** 3 + 22 * 42 ** 2 + 38 * 42 ** 1 + 22 * 40 ** 0\u003c/code\u003e\u003c/li\u003e\u003cli\u003e转换后的各位数 \u003ccode\u003e1 22 38 22\u003c/code\u003e 在字符表中对应的字符分别是 oMWM\u003c/li\u003e\u003cli\u003e\u003ccode\u003e\u0026#34;o\u0026#34; = String.fromCodePoint(111)\u003c/code\u003e，所以添加 seperator：\u003ccode\u003eseps[114514 % (0 + 111) % 17] = seps[73 % 17] = seps[5]\u003c/code\u003e 也就是 b\u003c/li\u003e\u003cli\u003e使用 seed \u003ccode\u003e8@salt!8ouNLs4OK5V9wA613QqG7XMYZ0JRTFy2BCHItUWxrD\u003c/code\u003e 打乱字符表得到 \u003ccode\u003eDWsUJ81NVrXqAxtYZ9wuIBG547K2RML3OQTCFH6o0y\u003c/code\u003e\u003c/li\u003e\u003cli\u003e进制转换的结果是 \u003ccode\u003e1919810 = 25 * 42 ** 3 + 38 * 42 ** 2 + 13 * 42 ** 1 + 32 * 42 ** 0\u003c/code\u003e\u003c/li\u003e\u003cli\u003e转换后的各位数 \u003ccode\u003e25 38 13 32\u003c/code\u003e 在字符表中对应的字符分别是 76xO\u003c/li\u003e\u003cli\u003e\u003ccode\u003e\u0026#34;7\u0026#34; = String.fromCodePoint(55)\u003c/code\u003e，所以添加 seperator：\u003ccode\u003eseps[1919810 % (1 + 55) % 17] = seps[18 % 17] = seps[1]\u003c/code\u003e 也就是 S\u003c/li\u003e\u003cli\u003e……\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e最后可以得到未填充的编码部分 \u003cspan style=\"color:#f80\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003eoMWM\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eb\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e76xO\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eS\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e3J\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eh\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e4u\u003c/span\u003e。\u003c/p\u003e\u003ch1 id=\"编码结果的填充\"\u003e\u003ca href=\"#编码结果的填充\" class=\"headerlink\" title=\"编码结果的填充\"\u003e\u003c/a\u003e编码结果的填充\u003c/h1\u003e\u003cp\u003e如果设置了最小长度，而刚刚得到的编码结果长度又不足，那么就需要进行填充了。Hashids 使用放在编码部分左右两边各一个的 guard 字符将编码和填充部分分开，这两个字符均使用 \u003ccode\u003eguards[(numbersIdInt + x) % guards.length]\u003c/code\u003e 求出，对于左边/右边的 guard，x 分别是编码部分第 0/1 个字符的 Unicode 码点。先添加左边的 guard，如果已经满足最小长度则不再添加右边的 guard。在上面的例子中：\u003c/p\u003e\u003cul\u003e\u003cli\u003eguards 是 vpnz\u003c/li\u003e\u003cli\u003e编码部分长度 16，前两个字符的 Unicode 码点：\u003ccode\u003e\u0026#34;8\u0026#34; = String.fromCodePoint(56)\u003c/code\u003e 和 \u003ccode\u003e\u0026#34;o\u0026#34; = String.fromCodePoint(111)\u003c/code\u003e\u003c/li\u003e\u003cli\u003e设置了最小长度为 24，编码结果的长度不足，因此在左边添加 \u003ccode\u003eguards[(97 + 56) % 4] = guards[1]\u003c/code\u003e 也就是 p\u003c/li\u003e\u003cli\u003e长度仍然不足，因此在右边添加 \u003ccode\u003eguards[(97 + 111) % 4] = guards[0]\u003c/code\u003e 也就是 v\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e如果添加 guard 之后长度还是不足呢？接下来就会在编码结果的左右两边填充数遍完整的字符表了。\u003c/p\u003e\u003cul\u003e\u003cli\u003e以 alphabet 自己作为 seed 打乱 alphabet（同样是取代之前的 alphabet）\u003c/li\u003e\u003cli\u003e将 alphabet 一分为二，前 \u003ccode\u003eMath.floor(alphabet.length / 2)\u003c/code\u003e 个字符添加到编码结果右边，剩下的字符添加到编码结果左边\u003c/li\u003e\u003cli\u003e循环到编码结果的长度超过最小长度为止\u003c/li\u003e\u003cli\u003e取编码结果 result 的从第 \u003ccode\u003eMath.floor((result.length - minLength) / 2)\u003c/code\u003e 个字符开始的 minLength 个字符作为最后的编码结果\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在上面的例子中，添加了 guard 的编码结果是 \u003cspan style=\"color:#63b\"\u003ep\u003c/span\u003e\u003cspan style=\"color:#f80\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003eoMWM\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eb\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e76xO\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eS\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e3J\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eh\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e4u\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ev\u003c/span\u003e，打乱一次 alphabet 的结果是 s2xC0oRZAQuLqyK6GwXUHNTB7rV4IOD51MF9WJ3tY8，添加到编码结果的左右两边得到 \u003cspan style=\"color:#e77\"\u003eNTB7rV4IOD51MF9WJ3tY8\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ep\u003c/span\u003e\u003cspan style=\"color:#f80\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003eoMWM\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eb\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e76xO\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eS\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e3J\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eh\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e4u\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ev\u003c/span\u003e\u003cspan style=\"color:#e77\"\u003es2xC0oRZAQuLqyK6GwXUH\u003c/span\u003e，长度为 60，于是截取从第 \u003ccode\u003eMath.floor((60 - 24) / 2) = 18\u003c/code\u003e 个字符开始的 24 个字符，得到最后的编码结果 \u003cspan style=\"color:#e77\"\u003etY8\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ep\u003c/span\u003e\u003cspan style=\"color:#f80\"\u003e8\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003eoMWM\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eb\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e76xO\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eS\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e3J\u003c/span\u003e\u003cspan style=\"color:#273\"\u003eh\u003c/span\u003e\u003cspan style=\"color:#9c6\"\u003e4u\u003c/span\u003e\u003cspan style=\"color:#63b\"\u003ev\u003c/span\u003e\u003cspan style=\"color:#e77\"\u003es2x\u003c/span\u003e。\u003c/p\u003e\u003ch1 id=\"解码和校验\"\u003e\u003ca href=\"#解码和校验\" class=\"headerlink\" title=\"解码和校验\"\u003e\u003c/a\u003e解码和校验\u003c/h1\u003e\u003cp\u003e对 Hashids 的解码实际上是把字符串中表示每个数的字符串恢复回原来的数，因为 seps 和 guards 是固定的，lottery 又固定是 guard 之间的未填充的编码部分的第一个字符，所以很容易就可以把每个数的字符串从编码后的字符串里拆出来。按照同样的顺序，每解码一个数之前，先使用 \u003ccode\u003elottery + salt + alphabet\u003c/code\u003e 打乱一次字符表，对照字符表得出这个数在 x 进制下的表示，再转换到十进制就可以完成解码了。\u003c/p\u003e\u003cp\u003e既然这样，那剩下的 seperator 和 guard 还有填充部分随便乱写，也是可以解码出结果的哦？\u003c/p\u003e\u003cp\u003e当然不能出这种问题啦！所以 Hashids 的\u003ca href=\"https://github.com/niieani/hashids.js/blob/f8a2d2f6bbd4ecbe0ec1b0a2aa04a6cbc7048098/lib/hashids.ts#L275\" target=\"_blank\" rel=\"noopener\"\u003e处理方法\u003c/a\u003e是……\u003cstrong\u003e把解码出的数重新编码一遍，如果和输入的字符串不同则按照解码结果无效处理，什么也不返回\u003c/strong\u003e。\u003c/p\u003e\u003cp\u003e看来这些部分还起到了校验码的作用呢。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e封面图：\u003ca href=\"https://www.pixiv.net/artworks/43737030\" target=\"_blank\" rel=\"noopener\"\u003ePixiv ID: 43737030 「Cafe de Lapin」 by Koi\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cblockquote class=\"mdui-m-b-0 mdui-m-x-0 mdui-p-y-1\" style=\"border-left:4px solid rgba(0,0,0,.36)\"\u003e\u003cstrong\u003e本作品采用\u003ca href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\" target=\"_blank\"\u003e知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议\u003c/a\u003e进行许可。不允许内容农场类网站、CSDN 用户和微信公众号转载。\u003c/strong\u003e\u003cbr/\u003e\u003cstrong\u003e本文作者：✨小透明・宸✨\u003c/strong\u003e\u003cbr/\u003e\u003cstrong\u003e本文链接：\u003ca href=\"https://akarin.dev/2021/02/26/hashids-description/\"\u003ehttps://akarin.dev/2021/02/26/hashids-description/\u003c/a\u003e\u003c/strong\u003e\u003c/blockquote\u003e\u003c/article\u003e",
  "Date": "2021-02-26T08:22:56Z",
  "Author": "✨小透明・宸✨"
}