{
  "Source": "antonz.org",
  "Title": "Trying Odin (with a playground)",
  "Link": "https://antonz.org/trying-odin/",
  "Content": "\u003carticle class=\"post\"\u003e\u003cdiv class=\"row\"\u003e\u003cdiv class=\"col-xs-12 col-md-10 article\"\u003e\u003cheader\u003e\u003ch1\u003eTrying Odin (with a playground)\u003c/h1\u003e\u003c/header\u003e\u003cp\u003eIn my recent search for a \u0026#34;better C\u0026#34; alternative, I\u0026#39;ve looked at C++, D, Rust, Nim, Hare, Odin, and Zig. At first glance, Odin and Zig seem to be exactly what I\u0026#39;m looking for. C++, D, Rust and Nim are bloated with features, while Hare is too bare-bones even for me.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eWhy do I need a better C when I have Go, you may ask. Well, Go is great at everything except C interop (which I sometimes need). It also has GC (which I sometimes don\u0026#39;t need).\u003c/p\u003e\u003cp\u003eI think of Go as \u0026#34;better Java\u0026#34;. It\u0026#39;d be nice to have better C, too.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eI\u0026#39;ll leave Zig for later and explore Odin for now.\u003c/p\u003e\u003cp\u003eOdin has a unique set of characteristics:\u003c/p\u003e\u003cul\u003e\u003cli\u003eSimple language design without bells and whistles.\u003c/li\u003e\u003cli\u003eManual memory management with custom allocators.\u003c/li\u003e\u003cli\u003eWell-thought standard library.\u003c/li\u003e\u003cli\u003eConcise and calm syntax.\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"some-examples\"\u003eSome examples\u003c/h2\u003e\u003cp\u003eA classic \u0026#34;hello world\u0026#34;:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003epackage main\n\nimport \u0026#34;core:fmt\u0026#34;\n\nmain :: proc() {\n    fmt.println(\u0026#34;Hellope!\u0026#34;)\n    // Hellope!\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003e\u003cstrong\u003eDynamic arrays\u003c/strong\u003e and sorting:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;core:fmt\u0026#34;\nimport \u0026#34;core:slice\u0026#34;\n\nmain :: proc() {\n    list := [dynamic]int{11, 7, 42}\n    defer delete(list)\n\n    append(\u0026amp;list, 2, 54)\n    slice.sort(list[:])\n\n    fmt.println(list)\n    // [2, 7, 11, 42, 54]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003e\u003cstrong\u003eMemory management\u003c/strong\u003e in Odin is manual, so allocated memory must be explicitly freed. There are two built-in allocators (a heap allocator and a growing arena based allocator), but the language supports custom allocators:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003e// tracking allocator for debugging\ntrack: mem.Tracking_Allocator\nmem.tracking_allocator_init(\u0026amp;track, context.allocator)\n\n// context is an implicit variable\n// available in every scope\ncontext.allocator = mem.tracking_allocator(\u0026amp;track)\n\n// we can use a custom allocator at any level,\n// even at individual statements\nlist := make([]int, 6, context.allocator)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eStructs\u003c/strong\u003e, procedures and iteration (I\u0026#39;ll skip the \u0026#34;package\u0026#34; stuff from now on):\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode\u003ePerson :: struct {\n    name: string,\n    age: int,\n}\n\nperson_to_str :: proc(p: Person) -\u0026gt; string {\n    return fmt.tprintf(\u0026#34;%v - %v\u0026#34;, p.name, p.age)\n}\n\npeople := []Person{\n    Person{\u0026#34;Alice\u0026#34;, 25},\n    Person{\u0026#34;Bob\u0026#34;, 24},\n    Person{\u0026#34;Cindy\u0026#34;, 26},\n}\n\nfor p, idx in people {\n    fmt.println(idx, person_to_str(p))\n}\n// 0 Alice - 25\n// 1 Bob - 24\n// 2 Cindy - 26\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\" template=\"main.odin\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003eThere are no functions or struct methods, only procedures.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePointers\u003c/strong\u003e are declared with a leading caret, and dereferenced with a trailing caret:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003eval := \u0026#34;Hellope!\u0026#34;\n\nptr: ^string\nptr = \u0026amp;val\n\nfmt.println(ptr^)\n// Hellope!\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\" template=\"main.odin\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003eA bit unusual, but logical.\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eErrors\u003c/strong\u003e are just values:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003eError :: enum {\n    None,\n    Insufficient_Funds,\n}\n\nwithdraw :: proc(balance, amount: int) -\u0026gt; (int, Error) {\n    if amount \u0026gt; balance {\n        return balance, .Insufficient_Funds\n    }\n    return balance - amount, .None\n}\n\nbalance, err := withdraw(42, 1000)\nif err != nil {\n    fmt.println(err)\n}\n// Insufficient_Funds\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\" template=\"main.odin\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003eThere is also a shortcut for the dreaded \u003ccode\u003eif err != nil return\u003c/code\u003e:\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003ebalance := withdraw(42, 1000) or_return\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eGenerics\u003c/strong\u003e (aka parametric polymorphism):\u003c/p\u003e\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-odin\" data-lang=\"odin\"\u003ePair :: struct($T: typeid) {\n    first: T,\n    second: T\n}\n\npair_to_str :: proc(p: $T/Pair) -\u0026gt; string {\n    return fmt.tprintf(\u0026#34;%v-%v\u0026#34;, p.first, p.second)\n}\n\np1 := Pair(int){1, 2}\np2 := Pair(string){\u0026#34;one\u0026#34;, \u0026#34;two\u0026#34;}\n\nfmt.println(pair_to_str(p1))\n// 1-2\n\nfmt.println(pair_to_str(p2))\n// one-two\n\u003c/code\u003e\u003c/pre\u003e\u003ccodapi-snippet sandbox=\"odin\" editor=\"basic\" template=\"main.odin\"\u003e\u003c/codapi-snippet\u003e\u003cp\u003eHere \u003ccode\u003epair_to_str\u003c/code\u003e only allows types that are specializations of the \u003ccode\u003ePair\u003c/code\u003e type.\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://odin-lang.org/docs/overview/\"\u003eLanguage overview\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"trying-odin\"\u003eTrying Odin\u003c/h2\u003e\u003cp\u003eThe easiest way to get a taste of Odin is the \u003ca href=\"https://codapi.org/odin/\"\u003eplayground\u003c/a\u003e I made (it powers the examples in this article).\u003c/p\u003e\u003cp\u003eIf you prefer local setup, the \u003ca href=\"https://odin-lang.org/\"\u003eofficial site\u003c/a\u003e has a decent \u0026#34;Getting Started\u0026#34; guide. There are binaries for Windows, Linux and macOS, but unfortunately only for amd64 (x86_64).\u003c/p\u003e\u003cp\u003eIf you have an arm64 Mac, you can use a \u003ca href=\"https://gist.github.com/nalgeon/b856a1cdcbc315a2f8f5c941f933d315\"\u003eDocker image\u003c/a\u003e (courtesy of \u003ca href=\"https://github.com/yeongjukang/docker-odin\"\u003eYeongju Kang\u003c/a\u003e with minor modifications by me).\u003c/p\u003e\u003ch2 id=\"specialization\"\u003eSpecialization\u003c/h2\u003e\u003cp\u003eAlthough Odin is a general-purpose language, it leans slightly towards game and visual effects programming. This is probably due to the fact that the language creator (\u003ca href=\"https://www.gingerbill.org/\"\u003eGinger Bill\u003c/a\u003e) is a physicist working in a visual effects company.\u003c/p\u003e\u003cp\u003eOdin supports a native \u003ccode\u003ematrix\u003c/code\u003e type and matrix operations, and has various SIMD/SIMT-related programming features (of which I don\u0026#39;t know anything about, so better consult the doc for those).\u003c/p\u003e\u003cp\u003eAs far as I can tell, a significant number of programmers using Odin are game developers.\u003c/p\u003e\u003ch2 id=\"current-status\"\u003eCurrent status\u003c/h2\u003e\u003cp\u003eOdin is pre-1.0. Sadly, it does not even have a 1.0 roadmap. It also seems to be less popular than Zig or Nim, probably on par with Hare.\u003c/p\u003e\u003cp\u003eHowever, Odin is actively used in production by the company it\u0026#39;s creator works for.\u003c/p\u003e\u003cp\u003eSo I hope it has a bright future!\u003c/p\u003e\u003cp\u003e──\u003c/p\u003e\u003cp\u003e\u003cmark\u003eInteractive examples in this post\u003c/mark\u003e are powered by \u003ca href=\"https://codapi.org/\"\u003e\u003cstrong\u003ecodapi\u003c/strong\u003e\u003c/a\u003e — an open source tool I\u0026#39;m building. Use it to embed live code snippets into your product docs, online course or blog.\u003c/p\u003e\u003cscript defer=\"\" src=\"/modules/codapi/snippet.js\"\u003e\u003c/script\u003e\u003cp\u003e\u003cem\u003e\u003ca href=\"/subscribe/\"\u003e\u003ci class=\"fas fa-star\"\u003e\u003c/i\u003e \u003cstrong\u003eSubscribe\u003c/strong\u003e\u003c/a\u003e\nto keep up with new posts.\u003c/em\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e\u003cfooter class=\"post__footer\"\u003e\u003cdiv class=\"row\"\u003e\u003cdiv class=\"col-xs-12\"\u003e\u003cdiv class=\"post__date\"\u003e\u003ctime datetime=\"2023-07-31 09:30:00 +0000 UTC\"\u003e31 Jul, 2023\u003c/time\u003e\u003c/div\u003e\u003cdiv class=\"post__tags\"\u003e\u003ca href=\"/tags/software/\"\u003esoftware\u003c/a\u003e \u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003c/footer\u003e\u003c/article\u003e",
  "Date": "2023-07-31T09:30:00Z",
  "Author": "Anton Zhiyanov"
}