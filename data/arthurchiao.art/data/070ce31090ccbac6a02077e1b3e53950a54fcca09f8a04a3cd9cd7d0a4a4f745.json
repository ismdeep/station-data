{
  "Source": "arthurchiao.art",
  "Title": "[译] 大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）",
  "Link": "https://arthurchiao.art/blog/ebpf-and-k8s-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2020-09-06 | Last Update 2021-02-21\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2020 年 Daniel Borkmann 在 KubeCon 的一篇分享:\n\u003ca href=\"https://kccnceu20.sched.com/event/ZemQ/ebpf-and-kubernetes-little-helper-minions-for-scaling-microservices-daniel-borkmann-cilium\"\u003eeBPF and Kubernetes: Little Helper Minions for Scaling Microservices\u003c/a\u003e，\n视频见\u003ca href=\"https://www.youtube.com/watch?v=99jUcLt3rSk\"\u003e油管\u003c/a\u003e。\n翻译已获得 Daniel 授权。\u003c/p\u003e\n\n\u003cp\u003eDaniel 是 eBPF 两位 maintainer 之一，目前在 eBPF commits\n榜单上排名第一，也是 Cilium 的核心开发者之一。\u003c/p\u003e\n\n\u003cp\u003e本文内容的时间跨度有 8 年，覆盖了 eBPF 发展的整个历史，非常值得一读。时间限制，\nDaniel 很多地方只是点到，没有展开。译文中加了一些延展阅读，有需要的同学可以参考。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-ebpf-正在吞噬世界\" id=\"markdown-toc-1-ebpf-正在吞噬世界\"\u003e1 eBPF 正在吞噬世界\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-kubernetes-已经是云操作系统\" id=\"markdown-toc-11-kubernetes-已经是云操作系统\"\u003e1.1 Kubernetes 已经是云操作系统\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-两个清晰的容器技术趋势\" id=\"markdown-toc-12-两个清晰的容器技术趋势\"\u003e1.2 两个清晰的容器技术趋势\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-内核面临的挑战\" id=\"markdown-toc-2-内核面临的挑战\"\u003e2 内核面临的挑战\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-复杂度性不断增长性能和可扩展性新需求\" id=\"markdown-toc-21-复杂度性不断增长性能和可扩展性新需求\"\u003e2.1 复杂度性不断增长，性能和可扩展性新需求\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-永远保持后向兼容\" id=\"markdown-toc-22-永远保持后向兼容\"\u003e2.2 永远保持后向兼容\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-feature-creeping-normality\" id=\"markdown-toc-23-feature-creeping-normality\"\u003e2.3 Feature creeping normality\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-ebpf-降世重新定义数据平面datapth\" id=\"markdown-toc-3-ebpf-降世重新定义数据平面datapth\"\u003e3 eBPF 降世：重新定义数据平面（datapth）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-ebpf-长什么样怎么用cilium-ebpf-networking-案例研究\" id=\"markdown-toc-4-ebpf-长什么样怎么用cilium-ebpf-networking-案例研究\"\u003e4 eBPF 长什么样，怎么用？Cilium eBPF networking 案例研究\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-cilium-ebpf-流程\" id=\"markdown-toc-41-cilium-ebpf-流程\"\u003e4.1 Cilium eBPF 流程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-ebpf-特点\" id=\"markdown-toc-42-ebpf-特点\"\u003e4.2 eBPF 特点\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-温故kube-proxy-包转发路径\" id=\"markdown-toc-5-温故kube-proxy-包转发路径\"\u003e5 温故：kube-proxy 包转发路径\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-知新cilium-ebpf-包转发路径\" id=\"markdown-toc-6-知新cilium-ebpf-包转发路径\"\u003e6 知新：Cilium eBPF 包转发路径\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-ebpf-年鉴\" id=\"markdown-toc-7-ebpf-年鉴\"\u003e7 eBPF 年鉴\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#2013\" id=\"markdown-toc-2013\"\u003e2013\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#前浪工具和子系统\" id=\"markdown-toc-前浪工具和子系统\"\u003e前浪工具和子系统\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-与前浪的区别\" id=\"markdown-toc-ebpf-与前浪的区别\"\u003eeBPF 与前浪的区别\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf第一个巨型patch\" id=\"markdown-toc-ebpf第一个巨型patch\"\u003eeBPF：第一个（巨型）patch\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2014\" id=\"markdown-toc-2014\"\u003e2014\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#第一个-ebpf-patch-合并到内核\" id=\"markdown-toc-第一个-ebpf-patch-合并到内核\"\u003e第一个 eBPF patch 合并到内核\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#kubernetes-提交第一个-commit\" id=\"markdown-toc-kubernetes-提交第一个-commit\"\u003eKubernetes 提交第一个 commit\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2015\" id=\"markdown-toc-2015\"\u003e2015\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-分成两个方向networking--tracing\" id=\"markdown-toc-ebpf-分成两个方向networking--tracing\"\u003eeBPF 分成两个方向：networking \u0026amp; tracing\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-backend-合并到-llvm-37\" id=\"markdown-toc-ebpf-backend-合并到-llvm-37\"\u003eeBPF backend 合并到 LLVM 3.7\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#支持将-ebpf-attach-到-kprobes\" id=\"markdown-toc-支持将-ebpf-attach-到-kprobes\"\u003e支持将 eBPF attach 到 kprobes\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#通过-cls_bpftc-变得完全可编程\" id=\"markdown-toc-通过-cls_bpftc-变得完全可编程\"\u003e通过 cls_bpf，tc 变得完全可编程\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#为-tc-添加了一个-lockless-ingress--egress-hook-点\" id=\"markdown-toc-为-tc-添加了一个-lockless-ingress--egress-hook-点\"\u003e为 tc 添加了一个 lockless ingress \u0026amp; egress hook 点\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#添加了很多-verifer-和-ebpf-辅助代码helper\" id=\"markdown-toc-添加了很多-verifer-和-ebpf-辅助代码helper\"\u003e添加了很多 verifer 和 eBPF 辅助代码（helper）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bcc-项目发布\" id=\"markdown-toc-bcc-项目发布\"\u003ebcc 项目发布\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2016\" id=\"markdown-toc-2016\"\u003e2016\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-添加了一个新-fast-pathxdp\" id=\"markdown-toc-ebpf-添加了一个新-fast-pathxdp\"\u003eeBPF 添加了一个新 fast path：XDP\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#cilium-项目发布\" id=\"markdown-toc-cilium-项目发布\"\u003eCilium 项目发布\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2017\" id=\"markdown-toc-2017\"\u003e2017\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-开始大规模应用于生产环境\" id=\"markdown-toc-ebpf-开始大规模应用于生产环境\"\u003eeBPF 开始大规模应用于生产环境\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2017--2018\" id=\"markdown-toc-2017--2018\"\u003e2017 ~ 2018\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-成为内核独立子系统\" id=\"markdown-toc-ebpf-成为内核独立子系统\"\u003eeBPF 成为内核独立子系统\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ktls--ebpf\" id=\"markdown-toc-ktls--ebpf\"\u003ekTLS \u0026amp; eBPF\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpftool--libbpf\" id=\"markdown-toc-bpftool--libbpf\"\u003ebpftool \u0026amp; libbpf\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-to-bpf-function-calls\" id=\"markdown-toc-bpf-to-bpf-function-calls\"\u003eBPF to BPF function calls\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2018\" id=\"markdown-toc-2018\"\u003e2018\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#cilium-10-发布\" id=\"markdown-toc-cilium-10-发布\"\u003eCilium 1.0 发布\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#btfbyte-type-format\" id=\"markdown-toc-btfbyte-type-format\"\u003eBTF（Byte Type Format）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#linux-plumbers-会议开辟-bpfxdp-主题\" id=\"markdown-toc-linux-plumbers-会议开辟-bpfxdp-主题\"\u003eLinux Plumbers 会议开辟 BPF/XDP 主题\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#新-socket-类型af_xdp\" id=\"markdown-toc-新-socket-类型af_xdp\"\u003e新 socket 类型：AF_XDP\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpffilter\" id=\"markdown-toc-bpffilter\"\u003ebpffilter\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2018--2019\" id=\"markdown-toc-2018--2019\"\u003e2018 ~ 2019\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#bpftrace\" id=\"markdown-toc-bpftrace\"\u003ebpftrace\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-专著bpf-performance-tools\" id=\"markdown-toc-bpf-专著bpf-performance-tools\"\u003eBPF 专著《BPF Performance Tools》\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#cilium-16-发布\" id=\"markdown-toc-cilium-16-发布\"\u003eCilium 1.6 发布\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-live-patching\" id=\"markdown-toc-bpf-live-patching\"\u003eBPF live-patching\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#第一次-bpfconf受邀请才能参加的-bpf-内核专家会议\" id=\"markdown-toc-第一次-bpfconf受邀请才能参加的-bpf-内核专家会议\"\u003e第一次 bpfconf：受邀请才能参加的 BPF 内核专家会议\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-backend-合并到-gcc\" id=\"markdown-toc-bpf-backend-合并到-gcc\"\u003eBPF backend 合并到 GCC\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#2019--2020\" id=\"markdown-toc-2019--2020\"\u003e2019 ~ 2020\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#不知疲倦的增长和-ebpf-的第三个方向linux-security-modules\" id=\"markdown-toc-不知疲倦的增长和-ebpf-的第三个方向linux-security-modules\"\u003e不知疲倦的增长和 eBPF 的第三个方向：Linux security modules\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-ebpf过去-50-年操作系统最大的变革\" id=\"markdown-toc-8-ebpf过去-50-年操作系统最大的变革\"\u003e8 eBPF：过去 50 年操作系统最大的变革\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-ebpf-数字榜单截至-202007\" id=\"markdown-toc-9-ebpf-数字榜单截至-202007\"\u003e9 eBPF 数字榜单（截至 2020.07）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-业界趋势\" id=\"markdown-toc-10-业界趋势\"\u003e10 业界趋势\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#11-ebpf-革命燃烧到-kubernetes-社区\" id=\"markdown-toc-11-ebpf-革命燃烧到-kubernetes-社区\"\u003e11 eBPF 革命：燃烧到 Kubernetes 社区\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#111-干掉-kube-proxyiptables\" id=\"markdown-toc-111-干掉-kube-proxyiptables\"\u003e11.1 干掉 kube-proxy/iptables\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#112-cilium-的-service-load-balancing-设计\" id=\"markdown-toc-112-cilium-的-service-load-balancing-设计\"\u003e11.2 Cilium 的 Service load balancing 设计\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#东西向流量\" id=\"markdown-toc-东西向流量\"\u003e东西向流量\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#南北向流量\" id=\"markdown-toc-南北向流量\"\u003e南北向流量\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#113-xdpebpf-vs-kube-proxy-性能对比\" id=\"markdown-toc-113-xdpebpf-vs-kube-proxy-性能对比\"\u003e11.3 XDP/eBPF vs kube-proxy 性能对比\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#网络吞吐\" id=\"markdown-toc-网络吞吐\"\u003e网络吞吐\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#cpu-利用率\" id=\"markdown-toc-cpu-利用率\"\u003eCPU 利用率\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#12-ebpf-和-kubernetes未来展望\" id=\"markdown-toc-12-ebpf-和-kubernetes未来展望\"\u003e12 eBPF 和 Kubernetes：未来展望\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#13-结束语\" id=\"markdown-toc-13-结束语\"\u003e13 结束语\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-ebpf-正在吞噬世界\"\u003e1 eBPF 正在吞噬世界\u003c/h1\u003e\n\n\u003ch2 id=\"11-kubernetes-已经是云操作系统\"\u003e1.1 Kubernetes 已经是云操作系统\u003c/h2\u003e\n\n\u003cp\u003eKubernetes 正在吞噬世界（eating the world）。越来越多的企业开始迁移到容器平台上\n，而 Kubernetes 已经是公认的云操作系统（Cloud OS）。从技术层面来说，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eLinux 内核是一切的坚实基础，例如，内核提供了 cgroup、namespace 等特性。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eKubernetes CNI 插件串联起了关键路径（critical path）上的组件。例如，从网络的\n视角看，包括，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e广义的 Pod 连通性：一个容器创建之后，CNI 插件会给它创建网络设备，移动到容\n器的网络命名空间。\u003c/li\u003e\n      \u003cli\u003eIPAM：CNI 向 IPAM 发送请求，为容器分配 IP 地址，然后配置路由。\u003c/li\u003e\n      \u003cli\u003eKubernetes 的 Service 处理和负载均衡功能。\u003c/li\u003e\n      \u003cli\u003e网络策略的生效（network policy enforcement）。\u003c/li\u003e\n      \u003cli\u003e监控和排障。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"12-两个清晰的容器技术趋势\"\u003e1.2 两个清晰的容器技术趋势\u003c/h2\u003e\n\n\u003cp\u003e今天我们能清晰地看到两个技术发展趋势：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e容器的\u003cstrong\u003e部署密度\u003c/strong\u003e越来越高（increasing Pod density）。\u003c/li\u003e\n  \u003cli\u003e容器的\u003cstrong\u003e生命周期\u003c/strong\u003e越来越短（decreasing Pod lifespan）。甚至短到\u003cstrong\u003e秒级或毫秒级\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e大家有兴趣的可以查阅相关调查：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.cncf.io/wp-content/uploads/2020/03/CNCF_Survey_Report.pdf\"\u003eCNCF’19 survey report\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://sysdig.com/blog/sysdig-2019-container-usage-report/\"\u003esysdig’19 container usage report\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"2-内核面临的挑战\"\u003e2 内核面临的挑战\u003c/h1\u003e\n\n\u003cp\u003e从操作系统内核的角度看，我们面临很多挑战。\u003c/p\u003e\n\n\u003ch2 id=\"21-复杂度性不断增长性能和可扩展性新需求\"\u003e2.1 复杂度性不断增长，性能和可扩展性新需求\u003c/h2\u003e\n\n\u003cp\u003e内核，或者说通用内核（general kernel），必须在\u003cstrong\u003e子系统复杂度不断增长\u003c/strong\u003e（\nincreasing complexity of kernel subsystems）的前提下，满足这些\u003cstrong\u003e性能和可扩展性\u003c/strong\u003e\n需求（performance \u0026amp; scalability requirements）。\u003c/p\u003e\n\n\u003ch2 id=\"22-永远保持后向兼容\"\u003e2.2 永远保持后向兼容\u003c/h2\u003e\n\n\u003cp\u003eLinus torvalds 的名言大家都知道：never break user space。\u003c/p\u003e\n\n\u003cp\u003e这对用户来说是好事，但对内核开发者来说意味着：我们必须保证在引入新代码时，五年前\n甚至十几年前的老代码仍然能正常工作。\u003c/p\u003e\n\n\u003cp\u003e显然，这会使原本就复杂的内核变得更加复杂，对于网络来说，这意味着\u003cstrong\u003e快速收发包路径\n（fast path）将受到影响\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"23-feature-creeping-normality\"\u003e2.3 Feature creeping normality\u003c/h2\u003e\n\n\u003cp\u003e开发者和用户不断往内核加入新功能，导致\u003cstrong\u003e内核非常复杂，现在已经没有一个人能理解所有东西了\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eWikipedia 对 \u003ca href=\"https://en.wikipedia.org/w/index.php?title=Death_by_a_thousand_cuts_(psychology)\"\u003ecreeping normality\u003c/a\u003e\n的定义：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eDef. creeping normality: … is a process by which a major change can be\naccepted as normal and acceptable if it happens slowly through small, often\nunnoticeable, increments of change. The change could otherwise be regarded as\nobjectionable if it took place in a single step or short period.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e应用到这里，意思就是：\u003cstrong\u003e内核不允许一次性引入非常大的改动，只能将它们拆\n分成数量众多的小 patch\u003c/strong\u003e，每次合并的 patch 保证系统后向兼容，并且对系统的影响非\n常小。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/feature-creeping.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e来看 Linus torvalds 的原话：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eLinus Torvalds on crazy new kernel features:\u003c/p\u003e\n\n  \u003cp\u003eSo I can work with crazy people, that’s not the problem. They just need to\n\u003cem\u003esell\u003c/em\u003e their crazy stuff to me using non-crazy arguments, and in small and\nwell-defined pieces. When I ask for killer features, I want them to lull\nme into a safe and cozy world where the stuff they are pushing is actually\nuseful to mainline people \u003cem\u003efirst\u003c/em\u003e.\u003c/p\u003e\n\n  \u003cp\u003eIn other words, every new crazy feature should be hidden in a nice solid\n“Trojan Horse” gift: something that looks \u003cem\u003eobviously\u003c/em\u003e good at first sight.\u003c/p\u003e\n\n  \u003cp\u003eLinus Torvalds,\u003c/p\u003e\n\n  \u003cp\u003ehttps://lore.kernel.org/lkml/alpine.LFD.2.00.1001251002430.3574@localhost.localdomain/\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"3-ebpf-降世重新定义数据平面datapth\"\u003e3 eBPF 降世：重新定义数据平面（datapth）\u003c/h1\u003e\n\n\u003cp\u003e这就是我们最开始想将 eBPF 合并到内核时遇到的问题：改动太大，功能太新（a crazy\nnew kernel feature）。\u003c/p\u003e\n\n\u003cp\u003e但是，eBPF 带来的好处也是无与伦比的。\u003c/p\u003e\n\n\u003cp\u003e首先，从长期看，\u003cstrong\u003eeBPF 这项新功能会减少未来的 feature creeping normality\u003c/strong\u003e。\n因为用户或开发者希望内核实现的功能，以后不需要再通过改内核的方式来实现了。\n只需要一段 eBPF 代码，实时动态加载到内核就行了。\u003c/p\u003e\n\n\u003cp\u003e其次，因为 eBPF，内核也不会再引入那些影响 fast path 的蹩脚甚至 hardcode 代码\n，从而也\u003cstrong\u003e避免了性能的下降\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e第三，eBPF 还使得内核\u003cstrong\u003e完全可编程，安全地可编程\u003c/strong\u003e（fully and safely programmable\n），用户编写的 eBPF 程序不会导致内核 crash。另外，eBPF 设计用来解决真实世界\n中的线上问题，而且我们现在仍然在坚守这个初衷。\u003c/p\u003e\n\n\u003ch1 id=\"4-ebpf-长什么样怎么用cilium-ebpf-networking-案例研究\"\u003e4 eBPF 长什么样，怎么用？Cilium eBPF networking 案例研究\u003c/h1\u003e\n\n\u003cp\u003eeBPF 程序长什么样？如下图所示，和 C 语言差不多，一般由用户空间 application 或\nagent 来生成。\u003c/p\u003e\n\n\u003ch2 id=\"41-cilium-ebpf-流程\"\u003e4.1 Cilium eBPF 流程\u003c/h2\u003e\n\n\u003cp\u003e下面我们将看看 Cilium 是如何用 eBPF 实现容器网络方案的。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/cilium-ebpf-1.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如上图所示，几个步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCilium agent \u003cstrong\u003e生成 eBPF 程序\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e用 LLVM 编译 eBPF 程序，\u003cstrong\u003e生成 eBPF 对象文件\u003c/strong\u003e（object file，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e*.o\u003c/code\u003e）。\u003c/li\u003e\n  \u003cli\u003e用 eBPF loader \u003cstrong\u003e将对象文件加载到 Linux 内核\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e校验器（verifier）对 eBPF 指令会进行\u003cstrong\u003e合法性验证\u003c/strong\u003e，以确保程序是安全的，例如\n，无非法内存访问、不会 crash 内核、不会有无限循环等。\u003c/li\u003e\n  \u003cli\u003e对象文件被\u003cstrong\u003e即时编译（JIT）为能直接在底层平台\u003c/strong\u003e（例如 x86）运行的 native code。\u003c/li\u003e\n  \u003cli\u003e如果要在内核和用户态之间共享状态，BPF 程序可以使用 BPF map，这种一种\u003cstrong\u003e共享存储\u003c/strong\u003e\n，BPF 侧和用户侧都可以访问。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eBPF 程序就绪，等待事件触发其执行\u003c/strong\u003e。对于这个例子，就是有数据包到达网络设备时，触发 BPF 程序的执行。\u003c/li\u003e\n  \u003cli\u003eBPF 程序对收到的包进行处理，例如 mangle。最后\u003cstrong\u003e返回一个裁决\u003c/strong\u003e（verdict）结果。\u003c/li\u003e\n  \u003cli\u003e根据裁决结果，如果是 DROP，这个包将被丢弃；如果是 PASS，包会被送到更网络栈的\n更上层继续处理；如果是重定向，就发送给其他设备。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"42-ebpf-特点\"\u003e4.2 eBPF 特点\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e最重要的一点：不能 crash 内核。\u003c/li\u003e\n  \u003cli\u003e执行起来，与内核模块（kernel module）一样快。\u003c/li\u003e\n  \u003cli\u003e提供稳定的 API。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/cilium-ebpf-2.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这意味着什么？简单来说，如果一段 BPF 程序能在老内核上执行，那它一定也能继续在新\n内核上执行，而无需做任何修改。\u003c/p\u003e\n\n\u003cp\u003e这就像是内核空间与用户空间的契约，内核保证对用户空间应用的兼容性，类似地，内核也\n会保证 eBPF 程序的兼容性。\u003c/p\u003e\n\n\u003ch1 id=\"5-温故kube-proxy-包转发路径\"\u003e5 温故：kube-proxy 包转发路径\u003c/h1\u003e\n\n\u003cp\u003e从网络角度看，使用传统的 kube-proxy 处理 Kubernetes Service 时，包在内核中的\n转发路径是怎样的？如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/flow-with-kube-proxy.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e网卡收到一个包（通过 DMA 放到 ring-buffer）。\u003c/li\u003e\n  \u003cli\u003e包经过 XDP hook 点。\u003c/li\u003e\n  \u003cli\u003e内核\u003cstrong\u003e给包分配内存\u003c/strong\u003e，此时才有了大家熟悉的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e（包的内核结构体表示），然后\n送到内核协议栈。\u003c/li\u003e\n  \u003cli\u003e包经过 GRO 处理，对分片包进行重组。\u003c/li\u003e\n  \u003cli\u003e包进入 tc（traffic control）的 ingress hook。接下来，\u003cstrong\u003e所有橙色的框都是 Netfilter 处理点\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePREROUTING\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eraw\u003c/code\u003e table 里的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003e包经过内核的\u003cstrong\u003e连接跟踪\u003c/strong\u003e（conntrack）模块。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePREROUTING\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emangle\u003c/code\u003e table 的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePREROUTING\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enat\u003c/code\u003e table 的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003e进行\u003cstrong\u003e路由判断\u003c/strong\u003e（FIB：Forwarding Information Base，路由条目的内核表示，译者注）\n。接下来又是四个 Netfilter 处理点。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eFORWARD\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emangle\u003c/code\u003e table 里的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eFORWARD\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efilter\u003c/code\u003e table 里的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOSTROUTING\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emangle\u003c/code\u003e table 里的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003eNetfilter：在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOSTROUTING\u003c/code\u003e hook 点处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enat\u003c/code\u003e table 里的 iptables 规则。\u003c/li\u003e\n  \u003cli\u003e包到达 TC egress hook 点，会进行出方向（egress）的判断，例如判断这个包是到本\n地设备，还是到主机外。\u003c/li\u003e\n  \u003cli\u003e对大包进行分片。根据 step 15 判断的结果，这个包接下来可能会：\u003c/li\u003e\n  \u003cli\u003e发送到一个本机 veth 设备，或者一个本机 service endpoint，\u003c/li\u003e\n  \u003cli\u003e或者，如果目的 IP 是主机外，就通过网卡发出去。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e相关阅读，有助于理解以上过程：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e\u003ca href=\"/blog/cracking-k8s-node-proxy/\"\u003eCracking Kubernetes Node Proxy (aka kube-proxy)\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/deep-dive-into-iptables-and-netfilter-arch-zh/\"\u003e(译) 深入理解 iptables 和 netfilter 架构\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/conntrack-design-and-implementation-zh/\"\u003e连接跟踪（conntrack）：原理、应用及 Linux 内核实现\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/understanding-ebpf-datapath-in-cilium-zh/\"\u003e(译) 深入理解 Cilium 的 eBPF 收发包路径（datapath）\u003c/a\u003e\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e译者注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"6-知新cilium-ebpf-包转发路径\"\u003e6 知新：Cilium eBPF 包转发路径\u003c/h1\u003e\n\n\u003cp\u003e作为对比，再来看下 Cilium eBPF 中的包转发路径：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e建议和 \u003ca href=\"/blog/understanding-ebpf-datapath-in-cilium-zh/\"\u003e(译) 深入理解 Cilium 的 eBPF 收发包路径（datapath）\u003c/a\u003e 对照看。\u003c/p\u003e\n\n  \u003cp\u003e译者注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/flow-with-cilium-ebpf-1.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e对比可以看出，\u003cstrong\u003eCilium eBPF datapath 做了短路处理\u003c/strong\u003e：从 tc ingress 直接 shortcut 到\ntc egress，节省了 9 个中间步骤（总共 17 个）。更重要的是：这个 datapath \u003cstrong\u003e绕过了\n整个 Netfilter 框架\u003c/strong\u003e（橘黄色的框们），Netfilter 在大流量情况下性能是很差的。\u003c/p\u003e\n\n\u003cp\u003e去掉那些不用的框之后，Cilium eBPF datapath 长这样：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/flow-with-cilium-ebpf-2.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCilium/eBPF 还能走的更远\u003c/strong\u003e。例如，如果包的目的端是另一台主机上的 service\nendpoint，那你可以直接在 XDP 框中完成包的重定向（收包 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1-\u0026gt;2\u003c/code\u003e，在步骤 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2\u003c/code\u003e 中对包\n进行修改，再通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2-\u0026gt;1\u003c/code\u003e 发送出去），将其发送出去，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/flow-with-cilium-ebpf-3.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到，这种情况下包都\u003cstrong\u003e没有进入内核协议栈（准确地说，都没有创建 skb）\u003c/strong\u003e就被转\n发出去了，性能可想而知。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eXDP 是 eXpress DataPath 的缩写，支持在网卡驱动中运行 eBPF 代码，而无需将包送\n到复杂的协议栈进行处理，因此处理代价很小，速度极快。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"7-ebpf-年鉴\"\u003e7 eBPF 年鉴\u003c/h1\u003e\n\n\u003cp\u003eeBPF 是如何诞生的呢？我最初开始讲起。这里“最初”我指的是 2013 年之前。\u003c/p\u003e\n\n\u003ch2 id=\"2013\"\u003e2013\u003c/h2\u003e\n\n\u003ch3 id=\"前浪工具和子系统\"\u003e前浪工具和子系统\u003c/h3\u003e\n\n\u003cp\u003e回顾一下当时的 “SDN” 蓝图。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e当时有 OpenvSwitch（OVS）、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e（Traffic control），以及内核中的 Netfilter 子系\n统（包括 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiptables\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipvs\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enftalbes\u003c/code\u003e 工具），可以用这些工具对 datapath 进行“\n编程”：。\u003c/li\u003e\n  \u003cli\u003eBPF 当时用于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e，\u003cstrong\u003e在内核中尽量前面的位置抓包\u003c/strong\u003e，它不会 crash 内核；此\n外，它还用于 seccomp，\u003cstrong\u003e对系统调用进行过滤\u003c/strong\u003e（system call filtering），但当时\n使用的非常受限，远不是今天我们已经在用的样子。\u003c/li\u003e\n  \u003cli\u003e此外就是前面提到的 feature creeping 问题，以及 \u003cstrong\u003e\u003cmark\u003etc 和 netfilter 的代码重复问题，因为这两个子系统是竞争关系\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eOVS 当时被认为是内核中最先进的数据平面\u003c/strong\u003e，但它最大的问题是：与内核中其他网\n络模块的集成不好【译者注 1】。此外，很多核心的内核开发者也比较抵触 OVS，觉得它很怪。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e【译者注 1】\u003c/p\u003e\n\n  \u003cp\u003e例如，OVS 的 internal port、patch port 用 tcpdump 都是\n\u003ca href=\"/blog/ovs-deep-dive-4-patch-port/\"\u003e抓不到包的\u003c/a\u003e，排障非常不方便。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"ebpf-与前浪的区别\"\u003eeBPF 与前浪的区别\u003c/h3\u003e\n\n\u003cp\u003e对比 eBPF 和这些已经存在很多年的工具：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003etc、OVS、netfilter 可以对 datapath 进行“编程”：但前提是 datapath 知道你想做什\n么（but only if the datapath knows what you want to do）。\n    \u003cul\u003e\n      \u003cli\u003e只能利用这些工具或模块提供的既有功能。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eeBPF 能够让你\u003cstrong\u003e创建新的 datapath\u003c/strong\u003e（eBPF lets you create the datapath instead）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003eeBPF 就是内核本身的代码，想象空间无限，并且热加载到内核；换句话说，一旦加\n载到内核，内核的行为就变了。\u003c/li\u003e\n    \u003cli\u003e在 eBPF 之前，改变内核行为这件事情，只能通过修改内核再重新编译，或者开发内\n核模块才能实现。\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"ebpf第一个巨型patch\"\u003eeBPF：第一个（巨型）patch\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e描述 eBPF 的 RFC 引起了广泛讨论，但普遍认为侵入性太强了（改动太大）。\u003c/li\u003e\n  \u003cli\u003e另外，当时 nftables (inspired by BPF) 正在上升期，它是一个与 eBPF 有点类似的\nBPF 解释器，大家不想同时维护两个解释器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e最终这个 patch 被拒绝了。\u003c/p\u003e\n\n\u003cp\u003e被拒的另外一个原因是前面提到的，没有遵循“大改动小提交”原则，全部代码放到了一个\npatch。Linus 会疯的。\u003c/p\u003e\n\n\u003ch2 id=\"2014\"\u003e2014\u003c/h2\u003e\n\n\u003ch3 id=\"第一个-ebpf-patch-合并到内核\"\u003e第一个 eBPF patch 合并到内核\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e用一个\u003cstrong\u003e扩展（extended）指令集\u003c/strong\u003e逐步、全面替换原来老的 BPF 解释器。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e自动新老 BPF 转换\u003c/strong\u003e：in-kernel translation。\u003c/li\u003e\n  \u003cli\u003e后续 patch 将 eBPF 暴露给 UAPI，并添加了 verifier 代码和 JIT 代码。\u003c/li\u003e\n  \u003cli\u003e更多后续 patch，从核心代码中移除老的 BPF。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/ebpf-first-merge.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e我们也从那时开始，顺理成章地成为了 eBPF 的 maintainer。\u003c/p\u003e\n\n\u003ch3 id=\"kubernetes-提交第一个-commit\"\u003eKubernetes 提交第一个 commit\u003c/h3\u003e\n\n\u003cp\u003e巧合的是，\u003cstrong\u003e对后来影响深远的 Kubernetes，也在这一年提交了第一个 commit\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/k8s-first-commit.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"2015\"\u003e2015\u003c/h2\u003e\n\n\u003ch3 id=\"ebpf-分成两个方向networking--tracing\"\u003eeBPF 分成两个方向：networking \u0026amp; tracing\u003c/h3\u003e\n\n\u003cp\u003e到了 \u003cstrong\u003e\u003cmark\u003e2015 年，eBPF 开发分成了两个方向\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003enetworking\u003c/li\u003e\n  \u003cli\u003etracing\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"ebpf-backend-合并到-llvm-37\"\u003eeBPF backend 合并到 LLVM 3.7\u003c/h3\u003e\n\n\u003cp\u003e这一年的一个重要里程碑是 eBPF backend 合并到了 upstream LLVM 编译器套件，因此你\n现在才能用 clang 编译 eBPF 代码。\u003c/p\u003e\n\n\u003ch3 id=\"支持将-ebpf-attach-到-kprobes\"\u003e支持将 eBPF attach 到 kprobes\u003c/h3\u003e\n\n\u003cp\u003e这是 \u003cstrong\u003e\u003cmark\u003etracing 的第一个使用案例\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eAlexei 主要负责 tracing 部分，他添加了一个 patch，支持加载 eBPF 用来做 tracing，\n能获取系统的观测数据。\u003c/p\u003e\n\n\u003ch3 id=\"通过-cls_bpftc-变得完全可编程\"\u003e通过 cls_bpf，tc 变得完全可编程\u003c/h3\u003e\n\n\u003cp\u003e我主要负责 networking 部分，使 tc 子系统可编程，这样我们就能用 eBPF 来灵活的对\ndatapath 进行编程，获得一个高性能 datapath。\u003c/p\u003e\n\n\u003ch3 id=\"为-tc-添加了一个-lockless-ingress--egress-hook-点\"\u003e为 tc 添加了一个 lockless ingress \u0026amp; egress hook 点\u003c/h3\u003e\n\n\u003cp\u003e注意这里的关键词之一是 “lockless”，在著名的 \u003cstrong\u003e\u003cmark\u003eqdisc root lock 之外\u003c/mark\u003e\u003c/strong\u003e执行 TC BPF 代码。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e译注：可参考：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"/blog/understanding-tc-da-mode-zh/\"\u003e深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/advanced-bpf-kernel-features-for-container-age-zh/\"\u003e为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"添加了很多-verifer-和-ebpf-辅助代码helper\"\u003e添加了很多 verifer 和 eBPF 辅助代码（helper）\u003c/h3\u003e\n\n\u003cp\u003e使用更方便。\u003c/p\u003e\n\n\u003ch3 id=\"bcc-项目发布\"\u003ebcc 项目发布\u003c/h3\u003e\n\n\u003cp\u003e作为 \u003cstrong\u003e\u003cmark\u003etracing frontend\u003c/mark\u003e\u003c/strong\u003e for eBPF。\u003c/p\u003e\n\n\u003ch2 id=\"2016\"\u003e2016\u003c/h2\u003e\n\n\u003ch3 id=\"ebpf-添加了一个新-fast-pathxdp\"\u003eeBPF 添加了一个新 fast path：XDP\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003eXDP 合并到内核，支持在驱动的 ingress 层 attach BPF 程序。\u003c/li\u003e\n  \u003cli\u003enfp 最为第一家网卡及驱动，支持将 eBPF 程序 offload 到 cls_bpf \u0026amp; XDP hook 点。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"cilium-项目发布\"\u003eCilium 项目发布\u003c/h3\u003e\n\n\u003cp\u003eCilium 最开始的目标是 \u003cstrong\u003e\u003cmark\u003edocker 网络解决方案\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e通过 eBPF 实现高效的 label-based policy、NAT64、tunnel mesh、容器连通性。\u003c/li\u003e\n  \u003cli\u003e整个 datapath \u0026amp; forwarding 逻辑全用 eBPF 实现，不再需要 Docker 或 OVS 桥接设备。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"2017\"\u003e2017\u003c/h2\u003e\n\n\u003ch3 id=\"ebpf-开始大规模应用于生产环境\"\u003eeBPF 开始大规模应用于生产环境\u003c/h3\u003e\n\n\u003cp\u003e2016 ~ 2017 年，eBPF 开始应用于生产环境：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eNetflix on eBPF for tracing: ‘Linux BPF superpowers’\u003c/li\u003e\n  \u003cli\u003eFacebook 公布了生产环境 XDP+eBPF 使用案例（DDoS \u0026amp; LB）\n    \u003cul\u003e\n      \u003cli\u003e用 XDP/eBPF 重写了原来基于 IPVS 的 L4LB，性能 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10x\u003c/code\u003e。\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003eeBPF 经受住了严苛的考验\u003c/strong\u003e：从 2017 开始，每个进入 facebook.com 的包，都是经过了 XDP \u0026amp; eBPF 处理的。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eCloudflare 将 XDP+BPF 集成到了它们的 DDoS mitigation 产品。\n    \u003cul\u003e\n      \u003cli\u003e成功将其组件从基于 Netfilter 迁移到基于 eBPF。\u003c/li\u003e\n      \u003cli\u003e到 2018 年，它们的 XDP L4LB 完全接管生产环境。\u003c/li\u003e\n      \u003cli\u003e扩展阅读：\u003ca href=\"/blog/cloudflare-arch-and-bpf-zh/\"\u003e(译) Cloudflare 边缘网络架构：无处不在的 BPF（2019）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e译者注：基于 XDP/eBPF 的 L4LB 原理都是类似的，简单来说，\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e通过 BGP 宣告 VIP\u003c/li\u003e\n    \u003cli\u003e通过 ECMP 做物理链路高可用\u003c/li\u003e\n    \u003cli\u003e通过 XDP/eBPF 代码做重定向，将请求转发到后端（VIP -\u0026gt; Backend）\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e对此感兴趣可参考入门级介绍：\u003ca href=\"/blog/k8s-l4lb/\"\u003eL4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"2017--2018\"\u003e2017 ~ 2018\u003c/h2\u003e\n\n\u003ch3 id=\"ebpf-成为内核独立子系统\"\u003eeBPF 成为内核独立子系统\u003c/h3\u003e\n\n\u003cp\u003e随着 eBPF 社区的发展，feature 和 patch 越来越多，为了管理这些 patch，Alexei、我和\nnetworking 的一位 maintainer David Miller 经过讨论，决定将 eBPF 作为独立的内核子\n系统。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eeBPF patch 合并到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e \u0026amp; \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf-next\u003c/code\u003e kernel trees on git.kernel.org\u003c/li\u003e\n  \u003cli\u003e拆分 eBPF 邮件列表：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf@vger.kernel.org\u003c/code\u003e (archive at: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elore.kernel.org/bpf/\u003c/code\u003e)\u003c/li\u003e\n  \u003cli\u003eeBPF PR 经内核网络部分的 maintainer David S. Miller 提交给 Linus Torvalds\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"ktls--ebpf\"\u003ekTLS \u0026amp; eBPF\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ekTLS \u0026amp; eBPF for introspection and ability for in-kernel TLS policy enforcement\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003ekTLS 是\u003cstrong\u003e将 TLS 处理 offload 到内核\u003c/strong\u003e，例如，将加解密过程从 openssl 下放到内核进\n行，以\u003cstrong\u003e使得内核具备更强的可观测性\u003c/strong\u003e（gain visibility）。\u003c/p\u003e\n\n\u003cp\u003e有了 kTLS，就可以用 eBPF 查看数据和状态，在内核应用安全策略。\n\u003cstrong\u003e目前 openssl 已经完全原生支持这个功能\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"bpftool--libbpf\"\u003ebpftool \u0026amp; libbpf\u003c/h3\u003e\n\n\u003cp\u003e为了检查内核内 eBPF 的状态（introspection）、查看内核加载了哪些 BPF 程序等，\n我们添加了一个新工具 bpftool。现在这个工具已经功能非常强大了。\u003c/p\u003e\n\n\u003cp\u003e同样，为了方便用户空间应用使用 eBPF，我们提供了\u003cstrong\u003e\u003cmark\u003e用户空间 API\u003c/mark\u003e\u003c/strong\u003e\n（user space API for applications）\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elibbpf\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\n这是一个 C 库，接管了所有加载工作，这样用户就不需要自己处理复杂的加载过程了。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-to-bpf-function-calls\"\u003eBPF to BPF function calls\u003c/h3\u003e\n\n\u003cp\u003e增加了一个 BPF 函数调用另一个 BPF 函数的支持，使得 BPF 程序的编写更加灵活。\u003c/p\u003e\n\n\u003ch2 id=\"2018\"\u003e2018\u003c/h2\u003e\n\n\u003ch3 id=\"cilium-10-发布\"\u003eCilium 1.0 发布\u003c/h3\u003e\n\n\u003cp\u003e这标志着 \u003cstrong\u003eBPF 革命之火燃烧到了 Kubernetes networking \u0026amp; security 领域\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eCilium 此时支持的功能：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eK8s CNI\u003c/li\u003e\n  \u003cli\u003eIdentity-based L3-L7 policy\u003c/li\u003e\n  \u003cli\u003eClusterIP Services\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"btfbyte-type-format\"\u003eBTF（Byte Type Format）\u003c/h3\u003e\n\n\u003cp\u003e内核添加了一个称为 BTF 的组件。这是一种元数据格式，和 DWARF 这样的 debugging\ndata 类似。但 \u003cstrong\u003e\u003cmark\u003eBTF 的 size 要小的多\u003c/mark\u003e\u003c/strong\u003e，更重要的是，有史以来\n\u003cstrong\u003e内核第一次变得可自描述了\u003c/strong\u003e（self-descriptive）。什么意思？\u003c/p\u003e\n\n\u003cp\u003e想象一下当前正在运行中的内核，它\u003cstrong\u003e内置了自己的数据格式\u003c/strong\u003e（its own data format）\n和\u003cstrong\u003e内部数据结构\u003c/strong\u003e（internal structures），你能用工具来查看这些东西（you can\nintrospect them）。还是不太懂？这么说吧，\u003cstrong\u003eBTF 是后来的 “一次编译、到处运行”、\n热补丁（live-patching）、BPF global data 处理等等所有这些 BPF 特性的基础\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e新的特性不断加入，它们都依赖 BTF 提供富元数据（rich metadata）这个基础。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多 BTF 内容，可参考 \u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-zh/\"\u003e(译) Cilium：BPF 和 XDP 参考指南（2019）\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003e译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"linux-plumbers-会议开辟-bpfxdp-主题\"\u003eLinux Plumbers 会议开辟 BPF/XDP 主题\u003c/h3\u003e\n\n\u003cp\u003e这一年，Linux Plumbers 会议第一次开辟了专门讨论 BPF/XDP 的微型分会，我们\n一起组织这场会议。其中，Networking Track 一半以上的议题都涉及 BPF 和 XDP\n主题，因为这是一个非常振奋人心的特性，越来越多的人用它来解决实际问题。\u003c/p\u003e\n\n\u003ch3 id=\"新-socket-类型af_xdp\"\u003e新 socket 类型：AF_XDP\u003c/h3\u003e\n\n\u003cp\u003e内核添加了一个\u003cstrong\u003e新 socket 类型 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_XDP\u003c/code\u003e\u003c/strong\u003e。它提供的能力是：\n\u003cstrong\u003e\u003cmark\u003e在零拷贝（zero-copy）的前提下将包从网卡驱动送到用户空间\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e回忆前面的内容，数据包到达网卡后，先经过 XDP，然后才为这个包分配内存。\n因此在 XDP 层直接将包送到用户态就绕过了内核内存分配和数据拷贝。\n译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_XDP\u003c/code\u003e 提供的能力与 DPDK 有点类似，不过\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eDPDK 需要\u003cstrong\u003e重写网卡驱动\u003c/strong\u003e，需要额外维护\u003cstrong\u003e用户空间的驱动代码\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_XDP\u003c/code\u003e 在\u003cstrong\u003e复用内核网卡驱动\u003c/strong\u003e的情况下，能达到与 DPDK 一样的性能。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e而且由于\u003cstrong\u003e复用了内核基础设施，所有的网络管理工具还都是可以用的\u003c/strong\u003e，因此非常方便，\n而 DPDK 这种 bypass 内核的方案导致绝大大部分现有工具都用不了了。\u003c/p\u003e\n\n\u003cp\u003e由于所有这些操作都是发生在 XDP 层的，因此它称为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_XDP\u003c/code\u003e。插入到这里的 BPF 代码\n能\u003cstrong\u003e\u003cmark\u003e直接将包送到 socket\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"bpffilter\"\u003ebpffilter\u003c/h3\u003e\n\n\u003cp\u003e开始了 bpffilter prototype，作用是通过用户空间驱动（userspace driver），\u003cstrong\u003e将\niptables 规则转换成 eBPF 代码\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这是将 iptables 转换成 eBPF 的第一次尝试，整个过程对用户都是无感知的，其中的某些\n组件现在还在用，用于在其他方面扩展内核的功能。\u003c/p\u003e\n\n\u003ch2 id=\"2018--2019\"\u003e2018 ~ 2019\u003c/h2\u003e\n\n\u003ch3 id=\"bpftrace\"\u003ebpftrace\u003c/h3\u003e\n\n\u003cp\u003eBrendan 发布了 bpftrace 工具，作为 DTrace 2.0 for Linux。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-专著bpf-performance-tools\"\u003eBPF 专著《BPF Performance Tools》\u003c/h3\u003e\n\n\u003cp\u003eBerendan 写了一本 800 多页的 BPF 书。\u003c/p\u003e\n\n\u003ch3 id=\"cilium-16-发布\"\u003eCilium 1.6 发布\u003c/h3\u003e\n\n\u003cp\u003e第一次支持完全干掉基于 iptables 的 kube-proxy，全部功能基于 eBPF。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这个版本其实是有问题的，例如 1.6 发布之后我们发现 externalIPs 的实现是有问题\n，社区在后面的版本修复了这个问题。在修复之前，还是得用 kube-proxy：\nhttps://github.com/cilium/cilium/issues/9285\u003c/p\u003e\n\n  \u003cp\u003e译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"bpf-live-patching\"\u003eBPF live-patching\u003c/h3\u003e\n\n\u003cp\u003e添加了一些内核新特性，例如尾调用（tail call），这使得 \u003cstrong\u003eeBPF 核心基础\n设施第一次实现了热加载\u003c/strong\u003e。这个功能帮我们极大地优化了 datapath。\u003c/p\u003e\n\n\u003cp\u003e另一个重要功能是 BPF trampolines，这里就不展开了，感兴趣的可以搜索相关资料，我只\n能说这是另一个振奋人心的技术。\u003c/p\u003e\n\n\u003ch3 id=\"第一次-bpfconf受邀请才能参加的-bpf-内核专家会议\"\u003e第一次 bpfconf：受邀请才能参加的 BPF 内核专家会议\u003c/h3\u003e\n\n\u003cp\u003e如题，这是 BPF 内核专家交换想法和讨论问题的会议。与 Linux Plumbers 会议互补。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-backend-合并到-gcc\"\u003eBPF backend 合并到 GCC\u003c/h3\u003e\n\n\u003cp\u003e前面提到，BPF backend 很早就合并到 LLVM/Clang，现在，它终于合并到 GCC 了。\n至此，\u003cstrong\u003eGCC 和 LLVM 这两个最主要的编译器套件都支持了 BPF backend\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e此外，BPF 开始支持有限循环（bounded loops），在此之前，是不支持循环的，以防止程\n序无限执行。\u003c/p\u003e\n\n\u003ch2 id=\"2019--2020\"\u003e2019 ~ 2020\u003c/h2\u003e\n\n\u003ch3 id=\"不知疲倦的增长和-ebpf-的第三个方向linux-security-modules\"\u003e不知疲倦的增长和 eBPF 的第三个方向：Linux security modules\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003eGoogle 贡献了 \u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/bpf_lsm.html\"\u003eBPF LSM\u003c/a\u003e（安全），部署在了他们的数据中心服务器上。\u003c/li\u003e\n  \u003cli\u003eBPF verifier 防护 Spectre 漏洞（2018 年轰动世界的 CPU bug）：even verifying safety on speculative program paths。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e主流云厂商开始通过 SRIOV 支持 XDP\u003c/strong\u003e：AWS (ena driver), Azure (hv_netvsc driver), …\u003c/li\u003e\n  \u003cli\u003eCilium 1.8 支持基于 XDP 的 Service 负载均衡和 host network policies。\u003c/li\u003e\n  \u003cli\u003eFacebook 开发了基于 BPF 的 TCP 拥塞控制模块。\u003c/li\u003e\n  \u003cli\u003eMicrosoft 基于 BPF 重写了将他们的 Windows monitoring 工具。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"8-ebpf过去-50-年操作系统最大的变革\"\u003e8 eBPF：过去 50 年操作系统最大的变革\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/netflix-says-bpf.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBrendan 说在他的职业生涯中，eBPF 是他见过的操作系统中最大的变革之一（one of the\nbiggest operating system changes），他为能身处其中而感到非常兴奋。\u003c/p\u003e\n\n\u003cp\u003e我接下来只能用数字证明：Brendan 的兴奋是没错的。\u003c/p\u003e\n\n\u003ch1 id=\"9-ebpf-数字榜单截至-202007\"\u003e9 eBPF 数字榜单（截至 2020.07）\u003c/h1\u003e\n\n\u003cp\u003eeBPF 内核社区截至 7 月份的一些数据：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e347 个贡献者，贡献了 4,935 个 patch 到 BPF 子系统。\u003c/li\u003e\n  \u003cli\u003eBPF 内核邮件列表日均 50 封邮件 (高峰经常超过日均 100)。\n    \u003cul\u003e\n      \u003cli\u003e23,395 mails since mailing list git archive was added in Feb 2019\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e每天合并 4 个新 patch。patch 接受率 30% 左右。\u003c/li\u003e\n  \u003cli\u003e30 个程序（different program），27 种 BPF map 类型，141 个 BPF helpers，超过 3,500 个测试。\u003c/li\u003e\n  \u003cli\u003e2 个 BPF kernel maintainers \u0026amp; team of 6 senior core reviewers。\n    \u003cul\u003e\n      \u003cli\u003e\u003cstrong\u003e主要贡献来自：Isovalent（Cilium）, Facebook and Google\u003c/strong\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e毫无疑问，这是内核里发展最快的子系统！\u003c/p\u003e\n\n\u003ch1 id=\"10-业界趋势\"\u003e10 业界趋势\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/industry-shift.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意贡献榜排名第一的就是演讲者本人，译者注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e列举几个生产环境大规模使用 BPF 的大厂：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eFacebook：L4LB、DDoS、tracing。\u003c/li\u003e\n  \u003cli\u003eNetflix：BPF 重度用户，例如生产环境 tracing。\u003c/li\u003e\n  \u003cli\u003eGoogle：Android、服务器安全以及其他很多方面。\u003c/li\u003e\n  \u003cli\u003eCloudflare：L4LB、DDoS。\u003c/li\u003e\n  \u003cli\u003eCilium\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e上图中，右边是\u003cstrong\u003e前 Netfilter 维护者\u003c/strong\u003e Rusty Russel 说的一句，业界对 eBPF\n的受认可程度可窥一斑。\u003c/p\u003e\n\n\u003ch1 id=\"11-ebpf-革命燃烧到-kubernetes-社区\"\u003e11 eBPF 革命：燃烧到 Kubernetes 社区\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/iptables-list.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eeBPF 已无处不在，而你还在使用 iptables？\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"111-干掉-kube-proxyiptables\"\u003e11.1 干掉 kube-proxy/iptables\u003c/h2\u003e\n\n\u003cp\u003e不用再忍受 iptables 复杂冗长的规则和差劲的性能了，以前没得选，现在你可以做个好人：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e kube-system delete ds kube-proxy\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e作为例子，我们来看看 Cilium 是怎么做 Service 的负载均衡的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eService 细节实现可参考 \u003ca href=\"/blog/cracking-k8s-node-proxy/\"\u003eCracking Kubernetes Node Proxy (aka kube-proxy)\u003c/a\u003e。\u003c/p\u003e\n\n  \u003cp\u003e译者注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"112-cilium-的-service-load-balancing-设计\"\u003e11.2 Cilium 的 Service load balancing 设计\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/cilium-service-1.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如上图所示，主要涉及两部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e在 socket 层运行的 BPF 程序\u003c/li\u003e\n  \u003cli\u003e在 XDP 和 tc 层运行的 BPF 程序\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"东西向流量\"\u003e东西向流量\u003c/h3\u003e\n\n\u003cp\u003e我们先来看 socker 层。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/cilium-service-2.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如上图所示，\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSocket 层的 BPF 程序主要处理 Cilium 节点的东西向流量\u003c/strong\u003e（E-W）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e将 Service 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIP:Port\u003c/code\u003e 映射到具体的 backend pods，并做负载均衡。\u003c/li\u003e\n  \u003cli\u003e当应用发起 \u003cstrong\u003econnect、sendmsg、recvmsg 等请求（系统调用）时，拦截这些请求\u003c/strong\u003e，\n并根据请求的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIP:Port\u003c/code\u003e 映射到后端 pod，直接发送过去。反向进行相反的变换。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这里实现的好处：性能更高。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e不需要包级别（packet leve）的地址转换\u003c/strong\u003e（NAT）。\u003cstrong\u003e\u003cmark\u003e在系统调用时，还没有创建包\u003c/mark\u003e\u003c/strong\u003e，因此性能更高。\u003c/li\u003e\n  \u003cli\u003e省去了 kube-proxy 路径中的很多中间节点（intermediate node hops）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可以看出，应用对这种拦截和重定向是无感知的（符合 k8s Service 的设计）。\u003c/p\u003e\n\n\u003ch3 id=\"南北向流量\"\u003e南北向流量\u003c/h3\u003e\n\n\u003cp\u003e再来看\u003cstrong\u003e从 k8s 集群外进入节点，或者从节点出 k8s 集群的流量（external traffic），\n即南北向流量（N-S）\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e区分集群外流量的一个原因是：Pod IP 很多情况下都是不可路由的（与跨主机选用的网\n络方案有关），只在集群内有效，即，集群外访问 Pod IP 是不通的。\u003c/p\u003e\n\n  \u003cp\u003e因此，如果 Pod 流量直接从 node 出宿主机，必须确保它能正常回来。而 node IP\n一般都是全局可达的，集群外也可以访问，所以常见的解决方案就是：在 Pod 通过 node\n出集群时，对其进行 SNAT，将源 IP 地址换成 node IP 地址；应答包回来时，再进行相\n反的 DNAT，这样包就能回到 Pod 了。\u003c/p\u003e\n\n  \u003cp\u003e译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/cilium-service-3.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如上图所示，集群外来的流量到达 node 时，由 \u003cstrong\u003eXDP 和 tc 层的 BPF 程序进行处理\u003c/strong\u003e，\n它们做的事情与 socket 层的差不多，将 Service 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIP:Port\u003c/code\u003e 映射到后端的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePodIP:Port\u003c/code\u003e，如果 backend pod 不在本 node，就通过网络再发出去。发出去的流程我们\n在前面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCilium eBPF 包转发路径\u003c/code\u003e 讲过了。\u003c/p\u003e\n\n\u003cp\u003e这里 BPF 做的事情：执行 DNAT。\u003cstrong\u003e这个功能可以在 XDP 层做，也可以在 TC 层做\u003c/strong\u003e，但\n在 XDP 层代价更小，性能也更高。\u003c/p\u003e\n\n\u003cp\u003e总结起来，这里的\u003cstrong\u003e核心理念\u003c/strong\u003e就是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e将\u003cstrong\u003e东西向流量\u003c/strong\u003e放在\u003cstrong\u003e离 socket 层尽量近\u003c/strong\u003e的地方做。\u003c/li\u003e\n  \u003cli\u003e将\u003cstrong\u003e南北向流量\u003c/strong\u003e放在\u003cstrong\u003e离驱动（XDP 和 tc）层尽量近\u003c/strong\u003e的地方做。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"113-xdpebpf-vs-kube-proxy-性能对比\"\u003e11.3 XDP/eBPF vs kube-proxy 性能对比\u003c/h2\u003e\n\n\u003ch3 id=\"网络吞吐\"\u003e网络吞吐\u003c/h3\u003e\n\n\u003cp\u003e测试环境：两台物理节点，一个发包，一个收包，收到的包做 Service loadbalancing 转发给后端 Pods。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/bpf-perf-1.png\" width=\"75%\" height=\"75%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看出：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCilium XDP eBPF 模式能处理接收到的全部 10Mpps（packets per second）。\u003c/li\u003e\n  \u003cli\u003eCilium tc eBPF 模式能处理 3.5Mpps。\u003c/li\u003e\n  \u003cli\u003ekube-proxy iptables 只能处理 2.3Mpps，因为它的 hook 点在收发包路径上更后面的位置。\u003c/li\u003e\n  \u003cli\u003ekube-proxy ipvs 模式这里表现更差，它\u003cstrong\u003e相比 iptables 的优势要在 backend 数量很多的时候才能体现出来\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"cpu-利用率\"\u003eCPU 利用率\u003c/h3\u003e\n\n\u003cp\u003e我们生成了 1Mpps、2Mpps 和 4Mpps 流量，空闲 CPU 占比（可以被应用使用的 CPU）结果如下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/bpf-perf-2.png\" width=\"75%\" height=\"75%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e结论与上面吞吐类似。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eXDP 性能最好，是因为 \u003cstrong\u003eXDP BPF 在驱动层执行，不需要将包 push 到内核协议栈\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003ekube-proxy 不管是 iptables 还是 ipvs 模式，都\u003cstrong\u003e\u003cmark\u003e在处理软中断（softirq）上消耗了大量 CPU\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"12-ebpf-和-kubernetes未来展望\"\u003e12 eBPF 和 Kubernetes：未来展望\u003c/h1\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e“The Linux kernel continues its march towards becoming BPF runtime-powered microkernel.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003e“Linux 内核继续朝着成为 BPF runtime-powered microkernel 而前进”\u003c/strong\u003e。这是一个非\n常有趣的思考角度。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e设想在将来，Linux 只会保留一个非常小的核心内核（tiny core kernel），其他所有\n内核功能都由用户定义，并用 BPF 实现（而不再是开发内核模块的方式）。\u003c/li\u003e\n  \u003cli\u003e这样可以减少受攻击面，因为此时的核心内核非常小；另外，所有 BPF 代码都会经过\nverifer 校验。\u003c/li\u003e\n  \u003cli\u003e极大减少 ‘static’ feature creep，资源（例如 CPU）可以用在更有意义的地方。\u003c/li\u003e\n  \u003cli\u003e设想一下，未来 Kubernetes 可能会内置 custom BPF-tailored extensions，能根据用户的应用自动适配（optimize needs for user workloads）；例如，判断 pod 是跑在数据中心，还是在嵌入式系统上。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/future.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBPF will replace Linux.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e我们的目标是星辰大海，与此相比，kube-proxy replacement 只是最微不足道的开端。\u003c/p\u003e\n\n\u003ch1 id=\"13-结束语\"\u003e13 结束语\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ebpf-and-k8s/conclusion.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eTry it out：\u003ca href=\"https://cilium.link/kubeproxy-free\"\u003ehttps://cilium.link/kubeproxy-free\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eContribute：\u003ca href=\"https://github.com/cilium/cilium\"\u003ehttps://github.com/cilium/cilium\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/understanding-ebpf-datapath-in-cilium-zh/\"\u003e\u003cspan\u003e« [译] 深入理解 Cilium 的 eBPF 收发包路径（datapath）（KubeCon, 2019）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cilium-life-of-a-packet-pod-to-service-zh/\"\u003e\u003cspan\u003eLife of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-09-06T00:00:00Z",
  "Author": "Arthur Chiao"
}