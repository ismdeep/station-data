{
  "Source": "arthurchiao.art",
  "Title": "[译] TTY 的前世今生（2008）",
  "Link": "https://arthurchiao.art/blog/tty-demystified-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] TTY 的前世今生（2008）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-12-08 | Last Update 2021-12-01\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2008 年的一篇帖子 \u003ca href=\"http://www.linusakesson.net/programming/tty/index.php\"\u003eThe TTY demystified\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-历史\" id=\"markdown-toc-1-历史\"\u003e1. 历史\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-使用场景\" id=\"markdown-toc-2-使用场景\"\u003e2. 使用场景\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-行编辑line-editing\" id=\"markdown-toc-21-行编辑line-editing\"\u003e2.1 行编辑（Line editing）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#line-discipline\" id=\"markdown-toc-line-discipline\"\u003eLine discipline\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-会话管理session-management\" id=\"markdown-toc-22-会话管理session-management\"\u003e2.2 会话管理（Session management）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-进程\" id=\"markdown-toc-3-进程\"\u003e3. 进程\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-作业jobs和会话\" id=\"markdown-toc-4-作业jobs和会话\"\u003e4. 作业（Jobs）和会话\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-简单粗暴的信号机制\" id=\"markdown-toc-5-简单粗暴的信号机制\"\u003e5. 简单粗暴的信号机制\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-一个例子\" id=\"markdown-toc-6-一个例子\"\u003e6. 一个例子\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-流控和阻塞式-io\" id=\"markdown-toc-7-流控和阻塞式-io\"\u003e7. 流控和阻塞式 I/O\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-配置-tty-设备\" id=\"markdown-toc-8-配置-tty-设备\"\u003e8. 配置 TTY 设备\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#tty-配置选项\" id=\"markdown-toc-tty-配置选项\"\u003eTTY 配置选项\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#修改窗口尺寸\" id=\"markdown-toc-修改窗口尺寸\"\u003e修改窗口尺寸\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#修改-sigint-对应的控制字符\" id=\"markdown-toc-修改-sigint-对应的控制字符\"\u003e修改 SIGINT 对应的控制字符\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#退格键无法使用\" id=\"markdown-toc-退格键无法使用\"\u003e退格键无法使用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#tty-开关项\" id=\"markdown-toc-tty-开关项\"\u003eTTY 开关项\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-结束语\" id=\"markdown-toc-9-结束语\"\u003e9. 结束语\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003eTTY 子系统是 Linux 乃至 Unix 家族中最核心的设计之一。\u003c/p\u003e\n\n\u003cp\u003e但不幸的是，TTY 的重要性经常被低估，而且网上也很难找到不错的介绍性文章。而我\n认为，对 Linux 中的 TTY 有一些基本了解对于\u003cstrong\u003e开发者和高级用户\u003c/strong\u003e来说是非常有帮助的。\u003c/p\u003e\n\n\u003cp\u003e但要注意：\u003cstrong\u003e接下来你将看到的东西并不是非常优雅\u003c/strong\u003e。事实上，TTY 子系统 —— 虽然从用\n户的角度来非常好用 —— 是很多特殊场景杂糅在一起的结果。而要理解为什么会变成这样，\n我们需要从历史说起。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"1-历史\"\u003e1. 历史\u003c/h1\u003e\n\n\u003cp\u003e1869，人类发明了\u003cstrong\u003e股票自动报价机\u003c/strong\u003e（stock ticker）。它是一个用于\u003cstrong\u003e跨长距离实时传\n递股票价格\u003c/strong\u003e的电子-机械设备，由一个打字机（typewriter）、一对很长的电缆（a long\npair of wires）和一个报价用的磁带打印机（tape printer）组成。后来，这个概念逐渐\n进化成速度更快的、基于 ASCII 码的\u003cstrong\u003e电传打印机\u003c/strong\u003e（teletype）。电传打印机曾通过一个称\n为 Telex 的网络实现全球互联，用于传递商业电报，但它们并没有连接到任何计算机（\ncomputers）。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/oldschool.jpg\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e20 世纪 40 年代的真实电传打印机（teletypes）\u003c/p\u003e\n\n\u003cp\u003e在同一时期，计算机 —— 虽然仍是很大很原始的机器，但能处理多任务（multitask）—— 开\n始 变得越来越强大，足以实现与用户的实时交互。\u003cstrong\u003e当命令行（command line）最终取代\n了老式的批处理模型（batch processing model）后，人们直接将电传打印机用作了计算\n机的输入和输出设备（input and output devices），因为这些设备在市场上很容易买到。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e但此时面临的一个问题是：\u003cstrong\u003e市场上有大量的电传打印机模型\u003c/strong\u003e，所有模型之间都有一些细\n微差别，因此就需要\u003cstrong\u003e某种层面的软件中间层来屏蔽这些差异\u003c/strong\u003e。Unix 世界中的方式是\n\u003cstrong\u003e让操作系统内核来处理所有的低层（low-level）细节\u003c/strong\u003e，例如 word 长度、波特率（baud\nrate）、流控（flow control）、奇偶校验（parity）、基本的行编辑（line editing）功\n能所用的控制码等等。而 20 世纪 70 年代随着例如 VT-100 这样的固态视频终端（solid\nstate video terminals）的出现而变成为现实的\u003cstrong\u003e光标炫酷移动、彩色输入和其他高级特\n性，则交给应用（application）来控制\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e如今在我们的世界中，物理电传打印机和视频终端事实上已经绝迹了。除非你去参观某个博\n物馆或者硬件爱好者的私藏，否则你能看到的所有 TTY 很可能都是\u003cstrong\u003e仿真（模拟）的视频\n终端\u003c/strong\u003e（emulated video terminals）——用软件去模拟真实硬件。但我们将会看到，这些传\n统的钢铁怪兽仍然潜伏在表面的平静之下。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"2-使用场景\"\u003e2. 使用场景\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/case1.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e用户（通过一个物理电传打印机）在一个终端上输入（打字）。这个终端通过一对电缆连接\n到计算机上的一个 \u003cstrong\u003eUART\u003c/strong\u003e（Universal Asynchronous Receiver and Transmitter，通用\n异步收发器）。操作系统中安装了 UART 驱动，能够\u003cstrong\u003e处理字节的物理传输\u003c/strong\u003e，包括奇偶校\n验和流控。在一个简陋的系统中，UART 驱动会\u003cstrong\u003e将收到的字节直接发送给某个应用进程\u003c/strong\u003e\n。但是，以上方式缺少下面几个必备特性。\u003c/p\u003e\n\n\u003ch2 id=\"21-行编辑line-editing\"\u003e2.1 行编辑（Line editing）\u003c/h2\u003e\n\n\u003cp\u003e大部分用户都难免在打字时犯错，因此\u003cstrong\u003e退格键\u003c/strong\u003e（backspace key）是很有必要的。\n这个功能当然可以由应用自己实现，但按照 Unix 的设计哲学，应用应该越简单越好。因此\n，为了方便，\u003cstrong\u003e操作系统\u003c/strong\u003e提供了一个\u003cstrong\u003e编辑缓冲区（editing buffer）\u003c/strong\u003e以及\u003cstrong\u003e一些基本\n的编辑命令\u003c/strong\u003e（退格、擦除单词、清除行、重新打印），这些功能在 line discipline（行\n规程）中是默认开启的。\u003c/p\u003e\n\n\u003ch3 id=\"line-discipline\"\u003eLine discipline\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e高级应用可以选择关闭这些特性\u003c/strong\u003e，只要将 line discipline 从默认（或 canonical）\n模式改为 raw 模式就行了。\u003cstrong\u003e大部分交互式应用（编辑器、邮件用户 agent、shell，以及\n所有依赖 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecurses\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadline\u003c/code\u003e 的程序）都运行在 raw 模式，自己来处理所有的行编辑\n命令\u003c/strong\u003e。line discipline 还包含了\u003cstrong\u003e字符回显（character echoing）\u003c/strong\u003e和\u003cstrong\u003e回车/换行（\ncarriage returns and linefeeds）自动转换\u003c/strong\u003e的功能。如果你愿意，可以将其想象成内核\n中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esed(1)\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e出于某些偶然的原因，\u003cstrong\u003e内核提供了多种 line discipline\u003c/strong\u003e。但在任何时刻，对于某个给\n定的串行设备，内核只会 attach 其中的一种到这个设备。\u003cstrong\u003e默认的 discipline\u003c/strong\u003e 叫\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eN_TTY\u003c/code\u003e（\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/drivers/tty/n_tty.c\"\u003edrivers/char/n_tty.c\u003c/a\u003e ——\n如果你喜欢刨根究底）。其他几种 disciplines用于不同目的，例如管理包交换数据（\npacket switched data，例如 ppp, IrDA, serial mice 等等），但这些超出了本文的范围。\u003c/p\u003e\n\n\u003ch2 id=\"22-会话管理session-management\"\u003e2.2 会话管理（Session management）\u003c/h2\u003e\n\n\u003cp\u003e用户可能希望同时运行多个程序，在不同时刻\n和不同的程序交互。如果一个程序进入无限循环，用户可能会杀掉或挂起这个程序。\n\u003cstrong\u003e后台（background）启动的程序如果执行到需要向终端写数据的地方，需要被挂起\u003c/strong\u003e。与\n此类似，\u003cstrong\u003e用户输入只应当被重定向到前台程序\u003c/strong\u003e（foreground program）。操作系统在\nTTY 驱动（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edrivers/char/tty_io.c\u003c/code\u003e）中实现了这些特性。\u003c/p\u003e\n\n\u003cp\u003e我们说一个操作系统进程“活着”（alive）时（有执行上下文），意味着这个进程能够执行\n动作（perform actions）。TTY 驱动并没有活着；用面向对象的术语来说，TTY 驱动是一\n个被动对象（passive object）。它有一些数据字段和方法，但只有当\n它在某个进程或某个内核中断处理函数的上下文中被调用时，它才能够执行。同样的，line\ndiscipline 也是一个被动实体（passive entity）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eUART 驱动、line discipline 实例和 TTY 驱动\u003c/mark\u003e\u003c/strong\u003e三者组成一个 \u003cstrong\u003e\u003cmark\u003eTTY 设备\u003c/mark\u003e\u003c/strong\u003e，\n有时简称为 TTY。用户进程能够通过操作 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/dev\u003c/code\u003e 目录下的相应设备文件来改变 TTY\n设备的行为。进程需要对设备文件有写权限，因此当一个\u003cstrong\u003e用户登陆到某个特定的 TTY 时\n，该用户必须成为相应设备文件的 owner\u003c/strong\u003e。传统上这是\u003cstrong\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elogin(1)\u003c/code\u003e 程序实现\u003c/strong\u003e的\n，该程序需要以 root 特权执行。\u003c/p\u003e\n\n\u003cp\u003e前面图中的物理线路当然也可以是一个长距离电话线路：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/case2.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在这张图中，除了系统此时也需要处理调制解调器（modem）的 hangup 情况之外，其他方\n面跟前一张没有太大区别。\u003c/p\u003e\n\n\u003cp\u003e接下来我们来看一个典型的桌面系统。下图展示的是 Linux console 是如何工作的：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/case3.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTTY 驱动和 line discipline 的行为和前面例子中的一样，但其中不再涉及 UART 或物理\n终端。与前面不同的地方在于，现在多了一个软件仿真的视频终端（一个复杂的状态机，包\n括一个字符帧缓冲区和一些图形字符属性），渲染到一个 VGA 显示器。\u003c/p\u003e\n\n\u003cp\u003e控制台（console）子系统某种程度上比较刻板。如果我们\u003cstrong\u003e将终端仿真放到用户空间（\nuserland），事情就会变得更加灵活（和抽象）\u003c/strong\u003e。下面是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exterm(1)\u003c/code\u003e 及其衍生版本如何\n工作的：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/case4.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e为了方便将终端模拟移到用户空间且同时保持 TTY 子系统（会话管理和 line\ndiscipline）的完整性\u003c/strong\u003e，人们引入了\u003cstrong\u003e伪终端（pseudo terminal）或称 pty\u003c/strong\u003e。\n你也许已经猜到了，当在伪终端内运行伪终端时（running pseudo terminals inside\npseudo terminals），事情会变得更加复杂，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003escreen(1)\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003essh(1)\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e现在让我们退后一步，来看一看这些东西是如何适配到进程模型的。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"3-进程\"\u003e3. 进程\u003c/h1\u003e\n\n\u003cp\u003e一个 Linux 进程可以处于以下几种状态之一：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/linuxprocess.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR\u003c/code\u003e: 运行中或可运行（Running or runnable (on run queue)）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eD\u003c/code\u003e: 不可中断睡眠（Uninterruptible sleep (waiting for some event)）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eS\u003c/code\u003e: 可中断睡眠（Interruptible sleep (waiting for some event or signal)）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eT\u003c/code\u003e: 停止（Stopped, either by a job control signal or because it is being traced by a debugger.）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eZ\u003c/code\u003e: 僵尸进程（Zombie process, terminated but not yet reaped by its parent.）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e运行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps l\u003c/code\u003e 可以看到各进程的状态。例如，如果是 sleeping 状态，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWCHAN\u003c/code\u003e 列（”wait\nchannel”，等待队列的名字）会显示\u003cstrong\u003e这个进程正在等待的内核事件\u003c/strong\u003e（kernel event）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eps l\nF   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND\n0   500  5942  5928  15   0  12916  1460 \u003cspan class=\"nb\"\u003ewait   \u003c/span\u003eSs   pts/14     0:00 -/bin/bash\n0   500 12235  5942  15   0  21004  3572 \u003cspan class=\"nb\"\u003ewait   \u003c/span\u003eS+   pts/14     0:01 vim index.php\n0   500 12580 12235  15   0   8080  1440 \u003cspan class=\"nb\"\u003ewait   \u003c/span\u003eS+   pts/14     0:00 /bin/bash \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003eps l\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e/tmp/v727757/1 2\u0026gt;\u0026amp;1\n0   500 12581 12580  15   0   4412   824 -      R+   pts/14     0:00 ps l\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e“wait” 等待队列（wait queue）和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewait(2)\u003c/code\u003e 系统调用相关，因此当这些进程的\n任何一个子进程有任何状态变化时，这些进程就会被移动到 running 状态。\u003c/p\u003e\n\n\u003cp\u003esleeping 状态有两种：可中断 sleep 和不可中断 sleep。可中断 sleep 最常见，它表示\n虽然该进程当前在 wait 队列中，但只要它收到信号，就可以被移动到 running 状态。如\n果查看内核源码，你会发现任何正在等待事件的内核代码都必须在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eschedule()\u003c/code\u003e 返回\n之后检查是否有信号 pending，如果有就 abort。\u003c/p\u003e\n\n\u003cp\u003e在上面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps\u003c/code\u003e 命令的输出结果中，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSTAT\u003c/code\u003e 列显式了每个进程的当前状态。除此之外，这一\n列还可能包含额外的属性或标记：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es\u003c/code\u003e：表示这个进程是 session leader\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e+\u003c/code\u003e：表示这个进程是一个前台进程组的一部分（part of a foreground process group）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这些属性用于作业控制（job control）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_4\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"4-作业jobs和会话\"\u003e4. 作业（Jobs）和会话\u003c/h1\u003e\n\n\u003cp\u003e当你\u003cstrong\u003e按下 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e 键\u003c/strong\u003e，或\u003cstrong\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026amp;\u003c/code\u003e 在后台启动一个程序\u003c/strong\u003e时，就是在进行\u003cstrong\u003e作业控制\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e作业和进程组的概念是一样的\u003c/strong\u003e（A job is the same as a process group）。shell 内\n置的命令，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejobs\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efg\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebg\u003c/code\u003e 等等可以用于\u003cstrong\u003e管理一个会话内已有的作业\u003c/strong\u003e。\u003cstrong\u003e每\n个 session 都是由一个 session leader 管理的，这个 session leader 就是 shell\u003c/strong\u003e ——\n通过一个复杂的信号协议和系统调用来和内核紧密协作。\u003c/p\u003e\n\n\u003cp\u003e下面的例子展示了进程、作业和会话之间的关系：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/exampleterm.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e上图中的 shell 交互对应下面的这些进程：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/examplediagram.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e以及下面这些内核结构：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eTTY Driver (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/dev/pts/0\u003c/code\u003e)\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  Size: 45x13                                           # 尺寸：45x13\n  Controlling process group: (101)                      # 控制进程组：101\n  Foreground process group: (103)                       # 前台进程组：103\n  UART configuration (ignored, since this is an xterm): # UART 配置（忽略，因为这是虚拟终端 xterm）\n    Baud rate, parity, word length and much more.\n  Line discipline configuration:                        # Line discipline 配置：\n    cooked/raw mode, linefeed correction,               #   cooked/raw 模式\n    meaning of interrupt characters etc.\n  Line discipline state:                                # Line discipline 状态：\n    edit buffer (currently empty),                      #   编辑缓冲区（当前为空）\n    cursor position within buffer etc.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epipe0\u003c/code\u003e\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  Readable end (connected to PID 104 as file descriptor 0) # 可读端（作为文件描述符 0 连接到 PID 104）\n  Writable end (connected to PID 103 as file descriptor 1) # 可写端（作为文件描述符 1 连接到 PID 103）\n  Buffer                                                   # 缓冲区\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这里的基本思想是：\u003cstrong\u003eevery pipeline is a job（每条流水线都是一个作业）\u003c/strong\u003e，因为每个\npipeline 内的进程都需要被同时操控（stopped, resumed, killed）。这也是为什么能够\n用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekill(2)\u003c/code\u003e 向一整个进程组发送信号的原因。默认情况下，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efork(2)\u003c/code\u003e 会将新创建出来\n的子进程放到与其父进程相同的进程组，因此，例如一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e 键就会同时影响到父子进程\n。但 shell 有些不同，作为其 session leader 职责的一部分，它每次创建一个 pipeline\n的时候都会创建一个新的进程组。\u003c/p\u003e\n\n\u003cp\u003eTTY 驱动跟踪记录前台进程组 ID（foreground process group id），但只会以\u003cstrong\u003e被动的方\n式跟踪\u003c/strong\u003e。当有必要时，\u003cstrong\u003esession leader 必须显式更新这项信息\u003c/strong\u003e。类似地，TTY 驱动\n也会以被动的方式跟踪所连接的终端的尺寸大小（size），但这个信息必须由终端模拟器甚\n至用户来显式更新。\u003c/p\u003e\n\n\u003cp\u003e前面的图中可以看到，几个不同进程都将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/dev/pts/0\u003c/code\u003e attach 到了它们的标准输入。但\n只有前台任务（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003els | sort\u003c/code\u003e pipeline）会从 TTY 接收输入。类似地，只有前台作业是允\n许写到 TTY 设备的（在默认配置下）。如果图中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat\u003c/code\u003e 进程试图写到该 TTY，内核会通\n过一个信号挂起它。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_5\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"5-简单粗暴的信号机制\"\u003e5. 简单粗暴的信号机制\u003c/h1\u003e\n\n\u003cp\u003e现在让我们来更加近距离地看看内核中的 TTY 驱动、line discipline 和 UART 驱动\n是如何与用户空间进程通信的。\u003c/p\u003e\n\n\u003cp\u003eUNIX 文件，包括 TTY 设备文件，都可以被读取或写入，以及通过神奇的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl(2)\u003c/code\u003e（\nUNIX 中的瑞士军刀）系统调用进一步操作，内核中已经为 TTY 设备实现了很多相关的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl\u003c/code\u003e 操作。但是，\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl\u003c/code\u003e 请求必须从进程（向内核）发起，因此当内核（主动）希\n望异步地与应用进行通信时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl\u003c/code\u003e 就不适用了\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e在《银河系漫游指南》中， Douglas Adams 描述了一个极其迟钝的星球，上面居住了一群\n意志消沉的人以及一种带有锋利牙齿的动物，后者与前者交谈的方式就是用力撕咬他们的大\n腿。\u003cstrong\u003e这与 UNIX 非常相似\u003c/strong\u003e，因为内核与进程通信的方式就是向进程发送能使之瘫痪或致\n命的信号。进程可能会捕获其中某些信号，然后尝试解决遇到的问题，但大部分信号都是没\n有被捕获的。\u003c/p\u003e\n\n\u003cp\u003e因此，\u003cstrong\u003e信号是一种粗暴的内核与应用进程异步通信的机制\u003c/strong\u003e。UNIX 中信号的设计并不整\n洁或通用；每个信号都是唯一的，因此必须逐个研究。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekill -l\u003c/code\u003e 命令可以查看当前系统已经实现了哪些信号。这个命令的输出可能与下面的类似\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ kill -l\n 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n 9) SIGKILL      10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n13) SIGPIPE      14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n17) SIGCHLD      18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n21) SIGTTIN      22) SIGTTOU     23) SIGURG      24) SIGXCPU\n25) SIGXFSZ      26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n29) SIGIO        30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n35) SIGRTMIN+1   36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n39) SIGRTMIN+5   40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9   44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13  52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9   56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n59) SIGRTMAX-5   60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1   64) SIGRTMAX    \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如上所示，信号是从 1 开始编码的。但如果是掩码（bitmask）形式表示（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps s\u003c/code\u003e 的\n输出中），最不重要比特（least significant bit）表示的是 1。\u003c/p\u003e\n\n\u003cp\u003e本文将关下面几信号：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIHUP\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGIT\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGQUI\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGPIPE\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e SIGCHLD\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGSTOP\u003c/code\u003e\n、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e SIGCONT\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e SIGTSTP\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e SIGTTIN\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGWINCH\u003c/code\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGHUP\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Terminate\u003c/li\u003e\n      \u003cli\u003e可能动作：Terminate, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e当\u003cstrong\u003e检测到 hangup\u003c/strong\u003e 时，\u003cstrong\u003eUART 驱动\u003c/strong\u003e会向\u003cstrong\u003e整个 session\u003c/strong\u003e 发送 SIGHUP 信号。\n  正常情况下，这会 kill 掉所有进程。某些程序，例如\n  \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enohup(1)\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003escreen(1)\u003c/code\u003e，会从他们的 session（和 TTY）中  detach 出来\u003c/strong\u003e，\n  因此这些程序的子进程无法关注到 hangup 事件。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Terminate\u003c/li\u003e\n      \u003cli\u003e可能动作：Terminate, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e当输入流中出现\u003cstrong\u003einteractive attention character\u003c/strong\u003e（交互式注意字符，通常是\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e，ASCII 码是 3）时，\u003cstrong\u003eTTY 驱动\u003c/strong\u003e会向\u003cstrong\u003e当前的前台\u003c/strong\u003e作业发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e 信号\n  ，除非这个特性被关闭了。任何对 TTY 设备有权限的人都可以修改 the interactive\n  attention character 或打开/关闭这个特性；另外，\u003cstrong\u003e会话管理器（session manager）\n  跟踪记录每个作业的 TTY 配置，当发生作业切换时会更新 TTY\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGQUIT\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Core dump\u003c/li\u003e\n      \u003cli\u003e可能动作：Core dump, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGQUIT\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e 类似，但 quit 字符通常是 ^\\，而且默认动作不同。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGPIPE\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Terminate\u003c/li\u003e\n      \u003cli\u003e可能动作：Terminate, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e对于每个尝试\u003cstrong\u003e向没有 reader 的 piepe 写数据的进程\u003c/strong\u003e，内核会向其发送\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGPIPE\u003c/code\u003e 信号。这很有用，因为如果没有这个信号，某些作业就无法终止。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCHLD\u003c/code\u003e\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Ignore\u003c/li\u003e\n      \u003cli\u003e可能动作：Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e当一个进程死掉或状态发生改变时（stop/continue），内核会向其父进程发送此信号\n  。该信号还附带了其他信息，即该进程的进程 ID、用户 ID、退出状态码（或终止信号）\n  以及其他一些执行时统计信息（execution time statistics）。session leader 使用\n  这个信号跟踪它的作业。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGSTOP\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Suspend\u003c/li\u003e\n      \u003cli\u003e可能动作：Suspend\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e该信号会无条件地挂起信号接受者，例如，该信号的动作是不能被重新配置的（\n  reconfigure）。但要注意，该信号并不是在作业控制（job control）期间被内核发送\n  的。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e 通常情况下触发的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e 信号，这个信号是可以被应用捕获的。例如\n  ，应用可以将光标移动到屏幕底部，或者将终端置于某个已知状态，随后通过\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGSTOP\u003c/code\u003e 将自己置于 sleep 状态。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Wake up\u003c/li\u003e\n      \u003cli\u003e可能动作：Wake up, Wake up + Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e该信号会唤醒（un-suspend）一个已经 stop 的进程。\u003cstrong\u003e用户执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efg\u003c/code\u003e 命令时，\n  shell 会显式地发送这个信号\u003c/strong\u003e。由于应用无法捕获该信号，因此如果出现未预期的\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e 信号，可能就表示某些进程在一段时间之前被挂起了，现在挂起被解除了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Suspend\u003c/li\u003e\n      \u003cli\u003e可能动作：Suspend, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e该信号与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGQUIT\u003c/code\u003e 类似，但对应的\u003cstrong\u003e魔法字符通常是\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e，默认动作是挂起进程\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTIN\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Suspend\u003c/li\u003e\n      \u003cli\u003e可能动作：Suspend, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e如果一个后台作业中的进程尝试读取一个 TTY 设备，TTY 会发送该信号给整个作业。\n  正常情况下这会挂起作业。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Suspend\u003c/li\u003e\n      \u003cli\u003e可能动作：Suspend, Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e如果一个后台作业中的进程尝试写一个 TTY 设备，TTY 会发送该信号给整个作业。\n  正常情况下这会挂起作业。可以在 per-TTY 级别打开或关闭这个特性。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGWINCH\u003c/code\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认动作：Ignore\u003c/li\u003e\n      \u003cli\u003e可能动作：Ignore, Function call\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e前面提到，TTY 设备会跟踪记录终端的尺寸（size），但这个信息需要手动更新。\n  \u003cstrong\u003e当终端尺寸发送变化时，TTY 设备会向前台作业发送该信号\u003c/strong\u003e。行为良好的交互式应用，\n  例如编辑器，会对此作出响应：从 TTY 设备获取新的终端尺寸，然后根据该信息重绘自己。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"ch_6\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"6-一个例子\"\u003e6. 一个例子\u003c/h1\u003e\n\n\u003cp\u003e设想你在用自己的（基于终端的）编辑器编辑某个文件。光标当前位于屏幕中央，编辑器正\n忙于执行某些 CPU 密集型任务，例如在一个大文件中执行搜索或替换操作。现在假设你按\n下了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e 键。因为 line discipline 已经配置了捕获此字符（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e 是单个字节，ASCII 码\n为 26），因此你无需等待编辑器完成它正在执行的任务然后开始从 TTY 设备读取数据。\u003c/p\u003e\n\n\u003cp\u003e此时的情况是，\u003cstrong\u003eline discipline 子系统会立即向前台进程组发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e 信号\u003c/strong\u003e。\n这个进程组中包括编辑器进程，以及它创建出来的任何子进程。\u003c/p\u003e\n\n\u003cp\u003e编辑器为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e 进程注册了信号处理函数，因此内核此时开始执行该\u003cstrong\u003e信号处理函数\u003c/strong\u003e\n的代码。该代码通过\u003cstrong\u003e向 TTY 设备写入相应的控制序列\u003c/strong\u003e（control sequences），\u003cstrong\u003e将\n光标移动到屏幕最后一行\u003c/strong\u003e。由于编辑器仍然在前台，这个控制序列能够正常发送出去（给\nTTY）。但之后，编辑器会\u003cstrong\u003e给自己所在的进程组发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGSTOP\u003c/code\u003e 信号\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e编辑器此时就被挂起（stop）了。这个事件会通过一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCHLD\u003c/code\u003e 信号发送给 session leader，\n其中包括了被挂起进程的进程 ID。当前台作业中的所有进程都被挂起后，session leader\n从 TTY 设备中读取当前配置，保存以备后面恢复时用。session leader 使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl\u003c/code\u003e 系\n统调用，继续将自己注册（install itself）为该 TTY 的当前前台进程组。然后，它打印\n出类似 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;[1]+ Stopped\u0026#34;\u003c/code\u003e 之类的信息，告知用户有一个作业刚被挂起了。\u003c/p\u003e\n\n\u003cp\u003e此时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps(1)\u003c/code\u003e 会告诉你编辑器进程当前处于 stopped state (“T”)。如果我们试图唤醒它\n，不管是通过 shell 内置的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebg\u003c/code\u003e 命令，还是使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekill(1)\u003c/code\u003e 发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e 信号给进程\n，都会触发编辑器执行它的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e 信号处理函数。该信号处理函数可能会尝试通过写\nTTY 设备来重绘编辑器 GUI。但由于此时编辑器是后台作业，TTY 设备是不允许其写入的。\n这种情况下 TTY 会给编辑器发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e 信号，再次将其 stop。这个事件会通过\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCHLD\u003c/code\u003e 信号通知到 session leader，然后 shell 会再次将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;[1]+ Stopped\u0026#34;\u003c/code\u003e 之类的\n消息写到终端。\u003c/p\u003e\n\n\u003cp\u003e但当我们输入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efg\u003c/code\u003e 命令时，shell 首先会恢复此前保存的 line discipline 配置。\n然后，它通知 TTY 驱动从现在开始编辑器作业应当被作为前台作业对待了。最后，它发送\n一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e 信号给进程组。编辑器进程尝试重绘 GUI，而这一次它不会被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e\n中断了，因为它现在是前台作业的一部分了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e（译者）总结：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e使用编辑器编辑文件。\u003c/li\u003e\n    \u003cli\u003e按 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Z\u003c/code\u003e 键 -\u0026gt; 唤醒 line discipline。\u003c/li\u003e\n    \u003cli\u003eline discipline -\u0026gt; 前台进程组：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e。\u003c/li\u003e\n    \u003cli\u003e编辑器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e 信号处理函数 -\u0026gt; TTY：写入控制序列，将光标移动到最后屏幕一行\u003c/li\u003e\n    \u003cli\u003e编辑器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTSTP\u003c/code\u003e 信号处理函数 -\u0026gt; 自己所在的进程组：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGSTOP\u003c/code\u003e。\u003c/li\u003e\n    \u003cli\u003e编辑器被挂起（stop）。这个事件会通过一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCHLD\u003c/code\u003e 信号发送给 session\nleader，其中包括了被挂起进程的进程 ID。\u003c/li\u003e\n    \u003cli\u003e前台进程组中的所有进程都被挂起，session leader 从 TTY 中读取当前配置并保存\u003c/li\u003e\n    \u003cli\u003esession leader 使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl\u003c/code\u003e 系统调用，继续将自己注册（install itself）为该\nTTY 的当前前台进程组。然后，它打印出类似 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;[1]+ Stopped\u0026#34;\u003c/code\u003e 之类的信息，告知\n用户有一个作业刚被挂起了。\u003c/li\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebg\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekill -SIGCONT\u003c/code\u003e 给编辑器发信号：编辑器会尝试写 TTY 来重绘窗口，但此\n时编辑器进程是后台进程，不允许写 TTY，因此 TTY 会给其发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e 信号，\n再次将其 stop；这个事件会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCHLD\u003c/code\u003e 信号告知 session leader，后者再次将\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1]+ Stopped\u003c/code\u003e 信息写到终端。\u003c/li\u003e\n    \u003cli\u003e但当我们输入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efg\u003c/code\u003e 命令时，shell 会恢复此前保存的 line discipline 配置。然\n后通知 TTY 驱动编辑器进程现在是前台进程了。最后，它发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGCONT\u003c/code\u003e 信号\n给进程组恢复编辑器的执行。\u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca name=\"ch_7\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"7-流控和阻塞式-io\"\u003e7. 流控和阻塞式 I/O\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/dsc00043.jpg\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在 xterm 中执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eyes\u003c/code\u003e 命令，你会看到大量的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;yes\u0026#34;\u003c/code\u003e 一行一行地快速闪过。正常情况\n下条，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eyes\u003c/code\u003e 进程产生 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;yes\u0026#34;\u003c/code\u003e 输出的速度要远快于 xterm 应用解析这些行、更新帧缓冲\n区、与 X server 通信来滚动窗口等等的速度。那么，\u003cstrong\u003e这些进程之间是如何协作的呢\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答案就是 blocking I/O\u003c/strong\u003e（阻塞式输入/输出）。伪终端只能在其内核缓冲区中保存一定量\n的数据，当缓冲区已经填满而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eyes\u003c/code\u003e 程序仍然调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(2)\u003c/code\u003e 写入时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(2)\u003c/code\u003e 会阻\n塞，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eyes\u003c/code\u003e 进程会被移入可中断 sleep 状态，直到 xterm 进程读走了一部分缓存的数据。\u003c/p\u003e\n\n\u003cp\u003e当 TTY 连接到的是串口（serial port）时，过程与此类似。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eyes\u003c/code\u003e 能够以很快的速度\n发送数据，例如 9600 波特，但如果串口速度比这个低，内核缓冲区很快就会塞满，随后的\n任何 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(2)\u003c/code\u003e 调用都会阻塞写进程（或者返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAGAIN\u003c/code\u003e 错误码 —— 如果进程请求的是非\n阻塞 I/O）。\u003c/p\u003e\n\n\u003cp\u003e如果我告诉你，我们能够\u003cstrong\u003e显式地将 TTY 置于阻塞状态\u003c/strong\u003e，即使内核缓冲区中仍然有可用\n空间呢？这样设置之后，每个进程调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(2)\u003c/code\u003e 进行写入时，TTY 都会自动阻塞。但\n\u003cstrong\u003e什么情况下回用到这个特性呢\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e设想我们正在以 9600 波特和某个陈旧的 VT-100 硬件通信。我们刚发送了一个复杂的控制\n序列要求终端滚动显示页面。此时，终端忙于执行滚动操作，无法以全速 9600 波特接收新\n的数据。这种情况下，在物理上，终端 UART 仍然运行在 9600 波特，但缓冲区中没有足够\n的空间来给终端存储接收到的数据。这就是一个将 TTY 置于阻塞状态的好时机。那么\u003cstrong\u003e要实\n现这个效果，我们该怎么做呢\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e前面已经看到，可以\u003cstrong\u003e配置 TTY 设备对某些特定的数据给予特殊对待\u003c/strong\u003e。例如，在默认配\n置中，TTY 收到的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e 字符并不会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eread(2)\u003c/code\u003e 直接交给应用，而是会触发发送一个\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e 信号给前台作业。类似地，可以配置 TTY 对 \u003cstrong\u003estop flow byte\u003c/strong\u003e（停止流字节）\n和\u003cstrong\u003estart flow byte\u003c/strong\u003e（开始流字节）做出响应。通常情况下，这\u003cstrong\u003e分别是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^S\u003c/code\u003e (ASCII\ncode 19) 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^Q\u003c/code\u003e (ASCII code 17)\u003c/strong\u003e。老式硬件终端能自动发送这些字节，然后期待操作\n系统能够按照约定对它的数据流进行管控。这个过程称为\u003cstrong\u003e流控\u003c/strong\u003e（flow control），这也是\n\u003cstrong\u003e为什么有时你误按了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^S\u003c/code\u003e 时，你的 xterm 会锁定的原因\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这里要区分两种情况：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e向一个由于流控或内核缓冲空间不足而 stop 的 TTY 写入\u003c/strong\u003e：写入进程会被阻塞（block）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e从后台作业向一个 TTY 写入\u003c/strong\u003e：会导致 TTY 发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e 给整个进程组将其挂起（suspend）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e我不清楚 UNIX 的设计者为何发明 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTOU\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTTIN\u003c/code\u003e 而不是依靠 blocking I/O，\n我尽己所能猜到的原因是：负责着作业控制（job control）的 TTY 驱动，设计用于监控和\n操作全部作业，而不是作业内的单个进程。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_8\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"8-配置-tty-设备\"\u003e8. 配置 TTY 设备\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/tty-demystified/cockpit.jpg\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e要确定当前 shell 的 TTY，可以通过我们前面介绍的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps l\u003c/code\u003e 命令，或者直接运行\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etty(1)\u003c/code\u003e 命令。\u003c/p\u003e\n\n\u003cp\u003e一个进程可能会\u003cstrong\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eioctl(2)\u003c/code\u003e 读取或修改一个已经打开的 TTY 设备\u003c/strong\u003e。相应的 API\n在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etty_ioctl(4)\u003c/code\u003e 中作了描述。由于这是 Linux 应用和内核之间的二进制接口的一部分，\n因此它在不同的 Linux 版本之间是保持稳定的。但是，\u003cstrong\u003e这个接口是不可移植的\u003c/strong\u003e，若想编\n写可移植的程序，应用应当使用 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etermios(3)\u003c/code\u003e man page 中提供的 POSIX wrapper\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这里我不会深入介绍 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etermios(3)\u003c/code\u003e 接口，但如果你正在编写 C 程序，涉及到捕获 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e、\n关闭行编辑或字符回显、修改串口的波特率、关闭流控等等工作，那你就需要去阅读前面提\n到的 man page。\u003c/p\u003e\n\n\u003cp\u003e另外还有一个\u003cstrong\u003e命令行工具 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty(1)\u003c/code\u003e，用于操纵 TTY 设备\u003c/strong\u003e。它使用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etermios(3)\u003c/code\u003e API。\u003c/p\u003e\n\n\u003cp\u003e我们来试试！\u003c/p\u003e\n\n\u003ch2 id=\"tty-配置选项\"\u003eTTY 配置选项\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty -a\u003c/code\u003e 打印所有配置项。默认打印的是当前 shell 所 attach 的 TTY 设备配置项，但\n可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-F\u003c/code\u003e 指定其他设备。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty\u003c/span\u003e \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e\nspeed 38400 baud\u003cspan class=\"p\"\u003e;\u003c/span\u003e rows 73\u003cspan class=\"p\"\u003e;\u003c/span\u003e columns 238\u003cspan class=\"p\"\u003e;\u003c/span\u003e line \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\u003cspan class=\"p\"\u003e;\u003c/span\u003e\nintr \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^C\u003cspan class=\"p\"\u003e;\u003c/span\u003e quit \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^\u003cspan class=\"se\"\u003e\\;\u003c/span\u003e erase \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^?\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003ekill\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^U\u003cspan class=\"p\"\u003e;\u003c/span\u003e eof \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^D\u003cspan class=\"p\"\u003e;\u003c/span\u003e eol \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u0026lt;undef\u0026gt;\u003cspan class=\"p\"\u003e;\u003c/span\u003e eol2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u0026lt;undef\u0026gt;\u003cspan class=\"p\"\u003e;\u003c/span\u003e swtch \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u0026lt;undef\u0026gt;\u003cspan class=\"p\"\u003e;\u003c/span\u003e start \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^Q\u003cspan class=\"p\"\u003e;\u003c/span\u003e stop \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^S\u003cspan class=\"p\"\u003e;\u003c/span\u003e susp \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^Z\u003cspan class=\"p\"\u003e;\u003c/span\u003e rprnt \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^R\u003cspan class=\"p\"\u003e;\u003c/span\u003e werase \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^W\u003cspan class=\"p\"\u003e;\u003c/span\u003e lnext \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^V\u003cspan class=\"p\"\u003e;\u003c/span\u003e flush \u003cspan class=\"o\"\u003e=\u003c/span\u003e ^O\u003cspan class=\"p\"\u003e;\u003c/span\u003e min \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003etime\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e-parenb\u003c/span\u003e \u003cspan class=\"nt\"\u003e-parodd\u003c/span\u003e cs8 \u003cspan class=\"nt\"\u003e-hupcl\u003c/span\u003e \u003cspan class=\"nt\"\u003e-cstopb\u003c/span\u003e cread \u003cspan class=\"nt\"\u003e-clocal\u003c/span\u003e \u003cspan class=\"nt\"\u003e-crtscts\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e-ignbrk\u003c/span\u003e brkint ignpar \u003cspan class=\"nt\"\u003e-parmrk\u003c/span\u003e \u003cspan class=\"nt\"\u003e-inpck\u003c/span\u003e \u003cspan class=\"nt\"\u003e-istrip\u003c/span\u003e \u003cspan class=\"nt\"\u003e-inlcr\u003c/span\u003e \u003cspan class=\"nt\"\u003e-igncr\u003c/span\u003e icrnl ixon \u003cspan class=\"nt\"\u003e-ixoff\u003c/span\u003e \u003cspan class=\"nt\"\u003e-iuclc\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ixany\u003c/span\u003e imaxbel \u003cspan class=\"nt\"\u003e-iutf8\u003c/span\u003e\nopost \u003cspan class=\"nt\"\u003e-olcuc\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ocrnl\u003c/span\u003e onlcr \u003cspan class=\"nt\"\u003e-onocr\u003c/span\u003e \u003cspan class=\"nt\"\u003e-onlret\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ofill\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ofdel\u003c/span\u003e nl0 cr0 tab0 bs0 vt0 ff0\nisig icanon iexten \u003cspan class=\"nb\"\u003eecho \u003c/span\u003eechoe echok \u003cspan class=\"nt\"\u003e-echonl\u003c/span\u003e \u003cspan class=\"nt\"\u003e-noflsh\u003c/span\u003e \u003cspan class=\"nt\"\u003e-xcase\u003c/span\u003e \u003cspan class=\"nt\"\u003e-tostop\u003c/span\u003e \u003cspan class=\"nt\"\u003e-echoprt\u003c/span\u003e echoctl echoke\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上选项中，某些是 UART 参数；某些影响 line discipline，某些用于作业控制。我们先\n来看第一行：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003espeed\u003c/code\u003e\n    \u003cul\u003e\n      \u003cli\u003eUART 参数\u003c/li\u003e\n      \u003cli\u003e波特率。伪终端忽略此选项。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erows\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecolumns\u003c/code\u003e\n    \u003cul\u003e\n      \u003cli\u003eTTY 驱动参数\u003c/li\u003e\n      \u003cli\u003eattach 到这个 TTY 设备的终端大小（size），单位是字符数。本质上这只是内核空\n间中的一对变量，可以随意修改和读取。修改这两个参数会触发 TTY 驱动发送\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGWINCH\u003c/code\u003e 信号给前台作业。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eline\u003c/code\u003e\n    \u003cul\u003e\n      \u003cli\u003eLine discipline 参数\u003c/li\u003e\n      \u003cli\u003e表示 attach 到这个 TTY 的 line discipline。0 代表 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eN_TTY\u003c/code\u003e。所有的合法值列在\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/tty/ldiscs\u003c/code\u003e 下面。未列出的值似乎是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eN_TTY\u003c/code\u003e 的 alias，但不依赖前者。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"修改窗口尺寸\"\u003e修改窗口尺寸\u003c/h2\u003e\n\n\u003cp\u003e尝试下面的例子：开启一个 xterm。记录下它的 TTY 设备（执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etty\u003c/code\u003e 命令查看）以及尺\n寸（执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty -a\u003c/code\u003e 命令查看）。在 xterm 中启动 vim（或其他全屏终端应用）。编辑器会询问 TTY 设\n备当前的终端尺寸，以填充整个窗口。\u003c/p\u003e\n\n\u003cp\u003e现在，在另一个 shell 窗口中执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty\u003c/span\u003e \u003cspan class=\"nt\"\u003e-F\u003c/span\u003e X rows Y\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 X 是 TTY 设备，Y 是终端高度的一半。这条命令会更新内核内存中的 TTY 配置数据\n，并触发向编辑器发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGWINCH\u003c/code\u003e 信号；vim 收到信号会立即重绘自身，结果是编辑\n器的高度减半。\u003c/p\u003e\n\n\u003ch2 id=\"修改-sigint-对应的控制字符\"\u003e修改 SIGINT 对应的控制字符\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty -a\u003c/code\u003e 命令的输出中，第二行列出了所有的特殊字符。\u003c/p\u003e\n\n\u003cp\u003e打开一个新 xterm 然后尝试：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty \u003c/span\u003eintr o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在输入字符 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eo\u003c/code\u003e —— 而不是原来默认的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e —— 会触发发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGINT\u003c/code\u003e 信号给前台作业。\u003c/p\u003e\n\n\u003cp\u003e你可以运行着某个命令，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat\u003c/code\u003e，然后验证此时 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^C\u003c/code\u003e 是不能终止其执行的。然后，再\n试试输入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehello\u003c/code\u003e 给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"退格键无法使用\"\u003e退格键无法使用\u003c/h2\u003e\n\n\u003cp\u003e某些场合下，你可能会在某个 UNIX 系统上遇到退格键无法使用的情况。\u003c/p\u003e\n\n\u003cp\u003e发生这种情况是因为\u003cstrong\u003e终端模拟器发送的退格码\u003c/strong\u003e（不管是 ASCII 8 还是 127）\u003cstrong\u003e与 TTY\n设备中的擦除设置（erase setting）不匹配\u003c/strong\u003e。要解决这个问题，通常需要\u003cstrong\u003e输入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty\u003c/code\u003e\n擦除 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^H\u003c/code\u003e（ASCII 8）或 stty erase \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^?\u003c/code\u003e（ASCII 127）\u003c/strong\u003e。但请记住，某些终端应用使\n用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadline\u003c/code\u003e，它们会将 line discipline 置于 raw 模式，这些应用不会受此影响。\u003c/p\u003e\n\n\u003ch2 id=\"tty-开关项\"\u003eTTY 开关项\u003c/h2\u003e\n\n\u003cp\u003e最后，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty -a\u003c/code\u003e 列出了一系列的开关。这些开关并没有先后顺序。某些与 UART 相关，某\n些影响 line discipline 行为，某些用于流控，某些用于作业控制。有减号（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-\u003c/code\u003e）表示该\n开关当前是关闭的；否则就是打开的。所有开关都在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty(1)\u003c/code\u003e man page 中有解释，因此\n这里只是简要介绍几个：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eicanon\u003c/code\u003e 打开/关闭 canonical (line-based) 模式。尝试在一个新 xterm 内运行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty\u003c/span\u003e \u003cspan class=\"nt\"\u003e-icanon\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e \n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e执行这条命令后，所有的行编辑字符，例如退格和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^U\u003c/code\u003e 将无法使用。你会注意到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat\u003c/code\u003e 此\n时开始按字符接收（以及打印）内容，而不是像之前一样按行。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eecho\u003c/code\u003e 打开字符回显（character echoing），这个选项默认是打开的。重新启用\ncanonical mode（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty icanon\u003c/code\u003e），然后执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty\u003c/span\u003e \u003cspan class=\"nt\"\u003e-echo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e输入命令时，终端模拟器会将命令信息发送给内核。通常情况下，内核会将相同的信息回显给\n终端模拟器，这样我们就可以看到自己输入的内容了。没有字符回显的话，我们无法看到自己输\n入的内容，但由于我们在 cooked 模式，因此行编辑设施还是仍然工作的。当按下回车键\n时，line discipline 会将编辑缓冲区发送给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat\u003c/code\u003e，后者就会显示输入的内容。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etostop\u003c/code\u003e 控制是否允许后台作业写终端。首先尝试：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estty \u003c/span\u003etostop\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003esleep \u003c/span\u003e5\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho \u003c/span\u003ehello, world\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u0026amp;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026amp;\u003c/code\u003e 使得前面的进程以后台作业的方式执行。5 秒之后，该作业会尝试写 TTY。TTY 驱动会\n使用 SIGTTOU 来挂起该进程，shell 可能会报告这个结果，可能是立即，也可能是某个时\n候弹出一个提醒框。现在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekill\u003c/code\u003e 掉后台作业，执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nb\"\u003estty\u003c/span\u003e \u003cspan class=\"nt\"\u003e-tostop\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003esleep \u003c/span\u003e5\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho \u003c/span\u003ehello, world\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u0026amp;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上命令会重新打开输入回显功能；5 秒之后，后台作业发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehello, world\u003c/code\u003e 给终端，此\n时不管你正在输入什么，这句话都会打印出来。\u003c/p\u003e\n\n\u003cp\u003e最后，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estty sane\u003c/code\u003e 会将 TTY 设备恢复到某个合理的配置。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_9\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"9-结束语\"\u003e9. 结束语\u003c/h1\u003e\n\n\u003cp\u003e本文提供了 TTY 驱动和 line discipline 相关的知识，以及它们和终端、行编辑及作业控\n制的联系，希望这些内容足够读者对它们有一个了解。更多信息请参考前面提到的几个 man\npage，以及 glibc 手册（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003einfo libc\u003c/code\u003e，”Job Control”）。\u003c/p\u003e\n\n\u003cp\u003e最后，感谢阅读！\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cracking-k8s-node-proxy/\"\u003e\u003cspan\u003e« Cracking Kubernetes Node Proxy (aka kube-proxy)\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/utf-8-history-zh/\"\u003e\u003cspan\u003e[译] 拨乱反正：Ken Thompson 才是 UTF-8 的设计者（2003） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-12-08T00:00:00Z",
  "Author": "Arthur Chiao"
}