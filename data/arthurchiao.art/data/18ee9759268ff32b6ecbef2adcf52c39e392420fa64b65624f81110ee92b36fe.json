{
  "Source": "arthurchiao.art",
  "Title": "[译] [论文] BBR：基于拥塞（而非丢包）的拥塞控制（ACM, 2017）",
  "Link": "https://arthurchiao.art/blog/bbr-paper-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] [论文] BBR：基于拥塞（而非丢包）的拥塞控制（ACM, 2017）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-01-02 | Last Update 2022-01-02\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 Google 2017 的论文：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eCardwell N, Cheng Y, Gunn CS, Yeganeh SH, Jacobson V.\n\u003ca href=\"https://queue.acm.org/detail.cfm?id=3022184\"\u003eBBR: congestion-based congestion control\u003c/a\u003e.\nCommunications of the ACM. 2017 Jan 23;60(2):58-66.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e论文副标题：Measuring \u003cstrong\u003e\u003cmark\u003eB\u003c/mark\u003e\u003c/strong\u003eottleneck \u003cstrong\u003e\u003cmark\u003eB\u003c/mark\u003e\u003c/strong\u003eandwidth and\n\u003cstrong\u003e\u003cmark\u003eR\u003c/mark\u003e\u003c/strong\u003eound-trip propagation time（测量瓶颈带宽和往返传输时间）。\u003c/p\u003e\n\n\u003cp\u003eBBR 之前，主流的 TCP 拥塞控制算法都是基于\u003cstrong\u003e\u003cmark\u003e丢包\u003c/mark\u003e\u003c/strong\u003e（loss-based）设计的，\n这一假设最早可追溯到上世纪八九十年代，那时的链路带宽和内存容量分别以 Mbps 和 KB\n计，链路质量（以今天的标准来说）也很差。\u003c/p\u003e\n\n\u003cp\u003e三十年多后，这两个物理容量都已经增长了至少六个数量级，链路质量也不可同日而语。特别地，在现代基础设施中，\n\u003cstrong\u003e\u003cmark\u003e丢包和延迟不一定表示网络发生了拥塞\u003c/mark\u003e\u003c/strong\u003e，因此原来的假设已经不再成立。\nGoogle 的网络团队从这一\u003cstrong\u003e\u003cmark\u003e根本问题\u003c/mark\u003e\u003c/strong\u003e出发，（在前人工作的基础上）\n设计并实现了一个\u003cstrong\u003e\u003cmark\u003e基于拥塞本身\u003c/mark\u003e\u003c/strong\u003e而非基于丢包或延迟的拥塞控制新算法，缩写为 BBR。\u003c/p\u003e\n\n\u003cp\u003e简单来说，BBR 通过\u003cstrong\u003e\u003cmark\u003e应答包（ACK）中的 RTT 信息\u003c/mark\u003e\u003c/strong\u003e和已发送字节数来计算\n\u003cstrong\u003e\u003cmark\u003e真实传输速率\u003c/mark\u003e\u003c/strong\u003e（delivery rate），然后根据后者来调节客户端接下来的\n\u003cstrong\u003e\u003cmark\u003e发送速率\u003c/mark\u003e\u003c/strong\u003e（sending rate），通过保持合理的 inflight 数据量来使\n\u003cstrong\u003e\u003cmark\u003e传输带宽最大、传输延迟最低\u003c/mark\u003e\u003c/strong\u003e。另外，它完全运行在发送端，无需协议、\n接收端或网络的改动，因此落地相对容易。\u003c/p\u003e\n\n\u003cp\u003eGoogle 的全球广域网（B4）在 2016 年就已经将全部 TCP 流量从 CUBIC 切换到 BBR，\n吞吐提升了 2~25 倍；在做了一些配置调优之后，甚至进一步提升到了 133 倍（文中有详细介绍）。\u003c/p\u003e\n\n\u003cp\u003eLinux 实现：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003einclude/uapi/linux/inet_diag.h\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet/ipv4/tcp_bbr.c\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e翻译时适当加入了一些小标题，另外插入了一些内核代码片段（基于内核 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.10\u003c/code\u003e），以更方便理解。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-拥塞和瓶颈congestion-and-bottlenecks\" id=\"markdown-toc-1-拥塞和瓶颈congestion-and-bottlenecks\"\u003e1 拥塞和瓶颈（Congestion and Bottlenecks）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-两个物理特性传输时延rtprop和瓶颈带宽btlbw\" id=\"markdown-toc-11-两个物理特性传输时延rtprop和瓶颈带宽btlbw\"\u003e1.1 两个物理特性：传输时延（RTprop）和瓶颈带宽（BtlBw）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-传输时延瓶颈带宽与-inflight-数据量的关系\" id=\"markdown-toc-12-传输时延瓶颈带宽与-inflight-数据量的关系\"\u003e1.2 传输时延/瓶颈带宽与 inflight 数据量的关系\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-以上关系的进一步解释\" id=\"markdown-toc-13-以上关系的进一步解释\"\u003e1.3 以上关系的进一步解释\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-拥塞和拥塞控制的直观含义\" id=\"markdown-toc-14-拥塞和拥塞控制的直观含义\"\u003e1.4 拥塞和拥塞控制的直观含义\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-基于丢包的拥塞控制工作机制\" id=\"markdown-toc-15-基于丢包的拥塞控制工作机制\"\u003e1.5 基于丢包的拥塞控制工作机制\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#16-更好的工作机制及存在的挑战\" id=\"markdown-toc-16-更好的工作机制及存在的挑战\"\u003e1.6 更好的工作机制及存在的挑战\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#17-bbr基于对两个参数rtpropbtlbw的测量实现拥塞控制\" id=\"markdown-toc-17-bbr基于对两个参数rtpropbtlbw的测量实现拥塞控制\"\u003e1.7 BBR：基于对两个参数（RTprop、BtlBw）的测量实现拥塞控制\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-瓶颈的数学表示characterizing-the-bottleneck\" id=\"markdown-toc-2-瓶颈的数学表示characterizing-the-bottleneck\"\u003e2 瓶颈的数学表示（Characterizing the Bottleneck）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-最小化缓冲区积压或最高吞吐最低延迟需满足的条件\" id=\"markdown-toc-21-最小化缓冲区积压或最高吞吐最低延迟需满足的条件\"\u003e2.1 最小化缓冲区积压（或最高吞吐+最低延迟）需满足的条件\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-无偏估计unbiased-estimator\" id=\"markdown-toc-22-无偏估计unbiased-estimator\"\u003e2.2 无偏估计（unbiased estimator）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-传输时延rtprop的表示与估计\" id=\"markdown-toc-23-传输时延rtprop的表示与估计\"\u003e2.3 传输时延（RTProp）的表示与估计\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-瓶颈带宽btlbw的表示与估计\" id=\"markdown-toc-24-瓶颈带宽btlbw的表示与估计\"\u003e2.4 瓶颈带宽（BtlBw）的表示与估计\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-bbr-测量机制\" id=\"markdown-toc-25-bbr-测量机制\"\u003e2.5 BBR 测量机制\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#26-不确定性原理\" id=\"markdown-toc-26-不确定性原理\"\u003e2.6 不确定性原理\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-使数据流packet-flow与传输路径delivery-path相匹配\" id=\"markdown-toc-3-使数据流packet-flow与传输路径delivery-path相匹配\"\u003e3 使数据流（Packet Flow）与传输路径（Delivery Path）相匹配\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-bbr-收到应答包ack时的逻辑\" id=\"markdown-toc-31-bbr-收到应答包ack时的逻辑\"\u003e3.1 BBR 收到应答包（ACK）时的逻辑\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-tcp-pacing在每个-rtt-窗口内均匀发送数据\" id=\"markdown-toc-32-tcp-pacing在每个-rtt-窗口内均匀发送数据\"\u003e3.2 TCP Pacing（在每个 RTT 窗口内均匀发送数据）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-bbr-发送数据时的逻辑\" id=\"markdown-toc-33-bbr-发送数据时的逻辑\"\u003e3.3 BBR 发送数据时的逻辑\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-稳态行为steady-state-behavior\" id=\"markdown-toc-34-稳态行为steady-state-behavior\"\u003e3.4 稳态行为（Steady-state behavior）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#路径适配与控制循环\" id=\"markdown-toc-路径适配与控制循环\"\u003e路径适配与控制循环\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#稳态的收敛过程\" id=\"markdown-toc-稳态的收敛过程\"\u003e稳态的收敛过程\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-bbr-flow-行为\" id=\"markdown-toc-4-bbr-flow-行为\"\u003e4 BBR Flow 行为\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-bbr-状态机\" id=\"markdown-toc-41-bbr-状态机\"\u003e4.1 BBR 状态机\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-单条-bbr-flow-的启动时行为\" id=\"markdown-toc-42-单条-bbr-flow-的启动时行为\"\u003e4.2 单条 BBR flow 的启动时行为\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-共享同一瓶颈的多条-bbr-flow-的行为\" id=\"markdown-toc-43-共享同一瓶颈的多条-bbr-flow-的行为\"\u003e4.3 共享同一瓶颈的多条 BBR flow 的行为\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-部署经验\" id=\"markdown-toc-5-部署经验\"\u003e5 部署经验\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-google-b4-广域网wan部署经验\" id=\"markdown-toc-51-google-b4-广域网wan部署经验\"\u003e5.1 Google B4 广域网（WAN）部署经验\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-youtube-边缘网络部署经验\" id=\"markdown-toc-52-youtube-边缘网络部署经验\"\u003e5.2 YouTube 边缘网络部署经验\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-问题讨论\" id=\"markdown-toc-6-问题讨论\"\u003e6 问题讨论\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-移动蜂窝网络中的自适应带宽\" id=\"markdown-toc-61-移动蜂窝网络中的自适应带宽\"\u003e6.1 移动蜂窝网络中的自适应带宽\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-延迟和聚合应答\" id=\"markdown-toc-62-延迟和聚合应答\"\u003e6.2 延迟和聚合应答\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-入向流量整形token-bucket-policers\" id=\"markdown-toc-63-入向流量整形token-bucket-policers\"\u003e6.3 入向流量整形（Token-Bucket Policers）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-与基于丢包的拥塞控制的竞争\" id=\"markdown-toc-64-与基于丢包的拥塞控制的竞争\"\u003e6.4 与基于丢包的拥塞控制的竞争\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-总结\" id=\"markdown-toc-7-总结\"\u003e7 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#致谢\" id=\"markdown-toc-致谢\"\u003e致谢\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#附录详细描述\" id=\"markdown-toc-附录详细描述\"\u003e附录：详细描述\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#顺序探测状态机a-state-machine-for-sequential-probing\" id=\"markdown-toc-顺序探测状态机a-state-machine-for-sequential-probing\"\u003e顺序探测状态机（A State Machine for Sequential Probing）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#稳态行为steady-state-behavior\" id=\"markdown-toc-稳态行为steady-state-behavior\"\u003e稳态行为（Steady-State Behavior）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#启动行为startup-behavior\" id=\"markdown-toc-启动行为startup-behavior\"\u003e启动行为（Startup Behavior）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#应对突发流量reacting-to-transients\" id=\"markdown-toc-应对突发流量reacting-to-transients\"\u003e应对突发流量（Reacting to Transients）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#references\" id=\"markdown-toc-references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e从各方面来说，今天的互联网\u003cstrong\u003e\u003cmark\u003e传输数据的速度\u003c/mark\u003e\u003c/strong\u003e都不甚理想：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e大部分移动用户都在忍受数秒乃至数分钟的延迟；\u003c/li\u003e\n  \u003cli\u003e机场和大会场馆的共享 WIFI 信号一般都很差；\u003c/li\u003e\n  \u003cli\u003e物理和气候学家需要与全球合作者交换 PB 级的数据，最后却发现精心设计的 Gbps\n基础设施在\u003cstrong\u003e\u003cmark\u003e跨大洲通信时\u003c/mark\u003e\u003c/strong\u003e带宽经常只能达到 Mbps\u003csup\u003e6\u003c/sup\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这些问题是由 \u003cstrong\u003e\u003cmark\u003eTCP 的设计导致的 —— 20 世纪 80 年代设计 TCP 拥塞控制\u003c/mark\u003e\u003c/strong\u003e（congestion control）\n时，认为\u003cstrong\u003e\u003cmark\u003e丢包是发生了“拥塞”\u003c/mark\u003e\u003c/strong\u003e\u003csup\u003e13\u003c/sup\u003e。\n在当时的技术条件下我们可以这样认为，但它\u003cstrong\u003e\u003cmark\u003e并非第一原则\u003c/mark\u003e\u003c/strong\u003e\n（technology limitations, not first principles）。随着网卡从 Mbps 到 Gbps、\n内存从 KB 到 GB，\u003cstrong\u003e\u003cmark\u003e丢包和拥塞之间的关系也变得愈发微弱\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e今天，TCP 那些\u003cstrong\u003e\u003cmark\u003e基于丢包的拥塞控制\u003c/mark\u003e\u003c/strong\u003e（loss-based congestion control） ——\n即使是目前其中最好的 CUBIC\u003csup\u003e11\u003c/sup\u003e —— 是\u003cstrong\u003e\u003cmark\u003e导致这些问题的主要原因\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e链路瓶颈处的 buffer 很大时，这类算法会\u003cstrong\u003e\u003cmark\u003e持续占满整个缓冲区\u003c/mark\u003e\u003c/strong\u003e，导致 \u003cstrong\u003e\u003cmark\u003ebufferbloat\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e链路瓶颈处的 buffer 很小时，这类算法又会\u003cstrong\u003e\u003cmark\u003e误将丢包当作拥塞的信号\u003c/mark\u003e\u003c/strong\u003e，导致\u003cstrong\u003e\u003cmark\u003e吞吐很低\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e解决这些问题需要一种全新的方式，而这首先需要对以下两点有深入理解：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e拥塞会发生哪里\u003c/mark\u003e\u003c/strong\u003e（where）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e拥塞是如何发生的\u003c/mark\u003e\u003c/strong\u003e（how）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"1-拥塞和瓶颈congestion-and-bottlenecks\"\u003e1 拥塞和瓶颈（Congestion and Bottlenecks）\u003c/h1\u003e\n\n\u003ch2 id=\"11-两个物理特性传输时延rtprop和瓶颈带宽btlbw\"\u003e1.1 两个物理特性：传输时延（RTprop）和瓶颈带宽（BtlBw）\u003c/h2\u003e\n\n\u003cp\u003e对于一个（全双工）TCP 连接，在任意时刻，它在每个方向都有且只有\u003cstrong\u003e\u003cmark\u003e一段最慢的链路\u003c/mark\u003e\u003c/strong\u003e\n（exactly one slowest link）或称\u003cstrong\u003e\u003cmark\u003e瓶颈\u003c/mark\u003e\u003c/strong\u003e（bottleneck）。这一点很重要，因为：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e瓶颈\u003cstrong\u003e\u003cmark\u003e决定了连接的最大数据传输速率\u003c/mark\u003e\u003c/strong\u003e。这是\u003cstrong\u003e\u003cmark\u003e不可压缩流\u003c/mark\u003e\u003c/strong\u003e（incompressible flow）的一个常规特性。\u003c/p\u003e\n\n    \u003cp\u003e例如，考虑交通高峰期的一个六车道高速公路，一起交通事故使其中一段变成了单车道，\n  那么这整条高速公路的吞吐就不会超过那条唯一还在正常通车的车道的吞吐。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e瓶颈也是\u003cstrong\u003e\u003cmark\u003e持久队列（persistent queues）形成的地方\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e对于一条链路，只有当它的\u003cstrong\u003e\u003cmark\u003e离开速率\u003c/mark\u003e\u003c/strong\u003e（departure rate）大于\u003cstrong\u003e\u003cmark\u003e到达速率\u003c/mark\u003e\u003c/strong\u003e（arrival\n  rate）时，这个队列才会开始收缩。对于一条有多段链路、运行在最大传输速率的连\n  接（connection），除瓶颈点之外的地方都有更大的离开速率，因此队列会朝着瓶颈\n  移动（migrate to the bottleneck）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e不管一条连接会经过多少条链路，以及每条链路的速度是多少，从 TCP 的角度来看，\n任何一条复杂路径的行为，与 RTT（round-trip time）及瓶颈速率相同的单条链路的行为是一样的。\n换句话说，\u003cstrong\u003e\u003cmark\u003e以下两个物理特性决定了传输的性能\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRTprop\u003c/code\u003e (round-trip propagation time)：往返传输时间\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBtlBw\u003c/code\u003e (bottleneck bandwidth)：瓶颈带宽\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e如果网络路径是一条物理管道，那 RTprop 就是管道的\u003cstrong\u003e\u003cmark\u003e长度\u003c/mark\u003e\u003c/strong\u003e，而\nBtlBw 则是管道\u003cstrong\u003e\u003cmark\u003e最窄处的直径\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"12-传输时延瓶颈带宽与-inflight-数据量的关系\"\u003e1.2 传输时延/瓶颈带宽与 inflight 数据量的关系\u003c/h2\u003e\n\n\u003cp\u003e图 1 展示了 \u003cstrong\u003e\u003cmark\u003einflight 数据量\u003c/mark\u003e\u003c/strong\u003e（已发送但还未被确认的数据量）不断增大时，\nRTT 和传输速率（delivery rate）的变化情况：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e直观上，这张图想解释的是：随着\u003cstrong\u003e\u003cmark\u003e正在传输中的数据的不断增多，传输延迟和传输速率将如何变化\u003c/mark\u003e\u003c/strong\u003e。\n难点在于二者并没有简单的关系可以表示。不仅如此，后文还将看到二者甚至不可同\n时测量 —— 就像量子力学中位置和动量不可同时测量。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson1.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 1. Delivery rate and RTT vs. inflight data\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003e蓝线展示 RTprop 限制，\u003c/li\u003e\n    \u003cli\u003e绿线展示 BtlBw 限制，\u003c/li\u003e\n    \u003cli\u003e红线是瓶颈缓冲区（bottleneck buffer）\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e横轴表示 inflight 数据量，关键的点有三个，依次为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0 -\u0026gt; BDP -\u0026gt; BDP+BtlneckBuffSize\u003c/code\u003e，\n后两个点做垂线，将整个空间分为了三个部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(0, BDP)\u003c/code\u003e：这个区间内，应用（客户端）发送的数据并未占满瓶颈带宽（容量），因此称为\n  \u003cstrong\u003e\u003cmark\u003e应用受限（app limited）\u003c/mark\u003e\u003c/strong\u003e区域；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(BDP, BDP+BtlneckBuffSize)\u003c/code\u003e：这个区间内，已经达到链路瓶颈容量，但还未超过\n  \u003cstrong\u003e\u003cmark\u003e瓶颈容量+缓冲区容量\u003c/mark\u003e\u003c/strong\u003e，此时应用能发送的数据量主要受带宽限制，\n  因此称为\u003cstrong\u003e\u003cmark\u003e带宽受限（bandwidth limited）\u003c/mark\u003e\u003c/strong\u003e区域；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(BDP+BtlneckBuffSize, infinity)\u003c/code\u003e：这个区间内，实际发送速率已经超过瓶颈容量+缓冲区容量\n，多出来的数据会被丢弃，缓冲区大小决定了丢包多少，因此称为\u003cstrong\u003e\u003cmark\u003e缓冲区受限（buffer limited）\u003c/mark\u003e\u003c/strong\u003e区域。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以上三者，也可以更直白地称为\u003cstrong\u003e\u003cmark\u003e应用不足、带宽不足、缓冲区不足\u003c/mark\u003e\u003c/strong\u003e区域。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"13-以上关系的进一步解释\"\u003e1.3 以上关系的进一步解释\u003c/h2\u003e\n\n\u003cp\u003e我们来更具体地看一下传输时延（RTprop）和瓶颈带宽（BtlBw）与与 inflight 数据量呈现以上关系：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003einflight 数据量在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0 -\u0026gt; BDP\u003c/code\u003e 区间内时，发送的数据还未达到瓶颈容量，此时，\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e往返时间不变\u003c/mark\u003e\u003c/strong\u003e：对应上半部分图，因为此时还未达到瓶颈带宽，链路不会随数据量增加而带来额外延迟；\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e传输速率线性增大\u003c/mark\u003e\u003c/strong\u003e：对应下半部分图；\u003c/li\u003e\n    \u003c/ol\u003e\n\n    \u003cp\u003e因此，这个阶段的行为由 RTprop 决定。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003einflight 数据量刚好等于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBDP\u003c/code\u003e 时，\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e两条限制线相交的点称为 BDP 点，这也是 BDP（bandwidth-delay product，\u003cstrong\u003e\u003cmark\u003e带宽-延迟乘积\u003c/mark\u003e\u003c/strong\u003e）这个名称的由来；\u003c/li\u003e\n      \u003cli\u003e此时可以算出：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003einflight = BtlBw × RTprop\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003einflight 大于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBDP\u003c/code\u003e 之后，管道就满了（超过瓶颈带宽）\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e超过瓶颈带宽的数据就会形成一个队列（queue），堆积在链路瓶颈处，然后\u003c/li\u003e\n      \u003cli\u003eRTT 将随着 inflight 数据的增加而线性增加，如上半部分图所示。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003einflight 继续增大，超过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBDP+BtlneckBuffSize\u003c/code\u003e 之后，即超过链路瓶颈所支持的最大缓冲区之后，就开始丢包。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e灰色区域是不可达的，因为它违反了至少其中一个限制。限制条件的不同导致了三个可行区域\n（app-limited, bandwidth-limited, and buffer-limited）各自有不同的行为。\u003c/p\u003e\n\n\u003ch2 id=\"14-拥塞和拥塞控制的直观含义\"\u003e1.4 拥塞和拥塞控制的直观含义\u003c/h2\u003e\n\n\u003cp\u003e再次给出图 1，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson1.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 1. Delivery rate and RTT vs. inflight data\u003c/p\u003e\n\n\u003cp\u003e直观上来说，\n\u003cstrong\u003e\u003cmark\u003e拥塞\u003c/mark\u003e\u003c/strong\u003e（congestion）就是 \u003cstrong\u003e\u003cmark\u003einflight 数据量持续向右侧偏离 BDP 线\u003c/mark\u003e\u003c/strong\u003e的行为，\n而\u003cstrong\u003e\u003cmark\u003e拥塞控制\u003c/mark\u003e\u003c/strong\u003e（congestion control）就是各种在平均程度上\u003cstrong\u003e\u003cmark\u003e控制这种偏离程度\u003c/mark\u003e\u003c/strong\u003e的方案或算法。\u003c/p\u003e\n\n\u003ch2 id=\"15-基于丢包的拥塞控制工作机制\"\u003e1.5 基于丢包的拥塞控制工作机制\u003c/h2\u003e\n\n\u003cp\u003e基于丢包的拥塞控制工作在 bandwidth-limited 区域的右侧，依靠：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e很高的延迟\u003c/mark\u003e\u003c/strong\u003e，以及\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e频繁的丢包\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e将连接的\u003cstrong\u003e\u003cmark\u003e传输速率维持在全速瓶颈带宽\u003c/mark\u003e\u003c/strong\u003e（full bottleneck bandwidth）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在内存很贵的年代，瓶颈链路的\u003cstrong\u003e\u003cmark\u003e缓冲区只比 BDP 略大\u003c/mark\u003e\u003c/strong\u003e，这使得\n基于丢包的拥塞控制导致的\u003cstrong\u003e\u003cmark\u003e额外延迟很小\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e随着内存越来越便宜，\u003cstrong\u003e\u003cmark\u003e缓冲区已经比 ISP 链路的 BDP 要大上几个数量级了\u003c/mark\u003e\u003c/strong\u003e，\n其结果是，bufferbloat 导致的 \u003cstrong\u003e\u003cmark\u003eRTT 达到了秒级\u003c/mark\u003e\u003c/strong\u003e，而不再是毫秒级\u003csup\u003e9\u003c/sup\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"16-更好的工作机制及存在的挑战\"\u003e1.6 更好的工作机制及存在的挑战\u003c/h2\u003e\n\n\u003cp\u003eBandwidth-limited 区域的\u003cstrong\u003e\u003cmark\u003e左侧边界\u003c/mark\u003e\u003c/strong\u003e是比右侧更好的一个拥塞控制点。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e1979 年，Leonard Kleinrock\u003csup\u003e16\u003c/sup\u003e \u003cstrong\u003e\u003cmark\u003e证明了这个点是最优的\u003c/mark\u003e\u003c/strong\u003e，\n能最大化传输速率、最小化延迟和丢包，不管是对于单个连接还是整个网络\u003csup\u003e8\u003c/sup\u003e。\u003c/li\u003e\n  \u003cli\u003e不幸的是，大约在同一时间，Jeffrey M. Jaffe\u003csup\u003e14\u003c/sup\u003e 证明了\n\u003cstrong\u003e\u003cmark\u003e不存在能收敛到这个点的分布式算法\u003c/mark\u003e\u003c/strong\u003e。这个结果使得研究方向从寻找一个能达到 Kleinrock\n最佳工作点（operating point）的分布式算法，转向了对不同拥塞控制方式的研究。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在 Google，我们团队每天都会花数小时来分析从世界各地收集上来的 TCP 包头，\n探究各种异常和反常现象背后的意义。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一步通常是寻找基本的路径特性 RTprop 和 BtlBw。\u003c/li\u003e\n  \u003cli\u003e能从跟踪信息中拿到这些数据这一事实，说明 Jaffe 的结论可能并没有看上去那么悲观。\nJaffe 的结果在本质上具有测量模糊性（fundamental measurement ambiguities），例\n如，测量到的 RTT 增加是由于路径长度变化导致的，还是瓶颈带宽变小导致的，还是另\n一个连接的流量积压、延迟增加导致的。\u003c/li\u003e\n  \u003cli\u003e虽然无法让任何单个测量参数变得很精确，但一个\u003cstrong\u003e\u003cmark\u003e连接随着时间变化的行为\u003c/mark\u003e\u003c/strong\u003e\n还是能清晰地反映出某些东西，也预示着用于\u003cstrong\u003e\u003cmark\u003e解决这种模糊性的测量策略\u003c/mark\u003e\u003c/strong\u003e是可行的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"17-bbr基于对两个参数rtpropbtlbw的测量实现拥塞控制\"\u003e1.7 BBR：基于对两个参数（RTprop、BtlBw）的测量实现拥塞控制\u003c/h2\u003e\n\n\u003cp\u003e组合这些测量指标（measurements），再引入一个健壮的\u003cstrong\u003e\u003cmark\u003e伺服系统\u003c/mark\u003e\u003c/strong\u003e\n（基于\u003cstrong\u003e\u003cmark\u003e控制系统\u003c/mark\u003e\u003c/strong\u003e领域的近期进展）\n\u003csup\u003e12\u003c/sup\u003e，我们便得到一个能\u003cstrong\u003e\u003cmark\u003e针对对真实拥塞 —— 而非丢包或延迟\u003c/mark\u003e\u003c/strong\u003e —— 做出反应的\n\u003cstrong\u003e\u003cmark\u003e分布式拥塞控制协议\u003c/mark\u003e\u003c/strong\u003e，能以很大概率收敛到 Kleinrock 的最优工作点。\u003c/p\u003e\n\n\u003cp\u003e我们的三年努力也正是从这里开始：试图基于对如下\u003cstrong\u003e\u003cmark\u003e刻画一条路径的两个参数\u003c/mark\u003e\u003c/strong\u003e的测量，\n来实现一种拥塞控制机制，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e瓶颈带宽（\u003cstrong\u003e\u003cmark\u003eB\u003c/mark\u003e\u003c/strong\u003eottleneck \u003cstrong\u003e\u003cmark\u003eB\u003c/mark\u003e\u003c/strong\u003eandwidth）\u003c/li\u003e\n  \u003cli\u003e往返传输时间（\u003cstrong\u003e\u003cmark\u003eR\u003c/mark\u003e\u003c/strong\u003eound-trip propagation time）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"2-瓶颈的数学表示characterizing-the-bottleneck\"\u003e2 瓶颈的数学表示（Characterizing the Bottleneck）\u003c/h1\u003e\n\n\u003ch2 id=\"21-最小化缓冲区积压或最高吞吐最低延迟需满足的条件\"\u003e2.1 最小化缓冲区积压（或最高吞吐+最低延迟）需满足的条件\u003c/h2\u003e\n\n\u003cp\u003e当一个连接满足以下两个条件时，它将运行在\u003cstrong\u003e\u003cmark\u003e最高吞吐和最低延迟\u003c/mark\u003e\u003c/strong\u003e状态：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e速率平衡（rate balance）\u003c/mark\u003e\u003c/strong\u003e：瓶颈链路的\u003cstrong\u003e\u003cmark\u003e数据包到达速率\u003c/mark\u003e\u003c/strong\u003e刚好等于瓶颈带宽 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBtlBw\u003c/code\u003e，\u003c/p\u003e\n\n    \u003cp\u003e这个条件保证了链路瓶颈已达到 100% 利用率。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e管道填满（full pipe）\u003c/mark\u003e\u003c/strong\u003e：传输中的总数据（inflight）等于 BDP（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e= BtlBw × RTprop\u003c/code\u003e）。\u003c/p\u003e\n\n    \u003cp\u003e这个条件保证了有恰好足够的数据，既不会产生瓶颈饥饿（bottleneck starvation），\n 又不会产生管道溢出（overfill the pipe）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e需要注意，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e仅凭 rate balance 一个条件\u003cstrong\u003e\u003cmark\u003e并不能确保没有积压\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e例如，某个连接在一个 BDP=5 的链路上，开始时它发送了 10 个包组成的 Initial\n  Window，之后就一直稳定运行在瓶颈速率上。那么，在这个链路此后的行为就是：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e稳定运行在瓶颈速率上\u003c/li\u003e\n      \u003cli\u003e稳定有 5 个包的积压（排队）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e类似地，仅凭 full pipe 一个条件\u003cstrong\u003e\u003cmark\u003e也无法确保没有积压\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e例如，如果某个连接以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBDP/2\u003c/code\u003e 的\u003cstrong\u003e\u003cmark\u003e突发方式\u003c/mark\u003e\u003c/strong\u003e发送一个 BDP 的数据，\n  那仍然能达到瓶颈利用率，但却会产生平均 BDP/4 的瓶颈积压。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在链路瓶颈以及整条路径上\u003cstrong\u003e\u003cmark\u003e最小化积压的唯一方式\u003c/mark\u003e\u003c/strong\u003e是同时满足以上两个条件。\u003c/p\u003e\n\n\u003ch2 id=\"22-无偏估计unbiased-estimator\"\u003e2.2 无偏估计（unbiased estimator）\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e下文会提到“无偏估计”这个统计学术语，这里先科普下：\u003c/p\u003e\n\n  \u003cp\u003eIn statistics, the bias (or bias function) of an estimator is the difference\nbetween this estimator’s expected value and the true value of the parameter\nbeing estimated. An estimator or decision rule with zero bias is called\nunbiased.\u003c/p\u003e\n\n  \u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Bias_of_an_estimator\"\u003eWikipedia: Bias of an estimator\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"23-传输时延rtprop的表示与估计\"\u003e2.3 传输时延（RTProp）的表示与估计\u003c/h2\u003e\n\n\u003cp\u003eBtlBw 和 RTprop 在一个连接的生命周期中是不断变化的，因此必须持续对它们做出\u003cstrong\u003e\u003cmark\u003e估计\u003c/mark\u003e\u003c/strong\u003e（estimation）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eTCP 目前跟踪了 RTT\u003c/mark\u003e\u003c/strong\u003e（从发送一段数据到这段数据被确认接收的时间）\n，因为检测是否有丢包要用到这个参数。在任意时刻 \u003ci\u003et\u003c/i\u003e,\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/eq1.png\" width=\"20%\" height=\"20%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e其中\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ci\u003e𝛈 ≥ 0\u003c/i\u003e 表示路径上因为积压、接收方延迟应答策略、应答聚合等因素而引入的\u003cstrong\u003e\u003cmark\u003e“噪声”\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ci\u003eRTprop\u003c/i\u003e 是往返传输时延。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e前面已经提到，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRTprop\u003c/code\u003e 是路径（connection’s path）的一个物理特性，只有当路径发\n生变化时它才会变化。由于路径变化的时间尺度远大于 RTProp，因此在时刻 T，一个无偏、高效估计是：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/eq2.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e例如，在时间窗口 \u003ci\u003eW\u003csub\u003eR\u003c/sub\u003e\u003c/i\u003e 内的移动最小值（running min），其中典型情况下，\n\u003ci\u003eW\u003csub\u003eR\u003c/sub\u003e\u003c/i\u003e 的持续时间是\u003cstrong\u003e\u003cmark\u003e几十秒到几分钟\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里直观上的解释是：\u003cstrong\u003e\u003cmark\u003e一段时间内的最小 RTT\u003c/mark\u003e\u003c/strong\u003e（可测量），就是\n这条路径\u003cstrong\u003e\u003cmark\u003e（在一段时间内）的往返传输延迟\u003c/mark\u003e\u003c/strong\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"24-瓶颈带宽btlbw的表示与估计\"\u003e2.4 瓶颈带宽（BtlBw）的表示与估计\u003c/h2\u003e\n\n\u003cp\u003e不同于 RTT，TCP 规范中并没有要求跟踪 bottleneck bandwidth，但可以通过\n\u003cstrong\u003e\u003cmark\u003e跟踪传输速率\u003c/mark\u003e\u003c/strong\u003e（delivery rate）来得到一个对瓶颈带宽的不错估计。\u003c/p\u003e\n\n\u003cp\u003e当应答包（ACK）到达发送端时，其中除了包含 RTT 信息，还包含包离开时的 inflight\ndata 传输情况。已传输的数据量除以传输时间，就是发送和应答之间的\u003cstrong\u003e\u003cmark\u003e平均传输速率\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e \u003ci\u003edeliveryRate = Δdelivered/Δt\u003c/i\u003e \u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这个速率一定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;= bottleneck rate\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e到达数据量 \u003ci\u003eΔdelivered\u003c/i\u003e 已经知道了，因此接下来需要确定的是 \u003ci\u003eΔt\u003c/i\u003e，而 \u003ci\u003eΔt ≥ true arrival interval\u003c/i\u003e；\u003c/li\u003e\n  \u003cli\u003e因此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edeliveryRate \u0026lt;= the true delivery rate\u003c/code\u003e，也就是\u003cstrong\u003e\u003cmark\u003e估计出的传输速率，不会超过真实瓶颈带宽\u003c/mark\u003e\u003c/strong\u003e，后者是前者的上限。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，传输速率在一段时间窗口内的最大值（windowed-max），是 BtlBw 的一个高效、\n无偏估计：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/eq3.png\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e其中时间窗口 \u003ci\u003eW\u003csub\u003eB\u003c/sub\u003e\u003c/i\u003e 典型情况下是 6~10 个 RTT。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里直观上的解释是：\u003cstrong\u003e\u003cmark\u003e一段时间内的链路最大传输带宽\u003c/mark\u003e\u003c/strong\u003e（可测量），就是这条链路的\u003cstrong\u003e\u003cmark\u003e瓶颈带宽\u003c/mark\u003e\u003c/strong\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"25-bbr-测量机制\"\u003e2.5 BBR 测量机制\u003c/h2\u003e\n\n\u003cp\u003eTCP 记录了每个包的离开时间，再加上已传输的数据量，当\u003cstrong\u003e\u003cmark\u003e每个 ACK 包到达发送端时，将产生\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e一个 RTT 值\u003c/li\u003e\n  \u003cli\u003e传输速率的一次测量值（a delivery rate measurement）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e过滤器可以将这两个测量到的值转换成对 RTprop 和 BtlBw 的估计。\u003c/p\u003e\n\n\u003cp\u003e注意，\u003cstrong\u003e\u003cmark\u003e这两个变量是完全独立的\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在瓶颈带宽不变的情况下，RTprop 仍可能发生变化（例如，路由变了）；\u003c/li\u003e\n  \u003cli\u003e路径（path）不变的情况下（因此 RTprop 也不变），BtlBw 也可能发生变化（例如，某条无线链路速率变了）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这种无关性也解释了为什么\u003cstrong\u003e\u003cmark\u003e需要同时知道这两个限制条件，才能确定传输路径的发送行为\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"26-不确定性原理\"\u003e2.6 不确定性原理\u003c/h2\u003e\n\n\u003cp\u003e由于 RTprop 只对 BDP 的左侧可见，BtlBw 只对右侧可见，因此它们服从不确定性原理（\nuncertainty principle）：\u003cstrong\u003e\u003cmark\u003e当测量其中一个时，另一个将不可测量\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e直观上的解释\u003c/mark\u003e\u003c/strong\u003e是：管道整个长度被填满 —— 或称溢出（overfilled）—— 时才能达到它的\n最大容量，而溢出之后会（在缓冲区中）创建一个队列（queue），后者作为管道的\n延伸又\u003cstrong\u003e\u003cmark\u003e反过来模糊了管道的长度\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e例如，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e发送请求/接收响应的的应用：可能永远无法发送足够多的数据来填满管道，因此它\n\u003cstrong\u003e\u003cmark\u003e只能测量到传输延迟，而无法测量到 BtlBw\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e持续几小时的大批量数据传输：可能整个生命周期都位于图中的带宽受限区域，因此它\n  \u003cstrong\u003e\u003cmark\u003e自始至终只有一个 RTprop 样本，也就是第一个包的 RTT\u003c/mark\u003e\u003c/strong\u003e（其他包\n  的 RTT 对这种场景来说是无效样本）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这种内在的不确定性意味着，除了依靠测量值来估计（恢复）出两个路径变量之外，\n必须有状态来跟踪：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e从当前的工作位置可以学到什么\u003c/mark\u003e\u003c/strong\u003e（what can be learned at the current operating point）\u003c/li\u003e\n  \u003cli\u003e当信息失效时，\u003cstrong\u003e\u003cmark\u003e如何找到下一个\u003c/mark\u003e\u003c/strong\u003e可以继续学习的工作位置（how to get to an operating point where it can be relearned）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这里说的\u003cstrong\u003e\u003cmark\u003e“工作位置”\u003c/mark\u003e\u003c/strong\u003e，是指图 1 中的 RTProp 和 BtlBw 不同组合产生的位置。\u003c/p\u003e\n\n\u003ch1 id=\"3-使数据流packet-flow与传输路径delivery-path相匹配\"\u003e3 使数据流（Packet Flow）与传输路径（Delivery Path）相匹配\u003c/h1\u003e\n\n\u003cp\u003eBBR 的核心算法分为两部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e当收到一个 ACK 时，应该做什么操作；\u003c/li\u003e\n  \u003cli\u003e当发送一段数据时，应该做什么操作。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"31-bbr-收到应答包ack时的逻辑\"\u003e3.1 BBR 收到应答包（ACK）时的逻辑\u003c/h2\u003e\n\n\u003cp\u003e每个 ACK 都为我们提供了 \u003cstrong\u003e\u003cmark\u003eRTT\u003c/mark\u003e\u003c/strong\u003e 和\u003cstrong\u003e\u003cmark\u003e平均传输速率\u003c/mark\u003e\u003c/strong\u003e\n的一次\u003cstrong\u003e\u003cmark\u003e测量\u003c/mark\u003e\u003c/strong\u003e，二者又将分别更新对 RTprop 和 BtlBw 的估计。\u003c/p\u003e\n\n\u003cp\u003e具体来说，收到一个 ACK 时，BBR 将执行以下逻辑：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003efunction\u003c/span\u003e \u003cspan class=\"n\"\u003eonAck\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ertt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enow\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esendtime\u003c/span\u003e                      \u003cspan class=\"c1\"\u003e// 收包时间 减去 包中记录的发包时间\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eupdate_min_filter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eRTpropFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ertt\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e             \u003cspan class=\"c1\"\u003e// 根据 2.2 中的方程，更新对 RTT 的估计\u003c/span\u003e\n \n  \u003cspan class=\"n\"\u003edelivered\u003c/span\u003e      \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\n  \u003cspan class=\"n\"\u003edelivered_time\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e  \u003cspan class=\"n\"\u003enow\u003c/span\u003e\n  \u003cspan class=\"n\"\u003edelivery_rate\u003c/span\u003e  \u003cspan class=\"o\"\u003e=\u003c/span\u003e  \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered_time\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered_time\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n \n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelivery_rate\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eBtlBwFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_max\u003c/span\u003e      \u003cspan class=\"c1\"\u003e// 实际传输速率已经大于当前估计的瓶颈带宽，或\u003c/span\u003e\n     \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapp_limited\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e                       \u003cspan class=\"c1\"\u003e// 不是应用受限（应用受限的样本对估计 BtlBw 无意义）\u003c/span\u003e\n     \u003cspan class=\"n\"\u003eupdate_max_filter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBtlBwFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edelivery_rate\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 根据 2.3 中的方程，更新对 BtlBw 的估计\u003c/span\u003e\n \n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eapp_limited_until\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e                       \u003cspan class=\"c1\"\u003e// 达到瓶颈带宽前，仍然可发送的字节数\u003c/span\u003e\n     \u003cspan class=\"n\"\u003eapp_limited_until\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eapp_limited_until\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e几点说明：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个包都会更新对 RTProp 的估计，但\u003cstrong\u003e\u003cmark\u003e只有部分包会更新对 BtlBw 的估计\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e应用受限的包\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e对于一个包，当应用（application）全速发送它而仍然没有占满瓶颈带宽时，\nBBR 会这个包标记为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eapp_limited\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（见下面的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e 伪代码），\n即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epacket.app_limited = true\u003c/code\u003e。\u003c/li\u003e\n      \u003cli\u003e这将决定哪些样本会用来更新对带宽的估计。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e瓶颈带宽 BtlBw 是传输速率的一个硬性上限，因此\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e如果测量到\u003cstrong\u003e\u003cmark\u003e当前的传输速率 \u0026gt; 当前对 BtlBw 估计\u003c/mark\u003e\u003c/strong\u003e，\n必定意味着这个估计太低了，不管样本是不是 app-limited；对应到上面的代码，就是只要\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edelivery_rate \u0026gt; BtlBwFilter.current_max\u003c/code\u003e，就一定更新 BtlBw 估计；否则，\u003c/li\u003e\n      \u003cli\u003e如果样本不是 app-limited（说明实际带宽已经饱和），也更新 BtlBw 估计。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-tcp-pacing在每个-rtt-窗口内均匀发送数据\"\u003e3.2 TCP Pacing（在每个 RTT 窗口内均匀发送数据）\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e科普下 TCP pacing 这个下文将用到的概念：\u003c/p\u003e\n\n  \u003cp\u003ePaper: \u003ca href=\"https://homes.cs.washington.edu/~tom/pubs/pacing.pdf\"\u003eUnderstanding the Performance of TCP Pacing\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003eTCP’s congestion control  mechanisms  can lead  to  bursty  traffic  flows\non  modern  high-speednetworks,  with  a negative  impact  on  overall\nnetwork  efficiency.   A  pro-posed solution to this problem is to\n\u003cstrong\u003e\u003cmark\u003eevenly space, or “pace”, data sent intothe network  over  an entire round-trip  time\u003c/mark\u003e\u003c/strong\u003e,\nso that  data is  not  sent  in  aburst.  In this paper, we quantitatively evaluate this approach.\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e为了让\u003cstrong\u003e\u003cmark\u003e数据包的到达速率\u003c/mark\u003e\u003c/strong\u003e（packet-arrival rate）能匹配到\n\u003cstrong\u003e\u003cmark\u003e瓶颈链路的离开速率\u003c/mark\u003e\u003c/strong\u003e（departure rate）, BBR 会\u003cstrong\u003e\u003cmark\u003e对每个数据进行 pace\u003c/mark\u003e\u003c/strong\u003e\n（在每个 RTT 窗口内均匀发送数据）。\u003c/p\u003e\n\n\u003cp\u003e有两个控制参数：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epacing_rate\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：BBR 的\u003cstrong\u003e\u003cmark\u003e主要控制参数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e要求达到速率必须匹配到瓶颈速率，意味着 \u003cstrong\u003e\u003cmark\u003epacing 是 BBR\u003c/mark\u003e\u003c/strong\u003e 设计以及实际操作中\n \u003cstrong\u003e\u003cmark\u003e必不可少的部分\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecwnd_gain\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：等于 BDP 乘以一个略大于 1 的系数，\n用来容忍常见的网络和接收端异常（pathologies） (见后文 Delayed and Stretched\nACKs 小节)。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"33-bbr-发送数据时的逻辑\"\u003e3.3 BBR 发送数据时的逻辑\u003c/h2\u003e\n\n\u003cp\u003eTCP 发包时的 BBR 逻辑如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003efunction\u003c/span\u003e \u003cspan class=\"n\"\u003esend\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ebdp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBtlBwFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_max\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eRTpropFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_min\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 计算 BDP\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einflight\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003ecwnd_gain\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ebdp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e                          \u003cspan class=\"c1\"\u003e// 如果正在传输中的数据量超过了允许的最大值\u003c/span\u003e\n     \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e                                                 \u003cspan class=\"c1\"\u003e// 直接返回，接下来就等下一个 ACK，或者等超时重传\u003c/span\u003e\n\n  \u003cspan class=\"c1\"\u003e// 能执行到这说明 inflight \u0026lt; cwnd_gain * bdp，即正在传输中的数据量 \u0026lt; 瓶颈容量\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enow\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003enext_send_time\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n     \u003cspan class=\"n\"\u003epacket\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enextPacketToSend\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n     \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e                      \u003cspan class=\"c1\"\u003e// 如果没有数据要发送\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eapp_limited_until\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einflight\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 更新 “在达到瓶颈容量之前，仍然可发送的数据量”\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\n\n     \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eapp_limited\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eapp_limited_until\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 如果仍然能发送若干字节才会达到瓶颈容量，说明处于 app_limited 状态\u003c/span\u003e\n     \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esendtime\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enow\u003c/span\u003e\n     \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edelivered\u003c/span\u003e\n     \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003edelivered_time\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edelivered_time\u003c/span\u003e\n     \u003cspan class=\"n\"\u003eship\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n     \u003cspan class=\"n\"\u003enext_send_time\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enow\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003epacket\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epacing_gain\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eBtlBwFilter\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecurrent_max\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003etimerCallbackAt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esend\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enext_send_time\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 Linux 实现中，BBR 发送过程会用到高效的 \u003cstrong\u003e\u003cmark\u003eFQ/pacing qdisc\u003c/mark\u003e\u003c/strong\u003e\u003csup\u003e4\u003c/sup\u003e，\n这使得 BBR 在多条 Gbps 链路上，单条连接的性能就能达到线速；CPU 开销几乎可以忽略\n，就能处理几千条低速 paced 连接。\u003c/p\u003e\n\n\u003ch2 id=\"34-稳态行为steady-state-behavior\"\u003e3.4 稳态行为（Steady-state behavior）\u003c/h2\u003e\n\n\u003ch3 id=\"路径适配与控制循环\"\u003e路径适配与控制循环\u003c/h3\u003e\n\n\u003cp\u003eBBR 的\u003cstrong\u003e\u003cmark\u003e发送速率\u003c/mark\u003e\u003c/strong\u003e和发送数据量只是估计出的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBtlBw\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRTprop\u003c/code\u003e\n的一个函数，过滤器（filters）除了要对瓶颈进行估计之外，还要控制\u003cstrong\u003e\u003cmark\u003e对传输路径的适配\u003c/mark\u003e\u003c/strong\u003e\n（control adaptation）。这产生了如图 2 所示的新的控制循环，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson2.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 2.  RTT (blue), inflight (green), BtlBw max filter (black) and delivery rate (red) detail\u003c/p\u003e\n\n\u003cp\u003e从上到下四条横线：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eRTT\u003c/li\u003e\n  \u003cli\u003einflight\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eBtlBw 的估计值（状态）\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e它上面的那行表格是\u003cstrong\u003e\u003cmark\u003epacing_gain\u003c/mark\u003e\u003c/strong\u003e，它是一个固定数组，不断循环；\u003c/li\u003e\n      \u003cli\u003e每个时刻使用的 pacing_gain 及其效果在图中是对齐的；\u003c/li\u003e\n      \u003cli\u003e每个 gain 会在发送数据时使用，因此是早一个 RTT 窗口；这可以从图中从下往上、再从上往下的整个环路看出来。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003edelivery rate（实际传输速率）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e几点说明：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e图中凸起的\u003cstrong\u003e\u003cmark\u003e尖峰是 BBR 使用 pacing_gain 周期切换导致\u003c/mark\u003e\u003c/strong\u003e的，目的是判断 BtlBw 是否有增加。\u003c/li\u003e\n  \u003cli\u003eBBR 在大部分时间都\u003cstrong\u003e\u003cmark\u003e将 inflight 数据量保持在一个 BDP\u003c/mark\u003e\u003c/strong\u003e，并用 BtlBw estimate 进行 pace，以此来\u003cstrong\u003e\u003cmark\u003e最小化延迟\u003c/mark\u003e\u003c/strong\u003e。\n  这将\u003cstrong\u003e\u003cmark\u003e瓶颈从链路前移到了发送端\u003c/mark\u003e\u003c/strong\u003e，因此发送端是无法看到 BtlBw 升高的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"稳态的收敛过程\"\u003e稳态的收敛过程\u003c/h3\u003e\n\n\u003cp\u003eBBR 会定期使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epacing_gain \u0026gt; 1\u003c/code\u003e 来均分每个 RTprop interval，增大了发送速率和 inflight 数据量。\n下面这是如何保持（或达到新的）稳态的。\u003c/p\u003e\n\n\u003cp\u003e考虑链路瓶颈带宽 BtlBw 的两种可能情况：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e继续保持恒定（大部分情况）\u003c/li\u003e\n  \u003cli\u003e突然增大（例如\u003cstrong\u003e\u003cmark\u003e物理链路扩容\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果 BtlBw 恒定，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e增加的数据量会在瓶颈处创建一个 queue，这会导致 RTT 变大，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edeliveryRate\u003c/code\u003e 此时还是恒定的；\u003c/li\u003e\n  \u003cli\u003e下一个 RTprop 窗口会以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epacing_gain \u0026lt; 1\u003c/code\u003e 发送数据，从而会将这个 queue 移除。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果 BtlBw 增大了，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edeliveryRate\u003c/code\u003e 也会增大，那么新的最大值会立即导致 BtlBw 的估计值变大，从而增大了基础 pacing 速率。\u003c/li\u003e\n  \u003cli\u003e因此，BBR 会以\u003cstrong\u003e\u003cmark\u003e指数级快速收敛到新的瓶颈速率\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e图 3 展示了一个原本运行在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10-Mbps/40-ms\u003c/code\u003e flow，链路瓶颈突然翻倍到 20 Mbps，平稳运行 20s 之后\n又重新回到 10Mbps 的效果：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson3.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 3. Bandwidth change\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBBR 是一个 max-plus 控制系统（一种基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax()\u003c/code\u003e 和加法操作的代数）的一个具体使用场景，这是一种基于非标准代数进行控制的新方式\u003csup\u003e12\u003c/sup\u003e。\n这种方式允许 adaptation rate （由 \u003ci\u003emax\u003c/i\u003e gain 控制）独立于 queue growth （由 \u003ci\u003eaverage\u003c/i\u003e gain 控制）。\n应用到这里，得到的就是一个简单、隐含的控制循环，其中，对物理限制的变化的适应过程，\n由代表这些限制的 filters 自动处理。而传统控制系统则需要通过一个复杂状态机连接\n起来的多个循环，才能完成同样效果。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"4-bbr-flow-行为\"\u003e4 BBR Flow 行为\u003c/h1\u003e\n\n\u003ch2 id=\"41-bbr-状态机\"\u003e4.1 BBR 状态机\u003c/h2\u003e\n\n\u003cp\u003e现有的实现使用事件相关（event-specific）的算法和代码来处理启动、关闭和丢包恢复等事件。\u003c/p\u003e\n\n\u003cp\u003eBBR 使用上一节的\u003cstrong\u003e\u003cmark\u003e两个函数\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eonAck()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e处理所有事情\u003c/mark\u003e\u003c/strong\u003e，\n通过序列化一组“状态”来处理事件，其中“状态”定义为一个 table，其中描述的是一组固定增益和退出条件（fixed gains and exit criteria）。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// include/uapi/linux/inet_diag.h\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* BBR has the following modes for deciding how fast to send: */\u003c/span\u003e\n\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebbr_mode\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_STARTUP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* ramp up sending rate rapidly to fill pipe */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_DRAIN\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* drain any queue created during startup */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_PROBE_BW\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* discover, share bw: pace around estimated bw */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_PROBE_RTT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* cut inflight to min to probe min_rtt */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* The pacing_gain values for the PROBE_BW gain cycle, to discover/share bw: */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebbr_pacing_gain\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* probe for more available bw */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* drain queue and/or yield bw to other flows */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* cruise at 1.0*bw to utilize pipe, */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBBR_UNIT\u003c/span\u003e\t\u003cspan class=\"cm\"\u003e/* without creating excess queue... */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e状态机：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e// net/ipv4/tcp_bbr.c\n\n                                   |\n                                   V\n                          +---\u0026gt; STARTUP  ----+\n                          |        |         |\n                          |        V         |\n                          |      DRAIN   ----+\n                          |        |         |\n                          |        V         |\n                          +---\u0026gt; PROBE_BW ----+\n                          |      ^    |      |\n                          |      |    |      |\n                          |      +----+      |\n                          |                  |\n                          +---- PROBE_RTT \u0026lt;--+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eStartup 状态发生在连接启动时；\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e为了处理跨 12 个量级的互联网链路带宽，Startup 为 BtlBw 实现了一个二分查找，随\n   着传输速率增加，每次用 2/ln2 增益来 double 发送速率。\n   这会在 \u003ci\u003elog\u003csub\u003e2\u003c/sub\u003eBDP\u003c/i\u003e 个 RTT 窗口内探测出 BDP，但过程中会导致最多两个 \n   \u003ci\u003e2BDP\u003c/i\u003e 的积压（excess queue）。\u003c/li\u003e\n      \u003cli\u003e探测出 BtlBw 之后，BBR 转入 Drain 状态。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eDrain 状态发生在连接启动时；\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003eDrain 状态利用与 Startup 相反的增益，来排尽那些积压在缓冲区中的数据，\u003c/li\u003e\n      \u003cli\u003einflight 数据量降低到一个 BDP 之后，转入 ProbeBW 状态；\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e大部分时间花在 ProbeBW 状态\u003c/mark\u003e\u003c/strong\u003e，具体内容就是前面已经介绍的\u003cstrong\u003e\u003cmark\u003e“稳态行为”收敛过程\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"42-单条-bbr-flow-的启动时行为\"\u003e4.2 单条 BBR flow 的启动时行为\u003c/h2\u003e\n\n\u003cp\u003e图 4 展示了一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10-Mbps/40-ms\u003c/code\u003e BBR TCP flow 的前 1 秒，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e发送端（绿色）和接收端（蓝色）随时间的变化。\u003c/li\u003e\n  \u003cli\u003e红色是 CUBIC 发送端在完全相同条件下的行为。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson4.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 4. First second of a 10-Mbps, 40-ms BBR flow. \u003c/p\u003e\n\n\u003cp\u003e几点解释：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e上半部分图展示的是 BBR 和 CUBIC 连接的 RTT 随时间的变化。注意，这份数据的时\n间参考是 ACK 到达（蓝色），因此，while they appear to be time shifted,\nevents are shown at the point where BBR learns of them and acts.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e下半部分图中可以看出，BBR 和 CUBIC 的初始行为是类似的，但 \u003cstrong\u003e\u003cmark\u003eBBR 能完全排尽它的 startup queue 而 CUBIC 不能\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003eCUBIC 算法中没有 inflight 信息，因此它后面的 inflight 还会持续增长（虽然没那么激进），直到\n 瓶颈 buffer 满了导致丢包，或者接收方的 inflight limit (TCP’s receive window) 达到了。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e图 5 是这条 flow 前 8 秒的详情，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson5.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 5. First eight seconds of 10-Mbps, 40-ms CUBIC and BBR flows. \u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCUBIC (red) 填满了可用缓冲区，然后每隔几秒就会从 70% to 100%；\u003c/li\u003e\n  \u003cli\u003e而 BBR（绿色）启动之后，后面运行时就\u003cstrong\u003e\u003cmark\u003e不会再出现积压\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"43-共享同一瓶颈的多条-bbr-flow-的行为\"\u003e4.3 共享同一瓶颈的多条 BBR flow 的行为\u003c/h2\u003e\n\n\u003cp\u003e图 6 展示了共享同一 100-Mbps/10-ms 瓶颈的多条 BBR flow 各自的吞吐，以及如何收敛到公平份额的：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson6.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 6. Throughputs of 5 BBR flows sharing a bottleneck \u003c/p\u003e\n\n\u003cp\u003e图中向下的几个三角形，是 connection ProbeRTT states，它们的 self-synchronization 加速了最终收敛。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eProbeBW gain 周期性变化（见前面图 2），使\u003cstrong\u003e\u003cmark\u003e大 flow 将带宽匀给小 flow\u003c/mark\u003e\u003c/strong\u003e，\n最终每个 flow 都得到一个公平的份额；\u003c/li\u003e\n  \u003cli\u003e整个过程非常快（\u003cstrong\u003e\u003cmark\u003e几个 ProbeBW 周期\u003c/mark\u003e\u003c/strong\u003e）；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但如果某些 flow 已经（短时地）导致积压，后来者会过高估计 RTProp，可能一段时间内\n的不公平（收敛时间超出几个 ProbeBW 周期）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e要学习到真正的 RTProp，需要通过 ProbeRTT 状态移动到 BDP 的左侧：\u003c/li\u003e\n  \u003cli\u003e当 RTProp estimate 持续几秒钟未被更新时（例如，没有测量到一个更低的 RTT）\nBBR 进入 ProbeRTT，这会将 inflight 降低到每个 RTT 不超过 4 包，然后再返回之前的状态。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e大 flow 进入 ProbeRTT 之后会从积压队列中 drain 很多包，因此一些 flows 就能观测\n到一个新的 RTprop (new minimum RTT)。这使得它们的 RTprop estimates 在同一时间过\n期，因此集中进入 ProbeRTT 状态，这会进一步使积压的数据更快消化，从而使更多 flow\n看到新的 RTprop，以此类推。这种\u003cstrong\u003e\u003cmark\u003e分布式协调\u003c/mark\u003e\u003c/strong\u003e（distributed\ncoordination）是公平性和稳定性（fairness and stability）的关键。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBBR 的期望状态是\u003cstrong\u003e\u003cmark\u003e瓶颈队列零积压\u003c/mark\u003e\u003c/strong\u003e（an empty bottleneck queue）\n，并围绕这个目标不断同步 flow；\u003c/li\u003e\n  \u003cli\u003e基于丢包的拥塞控制，期望状态是\u003cstrong\u003e\u003cmark\u003e队列的定期积压和溢出\u003c/mark\u003e\u003c/strong\u003e（\nperiodic queue growth and overflow，这会导致延迟放大和丢包），并围绕这个目标不断同步 flow。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"5-部署经验\"\u003e5 部署经验\u003c/h1\u003e\n\n\u003ch2 id=\"51-google-b4-广域网wan部署经验\"\u003e5.1 Google B4 广域网（WAN）部署经验\u003c/h2\u003e\n\n\u003cp\u003eB4 是 Google 用\u003cstrong\u003e\u003cmark\u003e商用交换机\u003c/mark\u003e\u003c/strong\u003e（commodity switches）构建的高速广域网\u003csup\u003e15\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这些\u003cstrong\u003e\u003cmark\u003e小缓冲区（shallow-buffered）交换机\u003c/mark\u003e\u003c/strong\u003e的丢包主要来自\u003cstrong\u003e\u003cmark\u003e偶发的突发流量\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e2015\u003c/mark\u003e\u003c/strong\u003e 年，Google 开始将 B4 上的生产流量\u003cstrong\u003e\u003cmark\u003e从 CUBIC 切换到 BBR\u003c/mark\u003e\u003c/strong\u003e，期间没有出现重大问题；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e2016\u003c/mark\u003e\u003c/strong\u003e 年，\u003cstrong\u003e\u003cmark\u003e所有 B4 TCP 流量\u003c/mark\u003e\u003c/strong\u003e都已经切到 BBR。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e图 7 可以看出，\u003cstrong\u003e\u003cmark\u003eBBR 的吞吐稳定地比 CUBIC 高 2~25 倍\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson7.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 7. BBR vs. CUBIC relative throughput improvement. \u003cbr/\u003e\n\n以我们某个活跃的探测器（prober）服务作为实验对象，该服务会创建到远程数据中心的持久 BBR 和 CUBIC 连接，\n然后每分钟传输 8MB 数据。探测器之间会通过北美、欧洲和亚洲的多条跨洲或洲内 B4 路径通信。\n\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e但按照我们的理论估计，BBR 的性能应该比这个更好\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e排查之后发现，75% 的 BBR 连接都受限于内核 TCP 的接收缓冲区，我们的网络运营团\n队之前有意将这个参数调低了（设置为 8MB），目的是防止 CUBIC MB 量级的积压数据\n泛洪（跨洲 8-MB/200-ms RTT 将导致最大 335-Mbps 带宽占用），\u003c/li\u003e\n  \u003cli\u003e手动将 US-Europe 的一条路径上的接收缓冲区调大之后，BBR 立即达到了 2Gbps 的带宽 ——\n而 CUBIC 仍然只能到达 15Mbps —— \u003cstrong\u003e\u003cmark\u003e133 倍\u003c/mark\u003e\u003c/strong\u003e的提升，正如 Mathis 等人的预测\u003csup\u003e17\u003c/sup\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这巨大的提升是 BBR \u003cstrong\u003e\u003cmark\u003e没有将丢包作为拥塞指示器\u003c/mark\u003e\u003c/strong\u003e（not using loss as a congestion indicator）的一个直接结果。\n为达到全速带宽，现有的基于丢包的拥塞控制，要求丢包率低于 BDP 的 inverse square \u003csup\u003e17\u003c/sup\u003e\n(e.g., 小于 one loss per 30 million packets for a 10-Gbps/100-ms path)\u003c/p\u003e\n\n\u003cp\u003eFigure 8 比较了不同丢包率下的实际吞吐量：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson8.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 8. BBR vs. CUBIC goodput for 60-second flows on a 100-Mbps/100-ms link with 0.001 to 50 percent random loss.\u003c/p\u003e\n\n\u003cp\u003e最大可能的吞吐是 \u003ccode\u003e链路速率乘以 * (1 - lossRate)\u003c/code\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eCUBIC 的吞吐在丢包率 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0.1%\u003c/code\u003e 时下降到了原来的 1/10 倍，在\u003cstrong\u003e\u003cmark\u003e丢包率 1% 时完全跌零了\u003c/mark\u003e\u003c/strong\u003e。\u003cbr/\u003e\u003c/li\u003e\n  \u003cli\u003eBBR 的吞吐 \u003cstrong\u003e\u003cmark\u003e在丢包率小于 5% 时能维持在最大值\u003c/mark\u003e\u003c/strong\u003e，在丢包率超过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e15%\u003c/code\u003e 之后才开始急剧下降。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCUBIC 的 loss tolerance 是其算法的一个\u003cstrong\u003e\u003cmark\u003e结构特性\u003c/mark\u003e\u003c/strong\u003e（structural property），\n而 BBR 中它是一个\u003cstrong\u003e\u003cmark\u003e配置参数\u003c/mark\u003e\u003c/strong\u003e。当 BBR 的\u003cstrong\u003e\u003cmark\u003e丢包率接近 ProbeBW 峰值增益\u003c/mark\u003e\u003c/strong\u003e时，\n测量真实 BtlBw 的传输速率的概率将剧烈下降，导致最大值过滤器（the max filter）将\n产生过低估计（underestimate）。\u003c/p\u003e\n\n\u003ch2 id=\"52-youtube-边缘网络部署经验\"\u003e5.2 YouTube 边缘网络部署经验\u003c/h2\u003e\n\n\u003cp\u003eBBR 已经部署到了 Google.com 和 YouTube 视频服务器上。我们在小规模灰度，一小部分用户会随机被分到 BBR 或 CUBIC。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e以 YouTube 的所有体验质量指标来衡量，BBR 给用户带来的提升都非常明显，这可能是\n由于 BBR 的行为更加一致和可预测（consistent and predictable）。\u003c/li\u003e\n  \u003cli\u003eBBR 只是略微提升了 Youtube 的连接吞吐（connection throughput），这是因为\nYouTube 已经将服务器的 streaming rate 充分控制在 BtlBw 以下，以最小化缓冲区膨胀（bufferbloat）和多次缓冲（rebuffer）问题。\u003c/li\u003e\n  \u003cli\u003e但即使是在这样的条件下，BBR 仍然将\u003cstrong\u003e\u003cmark\u003e全球范围内 RTT 的中值平均降低了 53%\u003c/mark\u003e\u003c/strong\u003e，\n而在发展中国家，这个降低的百分比更是达到了 80%。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e图 9 展示了 BBR vs. CUBIC 的中值 RTT 提升，数据来自一个星期内从五个大洲采集的超\n过 2 亿条 YouTube playback 连接，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在全球 70 亿移动互联用户中，超过一半是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e8-114kbps\u003c/code\u003e 的 2.5G 网络接入的\u003csup\u003e5\u003c/sup\u003e，\n这会导致很多已知问题，问题的根源在于，基于丢包的拥塞控制有所谓的\u003cstrong\u003e\u003cmark\u003e缓冲区填充倾向\u003c/mark\u003e\u003c/strong\u003e\n（buffer-filling propensities）\u003csup\u003e3\u003c/sup\u003e；\u003c/li\u003e\n  \u003cli\u003e这些系统的瓶颈链路通常位于在 SGSN (serving GPRS support node)\u003csup\u003e18\u003c/sup\u003e 和移动设备之间。\nSGSN 软件运行在有足够内存的标准 PC 平台上，因此\u003cstrong\u003e\u003cmark\u003e在互联网和移动设备之间经常有数 MB 的缓冲区\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson9.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 9. BBR vs. CUBIC median RTT improvement.\u003c/p\u003e\n\n\u003cp\u003e图 10 比较（仿真）了 BBR 和 CUBIC 的 SGSN Internet-to-mobile delay。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bbr-paper/vanjacobson10.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 10. Steady-state median RTT variation with link buffer size.\u003cbr/\u003e\n\n稳态时的 RTT 随链路缓冲区大小的变化，链路物理特性：128-Kbps/40-ms，8 BBR (green) / CUBIC (red) flows。\u003cbr/\u003e\n不管瓶颈缓冲区大小和活跃的 flow 数量如何，\u003cmark\u003eBBR 几乎一直将队列（延迟）保持在最小\u003c/mark\u003e；\u003cbr/\u003e\nCUBIC flow 永远会填满缓冲区， 因此\u003cmark\u003e延迟随着 buffer size 线性增长\u003c/mark\u003e。\n\u003c/p\u003e\n\n\u003cp\u003e几条水平线处表示的含义非常重要：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e除了连接建连时的 SYN 包之外，\n\u003cstrong\u003e\u003cmark\u003eTCP 已经适应到了一个非常大的 RTT 延迟\u003c/mark\u003e\u003c/strong\u003e（初始 SYN 包延迟由操作系统 hardcode，因此不会很大）。\u003c/li\u003e\n  \u003cli\u003e当移动设备通过一个大缓冲区的 SGSN 接收大块数据时（例如，手机软件自动更新），\n那这个设备就无法连接到互联网上的任何东西，直到队列被清空（SYN-ACK accept\npacket 被延迟的时间大于固定 SYN timeout）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eLinux 的初始超时时间是 1s，见\n\u003ca href=\"/blog/customize-tcp-initial-rto-with-bpf/\"\u003e\u003cmark\u003eCustomize TCP initial RTO (retransmission timeout) with BPF\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"6-问题讨论\"\u003e6 问题讨论\u003c/h1\u003e\n\n\u003ch2 id=\"61-移动蜂窝网络中的自适应带宽\"\u003e6.1 移动蜂窝网络中的自适应带宽\u003c/h2\u003e\n\n\u003cp\u003e蜂窝网络会根据每个用户的数据包排队（queue of packets）情况来调整每个用户的带宽\n（adapt per-subscriber bandwidth）。\u003c/p\u003e\n\n\u003cp\u003e早期版本的 BBR 通过针对性调优来产生非常小的队列，导致在低速情况下连接会卡住（stuck at low rates）。\n增大峰值 ProbeBW \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epacing_gain\u003c/code\u003e 来产生更大的队列，会使得卡住的情况大大减少，这暗示\n大队列（缓冲区）对某些网络也不是坏事。\u003c/p\u003e\n\n\u003cp\u003e使用当前的 \u003ci\u003e1.25 × BtlBw\u003c/i\u003epeak gain，\u003cstrong\u003e\u003cmark\u003eBBR 在任何网络上都不会比 CUBIC 差\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"62-延迟和聚合应答\"\u003e6.2 延迟和聚合应答\u003c/h2\u003e\n\n\u003cp\u003e蜂窝、WIFI 和有线宽带网络经常会\u003cstrong\u003e\u003cmark\u003e延迟和聚合 ACK\u003c/mark\u003e\u003c/strong\u003e（delay and aggregate）\n\u003csup\u003e1\u003c/sup\u003e。当 inflight 限制到单个 BDP 时，这会导致因为数据太少而导致的卡顿（\nthroughput-reducing stalls）。\u003c/p\u003e\n\n\u003cp\u003e将增大 ProbeBW cwnd_gain 增大到 2 使得 BBR 能在估计的传输速率上持续平稳发送，即使\nACK 被延迟了一个 RTT，这显著避免了卡顿（stalls）。\u003c/p\u003e\n\n\u003ch2 id=\"63-入向流量整形token-bucket-policers\"\u003e6.3 入向流量整形（Token-Bucket Policers）\u003c/h2\u003e\n\n\u003cp\u003eBBR 在 YouTube 部署之后，我们发现世界上大部分 ISP 都会用 TBP 来对接收到的流量进行处理（mangle） \u003csup\u003e7\u003c/sup\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e连接刚启动时，bucket 通常是满的，因此 BBR 能学到底层网络的 BtlBw，\u003c/li\u003e\n  \u003cli\u003e一旦 bucket 空了，所有发送速率快于（比 BtlBw 低一些的）bucket 填充速率的包，都会被丢弃，\u003c/li\u003e\n  \u003cli\u003eBBR 最终会学到这个新的传输速率，但 ProbeBW gain cycle 会导致持续的、少量的丢包（continuous moderate losses）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e为最小化上游带宽浪费，以及最小化因为丢包而导致的应用延迟增加，我们给 BBR 添加了\npolicer detection 和一个显式 policer 模型，并还在持续研究更好的方式来减缓\npolicer 带来的损失。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多入向流量整形（policing）内容，可参考：\n\u003ca href=\"/blog/lartc-qdisc-zh/\"\u003e\u003cmark\u003e（译）《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"64-与基于丢包的拥塞控制的竞争\"\u003e6.4 与基于丢包的拥塞控制的竞争\u003c/h2\u003e\n\n\u003cp\u003e不管是与其他 BBR flow 竞争，还是与基于丢包的拥塞控制竞争，\nBBR \u003cstrong\u003e\u003cmark\u003e都能收敛到瓶颈带宽的一个公平份额\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e即使基于丢包的拥塞控制填满了可用缓冲区，ProbeBW 仍然能健壮地将\nBtlBw estimate 朝着 flow 的公平份额移动，ProbeRTT 也是类似。\u003c/p\u003e\n\n\u003cp\u003e但是，不受通信双方控制的\u003cstrong\u003e\u003cmark\u003e路由器缓冲区会比 BDP 大好几倍\u003c/mark\u003e\u003c/strong\u003e，导致\nlong-lived loss-based competitors 占用大量队列，因此获得超出其公平的份额。\n如何解决（缓解）这个问题也是目前业内很热门的一个研究方向。\u003c/p\u003e\n\n\u003ch1 id=\"7-总结\"\u003e7 总结\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e重新思考拥塞控制\u003c/mark\u003e\u003c/strong\u003e让我们发掘出了这个古老世界的许多新东西。\n相比于使用\u003cstrong\u003e\u003cmark\u003e丢包、缓冲区大小\u003c/mark\u003e\u003c/strong\u003e等等这些\u003cstrong\u003e\u003cmark\u003e与拥塞只是弱相关\u003c/mark\u003e\u003c/strong\u003e的事件，\nBBR 以 Kleinrock 关于拥塞的规范化模型和与之相关的最佳工作位置作为出发点。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e关键的两个参数\u003c/mark\u003e\u003c/strong\u003e —— 延迟和带宽 —— \u003cstrong\u003e\u003cmark\u003e无法同时确定\u003c/mark\u003e\u003c/strong\u003e，\n这一结论看似绝望，但我们发现通过对二者进行\u003cstrong\u003e\u003cmark\u003e顺序估计\u003c/mark\u003e\u003c/strong\u003e（estimated\nsequentially）能绕开这一限制。具体来说，我们使用控制与估计理论领域的一些最新进\n展，创建了一个简单的分布式控制循环，后者能接近最优值，在充分利用网络的\n同时还能保持一个很小的缓冲队列。\u003c/p\u003e\n\n\u003cp\u003eGoogle BBR 的实现已经合并到 Linux 内核，关于一些实现细节见本文附录。\u003c/p\u003e\n\n\u003cp\u003eBBR is deployed on Google’s B4 backbone, improving throughput by orders of\nmagnitude compared with CUBIC. It is also being deployed on Google and YouTube\nWeb servers, substantially reducing latency on all five continents tested to\ndate, most dramatically in developing regions.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eBBR 只运行在发送端，无需协议、接收端或网络的改动\u003c/mark\u003e\u003c/strong\u003e，因此可以做到\n灰度（增量）部署。它只依赖 RTT 和应答包，因此大部分互联网传输协议都能实现这个算法。\u003c/p\u003e\n\n\u003cp\u003eThe authors are members of Google’s make-tcp-fast project, whose goal is to\nevolve Internet transport via fundamental research and open source software.\nProject contributions include TFO (TCP Fast Open), TLP (Tail Loss Probe), RACK\nloss recovery, fq/pacing, and a large fraction of the git commits to the Linux\nkernel TCP code for the past five years.\u003c/p\u003e\n\n\u003cp\u003eThe authors can be contacted at \u003ca href=\"mailto:bbr-dev@googlegroups.com\"\u003ebbr-dev@googlegroups.com\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"致谢\"\u003e致谢\u003c/h1\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThe authors are grateful to Len Kleinrock for pointing out the right way to\ndo congestion control.\u003c/li\u003e\n  \u003cli\u003eWe are indebted to Larry Brakmo for pioneering work on Vegas\u003csup\u003e2\u003c/sup\u003e and\n\u003cstrong\u003e\u003cmark\u003eNew Vegas congestion control that presaged many elements of BBR\u003c/mark\u003e\u003c/strong\u003e,\nand for advice and guidance during BBR’s early development.\u003c/li\u003e\n  \u003cli\u003eWe would also like to thank Eric Dumazet, Nandita Dukkipati, Jana Iyengar,\nIan Swett, M.  Fitz Nowlan, David Wetherall, Leonidas Kontothanassis, Amin\nVahdat, and the Google BwE and YouTube infrastructure teams for their\ninvaluable help and support.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"附录详细描述\"\u003e附录：详细描述\u003c/h1\u003e\n\n\u003ch2 id=\"顺序探测状态机a-state-machine-for-sequential-probing\"\u003e顺序探测状态机（A State Machine for Sequential Probing）\u003c/h2\u003e\n\n\u003cp\u003eThe pacing_gain controls how fast packets are sent relative to BtlBw and is key\nto BBR’s ability to learn. A pacing_gain \u0026gt; 1 increases inflight and decreases\npacket inter-arrival time, moving the connection to the right on figure 1. A\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epacing_gain \u0026lt; 1\u003c/code\u003e has the opposite effect, moving the connection to the left.\u003c/p\u003e\n\n\u003cp\u003eBBR uses this pacing_gain to implement a simple sequential probing state\nmachine that alternates between testing for higher bandwidths and then testing\nfor lower round-trip times. (It’s not necessary to probe for less bandwidth\nsince that is handled automatically by the BtlBw max filter: new\nmeasurements reflect the drop, so BtlBw will correct itself as soon as the\nlast old measurement times out of the filter. The RTprop min filter\nautomatically handles path length increases similarly.)\u003c/p\u003e\n\n\u003cp\u003eIf the bottleneck bandwidth increases, BBR must send faster to discover this.\nLikewise, if the actual round-trip propagation delay changes, this changes the\nBDP, and thus BBR must send slower to get inflight below BDP in order to\nmeasure the new RTprop. Thus, the only way to discover these changes is to run\nexperiments, sending faster to check for BtlBw increases or sending slower to\ncheck for RTprop decreases. The frequency, magnitude, duration, and structure\nof these experiments differ depending on what’s already known (startup or\nsteady-state) and sending app behavior (intermittent or continuous).\u003c/p\u003e\n\n\u003ch2 id=\"稳态行为steady-state-behavior\"\u003e稳态行为（Steady-State Behavior）\u003c/h2\u003e\n\n\u003cp\u003eBBR flows spend the vast majority of their time in ProbeBW state, probing for\nbandwidth using an approach called \u003ci\u003egain cycling\u003c/i\u003e, which helps BBR flows\nreach high throughput, low queuing delay, and convergence to a fair share of\nbandwidth. With gain cycling, BBR cycles through a sequence of values for the\npacing_gain. It uses an eight-phase cycle with the following pacing_gain\nvalues: 5/4, 3/4, 1, 1, 1, 1, 1, 1. Each phase normally lasts for the estimated\nRTprop. This design allows the gain cycle first to probe for more bandwidth\nwith a pacing_gain above 1.0, then drain any resulting queue with a pacing_gain\nan equal distance below 1.0, and then cruise with a short queue using a\npacing_gain of 1.0. The average gain across all phases is 1.0 because ProbeBW\naims for its average pacing rate to equal the available bandwidth and thus\nmaintain high utilization, while maintaining a small, well-bounded queue. Note\nthat while gain cycling varies the pacing_gain value, the cwnd_gain stays\nconstant at two, since delayed and stretched acks can strike at any time (see\nthe section on Delayed and Stretched Acks).\u003c/p\u003e\n\n\u003cp\u003eFurthermore, to improve mixing and fairness, and to reduce queues when multiple\nBBR flows share a bottleneck, BBR randomizes the phases of ProbeBW gain cycling\nby randomly picking an initial phase—from among all but the 3/4 phase—when\nentering ProbeBW. Why not start cycling with 3/4? The main advantage of the 3/4\npacing_gain is to drain any queue that can be created by running a 5/4\npacing_gain when the pipe is already full. When exiting Drain or ProbeRTT and\nentering ProbeBW, there is no queue to drain, so the 3/4 gain does not provide\nthat advantage. Using 3/4 in those contexts only has a cost: a link utilization\nfor that round of 3/4 instead of 1. Since starting with 3/4 would have a cost\nbut no benefit, and since entering ProbeBW happens at the start of any\nconnection long enough to have a Drain, BBR uses this small optimization.\u003c/p\u003e\n\n\u003cp\u003eBBR flows cooperate to periodically drain the bottleneck queue using a state\ncalled ProbeRTT. In any state other than ProbeRTT itself, if the RTProp\nestimate has not been updated (i.e., by getting a lower RTT measurement) for\nmore than 10 seconds, then BBR enters ProbeRTT and reduces the cwnd to a very\nsmall value (four packets). After maintaining this minimum number of packets in\nflight for at least 200 ms and one round trip, BBR leaves ProbeRTT and\ntransitions to either Startup or ProbeBW, depending on whether it estimates the\npipe was filled already.\u003c/p\u003e\n\n\u003cp\u003eBBR was designed to spend the vast majority of its time (about 98 percent) in\nProbeBW and the rest in ProbeRTT, based on a set of tradeoffs. ProbeRTT lasts\nlong enough (at least 200 ms) to allow flows with different RTTs to have\noverlapping ProbeRTT states, while still being short enough to bound the\nperformance penalty of ProbeRTT’s cwnd capping to roughly 2 percent (200 ms/10\nseconds). The RTprop filter window (10 seconds) is short enough to allow quick\nconvergence if traffic levels or routes change, but long enough so that\ninteractive applications (e.g., Web pages, remote procedure calls, video\nchunks) often have natural silences or low-rate periods within the window where\nthe flow’s rate is low enough or long enough to drain its queue in the\nbottleneck. Then the RTprop filter opportunistically picks up these RTprop\nmeasurements, and RTProp refreshes without requiring ProbeRTT. This way, flows\ntypically need only pay the 2 percent penalty if there are multiple bulk flows\nbusy sending over the entire RTProp window.\u003c/p\u003e\n\n\u003ch2 id=\"启动行为startup-behavior\"\u003e启动行为（Startup Behavior）\u003c/h2\u003e\n\n\u003cp\u003eWhen a BBR flow starts up, it performs its first (and most rapid) sequential\nprobe/drain process. Network-link bandwidths span a range of 10\u003csup\u003e12\u003c/sup\u003e—\nfrom a few bits to 100 gigabits per second. To learn BtlBw, given this huge\nrange to explore, BBR does a binary search of the rate space. This finds BtlBw\nvery quickly (\u003ci\u003elog\u003csub\u003e2\u003c/sub\u003eBDP\u003c/i\u003e round trips) but at the expense of\ncreating a 2BDP queue on the final step of the search. BBR’s Startup state does\nthis search and then the Drain state drains the resulting queue.\u003c/p\u003e\n\n\u003cp\u003eFirst, Startup grows the sending rate exponentially, doubling it each round. To\nachieve this rapid probing in the smoothest possible fashion, in Startup the\npacing_gain and cwnd_gain are set to \u003cspan style=\"font-family:\u0026#34;Stone Serif\u0026#34;\"\u003e2/ln2\u003c/span\u003e, the minimum value that will allow the sending rate\nto double each round. Once the pipe is full, the cwnd_gain bounds the queue to\n(\u003ci\u003ecwnd_gain\u003c/i\u003e \u003ci\u003e- 1\u003c/i\u003e) × \u003ci\u003eBDP\u003c/i\u003e.\u003c/p\u003e\n\n\u003cp\u003eDuring Startup, BBR estimates whether the pipe is full by looking for a plateau\nin the BtlBw estimate. If it notices that there are several (three) rounds\nwhere attempts to double the delivery rate actually result in little increase\n(less than 25 percent), then it estimates that it has reached BtlBw and exits\nStartup and enters Drain. BBR waits three rounds in order to have solid\nevidence that the sender is not detecting a delivery-rate plateau that was\ntemporarily imposed by the receive window. Allowing three rounds provides time\nfor the receiver’s receive-window autotuning to open up the receive window and\nfor the BBR sender to realize that BtlBw should be higher: in the first\nround the receive-window autotuning algorithm grows the receive window;\nin the second round the sender fills the higher receive window; in the\nthird round the sender gets higher delivery-rate samples. This\nthree-round threshold was validated by YouTube experimental data.\u003c/p\u003e\n\n\u003cp\u003eIn Drain, BBR aims to quickly drain any queue created in Startup by switching\nto a pacing_gain that is the inverse of the value used during Startup, which\ndrains the queue in one round. When the number of packets in flight matches the\nestimated BDP, meaning BBR estimates that the queue has been fully drained but\nthe pipe is still full, then BBR leaves Drain and enters ProbeBW.\u003c/p\u003e\n\n\u003cp\u003eNote that BBR’s Startup and CUBIC’s slow start both explore the bottleneck\ncapacity exponentially, doubling their sending rate each round; they differ in\nmajor ways, however. First, BBR is more robust in discovering available\nbandwidth, since it does not exit the search upon packet loss or (as in CUBIC’s\nHystart\u003csup\u003e10\u003c/sup\u003e) delay increases. Second, BBR smoothly accelerates its\nsending rate, while within every round CUBIC (even with pacing) sends a burst\nof packets and then imposes a gap of silence. Figure 4 demonstrates the number\nof packets in flight and the RTT observed on each acknowledgment for BBR and\nCUBIC.\u003c/p\u003e\n\n\u003ch2 id=\"应对突发流量reacting-to-transients\"\u003e应对突发流量（Reacting to Transients）\u003c/h2\u003e\n\n\u003cp\u003eThe network path and traffic traveling over it can make sudden dramatic\nchanges. To adapt to these smoothly and robustly, and reduce packet losses in\nsuch cases, BBR uses a number of strategies to implement the core model. First,\nBBR treats cwnd_gain×BDP as a target that the current cwnd approaches\ncautiously from below, increasing cwnd by no more than the amount of data\nacknowledged at any time. Second, upon a retransmission timeout, meaning the\nsender thinks all in-flight packets are lost, BBR conservatively reduces cwnd\nto one packet and sends a single packet (just like loss-based\ncongestion-control algorithms such as CUBIC). Finally, when the sender detects\npacket loss but there are still packets in flight, on the first round of the\nloss-repair process BBR temporarily reduces the sending rate to match the\ncurrent delivery rate; on second and later rounds of loss repair it ensures the\nsending rate never exceeds twice the current delivery rate. This significantly\nreduces transient losses when BBR encounters policers or competes with other\nflows on a BDP-scale buffer.\u003c/p\u003e\n\n\u003ch1 id=\"references\"\u003eReferences\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eAbrahamsson, M. 2015. TCP ACK suppression. IETF AQM mailing list; \u003ca href=\"https://www.ietf.org/mail-archive/web/aqm/current/msg01480.html\"\u003ehttps://www.ietf.org/mail-archive/web/aqm/current/msg01480.html\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBrakmo, L. S., Peterson, L.L. 1995. TCP Vegas: end-to-end congestion avoidance on a global Internet. \u003ci\u003eIEEE Journal on Selected Areas in Communications\u003c/i\u003e 13(8): 1465-1480.\u003c/li\u003e\n  \u003cli\u003eChakravorty, R., Cartwright, J., Pratt, I. 2002. Practical experience with TCP over GPRS. In \u003ci\u003eIEEE \u003c/i\u003e\u003ci\u003eGLOBECOM\u003c/i\u003e.\u003c/li\u003e\n  \u003cli\u003eCorbet, J. 2013. TSO sizing and the FQ scheduler. LWN.net; \u003ca href=\"https://lwn.net/Articles/564978/\"\u003ehttps://lwn.net/Articles/564978/\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eEricsson. 2015 Ericsson Mobility Report (June); \u003ca href=\"https://www.ericsson.com/res/docs/2015/ericsson-mobility-report-june-2015.pdf\"\u003ehttps://www.ericsson.com/res/docs/2015/ericsson-mobility-report-june-2015.pdf\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eESnet. Application tuning to optimize international astronomy workflow from NERSC to LFI-DPC at INAF-OATs; \u003ca href=\"http://fasterdata.es.net/data-transfer-tools/case-studies/nersc-astronomy/\"\u003ehttp://fasterdata.es.net/data-transfer-tools/case-studies/nersc-astronomy/\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eFlach, T., Papageorge, P., Terzis, A., Pedrosa, L., Cheng, Y., Karim, T., Katz-Bassett, E., Govindan, R. 2016. An Internet-wide analysis of traffic policing. In ACM \u003ci\u003eSIGCOMM\u003c/i\u003e: 468-482.\u003c/li\u003e\n  \u003cli\u003eGail, R., Kleinrock, L. 1981. An invariant property of computer network power. In \u003ci\u003eConference Record, International Conference on Communications\u003c/i\u003e: 63.1.1-63.1.5.\u003c/li\u003e\n  \u003cli\u003eGettys, J., Nichols, K. 2011. Bufferbloat: dark buffers in the Internet. \u003ci\u003eacmqueue\u003c/i\u003e 9(11); \u003ca href=\"https://queue.acm.org/detail.cfm?id=2071893\"\u003ehttp://queue.acm.org/detail.cfm?id=2071893\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eHa, S., Rhee, I. 2011. Taming the elephants: new TCP slow start. \u003ci\u003eComputer Networks\u003c/i\u003e 55(9): 2092-2110.\u003c/li\u003e\n  \u003cli\u003eHa, S., Rhee, I., Xu, L. 2008. CUBIC: a new TCP-friendly high-speed TCP variant. \u003ci\u003eACM SIGOPS Operating Systems Review\u003c/i\u003e 42(5): 64-74.\u003c/li\u003e\n  \u003cli\u003eHeidergott, B., Olsder, G. J., Van Der Woude, J. 2014. \u003ci\u003eMax Plus at Work: Modeling and Analysis of Synchronized Systems: a Course on Max-Plus Algebra and its Applications\u003c/i\u003e. Princeton University Press.\u003c/li\u003e\n  \u003cli\u003eJacobson, V. 1988. Congestion avoidance and control. \u003ci\u003eACM SIGCOMM Computer Communication Review\u003c/i\u003e 18(4): 314-329.\u003c/li\u003e\n  \u003cli\u003eJaffe, J. 1981. Flow control power is nondecentralizable. \u003ci\u003eIEEE Transactions on Communications\u003c/i\u003e 29(9): 1301-1306.\u003c/li\u003e\n  \u003cli\u003eJain, S., Kumar, A., Mandal, S., Ong, J., Poutievski, L., Singh, A., Venkata, S., Wanderer, J., Zhou, J., Zhu, M., et al. 2013. B4: experience with a globally-deployed software defined WAN. \u003ci\u003eACM SIGCOMM Computer Communication Review\u003c/i\u003e 43(4): 3-14.\u003c/li\u003e\n  \u003cli\u003eKleinrock, L. 1979. Power and deterministic rules of thumb for probabilistic problems in computer communications. In \u003ci\u003eConference Record, International Conference on Communications: 43.1.1-43.1.10.\u003c/i\u003e\u003c/li\u003e\n  \u003cli\u003eMathis, M., Semke, J., Mahdavi, J., Ott, T. 1997. The macroscopic behavior of the TCP congestion avoidance algorithm. \u003ci\u003eACM SIGCOMM Computer Communication Review\u003c/i\u003e 27(3): 67-82.\u003c/li\u003e\n  \u003cli\u003eWikipedia. \u003ca href=\"https://en.wikipedia.org/wiki/GPRS_core_network#Serving_GPRS_support_node_.28SGSN.29\"\u003eGPRS core network serving GPRS support node\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/trip-first-step-towards-cloud-native-security/\"\u003e\u003cspan\u003e« Trip.com: First Step towards Cloud Native Security\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cracking-k8s-network-policy/\"\u003e\u003cspan\u003eCracking Kubernetes Network Policy »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-01-02T00:00:00Z",
  "Author": "Arthur Chiao"
}