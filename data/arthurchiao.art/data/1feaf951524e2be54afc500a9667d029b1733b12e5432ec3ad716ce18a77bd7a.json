{
  "Source": "arthurchiao.art",
  "Title": "[译] BPF 可移植性和 CO-RE（一次编译，到处运行）（Facebook，2020）",
  "Link": "https://arthurchiao.art/blog/bpf-portability-and-co-re-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] BPF 可移植性和 CO-RE（一次编译，到处运行）（Facebook，2020）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-03-12 | Last Update 2022-04-22\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2020 年 Facebook 的一篇博客：\n\u003ca href=\"https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html\"\u003eBPF Portability and CO-RE\u003c/a\u003e，\n作者 Andrii Nakryiko。\u003c/p\u003e\n\n\u003cp\u003e关于 BPF CO-RE 的目标，引用文中的一段总结就是：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003e作为一种\u003cstrong\u003e\u003cmark\u003e简单的方式\u003c/mark\u003e\u003c/strong\u003e，帮助 BPF 开发者解决\u003cstrong\u003e\u003cmark\u003e简单的移植性问题\u003c/mark\u003e\u003c/strong\u003e（例如读取结构体的字段），并且\u003c/li\u003e\n    \u003cli\u003e作为一种\u003cstrong\u003e\u003cmark\u003e不是最优，但可用的方式\u003c/mark\u003e\u003c/strong\u003e，帮助 BPF 开发者\n解决\u003cstrong\u003e\u003cmark\u003e复杂的移植性问题\u003c/mark\u003e\u003c/strong\u003e（例如不兼容的数据结构改动、复杂的用户空间控制条件等）。\u003c/li\u003e\n    \u003cli\u003e使开发者能遵循\u003cstrong\u003e\u003cmark\u003e“一次编译、到处运行”\u003c/mark\u003e\u003c/strong\u003e（Compile Once – Run Everywhere）范式。\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-bpf-现状\" id=\"markdown-toc-1-bpf-现状\"\u003e1 BPF 现状\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-bpf-可移植性面临的问题\" id=\"markdown-toc-2-bpf-可移植性面临的问题\"\u003e2 BPF 可移植性面临的问题\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-可移植为什么理论上可行\" id=\"markdown-toc-21-可移植为什么理论上可行\"\u003e2.1 可移植：为什么理论上可行\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#211-不是所有-bpf-程序都依赖内核内部数据结构\" id=\"markdown-toc-211-不是所有-bpf-程序都依赖内核内部数据结构\"\u003e2.1.1 不是所有 BPF 程序都依赖内核内部数据结构\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#212-内核-bpf-基础设施提供了一组有限的稳定接口\" id=\"markdown-toc-212-内核-bpf-基础设施提供了一组有限的稳定接口\"\u003e2.1.2 内核 BPF 基础设施提供了一组有限的“稳定接口”\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-可移植挑战\" id=\"markdown-toc-22-可移植挑战\"\u003e2.2 可移植：挑战\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-内核版本不同字段被重命名或移动位置\" id=\"markdown-toc-221-内核版本不同字段被重命名或移动位置\"\u003e2.2.1 内核版本不同：字段被重命名或移动位置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-内核版本相同但配置不同字段在编译时被移除compile-out\" id=\"markdown-toc-222-内核版本相同但配置不同字段在编译时被移除compile-out\"\u003e2.2.2 内核版本相同但配置不同：字段在编译时被移除（compile out）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#223-小结\" id=\"markdown-toc-223-小结\"\u003e2.2.3 小结\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-可移植bcc-方式\" id=\"markdown-toc-23-可移植bcc-方式\"\u003e2.3 可移植：BCC 方式\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-开发和部署工作流\" id=\"markdown-toc-231-开发和部署工作流\"\u003e2.3.1 开发和部署工作流\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-缺点\" id=\"markdown-toc-232-缺点\"\u003e2.3.2 缺点\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-可移植新方式bpf-co-re\" id=\"markdown-toc-24-可移植新方式bpf-co-re\"\u003e2.4 可移植：新方式（BPF CO-RE）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-bpf-co-re高层机制\" id=\"markdown-toc-3-bpf-co-re高层机制\"\u003e3 BPF CO-RE：高层机制\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-组件与工作流\" id=\"markdown-toc-31-组件与工作流\"\u003e3.1 组件与工作流\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-btfbpf-type-format\" id=\"markdown-toc-32-btfbpf-type-format\"\u003e3.2 BTF（BPF Type Format）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-编译器clang支持\" id=\"markdown-toc-33-编译器clang支持\"\u003e3.3 编译器（clang）支持\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-加载器libbpf\" id=\"markdown-toc-34-加载器libbpf\"\u003e3.4 加载器（libbpf）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-内核\" id=\"markdown-toc-35-内核\"\u003e3.5 内核\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-bpf-co-re用户侧经验\" id=\"markdown-toc-4-bpf-co-re用户侧经验\"\u003e4 BPF CO-RE：用户侧经验\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-摆脱内核头文件依赖\" id=\"markdown-toc-41-摆脱内核头文件依赖\"\u003e4.1 摆脱内核头文件依赖\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-读取内核结构体字段\" id=\"markdown-toc-42-读取内核结构体字段\"\u003e4.2 读取内核结构体字段\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#421-例子读取-task_struct-pid-字段\" id=\"markdown-toc-421-例子读取-task_struct-pid-字段\"\u003e4.2.1 例子：读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct-\u0026gt;pid\u003c/code\u003e 字段\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#方式一bcc可移植\" id=\"markdown-toc-方式一bcc可移植\"\u003e方式一：BCC（可移植）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#方式二libbpf--bpf_prog_type_tracing不可移植\" id=\"markdown-toc-方式二libbpf--bpf_prog_type_tracing不可移植\"\u003e方式二：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibbpf\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e（不可移植）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#方式三bpf_prog_type_tracing--co-re可移植\" id=\"markdown-toc-方式三bpf_prog_type_tracing--co-re可移植\"\u003e方式三：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e + CO-RE（可移植）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#方式四libbpf--co-re-bpf_core_read可移植\" id=\"markdown-toc-方式四libbpf--co-re-bpf_core_read可移植\"\u003e方式四：libbpf + CO-RE \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_read()\u003c/code\u003e（可移植）\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#422-例子读取-task-mm-exe_file-f_inode-i_ino-字段\" id=\"markdown-toc-422-例子读取-task-mm-exe_file-f_inode-i_ino-字段\"\u003e4.2.2 例子：读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask-\u0026gt;mm-\u0026gt;exe_file-\u0026gt;f_inode-\u0026gt;i_ino\u003c/code\u003e 字段\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#方式一bcc可移植-1\" id=\"markdown-toc-方式一bcc可移植-1\"\u003e方式一：BCC（可移植）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#方式二bpf-co-re可移植\" id=\"markdown-toc-方式二bpf-co-re可移植\"\u003e方式二：BPF CO-RE（可移植）\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#423-其他与字段读取相关的-co-re-宏\" id=\"markdown-toc-423-其他与字段读取相关的-co-re-宏\"\u003e4.2.3 其他与字段读取相关的 CO-RE 宏\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-处理内核版本和配置差异\" id=\"markdown-toc-43-处理内核版本和配置差异\"\u003e4.3 处理内核版本和配置差异\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#431-libbpf-提供的-externs-kconfig-全局变量\" id=\"markdown-toc-431-libbpf-提供的-externs-kconfig-全局变量\"\u003e4.3.1 libbpf 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexterns\u003c/code\u003e Kconfig 全局变量\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#432-struct-flavors\" id=\"markdown-toc-432-struct-flavors\"\u003e4.3.2 struct flavors\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-根据用户提供的配置修改程序行为\" id=\"markdown-toc-44-根据用户提供的配置修改程序行为\"\u003e4.4 根据用户提供的配置修改程序行为\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#441-bpf-map-方式\" id=\"markdown-toc-441-bpf-map-方式\"\u003e4.4.1 BPF map 方式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#442-只读的全局数据方式\" id=\"markdown-toc-442-只读的全局数据方式\"\u003e4.4.2 只读的全局数据方式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-总结\" id=\"markdown-toc-5-总结\"\u003e5 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e本文介绍 BPF 可移植性面临的问题，以及 BPF CO-RE（Compile Once – Run Everywhere）\n是如何解决这些问题的。\u003c/p\u003e\n\n\u003ch1 id=\"1-bpf-现状\"\u003e1 BPF 现状\u003c/h1\u003e\n\n\u003cp\u003e(e)BPF 出来之后，社区一直在试图\u003cstrong\u003e简化 BPF 程序的开发过程\u003c/strong\u003e —— 最好能像开发\n用户空间应用程序（userspace application）一样简单直接 —— 可惜这个目标从未实现。\n具体来说，在使用性（usability）上确实有很大进步，但另一个重要方面却被忽略了\n（\u003cstrong\u003e大部分出于技术原因\u003c/strong\u003e）：可移植性。\u003c/p\u003e\n\n\u003cp\u003e那么，什么是 \u003cmark\u003e”BPF 可移植性“\u003c/mark\u003e（BPF portability）？我们定义它是\n\u003cstrong\u003e这样一种能力\u003c/strong\u003e：编写的程序\u003cstrong\u003e通过编译和内核校验之后\u003c/strong\u003e，能\u003cmark\u003e正确地\u003c/mark\u003e在\n\u003cstrong\u003e不同版本的内核\u003c/strong\u003e上运行 —— 而\u003cstrong\u003e无需针对不同内核重新编译\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e本文首先介绍 BPF 可移植性面临的问题，然后介绍我们的\u003cstrong\u003e\u003cmark\u003e解决方案：BPF CO-RE\u003c/mark\u003e\u003c/strong\u003e。\n接下来内容如下：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e讨论 BPF 可移植性问题本身，分析它所面临的挑战，以及为什么解决这些挑战如此重要；\u003c/li\u003e\n  \u003cli\u003e从较高层次查看 BPF CO-RE 的各组件，以及它们是如何组织成一个完整方案的；\u003c/li\u003e\n  \u003cli\u003e以一些例子（BPF 代码片段）结束本文，展示 BPF CO-RE 中用户可见的 API。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"2-bpf-可移植性面临的问题\"\u003e2 BPF 可移植性面临的问题\u003c/h1\u003e\n\n\u003cp\u003eBPF 程序是\u003cstrong\u003e由用户提供的\u003c/strong\u003e、经过验证之后\u003cstrong\u003e\u003cmark\u003e在内核上下文中执行\u003c/mark\u003e\u003c/strong\u003e的程序。\nBPF \u003cmark\u003e运行在内核内存空间\u003c/mark\u003e（kernel memory space），\u003cmark\u003e能访问大量的\n内核内部状态\u003c/mark\u003e（internal kernel state）。\n这使得 BPF 程序功能极其强大，也是为什么它能成功地应用在大量不同场景的原因之一。\u003c/p\u003e\n\n\u003cp\u003e然而，与强大能力相伴而生的是我们如今面临的可移植性问题：\u003cmark\u003eBPF 程序\n并不控制它\u003cstrong\u003e运行时所在内核\u003c/strong\u003e的内存布局\u003c/mark\u003e（memory layout）。\n因此，BPF 程序只能运行在\u003cstrong\u003e开发和编译这些程序时\u003c/strong\u003e所在的内核。\u003c/p\u003e\n\n\u003cp\u003e另外，\u003cstrong\u003e内核字段类型（kernel types）和数据结构（data structures）也在不断变化\u003c/strong\u003e。\n不同的内核版本中，同一结构体的同一字段所在的位置可能会不同 —— 甚至已经\n移到一个新的内部结构体（inner struct）中。此外，字段还可能会被重命名、删除、\n改变类型，或者（根据不同内核配置）被条件编译掉。\u003c/p\u003e\n\n\u003ch2 id=\"21-可移植为什么理论上可行\"\u003e2.1 可移植：为什么理论上可行\u003c/h2\u003e\n\n\u003cp\u003e以上分析可知，内核版本升级时很多东西都会发生变化，而 BPF 开发者希望能够\u003cmark\u003e\n避免这些变化对 BPF 程序造成影响\u003c/mark\u003e。这听上去似乎不可能 —— 内核环境都在不断变化，\n依赖内核环境执行的 BPF 程序又如何能置身事外呢？\u003c/p\u003e\n\n\u003cp\u003e但实际上，这是可能的，有下面几个原因。\u003c/p\u003e\n\n\u003ch3 id=\"211-不是所有-bpf-程序都依赖内核内部数据结构\"\u003e2.1.1 不是所有 BPF 程序都依赖内核内部数据结构\u003c/h3\u003e\n\n\u003cp\u003e一个例子是 BPF 工具 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eopensnoop\u003c/code\u003e，它基于 kprobes/tracepoints 跟踪进程打开的文件，\n因此\u003cstrong\u003e\u003cmark\u003e只要能拦截到少数几个系统调用\u003c/mark\u003e\u003c/strong\u003e就能工作。由于系统调用接口\n提供稳定的 ABI，不会随着内核版本而变，因此这样的 BPF 程序做到可移植是问题不大的。\u003c/p\u003e\n\n\u003cp\u003e不幸的是，这种类型的 BPF 程序很少，而且它们能做的事情通常也是非常有限的。\u003c/p\u003e\n\n\u003ch3 id=\"212-内核-bpf-基础设施提供了一组有限的稳定接口\"\u003e2.1.2 内核 BPF 基础设施提供了一组有限的“稳定接口”\u003c/h3\u003e\n\n\u003cp\u003e内核版本升级时保证稳定，因此 BPF 程序可以依赖这组接口。\n实际上，底层结构体和工作机制都可能发生变化，但这组稳定接口向用户程序屏蔽了这些变动。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e一个例子是网络应用中的 \u003ccode\u003estruct sk_buff\u003c/code\u003e 和 \u003ccode\u003estruct __sk_buff\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sk_buff\u003c/code\u003e 是内核中的数据包（socket buffer）表示，字段非常多，并且经常发生变化；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct __sk_buff\u003c/code\u003e 是 \u003cstrong\u003e\u003cmark\u003eBPF 校验器提供的一个屏蔽 sk_buff 变化的稳定接口（属性集合）\u003c/mark\u003e\u003c/strong\u003e，\n  将用户程序与底层的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sk_buff\u003c/code\u003e 解耦开来，因此后者内存布局发生变化时，不会影响 BPF 程序。\u003c/li\u003e\n  \u003cli\u003e所有对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct __sk_buff\u003c/code\u003e 字段的访问都会被\u003cstrong\u003e\u003cmark\u003e透明地转换成对 struct sk_buff 的访问\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e很多 BPF 程序类型都有类似的机制，\u003cstrong\u003e\u003cmark\u003e这种结构体在 BPF 中称为上下文（context）\u003c/mark\u003e\u003c/strong\u003e，\n触发 BPF 程序执行时，传递 BPF 程序的参数一般就是这种上下文指针（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct __sk_buff *ctx\u003c/code\u003e）。\n因此，如果开发 BPF 程序时使用的是这些结构体，那这样的程序大概率是可移植的。\u003c/p\u003e\n\n\u003ch2 id=\"22-可移植挑战\"\u003e2.2 可移植：挑战\u003c/h2\u003e\n\n\u003cp\u003e但是，一旦需要获取原始的内核内部数据（raw internal kernel data）—— 例如\n常见的表示进程或线程的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task_struct\u003c/code\u003e，这个结构体中有非常详细的进程信息 —— \n那你就只能靠自己了。对于 \u003cstrong\u003etracing、monitoring 和 profiling 应用\u003c/strong\u003e来说这个需求\n非常常见，而这类 BPF 程序也是极其有用的。\u003c/p\u003e\n\n\u003ch3 id=\"221-内核版本不同字段被重命名或移动位置\"\u003e2.2.1 内核版本不同：字段被重命名或移动位置\u003c/h3\u003e\n\n\u003cp\u003e在这种情况下，\u003cstrong\u003e\u003cmark\u003e如何保证读到的一定是我们期望的那个字段呢\u003c/mark\u003e\u003c/strong\u003e —— 例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e原来的程序是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task_struct\u003c/code\u003e offset 8 地址读取数据，\u003c/li\u003e\n  \u003cli\u003e由于新内核加个了 16 字节新字段，那此时正确的方式应该是从 offset 24 地址读，\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这还没完：如果这个字段被改名了呢？例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ethread_struct\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efs\u003c/code\u003e 字段（获取 thread-local storage 用），\n在 4.6 到 4.7 内核升级时就被重命名为了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efsbase\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"222-内核版本相同但配置不同字段在编译时被移除compile-out\"\u003e2.2.2 内核版本相同但配置不同：字段在编译时被移除（compile out）\u003c/h3\u003e\n\n\u003cp\u003e另一种情况：内核版本相同，但内核编译时的配置不同，导致\n结构体的某些字段在编译器时被完全移除了。\u003c/p\u003e\n\n\u003cp\u003e具体例子：某些可选的\u003cmark\u003e审计字段\u003c/mark\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"223-小结\"\u003e2.2.3 小结\u003c/h3\u003e\n\n\u003cp\u003e所有这些都意味着：依赖\u003cstrong\u003e\u003cmark\u003e开发环境本地的内核头文件\u003c/mark\u003e\u003c/strong\u003e编译的 BPF 程序，\n是无法直接分发到其他机器运行 —— 然后期待它们返回正确结果的。\n这是由于不同版本的内核头文件所假设的内存布局是不同的。\u003c/p\u003e\n\n\u003ch2 id=\"23-可移植bcc-方式\"\u003e2.3 可移植：BCC 方式\u003c/h2\u003e\n\n\u003cp\u003e目前，人们可以用 \u003ca href=\"https://github.com/iovisor/bcc/\"\u003eBCC\u003c/a\u003e (BPF Compiler Collection)\n解决这个问题。\u003c/p\u003e\n\n\u003ch3 id=\"231-开发和部署工作流\"\u003e2.3.1 开发和部署工作流\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e开发：将 BPF C 源码以\u003cstrong\u003e\u003cmark\u003e文本字符串\u003c/mark\u003e\u003c/strong\u003e形式，\u003cstrong\u003e嵌入（Python 编写的）用户空间控制应用\u003c/strong\u003e（control application）；\u003c/li\u003e\n  \u003cli\u003e部署：将控制应用以源码的形式拷贝到目标机器；\u003c/li\u003e\n  \u003cli\u003e执行：在目标机器上，BCC 调用它内置的 Clang/LLVM，然后 include 本地内核头文件\n  （\u003cstrong\u003e需要确保本机已经安装了正确版本的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekernel-devel\u003c/code\u003e 包\u003c/strong\u003e）然后\u003cmark\u003e现场执行编译、加载、运行\u003c/mark\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这种方式能确保 BPF 程序期望的内存布局与目标机器内核的内存布局是完全一致的。\u003c/p\u003e\n\n\u003cp\u003e对于那些\u003cstrong\u003e内核版本相关的可选字段或条件编译相关的配置代码\u003c/strong\u003e，只需要在源代码中\n用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#ifdef\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#else\u003c/code\u003e 做处理，BCC 内置的 Clang 能正确处理这些宏，最终剩下的就是与\n当前内核相匹配的源代码。这就是 BCC 解决内核版本差异的方式。\u003c/p\u003e\n\n\u003ch3 id=\"232-缺点\"\u003e2.3.2 缺点\u003c/h3\u003e\n\n\u003cp\u003eBCC 方式可行，但存在一些很大的缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eClang/LLVM 是一个庞大的库\u003c/mark\u003e\u003c/strong\u003e，在部署时除了要分发 BPF 程序，还必须一起分发这个大库。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eClang/LLVM 这两个庞然大物\u003cstrong\u003e非常消耗资源\u003c/strong\u003e，因此\u003cstrong\u003e\u003cmark\u003e每次在目标机器上编译 BPF 代码，都将消耗大量系统资源\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e尤其在线上的生产机器，现场编译可能会使机器负载瞬间飙高，导致生产问题。\u003c/li\u003e\n      \u003cli\u003e同样，如果机器本身已经负载很高，那编译一段很小的 BPF 程序可能都要几分钟。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e内核头文件强依赖：这些头文件必须已经在目标机器上了\u003c/mark\u003e\u003c/strong\u003e。\n在大部分情况下这都不是问题，但有时可能会带来麻烦。\u003c/p\u003e\n\n    \u003cp\u003e这对内核开发者来说也尤其头疼，因为他们经常要编译和部署一次性的内核，用于在\n 开发过程中验证某些问题。而机器上没有指定的、版本正确的内核头文件包，基于 BCC\n 的应用就无法正常工作。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e拖慢开发和迭代速度。\u003c/p\u003e\n\n    \u003cp\u003eBPF 程序的\u003cstrong\u003e\u003cmark\u003e测试和开发过程也非常繁琐\u003c/mark\u003e\u003c/strong\u003e，很多错误只有到了运行时\n（runtime）才会出现，而一旦出现就只能重启用户空间控制应用。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e总体来说，虽然 bcc 是一个很伟大的工具 —— 尤其是用于快速原型、实验和开发小工具 ——\n但广泛用于生产部署时，它存在非常明显的不足。\u003c/p\u003e\n\n\u003ch2 id=\"24-可移植新方式bpf-co-re\"\u003e2.4 可移植：新方式（BPF CO-RE）\u003c/h2\u003e\n\n\u003cp\u003e为了更彻底地解决 BPF 移植性问题，我们\u003cstrong\u003e设计了 BPF CO-RE\u003c/strong\u003e，并相信这是\n\u003cmark\u003eBPF 程序的未来开发方式\u003c/mark\u003e，尤其适用于开发复杂、真实环境中的 BPF 应用。\u003c/p\u003e\n\n\u003ch1 id=\"3-bpf-co-re高层机制\"\u003e3 BPF CO-RE：高层机制\u003c/h1\u003e\n\n\u003cp\u003eBPF CO-RE 将它所依赖的如下软件栈和它的数据集中到了一起，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e内核\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e用户空间 BPF 加载器库（libbpf）\u003c/mark\u003e\u003c/li\u003e\n  \u003cli\u003e编译器（clang）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e从而使我们能以一种轻松的方式编写可移植 BPF 程序，在\u003cstrong\u003e单个预编译的 BPF 程序内\n（pre-compiled BPF program）处理不同内核之间的差异\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"31-组件与工作流\"\u003e3.1 组件与工作流\u003c/h2\u003e\n\n\u003cp\u003eBPF CO-RE 需要下列组件之间的紧密合作：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eBTF 类型信息：用于获取\u003cmark\u003e内核、BPF 程序类型及 BPF 代码的关键信息\u003c/mark\u003e，\n这也是下面其他部分的基础；\u003c/li\u003e\n  \u003cli\u003e编译器（clang）：给 BPF C 代码提供了\u003cmark\u003e表达能力和记录重定位（relocation）信息的能力\u003c/mark\u003e；\u003c/li\u003e\n  \u003cli\u003eBPF loader (\u003ca href=\"https://github.com/libbpf/libbpf\"\u003elibbpf\u003c/a\u003e)：将内核的 BTF 与 BPF 程序联系起来，\n\u003cmark\u003e将编译之后的 BPF 代码适配到目标机器的特定内核\u003c/mark\u003e；\u003c/li\u003e\n  \u003cli\u003e内核：虽然\u003cstrong\u003e\u003cmark\u003e对 BPF CO-RE 完全不感知\u003c/mark\u003e\u003c/strong\u003e，但提供了一些 BPF 高级特性，使某些高级场景成为可能。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e以上几部分相结合，提供了一种开发可移植 BPF 程序的\u003cstrong\u003e史无前例的能力\u003c/strong\u003e：这个开发\n过程不仅方便（ease），而且具备很强的适配性（adaptability）和\u003cmark\u003e表达能力\u003c/mark\u003e（expressivity）。\n在此之前，实现同样的可移植效果只能通过 BCC 在运行时编译 BPF C 程序，而前面也分析了，\nBCC 开销非常高。\u003c/p\u003e\n\n\u003ch2 id=\"32-btfbpf-type-format\"\u003e3.2 BTF（BPF Type Format）\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/btf.html\"\u003eBTF\u003c/a\u003e 是 BPF CO-RE 的核心之一，\n它是一种\u003cstrong\u003e\u003cmark\u003e与 DWARF 类似的调试信息\u003c/mark\u003e\u003c/strong\u003e，但\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e更通用、表达更丰富，用于描述 C 程序的所有类型信息；\u003c/li\u003e\n  \u003cli\u003e更简单，空间效率更高（使用 \u003ca href=\"https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html\"\u003eBTF 去重算法\u003c/a\u003e），\n占用空间比 DWARF 低 100x。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e启用 BTF 需要在\u003cstrong\u003e\u003cmark\u003e编译内核时指定 CONFIG_DEBUG_INFO_BTF=y\u003c/mark\u003e\u003c/strong\u003e，\n这样内核在运行时（runtime）就会携带 BTF 信息。\u003c/p\u003e\n\n\u003cp\u003eBTF 除了被内核自身使用，现在还用于增强 BPF 校验器自身的能力 —— 某些能力甚至超过了一年前我们的想象力天花板（例\n如，已经有了直接读取内核内存的能力，不再需要通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e 间接读取了）。\u003c/p\u003e\n\n\u003cp\u003e更重要的是，内核已经将这个\u003cmark\u003e自描述的权威 BTF 信息\u003c/mark\u003e（定义结构体的精确内存布局等信息）\n\u003cmark\u003e通过 sysfs 暴露出来\u003c/mark\u003e，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/btf/vmlinux\u003c/code\u003e。\n下面的命令将\u003cstrong\u003e\u003cmark\u003e生成一个与所有内核类型兼容的 C 头文件\u003c/mark\u003e\u003c/strong\u003e（通常称为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003evmlinux.h\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool btf dump file /sys/kernel/btf/vmlinux format c\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里说的“所有”真的是\u003cstrong\u003e“所有”\u003c/strong\u003e：\u003cmark\u003e包括那些并未通过 kernel-devel package 导出的类型\u003c/mark\u003e！\u003c/p\u003e\n\n\u003ch2 id=\"33-编译器clang支持\"\u003e3.3 编译器（clang）支持\u003c/h2\u003e\n\n\u003cp\u003e为了让 BPF 加载器（例如 libbpf）将 BPF 程序适配到目标机器所运行的内核上，\n\u003cstrong\u003eClang 增加了几个新的 built-in\u003c/strong\u003e，功能是导出（emit）\n\u003cmark\u003eBTF relocations\u003c/mark\u003e（重定位信息），后者是对 \u003cstrong\u003eBPF 程序想读取的那些信息的高层描述\u003c/strong\u003e。\n例如，如果想访问 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct-\u0026gt;pid\u003c/code\u003e，那 \u003cmark\u003eclang 将做如下记录\u003c/mark\u003e：这是一个\n位于结构体 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task_struct\u003c/code\u003e 中、类型为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid_t\u003c/code\u003e、名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid\u003c/code\u003e 的字段。\u003c/p\u003e\n\n\u003cp\u003e有了这种方式，即使目标内核的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct\u003c/code\u003e 结构体中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid\u003c/code\u003e 字段位置已经发生了变\n化（例如，由于这个字段前面加了新字段），甚至已经移到了某个内部嵌套的匿名结构体\n或 union 中（在 C 语言中这种行为是完全透明的，因此内核开发者这样做时并不会有特别\n的顾虑），我们\u003cmark\u003e仍然能通过名字和类型信息找到这个字段\u003c/mark\u003e。这称为\n\u003cstrong\u003e\u003cmark\u003efield offset relocation\u003c/mark\u003e\u003c/strong\u003e（字段偏移重定位）。\u003c/p\u003e\n\n\u003cp\u003e除了字段重定位，其他一些字段相关的操作，例如判断 \u003cmark\u003efield existence\u003c/mark\u003e（\n字段是否存在）或者 \u003cmark\u003efield size（字段长度）\u003c/mark\u003e都是支持的。\n甚至对 bitfields（比特位字段，在 C 语言中是出了名的”难处理“的类型，C 社区一直在努力让它们变得可重定位）\n，我们仍然能基于 BTF 信息来使它们可重定位（relocatable），并且整个过程对 BPF 开\n发者透明。\u003c/p\u003e\n\n\u003ch2 id=\"34-加载器libbpf\"\u003e3.4 加载器（libbpf）\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/libbpf/libbpf\"\u003elibbpf\u003c/a\u003e 作为一个 \u003cmark\u003eBPF 程序加载器\u003c/mark\u003e（loader），\n处理前面介绍的内核 BTF 和 clang 重定位信息。它\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e读取编译之后得到的 BPF ELF 目标文件，\u003c/li\u003e\n  \u003cli\u003e进行一些必要的后处理，\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e设置各种内核对象\u003c/mark\u003e（bpf maps、bpf 程序等），\u003c/li\u003e\n  \u003cli\u003e将 BPF 程序加载到内核，然后触发校验器的验证过程。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003elibbpf 知道如何对 BPF 程序进行裁剪，以适配到目标机器的内核上\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e查看 BPF 程序记录的 BTF 和重定位信息，\u003c/li\u003e\n  \u003cli\u003e拿这些信息跟当前内核提供的 BTF 信息相匹配，\u003c/li\u003e\n  \u003cli\u003e解析和匹配所有的类型和字段，更新所有必要的 offsets 和其他可重定位数据。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e最终确保 BPF 程序在这个特定的内核上是能正确工作的。\u003c/p\u003e\n\n\u003cp\u003e如果一切顺利，你（作为 BPF 应用开发者）将得到一个针对目标机器“裁剪定制”的 BPF\n程序，就像这个程序是专门针对这个内核编译的一样。但这种工作方式无需将 clang 与\nBPF 一起打包部署，也没有在目标机器上运行时编译（runtime）的开销。\u003c/p\u003e\n\n\u003ch2 id=\"35-内核\"\u003e3.5 内核\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e内核无需太多改动就能支持 BPF CO-RE\u003c/mark\u003e\u003c/strong\u003e，这一点可能令很多人感到惊讶。\n由于设计合理，因此\u003cstrong\u003e对于内核来说，libbpf 处理之后的 BPF 程序，与\n其他任何合法的 BPF 程序是一样的\u003c/strong\u003e —— 与在这台机器上依赖最新内核头文件编译出的\nBPF 程序并无区别。这意味要 \u003cmark\u003eBPF CO-RE 并不依赖最新的内核功能\u003c/mark\u003e，因此\n应用范围更广，适配速度更快。\u003c/p\u003e\n\n\u003cp\u003e某些高级场景可能会需要更新的内核，但这些场景很少。接下来介绍 BPF CO-RE 用户侧机制\n时会讨论到这样的场景。\u003c/p\u003e\n\n\u003ch1 id=\"4-bpf-co-re用户侧经验\"\u003e4 BPF CO-RE：用户侧经验\u003c/h1\u003e\n\n\u003cp\u003e接下来看几个真实世界中 BPF CO-RE 的典型场景，以及它是如何解决面临的一些问题的。\n我们将看到，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一些可移植性问题（例如，兼容 struct 内存布局差异）能够处理地非常透明和自然，\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e而另一些则需要通过显式处理的，具体包括，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eelse\u003c/code\u003e 条件判断（\u003cstrong\u003e而不是 BCC 中的那种条件编译 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#ifdef\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#else\u003c/code\u003e\u003c/strong\u003e）。\u003c/li\u003e\n      \u003cli\u003eBPF CO-RE 提供的其他一些额外机制。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"41-摆脱内核头文件依赖\"\u003e4.1 摆脱内核头文件依赖\u003c/h2\u003e\n\n\u003cp\u003e内核 BTF 信息除了用来做字段重定位之外，还可以用来\u003cmark\u003e生成一个大的头文件\u003c/mark\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmlinux.h\u003c/code\u003e，\n它\u003cstrong\u003e\u003cmark\u003e包含了所有的内部内核类型，从而避免了依赖系统层面的内核头文件\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpftool\u003c/code\u003e 生成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmlinux.h\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool btf dump file /sys/kernel/btf/vmlinux format c \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e vmlinux.h\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e有了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmlinux.h\u003c/code\u003e，就无需再像通常的 BPF 程序那样 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include \u0026lt;linux/sched.h\u0026gt;\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include \u0026lt;linux/fs.h\u0026gt;\u003c/code\u003e 等很多头文件，\n\u003cstrong\u003e\u003cmark\u003e也不用再安装 kernel-devel \u003c/mark\u003e\u003c/strong\u003e，只要 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include \u0026#34;vmlinux.h\u0026#34;\u003c/code\u003e 就够了。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmlinux.h\u003c/code\u003e 包含了\u003cstrong\u003e所有的内核类型\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e作为 UAPI 的一部分暴露的 API\u003c/li\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekernel-devel\u003c/code\u003e 暴露的内部类型\u003c/li\u003e\n  \u003cli\u003e其他一些\u003cstrong\u003e通过任何其他方式都无法获取的内部内核类型\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e不幸的是，\u003cmark\u003eBPF（以及 DWARF）并不记录 \u003ccode\u003e#define\u003c/code\u003e 宏，因此某些常用\n的宏可能在 vmlinux.h 中是缺失的\u003c/mark\u003e。但这些没有记录的宏中\n，最常见的一些已经在 \u003ca href=\"https://github.com/libbpf/libbpf/blob/master/src/bpf_helpers.h\"\u003ebpf_helpers.h\u003c/a\u003e\n（libbpf 提供的内核侧“库”）提供了。\u003c/p\u003e\n\n\u003ch2 id=\"42-读取内核结构体字段\"\u003e4.2 读取内核结构体字段\u003c/h2\u003e\n\n\u003cp\u003e最常见和最典型的场景就是从某些内核结构体中读取一个字段。\u003c/p\u003e\n\n\u003ch3 id=\"421-例子读取-task_struct-pid-字段\"\u003e4.2.1 例子：读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct-\u0026gt;pid\u003c/code\u003e 字段\u003c/h3\u003e\n\n\u003cp\u003e假设我们想\u003cstrong\u003e读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct\u003c/code\u003e 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid\u003c/code\u003e 字段\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"方式一bcc可移植\"\u003e方式一：BCC（可移植）\u003c/h4\u003e\n\n\u003cp\u003e用 BCC 实现，代码很简单：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBCC 有强大的\u003cmark\u003e代码重写（rewrite）\u003c/mark\u003e能力，能自动将以上代码\u003cstrong\u003e\u003cmark\u003e转换成一次 bpf_probe_read() 调用\u003c/mark\u003e\u003c/strong\u003e\n（但\u003cstrong\u003e有时重写之后的代码并不能正确\u003c/strong\u003e，具体取决于表达式的复杂程度）。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibbpf\u003c/code\u003e 没有 BCC 的代码重写魔法（code-rewriting magic），但提供了几种其他方式来\n实现同样的目的。\u003c/p\u003e\n\n\u003ch4 id=\"方式二libbpf--bpf_prog_type_tracing不可移植\"\u003e方式二：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibbpf\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e（不可移植）\u003c/h4\u003e\n\n\u003cp\u003e如果使用的是最近新加的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBTF_PROG_TYPE_TRACING\u003c/code\u003e 类型 BPF 程序，那校验器已经足够智\n能了，能\u003cmark\u003e原生地理解和记录 BTF 类型、跟踪指针，直接（安全地）读取内核内存\n\u003c/mark\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从而\u003cstrong\u003e避免了调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e\u003c/strong\u003e，格式和语法更为自然，而且\u003cstrong\u003e\u003cmark\u003e无需编译器重写\u003c/mark\u003e\u003c/strong\u003e（rewrite）。\n但此时，这段代码还不是可移植的。\u003c/p\u003e\n\n\u003ch4 id=\"方式三bpf_prog_type_tracing--co-re可移植\"\u003e方式三：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e + CO-RE（可移植）\u003c/h4\u003e\n\n\u003cp\u003e要将以上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e 代码其变成可移植的，只需将待访问字段 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask-\u0026gt;pid\u003c/code\u003e\n放到编译器内置的一个名为\n\u003cmark\u003e\u003ccode\u003e__builtin_preserve_access_index()\u003c/code\u003e\u003c/mark\u003e 的宏中：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e__builtin_preserve_access_index\u003c/span\u003e\u003cspan class=\"p\"\u003e(({\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这就是全部工作了：这样的程序\u003cmark\u003e在不同内核版本之间是可移植的\u003c/mark\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"方式四libbpf--co-re-bpf_core_read可移植\"\u003e方式四：libbpf + CO-RE \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_read()\u003c/code\u003e（可移植）\u003c/h4\u003e\n\n\u003cp\u003e如果使用的内核版本还没支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_TRACING\u003c/code\u003e，就必须显式地使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e\n来读取字段。\u003c/p\u003e\n\n\u003cp\u003eNon-CO-RE libbpf 方式：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ebpf_probe_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e有了 CO-RE+libbpf，我们有\u003cmark\u003e两种方式实现这个目的\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e第一种，直接将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e 替换成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_read()\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ebpf_core_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_read()\u003c/code\u003e 是一个很简单的宏，直接展开成以下形式：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003ebpf_probe_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003e__builtin_preserve_access_index\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，第三个参数（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026amp;task-\u0026gt;pid\u003c/code\u003e）放到了前面已经介绍过的编译器 built-int 中，\n这样 clang 就能记录该字段的重定位信息，实现可移植。\u003c/p\u003e\n\n\u003cp\u003e第二种方式是使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CORE_READ()\u003c/code\u003e 宏，我们通过下面的例子来看。\u003c/p\u003e\n\n\u003ch3 id=\"422-例子读取-task-mm-exe_file-f_inode-i_ino-字段\"\u003e4.2.2 例子：读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask-\u0026gt;mm-\u0026gt;exe_file-\u0026gt;f_inode-\u0026gt;i_ino\u003c/code\u003e 字段\u003c/h3\u003e\n\n\u003cp\u003e这个字段表示的是当前进程的可执行文件的 inode。\n来看一下访问嵌套层次如此深的结构体字段时，面临哪些问题。\u003c/p\u003e\n\n\u003ch4 id=\"方式一bcc可移植-1\"\u003e方式一：BCC（可移植）\u003c/h4\u003e\n\n\u003cp\u003e用 BCC 实现的话可能是下面这样：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003einode\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emm\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eexe_file\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ef_inode\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ei_ino\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBCC 会对这个表达式进行重写（rewrite），\u003cmark\u003e转换成 4 次 bpf_probe_read()/bpf_core_read() 调用\u003c/mark\u003e，\n并且每个中间指针都需要一个\u003cmark\u003e额外的临时变量\u003c/mark\u003e来存储。\u003c/p\u003e\n\n\u003ch4 id=\"方式二bpf-co-re可移植\"\u003e方式二：BPF CO-RE（可移植）\u003c/h4\u003e\n\n\u003cp\u003e下面是 BPF CO-RE 的方式，仍然很简洁，但无需 BCC 的代码重写（code-rewriting magic）：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003einode\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emm\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eexe_file\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ef_inode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ei_ino\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e另外一个变种是：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003einode\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eBPF_CORE_READ_INTO\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003einode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emm\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eexe_file\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ef_inode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ei_ino\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"423-其他与字段读取相关的-co-re-宏\"\u003e4.2.3 其他与字段读取相关的 CO-RE 宏\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_read_str()\u003c/code\u003e：可以直接替换 Non-CO-RE 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read_str()\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CORE_READ_STR_INTO()\u003c/code\u003e：与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CORE_READ_INTO()\u003c/code\u003e 类似，但会对最后一个字段执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read_str()\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_field_exists()\u003c/code\u003e：判断字段是否存在，\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e      \u003cspan class=\"n\"\u003epid_t\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_core_field_exists\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_core_field_size()\u003c/code\u003e：判断字段大小，同一字段在不同版本的内核中大小可能会发生变化，\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e      \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003ecomm_sz\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_core_field_size\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecomm\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* will set comm_sz to 16 */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CORE_READ_BITFIELD()\u003c/code\u003e：通过\u003cstrong\u003e直接内存读取\u003c/strong\u003e（direct memory read）方式，读取比特位字段\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CORE_READ_BITFIELD_PROBED()\u003c/code\u003e：底层会调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etcp_sock\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e...;\u003c/span\u003e\n    \n  \u003cspan class=\"cm\"\u003e/* with direct reads */\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003eis_cwnd_limited\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ_BITFIELD\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eis_cwnd_limited\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \n  \u003cspan class=\"cm\"\u003e/* with bpf_probe_read()-based reads */\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eis_cwnd_limited\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eBPF_CORE_READ_BITFIELD_PROBED\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eis_cwnd_limited\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eis_cwnd_limited\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"43-处理内核版本和配置差异\"\u003e4.3 处理内核版本和配置差异\u003c/h2\u003e\n\n\u003cp\u003e某些情况下，BPF 程序必须处理不同内核版本之间\u003cstrong\u003e常用内核结构体的非细微差异\u003c/strong\u003e。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e字段\u003cmark\u003e被重命名了\u003c/mark\u003e：对依赖这个字段的调用方来说，这其实变成了一个新字段（但语义没变）。\u003c/li\u003e\n  \u003cli\u003e字段名字没变，但\u003cmark\u003e表示的意思变了\u003c/mark\u003e：例如，从 4.6 之后的某个内核版本开始，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask_struct\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eutime\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estime\u003c/code\u003e 字段，原来单位是 jiffies，现在变成了 nanoseconds，因此\n调用方必须自己转换单位。\u003c/li\u003e\n  \u003cli\u003e需要从内核提取的某些数据是\u003cstrong\u003e与内核配置有直接关系\u003c/strong\u003e，某些内核在编译时并\u003cmark\u003e没有将相关代码编译进来\u003c/mark\u003e。\u003c/li\u003e\n  \u003cli\u003e其他一些无法用单个、通用的类型定义来适用于所有内核版本的场景。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e对于这些场景，BPF CO-RE 提供了两种互补的解决方式；\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003elibbpf 提供的 \u003cmark\u003eextern Kconfig 变量\u003c/mark\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003estruct flavors\u003c/mark\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"431-libbpf-提供的-externs-kconfig-全局变量\"\u003e4.3.1 libbpf 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexterns\u003c/code\u003e Kconfig 全局变量\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e系统中已经有一些“知名”变量，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLINUX_KERNEL_VERSION\u003c/code\u003e，表示当前内核的版本。\nBPF 程序能\u003cmark\u003e用 extern 关键字声明这些变量\u003c/mark\u003e。\u003c/li\u003e\n  \u003cli\u003e另外，BPF 还能用 extern 的方式声明 \u003cmark\u003eKconfig 的某些 key 的名字\u003c/mark\u003e（例如\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_HZ\u003c/code\u003e，表示内核的 HZ 数）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e接下来的事情交给 libbpf，它会将这些变量\u003cmark\u003e分别匹配到系统中相应的值\u003c/mark\u003e（都是常量），\n并保证这些 extern 变量\u003cmark\u003e与全局变量的效果是一样的\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e此外，由于这些 extern “变量”都是常量，因此 \u003cstrong\u003eBPF 校验器\u003c/strong\u003e能用它们来做一些\n\u003cmark\u003e高级控制流分析和无效代码消除\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e下面是个例子，如何用 BPF CO-RE 来提取线程的 CPU user time：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"k\"\u003eextern\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003eLINUX_KERNEL_VERSION\u003c/span\u003e \u003cspan class=\"n\"\u003e__kconfig\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eextern\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003eCONFIG_HZ\u003c/span\u003e \u003cspan class=\"n\"\u003e__kconfig\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eutime_ns\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLINUX_KERNEL_VERSION\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eKERNEL_VERSION\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eutime_ns\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eutime\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* convert jiffies to nanoseconds */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eutime_ns\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eutime\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1000000000UL\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003eCONFIG_HZ\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"432-struct-flavors\"\u003e4.3.2 struct flavors\u003c/h3\u003e\n\n\u003cp\u003e有些场景中，\u003cstrong\u003e不同版本的内核中有不兼容的类型\u003c/strong\u003e，无法用单个通用结构体来为所有内核\n编译同一个 BPF 程序。struct flavor 在这种情况下可以派上用场。\u003c/p\u003e\n\n\u003cp\u003e下面是一个例子，提取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efs\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efsbase\u003c/code\u003e（前面提到过，字段名字在内核版本升级时改了）来\n做一些 thread-local 的数据处理：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* up-to-date thread_struct definition matching newer kernels */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ethread_struct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003efsbase\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* legacy thread_struct definition for \u0026lt;= 4.6 kernels */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ethread_struct___v46\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e   \u003cspan class=\"cm\"\u003e/* ___v46 is a \u0026#34;flavor\u0026#34; part */\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003efs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eextern\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eLINUX_KERNEL_VERSION\u003c/span\u003e \u003cspan class=\"n\"\u003e__kconfig\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ethread_struct\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ethr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e...;\u003c/span\u003e\n\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003efsbase\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eLINUX_KERNEL_VERSION\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eKERNEL_VERSION\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efsbase\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ethread_struct___v46\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ethr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efs\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efsbase\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_CORE_READ\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ethr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efsbase\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在这个例子中，对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;=4.6\u003c/code\u003e 的内核，我们将原来的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ethread_struct\u003c/code\u003e 定义为了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct thread_struct___v46\u003c/code\u003e。\n\u003cmark\u003e双下划线及其之后的部分\u003c/mark\u003e，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e___v46\u003c/code\u003e，\u003cstrong\u003e\u003cmark\u003e称为这个 struct 的 “flavor”\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003eflavor 部分会被 libbpf 忽略\u003c/mark\u003e，这意味着\u003cstrong\u003e在目标机器上执行字段重定位时，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct thread_struct__v46\u003c/code\u003e 匹配的仍然是真正的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct thread_struct\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种方式使得我们能在单个 C 程序内，为同一个内核类型定义不同的（而且是不兼容的）\n类型，然后在运行时（runtime）取出最合适的一个，这就是用\n\u003cmark\u003etype cast to a struct flavor\u003c/mark\u003e 来提取字段的方式。\u003c/p\u003e\n\n\u003cp\u003e没有 struct flavor 的话，就无法真正实现像上面那样“编译一次”，然后就能在不同内核\n上都能运行的 BPF 程序 —— 而只能用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#ifdef\u003c/code\u003e 来控制源代码，编译成两个独立的 BPF\n程序变种，在运行时（runtime）由控制应用根据所在机器的内核版本选择其中某个变种。\n所有这些都添加了不必要的复杂性和痛苦。\n相比之下，\u003cstrong\u003e以上 BPF CO-RE 方式虽然不是透明的\u003c/strong\u003e（上面的代码中也包含了内核\n版本相关的逻辑），但允许用熟悉的 C 代码结构解决即便是这样的高级场景的问题。\u003c/p\u003e\n\n\u003ch2 id=\"44-根据用户提供的配置修改程序行为\"\u003e4.4 根据用户提供的配置修改程序行为\u003c/h2\u003e\n\n\u003cp\u003eBPF 程序\u003cstrong\u003e知道内核版本和配置信息\u003c/strong\u003e，有时还不足以判断如何 —— 以及以何种方式 —— 从该版本的内核获取数据。\n在这些场景中，\u003cmark\u003e用户空间控制应用\u003c/mark\u003e（control application）可能是唯一知道\n究竟需要做哪些事情，以及需要启用或禁用哪些特性的主体。\n这通常是\u003cstrong\u003e在用户空间和 BPF 程序之间\u003c/strong\u003e\u003cmark\u003e通过某种形式的配置数据来通信\u003c/mark\u003e的。\u003c/p\u003e\n\n\u003ch3 id=\"441-bpf-map-方式\"\u003e4.4.1 BPF map 方式\u003c/h3\u003e\n\n\u003cp\u003e要实现这种目的，一种不依赖 BPF CO-RE 的方式是：\u003cmark\u003e将 BPF map 作为一个存储配置\n数据的地方\u003c/mark\u003e。BPF 程序\u003cstrong\u003e从 map 中提取配置信息，然后基于这些信息改变它的控制流\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e但这种方式有几个主要的缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eBPF 程序每次执行 \u003cmark\u003emap 查询操作，都需要运行时开销\u003c/mark\u003e（runtime overhead）。\u003c/p\u003e\n\n    \u003cp\u003e多次查询累积起来，开销就会比较比较明显，尤其在一些高性能 BPF 应用的场景。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e配置内容\u003c/mark\u003e（config value），虽然在 \u003cstrong\u003eBPF 程序启动之后就是不可变和只读\u003c/strong\u003e\n  （immutable and read-only）的了，但 \u003cmark\u003eBPF 校验器在校验时扔把它们当作未知的黑盒值\u003c/mark\u003e。\u003c/p\u003e\n\n    \u003cp\u003e这意味着校验器\u003cmark\u003e无法消除无效代码，也无法执行其他高级代码分析\u003c/mark\u003e。进一步，\n 这意味着我们无法将代码逻辑放到 map 中，例如，能处理不同内核版本差异的 BPF 代\n 码，因为 map 中的内容对校验器都是黑盒，因此校验器对它们是不信任的 ——\n 即使用户配置信息是安全的。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"442-只读的全局数据方式\"\u003e4.4.2 只读的全局数据方式\u003c/h3\u003e\n\n\u003cp\u003e这种（确实复杂的）场景的\u003cmark\u003e解决方案：使用只读的全局数据\u003c/mark\u003e（read-only global data）。\n这些数据是在 \u003cstrong\u003eBPF 程序加载到内核之前，由控制应用设置\u003c/strong\u003e的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e从 \u003cmark\u003eBPF 程序的角度\u003c/mark\u003e看，这就是\u003cstrong\u003e正常的全局变量访问，没有任何 BPF map lookup 开销\u003c/strong\u003e ——\n全局变量\u003cmark\u003e实现为一次直接内存访问\u003c/mark\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e控制应用方面，在 BPF 程序加载到内核之前设置初始的配置值，此后配置值就是全局可\n访问且只读（well known and read-only）的了。\u003c/p\u003e\n\n    \u003cp\u003e这\u003cmark\u003e使得 BPF 校验器能将它们作为常量对待\u003c/mark\u003e，然后就能执行\u003cstrong\u003e高级控制流分析\u003c/strong\u003e\n  （advanced control flow analysis）来消除无效代码。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，针对上面那个例子，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e某些老内核的 BPF 校验器就能推断出，例如，代码中某个未知的 BPF helper 不可能会用到，接下来就可以将相关代码直接移除。\u003c/li\u003e\n  \u003cli\u003e而对于新内核来说，应用提供的配置（application-provided configuration）会所有不\n同，因此 BPF 程序就能用到功能更强大的 BPF helper，而且这个逻辑能成功通过 BPF 校验器的验证。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面的 BPF 代码例子展示了这种用法：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* global read-only variables, set up by control app */\u003c/span\u003e\n\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003euse_fancy_helper\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003efallback_value\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003euse_fancy_helper\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_fancy_helper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_default_helper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003efallback_value\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从用户空间方面，通过 BPF skeleton 可以很方便地做这种配置。BPF skeleton 的讨论不在\n本文讨论范围内，使用它来简化 BPF 应用的例子，可参考内核源码中的\n\u003ca href=\"https://github.com/torvalds/linux/tree/master/tools/bpf/runqslower\"\u003erunqslower tool\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\n\u003cp\u003eBPF CO-RE 的目标是：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e作为一种\u003cstrong\u003e\u003cmark\u003e简单的方式\u003c/mark\u003e\u003c/strong\u003e帮助 BPF 开发者解决\u003cstrong\u003e\u003cmark\u003e简单的移植性问题\u003c/mark\u003e\u003c/strong\u003e（例如读取结构体的字段），并且\u003c/li\u003e\n  \u003cli\u003e作为一种\u003cstrong\u003e\u003cmark\u003e仍然可行（不是最优，但可容忍）的方式\u003c/mark\u003e\u003c/strong\u003e\n解决\u003cstrong\u003e\u003cmark\u003e复杂的移植性问题\u003c/mark\u003e\u003c/strong\u003e（例如不兼容的数据结构改动、复杂的用户空间控制条件等）。\u003c/li\u003e\n  \u003cli\u003e使得开发者能遵循”一次编译、到处运行“（Compile Once – Run Everywhere）范式。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这是通过几个 BPF CO-RE 模块的组合实现的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmlinux.h\u003c/code\u003e \u003cmark\u003e消除了对内核头文件的依赖\u003c/mark\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e字段重定位信息\u003c/mark\u003e（字段偏移、字段是否存在、字段大小等等）使得\u003cmark\u003e从内核提取数据这个过程变得可移植\u003c/mark\u003e；\u003c/li\u003e\n  \u003cli\u003elibbpf 提供的 \u003cmark\u003eKconfig extern 变量\u003c/mark\u003e允许 BPF 程序适应不同的内核版本 —— 以及配置相关的差异；\u003c/li\u003e\n  \u003cli\u003e当其他方式都失效时，应用提供的\u003cmark\u003e只读配置和 struct flavor 最终救场\u003c/mark\u003e，能解决\n任何需要复杂处理的场景。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e要成功地编写、部署和维护可移植 BPF 程序，并不是必须用到所有这些 CO-RE 特性\u003c/strong\u003e。\n只需选择若干，用最简单的方式解决你的问题。\u003c/p\u003e\n\n\u003cp\u003eBPF CO-RE 使我们回到了熟悉、自然的工作流程：将 BPF C 源码编译成二进制，然后将\n二进制文件分发到目标机器进行部署和运行 —— \n无需再随着应用一起分发重量级的编译器库、无需消耗宝贵的运行时资源做运行时编\n译（runtime compilation），也无需等到运行之前才能捕捉一些细微的编译时错误（\ncompilation errors in runtime）了。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eBPF CO-RE presentation from LSF/MM2019 conference: \u003ca href=\"http://vger.kernel.org/bpfconf2019.html#session-2\"\u003esummary\u003c/a\u003e, \u003ca href=\"http://vger.kernel.org/bpfconf2019_talks/bpf-core.pdf\"\u003eslides\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eArnaldo Carvalho de Melo’s presentation \u003ca href=\"http://vger.kernel.org/~acme/bpf/devconf.cz-2020-BPF-The-Status-of-BTF-producers-consumers/#/29\"\u003e“BPF: The Status of BTF”\u003c/a\u003e dives deep into BPF CO-RE and dissects the runqslower tool quite nicely.\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://facebookmicrosites.github.io/bpf/blog/2018/11/14/btf-enhancement.html\"\u003eBTF deduplication algorithm\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/on-getting-tc-classifier-fully-programmable-zh/\"\u003e\u003cspan\u003e« [译] [论文] 迈向完全可编程 tc 分类器（cls_bpf）（NetdevConf，2016）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/customize-tcp-initial-rto-with-bpf/\"\u003e\u003cspan\u003eCustomize TCP initial RTO (retransmission timeout) with BPF »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-03-12T00:00:00Z",
  "Author": "Arthur Chiao"
}