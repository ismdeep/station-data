{
  "Source": "arthurchiao.art",
  "Title": "[译] Socket listen 多地址需求与 SK_LOOKUP BPF 的诞生（LPC, 2019）",
  "Link": "https://arthurchiao.art/blog/birth-of-sk-lookup-bpf-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Socket listen 多地址需求与 SK_LOOKUP BPF 的诞生（LPC, 2019）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-12-11 | Last Update 2022-12-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文组合翻译 Cloudflare 的几篇分享，介绍了他们面临的独特网络需求、解决方案的演进，\n以及终极解决方案 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSK_LOOKUP\u003c/code\u003e BPF 的诞生：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://linuxplumbersconf.org/event/4/contributions/487/\"\u003eProgramming socket lookup with BPF\u003c/a\u003e, LPC, 2019\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/its-crowded-in-here/\"\u003eIt’s crowded in here\u003c/a\u003e, Cloudflare blog, 2019\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/jsitnicki/ebpf-summit-2020\"\u003eSteering connections to sockets with BPF socket lookup hook\u003c/a\u003e，eBPF Summit，2020\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-引言\" id=\"markdown-toc-1-引言\"\u003e1 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-现状cloudflare-边缘架构\" id=\"markdown-toc-11-现状cloudflare-边缘架构\"\u003e1.1 现状：Cloudflare 边缘架构\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-需求如何让一个服务监听至少几百个-ip-地址\" id=\"markdown-toc-12-需求如何让一个服务监听至少几百个-ip-地址\"\u003e1.2 需求：如何让一个服务监听至少几百个 IP 地址\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-场景需求与解决方案演进\" id=\"markdown-toc-2-场景需求与解决方案演进\"\u003e2 场景需求与解决方案演进\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-简单场景一个-socket-监听一个-ip-地址\" id=\"markdown-toc-21-简单场景一个-socket-监听一个-ip-地址\"\u003e2.1 简单场景：一个 socket 监听一个 IP 地址\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-进阶场景一个-socket-监听多个-ip-地址\" id=\"markdown-toc-22-进阶场景一个-socket-监听多个-ip-地址\"\u003e2.2 进阶场景：一个 socket 监听多个 IP 地址\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-bindinaddr_any-或-bind0000\" id=\"markdown-toc-221-bindinaddr_any-或-bind0000\"\u003e2.2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind(INADDR_ANY)\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind(0.0.0.0)\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-listen-unbound-socket\" id=\"markdown-toc-222-listen-unbound-socket\"\u003e2.2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elisten()\u003c/code\u003e unbound socket\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#223-技术原理内核-socket-lookup-逻辑\" id=\"markdown-toc-223-技术原理内核-socket-lookup-逻辑\"\u003e2.2.3 技术原理：内核 socket lookup 逻辑\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#224-优缺点比较\" id=\"markdown-toc-224-优缺点比较\"\u003e2.2.4 优缺点比较\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-魔鬼场景同一台机器上不同-service-使用同一个-portip-不重叠\" id=\"markdown-toc-23-魔鬼场景同一台机器上不同-service-使用同一个-portip-不重叠\"\u003e2.3 魔鬼场景：同一台机器上不同 service 使用同一个 port（IP 不重叠）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-地狱场景一个-service-监听所有-65535-个端口\" id=\"markdown-toc-24-地狱场景一个-service-监听所有-65535-个端口\"\u003e2.4 地狱场景：一个 service 监听所有 65535 个端口\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#241-iptables--tproxy\" id=\"markdown-toc-241-iptables--tproxy\"\u003e2.4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiptables + TPROXY\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#242-tproxy-方案缺点\" id=\"markdown-toc-242-tproxy-方案缺点\"\u003e2.4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTPROXY\u003c/code\u003e 方案缺点\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#243-有没有银弹\" id=\"markdown-toc-243-有没有银弹\"\u003e2.4.3 有没有银弹？\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-sk_lookup-bpf对-socket-lookup-过程进行编程\" id=\"markdown-toc-3-sk_lookup-bpf对-socket-lookup-过程进行编程\"\u003e3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSK_LOOKUP\u003c/code\u003e BPF：对 socket lookup 过程进行编程\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-设计思想\" id=\"markdown-toc-31-设计思想\"\u003e3.1 设计思想\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-引入新的-bpf-程序类型-sk_lookup\" id=\"markdown-toc-32-引入新的-bpf-程序类型-sk_lookup\"\u003e3.2 引入新的 BPF 程序类型 SK_LOOKUP\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#321-程序执行位置\" id=\"markdown-toc-321-程序执行位置\"\u003e3.2.1 程序执行位置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#322-工作原理\" id=\"markdown-toc-322-工作原理\"\u003e3.2.2 工作原理\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-bpf-程序示例\" id=\"markdown-toc-33-bpf-程序示例\"\u003e3.3 BPF 程序示例\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-demo\" id=\"markdown-toc-34-demo\"\u003e3.4 Demo\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#341-效果单个-socket-同时监听-4-个端口\" id=\"markdown-toc-341-效果单个-socket-同时监听-4-个端口\"\u003e3.4.1 效果：单个 socket 同时监听 4 个端口\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#342-创建服务端-echo-server\" id=\"markdown-toc-342-创建服务端-echo-server\"\u003e3.4.2 创建服务端 echo server\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#343-客户端访问测试\" id=\"markdown-toc-343-客户端访问测试\"\u003e3.4.3 客户端访问测试\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#344-编译加载-bpf-程序\" id=\"markdown-toc-344-编译加载-bpf-程序\"\u003e3.4.4 编译、加载 BPF 程序\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-总结\" id=\"markdown-toc-4-总结\"\u003e4 总结\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-引言\"\u003e1 引言\u003c/h1\u003e\n\n\u003ch2 id=\"11-现状cloudflare-边缘架构\"\u003e1.1 现状：Cloudflare 边缘架构\u003c/h2\u003e\n\n\u003cp\u003eCloudflare 的边缘服务器里运行着大量程序，不仅包括很多\u003cstrong\u003e\u003cmark\u003e内部应用\u003c/mark\u003e\u003c/strong\u003e，\n还包括很多\u003cstrong\u003e\u003cmark\u003e公网服务\u003c/mark\u003e\u003c/strong\u003e（public facing services），例如：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://www.cloudflare.com/cdn/\" target=\"_blank\"\u003eHTTP CDN\u003c/a\u003e (tcp/80)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.cloudflare.com/ssl/\" target=\"_blank\"\u003eHTTPS CDN\u003c/a\u003e (tcp/443, \u003ca href=\"https://cloudflare-quic.com/\" target=\"_blank\"\u003eudp/443\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.cloudflare.com/dns/\" target=\"_blank\"\u003eauthoritative DNS\u003c/a\u003e (udp/53)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/dns-resolver-1-1-1-1/\"\u003erecursive DNS\u003c/a\u003e (udp/53, 853)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/secure-time/\"\u003eNTP with NTS\u003c/a\u003e (udp/1234)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/roughtime/\"\u003eRoughtime time service\u003c/a\u003e (udp/2002)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/distributed-web-gateway/\"\u003eIPFS Gateway\u003c/a\u003e (tcp/443)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/cloudflare-ethereum-gateway/\"\u003eEthereum Gateway\u003c/a\u003e (tcp/443)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/spectrum/\"\u003eSpectrum proxy\u003c/a\u003e (tcp/any, udp/any)1\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/announcing-warp-plus/\"\u003eWARP\u003c/a\u003e (udp)\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这些应用通过横跨 \u003cstrong\u003e\u003cmark\u003e100+ 网段\u003c/mark\u003e\u003c/strong\u003e的 \u003cstrong\u003e\u003cmark\u003e100 万个 Anycast\u003c/mark\u003e\u003c/strong\u003e\n\u003ca href=\"https://www.cloudflare.com/ips\"\u003e\u003cmark\u003e公网 IPv4 地址\u003c/mark\u003e\u003c/a\u003e\n提供服务。为了保持一致性，Cloudflare 的\u003cstrong\u003e\u003cmark\u003e每台服务器都运行所有服务\u003c/mark\u003e\u003c/strong\u003e，\n每台机器都能处理每个 Anycast 地址的请求，这样能\u003cstrong\u003e\u003cmark\u003e充分利用服务器硬件资源\u003c/mark\u003e\u003c/strong\u003e，\n在所有服务器之间做请求的负载均衡，如下图所示，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/edge_data_center.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e之前的分享中已经介绍了 \u003cstrong\u003e\u003cmark\u003eCloudflare 的边缘网络架构\u003c/mark\u003e\u003c/strong\u003e，感兴趣可移步：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/no-scrubs-architecture-unmetered-mitigation/\"\u003eNo Scrubs: The Architecture That Made Unmetered Mitigation Possible\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cloudflare-arch-and-bpf-zh/\"\u003e(译) Cloudflare 边缘网络架构：无处不在的 BPF（2019）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"12-需求如何让一个服务监听至少几百个-ip-地址\"\u003e1.2 需求：如何让一个服务监听至少几百个 IP 地址\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e如何能让一个服务监听在至少几百个 IP 地址上\u003c/mark\u003e\u003c/strong\u003e，而且能确保内核网络栈稳定运行呢？\u003c/p\u003e\n\n\u003cp\u003e这是 Cloudflare 工程师过去几年一直在思考的问题，其答案也在驱动着我们的网络不断演进。\n特别是，它让我们\u003cstrong\u003e\u003cmark\u003e更有创造性地去使用\u003c/mark\u003e\u003c/strong\u003e\n\u003ca href=\"https://en.wikipedia.org/wiki/Berkeley_sockets\" target=\"_blank\"\u003eBerkeley sockets API\u003c/a\u003e，\n这是一个给应用分配 IP 和 port 的 POSIX 标准。\u003c/p\u003e\n\n\u003cp\u003e下面我们来回顾一下这趟奇妙的旅程。\u003c/p\u003e\n\n\u003ch1 id=\"2-场景需求与解决方案演进\"\u003e2 场景需求与解决方案演进\u003c/h1\u003e\n\n\u003ch2 id=\"21-简单场景一个-socket-监听一个-ip-地址\"\u003e2.1 简单场景：一个 socket 监听一个 IP 地址\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/mapping_1_to_1.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 最简单场景：一个 socket 绑定一个 \u003ccode\u003eIP:Port\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e这是最简单的场景，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(ip,port)\u003c/code\u003e 与 service 一一对应。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eService 监听在某个已知的 \u003cmark\u003e\u003ccode\u003eIP:Port\u003c/code\u003e\u003c/mark\u003e 提供服务；\u003c/li\u003e\n  \u003cli\u003eService 如果要支持多种协议类型（TCP、UDP），则需要\u003cstrong\u003e\u003cmark\u003e为每种协议类型打开一个 socket\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e例如，我们的\u003ca href=\"https://www.cloudflare.com/dns/\"\u003e权威 DNS\u003c/a\u003e 服务会分别针对 TCP 和 UDP 创建一个 socket：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    (192.0.2.1, 53/tcp) -\u0026gt; (\u0026#34;auth-dns\u0026#34;, pid=1001, fd=3)\n    (192.0.2.1, 53/udp) -\u0026gt; (\u0026#34;auth-dns\u0026#34;, pid=1001, fd=4)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e但是，对于 Cloudflare 的规模来说，我们需要\u003cstrong\u003e\u003cmark\u003e在至少 4K 个 IP\u003c/mark\u003e\u003c/strong\u003e\n上分别创建 socket，才能满足业务需求，也就是说 DNS 这个服务需要监听一个至少 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/20\u003c/code\u003e 的网段。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/mapping_many_1_to_1.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 为了支撑业务规模，需要为 DNS 这样的服务在至少 4000 个 IP 地址上创建 socket\u003c/p\u003e\n\n\u003cp\u003e如果用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ess\u003c/code\u003e 之类的工具看，就会看到非常长的 socket 列表：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003ess \u003cspan class=\"nt\"\u003e-ulpn\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;sport = 53\u0026#39;\u003c/span\u003e\nState  Recv-Q Send-Q  Local Address:Port Peer Address:Port\n...\nUNCONN 0      0           192.0.2.40:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11076\u003cspan class=\"o\"\u003e))\u003c/span\u003e\nUNCONN 0      0           192.0.2.39:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11075\u003cspan class=\"o\"\u003e))\u003c/span\u003e\nUNCONN 0      0           192.0.2.38:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11074\u003cspan class=\"o\"\u003e))\u003c/span\u003e\nUNCONN 0      0           192.0.2.37:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11073\u003cspan class=\"o\"\u003e))\u003c/span\u003e\nUNCONN 0      0           192.0.2.36:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11072\u003cspan class=\"o\"\u003e))\u003c/span\u003e\nUNCONN 0      0           192.0.2.31:53        0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e    \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;auth-dns\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e77556,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e11071\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e显然，这种方式非常原始和粗暴；不过也有它的优点：当其中一个 IP 遭受 UDP 泛洪攻击时，\n其他 IP 不受影响。\u003c/p\u003e\n\n\u003ch2 id=\"22-进阶场景一个-socket-监听多个-ip-地址\"\u003e2.2 进阶场景：一个 socket 监听多个 IP 地址\u003c/h2\u003e\n\n\u003cp\u003e以上做法显然太过粗糙，一个服务就使用这么多 IP 地址。但更大的问题是：\n监听的 \u003cstrong\u003e\u003cmark\u003esocket 越多，hash table 中的 chain 就越长，socket lookup 过程就越慢\u003c/mark\u003e\u003c/strong\u003e。\n我们在 \u003ca href=\"https://blog.cloudflare.com/revenge-listening-sockets/\"\u003eThe revenge of the listening sockets\u003c/a\u003e\n中经历了这一问题。那么，有没有更好的办法解决这个问题呢？有。\u003c/p\u003e\n\n\u003ch3 id=\"221-bindinaddr_any-或-bind0000\"\u003e2.2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind(INADDR_ANY)\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind(0.0.0.0)\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003eSocket API 中有个叫 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eINADDR_ANY\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的东西，能让我们\n避免以上那种 one-ip-per-socket 方式，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/mapping_inaddr_any.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. INADDR_ANY socket：监听这台机器上所有 IP 地址的某个端口\u003c/p\u003e\n\n\u003cp\u003e当指定一个 socket 监听在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eINADDR_ANY\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0.0.0.0\u003c/code\u003e 时，\n这个 socket 会监听这台\u003cstrong\u003e\u003cmark\u003e机器上的所有 IP 地址\u003c/mark\u003e\u003c/strong\u003e，\n此时只需要提供一个 listen port 就行了：\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esocket\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAF_INET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSOCK_STREAM\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;0.0.0.0\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e12345\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elisten\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e16\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e除此之外，还有没有其他 bind 所有 local 地址的方式？有，但不是使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind()\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"222-listen-unbound-socket\"\u003e2.2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elisten()\u003c/code\u003e unbound socket\u003c/h3\u003e\n\n\u003cp\u003e直接在一个 \u003cstrong\u003e\u003cmark\u003eunbound socket 上调用 \u003ccode\u003elisten()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\n其效果等同于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eINADDR_ANY\u003c/code\u003e，但监听在哪个 \u003cstrong\u003e\u003cmark\u003eport 是由内核自动分配的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e看个例子：首先用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc -l\u003c/code\u003e 创建一个 listening socket，用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 跟踪其中的几个系统调用，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003estrace \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e socket,bind,listen nc \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e\nsocket\u003cspan class=\"o\"\u003e(\u003c/span\u003eAF_INET, SOCK_STREAM, IPPROTO_TCP\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3\nlisten\u003cspan class=\"o\"\u003e(\u003c/span\u003e3, 1\u003cspan class=\"o\"\u003e)\u003c/span\u003e                            \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n^Z\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e1]+  Stopped                 strace \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e socket,bind,listen nc \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后查看我们创建的 socket：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ess \u003cspan class=\"nt\"\u003e-4tlnp\u003c/span\u003e\nState      Recv-Q Send-Q Local Address:Port               Peer Address:Port\nLISTEN     0      1            \u003cspan class=\"k\"\u003e*\u003c/span\u003e:42669\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到 listen 地址是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e*:42669\u003c/code\u003e， 其中\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e*\u003c/code\u003e 表示监听这个主机上所有 IP 地址，与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eINADDR_ANY\u003c/code\u003e 等价；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e42669\u003c/code\u003e 就是内核为我们分配的 port。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"223-技术原理内核-socket-lookup-逻辑\"\u003e2.2.3 技术原理：内核 socket lookup 逻辑\u003c/h3\u003e\n\n\u003cp\u003e这里介绍下内核中的 socket lookup 逻辑，也就是当 TCP 层收到一个包时，\n\u003cstrong\u003e\u003cmark\u003e如何判断这个包属于哪个 socket\u003c/mark\u003e\u003c/strong\u003e。逻辑其实非常简单：\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/net/inet_hashtables.h#L342-L361\"\u003e两阶段\u003c/a\u003e，\n先精确匹配，再模糊匹配：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/tcp_socket_lookup.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 内核 socket lookup 逻辑：判断一个包应该送到哪个 socket\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e首先是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(src_ip,src_port,dst_ip,dst_port)\u003c/code\u003e 4-tuple 精确匹配，看能不能找到 \u003cstrong\u003e\u003cmark\u003econnected 状态的 socket\u003c/mark\u003e\u003c/strong\u003e；如果找不到，\u003c/li\u003e\n  \u003cli\u003e再尝试 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(dst_ip,dst_port)\u003c/code\u003e 2-tuple，寻找有没有 \u003cstrong\u003e\u003cmark\u003elistening 状态的 socket\u003c/mark\u003e\u003c/strong\u003e；如果还是没找到，\u003c/li\u003e\n  \u003cli\u003e再尝试 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(INADDR_ANY)\u003c/code\u003e 1-tuple，寻找有没有 \u003cstrong\u003e\u003cmark\u003elistening 状态的 socket\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"224-优缺点比较\"\u003e2.2.4 优缺点比较\u003c/h3\u003e\n\n\u003cp\u003e如果我们给每个服务器都分配一个 IP 段（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/20\u003c/code\u003e），那通过以上两种方式，\n我们都能实现\u003cstrong\u003e\u003cmark\u003e一次 socket 调用就监听在整个 IP 段\u003c/mark\u003e\u003c/strong\u003e。\n而且 INADDR_ANY 的好处是无需关心服务器的 IP 地址，加减 IP 地址不需要重新配置服务。\u003c/p\u003e\n\n\u003cp\u003e但另一方面，缺点也比较多：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e不是每个服务都需要 4000 个地址\u003c/mark\u003e\u003c/strong\u003e，因此 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0.0.0.0\u003c/code\u003e 是浪费的，\n可能还会不小心将一些重要内部服务暴露到公网；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e安全方面：\u003cstrong\u003e\u003cmark\u003e任何一个 IP 被攻击，都有可能导致这个 socket 的 receive queue 被打爆\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e这是因为现在一台机器上只有一个 socket，监听在 4000 个地址上，攻击可能会命中任何一个 IP 地址。\n 这种情况下\n  \u003ca href=\"https://blog.cloudflare.com/syn-packet-handling-in-the-wild/\"\u003eTCP 还有办法应对\u003c/a\u003e，\n  但 UDP 就麻烦很多，需要特别关注，否则非法流量泛洪很容易将 socket 打挂。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eINADDR_ANY 使用的 port 是全局独占的\u003c/mark\u003e\u003c/strong\u003e，一个 socket 使用了之后，\n这台机器上的其他 socket 就无法使用了。\u003c/p\u003e\n\n    \u003cp\u003e常见的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind()\u003c/code\u003e 时报 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEADDRINUSE\u003c/code\u003e 错误：\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003esa_family\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eAF_INET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esin_port\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ehtons\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e12345\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003esin_addr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003einet_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;0.0.0.0\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)},\u003c/span\u003e \u003cspan class=\"mi\"\u003e16\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n \u003cspan class=\"n\"\u003ebind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003esa_family\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eAF_INET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esin_port\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ehtons\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e12345\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003esin_addr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003einet_addr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;127.0.0.1\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)},\u003c/span\u003e \u003cspan class=\"mi\"\u003e16\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"n\"\u003eEADDRINUSE\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eAddress\u003c/span\u003e \u003cspan class=\"n\"\u003ealready\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003euse\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e除非是 UDP-only 应用，否则设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_REUSEADDR\u003c/code\u003e 也没用。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"23-魔鬼场景同一台机器上不同-service-使用同一个-portip-不重叠\"\u003e2.3 魔鬼场景：同一台机器上不同 service 使用同一个 port（IP 不重叠）\u003c/h2\u003e\n\n\u003cp\u003e这就是上面提到的 “不是每个服务都需要 4000 个地址” 场景：如果两个服务使用了不同的一组 IP，\n那它们使用相同的端口，也应该没有问题 —— 这正是 Cloudflare 的现实需求。\u003c/p\u003e\n\n\u003cp\u003e边缘服务器中确实存在多个服务使用相同的端口号，但监听在不同的 IP 地址段。\n\u003cstrong\u003e\u003cmark\u003e典型的例子\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://blog.cloudflare.com/dns-resolver-1-1-1-1/\"\u003e\u003cmark\u003e\u003ccode\u003e1.1.1.1\u003c/code\u003e\u003c/mark\u003e\u003c/a\u003e：recursive DNS resolver\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.cloudflare.com/dns\"\u003e\u003cmark\u003e权威 DNS 服务\u003c/mark\u003e\u003c/a\u003e：提供给所有客户使用\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这两个服务总是相伴运行的。但不幸的是，\n\u003ca href=\"http://man7.org/linux/man-pages/man2/bind.2.html\" target=\"_blank\"\u003eSockets API\u003c/a\u003e\n\u003cstrong\u003e\u003cmark\u003e不支持同一主机上的多个服务使用不同的 IP 段，而共享相同的端口号\u003c/mark\u003e\u003c/strong\u003e。\n好在 Linux 的开发历史表明，任何不支持的功能，都能通过一个新的 \n\u003ca href=\"https://github.com/torvalds/linux/blame/master/include/uapi/asm-generic/socket.h\"\u003esocket option\u003c/a\u003e 来支持（现在已经有 60 多个 options）。\u003c/p\u003e\n\n\u003cp\u003e因此，2016 年我们内部引入了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_BINDTOPREFIX\u003c/code\u003e，能 listen 一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(ipnetwork, port)\u003c/code\u003e，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/mapping_bindtoprefix.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e但这个功能\u003cstrong\u003e\u003cmark\u003e不够通用，内核社区不接受\u003c/mark\u003e\u003c/strong\u003e，我们只能内部维护 patch。\u003c/p\u003e\n\n\u003ch2 id=\"24-地狱场景一个-service-监听所有-65535-个端口\"\u003e2.4 地狱场景：一个 service 监听所有 65535 个端口\u003c/h2\u003e\n\n\u003cp\u003e前面讨论的都是一个 socket 监听在多个 IP，但同一个 port。虽然有点怪，但常人还能理解。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e—— 听说过一个 socket 同时监听在多个 port 吗？\u003c/li\u003e\n  \u003cli\u003e—— 多个是多少个？\u003c/li\u003e\n  \u003cli\u003e—— 整个目的端口空间（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e16bit dst port\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e），\u003cstrong\u003e\u003cmark\u003e65535 个\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e—— 好家伙！\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这也是 Cloudflare 的现实需求。这个产品是个反向代理（reverse proxy），叫 \n\u003ca href=\"https://www.cloudflare.com/products/cloudflare-spectrum\"\u003eSpectrum\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind()\u003c/code\u003e 系统调用显然并未考虑这种需求，在将一个给定的 socket 关联到一个 port 时，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e要么自己指定\u003cstrong\u003e一个\u003c/strong\u003e port；\u003c/li\u003e\n  \u003cli\u003e要么让系统网络栈给你分一个；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e我们不禁开个脑洞：能不能和 INADDR_ANY 类似，搞个 INPORT_ANY 之类的东西来选中所有 ports 呢？\u003c/p\u003e\n\n\u003ch3 id=\"241-iptables--tproxy\"\u003e2.4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiptables + TPROXY\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e利用一个叫 \u003ca href=\"https://www.kernel.org/doc/Documentation/networking/tproxy.txt\"\u003eTPROXY\u003c/a\u003e\n的 \u003cstrong\u003e\u003cmark\u003enetfilter/iptables extension\u003c/mark\u003e\u003c/strong\u003e是能做到的，在 forward path 上拦截流量，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eiptables \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e mangle \u003cspan class=\"nt\"\u003e-I\u003c/span\u003e PREROUTING \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n         \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e 192.0.2.0/24 \u003cspan class=\"nt\"\u003e-p\u003c/span\u003e tcp \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n         \u003cspan class=\"nt\"\u003e-j\u003c/span\u003e TPROXY \u003cspan class=\"nt\"\u003e--on-ip\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e127.0.0.1 \u003cspan class=\"nt\"\u003e--on-port\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e1234\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e更多信息见 \u003ca href=\"https://blog.cloudflare.com/how-we-built-spectrum\"\u003eHow we built spectrum\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/mapping_tproxy.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. TPROXY 拦截不同端口的流量，透明转发到本机最终 socket\u003c/p\u003e\n\n\u003ch3 id=\"242-tproxy-方案缺点\"\u003e2.4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTPROXY\u003c/code\u003e 方案缺点\u003c/h3\u003e\n\n\u003cp\u003eTPROXY 方案是有代价的：\u003c/p\u003e\n\n\u003cp\u003e首先，服务需要\u003cstrong\u003e\u003cmark\u003e特殊权限才能创建支持 TPROXY 功能的 socket\u003c/mark\u003e\u003c/strong\u003e，见 \u003ca href=\"http://man7.org/linux/man-pages/man7/ip.7.html\"\u003eIP_TRANSPARENT\u003c/a\u003e；\u003c/p\u003e\n\n\u003cp\u003e其次，需要深入理解 TPROXY 和流量路径之间的交互，例如\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eTPROXY 重定向的 flow，会不会被 connection tracking 记录？\u003c/li\u003e\n  \u003cli\u003eis listening socket contention during a SYN flood when using TPROXY a concern?\u003c/li\u003e\n  \u003cli\u003e网络组其他部分，例如 XDP programs，是否需要感知 TPROXY 重定向包这件事情？\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e虽然我们把这个方案最终推到了生产，但不得不说，这种方式太 hack 了，很难 hold 住。\u003c/p\u003e\n\n\u003ch3 id=\"243-有没有银弹\"\u003e2.4.3 有没有银弹？\u003c/h3\u003e\n\n\u003cp\u003e上面提到的 TPROXY 方案虽然 hack，但传达出一个\u003cstrong\u003e\u003cmark\u003e极其重要的思想\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e不管一个 socket 监听在哪个 IP、哪个 port，我们都能通过在更底层的网络栈上“做手脚”，将任意连接、任意 socket 的包引导给它\u003c/mark\u003e\u003c/strong\u003e。\nsocket 之上的应用对此是无感的。\u003c/p\u003e\n\n\u003cp\u003e先理解这句话，再往下走。\u003c/p\u003e\n\n\u003cp\u003e意识到这一点是相当重要的，这意味着只需要一些 TPROXY（或其他）规则，我们就可以\n\u003cstrong\u003e\u003cmark\u003e完全掌控和调度 (ip,port) 和 socket 之间的映射关系\u003c/mark\u003e\u003c/strong\u003e。这里我们所说的 socket 是在本机内的 socket。\u003c/p\u003e\n\n\u003cp\u003e而要\u003cstrong\u003e\u003cmark\u003e更好地调度这种映射关系，就轮到 BPF 出场了\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBPF is absolutely the way to go here, as it allows for whatever user\nspecified tweaks, like a list of destination subnetwork, or/and a list of\nsource network, or the date/time of the day, or port knocking without\nnetfilter, or … you name it.\u003c/p\u003e\n\n  \u003cp\u003e—— Suggestions from the kernel community\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"3-sk_lookup-bpf对-socket-lookup-过程进行编程\"\u003e3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSK_LOOKUP\u003c/code\u003e BPF：对 socket lookup 过程进行编程\u003c/h1\u003e\n\n\u003ch2 id=\"31-设计思想\"\u003e3.1 设计思想\u003c/h2\u003e\n\n\u003cp\u003e想法很简单：\u003cstrong\u003e\u003cmark\u003e编写一段 BPF 程序来决定如何将一个包映射到一个 socket\u003c/mark\u003e\u003c/strong\u003e ——\n不管这个 socket 监听在哪个地址和端口。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/idea_program_socket_lookup_with_bpf.png\" width=\"75%\" height=\"75%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 通过自定义 BPF 程序将数据包送到期望的 socket\u003c/p\u003e\n\n\u003cp\u003e如上图例子所示，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e所有目的地址是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e192.0.2.0/24 :53\u003c/code\u003e 的包，都转发给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk:2\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e所有目的地址是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e203.0.113.1 :*\u003c/code\u003e 的包，都转发给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk:4\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"32-引入新的-bpf-程序类型-sk_lookup\"\u003e3.2 引入新的 BPF 程序类型 SK_LOOKUP\u003c/h2\u003e\n\n\u003cp\u003e要实现这个效果，就需要一个\u003cstrong\u003e\u003cmark\u003e新的 BPF 程序类型\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"321-程序执行位置\"\u003e3.2.1 程序执行位置\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/bpf_inet_lookup_hook.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在收包路径上\u003cstrong\u003e\u003cmark\u003e给一个包寻找（lookup）合适的 socket\u003c/mark\u003e\u003c/strong\u003e，因此叫 SK_LOOKUP；\u003c/li\u003e\n  \u003cli\u003e位置是在\u003cstrong\u003e\u003cmark\u003e包到达 socket 的 rxq 之前\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"322-工作原理\"\u003e3.2.2 工作原理\u003c/h3\u003e\n\n\u003cp\u003e前面提到过 Linux 内核的\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/net/inet_hashtables.h#L342-L361\"\u003e两阶段 socket lookup 过程\u003c/a\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e先用 4-tuple 查找有没有 connected 状态 socket；如果没有，\u003c/li\u003e\n  \u003cli\u003e再用 2-tuple 查找有没有 listening 状态的 socket。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eSK_LOOKUP 就是\u003cstrong\u003e\u003cmark\u003e对上面第二个过程进行编程\u003c/mark\u003e\u003c/strong\u003e，也就是查找 listening socket 过程。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/birth-of-sk-lookup-bpf/tcp_socket_lookup_with_bpf.png\" width=\"75%\" height=\"75%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果 BPF 程序找到了 socket(s)，就选择一个合适的 socket，然后终止内核 lookup 过程（HIT）；\u003c/li\u003e\n  \u003cli\u003eBPF 也可以忽略某些包，不做处理，这些包继续走内核原来的逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e具体 BPF 信息：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBPF 程序类型：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_PROG_TYPE_SK_LOOKUP\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003eAttach 类型：BPF_SK_LOOKUP\u003c/li\u003e\n  \u003cli\u003e更多信息见 \u003ca href=\"/blog/bpf-advanced-notes-1-zh/\"\u003eBPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"33-bpf-程序示例\"\u003e3.3 BPF 程序示例\u003c/h2\u003e\n\n\u003cp\u003e见 \u003ca href=\"/blog/pidfd-and-socket-lookup-bpf-illustrated/\"\u003e\u003cmark\u003ePidfd and Socket-lookup (SK_LOOKUP) BPF Illustrated (2022)\u003c/mark\u003e\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"34-demo\"\u003e3.4 Demo\u003c/h2\u003e\n\n\u003ch3 id=\"341-效果单个-socket-同时监听-4-个端口\"\u003e3.4.1 效果：单个 socket 同时监听 4 个端口\u003c/h3\u003e\n\n\u003cp\u003e单个 TCP socket 同时监听在 7, 77, 777, 7777 四个端口。\u003c/p\u003e\n\n\u003ch3 id=\"342-创建服务端-echo-server\"\u003e3.4.2 创建服务端 echo server\u003c/h3\u003e\n\n\u003cp\u003e两个工具：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003encat\u003c/code\u003e：Concatenate and redirect sockets\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e： arbitrary TCP and UDP connections and listens\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eNAME\n       ncat - Concatenate and redirect sockets\n\nSYNOPSIS\n       ncat [OPTIONS...] [hostname] [port]\n\nOPTIONS SUMMARY\n             -4                         Use IPv4 only\n             -e, --exec \u0026lt;command\u0026gt;       Executes the given command\n             -l, --listen               Bind and listen for incoming connections\n             -k, --keep-open            Accept multiple connections in listen mode\n             ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意在有的发行版上，可能是用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 命令，二者的大部分参数都是一样的：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eNAME\n     nc — arbitrary TCP and UDP connections and listens\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果你的环境上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-e\u003c/code\u003e 选项，那可以直接用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 即可。\n不过实际测试发现在 Ubuntu 20.04 上， \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 不支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-e\u003c/code\u003e 参数。因此我们这里用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003encat\u003c/code\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eapt \u003cspan class=\"nb\"\u003einstall \u003c/span\u003encat\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在\u003cstrong\u003e\u003cmark\u003e创建 server\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003encat \u003cspan class=\"nt\"\u003e-4lke\u003c/span\u003e \u003cspan class=\"si\"\u003e$(\u003c/span\u003ewhich \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e\u003cspan class=\"si\"\u003e)\u003c/span\u003e 127.0.0.1 7777\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e查看 listening socket 信息：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ess \u003cspan class=\"nt\"\u003e-4tlpn\u003c/span\u003e sport \u003cspan class=\"o\"\u003e=\u003c/span\u003e 7777\nState    Recv-Q   Send-Q  Local Address:Port   Peer Address:Port      Process\nLISTEN   0        1       127.0.0.1:7777       0.0.0.0:\u003cspan class=\"k\"\u003e*\u003c/span\u003e              \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e:\u003cspan class=\"o\"\u003e((\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;nc\u0026#34;\u003c/span\u003e,pid\u003cspan class=\"o\"\u003e=\u003c/span\u003e91994,fd\u003cspan class=\"o\"\u003e=\u003c/span\u003e3\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"343-客户端访问测试\"\u003e3.4.3 客户端访问测试\u003c/h3\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003enc 127.0.0.1 7777\nhello\nhello\n^C\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"344-编译加载-bpf-程序\"\u003e3.4.4 编译、加载 BPF 程序\u003c/h3\u003e\n\n\u003cp\u003e见 \u003ca href=\"/blog/pidfd-and-socket-lookup-bpf-illustrated/\"\u003e\u003cmark\u003ePidfd and Socket-lookup (SK_LOOKUP) BPF Illustrated (2022)\u003c/mark\u003e\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e加载完 BPF 程序之后，测试：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;Steer\u0026#39;\u003c/span\u003e    | \u003cspan class=\"nb\"\u003etimeout \u003c/span\u003e1 nc \u003cspan class=\"nt\"\u003e-4\u003c/span\u003e 127.0.0.1 7\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;on\u0026#39;\u003c/span\u003e       | \u003cspan class=\"nb\"\u003etimeout \u003c/span\u003e1 nc \u003cspan class=\"nt\"\u003e-4\u003c/span\u003e 127.0.0.1 77\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;multiple\u0026#39;\u003c/span\u003e | \u003cspan class=\"nb\"\u003etimeout \u003c/span\u003e1 nc \u003cspan class=\"nt\"\u003e-4\u003c/span\u003e 127.0.0.1 777\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;ports\u0026#39;\u003c/span\u003e    | \u003cspan class=\"nb\"\u003etimeout \u003c/span\u003e1 nc \u003cspan class=\"nt\"\u003e-4\u003c/span\u003e 127.0.0.1 7777\nSteer\non\nmultiple\nports\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"4-总结\"\u003e4 总结\u003c/h1\u003e\n\n\u003cp\u003e本文整理了 Cloudflare 三篇文章，介绍了他们面临的独特需求、解决方案的演进，以及\n终极解决方案 SK_LOOKUP BPF 的诞生。对资深网络工程师和网络架构师有较大参考价值。\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cilium-tomorrow-networking-data-plane-zh/\"\u003e\u003cspan\u003e« [译] Cilium 未来数据平面：支撑 100Gbit/s k8s 集群（KubeCon, 2022）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/pidfd-and-socket-lookup-bpf-illustrated/\"\u003e\u003cspan\u003ePidfd and Socket-lookup BPF (SK_LOOKUP) Illustrated (2022) »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-12-11T00:00:00Z",
  "Author": "Arthur Chiao"
}