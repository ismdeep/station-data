{
  "Source": "arthurchiao.art",
  "Title": "[译] BPF ring buffer：使用场景、核心设计及程序示例（2020）",
  "Link": "https://arthurchiao.art/blog/bpf-ringbuf-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] BPF ring buffer：使用场景、核心设计及程序示例（2020）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-04-25 | Last Update 2022-04-25\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 BPF 核心开发者 Andrii Nakryiko 2020 的一篇文章：\u003ca href=\"https://nakryiko.com/posts/bpf-ringbuf/\"\u003eBPF ring buffer\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e文章介绍了 BPF ring buffer 解决的问题及背后的设计，并给出了一些代码示例和内核\npatch 链接，深度和广度兼备，是学习 ring buffer 的极佳参考。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-ringbuf-相比-perfbuf-的改进\" id=\"markdown-toc-1-ringbuf-相比-perfbuf-的改进\"\u003e1 ringbuf 相比 perfbuf 的改进\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-降低内存开销memory-overhead\" id=\"markdown-toc-11-降低内存开销memory-overhead\"\u003e1.1 降低内存开销（memory overhead）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-保证事件顺序event-ordering\" id=\"markdown-toc-12-保证事件顺序event-ordering\"\u003e1.2 保证事件顺序（event ordering）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-减少数据复制wasted-data-copy\" id=\"markdown-toc-13-减少数据复制wasted-data-copy\"\u003e1.3 减少数据复制（wasted data copy）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-ringbuf-使用场景和性能\" id=\"markdown-toc-2-ringbuf-使用场景和性能\"\u003e2 ringbuf 使用场景和性能\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-常规场景\" id=\"markdown-toc-21-常规场景\"\u003e2.1 常规场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-高吞吐场景\" id=\"markdown-toc-22-高吞吐场景\"\u003e2.2 高吞吐场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-不可掩码中断non-maskable-interrupt场景\" id=\"markdown-toc-23-不可掩码中断non-maskable-interrupt场景\"\u003e2.3 不可掩码中断（non-maskable interrupt）场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-小结\" id=\"markdown-toc-24-小结\"\u003e2.4 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-示例程序show-me-the-code\" id=\"markdown-toc-3-示例程序show-me-the-code\"\u003e3 示例程序（show me the code）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-perfbuf-示例\" id=\"markdown-toc-31-perfbuf-示例\"\u003e3.1 perfbuf 示例\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#内核-bpf-程序\" id=\"markdown-toc-内核-bpf-程序\"\u003e内核 BPF 程序\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#用户空间程序\" id=\"markdown-toc-用户空间程序\"\u003e用户空间程序\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-ringbuf-示例\" id=\"markdown-toc-32-ringbuf-示例\"\u003e3.2 ringbuf 示例\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#内核-bpf-程序-1\" id=\"markdown-toc-内核-bpf-程序-1\"\u003e内核 BPF 程序\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#用户空间程序-1\" id=\"markdown-toc-用户空间程序-1\"\u003e用户空间程序\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-ringbuf-reservecommit-api-示例\" id=\"markdown-toc-33-ringbuf-reservecommit-api-示例\"\u003e3.3 ringbuf reserve/commit API 示例\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#原理\" id=\"markdown-toc-原理\"\u003e原理\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#限制\" id=\"markdown-toc-限制\"\u003e限制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#内核-bpf-程序-2\" id=\"markdown-toc-内核-bpf-程序-2\"\u003e内核 BPF 程序\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#用户空间程序-2\" id=\"markdown-toc-用户空间程序-2\"\u003e用户空间程序\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-ringbuf-事件通知控制\" id=\"markdown-toc-4-ringbuf-事件通知控制\"\u003e4 ringbuf 事件通知控制\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-事件通知开销\" id=\"markdown-toc-41-事件通知开销\"\u003e4.1 事件通知开销\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-perbuf-解决方式\" id=\"markdown-toc-42-perbuf-解决方式\"\u003e4.2 perbuf 解决方式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-ringbuf-解决方式\" id=\"markdown-toc-43-ringbuf-解决方式\"\u003e4.3 ringbuf 解决方式\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-总结\" id=\"markdown-toc-5-总结\"\u003e5 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#其他相关资料译注\" id=\"markdown-toc-其他相关资料译注\"\u003e其他相关资料（译注）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e很多场景下，BPF 程序都需要\u003cstrong\u003e\u003cmark\u003e将数据发送到用户空间\u003c/mark\u003e\u003c/strong\u003e（userspace），\nBPF perf buffer（perfbuf）是目前这一过程的事实标准，但它存在一些问题，例如\n\u003cstrong\u003e\u003cmark\u003e浪费内存（因为其 per-CPU 设计）、事件顺序无法保证\u003c/mark\u003e\u003c/strong\u003e等。\u003c/p\u003e\n\n\u003cp\u003e作为改进，\u003cstrong\u003e\u003cmark\u003e内核 5.8\u003c/mark\u003e\u003c/strong\u003e 引入另一个新的 BPF 数据结构：BPF ring buffer（环形缓冲区，ringbuf），\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e相比 perf buffer，它\u003cstrong\u003e\u003cmark\u003e内存效率更高、保证事件顺序\u003c/mark\u003e\u003c/strong\u003e，性能也不输前者；\u003c/li\u003e\n  \u003cli\u003e在使用上，既提供了与 perf buffer 类似的 API ，以方便用户迁移；又提供了一套新的\n\u003cstrong\u003e\u003cmark\u003ereserve/commit API\u003c/mark\u003e\u003c/strong\u003e（先预留再提交），以实现\u003cstrong\u003e\u003cmark\u003e更高性能\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e此外，实验与真实环境的压测结果都表明，从 BPF 程序发送数据给用户空间时，\n\u003cstrong\u003e\u003cmark\u003e应该首选 BPF ring buffer\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"1-ringbuf-相比-perfbuf-的改进\"\u003e1 ringbuf 相比 perfbuf 的改进\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eperfbuf 是 per-CPU 环形缓冲区\u003c/mark\u003e\u003c/strong\u003e（circular buffers），能实现高效的\n\u003cstrong\u003e\u003cmark\u003e“内核-用户空间”数据交互\u003c/mark\u003e\u003c/strong\u003e，在实际中也非常有用，但 per-CPU 的设计\n导致两个严重缺陷：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e内存使用效率低下\u003c/mark\u003e\u003c/strong\u003e（inefficient use of memory）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e事件顺序无法保证\u003c/mark\u003e\u003c/strong\u003e（event re-ordering）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此内核 5.8 引入了 ringbuf 来解决这个问题。\n\u003cstrong\u003e\u003cmark\u003eringbuf 是一个“多生产者、单消费者”\u003c/mark\u003e\u003c/strong\u003e（multi-producer, single-consumer，MPSC）\n队列，可\u003cstrong\u003e\u003cmark\u003e安全地在多个 CPU 之间共享和操作\u003c/mark\u003e\u003c/strong\u003e。perfbuf 支持的一些功能它都支持，包括，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e可变长数据（variable-length data records）；\u003c/li\u003e\n  \u003cli\u003e通过 memory-mapped region 来高效地从 userspace 读数据，避免内存复制或系统调用；\u003c/li\u003e\n  \u003cli\u003e支持 epoll notifications 和 busy-loop 两种获取数据方式。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e此外，它还解决了 perfbuf 的下列问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e内存开销（memory overhead）；\u003c/li\u003e\n  \u003cli\u003e数据乱序；\u003c/li\u003e\n  \u003cli\u003e无效的处理逻辑和不必要的数据复制（extra data copying）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e下面具体来看。\u003c/p\u003e\n\n\u003ch2 id=\"11-降低内存开销memory-overhead\"\u003e1.1 降低内存开销（memory overhead）\u003c/h2\u003e\n\n\u003cp\u003eperfbuf 为每个 CPU 分配一个独立的缓冲区，这意味着开发者通常需要\n\u003cstrong\u003e\u003cmark\u003e在内存效率和数据丢失之间做出折中\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e越大的 per-CPU buffer 越能避免丢数据，但也意味着大部分时间里，大部分内存都是浪费的；\u003c/li\u003e\n  \u003cli\u003e尽量小的 per-CPU buffer 能提高内存使用效率，但在数据量陡增（毛刺）时将导致丢数据。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e对于那些大部分时间都比较空闲、\u003cstrong\u003e\u003cmark\u003e周期性来一大波数据的场景\u003c/mark\u003e\u003c/strong\u003e，\n这个问题尤其突出，很难在两者之间取得一个很好的平衡。\u003c/p\u003e\n\n\u003cp\u003eringbuf 的解决方式是\u003cstrong\u003e\u003cmark\u003e分配一个所有 CPU 共享的大缓冲区\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e“大缓冲区”意味着能\u003cstrong\u003e\u003cmark\u003e更好地容忍数据量毛刺\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e“共享”则意味着\u003cstrong\u003e\u003cmark\u003e内存使用效率更高\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外，ringbuf \u003cstrong\u003e\u003cmark\u003e内存效率的扩展性\u003c/mark\u003e\u003c/strong\u003e也更好，比如 CPU 数量从 16 增加到 32 时，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eperfbuf 的总 buffer 会跟着翻倍，因为它是 per-CPU buffer；\u003c/li\u003e\n  \u003cli\u003eringbuf 的总 buffer 不一定需要翻倍，就足以处理扩容之后的数据量。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"12-保证事件顺序event-ordering\"\u003e1.2 保证事件顺序（event ordering）\u003c/h2\u003e\n\n\u003cp\u003e如果 BPF 应用要跟踪一系列关联事件（correlated events），例如进程的启动和终止、\n网络连接的生命周期事件等，那\u003cstrong\u003e\u003cmark\u003e保持事件的顺序\u003c/mark\u003e\u003c/strong\u003e就非常关键。\nperfbuf 在这种场景下有一些问题：如果这些事件发生的间隔非常短（几毫秒）并且分散\n在不同 CPU 上，那事件的发送顺序可能就会乱掉 ——这同样是 \u003cstrong\u003e\u003cmark\u003eperbuf 的 per-CPU 特性决定的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e举个真实例子，几年前我写的一个应用需要跟踪进程\nfork/exec/exit 事件，收集进程级别（per-process）的资源使用量。BPF 程序将这些事件\n写入 perfbuf，但它们到达的顺序经常乱掉。这是因为内核调度器在不同 CPU 上调度进程时，\n对于那些存活时间很短的进程，fork(), exec(), and exit() 会在极短的时间内在不同 CPU 上执行。\n这里的问题很清楚，但要解决这个问题，就需要在应用逻辑中加入大量的判断和处理，\n只有亲自做过才知道有多复杂。\u003c/p\u003e\n\n\u003cp\u003e但对于 ringbuf 来说，这根本不是问题，因为它是共享的同一个缓冲区。ringbuf 保证\n\u003cstrong\u003e\u003cmark\u003e如果事件 A 发生在事件 B 之前，那 A 一定会先于 B 被提交，也会在 B 之前被消费\u003c/mark\u003e\u003c/strong\u003e。\n这个特性显著简化了应用处理逻辑。\u003c/p\u003e\n\n\u003ch2 id=\"13-减少数据复制wasted-data-copy\"\u003e1.3 减少数据复制（wasted data copy）\u003c/h2\u003e\n\n\u003cp\u003eBPF 程序使用 perfbuf 时，必须先初始化一份事件数据，然后将它复制到 perfbuf，\n然后才能发送到用户空间。这意味着\u003cstrong\u003e\u003cmark\u003e数据会被复制两次\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一次：复制到一个\u003cstrong\u003e\u003cmark\u003e局部变量\u003c/mark\u003e\u003c/strong\u003e（a local variable）或 per-CPU array\n（BPF 的栈空间很小，因此较大的变量无法放到栈上，后面有例子）中；\u003c/li\u003e\n  \u003cli\u003e第二次：复制到 \u003cstrong\u003e\u003cmark\u003eperfbuf\u003c/mark\u003e\u003c/strong\u003e 中。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e更糟糕的是，如果 perfbuf 已经没有足够空间放数据了，那第一步的复制完全是浪费的。\u003c/p\u003e\n\n\u003cp\u003eBPF ringbuf 提供了一个可选的 reservation/submit API 来避免这种问题。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先申请为数据\u003cstrong\u003e\u003cmark\u003e预留空间\u003c/mark\u003e\u003c/strong\u003e（reserve the space），\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e预留成功后，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e应用就可以直接将准备发送的数据放到 ringbuf 了，从而\u003cstrong\u003e\u003cmark\u003e节省了 perfbuf 中的第一次复制\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e将数据提交到用户空间\u003c/mark\u003e\u003c/strong\u003e将是一件\u003cstrong\u003e\u003cmark\u003e极其高效、不会失败\u003c/mark\u003e\u003c/strong\u003e的操作，也不涉及任何额外的内存复制。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e如果因为 buffer 没有空间而预留失败了，那 BPF 程序马上就能知道，从而也不用再\n执行 perfbuf 中的第一步复制。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e后面会有具体例子。\u003c/p\u003e\n\n\u003ch1 id=\"2-ringbuf-使用场景和性能\"\u003e2 ringbuf 使用场景和性能\u003c/h1\u003e\n\n\u003ch2 id=\"21-常规场景\"\u003e2.1 常规场景\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e对于所有实际场景\u003c/mark\u003e\u003c/strong\u003e（尤其是那些基于 bcc/libbpf 的默认配置在使用 perfbuf 的场景），\n\u003cstrong\u003e\u003cmark\u003eringbuf 的性能都优于 perfbuf 性能\u003c/mark\u003e\u003c/strong\u003e。各种不同场景的仿真压测（synthetic benchmarking）\n结果见内核 \u003ca href=\"https://patchwork.ozlabs.org/project/netdev/patch/20200529075424.3139988-5-andriin@fb.com/\"\u003epatch\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"22-高吞吐场景\"\u003e2.2 高吞吐场景\u003c/h2\u003e\n\n\u003cp\u003ePer-CPU buffer 特性的 \u003cstrong\u003e\u003cmark\u003eperfbuf 在理论上能支持更高的数据吞吐\u003c/mark\u003e\u003c/strong\u003e，\n但这只有在\u003cstrong\u003e\u003cmark\u003e每秒百万级事件\u003c/mark\u003e\u003c/strong\u003e（millions of events per second）的场景下才会显现。\u003c/p\u003e\n\n\u003cp\u003e在编写了一个真实场景的高吞吐应用之后，我们证实了 ringbuf 在作为与 perfbuf 类似的 per-CPU buffer\n使用时，仍然可以作为 perfbuf 的一个高性能替代品，尤其是用到手动管理事件通知（manual data availability notification）机制时。\u003c/p\u003e\n\n\u003cp\u003e基本的 multi-ringbuf example 见内核 selftests：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/tools/testing/selftests/bpf/progs/test_ringbuf_multi.c\"\u003eBPF side\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/tools/testing/selftests/bpf/prog_tests/ringbuf_multi.c\"\u003euser-space side\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"23-不可掩码中断non-maskable-interrupt场景\"\u003e2.3 不可掩码中断（non-maskable interrupt）场景\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e唯一需要注意、最好先试验一下的场景\u003c/mark\u003e\u003c/strong\u003e：BPF 程序必须在\nNMI (non-maskable interrupt) context 中执行时，例如处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu-cycles\u003c/code\u003e 等 perf events 时。\u003c/p\u003e\n\n\u003cp\u003eringbuf 内部使用了一个\u003cstrong\u003e\u003cmark\u003e非常轻量级的 spin-lock\u003c/mark\u003e\u003c/strong\u003e，这意味着如果 NMI\ncontext 中有竞争，data reservation 可能会失败。\n因此，在 NMI context 中，如果 CPU 竞争非常严重，可能会\n\u003cstrong\u003e\u003cmark\u003e导致丢数据，虽然此时 ringbuf 仍然有可用空间\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"24-小结\"\u003e2.4 小结\u003c/h2\u003e\n\n\u003cp\u003e除了 NMI context 之外，在其他所有场景中优先选择 ringbuf 而不是 perfbuf 都是非常明智的。\u003c/p\u003e\n\n\u003ch1 id=\"3-示例程序show-me-the-code\"\u003e3 示例程序（show me the code）\u003c/h1\u003e\n\n\u003cp\u003e完整代码见 \u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples\"\u003ebpf-ringbuf-examples project\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序的功能是 trace 所有进程的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexec()\u003c/code\u003e 操作，也就是创建新进程事件。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e每次 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexec()\u003c/code\u003e 事件：收集进程 ID (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid\u003c/code\u003e)、进程名字 (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecomm\u003c/code\u003e)、可执行文件路径 (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efilename\u003c/code\u003e)，然后发送给用户空间程序；\u003c/li\u003e\n  \u003cli\u003e用户空间简单通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintf()\u003c/code\u003e 打印输出。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e用三种不同方式实现，输出都类似：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo\u003c/span\u003e ./ringbuf-reserve-commit    \u003cspan class=\"c\"\u003e# or ./ringbuf-output, or ./perfbuf-output\u003c/span\u003e\nTIME     EVENT PID     COMM             FILENAME\n19:17:39 EXEC  3232062 sh               /bin/sh\n19:17:39 EXEC  3232062 \u003cspan class=\"nb\"\u003etimeout\u003c/span\u003e          /usr/bin/timeout\n19:17:39 EXEC  3232063 ipmitool         /usr/bin/ipmitool\n19:17:39 EXEC  3232065 \u003cspan class=\"nb\"\u003eenv\u003c/span\u003e              /usr/bin/env\n19:17:39 EXEC  3232066 \u003cspan class=\"nb\"\u003eenv\u003c/span\u003e              /usr/bin/env\n19:17:39 EXEC  3232065 \u003cspan class=\"nb\"\u003etimeout\u003c/span\u003e          /bin/timeout\n19:17:39 EXEC  3232066 \u003cspan class=\"nb\"\u003etimeout\u003c/span\u003e          /bin/timeout\n19:17:39 EXEC  3232067 sh               /bin/sh\n19:17:39 EXEC  3232068 sh               /bin/sh\n^C\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e事件的结构体定义：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#define TASK_COMM_LEN 16\n#define MAX_FILENAME_LEN 512\n\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// BPF 程序发送给 userspace 的事件\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003epid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003ecomm\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eTASK_COMM_LEN\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003efilename\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eMAX_FILENAME_LEN\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里有意让这个结构体的\u003cstrong\u003e\u003cmark\u003e大小超过 512 字节\u003c/mark\u003e\u003c/strong\u003e，这样 event 变量就无法\n放到 BPF 栈空间（max 512Byte）上，后面会看到 perfbuf 和 ringbuf 程序分别怎么处理。\u003c/p\u003e\n\n\u003ch2 id=\"31-perfbuf-示例\"\u003e3.1 perfbuf 示例\u003c/h2\u003e\n\n\u003ch3 id=\"内核-bpf-程序\"\u003e内核 BPF 程序\u003c/h3\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// 声明一个 perfbuf map。几点注意：\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 1. 不用特意设置 max_entries，libbpf 会自动将其设置为 CPU 数量；\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 2. 这个 map 的 per-CPU buffer 大小是 userspace 设置的，后面会看到\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__uint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_MAP_TYPE_PERF_EVENT_ARRAY\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// perf buffer (array)\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__uint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__uint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"n\"\u003epb\u003c/span\u003e \u003cspan class=\"nf\"\u003eSEC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;.maps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 一个 struct event 变量的大小超过了 512 字节，无法放到 BPF 栈上，\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 因此声明一个 size=1 的 per-CPU array 来存放 event 变量\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__uint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_MAP_TYPE_PERCPU_ARRAY\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// per-cpu array\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__uint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emax_entries\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__type\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003e__type\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"n\"\u003eheap\u003c/span\u003e \u003cspan class=\"nf\"\u003eSEC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;.maps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eSEC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;tp/sched/sched_process_exec\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003ehandle_exec\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etrace_event_raw_sched_process_exec\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003efname_off\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003e__data_loc_filename\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xFFFF\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ezero\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\n\t\u003cspan class=\"n\"\u003ee\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map_lookup_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eheap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ezero\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* can\u0026#39;t happen */\u003c/span\u003e\n\t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\t\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003epid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_get_current_pid_tgid\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003ebpf_get_current_comm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecomm\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecomm\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003ebpf_probe_read_str\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efilename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efilename\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003efname_off\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\t\u003cspan class=\"c1\"\u003e// 发送事件，参数列表 \u0026lt;context, \u0026amp;perfbuf, flag, event, sizeof(event)\u0026gt;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003ebpf_perf_event_output\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_F_CURRENT_CPU\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"用户空间程序\"\u003e用户空间程序\u003c/h3\u003e\n\n\u003cp\u003e完整代码 \u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples/blob/main/src/perfbuf-output.c\"\u003ethe user-space side\u003c/a\u003e，\n基于 BPF skeleton（更多信息见\n\u003ca href=\"https://nakryiko.com/posts/bcc-to-libbpf-howto-guide/#bpf-skeleton-and-bpf-app-lifecycle\"\u003e这里\u003c/a\u003e）。\u003c/p\u003e\n\n\u003cp\u003e看一个关键点：使用 libbpf user-space \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf_buffer__new()\u003c/code\u003e API 来创建一个 perf buffer consumer：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eperf_buffer\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eperf_buffer_opts\u003c/span\u003e \u003cspan class=\"n\"\u003epb_opts\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{};\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eperfbuf_output_bpf\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskel\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\t\u003cspan class=\"cm\"\u003e/* Set up ring buffer polling */\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003epb_opts\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esample_cb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehandle_event\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\t\u003cspan class=\"n\"\u003epb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eperf_buffer__new\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_map__fd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskel\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emaps\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epb\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* 32KB per CPU */\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epb_opts\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里\u003cstrong\u003e\u003cmark\u003e设置 per-CPU buffer 为 32KB\u003c/mark\u003e\u003c/strong\u003e，\n注意其中的 8 表示的是 number of memory pages，每个 page 是 4KB，因此总大小：\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e8 pages x 4096 byte/page = 32KB\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"32-ringbuf-示例\"\u003e3.2 ringbuf 示例\u003c/h2\u003e\n\n\u003cp\u003e完整代码：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples/blob/main/src/ringbuf-output.bpf.c\"\u003eBPF-side code\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples/blob/main/src/ringbuf-output.c\"\u003euser-space code\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"内核-bpf-程序-1\"\u003e内核 BPF 程序\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_output()\u003c/code\u003e 在设计上遵循了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_perf_event_output()\u003c/code\u003e 的语义，\n以使应用从 perfbuf 迁移到 ringbuf 时更容易。为了看出二者有多相似，这里展示下\n两个示例代码的 diff。\u003c/p\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e--- src/perfbuf-output.bpf.c\t2020-10-25 18:52:22.247019800 -0700\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ src/ringbuf-output.bpf.c\t2020-10-25 18:44:14.510630322 -0700\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -6,12 +6,11 @@\u003c/span\u003e\n \n char LICENSE[] SEC(\u0026#34;license\u0026#34;) = \u0026#34;Dual BSD/GPL\u0026#34;;\n \n\u003cspan class=\"gd\"\u003e-/* BPF perfbuf map */\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+/* BPF ringbuf map */\n\u003c/span\u003e struct {\n\u003cspan class=\"gd\"\u003e-\t__uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n-\t__uint(key_size, sizeof(int));\n-\t__uint(value_size, sizeof(int));\n-} pb SEC(\u0026#34;.maps\u0026#34;);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\t__uint(type, BPF_MAP_TYPE_RINGBUF);\n+\t__uint(max_entries, 256 * 1024 /* 256 KB */);\n+} rb SEC(\u0026#34;.maps\u0026#34;);\n\u003c/span\u003e \n struct {\n \t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n\u003cspan class=\"p\"\u003e@@ -35,7 +34,7 @@\u003c/span\u003e\n \tbpf_get_current_comm(\u0026amp;e-\u0026gt;comm, sizeof(e-\u0026gt;comm));\n \tbpf_probe_read_str(\u0026amp;e-\u0026gt;filename, sizeof(e-\u0026gt;filename), (void *)ctx + fname_off);\n \n\u003cspan class=\"gd\"\u003e-\tbpf_perf_event_output(ctx, \u0026amp;pb, BPF_F_CURRENT_CPU, e, sizeof(*e));\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\tbpf_ringbuf_output(\u0026amp;rb, e, sizeof(*e), 0);\n\u003c/span\u003e \treturn 0;\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e只有两个小改动：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eringbuf map 的大小（max_entries）可以在 BPF 侧指定了\u003c/mark\u003e\u003c/strong\u003e，注意这是所有 CPU 共享的大小。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e在 userspace 侧来设置（或 override） max_entries 也是可以的，API 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_map__set_max_entries()\u003c/code\u003e；\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax_entries\u003c/code\u003e 的单位是字节，必须是\u003cstrong\u003e\u003cmark\u003e内核页大小\u003c/mark\u003e\u003c/strong\u003e（\n几乎永远是 4096）\u003cstrong\u003e\u003cmark\u003e的倍数，也必须是 2 的幂次\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_perf_event_output()\u003c/code\u003e 替换成了类似的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_output()\u003c/code\u003e，后者更简单，不需要 BPF context 参数。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"用户空间程序-1\"\u003e用户空间程序\u003c/h3\u003e\n\n\u003cp\u003e事件 handler 签名有点变化：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e会返回错误信息（进而终止 consumer 循环）\u003c/li\u003e\n  \u003cli\u003e参数里面去掉了产生这个事件的 CPU Index\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e-void handle_event(void *ctx, int cpu, void *data, unsigned int data_sz)\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+int handle_event(void *ctx, void *data, size_t data_sz)\n\u003c/span\u003e\u003cspan class=\"err\"\u003e{\u003c/span\u003e\n\tconst struct event *e = data;\n\tstruct tm *tm;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果 CPU index 对你很重要，那你需要自己在 BPF 代码中记录它。\u003c/p\u003e\n\n\u003cp\u003e另外，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ering_buffer\u003c/code\u003e API 不提供丢失数据（lost samples）的回调函数，而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf_buffer\u003c/code\u003e 是支持的。\n如果需要这个功能，必须自己在 BPF 代码中处理。\n这样的设计对于一个（所有 CPU）共享的 ring buffer 能\u003cstrong\u003e\u003cmark\u003e最小化锁竞争\u003c/mark\u003e\u003c/strong\u003e，\n同时也避免了为不需要的功能买单：在实际中，这功能除了能用户在 userspace 打印出有数据丢失之外，其他基本也做不了什么，\n而类似的目的在 BPF 中可以更显式和高效地完成。\u003c/p\u003e\n\n\u003cp\u003e第二个不同是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ering_buffer__new()\u003c/code\u003e API 更加简洁：\u003c/p\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \t/* Set up ring buffer polling */\n\u003cspan class=\"gd\"\u003e-\tpb_opts.sample_cb = handle_event;\n-\tpb = perf_buffer__new(bpf_map__fd(skel-\u0026gt;maps.pb), 8 /* 32KB per CPU */, \u0026amp;pb_opts);\n-\tif (libbpf_get_error(pb)) {\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\trb = ring_buffer__new(bpf_map__fd(skel-\u0026gt;maps.rb), handle_event, NULL, NULL);\n+\tif (!rb) {\n\u003c/span\u003e \t\terr = -1;\n\u003cspan class=\"gd\"\u003e-\t\tfprintf(stderr, \u0026#34;Failed to create perf buffer\\n\u0026#34;);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\t\tfprintf(stderr, \u0026#34;Failed to create ring buffer\\n\u0026#34;);\n\u003c/span\u003e \t\tgoto cleanup;\n \t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e接下来基本上就是文本替换一下的事情了：\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf_buffer__poll()\u003c/code\u003e -\u0026gt; \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ering_buffer__poll()\u003c/code\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \tprintf(\u0026#34;%-8s %-5s %-7s %-16s %s\\n\u0026#34;,\n \t       \u0026#34;TIME\u0026#34;, \u0026#34;EVENT\u0026#34;, \u0026#34;PID\u0026#34;, \u0026#34;COMM\u0026#34;, \u0026#34;FILENAME\u0026#34;);\n \twhile (!exiting) {\n\u003cspan class=\"gd\"\u003e-\t\terr = perf_buffer__poll(pb, 100 /* timeout, ms */);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\t\terr = ring_buffer__poll(rb, 100 /* timeout, ms */);\n\u003c/span\u003e \t\t/* Ctrl-C will cause -EINTR */\n \t\tif (err == -EINTR) {\n \t\t\terr = 0;\n \t\t\tbreak;\n \t\t}\n \t\tif (err \u0026lt; 0) {\n\u003cspan class=\"gd\"\u003e-\t\t\tprintf(\u0026#34;Error polling perf buffer: %d\\n\u0026#34;, err);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\t\t\tprintf(\u0026#34;Error polling ring buffer: %d\\n\u0026#34;, err);\n\u003c/span\u003e \t\t\tbreak;\n \t\t}\n \t}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"33-ringbuf-reservecommit-api-示例\"\u003e3.3 ringbuf reserve/commit API 示例\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_output()\u003c/code\u003e API 的目的是确保从 perfbuf 到 ringbuf 迁移时无需对 BPF 代\n码做重大改动，但这也意味着它继承了 perfbuf API 的一些缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e额外的内存复制（extra memory copy）\u003c/p\u003e\n\n    \u003cp\u003e这意味着需要额外的空间来构建 event 变量，然后将其复制到 buffer。不仅低效，\n 而且经常需要引入只有一个元素的 per-CPU array，增加了不必要的处理复杂性。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e非常晚的 buffer 空间申请（data reservation）\u003c/p\u003e\n\n    \u003cp\u003e如果这一步失败了（例如由于用户空间消费不及时导致 buffer 满了，或者有大量\n 突发事件导致 buffer 溢出了），那上一步的工作将变得完全无效，浪费内存空间和计算资源。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"原理\"\u003e原理\u003c/h3\u003e\n\n\u003cp\u003e如果\u003cstrong\u003e\u003cmark\u003e能提前知道事件将在第二步被丢弃，就无需做第一步了\u003c/mark\u003e\u003c/strong\u003e，\n节省一些内存和计算资源，消费端反而因此而消费地更快一些。\n但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exxx_output()\u003c/code\u003e 风格的 API 是无法实现这个目的的。\u003c/p\u003e\n\n\u003cp\u003e这就是为什么引入了新的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_reserve()\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_commit()\u003c/code\u003e API。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e提前预留空间，或者能立即发现没有可以空间了（返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNULL\u003c/code\u003e）；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e预留成功后，一旦数据写好了，将它发送到 userspace 是一个不会失败的操作。\u003c/p\u003e\n\n    \u003cp\u003e也就是说只要 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_reserve()\u003c/code\u003e 返回非空，那随后的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_commit()\u003c/code\u003e\n  就永远会成功，因此它没有返回值。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外，ring buffer 中\u003cstrong\u003e\u003cmark\u003e预留的空间在被提交之前，用户空间是看不到的\u003c/mark\u003e\u003c/strong\u003e，\n因此 BPF 程序可以从容地组织自己的 event 数据，不管它有多复杂、需要多少步骤。\n这种方式也避免了额外的内存复制和临时存储空间（extra memory copying and temporary storage spaces）。\u003c/p\u003e\n\n\u003ch3 id=\"限制\"\u003e限制\u003c/h3\u003e\n\n\u003cp\u003e唯一的限制是：\u003cstrong\u003e\u003cmark\u003eBPF 校验器在校验时\u003c/mark\u003e\u003c/strong\u003e（at verification time），\n\u003cstrong\u003e\u003cmark\u003e必须知道预留数据的大小\u003c/mark\u003e\u003c/strong\u003e\n（size of the reservation），因此不支持动态大小的事件数据。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对于动态大小的数据，用户只能退回到用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_output()\u003c/code\u003e 方式来提交，忍受额外的数据复制开销；\u003c/li\u003e\n  \u003cli\u003e其他所有情况下，reserve/commit API 都应该是首选。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"内核-bpf-程序-2\"\u003e内核 BPF 程序\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples/blob/main/src/ringbuf-reserve-submit.bpf.c\"\u003eBPF\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/anakryiko/bpf-ringbuf-examples/blob/main/src/ringbuf-reserve-submit.c\"\u003euser-space\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"gd\"\u003e--- src/ringbuf-output.bpf.c\t2020-10-25 18:44:14.510630322 -0700\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+++ src/ringbuf-reserve-submit.bpf.c\t2020-10-25 18:36:53.409470270 -0700\n\u003c/span\u003e\u003cspan class=\"p\"\u003e@@ -12,29 +12,21 @@\u003c/span\u003e\n \t__uint(max_entries, 256 * 1024 /* 256 KB */);\n } rb SEC(\u0026#34;.maps\u0026#34;);\n \n\u003cspan class=\"gd\"\u003e-struct {\n-\t__uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);\n-\t__uint(max_entries, 1);\n-\t__type(key, int);\n-\t__type(value, struct event);\n-} heap SEC(\u0026#34;.maps\u0026#34;);\n-\n\u003c/span\u003e SEC(\u0026#34;tp/sched/sched_process_exec\u0026#34;)\n int handle_exec(struct trace_event_raw_sched_process_exec *ctx)\n {\n \tunsigned fname_off = ctx-\u0026gt;__data_loc_filename \u0026amp; 0xFFFF;\n \tstruct event *e;\n\u003cspan class=\"gd\"\u003e-\tint zero = 0;\n\u003c/span\u003e \t\n\u003cspan class=\"gd\"\u003e-\te = bpf_map_lookup_elem(\u0026amp;heap, \u0026amp;zero);\n-\tif (!e) /* can\u0026#39;t happen */\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\te = bpf_ringbuf_reserve(\u0026amp;rb, sizeof(*e), 0);\n+\tif (!e)\n\u003c/span\u003e \t\treturn 0;\n \n \te-\u0026gt;pid = bpf_get_current_pid_tgid() \u0026gt;\u0026gt; 32;\n \tbpf_get_current_comm(\u0026amp;e-\u0026gt;comm, sizeof(e-\u0026gt;comm));\n \tbpf_probe_read_str(\u0026amp;e-\u0026gt;filename, sizeof(e-\u0026gt;filename), (void *)ctx + fname_off);\n \n\u003cspan class=\"gd\"\u003e-\tbpf_ringbuf_output(\u0026amp;rb, e, sizeof(*e), 0);\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\tbpf_ringbuf_submit(e, 0);\n\u003c/span\u003e \treturn 0;\n }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"用户空间程序-2\"\u003e用户空间程序\u003c/h3\u003e\n\n\u003cp\u003e用户空间代码与之前的 ringbuf output API 完全一样，因为这个 API 涉及到的只是提交方（生产方），\n消费方还是一样的方式来消费。\u003c/p\u003e\n\n\u003ch1 id=\"4-ringbuf-事件通知控制\"\u003e4 ringbuf 事件通知控制\u003c/h1\u003e\n\n\u003ch2 id=\"41-事件通知开销\"\u003e4.1 事件通知开销\u003c/h2\u003e\n\n\u003cp\u003e在高吞吐场景中，最大的性能损失经常来自提交数据时，\u003cstrong\u003e\u003cmark\u003e内核的信号通知开销\u003c/mark\u003e\u003c/strong\u003e（in-kernel signalling of data availability）\n，也就是内核的 poll/epoll 通知阻塞在读数据上的 userspace handler 接收数据。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e这一点对 perfbuf 和 ringbuf 都是一样的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"42-perbuf-解决方式\"\u003e4.2 perbuf 解决方式\u003c/h2\u003e\n\n\u003cp\u003eperfbuf 处理这种场景的方式是提供了一个\u003cstrong\u003e\u003cmark\u003e采样通知（sampled notification）机制\u003c/mark\u003e\u003c/strong\u003e：\n每 N 个事件才会发送一次通知。用户空间创建 perfbuf 时可以指定这个参数。\u003c/p\u003e\n\n\u003cp\u003e这种机制能否解决问题，因具体场景而异。\u003c/p\u003e\n\n\u003ch2 id=\"43-ringbuf-解决方式\"\u003e4.3 ringbuf 解决方式\u003c/h2\u003e\n\n\u003cp\u003eringbuf 选了一条不同的路：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_output()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ringbuf_commit()\u003c/code\u003e\n都\u003cstrong\u003e\u003cmark\u003e支持一个额外的 flags 参数\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_RB_NO_WAKEUP\u003c/code\u003e：不触发通知\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_RB_FORCE_WAKEUP\u003c/code\u003e：会触发通知\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e基于这个 flags，用户能实现\u003cstrong\u003e\u003cmark\u003e更加精确的通知控制\u003c/mark\u003e\u003c/strong\u003e。例子见\n\u003ca href=\"https://github.com/torvalds/linux/blob/master/tools/testing/selftests/bpf/progs/ringbuf_bench.c#L22-L31\"\u003eBPF ringbuf\nbenchmark\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e默认情况下，如果没指定任何 flag，ringbuf 会采用\u003cstrong\u003e\u003cmark\u003e自适应通知\u003c/mark\u003e\u003c/strong\u003e\n（adaptive notification）机制，根据 userspace 消费者是否有滞后（lagging）来动态\n调整通知间隔，尽量确保 userspace 消费者既不用承担额外开销，又不丢失任何数据。\n这种默认配置在大部分场景下都是有效和安全的，但如果想获得极致性能，那\n显式控制数据通知就是有必要的，需要结合具体应用场景和处理逻辑来设计。\u003c/p\u003e\n\n\u003ch1 id=\"5-总结\"\u003e5 总结\u003c/h1\u003e\n\n\u003cp\u003e本文介绍了 BPF ring buffer 解决的问题及其背后的设计。\u003c/p\u003e\n\n\u003cp\u003e文中给出的示例代码和内核代码链接，展示了 ringbuf API 的基础和高级用法。\n希望阅读本文之后，读者能对 ringbuf 有一个很好的理解和把握，能根据自己的具体应用\n选择合适的 API 来使用。\u003c/p\u003e\n\n\u003ch1 id=\"其他相关资料译注\"\u003e其他相关资料（译注）\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e内核文档，\u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/ringbuf.html\"\u003eBPF ring buffer\u003c/a\u003e\u003c/p\u003e\n\n    \u003cp\u003e有一些更细节的设计与实现，可作为本文补充。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cracking-k8s-authz-rbac/\"\u003e\u003cspan\u003e« Cracking Kubernetes RBAC Authorization (AuthZ) Model (2022)\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/bpf-advanced-notes-4-zh/\"\u003e\u003cspan\u003eBPF 进阶笔记（四）：调试 BPF 程序 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-04-25T00:00:00Z",
  "Author": "Arthur Chiao"
}