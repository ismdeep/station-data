{
  "Source": "arthurchiao.art",
  "Title": "BPF 进阶笔记（四）：调试 BPF 程序",
  "Link": "https://arthurchiao.art/blog/bpf-advanced-notes-4-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eBPF 进阶笔记（四）：调试 BPF 程序\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-05-02 | Last Update 2023-01-13\u003c/p\u003e\n  \n  \u003ch2 id=\"关于-bpf-进阶笔记-系列\"\u003e关于 “BPF 进阶笔记” 系列\u003c/h2\u003e\n\n\u003cp\u003e平时学习和使用 BPF 时所整理。由于是笔记而非教程，因此内容不会追求连贯，有基础的\n同学可作查漏补缺之用。\u003c/p\u003e\n\n\u003cp\u003e文中涉及的代码，如无特殊说明，均基于内核 \u003cstrong\u003e\u003cmark\u003e5.10\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-1-zh/\"\u003eBPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-2-zh/\"\u003eBPF 进阶笔记（二）：BPF Map 类型详解：使用场景、程序示例\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-3-zh/\"\u003eBPF 进阶笔记（三）：BPF Map 内核实现\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-4-zh/\"\u003eBPF 进阶笔记（四）：调试 BPF 程序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-5-zh/\"\u003eBPF 进阶笔记（五）：几种 TCP 相关的 BPF（sockops、struct_ops、header options）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#关于-bpf-进阶笔记-系列\" id=\"markdown-toc-关于-bpf-进阶笔记-系列\"\u003e关于 “BPF 进阶笔记” 系列\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-打印日志\" id=\"markdown-toc-1-打印日志\"\u003e1 打印日志\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-日志路径及格式\" id=\"markdown-toc-11-日志路径及格式\"\u003e1.1 日志路径及格式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-bpf_printkkernel-52\" id=\"markdown-toc-12-bpf_printkkernel-52\"\u003e1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e：kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.2+\u003c/code\u003e\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#使用方式\" id=\"markdown-toc-使用方式\"\u003e使用方式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#使用限制\" id=\"markdown-toc-使用限制\"\u003e使用限制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#内核实现\" id=\"markdown-toc-内核实现\"\u003e内核实现\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-bpf_trace_printk\" id=\"markdown-toc-13-bpf_trace_printk\"\u003e1.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#使用方式-1\" id=\"markdown-toc-使用方式-1\"\u003e使用方式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#使用限制-1\" id=\"markdown-toc-使用限制-1\"\u003e使用限制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#内核实现-1\" id=\"markdown-toc-内核实现-1\"\u003e内核实现\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-用-bpf-程序-trace-另一个-bpf-程序\" id=\"markdown-toc-2-用-bpf-程序-trace-另一个-bpf-程序\"\u003e2 用 BPF 程序 trace 另一个 BPF 程序\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-使用场景\" id=\"markdown-toc-21-使用场景\"\u003e2.1 使用场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-依赖kernel-55\" id=\"markdown-toc-22-依赖kernel-55\"\u003e2.2 依赖：kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.5+\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-设置断点单步调试\" id=\"markdown-toc-3-设置断点单步调试\"\u003e3 设置断点，单步调试\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-bpf_dbg仅限-cbpf\" id=\"markdown-toc-31-bpf_dbg仅限-cbpf\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_dbg\u003c/code\u003e（仅限 cBPF）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#附录\" id=\"markdown-toc-附录\"\u003e附录\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#bpf-trampoline-简介\" id=\"markdown-toc-bpf-trampoline-简介\"\u003eBPF trampoline 简介\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-to-kernel-trampolinebpf-调用内核函数\" id=\"markdown-toc-bpf-to-kernel-trampolinebpf-调用内核函数\"\u003eBPF-to-kernel trampoline（BPF 调用内核函数）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#kernel-to-bpf-trampoline内核函数调用-bpf\" id=\"markdown-toc-kernel-to-bpf-trampoline内核函数调用-bpf\"\u003eKernel-to-BPF trampoline（内核函数调用 BPF）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#fentryfexit-相比-kprobekretprobe-的优势\" id=\"markdown-toc-fentryfexit-相比-kprobekretprobe-的优势\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efentry/fexit\u003c/code\u003e 相比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekprobe/kretprobe\u003c/code\u003e 的优势\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-打印日志\"\u003e1 打印日志\u003c/h1\u003e\n\n\u003ch2 id=\"11-日志路径及格式\"\u003e1.1 日志路径及格式\u003c/h2\u003e\n\n\u003cp\u003e本节将介绍的几种打印日志方式最终都会输出到 debugfs 路径 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/sys/kernel/debug/tracing/trace\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo tail\u003c/span\u003e /sys/kernel/debug/tracing/trace\n\u003cspan class=\"c\"\u003e# 字段说明  \u0026lt;taskname\u0026gt;-\u0026lt;pid\u0026gt;    \u0026lt;cpuid\u0026gt;  \u0026lt;opts\u0026gt;  \u0026lt;timestamp\u0026gt;    \u0026lt;fake by bpf\u0026gt;  \u0026lt;log content\u0026gt;\u003c/span\u003e\n            telnet-470          \u003cspan class=\"o\"\u003e[\u003c/span\u003e001]     .N..   419421.045894: 0x00000001:    \u0026lt;formatted msg\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以上看到的是默认 trace 输出格式，\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e可通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/trace_options\u003c/code\u003e 定制化 trace 输出格式（打印哪些列）；\u003c/li\u003e\n    \u003cli\u003e另外还可参考 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/README\u003c/code\u003e，其中有更详细的说明。\u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/uapi/linux/bpf.h#L796\"\u003e\u003cmark\u003e字段说明\u003c/mark\u003e\u003c/a\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etelnet\u003c/code\u003e：进程名；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e470\u003c/code\u003e：进程 ID；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e001\u003c/code\u003e：进程所在的 CPU；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.N..\u003c/code\u003e：每个字符表示一组配置选项，依次为，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e是否启用了中断（irqs）；\u003c/li\u003e\n      \u003cli\u003e调度选项，这里 N 表示设置了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTIF_NEED_RESCHED\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePREEMPT_NEED_RESCHED\u003c/code\u003e 标志位；\u003c/li\u003e\n      \u003cli\u003e硬中断/软中断是否正在运行；\u003c/li\u003e\n      \u003cli\u003elevel of preempt_disabled\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e419421.045894\u003c/code\u003e：时间戳；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x00000001\u003c/code\u003e：BPF 使用的一个 fake value，for instruction pointer register；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;formatted msg\u0026gt;\u003c/code\u003e：日志内容。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"12-bpf_printkkernel-52\"\u003e1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e：kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.2+\u003c/code\u003e\u003c/h2\u003e\n\n\u003ch3 id=\"使用方式\"\u003e使用方式\u003c/h3\u003e\n\n\u003cp\u003e这是内核 libbpf 库提供的一个宏：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/tools/lib/bpf/bpf_helpers.h#L17\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* Helper macro to print out debug messages */\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define bpf_printk(fmt, ...)                \\\n({                            \\\n    char ____fmt[] = fmt;                \\\n    bpf_trace_printk(____fmt, sizeof(____fmt),    \\\n             ##__VA_ARGS__);        \\\n})\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使用非常方便，和 C 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintf()\u003c/code\u003e 差不多，例如，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003ebpf_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;tcp_v4_connect latency_us: %u\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elatency_us\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"使用限制\"\u003e使用限制\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e需要内核 5.2+，否则编译能通过，但执行时会报错：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e map .rodata: map create: read- and write-only maps not supported (requires \u0026gt;= v5.2)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e这个错误提示非常奇怪（实际上目前来说，大部分 BPF 错误提示都不那么直接）。\u003c/p\u003e\n\n    \u003cp\u003e简单来说，BPF 的栈空间非常小，每次调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e 都会动态声明一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003echar ____fmt[] = fmt;\u003c/code\u003e 并放到栈上，导致性能很差。\n \u003cstrong\u003e\u003cmark\u003e5.2 引入了 BPF global (and static) 变量\u003c/mark\u003e\u003c/strong\u003e，因此 clang 在编译时\n 可以直接将这些变量放到 ELF 的只读区域（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.rodata\u003c/code\u003e，read-only data），libbpf\n 加载程序时将这些数据放到一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.rodata\u003c/code\u003e BPF map 中，程序在用到这些变量时，背后执行一次 map lookup 即可。\n 相比于每次都在栈上创建一个字符数组（字符串），这样更加快速和高效。\u003c/p\u003e\n\n    \u003cp\u003e更多内容，见 Andrii Nakryiko 的博客 \u003ca href=\"https://nakryiko.com/posts/bpf-tips-printk/\"\u003eImproving \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e\u003c/a\u003e 。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e最多只能带 3 个参数\u003c/mark\u003e\u003c/strong\u003e，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk(fmt, arg1, arg2, arg3)\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e这是由 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e 的限制决定的，下一节有具体解释。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"内核实现\"\u003e内核实现\u003c/h3\u003e\n\n\u003cp\u003e前面已经看到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e 非常简单，只是单纯封装了一下 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ebpf_trace_printk()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\n后者定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einclude/uapi/linux/bpf.h\u003c/code\u003e，具体实现见下文。\u003c/p\u003e\n\n\u003ch2 id=\"13-bpf_trace_printk\"\u003e1.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e对于 5.2 以下的内核，打印日志可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e，它比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_printk()\u003c/code\u003e\n要麻烦一点：要提前声明格式字符串 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efmt\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"使用方式-1\"\u003e使用方式\u003c/h3\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e//  https://github.com/torvalds/linux/blob/v5.10/include/uapi/linux/bpf.h#L772\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/**\n * long bpf_trace_printk(const char *fmt, u32 fmt_size, ...)\n */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e功能与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintk()\u003c/code\u003e 类似，按指定格式将日志打印到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/trace\u003c/code\u003e 中；\n但\u003cstrong\u003e\u003cmark\u003e支持的格式比 printk() 少\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.10\u003c/code\u003e 支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%d\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%i\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%u\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%x\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%ld\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%li\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%lu\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%lx\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%lld\u003c/code\u003e,\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%lli\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%llu\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%llx\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%p\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%s\u003c/code\u003e。不支持指定字符串或数字长度等，否则会返回\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-EINVAL\u003c/code\u003e（同时什么都不打印）。\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.13\u003c/code\u003e 有进一步增强，见 \u003ca href=\"https://nakryiko.com/posts/bpf-tips-printk/\"\u003eDetecting full-powered bpf_trace_printk()\u003c/a\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e每次调用这个函数时，会往 trace 中追加一行；当 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/trace\u003c/code\u003e is open，日志会被丢弃，\n  可使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/trace_pipe\u003c/code\u003e 来避免这种情况；\u003c/li\u003e\n  \u003cli\u003e这个函数\u003cstrong\u003e\u003cmark\u003e执行很慢，因此只应在调试时使用\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efmt\u003c/code\u003e 格式串\u003cstrong\u003e\u003cmark\u003e是否有默认换行\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.9\u003c/code\u003e 之前没有，需要自己加 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\\n\u003c/code\u003e；\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.9+\u003c/code\u003e 会默认加一个换行符，patch 见 \u003ca href=\"https://github.com/torvalds/linux/commit/ac5a72ea5c898\"\u003ebpf: Use dedicated bpf_trace_printk event instead of trace_printk()\u003c/a\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e函数的返回值是写到 buffer 的字节数，出错时返回负的 error code。\u003c/p\u003e\n\n\u003cp\u003e例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;tcp_v4_connect latency_us: %u\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003elatency_us\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"使用限制-1\"\u003e使用限制\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e最多只能带 3 个参数\u003c/mark\u003e\u003c/strong\u003e（这是因为 \u003cstrong\u003e\u003cmark\u003eeBPF helpers 最多只能带 5 个参数\u003c/mark\u003e\u003c/strong\u003e，前面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efmt\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efmt_size\u003c/code\u003e 已经占了两个了）；\u003c/li\u003e\n  \u003cli\u003e使用该函数的代码必须是 \u003ca href=\"https://nakryiko.com/posts/bpf-tips-printk/\"\u003eGPL 兼容的\u003c/a\u003e；\u003c/li\u003e\n  \u003cli\u003e前面已经提到，格式字符串支持的类型有限，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.13\u003c/code\u003e 有进一步改进，详见 \u003ca href=\"https://nakryiko.com/posts/bpf-tips-printk/\"\u003eDetecting full-powered bpf_trace_printk()\u003c/a\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"内核实现-1\"\u003e内核实现\u003c/h3\u003e\n\n\u003cp\u003e实现：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/kernel/trace/bpf_trace.c#L428\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eBPF_CALL_5\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efmt_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earg1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earg2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003earg3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 BPF_CALL_5 的定义：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/include/linux/filter.h#L485\u003c/span\u003e\n\n\u003cspan class=\"cp\"\u003e#define BPF_CALL_x(x, name, ...)                           \\\n    static __always_inline u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__));   \\\n    typedef u64                (*btf_##name)(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__)); \\\n    u64                        name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__));           \\\n    u64                        name(__BPF_REG(x, __BPF_DECL_REGS, __BPF_N, __VA_ARGS__)) {       \\\n        return ((btf_##name)____##name)(__BPF_MAP(x,__BPF_CAST,__BPF_N,__VA_ARGS__));\\\n    }                                       \\\n    static __always_inline u64 ____##name(__BPF_MAP(x, __BPF_DECL_ARGS, __BPF_V, __VA_ARGS__))\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define BPF_CALL_5(name, ...)    BPF_CALL_x(5, name, __VA_ARGS__)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"2-用-bpf-程序-trace-另一个-bpf-程序\"\u003e2 用 BPF 程序 trace 另一个 BPF 程序\u003c/h1\u003e\n\n\u003ch2 id=\"21-使用场景\"\u003e2.1 使用场景\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://lwn.net/Articles/804112/\"\u003eBPF trampoline\u003c/a\u003e 是\n内核函数和 BPF 程序之间、BPF 程序和其他 BPF 程序之间的桥梁（更多介绍见附录）。\n使用场景之一是 \u003cstrong\u003e\u003cmark\u003etracing 其他 BPF 程序\u003c/mark\u003e\u003c/strong\u003e，例如 XDP 程序。\n现在能向任何网络类型的 BPF 程序 attach 类似 fentry/fexit 的 BPF 程序，因\n此能够看到 XDP、TC、LWT、cgroup 等任何类型 BPF 程序中包的进进出出，而不会影\n响到这些程序的执行，大大降低了基于 BPF 的网络排障难度。\u003c/p\u003e\n\n\u003cp\u003e一些 patch，如果感兴趣:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-4-ast@kernel.org/\"\u003ebpf: Introduce BPF trampoline\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-15-ast@kernel.org/\"\u003ebpf: Support attaching tracing BPF program to other BPF programs\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-17-ast@kernel.org/\"\u003elibbpf: Add support for attaching BPF programs to other BPF programs\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/commit/b8c54ea455dc2e0bda7ea9b0370279c224e21045\"\u003elibbpf: Add support to attach to fentry/fexit tracing progs\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-4-ast@kernel.org/\"\u003etrampoline impl: jit_com, trampoline, verifier, btf, good doc\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBPF trampoline 其他使用场景：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003efentry/fexit\u003c/mark\u003e\u003c/strong\u003e BPF 程序：\u003cstrong\u003e\u003cmark\u003e功能与 kprobe/kretprobe 类似，但性能更好\u003c/mark\u003e\u003c/strong\u003e，几乎没有性能开销（practically zero overhead）；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e动态链接 BPF 程序\u003c/mark\u003e\u003c/strong\u003e（dynamicly link BPF programs）。\u003c/p\u003e\n\n    \u003cp\u003e在 tracing、networking、cgroup BPF 程序中，是比 prog array 和 prog link list 更加通用的机制。\n 在很多情况下，可直接作为基于 bpf_tail_call 程序链的一种替代方案。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这些特性都需要 root 权限。\u003c/p\u003e\n\n\u003ch2 id=\"22-依赖kernel-55\"\u003e2.2 依赖：kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.5+\u003c/code\u003e\u003c/h2\u003e\n\n\u003ch1 id=\"3-设置断点单步调试\"\u003e3 设置断点，单步调试\u003c/h1\u003e\n\n\u003ch2 id=\"31-bpf_dbg仅限-cbpf\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_dbg\u003c/code\u003e（仅限 cBPF）\u003c/h2\u003e\n\n\u003cp\u003e见 \u003ca href=\"/blog/linux-socket-filtering-aka-bpf-zh/\"\u003e(译) Linux Socket Filtering (LSF, aka BPF)（Kernel，2021）\u003c/a\u003e。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"附录\"\u003e附录\u003c/h1\u003e\n\n\u003ch2 id=\"bpf-trampoline-简介\"\u003eBPF trampoline 简介\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e“trampoline” 是意思是“蹦床”，这里是指程序执行时的特殊“适配+跳转”。\nBPF trampoline 最初用于 tracing 和 fentry/fexit，但后面扩展到了其他场景，例如\n更高效地跟踪 XDP 程序，解决 XDP 程序开发和排障痛点。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个 \u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-4-ast@kernel.org/\"\u003epatch\u003c/a\u003e 引入了\nBPF trampoline 概念，\u003cstrong\u003e\u003cmark\u003e将原生调用约定\u003c/mark\u003e\u003c/strong\u003e（native calling convention）\n\u003cstrong\u003e\u003cmark\u003e转换成 BPF 调用约定\u003c/mark\u003e\u003c/strong\u003e（BPF calling convention），\n从而使内核代码能\u003cstrong\u003e\u003cmark\u003e几乎零开销地（practically zero overhead）调用 BPF 程序\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eBPF 架构和调用约定：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e64 位 ISA（即使在 32 位架构上），\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eR1-R5 用于 BPF function 传参\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e主 BPF program 只接受一个参数\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e，通过 R1 传递。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCPU 原生调用约定：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ex86-64 前 6 个参数通过寄存器传递，其他参数通过栈传递；\u003c/li\u003e\n  \u003cli\u003ex86-32 前 3 个参数通过寄存器传递；\u003c/li\u003e\n  \u003cli\u003esparc64 前 6 个参数通过寄存器传递；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003etrampoline 是架构相关的，因此其代码生成逻辑因架构而异\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-to-kernel-trampolinebpf-调用内核函数\"\u003eBPF-to-kernel trampoline（BPF 调用内核函数）\u003c/h3\u003e\n\n\u003cp\u003e这种 trampoline 早就有了：\n宏 BPF_CALL_x （定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einclude/linux/filter.h\u003c/code\u003e）将 BPF 中的 trampolines\n\u003cstrong\u003e\u003cmark\u003e静态地编译为内核辅助函数\u003c/mark\u003e\u003c/strong\u003e（helpers）。\n这个过程\u003cstrong\u003e\u003cmark\u003e最多能将 5 个参数转换成内核 C 指针或整数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 64 位机器上：\u003cstrong\u003e\u003cmark\u003e不需做额外的处理\u003c/mark\u003e\u003c/strong\u003e（因为 BPF 本来就是针对 64\n架构设计的，尤其关注与底层 ISA 的高效转换），因此 trampolines 都是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enop\u003c/code\u003e 指令；\u003c/li\u003e\n  \u003cli\u003e在 32 位架构上：trampolines 是有实际作用的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"kernel-to-bpf-trampoline内核函数调用-bpf\"\u003eKernel-to-BPF trampoline（内核函数调用 BPF）\u003c/h3\u003e\n\n\u003cp\u003e这些反向 trampolines 是由宏 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCAST_TO_U64\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__bpf_trace_##call()\u003c/code\u003e shim functions（定义在 include/trace/bpf_probe.h）完成的。\n它们\u003cstrong\u003e\u003cmark\u003e将内核函数的参数们转成 u64 数组，这样 BPF 程序通过 R1=ctx 指针就能消费了\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这个 \u003ca href=\"https://lwn.net/ml/netdev/20191107054644.1285697-4-ast@kernel.org/\"\u003epatch set\u003c/a\u003e\n所做的工作与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__bpf_trace_##call()\u003c/code\u003e static trampolines 类似，但通过\u003cstrong\u003e\u003cmark\u003e动态方式，支持任何内核函数\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e内核有 ~22k global 内核函数\u003c/mark\u003e\u003c/strong\u003e，能够在进入函数时（at function entry）\u003cstrong\u003e\u003cmark\u003e通过 nop 来 attach\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e函数参数和类型在 BTF 中有描述\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ebtf_distill_func_proto()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 从\n  BTF 中提取有用信息，转换成“函数模型”（function model），然后架构相关的\n  trampoline generators 就能用这些信息来生成汇编代码，将内核函数参数转成 u64 数组。\u003c/p\u003e\n\n    \u003cp\u003e例如，内核函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth_type_trans()\u003c/code\u003e 有两个指针，它们会被转成 u64 然后存储到生\n  成的 trampoline 的栈中；指向这个栈空间的指针会放到 R1 传给 BPF 程序。\u003c/p\u003e\n\n    \u003cp\u003e在 x86-64 架构上，这种 generated trampoline 将会占用 16 字节栈空间，并将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%rdi\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%rsi\u003c/code\u003e 存储到栈上。\n  校验器会保证 BPF 程序只能以 read-only 方式访问到两个 u64 参数。此外，校验器\n  还能精确识别出指针的类型，不允许在 BPF 程序内将其转换（typecast）成其他类型。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"fentryfexit-相比-kprobekretprobe-的优势\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efentry/fexit\u003c/code\u003e 相比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekprobe/kretprobe\u003c/code\u003e 的优势\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e性能更好\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e数据中心中的一些真实 tracing 场景显示，\n 某些关键的内核函数（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcp_retransmit_skb\u003c/code\u003e）有 2 个甚至更多永远活跃的 kprobes，\n 其他一些函数同时有 kprobe and kretprobe。\u003c/p\u003e\n\n    \u003cp\u003e所以，\u003cstrong\u003e\u003cmark\u003e最大化\u003c/mark\u003e\u003c/strong\u003e内核代码和 BPF 程序的\u003cstrong\u003e\u003cmark\u003e执行速度\u003c/mark\u003e\u003c/strong\u003e就非常有必要。因此\n 在每个新程序 attach 时或者 detach 时，BPF trampoline 都会重新生成，以保证最高性能。\n （另外在设计上，从 trampoline detach BPF 程序不会失败。）\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e能拿到的信息更多\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003efentry BPF 程序能拿到内核\u003cstrong\u003e\u003cmark\u003e函数参数\u003c/mark\u003e\u003c/strong\u003e， 而\u003c/li\u003e\n      \u003cli\u003efexit BPF 程序除了能拿到函数参数，还能拿到\u003cstrong\u003e\u003cmark\u003e函数返回值\u003c/mark\u003e\u003c/strong\u003e；而  kretprobe 只能拿到返回结果。\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003ekprobe BPF 程序通常将函数参数记录到一个 map 中，然后 kretprobe 从 map 中\n 拿出参数，并和返回值一起做一些分析处理。fexit BPF 程序加速了这个典型的使用场景。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e可用性更好\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e和普通 C 程序一样，\u003cstrong\u003e\u003cmark\u003e直接对指针参数解引用\u003c/mark\u003e\u003c/strong\u003e，\n 不再需要各种繁琐的 probe read helpers 了。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e限制：fentry/fexit BPF 程序需要更高的内核版本（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e5.5+\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）才能支持。\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/bpf-ringbuf-zh/\"\u003e\u003cspan\u003e« [译] BPF ring buffer：使用场景、核心设计及程序示例（2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/k8s-reliability-list-data-zh/\"\u003e\u003cspan\u003eK8s 集群稳定性：LIST 请求源码分析、性能评估与大规模基础服务部署调优 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-05-02T00:00:00Z",
  "Author": "Arthur Chiao"
}