{
  "Source": "arthurchiao.art",
  "Title": "[译] 基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现（Tailscale, 2021）",
  "Link": "https://arthurchiao.art/blog/rbac-as-it-meant-to-be-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现（Tailscale, 2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-09-14 | Last Update 2021-09-14\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2021 年的一篇英文博客：\n\u003ca href=\"https://tailscale.com/blog/rbac-like-it-was-meant-to-be/\"\u003eRBAC like it was meant to be\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e很多系统（例如 \u003cstrong\u003e\u003cmark\u003eKubernetes\u003c/mark\u003e\u003c/strong\u003e、AWS）都在使用某种形式的 RBAC 做权限/访问控制。\u003c/p\u003e\n\n\u003cp\u003e本文基于 access control 的发展历史，从设计层面分析了\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eDAC -\u0026gt; MAC -\u0026gt; RBAC -\u0026gt; ABAC\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e的演进历程及各模型的优缺点、适用场景等，\n然后从实际需求出发，一步步地设计出一个实用、简洁、真正符合 RBAC 理念的访问控制系统。\u003c/p\u003e\n\n\u003cp\u003e作为对比，如果想看看表达能力更强（但也更复杂）的 RBAC/ABAC 系统是什么样子，可以研究一下\n\u003ca href=\"https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html\"\u003eAWS 的访问控制模型\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-从-dac-到-mac\" id=\"markdown-toc-1-从-dac-到-mac\"\u003e1 从 DAC 到 MAC\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-dac自主访问控制各文件-owner-自主设置文件权限\" id=\"markdown-toc-11-dac自主访问控制各文件-owner-自主设置文件权限\"\u003e1.1 DAC（自主访问控制）：各文件 owner 自主设置文件权限\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#设计\" id=\"markdown-toc-设计\"\u003e设计\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#使用场景普通用户的文件权限控制\" id=\"markdown-toc-使用场景普通用户的文件权限控制\"\u003e使用场景：普通用户的文件权限控制\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-mac强制访问控制强制由专门的-admin-设置文件权限\" id=\"markdown-toc-12-mac强制访问控制强制由专门的-admin-设置文件权限\"\u003e1.2 MAC（强制访问控制）：（强制由）专门的 admin 设置文件权限\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#设计dac-基础上引入专门的-admin-角色\" id=\"markdown-toc-设计dac-基础上引入专门的-admin-角色\"\u003e设计：DAC 基础上引入专门的 admin 角色\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#例子tcpudp-端口号\" id=\"markdown-toc-例子tcpudp-端口号\"\u003e例子：TCP/UDP 端口号\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#适用场景文档系统访问控制\" id=\"markdown-toc-适用场景文档系统访问控制\"\u003e适用场景：文档/系统访问控制\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-mac-之双因素登录two-factor-login-as-mac\" id=\"markdown-toc-13-mac-之双因素登录two-factor-login-as-mac\"\u003e1.3 MAC 之双因素登录（two-factor login as MAC）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-图片分享dacmac-模型比较\" id=\"markdown-toc-14-图片分享dacmac-模型比较\"\u003e1.4 图片分享：DAC/MAC 模型比较\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-mac-概念限制太多又好像没什么限制\" id=\"markdown-toc-15-mac-概念限制太多又好像没什么限制\"\u003e1.5 MAC 概念：限制太多，又好像没什么限制\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-第一次尝试基于-rbacabac\" id=\"markdown-toc-2-第一次尝试基于-rbacabac\"\u003e2 第一次尝试：基于 RBAC/ABAC\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-rbac基于角色的访问控制\" id=\"markdown-toc-21-rbac基于角色的访问控制\"\u003e2.1 RBAC（基于角色的访问控制）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-abac基于属性的访问控制\" id=\"markdown-toc-22-abac基于属性的访问控制\"\u003e2.2 ABAC（基于属性的访问控制）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-也许你从未用过真正的-rbac\" id=\"markdown-toc-23-也许你从未用过真正的-rbac\"\u003e2.3 也许你从未用过真正的 RBAC\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#windows-文件安全模型每个文件一个-acl\" id=\"markdown-toc-windows-文件安全模型每个文件一个-acl\"\u003eWindows 文件安全模型：每个文件一个 ACL\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#控制谁能访问哪个文件\" id=\"markdown-toc-控制谁能访问哪个文件\"\u003e控制谁能访问哪个文件\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-存在的问题acl-太多到处重复批量修改麻烦\" id=\"markdown-toc-24-存在的问题acl-太多到处重复批量修改麻烦\"\u003e2.4 存在的问题：ACL 太多，到处重复，批量修改麻烦\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-第二次尝试每个-acl-对应一个用户组\" id=\"markdown-toc-3-第二次尝试每个-acl-对应一个用户组\"\u003e3 第二次尝试：每个 ACL 对应一个用户组\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-仍以-windows-文件系统为例\" id=\"markdown-toc-31-仍以-windows-文件系统为例\"\u003e3.1 仍以 Windows 文件系统为例\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-存在的问题\" id=\"markdown-toc-32-存在的问题\"\u003e3.2 存在的问题\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-第三次尝试重拾被忽视的概念object-tags\" id=\"markdown-toc-4-第三次尝试重拾被忽视的概念object-tags\"\u003e4 第三次尝试：重拾被忽视的概念：object tags\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-根据-user-type-而非-file-type-创建-user-group\" id=\"markdown-toc-41-根据-user-type-而非-file-type-创建-user-group\"\u003e4.1 根据 user type 而非 file type 创建 user group\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-roles-去扁平化增强表达力将-acl-定义为一组策略规则\" id=\"markdown-toc-42-roles-去扁平化增强表达力将-acl-定义为一组策略规则\"\u003e4.2 Roles 去扁平化，增强表达力：将 ACL 定义为一组策略规则\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-关于策略规则的进一步解释\" id=\"markdown-toc-43-关于策略规则的进一步解释\"\u003e4.3 关于策略规则的进一步解释\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-其他特性\" id=\"markdown-toc-44-其他特性\"\u003e4.4 其他特性\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#45-mac-归来\" id=\"markdown-toc-45-mac-归来\"\u003e4.5 MAC 归来\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#46-例子api-访问控制\" id=\"markdown-toc-46-例子api-访问控制\"\u003e4.6 例子：API 访问控制\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-职责分离\" id=\"markdown-toc-5-职责分离\"\u003e5 职责分离\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-根据-policy-rules-和-user-groups-自动生成访问权限\" id=\"markdown-toc-51-根据-policy-rules-和-user-groups-自动生成访问权限\"\u003e5.1 根据 policy rules 和 user groups 自动生成访问权限\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-tags-和-roles-各自的适用场景\" id=\"markdown-toc-52-tags-和-roles-各自的适用场景\"\u003e5.2 Tags 和 roles 各自的适用场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-小结\" id=\"markdown-toc-53-小结\"\u003e5.3 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-结束语\" id=\"markdown-toc-6-结束语\"\u003e6 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#附录译者注tailscale-的安全策略模型\" id=\"markdown-toc-附录译者注tailscale-的安全策略模型\"\u003e附录（译者注）：Tailscale 的安全策略模型\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e大部分人都听说过\u003cstrong\u003e基于角色的访问控制\u003c/strong\u003e（role-based access control, RBAC）以及它\n的后继演进版\u003cstrong\u003e基于属性的访问控制\u003c/strong\u003e（attribute-based access control, ABAC），\n但我们经常\u003cstrong\u003e\u003cmark\u003e遗忘或不懂得欣赏其中的伟大思想\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e大部分如今\u003cstrong\u003e\u003cmark\u003e常见的 RBAC 系统都经过了某种程度的简化\u003c/mark\u003e\u003c/strong\u003e，因此比最初的设计要弱一些。\n而本文想要说明，只要\u003cstrong\u003e\u003cmark\u003e回到 RBAC 最初的设计\u003c/mark\u003e\u003c/strong\u003e，我们就能构建一个\n\u003ca href=\"https://tailscale.com/kb/1018/acls/\"\u003e真正的 RBAC/ABAC 安全模型\u003c/a\u003e\n，它比你能见到的那些系统更\u003cstrong\u003e\u003cmark\u003e简单而强大\u003c/mark\u003e\u003c/strong\u003e，而且不管网络规模大还是小，它都能适用。\u003c/p\u003e\n\n\u003cp\u003e客户经常跟我们反馈说，他们如何震惊于如下事实：在 Tailscale 平台上，\n\u003cstrong\u003e\u003cmark\u003e只用如此少的规则就能表达他们的安全策略\u003c/mark\u003e\u003c/strong\u003e。这并非偶然！\n但在解释为什么之前，我们先来回顾一些历史。\u003c/p\u003e\n\n\u003ch1 id=\"1-从-dac-到-mac\"\u003e1 从 DAC 到 MAC\u003c/h1\u003e\n\n\u003cp\u003eRBAC/ABAC 的概念和术语都源自几十年前的\u003cstrong\u003e\u003cmark\u003e美国军方\u003c/mark\u003e\u003c/strong\u003e。\n\u003ca href=\"https://www.researchgate.net/publication/24164143_Role-Based_Access_Controls\"\u003eRole-Based Access Controls (Ferraiolo and Kuhn, 1992)\u003c/a\u003e\n是一篇很好的介绍。下面来看一下它们的一些演进过程。\u003c/p\u003e\n\n\u003ch2 id=\"11-dac自主访问控制各文件-owner-自主设置文件权限\"\u003e1.1 DAC（自主访问控制）：各文件 owner 自主设置文件权限\u003c/h2\u003e\n\n\u003cp\u003e最早出现的是 DAC（Discretionary Access Control），直到\u003cstrong\u003e\u003cmark\u003e今天仍然很常见\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"设计\"\u003e设计\u003c/h3\u003e\n\n\u003cp\u003e如下图所示，在 DAC 中 \u003cstrong\u003e\u003cmark\u003eobject owner\u003c/mark\u003e\u003c/strong\u003e 有权\u003cstrong\u003e\u003cmark\u003e设置该 object 的访问权限\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_01.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e DAC：通过授予 individuals/groups 以 read/write/execute 权限，\nobject (file) 的创建者能完全控制该 object 的内容和权限。\u003c/p\u003e\n\n\u003cp\u003e例如，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e在 Unix 系统中，设置 file permission\u003c/mark\u003e\u003c/strong\u003e（“模式”，这也是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003echmod\u003c/code\u003e change mode 的来历）\n  就能授予别人 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e读/写/执行\u003c/code\u003e 这个文件的权限。\u003c/li\u003e\n  \u003cli\u003e在 Google Doc 中，点击 share 按钮能授予权限。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"使用场景普通用户的文件权限控制\"\u003e使用场景：普通用户的文件权限控制\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e军方\u003c/mark\u003e\u003c/strong\u003e不怎么喜欢 DAC，因为这种方式中，\u003cstrong\u003e\u003cmark\u003e合规性很难保证，机密文件很容易被恶意 reshare 出去\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e但在\u003cstrong\u003e\u003cmark\u003e普通用户\u003c/mark\u003e\u003c/strong\u003e场景中，这种方式还是很常用也很合理的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"12-mac强制访问控制强制由专门的-admin-设置文件权限\"\u003e1.2 MAC（强制访问控制）：（强制由）专门的 admin 设置文件权限\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：不要把 MAC (mandatory access control) 与网络术语 “MAC address” 中的 MAC\n(media access address) 搞混了，二者没有任何关系，只是碰巧缩写相同。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"设计dac-基础上引入专门的-admin-角色\"\u003e设计：DAC 基础上引入专门的 admin 角色\u003c/h3\u003e\n\n\u003cp\u003eMAC (Mandatory access control) \u003cstrong\u003e\u003cmark\u003e对 DAC 做了增强\u003c/mark\u003e\u003c/strong\u003e。如下图所示，\n由 \u003cstrong\u003e\u003cmark\u003eadministrator\u003c/mark\u003e\u003c/strong\u003e（管理员）或 \u003cstrong\u003e\u003cmark\u003eadministrative rule\u003c/mark\u003e\u003c/strong\u003e（管理员级别的规则）\n来\u003cstrong\u003e\u003cmark\u003e定义 rules\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_02.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e MAC：文件 owner 只能设置一个文件 type，这个 type 包含了哪些\u003cmark\u003e权限是由 admin 或 policy 设置的\u003c/mark\u003e。\n用户能编辑文件内容，但无法修改文件权限。\u003c/p\u003e\n\n\u003cp\u003e因此在 MAC 模型中，\u003cstrong\u003e\u003cmark\u003e一个人做某些事情的\n能力是无法再分享给其他人\u003c/mark\u003e\u003c/strong\u003e的，从而避免了文件被 reshare 的问题。\u003c/p\u003e\n\n\u003ch3 id=\"例子tcpudp-端口号\"\u003e例子：TCP/UDP 端口号\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eMAC 很难解释\u003c/mark\u003e\u003c/strong\u003e，因为在实际中很少看到它，甚至看到了之后，你都不觉得它是“访问控制”。\u003c/p\u003e\n\n\u003cp\u003eWikipedia 给了一个很好的例子：TCP 或 UDP 端口号。当你占用了一个 local port 之后（假设没设置\n\u003ca href=\"https://man7.org/linux/man-pages/man7/socket.7.html\"\u003eSO_REUSEADDR\u003c/a\u003e），\n这台机器上的其他任何人就都无法再用这个端口号了 —— 不管他们是什么级别的特权用户。\n这里，\u003cstrong\u003e\u003cmark\u003e端口范围不可重叠这一条件，就是强制性的\u003c/mark\u003e\u003c/strong\u003e（mandatory）。\u003c/p\u003e\n\n\u003ch3 id=\"适用场景文档系统访问控制\"\u003e适用场景：文档/系统访问控制\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://apenwarr.ca/log/20101213\"\u003e之前关于 file locking\u003c/a\u003e 的文章中，我讨论了\nadvisory locks 和 mandatory locks 之间的区别：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eadvisory lock：\u003cstrong\u003e\u003cmark\u003e其他 apps 可以安全地读\u003c/mark\u003e\u003c/strong\u003e这个文件；\u003c/li\u003e\n  \u003cli\u003emandatory lock：按照规则，其他\u003cstrong\u003e\u003cmark\u003e不允许 apps 读任何内容\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可以看出，MAC 适用于对\u003cstrong\u003e\u003cmark\u003e文档或系统的访问控制\u003c/mark\u003e\u003c/strong\u003e，这就不难理解为什么\n军方对 MAC —— 至少在理论上 —— 如此兴奋了。理想场景：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个带锁的房间，门口有警卫站岗，\u003c/li\u003e\n  \u003cli\u003e出示门禁卡能进入这个房间，\u003c/li\u003e\n  \u003cli\u003e但警卫\u003cstrong\u003e\u003cmark\u003e禁止携带相机进入房间\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在这种场景下，你自己有权限查看房间内的文档，但无法将其分享给其他人。\u003c/p\u003e\n\n\u003cp\u003e这个例子给我们的一个启示是：\u003cstrong\u003e\u003cmark\u003e数字系统中，MAC 在理论要比在实际中简单\u003c/mark\u003e\u003c/strong\u003e\n（easier in theory than in practice）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个功能完整的（full-on）MAC 系统是很难真正实现的。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eDigital restrictions management\u003c/mark\u003e\u003c/strong\u003e (DRM，数字限制管理) 是 MAC 的\n一种，在这种模型中，文件的\u003cstrong\u003e\u003cmark\u003e接收方无法再将文件分享给别人\u003c/mark\u003e\u003c/strong\u003e —— 每个\nBitTorrent 用户都能体会到这种方式是如何奏效的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"13-mac-之双因素登录two-factor-login-as-mac\"\u003e1.3 MAC 之双因素登录（two-factor login as MAC）\u003c/h2\u003e\n\n\u003cp\u003e大家可能没意识到，另一种 MAC 是 multi-factor authentication (\u003cstrong\u003e\u003cmark\u003eMFA or 2FA\u003c/mark\u003e\u003c/strong\u003e):\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_03.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e 2FA as MAC：密码可以共享，但硬件 token 不能。\u003cmark\u003e密码是 DAC，而硬件 token 是 MAC\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e用 MFA 能允许特定的人登录一台计算机或服务，如果这个人不是管理员（admin），那他\n自己能登录，但将无法进一步将计算机共享给其他人，将密码告诉他们也不行。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e这种 login 是强制性的\u003c/mark\u003e\u003c/strong\u003e（mandatory，单有密码不行，还必须有硬件 token 才能登录）。\n在这个模型中，假设了第二因素（the second factor，即硬件 token）是不可分享的。\u003c/p\u003e\n\n\u003ch2 id=\"14-图片分享dacmac-模型比较\"\u003e1.4 图片分享：DAC/MAC 模型比较\u003c/h2\u003e\n\n\u003cp\u003e另一个例子是分享图片。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e在某些服务中，任何有正确 secret URL 的人都能访问给定的图片/消息/文件，并且\n\u003cstrong\u003e\u003cmark\u003e任何有这个 URL 的人都能继续分享它，这是 DAC 模式\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e在另一些服务中，单有这个 URL 还不行，必须要\u003cstrong\u003e\u003cmark\u003e登录有权限查看这个文件的账号之后\u003c/mark\u003e\u003c/strong\u003e，\n才能 reshare：\u003cstrong\u003e\u003cmark\u003e这 MAC 模式\u003c/mark\u003e\u003c/strong\u003e。虽然某些人能通过特定的 URL 访问\n这个文件，但 reshre 这个 URL 并不能让其他人看到这个文件。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e当然，如果一个人能下载这个文件，然后发送副本给别人，那结果还是泄露了这个文件\n。这也是为什么一些人认为 secret URL 的安全性在数学上与 MAC 是等价的，因为现在\n分享 URL 已经和分享文件一样难了。但二者有一个区别：\n你可以关闭一个 URL 的共享，但无法追回一个已经发送出去的文件副本。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"15-mac-概念限制太多又好像没什么限制\"\u003e1.5 MAC 概念：限制太多，又好像没什么限制\u003c/h2\u003e\n\n\u003cp\u003e历史上，军方中的 MAC 是围绕\n\u003ca href=\"https://en.wikipedia.org/wiki/Multilevel_security\"\u003emulti-level security\u003c/a\u003e\n构建的，这里的\u003cstrong\u003e\u003cmark\u003e设计思想\u003c/mark\u003e\u003c/strong\u003e是：\n\u003cstrong\u003e\u003cmark\u003e并非只有 admin 和 non-admin 两种用户，实际上有很多层的访问\u003c/mark\u003e\u003c/strong\u003e。\n他们最初将其设想为同心圆（“最高机密许可”、“机密许可” 等等），但最后证明\n表达力太弱（too unexpressive）。\u003c/p\u003e\n\n\u003cp\u003e如今的访问控制更像是\u003cstrong\u003e\u003cmark\u003e独立的 flags 或 subgroups\u003c/mark\u003e\u003c/strong\u003e。例如，\n\u003ca href=\"https://en.wikipedia.org/wiki/Security-Enhanced_Linux\"\u003eSELinux\u003c/a\u003e\n提供了对\u003cstrong\u003e\u003cmark\u003e每个进程内的每个权限\u003c/mark\u003e\u003c/strong\u003e的细粒度控制，而传统 Unix/Linux\n上只有 root 和常规用户权限的区分。但最终证明 SELinux 这套东西是\u003cstrong\u003e\u003cmark\u003e噩梦般的复杂\u003c/mark\u003e\u003c/strong\u003e，\n难以真正实用 —— 除非你在 \u003cstrong\u003e\u003cmark\u003eNSA\u003c/mark\u003e\u003c/strong\u003e（发明 SELinux 的机构）工作，但即使\n你在 NSA 也不一定会用。\u003c/p\u003e\n\n\u003cp\u003e最终来说，MAC 的概念证明是\u003cstrong\u003e\u003cmark\u003e过于限制又过于模糊\u003c/mark\u003e\u003c/strong\u003e（both too restrictive and too vague）。\n当人们谈论 MAC 时，我们很难搞清楚他们到底指的是什么，唯一知道是：这东西\n\u003cstrong\u003e\u003cmark\u003e用起来非常让人抓狂\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"2-第一次尝试基于-rbacabac\"\u003e2 第一次尝试：基于 RBAC/ABAC\u003c/h1\u003e\n\n\u003ch2 id=\"21-rbac基于角色的访问控制\"\u003e2.1 RBAC（基于角色的访问控制）\u003c/h2\u003e\n\n\u003cp\u003eRBAC 是 \u003cstrong\u003e\u003cmark\u003eMAC 的一个子集\u003c/mark\u003e\u003c/strong\u003e，它是一种特殊类型的 MAC，更加具体，因此\n在讨论及使用上会更加方便。\u003c/p\u003e\n\n\u003cp\u003eRBAC \u003cstrong\u003e\u003cmark\u003e与常见的 users/groups 模型类似\u003c/mark\u003e\u003c/strong\u003e。在 RBAC 中，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eadmin\u003c/mark\u003e\u003c/strong\u003e 将某些 user 放到一个 group，然后\u003c/li\u003e\n  \u003cli\u003e可以指定将\u003cstrong\u003e\u003cmark\u003e某些资源\u003c/mark\u003e\u003c/strong\u003e（文件、计算机等）共享给\u003cstrong\u003e\u003cmark\u003e某个 group（role）\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e系统确保只有指定的 role 能访问指定的资源；\u003c/li\u003e\n  \u003cli\u003e文件的接收方没有 reshare 权限 —— 除非拷贝一份，否则是无法 reshare 的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"22-abac基于属性的访问控制\"\u003e2.2 ABAC（基于属性的访问控制）\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.researchgate.net/publication/273393378_Attribute-Based_Access_Control\"\u003eAttribute-based access control (Hu, Kuhn, Ferraiolo, 2015)\u003c/a\u003e 是\u003cstrong\u003e\u003cmark\u003e对 RBAC 的改进，加了一些细节\u003c/mark\u003e\u003c/strong\u003e（属性，Attributes）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e属性\u003c/mark\u003e\u003c/strong\u003e可以是位置、客户端设备平台、认证类型、用户的 http cookies 等。\u003c/li\u003e\n  \u003cli\u003e当系统判断是否授予某个用户对某资源的访问权限时，ABAC 系统\n\u003cstrong\u003e\u003cmark\u003e除了检查他们的 RBAC role（group）\u003c/mark\u003e\u003c/strong\u003e，还会检查\u003cstrong\u003e\u003cmark\u003e这个人携带的各种属性\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果你遇到过下面这种情况 —— 登录某个服务时弹出额外的\u003cstrong\u003e\u003cmark\u003e图片识别认证\u003c/mark\u003e\u003c/strong\u003e\n\u003ca href=\"https://www.google.com/recaptcha/about/\"\u003ereCAPTCHA\u003c/a\u003e，\n而你旁边的朋友登录时却不用 —— 就\u003cstrong\u003e\u003cmark\u003e说明你遇到了 ABAC\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eABAC 很有用\u003c/mark\u003e\u003c/strong\u003e，因为这些额外的属性能给我们带来很多有用信息，尤其\n是对于那些连接到互联网的、攻击矢量特别多的系统。但在概念上，ABAC 与 RBAC 类似，只是稍微向前演进了一点。\n\u003cstrong\u003e\u003cmark\u003e属性的解析和认证\u003c/mark\u003e\u003c/strong\u003e工作是\u003cstrong\u003e\u003cmark\u003e中心式的\u003c/mark\u003e\u003c/strong\u003e，大部分都实现\n在各家的 \u003cstrong\u003e\u003cmark\u003eidentity provider\u003c/mark\u003e\u003c/strong\u003e 中。有鉴于此，接下来我们的讨论重点扔将放在 RBAC。\u003c/p\u003e\n\n\u003ch2 id=\"23-也许你从未用过真正的-rbac\"\u003e2.3 也许你从未用过真正的 RBAC\u003c/h2\u003e\n\n\u003cp\u003eRBAC 与前面提到的 users/groups 模型类似。接下来看一个具体的文件系统安全模型，例如 Windows。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里也可以拿 Unix 作为例子，但经典 Unix 文件安全与常见的安全模型不同，\n它只支持单个 owner、单个 group，以及 self/group/other 文件模式。\n如今 Linux 也支持 \u003ca href=\"https://www.usenix.org/legacy/publications/library/proceedings/usenix03/tech/freenix03/full_papers/gruenbacher/gruenbacher_html/main.html\"\u003efacls\u003c/a\u003e，\n这算是 RBAC，但\u003cstrong\u003e\u003cmark\u003e没人知道怎么用\u003c/mark\u003e\u003c/strong\u003e，因此这个也不算数。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"windows-文件安全模型每个文件一个-acl\"\u003eWindows 文件安全模型：每个文件一个 ACL\u003c/h3\u003e\n\n\u003cp\u003e在 Windows 中，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e每个文件\u003c/mark\u003e\u003c/strong\u003e（或目录）都有一个 \u003cstrong\u003e\u003cmark\u003eusers 和 groups 列表\u003c/mark\u003e\u003c/strong\u003e，以及\u003c/li\u003e\n  \u003cli\u003e每个\u003cstrong\u003e\u003cmark\u003e列表中的成员可以对这个文件做什么操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这是一种访问控制列表（access control list，ACL）。\u003cstrong\u003e\u003cmark\u003eowner 设置 ACL，操作系\n统执行 ACL。这是 MAC，对吧？\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e对的 —— 大部分情况下。想一下，任何有文件读权限的人，都可以拷贝一份，然后在副本上\n设置权限，因此这是\u003cstrong\u003e\u003cmark\u003e某种形式的 DAC\u003c/mark\u003e\u003c/strong\u003e，或者说在执行上充满漏洞的 MAC。\n但\u003cstrong\u003e\u003cmark\u003e在真实文件上\u003c/mark\u003e\u003c/strong\u003e（而非 API 上）\u003cstrong\u003e\u003cmark\u003e执行 MAC 非常难\u003c/mark\u003e\u003c/strong\u003e。\n我们将这个难题留给军方，现在把关注点放在 \u003cstrong\u003e\u003cmark\u003eACL 语义\u003c/mark\u003e\u003c/strong\u003e上。\u003c/p\u003e\n\n\u003cp\u003e在一个 Windows filesystem ACL 中，有如下概念：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eUser\u003c/mark\u003e\u003c/strong\u003e：在这个文件上执行操作的用户。在经典 RBAC 术语中，称为 \u003cstrong\u003e\u003cmark\u003esubject\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eGroup 或 Role\u003c/mark\u003e\u003c/strong\u003e：由管理员定义的一组 user。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eFile\u003c/mark\u003e\u003c/strong\u003e：需要做访问控制的资源（\u003cstrong\u003e\u003cmark\u003eresource\u003c/mark\u003e\u003c/strong\u003e）。也称为 \u003cstrong\u003e\u003cmark\u003eobject\u003c/mark\u003e\u003c/strong\u003e。subject 对 object 进行操作。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003ePermission 或 Entitlement\u003c/mark\u003e\u003c/strong\u003e： 一条 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esubject-action-object\u003c/code\u003e（用户-动作-目标文件）\u003cstrong\u003e\u003cmark\u003e规则\u003c/mark\u003e\u003c/strong\u003e。\n  有时会说某个 subject \u003cstrong\u003e\u003cmark\u003e有\u003c/mark\u003e\u003c/strong\u003e一条 entitlement，或者说某个 object \u003cstrong\u003e\u003cmark\u003e允许\u003c/mark\u003e\u003c/strong\u003e某个\n  permission，这两种表达方式本质上是一样的，只是从不同的角度描述。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eACL\u003c/mark\u003e\u003c/strong\u003e：一个 \u003cstrong\u003e\u003cmark\u003eentitlements 列表\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"控制谁能访问哪个文件\"\u003e控制谁能访问哪个文件\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e每个文件都有一个 ACL\u003c/mark\u003e\u003c/strong\u003e（permission 列表）。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003e每个文件都有一个 ACL。该 ACL 可能从文件所在子目录的 ACL中继承某些 entry，也\n可能不会，这些对我们目前的讨论来说不重要。\u003c/li\u003e\n    \u003cli\u003eACL 相同的文件，它们的 ACL 可能在磁盘上是分别存储的，这些是实现细节，我们这里\n也不关心。\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e如果想\u003cstrong\u003e\u003cmark\u003e控制谁能访问这些文件\u003c/mark\u003e\u003c/strong\u003e，可通过以下任一种方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e找到 ACL 对应的 groups/roles，在其中添加或删除 user（称为修改 group/role 的 membership）；或者，\u003c/li\u003e\n  \u003cli\u003e直接修改 ACL，添加或删除 permissions。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果想\u003cstrong\u003e\u003cmark\u003e一次修改一组文件的 ACL\u003c/mark\u003e\u003c/strong\u003e，可以\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e修改 group/role membership（简单），或者\u003c/li\u003e\n  \u003cli\u003e找到所有相关文件，逐个修改对应的 ACL（慢且易出错）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_04.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e文件多了之后，逐个修改 ACL 就不切实际了。\u003c/p\u003e\n\n\u003ch2 id=\"24-存在的问题acl-太多到处重复批量修改麻烦\"\u003e2.4 存在的问题：ACL 太多，到处重复，批量修改麻烦\u003c/h2\u003e\n\n\u003cp\u003e最后一点，也是访问控制开始出现漏洞的地方。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e几乎所有系统，不管是不是 RBAC，都支持\u003cstrong\u003e\u003cmark\u003e寻找文件系统中的 objects，然后修改它们的 ACL\u003c/mark\u003e\u003c/strong\u003e，\n但配套的 object 管理系统可能做的很差。\u003c/li\u003e\n  \u003cli\u003e在分布式系统中，这些 objects 可能分散在世界各地，放在各种不同的存储系统中，而\n它们的共同之处就是\u003cstrong\u003e\u003cmark\u003e都依赖你的 identity 系统\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e如果某天发现一个 permission 给错了，就必须找到这个 permission 的所有副本并解\n决之，否则就遗留了一个安全问题。但如果 objects 管理系统做得比较糟糕，这里做起\n来就会很麻烦。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"3-第二次尝试每个-acl-对应一个用户组\"\u003e3 第二次尝试：每个 ACL 对应一个用户组\u003c/h1\u003e\n\n\u003cp\u003e被以上问题折磨多次之后，你可能会尝试一些新东西：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e将尽量多的信息从 ACL（分散在各处）中移出\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e将尽量多的东西移入 user groups（集中式存储，而且能审计）\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"31-仍以-windows-文件系统为例\"\u003e3.1 仍以 Windows 文件系统为例\u003c/h2\u003e\n\n\u003cp\u003e仍然以 Windows 文件系统为例，如下图所示，你可能会创建两个 group \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-readers\u003c/code\u003e\n和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-writers\u003c/code\u003e：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_05.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e将尽量多的东西从 ACL 中移出，将尽量多的东西移入 groups 中。\u003c/p\u003e\n\n\u003cp\u003e效果是：所有 reports 文件能被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-readers\u003c/code\u003e 组内的用户读，能被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-writers\u003c/code\u003e\n组内的用户写。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e经验不足的人在这里会犯的一个错误是：只创建一个名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport\u003c/code\u003e 的 group，然后给\n予这个 group read/write 权限。通常来说，\u003cstrong\u003e\u003cmark\u003e需要文件读权限的用户，要比需要\n写权限的用户更多\u003c/mark\u003e\u003c/strong\u003e。甚至在某些情况下，writer 和 reader 用户之间都\n\u003cstrong\u003e\u003cmark\u003e没有重叠\u003c/mark\u003e\u003c/strong\u003e（例如审计日志场景）。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种 per-file-type group（每种文件访问类型一个单独的 user group）结构是\n\u003cstrong\u003e\u003cmark\u003eDon\u0026#39;t Repeat Yourself\u003c/mark\u003e\u003c/strong\u003e (DRY) 原则在实际应用中的一个例子：\n上一节 RBAC/ABAC 模型中，根源问题是\u003cstrong\u003e\u003cmark\u003e每个文件都有自己的 ACL\u003c/mark\u003e\u003c/strong\u003e，\n这些 ACL 到处重复，因此这里\u003cstrong\u003e\u003cmark\u003e提取出了重复部分放到了一个公共的地方\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"32-存在的问题\"\u003e3.2 存在的问题\u003c/h2\u003e\n\n\u003cp\u003e这个改进比较合理，尤其是在有很多 objects 的大公司中工作良好，但也有几个问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e现在\u003cstrong\u003e\u003cmark\u003e需要有某种形式的 IAM admin 访问控制\u003c/mark\u003e\u003c/strong\u003e，也就是对\n\u003cstrong\u003e\u003cmark\u003e用户组的增删查改\u003c/mark\u003e\u003c/strong\u003e做控制。\u003c/p\u003e\n\n    \u003cp\u003e上一节的 RBAC/ABAC 模型中无需这种功能，因为它直接修改文件的 ACL。IAM admin\n 管控带来的一个新问题是：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e如果管控太松，会导致很多人都有 IAM 的访问权限，存在风险；\u003c/li\u003e\n      \u003cli\u003e如果管控太紧，大部分都无权修改 group membership，又会使得这种模型的好处大打折扣。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eEnd users 仍然能四处游荡，在需要时\u003cstrong\u003e\u003cmark\u003e能修改每个 report 文件的 ACL\u003c/mark\u003e\u003c/strong\u003e\n  （“Alice 真的真的需要查看这个文件”），破坏了你精心设计的系统 —— 而你自己都\n  \u003cstrong\u003e\u003cmark\u003e无法察觉\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e现在需要\u003cstrong\u003e\u003cmark\u003e为每个 ACL 组合创建一个 user group\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e最后会发现，公司的每个工程师都属于 975 个 group，每个 group 都需要定义\n read/write 两种类型。你必须 review 每个 group 的 membership。这种方式虽然比\n 老的 ad-hoc 文件权限方式审计性要好，但也好不了太多。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"4-第三次尝试重拾被忽视的概念object-tags\"\u003e4 第三次尝试：重拾被忽视的概念：object tags\u003c/h1\u003e\n\n\u003cp\u003e至此，我们决定\u003cstrong\u003e\u003cmark\u003e放弃文件系统的 ACL\u003c/mark\u003e\u003c/strong\u003e，原因是：文件系统已经设计成这样了，\n基于文件系统的 ACL 我们只能做到目前这样。你大概率无法解决现有的文件系统和操作系统中这些问题。\u003c/p\u003e\n\n\u003cp\u003e但接下来的好消息是：\n\u003ca href=\"/blog/modules-monoliths-and-microservices/\"\u003e如今的服务都运行在无状态容器内\u003c/a\u003e，\n大部分 VM \u003ca href=\"https://www.qubes-os.org/doc/vm-sudo/\"\u003e都无需密码就能执行 sudo\u003c/a\u003e，\n因此我们不用再对文件系统进行控制，而是对 web 应用和 NoSQL 的 API 做控制。\n这也许不是巧合，因为\u003cstrong\u003e\u003cmark\u003e对细粒度分布式安全\u003c/mark\u003e\u003c/strong\u003e（fine-grained distributed security）\n\u003cstrong\u003e\u003cmark\u003e的需求一直在增长，而文件系统还停留在 1980s 年代\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e那么，接下来就开始设计我们想要的 permission 系统！\u003c/p\u003e\n\n\u003ch2 id=\"41-根据-user-type-而非-file-type-创建-user-group\"\u003e4.1 根据 user type 而非 file type 创建 user group\u003c/h2\u003e\n\n\u003cp\u003e首先，注意到，前面两节的文件系统 ACL 方案其实\u003cstrong\u003e\u003cmark\u003e并不是真正意义上基于角色的（role-based）访问控制\u003c/mark\u003e\u003c/strong\u003e。\n为什么呢？它把 user groups 作为 roles —— 这没有问题 —— 但如果你有 975 个像 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-readers\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport-writers\u003c/code\u003e\n一样的 group，那这些就不算不上是真正的 \u003cstrong\u003e\u003cmark\u003ehuman-relevant roles\u003c/mark\u003e\u003c/strong\u003e。HR 并不知道\n你的新员工是否应该是 report-reader，这个决策太底层了（low-level）。\u003c/p\u003e\n\n\u003cp\u003e因此我们得到的第一个启示就是：应该根据\u003cstrong\u003e\u003cmark\u003e用户类型\u003c/mark\u003e\u003c/strong\u003e（user types）而非\n\u003cstrong\u003e\u003cmark\u003e文件类型\u003c/mark\u003e\u003c/strong\u003e（file types）来创建 user groups。如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_06.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"42-roles-去扁平化增强表达力将-acl-定义为一组策略规则\"\u003e4.2 Roles 去扁平化，增强表达力：将 ACL 定义为一组策略规则\u003c/h2\u003e\n\n\u003cp\u003e以上 group-per-user-type 格式还是\u003cstrong\u003e\u003cmark\u003e过于扁平\u003c/mark\u003e\u003c/strong\u003e了（too flat）：它已经丢失了\n“\u003cstrong\u003e\u003cmark\u003e为什么\u003c/mark\u003e\u003c/strong\u003e某人会在某 group” 的语义含义（semantic meaning）。如果\nBob 离职了，我们必须修改所有可能包含 Bob 的 groups。这虽然已经比跟踪每个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereport\u003c/code\u003e 类型的文件\n然后 double check 它的 permissions 是否还正确要好，但仍然\u003cstrong\u003e\u003cmark\u003e很容易出错\n\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e我们假设有如下角色（roles）：Accounting（审计人员）、DevOps（研发运维人员）、Engineering（工程师）、Executive（高管）。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_07.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e然后我们就可以\u003cstrong\u003e\u003cmark\u003e将 ACL 定义为一组策略规则\u003c/mark\u003e\u003c/strong\u003e（a set of policy rules）：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_08.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这种模型与最初的 flat 模型\u003cstrong\u003e\u003cmark\u003e表达的东西是一样的\u003c/mark\u003e\u003c/strong\u003e，但通过增加一个间接层（indirection），\n它表达了我们\u003cstrong\u003e\u003cmark\u003e一直想表达（而没有表达出来）的东西\u003c/mark\u003e\u003c/strong\u003e。有了这个模型，\n接下来就可以讨论：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e由 HR 部门定义的 human-relevant roles，以及\u003c/li\u003e\n  \u003cli\u003e由安全部门定义的标签（tags），以及\u003c/li\u003e\n  \u003cli\u003e二者是如何联系到一起的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"43-关于策略规则的进一步解释\"\u003e4.3 关于策略规则的进一步解释\u003c/h2\u003e\n\n\u003cp\u003e我们正在设计一个新的权限系统。\u003c/p\u003e\n\n\u003cp\u003e现在，先将刚才设计的\u003cstrong\u003e\u003cmark\u003e能转换成的 roles 的 policy rules\u003c/mark\u003e\u003c/strong\u003e 进一步表示为：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_09.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e有了这样一种格式的描述之后，当我们需要满足 SOC2 合规性要求时，只需将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edatabase\u003c/code\u003e\n的 readers 改为，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[DevOps, Prod]\u003c/code\u003e，这将会立即锁定所有数据库相关的对象。\u003c/p\u003e\n\n\u003ch2 id=\"44-其他特性\"\u003e4.4 其他特性\u003c/h2\u003e\n\n\u003cp\u003e最后，我们来加两个其他特性：\u003c/p\u003e\n\n\u003cp\u003e首先，与文件只有一种 type（读或写）不同，一个对象可以有零或\u003cstrong\u003e\u003cmark\u003e多个 tags\u003c/mark\u003e\u003c/strong\u003e。\n因此，与数据库相关的源文件可以打上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edatabase\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esourcefile\u003c/code\u003e 两个 tag，对应地，\n它获得的是两种 \u003cstrong\u003e\u003cmark\u003epermission set 的交集\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_10.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e第二，\u003cstrong\u003e\u003cmark\u003e只有 tag 的 owner 有权限增加或删除\u003c/mark\u003e\u003c/strong\u003e任何对象上的\u003cstrong\u003e\u003cmark\u003e该 tag\u003c/mark\u003e\u003c/strong\u003e。\n例如在下图中，只有 Engineering 可以在某个对象打 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esourcefile\u003c/code\u003e tag。\n这能够避免意外将对象分享给应该完全隔离的人，或在不期望的地方错误地应用已有策略。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_13.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"45-mac-归来\"\u003e4.5 MAC 归来\u003c/h2\u003e\n\n\u003cp\u003e至此，我们看到了 \u003cstrong\u003e\u003cmark\u003eMAC 回归的身影\u003c/mark\u003e\u003c/strong\u003e。但是，现在它，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e不需要一个针对 security policy 的 global admin access control。\u003c/li\u003e\n  \u003cli\u003e每个 tag owner 能直接对他们的 objects 进行授权，但他们能授予哪些访问权限，是\n由整体上的安全策略（the overall security policy，即 \u003cstrong\u003e\u003cmark\u003eroles\u003c/mark\u003e\u003c/strong\u003e）控制的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"46-例子api-访问控制\"\u003e4.6 例子：API 访问控制\u003c/h2\u003e\n\n\u003cp\u003e在类似 Tailscale 的网络系统中，我们其实并不会用 readers和 writers 这样的文件系统术语。\n我们\u003cstrong\u003e\u003cmark\u003e定义node 和 port，以及允许谁连接到这些 node 和 port\u003c/mark\u003e\u003c/strong\u003e。\n例如可能会如下规则：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_11.png\" width=\"55%\" height=\"55%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e有了以上规则，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eEngineering 中的任何人都可以启动一个\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev-api-server\u003c/code\u003e node，\u003c/li\u003e\n  \u003cli\u003e该 node 能接受从任何 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev-api-client\u003c/code\u003e node 来的非加密连接（TLS 太难了！开发环境就放行非加密连接吧），但反之并不亦然。\u003c/li\u003e\n  \u003cli\u003e只有 Ops 中的人能启动 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprod-api-server\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprod-api-client\u003c/code\u003e nodes，它们只处理 https 流量，拒绝非加密 http。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e下面是效果：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_12.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里注意：我们递归地用一些 tag names 来定义\npermissions for other tags。Ops 中的某个人可以启动一个 node 并打上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprod-api-server\u003c/code\u003e tag，\n这个 node 就会获得与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprod-api-server\u003c/code\u003e 而不是 Ops 相关联的 permissions 和 entitlements（\n这很重要，因为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprod-api-server\u003c/code\u003e instance 无法像 Ops 一样启动更多 instance）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://tailscale.com/kb/1018/acls/\"\u003e真实的 Tailscale ACLs 和 tags\u003c/a\u003e 与此很像，但更加具体。\u003c/p\u003e\n\n\u003ch1 id=\"5-职责分离\"\u003e5 职责分离\u003c/h1\u003e\n\n\u003ch2 id=\"51-根据-policy-rules-和-user-groups-自动生成访问权限\"\u003e5.1 根据 policy rules 和 user groups 自动生成访问权限\u003c/h2\u003e\n\n\u003cp\u003e如果试图将这个模型反向适配到 legacy-style filesystem permissions，\n我们就会发现 \u003cstrong\u003e\u003cmark\u003eroles 和 tag definitions 其实是相同类型的对象\u003c/mark\u003e\u003c/strong\u003e（都是 lists of users），\n二者之间通过一个（“安全策略”）算法进行单向转换：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/rbac-as-it-meant-to-be/RBAC_14.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e将 roles 扩展成 tags，然后适配到传统文件系统的权限控制模型。\u003c/p\u003e\n\n\u003cp\u003e你可以类似地写一些脚本，将给定的 roles 和 group membership rules\n\u003cstrong\u003e\u003cmark\u003e自动生成你的 /etc/group 内容\u003c/mark\u003e\u003c/strong\u003e，我知道有些公司就是这样做的。\n这不是标准方式，维护很痛苦，而且通常用定时任务来批量执行，这意味着当修改\n一个 tag 或 group membership 之后，必须要等上一段时间才能生效。但本质上来说，这\n种方式是能工作的，而且比典型的操作系统默认值要好多了。\u003c/p\u003e\n\n\u003ch2 id=\"52-tags-和-roles-各自的适用场景\"\u003e5.2 Tags 和 roles 各自的适用场景\u003c/h2\u003e\n\n\u003cp\u003e前面说 \u003cstrong\u003e\u003cmark\u003etags（用于 ACL 目的）\u003c/mark\u003e\u003c/strong\u003e和 \u003cstrong\u003e\u003cmark\u003eroles（用于 user management 目的）\u003c/mark\u003e\u003c/strong\u003e\n都是“用户列表”（lists of users），其实这种说法有误导性。二者用于不同场景。最重要的是，\n\u003cstrong\u003e\u003cmark\u003e不同的人\u003c/mark\u003e\u003c/strong\u003e负责系统的不同部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eRoles\u003c/mark\u003e\u003c/strong\u003e 描述的是 \u003cstrong\u003e\u003cmark\u003eidentity system (authentication) 中的人\u003c/mark\u003e\u003c/strong\u003e。\n  Roles \u003cstrong\u003e\u003cmark\u003e变化很少\u003c/mark\u003e\u003c/strong\u003e，通常在入职、晋升或转岗时由 HR 部门设置。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eObject types (tags)\u003c/mark\u003e\u003c/strong\u003e 由 \u003cstrong\u003e\u003cmark\u003eobject owner\u003c/mark\u003e\u003c/strong\u003e 在这个 object 创建时设置。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eEntitlements\u003c/mark\u003e\u003c/strong\u003e 用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(Role, Tag)\u003c/code\u003e 描述，由简单的程序（安全策略）来定义，由\u003cstrong\u003e\u003cmark\u003e安全团队设置\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在这个架构中，这三种类型的人只有很少时候才需要交互：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eAccounting 部门中的财报 writer 并不关心谁是 Executive，也不关心 Executive 是否\n  有权查看或编辑财报。他们只需知道\u003cstrong\u003e\u003cmark\u003e要给 report 文件打上 financial-report tag\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e安全团队并不关心哪个文件打了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efinancial-report\u003c/code\u003e（讨论一般情况下），也不关心谁是Executive。\n  他们需要的是\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e能读、写对应的安全策略，以及确保策略生效\u003c/mark\u003e\u003c/strong\u003e：\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e确保 financial-report tag 只能被 Accounting 部门打\u003c/mark\u003e\u003c/strong\u003e，对应的文件只能被\nExecutives 和 Accounting 读（read only）。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eHR 团队不知道也不关心文件或安全策略，他们只关心\u003cstrong\u003e\u003cmark\u003e这周招了一个 Accounting role 的人\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"53-小结\"\u003e5.3 小结\u003c/h2\u003e\n\n\u003cp\u003e回到 network permissions 场景：在大公司中，正确地围绕这些概念设计你的模型，就能避免大量摩擦。\u003c/p\u003e\n\n\u003cp\u003e我们在实际工作中可能会遇到如下类似的例子：工程师创建了一个新的开发（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev\u003c/code\u003e）集群后，\n\u003cstrong\u003e\u003cmark\u003e还要去提个工单，让安全团队给他开防火墙端口\u003c/mark\u003e\u003c/strong\u003e。为什么会这样？\n因为在这些公司中，安全团队维护的策略并不规范，没有收敛到以上模型：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e允许 Engineers 运行 dev API servers，接受来自本机或 dev API clients 的 incoming 连接 —— 这个没问题；\u003c/li\u003e\n  \u003cli\u003e通常不允许创建 outgoing connections —— 这个也没问题；\u003c/li\u003e\n  \u003cli\u003e噢对了，Carol 的 dev API server 需要主动访问数据库服务器，只能开单独策略了 —— 问题来了。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果安全团队能将这些安全规则固化成代码片段，结果将会更好，能确保它们在整张\n网络上得到一致执行。\u003c/p\u003e\n\n\u003ch1 id=\"6-结束语\"\u003e6 结束语\u003c/h1\u003e\n\n\u003cp\u003e以上提到的所有东西，users、roles、object types、policies \u003cstrong\u003e\u003cmark\u003e都不是新概念\u003c/mark\u003e\u003c/strong\u003e，\n它们都来自 1992 提出 RBAC 模型的那篇论文，只是术语稍有不同。\u003c/p\u003e\n\n\u003cp\u003e如今，几乎每个人都在使用 users、groups、ACLs 了。一些人认为，我们实现的东西已经\n是 RBAC，但事实告诉我们：并不是。\u003cstrong\u003e\u003cmark\u003e还没有谁实现过完整的 RBAC 模型\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个人都是一个 User (subject)。\u003c/li\u003e\n  \u003cli\u003e每个 user 都有一个或多个 Roles。\u003c/li\u003e\n  \u003cli\u003e每个 object 都有一个或多个 Tags。\u003c/li\u003e\n  \u003cli\u003e一条 “security policy” \u003cstrong\u003e\u003cmark\u003e定义一个\u003c/mark\u003e\u003c/strong\u003e将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(Role, Tag)\u003c/code\u003e 转换成 Entitlements 的\n\u003cstrong\u003e\u003cmark\u003e公式\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e一个执行层（enforcement layer）负责 enforce security policy，并为每个 object 生成有效 entitlements 列表（ACL）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e但另一方面，实现这样一个模型比实现常见的 users+groups 模型\u003cstrong\u003e\u003cmark\u003e并没有复杂多少\n\u003c/mark\u003e\u003c/strong\u003e —— 只要\u003cstrong\u003e\u003cmark\u003e从一开始就将其放到系统的核心\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e最后回到文初，这就是为什么 \u003ca href=\"https://tailscale.com/kb/1018/acls/\"\u003eTailscale RBAC、ABAC 和 security policy 不同寻常的地方\u003c/a\u003e。\nTailscale objects 都是设备和端口（devices and ports），而非文件，但所有概念在使用上与在文件系统中是一样的。\n最终的产品在\u003cstrong\u003e\u003cmark\u003e理念设计上很简洁\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eDevice 或 container 的 owner 可以设置 tag；\u003c/li\u003e\n  \u003cli\u003e安全团队决定谁 own 哪些 tag、每个 tag 关联了哪些 permissions、tags 会授权给哪些 roles；\u003c/li\u003e\n  \u003cli\u003eIdentity/HR 团队决定哪些 users 应该属于哪些 roles。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"附录译者注tailscale-的安全策略模型\"\u003e附录（译者注）：Tailscale 的安全策略模型\u003c/h1\u003e\n\n\u003cp\u003eACL rules 格式：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"s2\"\u003e\u0026#34;action\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;accept\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;users\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e[\u003c/span\u003e list-of-sources... \u003cspan class=\"o\"\u003e]\u003c/span\u003e,      \u003cspan class=\"c\"\u003e# 广义的访问来源，相当于 RBAC 模型中的 users/subjects\u003c/span\u003e\n  \u003cspan class=\"s2\"\u003e\u0026#34;ports\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e[\u003c/span\u003e list-of-destinations... \u003cspan class=\"o\"\u003e]\u003c/span\u003e, \u003cspan class=\"c\"\u003e# 广义的访问目标，相当于 RBAC 模型中的 objects/resources\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上 json 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eusers\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eports\u003c/code\u003e 都是为了兼容公司的历史 API，它们实际上包含的\n范围要比字面意思大的多，具体见 \u003ca href=\"https://tailscale.com/kb/1018/acls/\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cgroupv2-zh/\"\u003e\u003cspan\u003e« [译] Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/everything-about-pki-zh/\"\u003e\u003cspan\u003e[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-09-14T00:00:00Z",
  "Author": "Arthur Chiao"
}