{
  "Source": "arthurchiao.art",
  "Title": "[译] strace 是如何工作的（2016）",
  "Link": "https://arthurchiao.art/blog/how-does-strace-work-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] strace 是如何工作的（2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-02-02 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2016 年的一篇英文博客 \u003ca href=\"https://blog.packagecloud.io/eng/2016/02/29/how-does-strace-work/\"\u003eHow Does strace Work\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e阅读本文之前，强烈建议先阅读\n\u003ca href=\"/blog/system-call-definitive-guide-zh/\"\u003eLinux 系统调用权威指南\u003c/a\u003e，\n其中包含了本文所需的部分预备知识。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003ch3 id=\"太长不读tldr\"\u003e太长不读（TL;DR）\u003c/h3\u003e\n\n\u003cp\u003e本文介绍 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 内部是如何工作的。我们会研究 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 工具内部所依赖的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用，对其 API 层及内部实现进行分析，以弄清楚 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e\n是如何获取被跟踪进程的（系统调用相关的）详细信息的。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#太长不读tldr\" id=\"markdown-toc-太长不读tldr\"\u003e太长不读（TL;DR）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-ptrace-是什么\" id=\"markdown-toc-1-ptrace-是什么\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 是什么\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-ptrace-系统调用\" id=\"markdown-toc-11-ptrace-系统调用\"\u003e1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace()\u003c/code\u003e 系统调用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-使用场景\" id=\"markdown-toc-12-使用场景\"\u003e1.2 使用场景\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-ptrace-跟踪过程\" id=\"markdown-toc-2-ptrace-跟踪过程\"\u003e2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 跟踪过程\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-内核实现\" id=\"markdown-toc-3-内核实现\"\u003e3 内核实现\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-ptrace_attach-代码流程\" id=\"markdown-toc-31-ptrace_attach-代码流程\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 代码流程\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#311-ptrace_attach\" id=\"markdown-toc-311-ptrace_attach\"\u003e3.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_attach\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#312-从-ptrace_attach-返回到-ptrace\" id=\"markdown-toc-312-从-ptrace_attach-返回到-ptrace\"\u003e3.1.2 从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_attach\u003c/code\u003e 返回到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-ptrace_syscall-代码流程\" id=\"markdown-toc-32-ptrace_syscall-代码流程\"\u003e3.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 代码流程\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-进入系统调用\" id=\"markdown-toc-4-进入系统调用\"\u003e4 进入系统调用\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-_tif_work_syscall_entry\" id=\"markdown-toc-41-_tif_work_syscall_entry\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_WORK_SYSCALL_ENTRY\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-tracesys\" id=\"markdown-toc-42-tracesys\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracesys\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-ptrace_report_syscall\" id=\"markdown-toc-43-ptrace_report_syscall\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_report_syscall\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-sigtrap\" id=\"markdown-toc-44-sigtrap\"\u003e4.4 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#45-syscall_trace_leave\" id=\"markdown-toc-45-syscall_trace_leave\"\u003e4.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall_trace_leave\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-结束语\" id=\"markdown-toc-5-结束语\"\u003e5 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-我们的相关文章\" id=\"markdown-toc-6-我们的相关文章\"\u003e6 我们的相关文章\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-ptrace-是什么\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 是什么\u003c/h1\u003e\n\n\u003ch2 id=\"11-ptrace-系统调用\"\u003e1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace()\u003c/code\u003e 系统调用\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace()\u003c/code\u003e 是一个系统调用，可以用来：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e跟踪（其他）系统调用\u003c/li\u003e\n  \u003cli\u003e读写内存和寄存器\u003c/li\u003e\n  \u003cli\u003e控制（manipulate）被跟踪进程的信号传送（signal delivery）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eptrace \u003ca href=\"http://man7.org/linux/man-pages/man2/ptrace.2.html\"\u003eman page\u003c/a\u003e 可以查看更多信息。\u003c/p\u003e\n\n\u003ch2 id=\"12-使用场景\"\u003e1.2 使用场景\u003c/h2\u003e\n\n\u003cp\u003e以上可以看出，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 在跟踪和控制程序方面非常有用。\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estrace\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e、\n\u003cstrong\u003e\u003cmark\u003eGDB 等工具内部都用到了它\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"2-ptrace-跟踪过程\"\u003e2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 跟踪过程\u003c/h1\u003e\n\n\u003cp\u003e本文将使用如下两个术语：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003etracer：跟踪（其他程序的）程序\u003c/li\u003e\n  \u003cli\u003etracee：被跟踪程序\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003etracer 跟踪 tracee 的过程：\u003c/p\u003e\n\n\u003cp\u003e首先，\u003cstrong\u003eattach 到 tracee 进程\u003c/strong\u003e：调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e，带 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 及 tracee 进程 ID 作为参数。\u003c/p\u003e\n\n\u003cp\u003e之后当 \u003cstrong\u003etracee 运行到系统调用函数时就会被内核暂停\u003c/strong\u003e；对 tracer 来说，就像\ntracee 收到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号而停下来一样。接下来 tracer 就可以查看这次系统调\n用的参数，打印相关的信息。\u003c/p\u003e\n\n\u003cp\u003e然后，\u003cstrong\u003e恢复 tracee 执行\u003c/strong\u003e：再次调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e，带 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 和 tracee 进程 ID。\ntracee 会继续运行，进入到系统调用；在退出系统调用之前，再次被内核暂停。\u003c/p\u003e\n\n\u003cp\u003e以上\u003cstrong\u003e\u003cmark\u003e“暂停-采集-恢复执行”\u003c/mark\u003e\u003c/strong\u003e过程不断重复，tracer 就可以获取每次系统调用的信息，打印\n出参数、返回值、时间等等。\u003c/p\u003e\n\n\u003cp\u003e以上就是 ptrace 跟踪其他系统调用的大致过程，接下来看它在内核中具体是如何工作的。\u003c/p\u003e\n\n\u003ch1 id=\"3-内核实现\"\u003e3 内核实现\u003c/h1\u003e\n\n\u003cp\u003e内核的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用是一个很好的起点。接下来的代码会基于内核 3.13，并提供\ngithub 的代码连接。\u003c/p\u003e\n\n\u003cp\u003e整个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统的代码见\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L1036\"\u003ekernel/ptrace.c\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"31-ptrace_attach-代码流程\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 代码流程\u003c/h2\u003e\n\n\u003cp\u003e首先看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 干了什么事情。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L1055-L1064\"\u003e检查 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erequest\u003c/code\u003e 参数\u003c/a\u003e，然后调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_attach\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erequest\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ePTRACE_ATTACH\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003erequest\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ePTRACE_SEIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eptrace_attach\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003erequest\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n  \u003cspan class=\"cm\"\u003e/*\n   * Some architectures need to do book-keeping after\n   * a ptrace attach.\n   */\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eret\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003earch_ptrace_attach\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n  \u003cspan class=\"k\"\u003egoto\u003c/span\u003e \u003cspan class=\"n\"\u003eout_put_task_struct\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"311-ptrace_attach\"\u003e3.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_attach\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e这个\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L279\"\u003e函数\u003c/a\u003e做的事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e初始化一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflags\u003c/code\u003e 变量\u003c/li\u003e\n  \u003cli\u003e确保 tracee 不是内核线程\u003c/li\u003e\n  \u003cli\u003e确保 tracee 不是当前进程的一个线程\u003c/li\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__ptrace_may_access\u003c/code\u003e 做一些安全检查\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e然后，将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflags\u003c/code\u003e 赋值给 tracee 进程的内核结构体变量上（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task_struct\n*task\u003c/code\u003e），并\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L339\"\u003e停止\ntracee\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e在我们的例子中，这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflags\u003c/code\u003e 的值为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePT_PTRACED\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e函数结束后，执行回到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"312-从-ptrace_attach-返回到-ptrace\"\u003e3.1.2 从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_attach\u003c/code\u003e 返回到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e接下来，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 调用\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L1066\"\u003eptrace_check_attach\u003c/a\u003e\n来检查是否可以操作 tracee 了。\u003c/p\u003e\n\n\u003cp\u003e最后， ptrace 调用 CPU 相关的\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L1071\"\u003earch_ptrace\u003c/a\u003e\n函数。对于 x86 平台，这个函数在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earch/x86/kernel/ptrace.c\u003c/code\u003e\n中，见\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/ptrace.c#L821\"\u003e这里\u003c/a\u003e。如果你看完了代码里巨长的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eswitch\u003c/code\u003e 语句，会发现并没有对应 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 的 case，这说明这种 case 走的是\ndefault 分支。default 分支做的事情就是调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_request\u003c/code\u003e 函数，然后回到\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 代码。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L803\"\u003eptrace_request\u003c/a\u003e\n也没有对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 做特殊处理，接下来的代码就是一路返回到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\n系统调用，然后再从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 函数返回。\u003c/p\u003e\n\n\u003cp\u003e以上就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_ATTACH\u003c/code\u003e 的工作流程。接下来看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"32-ptrace_syscall-代码流程\"\u003e3.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 代码流程\u003c/h2\u003e\n\n\u003cp\u003e首先会调用\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L1066\"\u003eptrace_check_attach\u003c/a\u003e\n以确保可以对 tracee 进程进行操作。\u003c/p\u003e\n\n\u003cp\u003e接下来和 attach 部分类似，调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earch_ptrace\u003c/code\u003e\n函数，里面包含 CPU 相关的代码。同样的， \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earch_ptrace\u003c/code\u003e 也没有什么需要为\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 做的，直接调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_request\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e到目前为止，流程和 attach 过程都是类似的，但接下来就不一样了。在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L982-L984\"\u003eptrace_request\u003c/a\u003e\n中，针对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e，调用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_resume\u003c/code\u003e 函数。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L720\"\u003e该函数\u003c/a\u003e首先给\ntracee 的内核结构体变量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etask\u003c/code\u003e 设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTIF_SYSCALL_TRACE\u003c/code\u003e flag。\u003c/p\u003e\n\n\u003cp\u003e接下来检查几种可能的状态（因为其他函数可能也在调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_resume\u003c/code\u003e），最后\ntracee\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/ptrace.c#L751\"\u003e被唤醒\u003c/a\u003e，直到它遇到下一个系统调用。\u003c/p\u003e\n\n\u003ch1 id=\"4-进入系统调用\"\u003e4 进入系统调用\u003c/h1\u003e\n\n\u003cp\u003e到目前为止，我们已经通过设置内核结构体变量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task_struct *task\u003c/code\u003e 的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTIF_SYSCALL_TRACE\u003c/code\u003e 来使内核跟踪指定进程的系统调用。\u003c/p\u003e\n\n\u003cp\u003e那么：\u003cstrong\u003e设置的参数是何时被检查和使用的呢？\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e程序发起一个系统调用时，在系统调用执行之前，会执行一段 CPU 相关的内核代码。在\nx86 平台上，这段代码位于\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L593\"\u003earch/x86/kernel/entry_64.S\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"41-_tif_work_syscall_entry\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_WORK_SYSCALL_ENTRY\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e如果查看汇编函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem_call\u003c/code\u003e，会看到它会检查一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_WORK_SYSCALL_ENTRY\u003c/code\u003e flag：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"n\"\u003etestl\u003c/span\u003e \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"n\"\u003e_TIF_WORK_SYSCALL_ENTRY\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eTI_flags\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003eTHREAD_INFO\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eRIP\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eARGOFFSET\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ejnz\u003c/span\u003e \u003cspan class=\"n\"\u003etracesys\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果设置了这个 flag，执行会转到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracesys\u003c/code\u003e 函数。\u003c/p\u003e\n\n\u003cp\u003e这个 flag 的定义：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* work to do in syscall_trace_enter() */\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define _TIF_WORK_SYSCALL_ENTRY \\\n        (_TIF_SYSCALL_TRACE | _TIF_SYSCALL_EMU | _TIF_SYSCALL_AUDIT |   \\\n         _TIF_SECCOMP | _TIF_SINGLESTEP | _TIF_SYSCALL_TRACEPOINT |     \\\n         _TIF_NOHZ)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到这个 flag 其实就是多个 flag\n的组合，其中包括我们之前设置的那个：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_SYSCALL_TRACE\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e到这里就明白了，如果进程的内核结构体变量设置了\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_SYSCALL_TRACE\u003c/code\u003e，到这里就会检测到，然后执行转到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracesys\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"42-tracesys\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracesys\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L723\"\u003e代码\u003c/a\u003e会调用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall_trace_enter\u003c/code\u003e。这个函数定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earch/x86/kernel/ptrace.c\u003c/code\u003e，是 CPU\n相关的代码，可以查看\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/ptrace.c#L1457\"\u003e这里\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e代码如果检测到设置了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_TIF_SYSCALL_TRACE\u003c/code\u003e flag，就会调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracehook_report_syscall_entry\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003etest_thread_flag\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTIF_SYSCALL_TRACE\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e\n      \u003cspan class=\"n\"\u003etracehook_report_syscall_entry\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eregs\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1L\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracehook_report_syscall_entry\u003c/code\u003e 是一个静态内联函数，定义在\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003einclude/linux/tracehook.h\u003c/code\u003e，有很好的\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/include/linux/tracehook.h#L80-L103\"\u003e文档\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e它接下来又调用了 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/include/linux/tracehook.h#L58\"\u003eptrace_report_syscall\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"43-ptrace_report_syscall\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_report_syscall\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e这个函数符合之前我们描述过的：当 tracee 进入系统调用时生成一个 SIGTRAP 信号：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eptrace_notify\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eSIGTRAP\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003eptrace\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003ePT_TRACESYSGOOD\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x80\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_notify\u003c/code\u003e 定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/kernel/signal.c#L1975\"\u003ekernel/signal.c\u003c/a\u003e。\n它会进一步调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_do_notify\u003c/code\u003e，后者会初始化一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esiginfo_t info\u003c/code\u003e 变量，交给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_stop\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"44-sigtrap\"\u003e4.4 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003etracee 一旦收到 SIGTRAP 信号就停止执行，tracer 会收到通知说有信号待处理。接下来\ntracer 就可以查看 tracee 的状态，打印寄存器的值、时间戳等等信息。\u003c/p\u003e\n\n\u003cp\u003e当你用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 工具跟踪进程时，屏幕上的输出就是这么来的。\u003c/p\u003e\n\n\u003ch2 id=\"45-syscall_trace_leave\"\u003e4.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall_trace_leave\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e退出系统调用的过程与此类似：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L796\"\u003e汇编代码\u003c/a\u003e 调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall_trace_leave\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/ptrace.c#L1507\"\u003e这个函数\u003c/a\u003e 调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etracehook_report_syscall_exit\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/include/linux/tracehook.h#L122\"\u003e继续调用\u003c/a\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace_report_syscall\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这就是 tracee 的系统调用完成时，tracer 如何获取返回值、时间戳等等信息以打印输出的。\u003c/p\u003e\n\n\u003ch1 id=\"5-结束语\"\u003e5 结束语\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\n系统调用对调试器、跟踪器和其他的从进程中提取信息的程序非常有用，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e\n主要就是基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 实现的。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\n内部略微有些复杂，因为执行过程在一些文件之间跳来跳去，但总体来说，实现还是挺简单直接的。\u003c/p\u003e\n\n\u003cp\u003e我建议你也看一看你最喜欢的调试器的源码，看它是如何基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\n来完成检查程序状态、修改寄存器和内存等工作的。\u003c/p\u003e\n\n\u003ch1 id=\"6-我们的相关文章\"\u003e6 我们的相关文章\u003c/h1\u003e\n\n\u003cp\u003e如果对本文感兴趣，那么你可能对我们的以下文章也感兴趣：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/system-call-definitive-guide-zh/\"\u003e(译) Linux 系统调用权威指南\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/how-does-ltrace-work-zh/\"\u003e(译) ltrace 是如何工作的\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/system-call-definitive-guide-zh/\"\u003e\u003cspan\u003e« [译] Linux 系统调用权威指南（2016）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/how-does-ltrace-work-zh/\"\u003e\u003cspan\u003e[译] ltrace 是如何工作的（2016） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-02-02T00:00:00Z",
  "Author": "Arthur Chiao"
}