{
  "Source": "arthurchiao.art",
  "Title": "[译] [论文] 可虚拟化第三代（计算机）架构的规范化条件（ACM, 1974）",
  "Link": "https://arthurchiao.art/blog/formal-requirements-for-virtualizable-arch-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] [论文] 可虚拟化第三代（计算机）架构的规范化条件（ACM, 1974）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-11-19 | Last Update 2021-11-19\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 1974 年关于\u003cstrong\u003e\u003cmark\u003e可虚拟化计算机架构\u003c/mark\u003e\u003c/strong\u003e（即能支持 VM）的经典\n\u003ca href=\"http://courses.cs.washington.edu/courses/cse548/08wi/papers/p412-popek.pdf\"\u003e论文\u003c/a\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ePopek, Gerald J., and Robert P. Goldberg.\n\u003cstrong\u003e\u003cmark\u003e\u0026#34;Formal requirements for virtualizable third generation architectures.\u0026#34;\u003c/mark\u003e\u003c/strong\u003e\nCommunications of the ACM 17.7\n(1974): 412-421.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e虽然距今已半个世纪，但这篇文章的一些核心思想仍未过时。特别是，它在最朴素的层面\n介绍了虚拟机是如何工作的（就像 \u003ca href=\"/blog/rfc1180-a-tcp-ip-tutorial-zh/\"\u003e\u003cmark\u003e(译) RFC 1180：朴素 TCP/IP 教程（1991）\u003c/mark\u003e\u003c/a\u003e\n在最朴素的层面介绍 TCP/IP 是如何工作的一样，虽然本文更晦涩一些），这些内容对理解虚拟化的底层原理有很大帮助。\u003c/p\u003e\n\n\u003cp\u003e第 1~4 代计算机架构的介绍可参考 \u003ca href=\"https://ukdiss.com/examples/first-generation-fourth-generation-computers.php\"\u003eEvolution of Computers from First Generation to Fourth Generation\u003c/a\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一代：1940 – 1958\u003c/li\u003e\n  \u003cli\u003e第二代：1958 – 1964\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e第三代：1964 ~ 1974，特点：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e使用集成电路取代晶体管\u003c/li\u003e\n      \u003cli\u003eHigh-level 编程语言\u003c/li\u003e\n      \u003cli\u003e磁质存储\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e第四代：1974 ~ 今\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-虚拟机概念virtual-machine-concepts\" id=\"markdown-toc-1-虚拟机概念virtual-machine-concepts\"\u003e1. 虚拟机概念（Virtual Machine Concepts）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-虚拟机vm和虚拟机监督器vmm\" id=\"markdown-toc-11-虚拟机vm和虚拟机监督器vmm\"\u003e1.1 虚拟机（VM）和虚拟机监督器（VMM）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-vmm-特点\" id=\"markdown-toc-12-vmm-特点\"\u003e1.2 VMM 特点\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#121-一致性程序在-vm-中执行与在真实机器上执行结果相同\" id=\"markdown-toc-121-一致性程序在-vm-中执行与在真实机器上执行结果相同\"\u003e1.2.1 一致性：程序在 VM 中执行与在真实机器上执行结果相同\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#122-高效性大部分-vm-指令直接在硬件上执行\" id=\"markdown-toc-122-高效性大部分-vm-指令直接在硬件上执行\"\u003e1.2.2 高效性：大部分 VM 指令直接在硬件上执行\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#123-完全控制系统资源\" id=\"markdown-toc-123-完全控制系统资源\"\u003e1.2.3 完全控制系统资源\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-虚拟机vm的定义\" id=\"markdown-toc-13-虚拟机vm的定义\"\u003e1.3 虚拟机（VM）的定义\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-一种第三代计算机模型a-model-of-third-generation-machines\" id=\"markdown-toc-2-一种第三代计算机模型a-model-of-third-generation-machines\"\u003e2. 一种第三代计算机模型（A Model of Third Generation Machines）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-计算机组成模块\" id=\"markdown-toc-21-计算机组成模块\"\u003e2.1 计算机组成模块\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#211-处理器supervisoruser-模式\" id=\"markdown-toc-211-处理器supervisoruser-模式\"\u003e2.1.1 处理器：supervisor/user 模式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#212-内存寻址重定位寄存器\" id=\"markdown-toc-212-内存寻址重定位寄存器\"\u003e2.1.2 内存寻址：重定位寄存器\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-指令集\" id=\"markdown-toc-22-指令集\"\u003e2.2 指令集\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-计算机状态表示\" id=\"markdown-toc-23-计算机状态表示\"\u003e2.3 计算机状态表示\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-四元组表示\" id=\"markdown-toc-231-四元组表示\"\u003e2.3.1 四元组表示\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-内存重定位vm-地址---物理地址过程\" id=\"markdown-toc-232-内存重定位vm-地址---物理地址过程\"\u003e2.3.2 内存重定位（VM 地址 -\u0026gt; 物理地址）过程\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#233-程序状态字psw\" id=\"markdown-toc-233-程序状态字psw\"\u003e2.3.3 程序状态字（PSW）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#234-状态的有限集合\" id=\"markdown-toc-234-状态的有限集合\"\u003e2.3.4 状态的有限集合\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-第三代计算机模型核心抽象原语保护简单内存分配\" id=\"markdown-toc-24-第三代计算机模型核心抽象原语保护简单内存分配\"\u003e2.4 第三代计算机模型（核心抽象）：原语保护+简单内存分配\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-traps\" id=\"markdown-toc-25-traps\"\u003e2.5 Traps\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#251-定义\" id=\"markdown-toc-251-定义\"\u003e2.5.1 定义\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#252-直观解释\" id=\"markdown-toc-252-直观解释\"\u003e2.5.2 直观解释\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#253-memory-trap\" id=\"markdown-toc-253-memory-trap\"\u003e2.5.3 Memory trap\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-指令行为instruction-behavior\" id=\"markdown-toc-3-指令行为instruction-behavior\"\u003e3. 指令行为（Instruction Behavior）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-特权指令privileged-instruction与特权指令-trap\" id=\"markdown-toc-31-特权指令privileged-instruction与特权指令-trap\"\u003e3.1 特权指令（privileged instruction）与特权指令 trap\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-敏感指令sensitive-instructions\" id=\"markdown-toc-32-敏感指令sensitive-instructions\"\u003e3.2 敏感指令（sensitive instructions）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#321-控制敏感control-sensitive指令\" id=\"markdown-toc-321-控制敏感control-sensitive指令\"\u003e3.2.1 控制敏感（control sensitive）指令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#322-重定位偏移算子-\" id=\"markdown-toc-322-重定位偏移算子-\"\u003e3.2.2 重定位偏移算子 ⊕\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#323-行为敏感behavior-sensitivity指令\" id=\"markdown-toc-323-行为敏感behavior-sensitivity指令\"\u003e3.2.3 行为敏感（behavior sensitivity）指令\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-virtual-machine-monitor-vmm\" id=\"markdown-toc-4-virtual-machine-monitor-vmm\"\u003e4. Virtual Machine Monitor (VMM)\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-模块组成\" id=\"markdown-toc-41-模块组成\"\u003e4.1 模块组成\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#411-第一类模块分发器dispatcherd\" id=\"markdown-toc-411-第一类模块分发器dispatcherd\"\u003e4.1.1 第一类模块：分发器（dispatcher，D）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#412-第二类模块分配器allocatora\" id=\"markdown-toc-412-第二类模块分配器allocatora\"\u003e4.1.2 第二类模块：分配器（allocator，A）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#413-第三类模块trap-对应的-interpreter-routine解释例程\" id=\"markdown-toc-413-第三类模块trap-对应的-interpreter-routine解释例程\"\u003e4.1.3 第三类模块：trap 对应的 interpreter routine（解释例程）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-控制程序cp的表示\" id=\"markdown-toc-42-控制程序cp的表示\"\u003e4.2 控制程序（CP）的表示\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-虚拟机的特性virtual-machine-properties\" id=\"markdown-toc-5-虚拟机的特性virtual-machine-properties\"\u003e5. 虚拟机的特性（Virtual Machine Properties）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-三大特性\" id=\"markdown-toc-51-三大特性\"\u003e5.1 三大特性\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#511-高效性efficiency\" id=\"markdown-toc-511-高效性efficiency\"\u003e5.1.1 高效性（efficiency）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#512-资源控制resource-control\" id=\"markdown-toc-512-资源控制resource-control\"\u003e5.1.2 资源控制（resource control）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#513-等价性equivalence\" id=\"markdown-toc-513-等价性equivalence\"\u003e5.1.3 等价性（equivalence）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-定理一主定理计算机支持-vmm-的充分条件\" id=\"markdown-toc-52-定理一主定理计算机支持-vmm-的充分条件\"\u003e5.2 定理一（主定理）：计算机支持 VMM 的充分条件\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-关于主定理的讨论discussion-of-theorem\" id=\"markdown-toc-6-关于主定理的讨论discussion-of-theorem\"\u003e6. 关于主定理的讨论（Discussion of Theorem）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-什么是常规第三代计算机\" id=\"markdown-toc-61-什么是常规第三代计算机\"\u003e6.1 什么是“常规第三代计算机”\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-状态集合-c-和同态映射\" id=\"markdown-toc-62-状态集合-c-和同态映射\"\u003e6.2 状态集合 C 和同态映射\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-虚拟机映射vm-map\" id=\"markdown-toc-63-虚拟机映射vm-map\"\u003e6.3 虚拟机映射（VM map）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-vm-map-示例\" id=\"markdown-toc-64-vm-map-示例\"\u003e6.4 VM map 示例\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#65-等价性equivalence意味着什么\" id=\"markdown-toc-65-等价性equivalence意味着什么\"\u003e6.5 等价性（equivalence）意味着什么\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#66-定理一的简要证明proof-sketch\" id=\"markdown-toc-66-定理一的简要证明proof-sketch\"\u003e6.6 定理一的简要证明（Proof Sketch）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#控制程序\" id=\"markdown-toc-控制程序\"\u003e控制程序\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#三个特性\" id=\"markdown-toc-三个特性\"\u003e三个特性\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#充分而非必要条件\" id=\"markdown-toc-充分而非必要条件\"\u003e充分而非必要条件\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-递归虚拟化recursive-virtualization\" id=\"markdown-toc-7-递归虚拟化recursive-virtualization\"\u003e7. 递归虚拟化（Recursive Virtualization）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-定理二递归虚拟化的充分条件\" id=\"markdown-toc-71-定理二递归虚拟化的充分条件\"\u003e7.1 定理二：递归虚拟化的充分条件\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-定理二的证明\" id=\"markdown-toc-72-定理二的证明\"\u003e7.2 定理二的证明\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-混合虚拟机hybrid-virtual-machines\" id=\"markdown-toc-8-混合虚拟机hybrid-virtual-machines\"\u003e8. 混合虚拟机（Hybrid Virtual Machines）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#81-hvm-定义更多指令通过软件解释执行\" id=\"markdown-toc-81-hvm-定义更多指令通过软件解释执行\"\u003e8.1 HVM 定义：更多指令通过软件解释执行\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#82-对敏感指令进一步分类\" id=\"markdown-toc-82-对敏感指令进一步分类\"\u003e8.2 对敏感指令进一步分类\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#user-sensitive\" id=\"markdown-toc-user-sensitive\"\u003euser sensitive\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#supervisor-sensitive\" id=\"markdown-toc-supervisor-sensitive\"\u003esupervisor sensitive\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#83-定理三\" id=\"markdown-toc-83-定理三\"\u003e8.3 定理三\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-总结\" id=\"markdown-toc-9-总结\"\u003e9. 总结\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#致谢\" id=\"markdown-toc-致谢\"\u003e致谢\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#附录\" id=\"markdown-toc-附录\"\u003e附录\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#references\" id=\"markdown-toc-references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e少数几种第三代计算机系统 —— 例如 IBM 360/67 的 CP-67 —— 已经实现了\u003cstrong\u003e\u003cmark\u003e虚拟机系统\u003c/mark\u003e\u003c/strong\u003e\n（virtual machine systems）。\n而经验研究指出：某些第三代计算机系统，例如 DEC PDP-10，是无法支持虚拟机系统的。\u003c/p\u003e\n\n\u003cp\u003e本文将提出一种泛第三代（third-generation-like）计算机系统，并用一些\n规范化技术（formal techniques）来推导出\u003cstrong\u003e\u003cmark\u003e这种架构支持虚拟机\u003c/mark\u003e\u003c/strong\u003e的充分条件。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e关键字/词\u003c/mark\u003e\u003c/strong\u003e: operating system, third\ngeneration architecture, sensitive instruction, formal\nrequirements, abstract model, proof, virtual machine,\nvirtual memory, hypervisor, virtual machine monitor\u003c/p\u003e\n\n\u003ch1 id=\"1-虚拟机概念virtual-machine-concepts\"\u003e1. 虚拟机概念（Virtual Machine Concepts）\u003c/h1\u003e\n\n\u003ch2 id=\"11-虚拟机vm和虚拟机监督器vmm\"\u003e1.1 虚拟机（VM）和虚拟机监督器（VMM）\u003c/h2\u003e\n\n\u003cp\u003e当前有很多关于“什么是虚拟机、应该如何构建虚拟机、硬件和操作系统将对构建虚拟机产\n生什么影响”的研究 [1, 6, 7, 9, 12]。\u003c/p\u003e\n\n\u003cp\u003e本文将通过对泛第三代机器的\u003cstrong\u003e\u003cmark\u003e计算机架构\u003c/mark\u003e\u003c/strong\u003e（computer architectures）\n的分析，得出一个简单的\u003cstrong\u003e\u003cmark\u003e判断一个架构是否支持虚拟机\u003c/mark\u003e\u003c/strong\u003e的条件。\n此外，这个条件也能用于新机器的设计（machine design）过程。\u003c/p\u003e\n\n\u003cp\u003e虚拟机（virtual machine）是以高效、隔离的方式对真实机器（real machine）的模拟（efficient, isolated duplicate）。\n我们通过\u003cstrong\u003e\u003cmark\u003e虚拟机监督程序\u003c/mark\u003e\u003c/strong\u003e（virtual machine monitor，VMM）来解释这些概念。\u003c/p\u003e\n\n\u003ch2 id=\"12-vmm-特点\"\u003e1.2 VMM 特点\u003c/h2\u003e\n\n\u003cp\u003e如图 1 所示。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/formal-requirements-for-virtualizable-arch/1.png\" width=\"30%\" height=\"30%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 1. VMM\u003c/p\u003e\n\n\u003cp\u003eVMM 作为一个软件有三个基本特点，下面分别介绍。\u003c/p\u003e\n\n\u003ch3 id=\"121-一致性程序在-vm-中执行与在真实机器上执行结果相同\"\u003e1.2.1 一致性：程序在 VM 中执行与在真实机器上执行结果相同\u003c/h3\u003e\n\n\u003cp\u003eVMM \u003cstrong\u003e\u003cmark\u003e提供了一个供程序运行的环境\u003c/mark\u003e\u003c/strong\u003e（即 VM），并且程序在 VM 中运行\n与在真实机器上运行并无二致（essentially identical）。可能的例外是：由于系统资源不足或\n时序依赖（timing dependencies）问题，程序\u003cstrong\u003e\u003cmark\u003e执行效果会略有不同\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e资源问题会出现是因为，例如，我们希望在定义中引入 \u003cstrong\u003e\u003cmark\u003eVMM 有分配多片内存（对应多个 VM）的能力\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eTiming 问题是因为众多软件之间存在干扰，而且在相同硬件上并发运行着多个虚拟机。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e一致的环境\u003c/mark\u003e\u003c/strong\u003e（identical environment）这一前提，使我们将\n\u003cstrong\u003e\u003cmark\u003etime-sharing 操作系统的常见行为排除在外\u003c/mark\u003e\u003c/strong\u003e，它们无法作为本文的 VMM。\u003c/p\u003e\n\n\u003ch3 id=\"122-高效性大部分-vm-指令直接在硬件上执行\"\u003e1.2.2 高效性：大部分 VM 指令直接在硬件上执行\u003c/h3\u003e\n\n\u003cp\u003eVMM 的第二个特点是效率（efficiency）。在这个环境下运行的软件，\n\u003cstrong\u003e\u003cmark\u003e最坏情况\u003c/mark\u003e\u003c/strong\u003e也就是\u003cstrong\u003e\u003cmark\u003e执行速度略微变慢\u003c/mark\u003e\u003c/strong\u003e；\n这就要求\u003cstrong\u003e\u003cmark\u003e虚拟处理器（virtual processor）的大部分指令要直接在真实处理器（real processor）上执行\u003c/mark\u003e\u003c/strong\u003e，\n而无须 VMM 的软件干预（software intervention）。\u003c/p\u003e\n\n\u003cp\u003e这一条件也直接将\u003cstrong\u003e\u003cmark\u003e传统模拟器（emulators）和纯软件解释器\u003c/mark\u003e\u003c/strong\u003e（complete\nsoftware interpreters，也称为 simulators）\u003cstrong\u003e\u003cmark\u003e排除在外\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"123-完全控制系统资源\"\u003e1.2.3 完全控制系统资源\u003c/h3\u003e\n\n\u003cp\u003e第三个特点是资源控制（resource control），将常见的\u003cstrong\u003e\u003cmark\u003e内存、外设\u003c/mark\u003e\u003c/strong\u003e等也算作资源，\n虽然严格来说它们并不是处理器活动（processor activity）。\u003c/p\u003e\n\n\u003cp\u003e如果满足以下条件，就说 VMM 对这些资源有完全控制权：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e在 VMM 创建的环境内运行的程序，\u003cstrong\u003e\u003cmark\u003e无法访问任何未显式分配给它的资源\u003c/mark\u003e\u003c/strong\u003e（resource not explicitly allocated to it），以及\u003c/li\u003e\n  \u003cli\u003e在某些条件下，\u003cstrong\u003e\u003cmark\u003eVMM 能重新获取对已分配出去的资源的控制权\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"13-虚拟机vm的定义\"\u003e1.3 虚拟机（VM）的定义\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eVMM 创建的环境，其实就是一台虚拟机\u003c/mark\u003e\u003c/strong\u003e。我们有意选取的这个定义，\n不仅反映了已经广泛接受的虚拟机概念，而且还为接下来的证明了提供一个合理的环境。\n在描述我们的机器模型（machine model）之前，有必要对这个这个定义做一些解释。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e我们定义的 VMM 不一定要是一个分时系统（time-sharing system），虽然它可能是。\u003c/li\u003e\n  \u003cli\u003e不管真实计算机上在执行什么活动，VM 中程序的执行效果要与在真实硬件上完全相同这一条件（identical effect），\n使得从保护虚拟机环境（virtual machine environment）的意义上来说，\u003cstrong\u003e\u003cmark\u003e隔离性（isolation）需要满足\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e执行效果完全相同这一要求也将\u003cstrong\u003e\u003cmark\u003e虚拟机\u003c/mark\u003e\u003c/strong\u003e（virtual machine）概念与\u003cstrong\u003e\u003cmark\u003e虚拟内存\u003c/mark\u003e\u003c/strong\u003e（virtual memory）从本质上区分开来。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e虚拟内存只是虚拟机的一个组成部分；分片和分页（segmentation and paging）等是具体的虚拟内存技术；\u003c/li\u003e\n      \u003cli\u003e虚拟机实际上还会有虚拟处理器（virtual processor），及其其他虚拟设备。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e接下来，在陈述和证明计算机能支持 VMM 的充分条件之前，我们先来给出\n泛第三代计算机的一个正式规范。\u003c/p\u003e\n\n\u003ch1 id=\"2-一种第三代计算机模型a-model-of-third-generation-machines\"\u003e2. 一种第三代计算机模型（A Model of Third Generation Machines）\u003c/h1\u003e\n\n\u003ch2 id=\"21-计算机组成模块\"\u003e2.1 计算机组成模块\u003c/h2\u003e\n\n\u003cp\u003e下图（原文忘了插图，下面从网上找了一张，译注）展示了一个常规第三代计算机模型的简化版，例如\nIBM 360、Honeywell 6000 或 DEC PDP-10，它们有\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个处理器，\u003c/li\u003e\n  \u003cli\u003e一个\u003cstrong\u003e\u003cmark\u003e线性\u003c/mark\u003e\u003c/strong\u003e、可均匀寻址的内存\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/formal-requirements-for-virtualizable-arch/3rd-gen-arch.jpg\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n  \u003cp align=\"center\"\u003e第三代计算机架构。Image credit \u003ca href=\"https://ukdiss.com/examples/first-generation-fourth-generation-computers.php\"\u003eUKDiss.com\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003e上图几个主要模块：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e寄存器：分为通用目的寄存器和浮点寄存器\u003c/li\u003e\n    \u003cli\u003e处理器：分为三个处理单元：\n      \u003cul\u003e\n        \u003cli\u003e定点算术单元\u003c/li\u003e\n        \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e十进制算术单元\u003c/mark\u003e\u003c/strong\u003e！—— 对，历史上（直到现在）并不是只有二进制处理器。\u003c/li\u003e\n        \u003cli\u003e浮点算术单元\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e内存及内存控制器\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e本文\u003cstrong\u003e\u003cmark\u003e假设不存在 I/O 指令和中断\u003c/mark\u003e\u003c/strong\u003e，但二者是可以作为扩展（extensions）加进来的。\n接下来我们：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e首先提出关于这种计算机行为的几个必备假设，\u003c/li\u003e\n  \u003cli\u003e然后描述它的\u003cstrong\u003e\u003cmark\u003e状态空间\u003c/mark\u003e\u003c/strong\u003e（state-space），并说明状态将可能发生哪些变化。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"211-处理器supervisoruser-模式\"\u003e2.1.1 处理器：supervisor/user 模式\u003c/h3\u003e\n\n\u003cp\u003e这里的处理器是\u003cstrong\u003e\u003cmark\u003e只有两种操作状态\u003c/mark\u003e\u003c/strong\u003e（operation mode）的常规处理器：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003esupervisor 模式：处理器可执行所有类型的指令。\u003c/li\u003e\n  \u003cli\u003euser 模式：处理器只能执行部分指令。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"212-内存寻址重定位寄存器\"\u003e2.1.2 内存寻址：重定位寄存器\u003c/h3\u003e\n\n\u003cp\u003e内存寻址是根据一个\u003cstrong\u003e\u003cmark\u003e重定位寄存器\u003c/mark\u003e\u003c/strong\u003e（relocation register）中的值做相对寻址的。\u003c/p\u003e\n\n\u003ch2 id=\"22-指令集\"\u003e2.2 指令集\u003c/h2\u003e\n\n\u003cp\u003e指令集包括了常见的算术、测试、分支、内存读写等指令。\u003c/p\u003e\n\n\u003cp\u003e需要强调的一点是：\u003cstrong\u003e\u003cmark\u003e基于这些指令\u003c/mark\u003e\u003c/strong\u003e就能够在任意 size/key/value 的 table\n上执行\u003cstrong\u003e\u003cmark\u003e查找操作\u003c/mark\u003e\u003c/strong\u003e，然后将查到的值存储到内存中的任意位置 ——\n也就是实现了 table 的\u003cstrong\u003e\u003cmark\u003e查询和复制\u003c/mark\u003e\u003c/strong\u003e特性【注释 1】。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注释 1：后文证明过程将用到这个特性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"23-计算机状态表示\"\u003e2.3 计算机状态表示\u003c/h2\u003e\n\n\u003ch3 id=\"231-四元组表示\"\u003e2.3.1 四元组表示\u003c/h3\u003e\n\n\u003cp\u003e这种计算机的状态能用一个 4-tuple 来表示：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e        S = \u0026lt;E, M, P, R\u0026gt;\n        |    |  |  |  |\n        |    |  |  |  +---- relocation-bounds Register : R=(l,b), see below explanations\n        |    |  |  +------- Program counter (PC)       : addr of the next instruction to be executed\n        |    |  +---------- Mode (processor mode)      : supervisor/user\n        |    +------------- Executable storage (memory): size: q\n        |\n        +---- State of the real machine\n\n\n        R = (l, b)   # Example: R=(0,q-1) corresponds to the entire physical memory\n        |    |  |\n        |    |  +--- Bound part: absolute size of the virtual memory\n        |    +------ reLocation part: an absolute address, started from 0\n        |\n        +---------- relocation-bounds Register\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eE\u003c/mark\u003e\u003c/strong\u003e: \u003cstrong\u003e\u003cmark\u003e可执行内存空间\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e传统的 word 或 byte 寻址内存，内存的大小用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eq\u003c/code\u003e 表示。\n \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE[i]\u003c/code\u003e 表示内存中第 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei\u003c/code\u003e 个单位处的值。\u003c/p\u003e\n\n    \u003cp\u003e如果对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0 \u0026lt;= i \u0026lt; q\u003c/code\u003e，都有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE[i] = E\u0026#39;[i]\u003c/code\u003e，那么就称 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE == E\u0026#39;\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eM\u003c/mark\u003e\u003c/strong\u003e: 处理器当前的工作模式，可以是：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es\u003c/code\u003e: supervisor mode\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu\u003c/code\u003e: user mode\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eP\u003c/mark\u003e\u003c/strong\u003e: 程序计数器\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eP 是相对于 R 的一个地址\u003c/mark\u003e\u003c/strong\u003e，作为在内存 E 中的索引（index），是\n \u003cstrong\u003e\u003cmark\u003e接下来将要执行的指令的地址\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e注意，状态 S 表示的是\u003cstrong\u003e\u003cmark\u003e真实计算机系统\u003c/mark\u003e\u003c/strong\u003e（the real computer system）的当前状态，\n 而不是虚拟机的。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eR\u003c/mark\u003e\u003c/strong\u003e: \u003cstrong\u003e\u003cmark\u003e重定位-边界 寄存器\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR = (l, b)\u003c/code\u003e 永远为真，不管计算机当前的状态（mode）为何。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003el\u003c/code\u003e：relocation 部分，给出的是一个绝对地址，从 0 开始；\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e：bound 部分，给出的虚拟内存的绝对 size（而不是最大合法地址）\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e例如，如果想\u003cstrong\u003e\u003cmark\u003e访问所有内存，要设置 \u003ccode\u003el=0 \u0026amp;\u0026amp; b=q-1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"232-内存重定位vm-地址---物理地址过程\"\u003e2.3.2 内存重定位（VM 地址 -\u0026gt; 物理地址）过程\u003c/h3\u003e\n\n\u003cp\u003e如果一条指令要访问地址 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e，那绝对地址将计算如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eif a + l \u0026gt;= q         # 重定位之后，（绝对地址）超出了物理内存边界\n    memorytrap\nelse if a \u0026gt; b         # 超出了虚拟内存的边界\n    memorytrap\nelse\n    return E[a+l]     # 真实机器的内存中 a+1 位置\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e后文将解释 memorytrap（内存陷入）是什么。\u003c/p\u003e\n\n\u003ch3 id=\"233-程序状态字psw\"\u003e2.3.3 程序状态字（PSW）\u003c/h3\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e            S = \u0026lt;E, M, P, R\u0026gt;\n            |    |  |  |  |\n            |    |  |  |  +---- relocation-bounds Register\n            |    |  |  +------- Program counter (PC)\n            |    |  +---------- Mode (processor mode)\n            |    +------------- Executable storage\n            |\n            +---- State of the real machine\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(M, P, R)\u003c/code\u003e 三元组通常称为程序状态字（program status word, \u003cstrong\u003e\u003cmark\u003ePSW\u003c/mark\u003e\u003c/strong\u003e）。\n为使证明方便，我们假设 PSW 能\u003cstrong\u003e\u003cmark\u003e存储在单个内存位置\u003c/mark\u003e\u003c/strong\u003e（这个假设是很容易去掉的）。\n后文将会看到为了保存执行状态，会把老 PSW 存储到 E[0] 然后从 E[1] 读取新 PSW 的操作。\u003c/p\u003e\n\n\u003ch3 id=\"234-状态的有限集合\"\u003e2.3.4 状态的有限集合\u003c/h3\u003e\n\n\u003cp\u003e以上四个变量都只能取有限几个值，因此 S 将是一个有限状态集合，我们称为 C。\u003c/p\u003e\n\n\u003cp\u003e那么，指令（instruction） \u003cem\u003ei\u003c/em\u003e 就是一个\u003cstrong\u003e\u003cmark\u003e从 C 到 C 的函数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\n  \u003ci\u003ei: C -\u0026gt; C\u003c/i\u003e\n\u003c/p\u003e\n\n\u003cp\u003e例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei(S1) = S2\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei(E1, M1, P1, R1) = (E2, M2, P2, R2)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e至此，我们讨论的所有内容还都属于常规第三代计算机的范畴，因此没什么让人惊讶的。\u003c/p\u003e\n\n\u003ch2 id=\"24-第三代计算机模型核心抽象原语保护简单内存分配\"\u003e2.4 第三代计算机模型（核心抽象）：原语保护+简单内存分配\u003c/h2\u003e\n\n\u003cp\u003e将常规第三代计算机系统\u003cstrong\u003e\u003cmark\u003e外表的复杂性\u003c/mark\u003e\u003c/strong\u003e去掉之后，剩下的将是\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个广义的围绕 \u003cstrong\u003e\u003cmark\u003esupervisor/user 模式\u003c/mark\u003e\u003c/strong\u003e概念构建的\n\u003cstrong\u003e\u003cmark\u003eprimitive protection system\u003c/mark\u003e\u003c/strong\u003e（原语保护系统，即特权指令只能被\nsupervisor 执行，译注），\u003c/li\u003e\n  \u003cli\u003e也是一个围绕\u003cstrong\u003e\u003cmark\u003e重定位-边界系统\u003c/mark\u003e\u003c/strong\u003e（relocation-bounds system）构建的\u003cstrong\u003e\u003cmark\u003e简单内存分配系统\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在这个模型中，为简单起见，我们将稍微偏离最常见的重定位系统，假设在 supervisor 和 user 模式中\n这种重定位都是可用的。这种偏离对我们的证明没有很大影响。\n另外也要注意，处理器的所有内存引用都假设是 relocated。\u003c/p\u003e\n\n\u003cp\u003e这个模型的一个\u003cstrong\u003e\u003cmark\u003e核心限制是：不包括 I/O 设备及相关指令\u003c/mark\u003e\u003c/strong\u003e。\n现在大部分 extended software machine（即虚拟机）都没有提供显式的 I/O 设备及指令支持，但最近\n的第三代硬件计算机已经开始支持这种功能了。\nDEC PDP-11 中，\u003cstrong\u003e\u003cmark\u003eI/O devices 是作为 memory ceils 来处理的\u003c/mark\u003e\u003c/strong\u003e，I/O\n操作就是\u003cstrong\u003e\u003cmark\u003e定位到对应的内存单元然后读/写适量的内存数据\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ePDP-11 在计算机、操作系统和编程语言的发展历史上有极其重要的地位。\u003c/p\u003e\n\n  \u003cp\u003e1969 年，Bell Labs 的 MULTICS 项目失败之后，Ken Thompson 在 PDP-7 上用汇编语言非正式地\n开发了一个轻量级操作系统；1970 年这个操作系统移植到 PDP-11，并正式命名为 Unix\n。1972 年，Dennis Ritchie 和 Ken Thompson 在 PDP-7 上用汇编实现最早的 C 语言\n，稍后又移植到 PDP-11，然后用它重写了 Unix —— 这就是 Unix 第四版。\u003c/p\u003e\n\n  \u003cp\u003eC 语言的某些特性在今天看来有点古怪，但如果考虑一下它的诞生背景，尤其是对照 PDP-11 的架构，那很多东西就不难理解了。\n例如，它的前递增（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e++i\u003c/code\u003e）和后递增（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei++\u003c/code\u003e）运算符都能一个萝卜一个坑地对应到 PDP-11 的不同寻址模式。\u003c/p\u003e\n\n  \u003cp\u003e更多关于编程语言和计算机架构的思考，移步：\n\u003ca href=\"/blog/c-is-not-a-low-level-language-zh/\"\u003e\u003cmark\u003e(译) C 不是一门低层（low-level）语言（acmqueue, 2018）\u003c/mark\u003e\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"25-traps\"\u003e2.5 Traps\u003c/h2\u003e\n\n\u003cp\u003e继续描述我们的第三代模型，接下来定义什么是 trap（一般翻译成陷入或捕获）。\u003c/p\u003e\n\n\u003ch3 id=\"251-定义\"\u003e2.5.1 定义\u003c/h3\u003e\n\n\u003cp\u003e如果一条指令 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ei\u0026lt;E1,M1,P1,R1\u0026gt; = \u0026lt;E2,M2,P2,R2\u0026gt;\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 且满足下列两个条件，它就是 trap 了：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e                 /- (M1,P1,R1), j = 0      # E2 地址空间的第一个值（E2[0]），保存系统此时的状态（PSW）\n        E2[j] = |\n                 \\- E1[j]     , 0 \u0026lt; j \u0026lt; q  # E2 地址空间的其他地方，值与 E1 完全相同\n        \n        (M2, P2, R2) = E1[1]               # E2 系统此时的状态，保存到 E[1] 中\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e解释一下：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e当指令 trap 之后，对于内存空间来说，\u003cstrong\u003e\u003cmark\u003e除了第一个地址中的内容（\u003ccode\u003eE2[0]\u003c/code\u003e）有变化，其他地址中的内容都保持不变\u003c/mark\u003e\u003c/strong\u003e。\n  换句话来说，在 \u003cstrong\u003e\u003cmark\u003etrap 之前会将当前 PSW 写入第一个地址\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003etrap 之后，当前 PSW 是从内存空间的第二个地址 \u003ccode\u003eE1(1)\u003c/code\u003e 读取的\u003c/mark\u003e\u003c/strong\u003e，\n  在大部分第三代机器的软件中，期望的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eM2 = supervisor mode\u003c/code\u003e 以及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR2 = (0, q-1)\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"252-直观解释\"\u003e2.5.2 直观解释\u003c/h3\u003e\n\n\u003cp\u003e直观上的解释是，trap 时会自动\u003cstrong\u003e\u003cmark\u003e保存机器当前的状态\u003c/mark\u003e\u003c/strong\u003e，然后通过改变\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e处理器模式\u003c/li\u003e\n  \u003cli\u003e重定位-边界 寄存器\u003c/li\u003e\n  \u003cli\u003e程序计数器（初始化为 E[1]）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e的值，将\u003cstrong\u003e\u003cmark\u003e控制权交给一个预先指定的例程\u003c/mark\u003e\u003c/strong\u003e（routine）。\u003c/p\u003e\n\n\u003cp\u003e这个定义还可以放宽，包括 trap 不会阻塞指令，而是立即或在几条指令之后获得控制权，\n只要\u003cstrong\u003e\u003cmark\u003e状态是以这种可逆的方式存储的\u003c/mark\u003e\u003c/strong\u003e，在 trap 结束之后能精确恢复原来的执行状态。\u003c/p\u003e\n\n\u003ch3 id=\"253-memory-trap\"\u003e2.5.3 Memory trap\u003c/h3\u003e\n\n\u003cp\u003e对 trap 进行分类将给我们带来很大方便。\u003c/p\u003e\n\n\u003cp\u003e当一条指令给出的内存地址\u003cstrong\u003e\u003cmark\u003e超出了 R 中的范围或物理内存的范围\u003c/mark\u003e\u003c/strong\u003e时，\n就会触发 memory trap。\u003c/p\u003e\n\n\u003cp\u003e基于前面定义的变量，用伪代码来表示就是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e# a: address\n# l: value in the relocation register\n# b: relocation bounds\n# q: physical memory size\n\nif (a + l \u0026gt;= q) || (a \u0026gt;= b)\n    memorytrap\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"3-指令行为instruction-behavior\"\u003e3. 指令行为（Instruction Behavior）\u003c/h1\u003e\n\n\u003cp\u003e指令的行为是\u003cstrong\u003e\u003cmark\u003e机器状态 S 的一个函数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e接下来我们根据指令行为的不同对其进行分类。\n\u003cstrong\u003e\u003cmark\u003e一条指令被划分到哪个类别，将决定真实机器是否可虚拟化。\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"31-特权指令privileged-instruction与特权指令-trap\"\u003e3.1 特权指令（privileged instruction）与特权指令 trap\u003c/h2\u003e\n\n\u003cp\u003e如果对于任意\u003cstrong\u003e\u003cmark\u003e一对状态（state pair）\u003c/mark\u003e\u003c/strong\u003e S1 和 S2，都有\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e        S1 = (e, supervisor, p, r)\n        S2 = (e, user      , p, r)\n        \n        其中，i(S1) 和 i(S2) 都不会触发 memory trap\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在以上条件下，如果对于一条指令 \u003cem\u003ei\u003c/em\u003e，都有\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cem\u003ei(S2)\u003c/em\u003e 会发生（非 memory）trap，且\u003c/li\u003e\n  \u003cli\u003e\u003cem\u003ei(S1)\u003c/em\u003e 不会发生 trap\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e那么就称指令 \u003cem\u003ei\u003c/em\u003e 是一条 privileged instruction（\u003cstrong\u003e\u003cmark\u003e特权指令\u003c/mark\u003e\u003c/strong\u003e），\n相应的 trap 称为 privileged instruction trap（\u003cstrong\u003e\u003cmark\u003e特权指令陷入\u003c/mark\u003e\u003c/strong\u003e）。\u003c/p\u003e\n\n\u003cp\u003eS1 与 S2 的唯一区别是：S1 是 supervisor mode，S2 是 user mode。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e通俗解释就是：在\u003cstrong\u003e\u003cmark\u003e其他条件完全相同\u003c/mark\u003e\u003c/strong\u003e的情况下，当一条指令\n\u003cstrong\u003e\u003cmark\u003e工作在 supervisor 模式时不会 trap，工作在 user 模式会 trap\u003c/mark\u003e\u003c/strong\u003e，\n那这就是一条特权指令。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种特权指令的概念与传统上还是很类似的。\u003cstrong\u003e\u003cmark\u003e特权指令独立于虚拟化进程\u003c/mark\u003e\u003c/strong\u003e\n（independent of the virtualization process），它们是\u003cstrong\u003e\u003cmark\u003e机器的特性\u003c/mark\u003e\u003c/strong\u003e\n（characteristics of the machine），阅读机器的操作说明书就能判断出来。\u003c/p\u003e\n\n\u003cp\u003e但注意，我们这里是根据是否 trap 来定义特权指令的。仅仅是 NOP-ing 一条指令而非\ntrap 它是不够的， 这种不能被称作特权指令，也许 “user mode NOP” 比较准确。\u003c/p\u003e\n\n\u003cp\u003e第三代计算机中的特权指令例子：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eIBM System/360 LPSW：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e if M = s      # supervisor mode\n     load_PSW\n else\n     trap;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eHoneywell 6000 LBAR 和 DEC PDP-10 DATAO APR：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e if M = s      # supervisor mode\n     load_R\n else\n     trap\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-敏感指令sensitive-instructions\"\u003e3.2 敏感指令（sensitive instructions）\u003c/h2\u003e\n\n\u003cp\u003e另一种重要的指令类型是 sensitive instructions [4]。\n这种指令在很大程度上觉得了一台计算机能否支持虚拟化。\u003c/p\u003e\n\n\u003cp\u003e我们定义两种类型的敏感指令。\u003c/p\u003e\n\n\u003ch3 id=\"321-控制敏感control-sensitive指令\"\u003e3.2.1 控制敏感（control sensitive）指令\u003c/h3\u003e\n\n\u003cp\u003e如果存在一个状态 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eS1 = \u0026lt;e1, m1, p1, r1\u0026gt;\u003c/code\u003e，有\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e        i(S1) = S2 = \u0026lt;e2, m2, p2, r2\u0026gt;\n\n        其中：\n\n        1. i(S1) 不会 memory trap，且\n        2. (r1 != r2 || m1 != m2) == true\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e就称指令 \u003cem\u003ei\u003c/em\u003e 是一条控制敏感指令。\u003c/p\u003e\n\n\u003cp\u003e也就是说，如果一条指令\u003cstrong\u003e\u003cmark\u003e不经过 memory trap 流程就尝试修改可用内存量\u003c/mark\u003e\u003c/strong\u003e（r1 != r2），\n\u003cstrong\u003e\u003cmark\u003e或修改处理器模式\u003c/mark\u003e\u003c/strong\u003e（m1 != m2），那就是控制敏感的【注释 2】。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e【注释 2】\u003c/p\u003e\n\n  \u003cp\u003eCertain machines may have instructions that can store old\nand new PSWs directly; that is, reference e[0] or e[1], regardless of\nthe values in the relocation register R. In that case, one might wish\nto add to the two control sensitivity conditions a third one: that\ne1[i] ~ e2[i] for i = 0,1.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e例子：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e上一节几个特权指令的例子，也都是 control sensitive 的。\u003c/li\u003e\n  \u003cli\u003e另一个例子是 DEC PDP-10 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eJRST 1\u003c/code\u003e 指令，作用是返回到 user mode。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e关于我们这种控制敏感型指令的定义，有几点值得注意。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e前面定义 VMM 时，我们假设了它\u003cstrong\u003e\u003cmark\u003e能完全控制系统资源\u003c/mark\u003e\u003c/strong\u003e。\n  而在我们这个第三代计算机简化模型中，\u003cstrong\u003e\u003cmark\u003e内存是唯一的系统资源\u003c/mark\u003e\u003c/strong\u003e【注释 3】。\n  \u003cstrong\u003e\u003cmark\u003e控制敏感指令会影响或潜在地影响 VMM 的这种控制\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cblockquote\u003e\n      \u003cp\u003e【注释 3】\n这里我们\u003cstrong\u003e\u003cmark\u003e并没有将处理器（processor）作为一种系统资源\u003c/mark\u003e\u003c/strong\u003e。从最简单的形式上来说，\n虚拟机概念不需要 multiprograming 或 time-sharing，因此无需控制处理器的分配。\n但对大部分实际系统来说，这个假设并不准确，因此如果引入 I/O，这个假设就要改。\n忽略处理器资源的分配，带来的一个有趣后果是可能允许直接执行 HALT 指令，\n而在 VM time-sharing 场景下，这一行为是不允许的。\u003c/p\u003e\n    \u003c/blockquote\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e这里使用的是一个简化的机器模型（simplified machine），\n  其中没有独立的条件代码（condition codes）或允许指令之间交互的复杂东西\n  （\u003cstrong\u003e\u003cmark\u003e所有交互都通过 PSW\u003c/mark\u003e\u003c/strong\u003e）。但对于实际计算机，ADD 或 DIVIDE 之类的指令在\n  异常条件时会 trap，这种情况下定义 control sensitivity 时就要将这些 trap\n  都排除在外，就像对待 memory trap 一样。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"322-重定位偏移算子-\"\u003e3.2.2 重定位偏移算子 ⊕\u003c/h3\u003e\n\n\u003cp\u003e为描述第二种敏感指令，我们需要先引入一些符号。\u003c/p\u003e\n\n\u003cp\u003e前面已经定义了 重定位-位置 寄存器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er = (l,b)\u003c/code\u003e。\n对于一个整数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e，定义一个算子 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e⊕\u003c/code\u003e，使得：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003er\u0026#39; = r ⊕ x = (l+x,b)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e也就是重定位寄存器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er\u003c/code\u003e 的 \u003cstrong\u003e\u003cmark\u003ebase 值移动了 x 个位置\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e此时需要指出，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e一个状态 S 能访问哪些内存\u003c/mark\u003e\u003c/strong\u003e（the only part of memory），\n就由\u003cstrong\u003e\u003cmark\u003e重定位-边界寄存器 R 指定的\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e因此，要确定一条指令的效果，\u003cstrong\u003e\u003cmark\u003e只需要将 R 限制的这部分内存包括到状态描述里\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e我们用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE | R\u003c/code\u003e 来表示\u003cstrong\u003e\u003cmark\u003e这部分内存中的内容\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e由于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er = (l,b)\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE | r\u003c/code\u003e 表示的就是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003el\u003c/code\u003e 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003el+b\u003c/code\u003e 位置的这部分内存中的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，我们本质上可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eS = (e|r, m, p, r)\u003c/code\u003e 来表示一个状态【注释 4】。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e【注释 4】\nTo be more precise, (e|r, m, p, r) represents an equivalence\nclass of states: those whose values of m, p, and r match, and for\nwhom that portion of memory from l to l+b is the same. To be\ncompletely accurate, it must also be the case that E[1] is also the\nsame. In this way the equivalence classes of states are maintained .\nby instructions. That is, for any S1 and S2 both in the class (e|r,\nm, p, r) and any instruction i, where i(S1) = S1’ and i(S2) = S2’,\nS1’ and S2’ are also in the same equivalence class. Even though\n(e|r, m, p, r) really specifies a set of states rather than a single\nstate, we will not maintain the distinction in the text since it will be\nclear from context that instructions behave as above.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e那 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE | r⊕x\u003c/code\u003e 又表示什么意思呢？结合以上两者，它表示的就是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003el+x\u003c/code\u003e 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003el+b+x\u003c/code\u003e 的这部分内存中的内容。\u003c/p\u003e\n\n\u003cp\u003e那么说 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE | r == E\u0026#39; | r⊕x\u003c/code\u003e 意味着对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0 \u0026lt; i \u0026lt; b\u003c/code\u003e，有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE[l+i] == E\u0026#39;[l+x+i]\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e直观上，我们已经准备好描述\u003cstrong\u003e\u003cmark\u003e程序在可执行存储中移动时\u003c/mark\u003e\u003c/strong\u003e的条件了。\u003c/p\u003e\n\n\u003cp\u003e在引入这些繁琐的符号和公式之后，我们现在终于可以定义第二种控制敏感指令了。\u003c/p\u003e\n\n\u003ch3 id=\"323-行为敏感behavior-sensitivity指令\"\u003e3.2.3 行为敏感（behavior sensitivity）指令\u003c/h3\u003e\n\n\u003cp\u003e对于一条指令 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei\u003c/code\u003e，如果存在一个整数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 和两个状态，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1. S1 = (e | r  , m1, p, r  ), and\n2. S2 = (e | r⊕x, m2, p, r⊕x),\n\nwhere,\n\n1. i(S1) = (e1 | r  , m1, p1, r  )\n2. i(S2) = (e2 | r⊕x, m2, p2, r⊕x), and\n3. i(S1) and i(S2) do not memorytrap\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使下面\u003cstrong\u003e\u003cmark\u003e至少一条成立\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1. (e1 | r) != (e2 | r⊕x)  # 可执行内存中的内容变了（E）\n2.       p1 != p2          # 处理器工作模式（M）导致 P（下一条要执行的指令的地址）不同\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e就说它是行为敏感指令【注释 5】。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThe results of this paper are still true if the definition of behavior\nsensitivity is restricted to the cases where m2 != supervisor_mode. Changes\nin instruction behavior due to relocation in supervisor mode does\nnot affect virtual machine code, since that code is run in user mode.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e以上定义比较晦涩，直观上来说，对于状态的四元组 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;E, M, P, R\u0026gt;\u003c/code\u003e （或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;E|R, M, P, R\u0026gt;\u003c/code\u003e，更方便理解），\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果一条指令的\u003cstrong\u003e\u003cmark\u003e执行效果取决于 \u003ccode\u003eE|R\u003c/code\u003e 中的值\u003c/mark\u003e\u003c/strong\u003e\n  （例如它在真实内存中的位置）或\u003cstrong\u003e\u003cmark\u003e处理器模式（M）\u003c/mark\u003e\u003c/strong\u003e，那这条指令就是\u003cstrong\u003e\u003cmark\u003e行为敏感\u003c/mark\u003e\u003c/strong\u003e的。\u003c/p\u003e\n\n    \u003cp\u003e因此在我们的模型中，行为敏感又分为两种：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e位置敏感：指令的执行行为取决于它\u003cstrong\u003e\u003cmark\u003e在真实内存（real memory）中的位置\u003c/mark\u003e\u003c/strong\u003e，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE|R\u003c/code\u003e 不同导致。例子：load physical address (IBM 360/ 67 ERA)。\u003c/li\u003e\n      \u003cli\u003e模式敏感：指令的行为\u003cstrong\u003e\u003cmark\u003e受机器模式的影响\u003c/mark\u003e\u003c/strong\u003e，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eM\u003c/code\u003e 不同导致。例子：DeC PDP-11/45 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMVPI\u003c/code\u003e 指令（move from previous instruction space）。\n   这条指令\u003cstrong\u003e\u003cmark\u003e依据当前模式（mode）等信息，生成它的有效地址（P）\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e其他两种情况，即\u003cstrong\u003e\u003cmark\u003e指令执行之后， M 或 R 不同\u003c/mark\u003e\u003c/strong\u003e，属于控制敏感型的。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e按照以上定义，如果一条指令是控制敏感或行为敏感的，那它就是敏感型的；否则就是\n\u003cstrong\u003e\u003cmark\u003einnocuous\u003c/mark\u003e\u003c/strong\u003e（无害）指令。\n有了这种分类，我们就可以用\u003cstrong\u003e\u003cmark\u003e更精确的术语来定义 VMM\u003c/mark\u003e\u003c/strong\u003e 了。\u003c/p\u003e\n\n\u003ch1 id=\"4-virtual-machine-monitor-vmm\"\u003e4. Virtual Machine Monitor (VMM)\u003c/h1\u003e\n\n\u003cp\u003eVMM 是一个特殊的软件，更具体地说，是一个\u003cstrong\u003e\u003cmark\u003e具备了一些特殊功能的控制程序\u003c/mark\u003e\u003c/strong\u003e（control program，CP）。\u003c/p\u003e\n\n\u003cp\u003e我们将证明，所有满足我们所描述的几个特性的控制程序，都能用于构建指令集满足某个特殊限制的第三代计算机。\u003c/p\u003e\n\n\u003ch2 id=\"41-模块组成\"\u003e4.1 模块组成\u003c/h2\u003e\n\n\u003cp\u003eVMM 由几个/几类模块组成。\u003c/p\u003e\n\n\u003ch3 id=\"411-第一类模块分发器dispatcherd\"\u003e4.1.1 第一类模块：分发器（dispatcher，D）\u003c/h3\u003e\n\n\u003cp\u003e第一类是 dispatcher D.\u003c/p\u003e\n\n\u003cp\u003eD 的\u003cstrong\u003e\u003cmark\u003e初始指令\u003c/mark\u003e\u003c/strong\u003e放在\u003cstrong\u003e\u003cmark\u003e硬件会 trap 的位置\u003c/mark\u003e\u003c/strong\u003e：在位置 1 放置 PC（程序计数器）的值。\u003c/p\u003e\n\n\u003cp\u003e注意，虽然前面关于 trap 的定义中并没有说明，但某些机器会\u003cstrong\u003e\u003cmark\u003e根据不同的 trap 类型而陷入到不同位置\u003c/mark\u003e\u003c/strong\u003e。\n这种行为对我们并没有很大影响，因为 D \u003cstrong\u003e\u003cmark\u003e允许有多个“第一条”指令\u003c/mark\u003e\u003c/strong\u003e（entry points）。\u003c/p\u003e\n\n\u003cp\u003e可以认为 D 是\u003cstrong\u003e\u003cmark\u003e控制程序的最外层控制模块\u003c/mark\u003e\u003c/strong\u003e（the top level control module），\n它决定了接下来调用哪个模块，也可以唤醒下面第二类或第三类模块。\u003c/p\u003e\n\n\u003ch3 id=\"412-第二类模块分配器allocatora\"\u003e4.1.2 第二类模块：分配器（allocator，A）\u003c/h3\u003e\n\n\u003cp\u003e第二类只有一个 member，即一个 allocator A。\u003c/p\u003e\n\n\u003cp\u003e分配器 A 决定\u003cstrong\u003e\u003cmark\u003e提供哪些系统资源\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e如果只有一个 VM，那 A 只需要将 VM 和 VMM 分开就行了；\u003c/li\u003e\n  \u003cli\u003e如果有多个 VM，那 A 就要\u003cstrong\u003e\u003cmark\u003e保证不会将同一系统资源（例如，同一块内存）同时分配给不同 VM\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e常见的第三代计算机要有能力\u003cstrong\u003e\u003cmark\u003e根据给定的资源资源表\u003c/mark\u003e\u003c/strong\u003e（resource tables）来构建自己的分配器\u0026lt;/mark\u0026gt;**。\u003c/p\u003e\n\n\u003cp\u003e每当 VM 中执行到\u003cstrong\u003e\u003cmark\u003e会改变这个 VM 资源的特权指令\u003c/mark\u003e\u003c/strong\u003e时，\u003cstrong\u003e\u003cmark\u003eD 会唤醒 A\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在我们的简化模型中，一个有代表性的例子就是\u003cstrong\u003e\u003cmark\u003e重置 R (relocation-bounds) 寄存器操作\u003c/mark\u003e\u003c/strong\u003e（\n这会改变 VM 的可用内存大小，译注）。\u003c/li\u003e\n  \u003cli\u003e如果将处理器当做一种资源，那需要将 halt 同样当做资源。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"413-第三类模块trap-对应的-interpreter-routine解释例程\"\u003e4.1.3 第三类模块：trap 对应的 interpreter routine（解释例程）\u003c/h3\u003e\n\n\u003cp\u003e第三种类型可以认为是\u003cstrong\u003e\u003cmark\u003e所有会 trap 的指令的解释程序\u003c/mark\u003e\u003c/strong\u003e，每个特权指令对应一个解\n释例程（interpreter routine）。这种 routine 的目的是\u003cstrong\u003e\u003cmark\u003e模拟 trapped 指令的效果\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e进一步，回忆一下我们当前的表示：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei(S1) = S2\u003c/code\u003e 表示通过指令 i，状态 S1 将映射到 S2。\n现在定义 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eij(S1) = S2\u003c/code\u003e，它表示存在\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ei(S1) = S3，且\u003c/li\u003e\n  \u003cli\u003ej(S3) = S2\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以此类推，指令序列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eij...k(S1)\u003c/code\u003e 表示的意思大家就清楚了。\u003c/p\u003e\n\n\u003ch2 id=\"42-控制程序cp的表示\"\u003e4.2 控制程序（CP）的表示\u003c/h2\u003e\n\n\u003cp\u003e令 \u003cem\u003e\u003ccode\u003ev\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e\u003c/em\u003e 表示这样一个\u003cstrong\u003e\u003cmark\u003e指令序列\u003c/mark\u003e\u003c/strong\u003e。那么就可以将\ninterpretive routines 表示为 \u003cem\u003e\u003ccode\u003ev\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e\u003c/em\u003e 的集合，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e \u003ccode\u003e{v\u003csub\u003ei\u003c/sub\u003e}\u003c/code\u003e, \u003ccode\u003e1 \u0026lt;= i \u0026lt;= m\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e其中 m 为特权指令的数量。\u003c/p\u003e\n\n\u003cp\u003edispatcher 和 allocator 也是指令序列。因此，一个\u003cstrong\u003e\u003cmark\u003e控制程序\u003c/mark\u003e\u003c/strong\u003e（Control Program, CP）就由它的三部分表示如下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\n    \u003cmark\u003e\n        \u003ci\u003e\u003ccode\u003eCP = \u0026lt;D, A, {v\u003csub\u003ei\u003c/sub\u003e}\u0026gt;\u003c/code\u003e\u003c/i\u003e\n    \u003c/mark\u003e\n\u003c/p\u003e\n\n\u003cp\u003e我们感兴趣的是\u003cstrong\u003e\u003cmark\u003e满足我们将讨论的某些特性的控制程序\u003c/mark\u003e\u003c/strong\u003e。\n接下来将\u003cstrong\u003e\u003cmark\u003e假设控制程序运行在 supervisor mode\u003c/mark\u003e\u003c/strong\u003e，在实际系统中，这一点是非常常见的。\u003c/p\u003e\n\n\u003cp\u003e这就是说，在 trap 发生时，硬件会将 PSW 加载到地址 1；此时 PSW 需要\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e将 mode 设置为 supervisor，\u003c/li\u003e\n  \u003cli\u003e将程序计数器 PC 设置为 D 的第一个地址。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e此外，我们认为其他所有程序都运行在 user mode 【注释 6】。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eSee for example [6, pp. 108-113] for a discussion of other\nalternatives to these assumptions.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003etrap 执行结束后，控制程序（的最后一个操作）将原来的 PSW 加载回来，在\n\u003cstrong\u003e\u003cmark\u003e将控制权重新交还给运行中的程序时\u003c/mark\u003e\u003c/strong\u003e，会将 mode 设置为 user。\u003c/p\u003e\n\n\u003cp\u003e因此，在\u003cstrong\u003e\u003cmark\u003e控制程序中就必须\u003c/mark\u003e\u003c/strong\u003e有一个位置用来\u003cstrong\u003e\u003cmark\u003e记录虚拟机的 simulated mode\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"5-虚拟机的特性virtual-machine-properties\"\u003e5. 虚拟机的特性（Virtual Machine Properties）\u003c/h1\u003e\n\n\u003cp\u003e在控制程序监督下运行的程序，有三个特性：高效性（efficiency）、资源控制（resource control）和等价性（equivalence）。\u003c/p\u003e\n\n\u003ch2 id=\"51-三大特性\"\u003e5.1 三大特性\u003c/h2\u003e\n\n\u003ch3 id=\"511-高效性efficiency\"\u003e5.1.1 高效性（efficiency）\u003c/h3\u003e\n\n\u003cp\u003e所有 innocuous 指令由\u003cstrong\u003e\u003cmark\u003e硬件直接执行，无需控制程序的任何干预\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"512-资源控制resource-control\"\u003e5.1.2 资源控制（resource control）\u003c/h3\u003e\n\n\u003cp\u003e用户程序无法改变分配给它的系统资源，例如内存；需要修改资源时，必须\u003cstrong\u003e\u003cmark\u003e唤醒控制程序的分配器 A\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"513-等价性equivalence\"\u003e5.1.3 等价性（equivalence）\u003c/h3\u003e\n\n\u003cp\u003e任何程序 K，在控制程序的监督下执行时，其行为应当与没有控制程序监督时一致 —— 但有\u003cstrong\u003e\u003cmark\u003e两个例外\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003etiming\u003c/p\u003e\n\n    \u003cp\u003e由于来自控制程序的偶尔干预，K 中的特定指令流执行可能要（比没有控制程序干预）慢一些。\n 因此，如果模型中假设执行时间完全不变，可能会导致错误的结果。\u003c/p\u003e\n\n    \u003cp\u003e在我们的简单系统中，将假设这种变慢可以忽略不计。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eresource availability\u003c/p\u003e\n\n    \u003cp\u003e举个例子，对于程序提出的修改重定位-边界 寄存器（即申请更多内存资源），分配器\n A 无法满足；因此程序接下来的行为与资源充足时的行为就会有差异。\u003c/p\u003e\n\n    \u003cp\u003e这种问题很容易出现，因为控制程序自身也占用内存。\n 我们要意识到：创建出来的 VM 环境是真实硬件的一个缩小版（”smaller” version）：\n 逻辑上一样，但资源量要小（lesser quantity of certain resources）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e需要保证的等价性是：程序运行在 VM 中时，与运行在一台\u003cstrong\u003e\u003cmark\u003e同样资源量的真实硬件机器\u003c/mark\u003e\u003c/strong\u003e上时，行为应当完全一致。\n后文将对等价性作出更精确的描述。在此之前，先给出我们的主定理（major theorem）的定义和声明。\u003c/p\u003e\n\n\u003ch2 id=\"52-定理一主定理计算机支持-vmm-的充分条件\"\u003e5.2 定理一（主定理）：计算机支持 VMM 的充分条件\u003c/h2\u003e\n\n\u003cp\u003e我们说一个 VMM 是满足三个特性（efficiency, resource control, and equivalence）的任意控制程序。\n那么，功能上来说，任何程序在 VMM 存在时\u003cstrong\u003e\u003cmark\u003e执行所看到的环境，就称为一台虚拟机\u003c/mark\u003e\u003c/strong\u003e（virtual machine）。\n这个环境由真实机器（real machine）和虚拟机监视器（VMM）两部分组成。\n这个正式定义与前文的直观（形象）定义是一致的。\u003c/p\u003e\n\n\u003cp\u003e有了这个定义，就可以声明我们的基本定理了。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eTHEOREM 1\u003c/mark\u003e\u003c/strong\u003e：对于任何常规第三代计算机，如果其\u003cstrong\u003e\u003cmark\u003e敏感指令\u003c/mark\u003e\u003c/strong\u003e（sensitive instructions）\n\u003cstrong\u003e\u003cmark\u003e是其特权指令\u003c/mark\u003e\u003c/strong\u003e（privileged instructions）\u003cstrong\u003e\u003cmark\u003e的一部分，那就能为这台计算机构建一个 VMM\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"6-关于主定理的讨论discussion-of-theorem\"\u003e6. 关于主定理的讨论（Discussion of Theorem）\u003c/h1\u003e\n\n\u003ch2 id=\"61-什么是常规第三代计算机\"\u003e6.1 什么是“常规第三代计算机”\u003c/h2\u003e\n\n\u003cp\u003e在讨论这定理之前，先来明确什么是“常规第三代计算机”。\n这个术语用来表示所有\u003cstrong\u003e\u003cmark\u003e满足前面假设的几个特性\u003c/mark\u003e\u003c/strong\u003e的计算机：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e重定位机制\u003c/li\u003e\n  \u003cli\u003esupervisor/user mode\u003c/li\u003e\n  \u003cli\u003etrap 机制\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这些假设简洁而合理地反映了当前第三代计算机的一些相关实践。\n此外，这个术语也暗示这些\u003cstrong\u003e\u003cmark\u003e指令集是足够通用的\u003c/mark\u003e\u003c/strong\u003e，基于这些指令能够构建\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003edispatcher\u003c/li\u003e\n  \u003cli\u003eallocator\u003c/li\u003e\n  \u003cli\u003egeneralized table lookup procedure：后文会看到为什么需要这个东西。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"62-状态集合-c-和同态映射\"\u003e6.2 状态集合 C 和同态映射\u003c/h2\u003e\n\n\u003cp\u003e基于这些“第三代计算机”特性，定理一提供了一个\u003cstrong\u003e\u003cmark\u003e相当简单且足够保证虚拟化\u003c/mark\u003e\u003c/strong\u003e的条件。\n其实这几个特性如今已经非常普遍，因此唯一一个新限制其实也就是\u003cstrong\u003e\u003cmark\u003e敏感指令和特权指令之间的关系\u003c/mark\u003e\u003c/strong\u003e，\n而判断这个关系是否成立也是非常容易的。\u003c/p\u003e\n\n\u003cp\u003e此外，这个定理还可以作为 design requirement 被硬件设计师使用。当然，我们并没有\n对中断处理或 I/O 需要满足哪些条件作出说明。本质上这些也是很类似的。\u003c/p\u003e\n\n\u003cp\u003e将机器所有状态的集合称为 C，在证明过程中用 C 的\u003cstrong\u003e\u003cmark\u003e同态映射\u003c/mark\u003e\u003c/strong\u003e\n（homomorphism on C）来刻画等价性（equivalence）比较方便。\u003c/p\u003e\n\n\u003cp\u003e将 C 分为两部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eC\u003csub\u003ev\u003c/sub\u003e ：VMM 已经在内存和 PSW 的 P 中提供的状态，其中 PSW 就是内存第一个地址处存储的值，也是 VMM 的第一个地址。\u003c/li\u003e\n  \u003cli\u003eC\u003csub\u003er\u003c/sub\u003e ：所有其他状态。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这两个集合分别\u003cstrong\u003e\u003cmark\u003e反映了真实机器有 VMM 和无 VMM 条件下的所有可能状态\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e每条指令\u003c/mark\u003e\u003c/strong\u003e都可以认为是一个\u003cstrong\u003e\u003cmark\u003e状态集合 C 之上的一元算子\u003c/mark\u003e\u003c/strong\u003e（unary operator）：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003ei(Si) = S\u003csub\u003ek\u003c/sub\u003e\u003c/p\u003e\n\n\u003cp\u003e同理，\u003cstrong\u003e\u003cmark\u003e每个指令流\u003c/mark\u003e\u003c/strong\u003e（instruction sequence），例如\u003c/p\u003e\n\n\u003cp align=\"center\"\u003ee\u003csub\u003en\u003c/sub\u003e(S1) = ij...k(S1) = S2\u003c/p\u003e\n\n\u003cp\u003e也可以认为是 C 之上的一个一元算子。\u003c/p\u003e\n\n\u003ch2 id=\"63-虚拟机映射vm-map\"\u003e6.3 虚拟机映射（VM map）\u003c/h2\u003e\n\n\u003cp\u003e考虑有限长度的所有指令流，将这种指令流集合用 I 表示。I 包含了同态映射要用的算子。\u003c/p\u003e\n\n\u003cp\u003e定义一个虚拟机映射（VM map）\u003c/p\u003e\n\n\u003cp align=\"center\"\u003ef：C\u003csub\u003er\u003c/sub\u003e -\u0026gt; C\u003csub\u003ev\u003c/sub\u003e\u003c/p\u003e\n\n\u003cp\u003e是一一同态映射（one-one homomorphism），对于指令流集合 I 中的所有算子 e\u003csub\u003ei\u003c/sub\u003e 都成立。\u003c/p\u003e\n\n\u003cp\u003e也就是说，对于任意状态 S\u003csub\u003ei\u003c/sub\u003e ∈ C\u003csub\u003er\u003c/sub\u003e 和任意指令流 e\u003csub\u003ei\u003c/sub\u003e，\n存在一个治理流 \u003ci\u003ee\u003csub\u003ei\u003c/sub\u003e\u003csup\u003e’\u003c/sup\u003e\u003c/i\u003e 满足\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\nf(e\u003csub\u003ei\u003c/sub\u003e(S\u003csub\u003ei\u003c/sub\u003e) = e\u003csub\u003ei\u003c/sub\u003e\u0026#39;(f(S\u003csub\u003ei\u003c/sub\u003e))\n\u003c/p\u003e\n\n\u003cp\u003e如图 2 所示。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/formal-requirements-for-virtualizable-arch/2.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 2. VM map\u003c/p\u003e\n\n\u003cp\u003eVM map 定义中有两个相关联的特性：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e从 real machine 的状态到 virtual machine 的状态的某个特定\u003cstrong\u003e\u003cmark\u003e映射，在数学上存在的\u003c/mark\u003e\u003c/strong\u003e。\n 但这里并没有对构建这种映射的能力、用硬件还是软件来构建，做出任何限制。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eC\u003csub\u003ev\u003c/sub\u003e domain 的 e\u003csub\u003ei\u003c/sub\u003e’ 指令是真实存在的，对应的是 C\u003csub\u003er\u003c/sub\u003e domain 的 e\u003csub\u003ei\u003c/sub\u003e 指令流。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e我们要求\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e作为 VM map 定义的一部分，对于每个 ei，存在合适的 ei’ 且能被执行。因此不是立即清楚，对于一个特定计算机，VM map 是否存在。\u003c/li\u003e\n  \u003cli\u003e作为定义的一部分，还需要指出，\u003cstrong\u003e\u003cmark\u003ef 是一一映射\u003c/mark\u003e\u003c/strong\u003e。这个条件等价于\n  \u003cstrong\u003e\u003cmark\u003ef 是（左）可逆的\u003c/mark\u003e\u003c/strong\u003e，将其逆函数称为 g，后文的证明中将用到。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e为更清楚地展示这个概念，我们来看一个具体的 VM map。\u003c/p\u003e\n\n\u003ch2 id=\"64-vm-map-示例\"\u003e6.4 VM map 示例\u003c/h2\u003e\n\n\u003cp\u003e令：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e控制程序占据物理内存的前 k 个位置\u003c/mark\u003e\u003c/strong\u003e，也就是说：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003eE[0] and E[1] 是 PSW 预留的\u003c/li\u003e\n      \u003cli\u003e控制程序占据 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e2 ~ k-1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 位置。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e接下来的 w 个位置给虚拟机使用\u003c/mark\u003e\u003c/strong\u003e，此处有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek + w \u0026lt;= q\u003c/code\u003e，即不能超越物理内存边界。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef(E, M, P, R) = (E\u0026#39;, M\u0026#39;, P\u0026#39;, R\u0026#39;)\u003c/code\u003e，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eS = (E, M, P, R)\u003c/code\u003e 是没有 VMM 的机器的状态。\n我们假设在这样一台真实机器（接下来将拿虚拟机的活动和它做对比）上，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er = (1,b)\u003c/code\u003e 中，b 的值永远小于 w。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eE’[i] = the control program, for i = 2 ~ k-l，即\u003cstrong\u003e\u003cmark\u003e控制程序占用内存的前 k 个位置\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003eE’[i + k] = E[i], for i= 0, w-1，\u003cstrong\u003e\u003cmark\u003e物理内存中 (k, k+w-1)\u003c/mark\u003e\u003c/strong\u003e 位置，即 \u003cstrong\u003e\u003cmark\u003eVM 占用的物理内存\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eE’[i] = (m’,p’,r’),\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003em’ = supervisor，即\u003cstrong\u003e\u003cmark\u003e模式永远是 supervisor\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n      \u003cli\u003ep’ = first location of the control program，\u003cstrong\u003e\u003cmark\u003e控制程序的起始地址\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n      \u003cli\u003er’ = (0,q-1)，\u003cstrong\u003e\u003cmark\u003e完整的物理内存空间\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eE’[0] = \u0026lt;m,p,r\u0026gt; as last set by trap handler，表示 PSW，由 trap handler 设置\u003c/li\u003e\n  \u003cli\u003eM’ = u (user),\u003c/li\u003e\n  \u003cli\u003eP’ = p,\u003c/li\u003e\n  \u003cli\u003eR’ = (l+k, b), where R = (l, b).\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e需要说明，以上 VM map 只对真实机器中\u003cstrong\u003e\u003cmark\u003e一条指令执行结束且下一条指令还没开始时的状态\u003c/mark\u003e\u003c/strong\u003e\n（states after the completion of one instruction in the real machine and\nbefore the beginning of the next）\u003cstrong\u003e\u003cmark\u003e做映射\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这个 VM map 的例子非常简单；当然可以创建更加复杂的函数来表示 VM map 所需的特性，\n但我们接下来还是将用以上例子，并把它作为标准 VM map。如无特殊说明，接下来提到的 VM map 都是这个标准 VM map。\u003c/p\u003e\n\n\u003cp\u003eFig. 2. The virtual machine map.\u003c/p\u003e\n\n\u003ch2 id=\"65-等价性equivalence意味着什么\"\u003e6.5 等价性（equivalence）意味着什么\u003c/h2\u003e\n\n\u003cp\u003e现在我们来声明 “equivalence”，或者更准确地说，”essentially identical effect”  意味着什么。\u003c/p\u003e\n\n\u003cp\u003e假设有两台机器，一个在状态 S1，一个在状态 S1’ = f(S1)，二者同时开始运行，\n那么，当且仅当\u003cstrong\u003e\u003cmark\u003e对于任何状态 S1，如果真实机器在 S2 状态 halt 了，那 VM 一定在状态 S2\u0026#39;=f(S2) halt\u003c/mark\u003e\u003c/strong\u003e 。\n那么我们就称 \u003cstrong\u003e\u003cmark\u003eVMM 提供的环境与真实计算机是等价的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这里说的 VM halt，意思是在 VM 系统中，\u003cstrong\u003e\u003cmark\u003e用户程序试图从位置 j（其中 j\u0026gt;k）执行一个 halt 操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这个定义的设定有多方面考虑：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e基于比较点（\u003cstrong\u003e\u003cmark\u003ecomparison points\u003c/mark\u003e\u003c/strong\u003e）而非\u003cstrong\u003e\u003cmark\u003e已执行指令的数量\u003c/mark\u003e\u003c/strong\u003e（number of instructions executed）触发 halt，\n  例如，部分指令会被 VM 系统解释执行（interpreted），因此可能会使用很长的指令流，基于指令数量就不合适。\u003c/li\u003e\n  \u003cli\u003e这里选择的 VM map \u003cem\u003ef(S21) = S2\u003c/em\u003e 非常简单，映射关系一目了然，因此无需笔墨，大家就能看出\n  逆函数 g(S2’) = S2 是成立的，即等价性存在。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"66-定理一的简要证明proof-sketch\"\u003e6.6 定理一的简要证明（Proof Sketch）\u003c/h2\u003e\n\n\u003cp\u003e我们的目标是证明：只要计算机满足前面分析的 equivalence、resource control 和\nefficiency 这三个特性，就能为这种计算机构建控制程序（即 VMM）\u003c/p\u003e\n\n\u003ch3 id=\"控制程序\"\u003e控制程序\u003c/h3\u003e\n\n\u003cp\u003eWe construct a control program that obeys the\nthree requisite properties. It is the cp outlined earlier.\nThe only constructive part not demonstrated was the\nability to provide the appropriate interpretive routines\nfor all privileged instructions. \n\u003cstrong\u003e\u003cmark\u003eWe demonstrate below that a general solution exists\u003c/mark\u003e\u003c/strong\u003e.\nNote that this will be an existence argument only. In practice there are much\nmore practical techniques. \n任何 privileged instruction（实际来说，**\u003cmark\u003e任何指令）的执行结果只取决于\u003c/mark\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eM, P, R, E[1]\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eE|R\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e也就是说，不是所有内存，而仅仅是\u003cstrong\u003e\u003cmark\u003e位置 1\u003c/mark\u003e\u003c/strong\u003e 以及重定位-边界寄存器 \u003cstrong\u003e\u003cmark\u003eR 限定的内存范围\u003c/mark\u003e\u003c/strong\u003e。\n再考虑到：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eVM 最大可用的内存空间是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eE|R = w\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e那任何特权指令就能够以 two-tuples 方式组织到一张表里面，表的长度就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;E|R, M, P, R\u0026gt;\u003c/code\u003e 的所有可能状态。\n这个二元组的两个元素：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e第一个元素：某个状态\u003c/li\u003e\n  \u003cli\u003e第二个元素：在 1 中的状态下，执行某个特权执行的结果（effect）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e但这样一张表会非常庞大，而且对于每个特权指令，都需要建立一张这样的表。最终结果就是 VMM —— 用它占用的内存空间 (0, k-1) 来衡量，\n就会非常庞大。那么，无需数学证明，我们就可以得出的一个结论是：通过限制真实机器的大小 —— 具体来说就是 w 的大小 —— 我们就可以限制这个表的大小。\u003c/p\u003e\n\n\u003cp\u003eWe have assumed that third generation machines\nhave an instruction set capable of managing these\ntables. Hence, interpretive routines are guaranteed constructable.\nNote of course that such state tables are a\nlast resort, for those privileged instructions of an extremely\narcane nature which are in fact arbitrary algorithms.\u003c/p\u003e\n\n\u003cp\u003eBy limiting the size of “real” memory\nthough, the number of nonequivalent such programs\nis also limited, hence the appropriate tables are also of\nlimited size. In all real cases today, much simpler and\nmore efficient routines exist, and should be used.\u003c/p\u003e\n\n\u003cp\u003eThis completes the description of the control program,\nso it remains to discuss the three properties.\u003c/p\u003e\n\n\u003ch3 id=\"三个特性\"\u003e三个特性\u003c/h3\u003e\n\n\u003cp\u003eGuarantees of the resource control and efficiency\nproperties are trivially dispensed with. By the definition\nof sensitive instruction and the subset requirement of\nthe theorem, any instruction that would affect the\nallocation of resources traps and passes control to the\nVMM. Efficiency has been taken to mean the direct\nexecution of innocuous instructions; we have constructed\nthe VMM to provide that behavior.\u003c/p\u003e\n\n\u003cp\u003eOnly equivalence remains. It is necessary to demonstrate\nthat, for any instruction sequence t = ij . . . k\nwhere k is a halt and any state S1 of a real machine,\nthe following is true.\u003c/p\u003e\n\n\u003cp\u003eLet S1’ = f(S1) and S2 = t(S1). Thenf(S2) = t(S1’).\u003c/p\u003e\n\n\u003cp\u003eAgain, see Figure 2.\u003c/p\u003e\n\n\u003cp\u003eFirst, we demonstrate that the equivalence property\nis true for single instructions; that is, for t = any\ninstruction i. We consider two cases, innocuous instructions\nand sensitive instructions. Both cases are\neasy, and demonstrated in detail in the Appendix as\nlemmas 1 and 2. The innocuous case follows from the\ndefinition of an innocuous instruction and direct application\nof the definition of VM map. The sensitive case\nfollows from the fact that all sensitive instructions are\nprivileged, from the existence of correct interpretation\nsequences and the VM map definition.\u003c/p\u003e\n\n\u003cp\u003eSince single instructions “execute correctly,” it now\nremains only to show that finite sequences also do.\u003c/p\u003e\n\n\u003cp\u003eThat is for any instruction sequence e\u003csub\u003em\u003c/sub\u003e = ij . . . k,\ne\u003csub\u003em\u003c/sub\u003e(f(S)) = f(e\u003csub\u003em\u003c/sub\u003e‘(S)). This fact follows from lemmas 1\nand 2, and the definition of the VM map f as a one-one\nhomomorphism. It is a fairly standard proof and is\ndemonstrated in the Appendix as lemma 3.\u003c/p\u003e\n\n\u003cp\u003eThe proof is now complete, since for third-generation-\nlike machines in which sensitive instructions are a\nsubset of privileged instructions, we have demonstrated\nthat a control program can be constructed which obeys\nthe required three properties. That is, we have exhibited\na VMM. Q.E.D.\u003c/p\u003e\n\n\u003ch3 id=\"充分而非必要条件\"\u003e充分而非必要条件\u003c/h3\u003e\n\n\u003cp\u003e注意，有几方面原因导致\u003cstrong\u003e\u003cmark\u003e定理一的必要条件在通常情况下并不成立\u003c/mark\u003e\u003c/strong\u003e。\n也就是说，在某些条件下，\u003cstrong\u003e\u003cmark\u003e即使定理一的前提并不满足，仍然能为一台计算机构建出 VMM\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eAs a case in point, architectures that include location sensitive instructions may still support\na virtual machine system if it is possible to construct a\nVMM that resides in high core, letting other programs\nexecute unrelocated. Location sensitivity then would\nnot matter.\u003c/p\u003e\n\n\u003cp\u003eIn addition, there may be instructions that are not\ntrue privileged instructions as defined earlier, but which\nstill trap when an undesirable action would result. An\nexample of such a case is an instruction that is able to\nchange the relocation bounds register, but can only\ndecrease the bounds value when executed from user\nmode.\u003c/p\u003e\n\n\u003ch1 id=\"7-递归虚拟化recursive-virtualization\"\u003e7. 递归虚拟化（Recursive Virtualization）\u003c/h1\u003e\n\n\u003cp\u003e基于定理一，我们很快就能引申出很多相关结果，例如\u003cstrong\u003e\u003cmark\u003e递归虚拟化\u003c/mark\u003e\u003c/strong\u003e\n（recursive virtualization，或称嵌套虚拟化）的设想：是否有可能在 VM 内运行一个 VMM 副本，这个副\n本的行为与创建这个 VM 的 VMM 特性完全一样？如果这个过程可以重复，直到系统资源耗\n尽（因为控制程序需要消耗一些内存资源），那就称这台机器是可递归虚拟化的（\nrecursively virtualizable）[2, 6]。\u003c/p\u003e\n\n\u003ch2 id=\"71-定理二递归虚拟化的充分条件\"\u003e7.1 定理二：递归虚拟化的充分条件\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eTHEOREM 2\u003c/mark\u003e\u003c/strong\u003e. 一个常规第三代计算机是可递归虚拟化的，如果：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e这台计算机支持虚拟化（virtualizable），且\u003c/li\u003e\n  \u003cli\u003e可在这台计算机上构建一个没有任何 timing 依赖的 VMM。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"72-定理二的证明\"\u003e7.2 定理二的证明\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e证明\u003c/mark\u003e\u003c/strong\u003e. This property is nearly trivial to demonstrate.\nA VMM is guaranteed, by definition, to produce an\nenvironment in which a large class of programs run\nwith effect identical to that on the real machine. Then it\nis merely necessary to demonstrate that a VMM which\nbelongs to that class of programs can be constructed.\nIf it can, then the performance of the VMM running on\nthe real machine and under other VMMS will be indistinguishable.\u003c/p\u003e\n\n\u003cp\u003eThe only programs excluded from the class of\nidentically performing programs are those which are\nresource bound, or have timing dependencies. The\nsecond limitation is mentioned in the statement of the\ntheorem. The resource bound for our skeletal model is\nonly memory, and it just limits the depth (number of\nnested VMMS) of the recursion, as pointed out in the\ndefinition of recursive virtualization. Hence the VMM as\nconstructed earlier qualifies as a member of that “large\nclass of programs.” Q.E.D.\u003c/p\u003e\n\n\u003ch1 id=\"8-混合虚拟机hybrid-virtual-machines\"\u003e8. 混合虚拟机（Hybrid Virtual Machines）\u003c/h1\u003e\n\n\u003cp\u003e前面提到，目前只有很少的第三代架构能够虚拟化 [5,6]。\n出于这个原因，我们放松前面的定义，得到一个\u003cstrong\u003e\u003cmark\u003e更加宽松、通用但略低效的定义\u003c/mark\u003e\u003c/strong\u003e，\n对应的模型我们称为 hybrid virtual machine system (HVM) [6]。\u003c/p\u003e\n\n\u003ch2 id=\"81-hvm-定义更多指令通过软件解释执行\"\u003e8.1 HVM 定义：更多指令通过软件解释执行\u003c/h2\u003e\n\n\u003cp\u003eHVM 的结构与 VMS（virtual machine system）几乎完全相同，\n区别在于：\u003cstrong\u003e\u003cmark\u003e更多的指令是解释执行的，而不是直接在硬件上执行的\u003c/mark\u003e\u003c/strong\u003e。\n因此 HVM 效率要比 VM 低，但好处是，实际中更多的第三代架构是满足这个模型的。\n例如，PDP-10 can host a HVM monitor, although it cannot host a VM monitor [3].\u003c/p\u003e\n\n\u003cp\u003e放松定义，需要将敏感指令划分为两个 not necessarily disjoint subsets.\u003c/p\u003e\n\n\u003ch2 id=\"82-对敏感指令进一步分类\"\u003e8.2 对敏感指令进一步分类\u003c/h2\u003e\n\n\u003ch3 id=\"user-sensitive\"\u003euser sensitive\u003c/h3\u003e\n\n\u003cp\u003eAn instruction i is said to be user sensitive if there\nexists a state S = (E, u, P, R) for which i is control\nsensitive or behavior sensitive.\u003c/p\u003e\n\n\u003cp\u003eThat is, an instruction i is user control sensitive if the\ndefinition given earlier for control sensitivity holds,\nwith ml in that definition set to user. The instruction\ni is user behavior sensitive if the definition for location\nsensitivity holds with the mode of states S1 and S2\nequal to user. Then i is user sensitive if it is either user\ncontrol sensitive or user location sensitive. Intuitively,\nthese are instructions which cause difficulty when\nexecuted from user mode.\u003c/p\u003e\n\n\u003ch3 id=\"supervisor-sensitive\"\u003esupervisor sensitive\u003c/h3\u003e\n\n\u003cp\u003eIn a parallel fashion, an instruction i is supervisor\nsensitive if there exists a state S = (E, s, P, R) for which\ni is control sensitive or behavior sensitive.\u003c/p\u003e\n\n\u003ch2 id=\"83-定理三\"\u003e8.3 定理三\u003c/h2\u003e\n\n\u003cp\u003eTHEOREM 3. A hybrid virtual machine monitor may\nbe constructed for any conventional third generation\nmachine in which the set of user sensitive instructions\nare a subset of the set of privileged instructions.\u003c/p\u003e\n\n\u003cp\u003eIn order to argue the validity of the theorem, it is\nfirst necessary to characterize the HVM monitor. The\ndifference between a HVM monitor and a VMM is that,\nin the nVM monitor, all instructions in virtual supervisor\nmode will be interpreted. Otherwise the HVM\nmonitor is the same as the VM monitor. Equivalence\nand control can then be guaranteed as a result of two\nfacts. First, as in the VMM, the nVM monitor always\neither has control, or gains control via a trap, whenever\nthere is an attempt to execute a behavior sensitive or\ncontrol sensitive instruction. Second, by the same argument\nas before, there exist interpretive routines for all\nthe necessary instructions. Hence, all sensitive instructions\nare caught by the HVM and simulated.\u003c/p\u003e\n\n\u003cp\u003eTo aemonstrate the utility of the concept of a HVM\nmonitor, we present the following.\u003c/p\u003e\n\n\u003cp\u003eExample. The PDP-10 instruction JRST 1, (return to\nuser mode) is a supervisor control sensitive instruction\nwhich is not a privileged instruction. Hence the\nPDP-10 cannot host a VMM. However, since all user\nsensitive instructions are privileged, it can host a hybrid\nvirtual machine monitor [3].\u003c/p\u003e\n\n\u003ch1 id=\"9-总结\"\u003e9. 总结\u003c/h1\u003e\n\n\u003cp\u003e本文提出了一种第三代计算机系统的规范化（或正式）模型。\n基于这个模型，我们推导出了判断一个特定的第三代计算机是否能支持 VMM 的必要和充分条件。\u003c/p\u003e\n\n\u003cp\u003e前期研究 [4, 5] 已经指出了第三代机器的虚拟化所需的架构特性，\n而我们基于本文提出的规范化方法，建立了评估这一问题的更加精确的机制及所需满足的条件。\n这些结果已经用在 UCLA，例如，评估 DEC PDP-11/45 以及对它做出修改，这样就能建立一个虚拟机系统[13]。\u003c/p\u003e\n\n\u003cp\u003e虽然这个模型确实抓住了第三代计算机的本质，但出于展示目的，其中一些地方做了简化。\n从经验上来说，我们认为该模型缺失的东西，例如 I/O 资源和指令、异步事件、或更加复杂的内存映射机制，\n能作为这个基础模型的直接扩展（extensions）加入进来[6, 12]。\u003c/p\u003e\n\n\u003cp\u003e另外，近期计算机系统架构领域的一些工作已经提出了一些无需传统 VMM 解释软件（interpretive software）开销，\n直接支持虚拟机的虚拟化架构提案[2, 6, 8, 10, 11]。\n本文提出的方法，可能也能用于验证他们提出的架构及其是否能支持虚拟化。\u003c/p\u003e\n\n\u003ch2 id=\"致谢\"\u003e致谢\u003c/h2\u003e\n\n\u003cp\u003eThe authors would like to thank\ntheir colleagues at both UCLA and Harvard for many\nhelpful discussions on various aspects of virtual computer\nsystems. Special thanks are due to Professor G.\nEstrin of tJCLA and Dr. U.O. Gagliardi of Harvard\nUniversity and Honeywell Information Systems for\ntheir advice and encouragement during the preparation\nof this paper. In addition, the authors wish to\nthank the referees for their constructive comments on an\nearlier draft of this paper.\u003c/p\u003e\n\n\u003ch1 id=\"附录\"\u003e附录\u003c/h1\u003e\n\n\u003cp\u003eSeveral results were used in the statement of the\nproof without being explicitly demonstrated. They are\nthe lemmas which follow.\u003c/p\u003e\n\n\u003cp\u003eLEMMA 1. Innocuous instructions, as executed by the\nvirtual machine system, obey the equivalence property.\nPROOF SKETCH. Let i be any innocuous instruction.\u003c/p\u003e\n\n\u003cp\u003eLet S be any state in the real machine, and S’ = f(S).\nS = (e|r, m, p, r) and S’ = (e’ [ r’, m’, p’, r’). However,\nfrom the definition off, e’|r’ = e | r and p’ = p, and\nthe bounds in both r’ and r are the same. By definition,\ni(S) cannot depend on m or 1 (the relocation part of r),\nand all other parameters are the same for both S and S’.\u003c/p\u003e\n\n\u003cp\u003eHence it must be the case that i(S) = i(S’). Q.E.D.\u003c/p\u003e\n\n\u003cp\u003eLEMMA 2. Sensitive instructions, as interpreted by\nthe virtual machine system, obey the equivalence property.\u003c/p\u003e\n\n\u003cp\u003ePROOF SKETCH. By assumption, any sensitive instruction\ni traps. By construction, the interpretation is\ndone correctly, given all necessary parameter specifications.\nThe values of locations E I R are not changed\nby the trap. The values of P and R are saved in El0].\u003c/p\u003e\n\n\u003cp\u003eThe “simulated mode” value M is stored by the VMM.\nHence all necessary information is present, so proper\ninterpretation can be performed. Q.E.D.\u003c/p\u003e\n\n\u003cp\u003eLEMMA 3. Given that all single instructions obey the\nequivalence property, any finite sequence of instructions\nalso obeys the equivalence property.\u003c/p\u003e\n\n\u003cp\u003ePROOF. The proof is by induction on the length of\nthe instruction sequence. Each sequence can be thought\nof as a unary operator on the set C of states. The basis of\nthe lemma is true by the hypothesis in the statement of the lemma.\u003c/p\u003e\n\n\u003cp\u003eIn the following, parentheses will be used only\nsparingly. Hence f(g(h(S))) may be written fgh(S).\nInduction Step. Let i be any instruction, and t any\nsequence of length less than or equal to k, and t’ the\ninstruction sequence corresponding to t.\u003c/p\u003e\n\n\u003cp\u003eThen by the induction and lemma hypothesis, we\nhave that, for any state S, there exists an instruction\nsequence t’ such that\nf(t(S)) = t’(f(S)) and f(i(S)) = i’(f(S))\nwhere the primed operators may or may not be the\nsame instructions or sequences as the unprimed operators.\nThe instruction sequences may differ since some of\nthe instructions expressed by the unprimed operators\nmay be sensitive. The primed operator includes the\ninterpretation sequences for those instructions.\nWe are given\u003c/p\u003e\n\n\u003cp\u003ef t ( s ) = t’f(s). (1)\u003c/p\u003e\n\n\u003cp\u003eClearly then,\u003c/p\u003e\n\n\u003cp\u003ei’ft(S) = i’t’f(S). (2)\u003c/p\u003e\n\n\u003cp\u003eBut, for any S, we are given\u003c/p\u003e\n\n\u003cp\u003ei’f(S) = fi(S). (3)\u003c/p\u003e\n\n\u003cp\u003eSo, letting t(S) in (2) be S in (3), we have, combining\u003c/p\u003e\n\n\u003cp\u003e(3) with the left side of (2):\u003c/p\u003e\n\n\u003cp\u003efit(S) = i’t’f(S).\u003c/p\u003e\n\n\u003cp\u003eSince the sequence may be any sequence of length\nk + 1, and the above is the desired induction step\nresult, the lemma is proven. Q.E.D.\u003c/p\u003e\n\n\u003ch1 id=\"references\"\u003eReferences\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eBuzen, J.P., and Gagliardi, U.O. The evolution of virtual machine architecture. Proc. NCC 1973, AHPS Press, Montvale, N.J., pp. 291-300.\u003c/li\u003e\n  \u003cli\u003eGagliardi, U.O., and Goldberg, R.P. Virtualizable architectures, Proc. ACM AICA lnternat. Computing Symposium, Venice, Italy, 1972.\u003c/li\u003e\n  \u003cli\u003eGalley, S.W. PDP-10 Virtual machines. Proc. ACM SIGARCH-SIGOPS Workshop on Virtual Computer Systems, Cambridge, Mass., 1969.\u003c/li\u003e\n  \u003cli\u003eGoldberg, R.P. Virtual machine systems. MIT Lincoln Laboratory Rept. No. MS-2686 (also 28L-0036), Lexington, Mass., 1969.\u003c/li\u003e\n  \u003cli\u003eGoldberg, R.P. Hardware requirements for virtual machine systems. Proc. Hawaii hlternat. CoJ~lbrence on Systems Sciences, Honolulu, Hawaii, 1971.\u003c/li\u003e\n  \u003cli\u003eGoldberg, R.P. Architectural principles for virtual computer systems. Ph.D. Th., Div. of Eng. and Applied Physics, Harvard U., Cambridge, Mass., 1972.\u003c/li\u003e\n  \u003cli\u003eGoldberg, R.P. (Ed). Proc. ACM SIGARCH-SIGOPS Workshop on Virtual Computer Systems, Cambridge, Mass., 1973.\u003c/li\u003e\n  \u003cli\u003eGoldberg, R.P. Architecture of virtual machines. Proc. NCC 1973, AFIPS Press, Montvale, N.J., pp. 309-318.\u003c/li\u003e\n  \u003cli\u003eIBM Corporation. IBM Virtual Machine Facility/370: Planning Guide, Pub. No. GC20-1801-0, 1972.\u003c/li\u003e\n  \u003cli\u003eLauer, H.C., and Snow, C.R. Is supervisor-state necessary?  Proc. ACM AICA lnternat. Computing Symposium, Venice, Italy, 1972.\u003c/li\u003e\n  \u003cli\u003eLauer, H.C., and Wyeth, D. A recursive virtual machine architecture. Proc. ACM SIGARCH-SIGOPS Workshop on Virtual Computer Systems, Cambridge, Mass., 1973.\u003c/li\u003e\n  \u003cli\u003eMeyer, R.A., and Seawright, L.H. A virtual machine timesharing system. IBM Systems J. 9, 3 (1970).\u003c/li\u003e\n  \u003cli\u003ePopek, G.J., and Kline, C. Verifiable secure operating system software. Proc. NCC 1974, AFIPS Press, Montvale, N.J., pp. 145-151.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/how-nat-traversal-works-zh/\"\u003e\u003cspan\u003e« [译] NAT 穿透是如何工作的：技术原理及企业级实践（Tailscale, 2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/bpf-datapath-extensions-for-k8s-zh/\"\u003e\u003cspan\u003e[译] 为 K8s workload 引入的一些 BPF datapath 扩展（LPC, 2021） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-11-19T00:00:00Z",
  "Author": "Arthur Chiao"
}