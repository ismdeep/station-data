{
  "Source": "arthurchiao.art",
  "Title": "OVS Deep Dive 4: OVS netdev and Patch Port",
  "Link": "https://arthurchiao.art/blog/ovs-deep-dive-4-patch-port/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eOVS Deep Dive 4: OVS netdev and Patch Port\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2017-01-07 | Last Update \u003c/p\u003e\n  \n  \u003cp\u003eThis post introduces OVS patch port, and compares it with linux veth pair.\u003c/p\u003e\n\n\u003ch2 id=\"1-what-is-ovs-patch-port\"\u003e1. What is OVS \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eAn OVS patch port is like a physical cable plugged from\none (OVS) switch port to another. It is quite similar to Linux veth\npair.\u003c/p\u003e\n\n\u003cp\u003eIndeed, in some situations, these two could be used alternatively. Such as,\nin OpenStack compute node, there are usually two ovs bridges: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebr-int\u003c/code\u003e and\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebr-eth1\u003c/code\u003e. In the early OpenStack releases (prior to Kilo), the two are connected\nby linux veth pair. In newer releases (such as, releases after Liberty),\nhowever, the default connection fashion has been changed to OVS patch port.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/ovs-compute-node.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.1.1. Network On OpenStack Compute Node[1])\u003c/p\u003e\n\n\u003cp\u003eAccording to some materials[2,3][6][7], the reason of switching from\nlinux veth pair to OVS patch port is for performance consideration. Apart from\nthis, at least for OpenStack, the patch port brings another great benefit:\ntraffic of instances (VMs) will not get down during OVS neutron agent restart -\nthis is what \u003cstrong\u003e\u003cem\u003egraceful OVS agent restart[4,5]\u003c/em\u003e\u003c/strong\u003e achieves in newer\nOpenStack releases.\u003c/p\u003e\n\n\u003cp\u003eHowever, there is also a disadvanage of patch port: you could no longer capture\npackets on the patch ports using tools such as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e - like what you have\nbeen doing on linux veth pair ports.\u003c/p\u003e\n\n\u003cp\u003eIn this article, we will dig into the source code and get to know why it behaves\nthis way.\u003c/p\u003e\n\n\u003ch2 id=\"2-ovs-netdev\"\u003e2. OVS \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/netdev_rx_tx.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.2.1 network device xmit/receive\u003c/p\u003e\n\n\u003cp\u003eA network device (e.g. physical NIC) has two ends/parts, one end works in kernel, which is responsible\nfor sending/receiving, and the other end in userspace, which manages the kernel\nparts, such as changing device MTU size, disabling/enabling queues, etc. The communication\nbetween kernel and userspace space is usually through \u003ca href=\"\"\u003enetlink\u003c/a\u003e or \u003ca href=\"\"\u003eioctl\u003c/a\u003e (deprecated).\u003c/p\u003e\n\n\u003cp\u003eFor virtual network devices, such as TUN/TAP, the working process is similar, execpt that\nthe packets a TAP device receives is not from outside, but from the userspace; and\nthe packets a TAP device sends does not go to outside, but goes to userspace.\u003c/p\u003e\n\n\u003cp\u003eIn OVS,\nA \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct netdev\u003c/code\u003e instance represents a network device in OVS userspace, it is\nused for controlling the kernel end of this device, it maybe a\nphysical NIC, a TAP device, or other types.\u003c/p\u003e\n\n\u003cp\u003eDefined in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/netdev-provider.h\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* A network device (e.g. an Ethernet device) */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e                         \u003cspan class=\"cm\"\u003e/* Name of network device. */\u003c/span\u003e\n    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* Functions to control\n                                                this device. */\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en_txq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003en_rxq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eref_cnt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e                        \u003cspan class=\"cm\"\u003e/* Times this devices was opened. */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_class\u003c/code\u003e is a general abstraction of all network devices, defined in\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/netdev-provider.h\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* Type of netdevs in this class, e.g. \u0026#34;system\u0026#34;, \u0026#34;tap\u0026#34;, \u0026#34;gre\u0026#34;, etc. */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003eis_pmd\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"cm\"\u003e/* If \u0026#39;true\u0026#39; then this netdev should be polled by PMD threads. */\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/* ## Top-Level Functions ## */\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003einit\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erun\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ewait\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/* ## netdev Functions ## */\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003econstruct\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edestruct\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erxq_recv\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_rxq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003edp_packet_batch\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ebatch\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erxq_wait\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_rxq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erx\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAny device type has to implement the methods in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_class\u003c/code\u003e before being used\n(became a \u003cstrong\u003enetdev provider\u003c/strong\u003e) , so there are implementations for different\ntypes on different platforms: for Linux paltform, for BSD paltform, for windows,\netc.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/netdev_providers.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.2.2. netdev providers\u003c/p\u003e\n\n\u003cp\u003eFig.2.2 depicts the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev providers\u003c/code\u003e in OVS.\u003c/p\u003e\n\n\u003cp\u003eIn the following, we only talk about the linux netdevs, vport netdevs, and\ndpdk netdevs.\u003c/p\u003e\n\n\u003ch3 id=\"21-linux-netdev\"\u003e2.1. Linux netdev\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct linux_netdev\u003c/code\u003e defined in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/netdev-linux.c\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eLinux netdevs are network devices (the userspace part) on Linux platform, call\nthe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e method on a netdev will send the packet from userspace to linux\nkernel (see \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux_netdev_send()\u003c/code\u003e), then the packet will be handled by the\nkernel part (device drivers) of that device. It includes the following three types:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_linux_class\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003edefault linux network device type, for physical devices. Also called\n\u003cstrong\u003eexternal\u003c/strong\u003e devices because they send packets out and receives from out)\u003c/p\u003e\n\n    \u003cp\u003ethe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e method of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem\u003c/code\u003e device will\nsend packet to kernel through \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_PACKET\u003c/code\u003e [9] socket.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_internal_class\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003eA special kind of virutual network devices on linux. The functionality is\nmuch the same as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem\u003c/code\u003e type, but does not directly send/receive from\noutside as physical NICs do, and some differences in calculating statistics.\u003c/p\u003e\n\n    \u003cp\u003ethe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e method of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal\u003c/code\u003e device will\nsend packet to kernel through \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_PACKET\u003c/code\u003e [9] socket.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_tap_class\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003eLinux tap device.\u003c/p\u003e\n\n    \u003cp\u003ethe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend()\u003c/code\u003e method of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap\u003c/code\u003e device will\nsend packet to kernel through \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite\u003c/code\u003e system call on the userspace part of\nthe tap device (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(netdev-\u0026gt;tap_fd, data, size)\u003c/code\u003e).\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eDeclaration of 3 linux netdevs, where \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNETDEV_LINUX_CLASS\u003c/code\u003e is a macro to\ninitialize all callbacks:\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_linux_class\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNETDEV_LINUX_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"s\"\u003e\u0026#34;system\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_construct\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_get_stats\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_get_features\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_get_status\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_tap_class\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNETDEV_LINUX_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"s\"\u003e\u0026#34;tap\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_construct_tap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_tap_get_stats\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_get_features\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_get_status\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_internal_class\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNETDEV_LINUX_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"s\"\u003e\u0026#34;internal\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_linux_construct\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_internal_get_stats\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e                  \u003cspan class=\"cm\"\u003e/* get_features */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_internal_get_status\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"22-vport-netdev\"\u003e2.2 vport netdev\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/netdev-vport.c\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eA vport is an OVS abstracted virtual port in OVS datapath.\nvport netdevs are the userspace part of OVS vports. It is divided into two\ncategories: \u003cstrong\u003etunnel type\u003c/strong\u003e and \u003cstrong\u003epatch type\u003c/strong\u003e.\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003etunnel class\u003c/p\u003e\n\n    \u003cp\u003eused for overlay network.\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egeneve\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egre\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evxlan\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elisp\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estt\u003c/code\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch_class\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003eused for forwarding packets between different OVS bridges.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eRegistration of the tunnel vports is in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_vport_tunnel_register()\u003c/code\u003e,\nand \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch\u003c/code\u003e port in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_vport_patch_register()\u003c/code\u003e. Both of them will then\ncall \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_register_provider()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\n\u003cspan class=\"nf\"\u003enetdev_vport_tunnel_register\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003evport_class\u003c/span\u003e \u003cspan class=\"n\"\u003evport_classes\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTUNNEL_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;geneve\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;genev_sys\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_geneve_build_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"n\"\u003enetdev_tnl_push_udp_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_geneve_pop_header\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTUNNEL_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;gre\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;gre_sys\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_gre_build_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"n\"\u003enetdev_gre_push_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_gre_pop_header\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTUNNEL_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;vxlan\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;vxlan_sys\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_vxlan_build_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                \u003cspan class=\"n\"\u003enetdev_tnl_push_udp_header\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetdev_vxlan_pop_header\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTUNNEL_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;lisp\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;lisp_sys\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTUNNEL_CLASS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;stt\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;stt_sys\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eARRAY_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003evport_classes\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enetdev_register_provider\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003evport_classes\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\n\u003cspan class=\"nf\"\u003enetdev_vport_patch_register\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003evport_class\u003c/span\u003e \u003cspan class=\"n\"\u003epatch_class\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;patch\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n              \u003cspan class=\"n\"\u003eVPORT_FUNCTIONS\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eget_patch_config\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eset_patch_config\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                              \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e}};\u003c/span\u003e\n    \u003cspan class=\"n\"\u003enetdev_register_provider\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003epatch_class\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enetdev_class\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eFollowing is the simplified init macro:\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#define VPORT_FUNCTIONS(GET_CONFIG, SET_CONFIG,             \\\n                        GET_TUNNEL_CONFIG, GET_STATUS,      \\\n                        BUILD_HEADER,                       \\\n                        PUSH_HEADER, POP_HEADER)            \\\n    netdev_vport_alloc,                                     \\\n    netdev_vport_construct,                                 \\\n    BUILD_HEADER,                                           \\\n    PUSH_HEADER,                                            \\\n    POP_HEADER,                                             \\\n                                                            \\\n    NULL,                       \u003c/span\u003e\u003cspan class=\"cm\"\u003e/* send */\u003c/span\u003e\u003cspan class=\"cp\"\u003e                  \\\n    NULL,                       \u003c/span\u003e\u003cspan class=\"cm\"\u003e/* send_wait */\u003c/span\u003e\u003cspan class=\"cp\"\u003e             \\\n    ...\n\u003c/span\u003e    \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e                   \u003cspan class=\"cm\"\u003e/* rx_recv */\u003c/span\u003e                  \\\n    \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e                   \u003cspan class=\"cm\"\u003e/* rx_drain */\u003c/span\u003e\n\n\n\u003cspan class=\"cp\"\u003e#define TUNNEL_CLASS(NAME, DPIF_PORT, BUILD_HEADER, PUSH_HEADER, POP_HEADER)   \\\n    { DPIF_PORT,                                                               \\\n        { NAME, false,                                                         \\\n          VPORT_FUNCTIONS(get_tunnel_config,                                   \\\n                          set_tunnel_config,                                   \\\n                          get_netdev_tunnel_config,                            \\\n                          tunnel_get_status,                                   \\\n                          BUILD_HEADER, PUSH_HEADER, POP_HEADER) }}\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eNote\u003c/strong\u003e that the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esend\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erx_recv\u003c/code\u003e callbacks of all vport type netdevs are all \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNULL\u003c/code\u003es.\nWhat this means is that: \u003cstrong\u003ea packet could not be sent from userspace to kernel\nvia vport netdevs, and vport does not receive packets from physical NICs\u003c/strong\u003e.\nActually, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evports\u003c/code\u003e are used to either forward packets\ninside datapath, or send packets out by calling kernel method\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev_queue_xmit()\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"23-dpdk-netdev\"\u003e2.3 DPDK netdev\u003c/h3\u003e\n\n\u003cp\u003eDPDK netdevs are netdev implementation on DPDK platform.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edpdk_class\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edpdk_ring_class\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edpdk_vhost_class\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edpdk_vhost_client_class\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"3-patch-port\"\u003e3. Patch Port\u003c/h2\u003e\n\n\u003cp\u003ePatch port as a kind of vport type \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev\u003c/code\u003e is registered by calling\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_register_provider(const struct netdev_class *new_class)\u003c/code\u003e in\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/netdev-vport.c\u003c/code\u003e. It initializes and registers a new netdev provider. After\nregistration, new netdevs of that type can be opened using \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_open()\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch\u003c/code\u003e port accepts exactly one parameter: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epeer\u003c/code\u003e - the other side of the\nconnection. This is much like linux \u003cstrong\u003eveth pair\u003c/strong\u003e. Actually, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e was\nintroduced as a drop-in replacement of linux veth pair [10][11] - originally for connecting\ntwo datapaths - now for connecting different OVS bridges.\u003c/p\u003e\n\n\u003ch3 id=\"31-how-patch-port-works\"\u003e3.1 How Patch Port Works\u003c/h3\u003e\n\n\u003cp\u003eAs we mentioned in Section 2, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e does not implement the send and\nreceive methods of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_class\u003c/code\u003e, so a packet could not be sent from userspace\nto kernel vport via \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e, and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e will not receives packets\nfrom physical devices. Actually, a patch port only receives packets from other\nports of ovs bridge (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eofproto\u003c/code\u003e), and the (\u003cstrong\u003eONLY?\u003c/strong\u003e) action for incoming packets\nfrom a patch port to datapath, is to “OUTPUT” it to the peer side of this patch\nport. In this way, it connects the two sides (usually, two OVS bridges).\u003c/p\u003e\n\n\u003cp\u003eThe “OUTPUT” action just delivers the packet from one vport to another, no\nmemcpy, no context switching, and all work done in datapath, \u003cstrong\u003eno kernel\nnetwork stack involved\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"32-why-packets-not-captured-on-patch-ports\"\u003e3.2 Why Packets Not Captured On Patch Ports\u003c/h3\u003e\n\n\u003cp\u003eTo understand why we could see the patch ports on host with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifconfig\u003c/code\u003e, but\ncould not capture packets with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e, we need some knowledge about the\nunderlying theories of packet filtering. I’m not going too deep into packet\ncapturing, that’s something I’d like to discuss in a separate post.\u003c/p\u003e\n\n\u003cp\u003eIn short, packet capturing is done by inserting some filtering code into kernel\nat run time, the code will copy each incoming packet at \u003cstrong\u003elink layer\u003c/strong\u003e, sends it\nto a buffer, then userspace applications (such as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e) will read the buffer and get the packets.\nSome key components to accomplish this:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003enetwork tap\u003c/strong\u003e: for intercepting and coping packets at L2 (in device drivers)\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003efiltering mechanism\u003c/strong\u003e: what BPF (LSF) provides\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eFig.3.1 depicts how BPF works[12]:\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/bpf_overview.jpg\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.3.1 BPF overview[12]\u003c/p\u003e\n\n\u003cp\u003eIn Linux, the packet copying occurs in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetif_rx()\u003c/code\u003e, which delivers a packet\nfrom L2 driver to Linux network stack (L3).\u003c/p\u003e\n\n\u003cp\u003eIn Linux kernel code \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet/core/dev.c\u003c/code\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/**\n *  netif_rx    -   post buffer to the network code\n *\n *  This function receives a packet from a device driver and queues it for\n *  the upper (protocol) levels to process. It always succeeds.\n *\n *  return values:\n *  NET_RX_SUCCESS  (no congestion)\n *  NET_RX_DROP     (packet was dropped)\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003enetif_rx\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etrace_netif_rx_entry\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003enetif_rx_internal\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWhen packets go through a physical (e.g. eth0) or virtual device (e.g. tun/tap),\nthe device drivers delivers the packet to kernel stack by calling\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetif_rx(skb)\u003c/code\u003e, and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrace_netif_rx_entry(skb)\u003c/code\u003e does the packet filtering and\ncopying work. In contrast, when a packet is received by a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epatch port\u003c/code\u003e, the patch port\ndriver (receive method) will not call \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetif_rx()\u003c/code\u003e (because the packet’s\ndestination is the peer side, not kernel stack), and there is no no filtering\ncode in its driver (as we’ve mentioned, the driver just delivers the packet to\nits peer vport), so packet could not be copied.\u003c/p\u003e\n\n\u003cp\u003eThis is why when \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e on patch ports, there is not any output.\u003c/p\u003e\n\n\u003cp\u003eThe same reason explains why some network utilities, such as \u003cem\u003etcpdump\u003c/em\u003e, \u003cem\u003enetstat\u003c/em\u003e,\nnot work on DPDK-managed physical ports:\nin this scenario, after packets are received on physical ports, instead of going\nthrough kernel stack by calling \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetif_rx()\u003c/code\u003e, they are forwarded directly to\nuserspace.\u003c/p\u003e\n\n\u003ch3 id=\"33-patch-port-performance-todo-update\"\u003e3.3 Patch Port Performance (TODO: update)\u003c/h3\u003e\n\n\u003cp\u003eAs has been pointed out in [2][3][6][7], there is great performance boost in OpenStack\ncompute node when replacing linux veth pair with OVS patch port for connections\nbetween \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebr-int\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebr-phy\u003c/code\u003e. Then, the question is: where the performance\nincrease comes from?\u003c/p\u003e\n\n\u003cp\u003eHere are some explanations from [5]: it “saves an extra lookup in the kernel\ndatapath and an extra trip to userspace to figure out what happens in the second\nbridge”.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eI’ll come back to update this later.\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"http://docs.openstack.org/developer/neutron/devref/openvswitch_agent.html\"\u003edoc: Open vSwitch L2 Agent\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://mail.openvswitch.org/pipermail/ovs-discuss/2013-December/032222.html\"\u003edisuss: OVS performance with Openstack Neutron\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://docs.google.com/spreadsheets/d/1ZGra_MszBlL0fNsFqd4nOvh1PsgWu58-GxEeh1m1BPw/edit#gid=1328396036\"\u003edatasheet: Kilo vs Liberty - OVS Agent restart outage\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://bugs.launchpad.net/openstack-manuals/+bug/1487250\"\u003epatch: Graceful OVS Agent Restart\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://bugs.launchpad.net/neutron/+bug/1383674\"\u003ediscuss: Restarting neutron openvswitch agent causes network hiccup by throwing away all flows\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://www.opencloudblog.com/?p=386\"\u003eSwitching Performance - Chaining OVS bridges\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://www.opencloudblog.com/?p=96\"\u003eSwitching Performance – Connecting Linux Network Namespaces\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.kernel.org/doc/Documentation/networking/filter.txt\"\u003eLinux Socket Filtering aka Berkeley Packet Filter (BPF)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.google.com.hk/url?sa=t\u0026amp;rct=j\u0026amp;q=\u0026amp;esrc=s\u0026amp;source=web\u0026amp;cd=2\u0026amp;ved=0ahUKEwie5eTuo8bSAhUCn5QKHVLwCCgQFggaMAE\u0026amp;url=http%3A%2F%2Fwww.microhowto.info%2Fhowto%2Fsend_an_arbitrary_ethernet_frame_using_an_af_packet_socket_in_c.html\u0026amp;usg=AFQjCNE3nRXs5NgRg4UdO1BG4DKchJp4Dw\u0026amp;sig2=fkF60J6TCgwO-GjQ_dPEiA\"\u003emicroHOWTO: Send an arbitrary Ethernet frame using an AF_PACKET\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/openvswitch/ovs/commit/2158888d8d8f3b4c00dcf979390a19fa7fcf7942\"\u003eOVS commit: remove veth pair driver\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/openvswitch/ovs/commit/4fe648861042761f3a132ba8a998aacd03ad8e4a\"\u003eOVS commit: add patch port\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"www.vodun.org/papers/net-papers/van_jacobson_the_bpf_packet_filter.pdf\"\u003eBPF Packet Filter: A New Approach for Packet Capturing (1992)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/ovs-deep-dive-3-datapath/\"\u003e\u003cspan\u003e« OVS Deep Dive 3: Datapath\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/ovs-deep-dive-5-datapath-tx-offloading/\"\u003e\u003cspan\u003eOVS Deep Dive 5: Datapath and TX Offloading »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2017-01-07T00:00:00Z",
  "Author": "Arthur Chiao"
}