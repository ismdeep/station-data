{
  "Source": "arthurchiao.art",
  "Title": "[译] 编程语言中的 6 种内存模型（2016）",
  "Link": "https://arthurchiao.art/blog/memory-models-underlie-programming-languages-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 编程语言中的 6 种内存模型（2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-11-09 | Last Update 2019-11-09\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自一篇英文博客 \u003ca href=\"http://canonical.org/~kragen/memory-models/\"\u003eThe memory models that underlie programming\nlanguages\u003c/a\u003e，截至本文翻译时，原文最\n后一次更新是在 2016 年。\u003c/p\u003e\n\n\u003cp\u003e作者似乎是计算机和编程领域的老兵，除了高屋建瓴地分析这 6 种横跨半个多\n世纪的内存模型之外，还举重若轻地点评了如下几十种语言、库或系统（大部\n分都是编程语言）：Forth、morden Lisps、Haskell、ML、Python、Ruby、PHP5、Lua、\nJavaScript、Erlang、Smalltalk、Java、C#、Assembly、Awk、Perl4、Tcl、Octave、\nMatlab、APL、J、K、PV-WAVE IDL、Lush、S、S-Plus、R、Numpy、Pandas、OpenGL、Linda\n、C++、D、MUMPS、Wheat、Prolog、miniKANREN 等等。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003ch2 id=\"目录\"\u003e目录\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"#ch_1\"\u003e引言\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_2\"\u003e序曲：只有原子变量的程序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_3\"\u003eCOBOL 内存模型：嵌套结构 —— 内存就像一张税单\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_4\"\u003eLISP 内存模型：对象图 —— 内存是一张带标签的有向图\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_5\"\u003eFORTRAN 内存模型：并行数组 —— 内存是一系列数组\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_6\"\u003e茶歇：为什么没有 Lua、Erlang 和 Forth 内存模型？\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_7\"\u003e磁带内存模型：管道 —— 写入、等待数据、继续写入\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_8\"\u003eMULTICS 内存模型：目录 —— 内存是一棵树\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_9\"\u003eSQL 内存模型：关系 —— 内存是一个可变、多值有限函数集\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ch_10\"\u003e注释\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e编程语言发展至今，大约产生了 6 种主要的内存概念化（conceptualizations of memory\n）模型，我将其称为 \u003cstrong\u003e“内存模型”（memory models）\u003c/strong\u003e[2]。从历史渊源上看，这 6 种\n模型中有 3 种来自于 \u003cstrong\u003e20 世纪 50 年代（1950s）最重要的 3 种编程语言\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003eCOBOL\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eLISP\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eFORTRAN\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外 3 种来自于在历史上有重要地位的\u003cstrong\u003e数据存储系统\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e磁带\u003c/strong\u003e（magnetic tap）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eUnix-style 层级文件系统\u003c/strong\u003e（Unix-style hierarchical filesystems）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e关系数据库\u003c/strong\u003e（relational databases）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e相比于\u003cstrong\u003e语法\u003c/strong\u003e（syntax）乃至\u003cstrong\u003e类型系统\u003c/strong\u003e（type systems），\u003cstrong\u003e内存模型\u003c/strong\u003e在更深层次\n上\u003cstrong\u003e决定了一门编程语言能够做什么或不能做什么\u003c/strong\u003e。但奇怪的是，我还从未看到过介绍这\n些模型的好文章，因此我决定自己来写一篇。在本文中，我会介绍一些主流模型之外的其他\n选项（possible alternatives to the mainstream options），以及为什么它们很有趣。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"1-引言\"\u003e1. 引言\u003c/h1\u003e\n\n\u003cp\u003e每种现代编程环境都会在一定程度上\u003cstrong\u003e处理所有这六种内存模型\u003c/strong\u003e，这也是为什么我们的系\n统如此复杂和难以理解的原因之一。\u003c/p\u003e\n\n\u003cp\u003e下面的内容中，我将分析这些内存模型如何：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e表示实体的属性\u003c/strong\u003e（represent attributes of entities）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e与数据序列化交互\u003c/strong\u003e（interact with data serialization）\u003c/li\u003e\n  \u003cli\u003e执行（perform）程序的解耦\u003c/li\u003e\n  \u003cli\u003e支持（support）程序的解耦\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e解耦的实现方式是对程序按功能分块，限制每块功能的可访问范围（局部化或私有化）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"2-序曲只有原子变量的程序\"\u003e2. 序曲：只有原子变量的程序\u003c/h1\u003e\n\n\u003cp\u003e我们先从一门简单的编程语言开始，这种语言\u003cstrong\u003e没有结构化数据（structure data）的能力\u003c/strong\u003e，\n因为它没有闭包（closure）和数据类型（data types），只有\u003cstrong\u003e固定精度的数值类型（\nnumber）和布尔类型\u003c/strong\u003e变量。\u003c/p\u003e\n\n\u003ch2 id=\"21-定义示例语言example-language\"\u003e2.1 定义示例语言（example language）\u003c/h2\u003e\n\n\u003cp\u003e下面是这种语言的 \u003cstrong\u003eBNF 定义\u003c/strong\u003e，其\u003cstrong\u003e语义（semantics）\u003c/strong\u003e\n和常规语言差不多，并且有必要的运算符优先级，而不是由\u003cstrong\u003e语法（grammar）\u003c/strong\u003e隐式提供：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eprogram ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e def\u003cspan class=\"k\"\u003e*\u003c/span\u003e\ndef ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;def\u0026#34;\u003c/span\u003e name \u003cspan class=\"s2\"\u003e\u0026#34;(\u0026#34;\u003c/span\u003e args \u003cspan class=\"s2\"\u003e\u0026#34;)\u0026#34;\u003c/span\u003e block\nargs ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e | name \u003cspan class=\"s2\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003e args\nblock ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;{\u0026#34;\u003c/span\u003e statement\u003cspan class=\"k\"\u003e*\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;}\u0026#34;\u003c/span\u003e\nstatement ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;return\u0026#34;\u003c/span\u003e exp \u003cspan class=\"s2\"\u003e\u0026#34;;\u0026#34;\u003c/span\u003e | name \u003cspan class=\"s2\"\u003e\u0026#34;:=\u0026#34;\u003c/span\u003e exp \u003cspan class=\"s2\"\u003e\u0026#34;;\u0026#34;\u003c/span\u003e | exp \u003cspan class=\"s2\"\u003e\u0026#34;;\u0026#34;\u003c/span\u003e | nest\nnest ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;if\u0026#34;\u003c/span\u003e exp block | \u003cspan class=\"s2\"\u003e\u0026#34;if\u0026#34;\u003c/span\u003e exp block \u003cspan class=\"s2\"\u003e\u0026#34;else\u0026#34;\u003c/span\u003e block | \u003cspan class=\"s2\"\u003e\u0026#34;while\u0026#34;\u003c/span\u003e exp block\nexp ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e name | num | exp op exp | exp \u003cspan class=\"s2\"\u003e\u0026#34;(\u0026#34;\u003c/span\u003e exps \u003cspan class=\"s2\"\u003e\u0026#34;)\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;(\u0026#34;\u003c/span\u003e exp \u003cspan class=\"s2\"\u003e\u0026#34;)\u0026#34;\u003c/span\u003e | unop exp\nexps ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e | exp \u003cspan class=\"s2\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003e exps\nunop ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;!\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;-\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;~\u0026#34;\u003c/span\u003e\nop ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e logical | comparison | \u003cspan class=\"s2\"\u003e\u0026#34;+\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;*\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;-\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;/\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;%\u0026#34;\u003c/span\u003e\nlogical ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;||\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026amp;\u0026amp;\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026amp;\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;|\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;^\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;\u0026lt;\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026gt;\u0026gt;\u0026#34;\u003c/span\u003e\ncomparison ::\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;==\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026gt;\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026lt;=\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;\u0026gt;=\u0026#34;\u003c/span\u003e | \u003cspan class=\"s2\"\u003e\u0026#34;!=\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这门语言能够实现下面的程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003ef2c\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef2c\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e40\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"n\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef2c\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"n\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef2c\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e98\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"n\"\u003esay\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ef2c\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e212\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"22-规定进一步限制\"\u003e2.2 规定进一步限制\u003c/h2\u003e\n\n\u003cp\u003e这里我们规定：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e递归是非法的\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e这门编程语言是\u003cstrong\u003e及早求值\u003c/strong\u003e的（eager/greedy evaluation, 与惰性求值 lazy\nevaluation 相反）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e函数调用是按值传递\u003c/strong\u003e（call-by-value），这和大部分编程语言是一样的\u003c/li\u003e\n  \u003cli\u003e调用子过程（subroutine）时，所有变量默认（implicitly）都是局部变量，并且会被\n零值初始化（zero-initialized），因此\u003cstrong\u003e子函数不会产生任何副作用\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"23-抽象能力和使用场景\"\u003e2.3 抽象能力和使用场景\u003c/h2\u003e\n\n\u003cp\u003e在这些限制条件下，这种编程语言只能用来实现\u003cstrong\u003e有限状态机\u003c/strong\u003e（FSM）。你可以将其\u003cstrong\u003e制\n作成一个电路\u003c/strong\u003e（compile it into a circuit）。（不是一个理论上的电路，在计算\n机科学中，理论上的电路只是一个布尔表达式有向无环图；而我们这里所说的是一个真正\n的物理电路，可以集成寄存器。）\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e程序中出现的每个变量可以分配一个寄存器\u003c/li\u003e\n  \u003cli\u003e每个子过程调用可以分配一个寄存器存放其返回值\u003c/li\u003e\n  \u003cli\u003e另外还需要一个额外的寄存器存放\u003cstrong\u003e程序计数器\u003c/strong\u003e（PC）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在一台有几 GB 内存的机器上运行这种语言写的代码并不会带来多大好处，因为它\u003cstrong\u003e只能用\n到程序中声明的那些变量\u003c/strong\u003e，其他的变量是无法用到的（never be able to use any more\nvariables than the ones it started with）。\u003c/p\u003e\n\n\u003cp\u003e但这并不是说这种语言就毫无用处 —— 很多有用的计算都可以在\u003cstrong\u003e有限空间\u003c/strong\u003e（finite\nspace）内完成。但话说回来，这种编程语言的抽象能力还是非常弱的，即使是面向有限空\n间计算的场景。\u003c/p\u003e\n\n\u003ch2 id=\"24-访问内存方式\"\u003e2.4 访问内存方式\u003c/h2\u003e\n\n\u003cp\u003e可以使用该语言提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epeek()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epoke()\u003c/code\u003e 函数来访问内存 —— \u003cstrong\u003e读/写给定数值地址\n（numerical address） 的单个字节\u003c/strong\u003e。例如，基于这两个函数实现字符串拷贝：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003estrcpy\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003es\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003epoke\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epeek\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"n\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这或多或少就是\u003cstrong\u003e机器码\u003c/strong\u003e（machine code）和\n\u003ca href=\"https://en.wikipedia.org/wiki/Forth_(programming_language)\"\u003e\u003cstrong\u003eForth\u003c/strong\u003e\u003c/a\u003e 能提供的基础设施。\n但是，大部分编程语言不会止步于此，事实上很多语言并不会提供 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epeek()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epoke()\u003c/code\u003e\n函数。相反，它们会在\u003cstrong\u003e朴素的、单一维度的字节数组\u003c/strong\u003e（austere uniform array of bytes）\n之上提供某种形式的结构。\u003c/p\u003e\n\n\u003cp\u003e例如，即使只能对有限状态机进行编程，但只要有了\u003cstrong\u003e嵌套记录（nested-record）、数组\n（array）和 union\u003c/strong\u003e 等数据结构，就能使语言的能力得到很大加强。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"3-cobol-内存模型嵌套结构--内存就像一张税单\"\u003e3. COBOL 内存模型：嵌套结构 —— 内存就像一张税单\u003c/h1\u003e\n\n\u003ch2 id=\"31-历史起源\"\u003e3.1 历史起源\u003c/h2\u003e\n\n\u003cp\u003e在 COBOL 中，一个数据对象要么是\u003cstrong\u003e不可分割的\u003c/strong\u003e（indivisible）—— 例如字符串或数值\n这种特定大小的基础对象 —— 要么是一个\u003cstrong\u003e聚合类型\u003c/strong\u003e（aggregate），例如：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e记录（record）\u003c/strong\u003e：将不同类型的数据对象相邻存放到一起\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e联合（union）\u003c/strong\u003e：同一位置能够存放不同类型的数据对象，但对于任意一个给定的\nunion 对象，其中存储的只能是\u003cstrong\u003e唯一一种\u003c/strong\u003e特定类型的对象\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e数组（array）\u003c/strong\u003e：同一类型的数据对象连续地存储在一起\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e为了在 60 多年后的今天以“事后诸葛亮”的方式来更简单地解释 COBOL 提供的概念，下\n面的内容中我会在较大程度上偏离 COBOL 专业术语和分类。）\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这或多或少代表了计算机商业数据处理（business data processing on computers）的\n\u003cstrong\u003e穿孔卡片\u003c/strong\u003e（punched-card）和\u003cstrong\u003e纸张表格\u003c/strong\u003e（paper-form）的起源，而这些是继承了\nHollerith 在 \u003cstrong\u003e1890 年美国人口普查\u003c/strong\u003e（1890 US census）中使用的自动化系统。\u003c/p\u003e\n\n\u003ch2 id=\"32-嵌套记录内存模型\"\u003e3.2 嵌套记录内存模型\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/nested-ballpoint-circles.jpg\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eCOBOL \u003cstrong\u003e程序的任何部分\u003c/strong\u003e都可以在\u003cstrong\u003e任意时间\u003c/strong\u003e读或修改这个表格的\u003cstrong\u003e字段层级中的任何\n部分\u003c/strong\u003e（any part of this hierarchy of form fields）。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e我不确定你\u003cstrong\u003e是否真的能修改输入文件中的数据\u003c/strong\u003e（想象一下，这里的输入文件都是人口\n普查记录表，你在对记录表做处理/统计的时候，真的能在表格之上随意做修改吗？再推\n广到编程范式，应该允许对传入的数据做修改吗？译者注）。但我对此处不是太关心，因\n此不再展开。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e在这种\u003cstrong\u003e嵌套记录（nested-record）内存模型\u003c/strong\u003e中，如果有同一类型的多个实体（several\nentities of the same type），那每个实体都会对应一个这种类型的记录（record），其\n中有与存储这些信息相关的子字段（subfields）和字节大小（size）；因此，\u003cstrong\u003e一个给\n定实体的所有信息在内存中都是连续的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e可以很容易地从存储媒介（例如磁盘、磁带或穿孔卡片）加载这些连续的数据块（\u003cstrong\u003e“反序\n列化”\u003c/strong\u003e），或向存储媒介存放数据块（\u003cstrong\u003e“序列化”\u003c/strong\u003e）。如果同时在内存中有多个实体，\n它们可能会以数组的形式存放。\u003c/p\u003e\n\n\u003cp\u003e一个实体的\u003cstrong\u003e类型中的某个属性\u003c/strong\u003e —— 例如，银行账户中的“账户类型”（account type）属\n性 —— 是\u003cstrong\u003e用一个地址偏移对（a pair of byte offsets）表示\u003c/strong\u003e的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e第一个 offset 表示这个属性在实体中的\u003cstrong\u003e起始地址\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e第二个 offset 表示这个属性在实体中的\u003cstrong\u003e结束地址\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e例如，一个 account 对象可能有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 字段，对应对象中的 10-35 字节，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 可能又包括一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e 子字段，占据的是 18-26 字节。\u003c/p\u003e\n\n\u003ch2 id=\"33-设计特点\"\u003e3.3 设计特点\u003c/h2\u003e\n\n\u003cp\u003e这种模型中有一些很有趣的东西，其中一些设计甚至要比我们现在在用的方式还要好。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e首先，这种内存模型中没有指针\u003c/strong\u003e。这意味着：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e无法做动态内存分配\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e不会解引用一个空指针\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e不会出现野指针覆写（overwrite）某些内存区域的情况（如果两个变量通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eREDEFINES\u003c/code\u003e\n语句共享存储，那其中一个可以覆写另一个；但 tagged unions 可以避免这种问题）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e不会出现内存耗尽\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e不会有别名（aliasing）\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e不会为指针消耗内存（no memory spent on pointers）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但另一方面，这也意味着：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e定义每个数据结构占用多少内存是不受限制的\u003c/strong\u003e（arbitrary limit）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e复用内存的风险\u003c/strong\u003e与让两个程序同时使用这段内存是一样的（没有动态内存分配和回收，译者注）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e嵌套记录在内存使用上很经济，只需要将当前要用的实体加载到内存中\u003c/strong\u003e。这意味着完全\n可以在只有 KB 级内存的机器上处理 MB 级别的数据 —— 实际上人们在 20 世纪 50 年代（\n1950s）就是用 COBOL 这么做的。\u003c/p\u003e\n\n\u003ch2 id=\"34-内存布局\"\u003e3.4 内存布局\u003c/h2\u003e\n\n\u003cp\u003e内存布局：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e整个程序除了最外层（top level）之外，程序中的每段数据（字段、子字段、数据项或\n者其他任何数据片段）都有一个\u003cstrong\u003e唯一的父字段或父记录\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e每段\u003cstrong\u003e数据都包含在其父字段或父记录的数据之中\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e最外层表示整个程序的内存\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在这种内存模型中，如果程序的某个部分有一段\u003cstrong\u003e私有/局部内存\u003c/strong\u003e（例如栈指针或私有静\n态变量），那程序就能够将某些实体作为\u003cstrong\u003e私有实体/局部实体\u003c/strong\u003e，只需要将这些实体存储\n在这段私有/局部内存就行了。这\u003cstrong\u003e对创建局部临时变量来说非常有用\u003c/strong\u003e，这些变量不会影\n响到程序其他部分的执行。\u003c/p\u003e\n\n\u003cp\u003e但是，嵌套记录内存模型并没有提供一种将程序某个部分中的\u003cstrong\u003e某个属性（attribute）声明\n为私有\u003c/strong\u003e的方式的。\u003c/p\u003e\n\n\u003ch2 id=\"35-对其他编程语言的影响\"\u003e3.5 对其他编程语言的影响\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003eALGOL\u003c/strong\u003e（可能是 ALGOL-58，也可能是 ALGOL-60）\u003cstrong\u003e采用了 COBOL 的这种“记录”（\nrecord）模型\u003c/strong\u003e作为它的主要数据结构机制（data structuring mechanism），而不是采用\n数组（array）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e在 ALGOL 之后，几乎所有其他编程语言都继承了这个系统\u003c/strong\u003e，虽然具体形式上可能有些\n差别。例如，\u003cstrong\u003eC 语言\u003c/strong\u003e几乎完全包含了这个数据结构操作符集合（set of\ndata-structuring operators）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e原生类型，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003echar\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e结构体（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estructs\u003c/code\u003e）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunions\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e数组（arrays）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但是，C 还有子函数，这些函数不仅可以带参数，而且还可以递归，这对栈分配等等来说是\n不可或缺的；另外，C 还有指针。这些对 COBOL 模型的扩展或多或少来自 LISP。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_4\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"4-lisp-内存模型对象图--内存是一张带标签的有向图\"\u003e4. LISP 内存模型：对象图 —— 内存是一张带标签的有向图\u003c/h1\u003e\n\n\u003ch2 id=\"41-特点lisp-vs-cobol\"\u003e4.1 特点（LISP vs COBOL）\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/lisp-1-ballpoint-circles.jpg\" width=\"30%\" height=\"30%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eLISP\u003c/strong\u003e（虽然现在叫 Lisp，但 1959 年的时候还叫 LISP）\u003cstrong\u003e和 COBOL 的差异不能更大\n了：\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003eLISP 不仅有指针，而且几乎只有指针\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eLISP 唯一的数据结构\u003c/strong\u003e是一个叫 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econs\u003c/code\u003e 的东西：一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econs\u003c/code\u003e 包含两个指针，一个称\n为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecar\u003c/code\u003e，另一个称为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecdr\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e每个变量的值都是一个指针\u003c/strong\u003e：可能是一个指向 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econs\u003c/code\u003e 的指针，一个指向符号（\nsymbol）的指针，一个指向数值（number）的指针（某些 Lisps 使用 pointer-tagging\n小把戏来避免在内存中真正地创建一个数值对象），甚至是指向一个子过程（subroutine\n）的指针，但不管是那种情况，它都是一个指针\u003c/li\u003e\n  \u003cli\u003eLISP 还支持\u003cstrong\u003e带参数的子过程\u003c/strong\u003e。事实上，这个特性加上它的\u003cstrong\u003e尾调用优化\u003c/strong\u003e特性，你\n能够编写在完全不改变变量的情况下做任何事情的程序。（这大部分归功于 Martin 和\nNewell 的 IPL，但 \u003cstrong\u003eLISP 是公认的 IPL 精神的继承者\u003c/strong\u003e。）\u003c/li\u003e\n  \u003cli\u003e由于可以向任何对象添加任意数量的指针别名（pointer alias），而通过任何一个\n别名就可以修改这个对象，因此在 \u003cstrong\u003eLISP 中没有唯一的父结构\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"42-优缺点\"\u003e4.2 优缺点\u003c/h2\u003e\n\n\u003cp\u003e这种模型极度灵活，使得编写下列方面的程序非常简单：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e自然语言解析\u003c/li\u003e\n  \u003cli\u003e程序解释和编译\u003c/li\u003e\n  \u003cli\u003e穷举搜索（exhaustive search of possibilities）\u003c/li\u003e\n  \u003cli\u003e符号数学（symbolic mathematics）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外，这种模型还使得\u003cstrong\u003e只需要编写一个数据结构（例如，红黑树），就可以将其应用到不\n同类型的数据对象上\u003c/strong\u003e（Lisp 是动态类型，编写程序时不需要指明数据类型，译者注）。\n作为对比，从 COBOL 衍生的语言（例如 C）在这种泛型（generalization）上就有非常大的\n困难，导致程序员不得不为新数据类型实现那些著名的数据结构和算法，而其中其实包含了\n大量的重复代码（某种程度上，C++ 的模板可以做类似的事情，译者注）。\u003c/p\u003e\n\n\u003cp\u003eLISP 内存模型的缺点包括：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e内存管理很差，程序很容易占用大量内存\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e容易产生 bug（bug-prone）\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e编写高效的代码需要\u003cstrong\u003e很高的天赋\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e指针管理成本高\u003c/strong\u003e：由于每个对象都是通过指针来识别的，因此每个对象都可以有别名（\nevery object can be aliased）。每个变量都可能是空指针（null pointer）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e大量类型错误\u003c/strong\u003e：由于一个指针可以指向任何东西，因此到处存在\u003cstrong\u003e类型错误\u003c/strong\u003e（指向一个某\n种类型的对象的指针存储在另一个变量中，后者很可能是另一种类型）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e执行效率低\u003c/strong\u003e：传统的对象-图（object-graph）语言使用\u003cstrong\u003e运行时类型检测\u003c/strong\u003e来避免调试时间\n的膨胀，这进一步降低了程序的执行速度\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"43-查找对象和修改对象\"\u003e4.3 查找对象和修改对象\u003c/h2\u003e\n\n\u003cp\u003e在这种对象-图（object-graph）内存模型中，如果有同一类型的多个实体，那每个实体会\n通过一个指针识别；要访问一个实体中的某个具体属性（attribute），需要沿着对象图\n中这个指针的开始位置往后寻找。\u003c/p\u003e\n\n\u003cp\u003e例如，如果有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount\u003c/code\u003e 对象，我们用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealist\u003c/code\u003e 表示。\u003cstrong\u003e要查找这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount\u003c/code\u003e 对\n象中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 对象\u003c/strong\u003e（可能和其他 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount\u003c/code\u003e 对象共享，因为一个持有人可\n以有多个账户），需要\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e沿着 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealist\u003c/code\u003e 往后走，直到找到一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econs\u003c/code\u003e，这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econs\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecar\u003c/code\u003e 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eACCOUNT-HOLDER\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e取这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecar\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecdr\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e要进一步查找 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e 对象\u003c/strong\u003e，你可能会在一个包含了\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 各种属性的向量内进行查找（index into a vector of\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e attributes）对应的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e 的指针，这个指针指向的（\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e 对象）可能是一个字符串，也可能是一个符号（symbol），因为在早期\nLisps 中没有字符串。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e更新 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e\u003c/strong\u003e 可能涉及到：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e修改原有字符串\u003c/li\u003e\n  \u003cli\u003e更新属性向量，让 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emiddle-name\u003c/code\u003e 指向新的字符串\u003c/li\u003e\n  \u003cli\u003e构造一个指向新 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 对象的新 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealist\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e具体取决于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 是否在多个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount\u003c/code\u003e 对象之间共享，以及是否希望其\n他 account 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 也被更新。\u003c/p\u003e\n\n\u003ch2 id=\"44-垃圾回收\"\u003e4.4 垃圾回收\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e垃圾回收（GC）在这类语言中是必不可少的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e从 McCarthy 在 1959 年发明 LISP，到 1980 年 Lieberman 和 Hewitt 提出新一代的垃圾\n回收算法，在这中间的二十多年，所有使用\u003cstrong\u003e标记有向图（labeled-directed-graph）\u003c/strong\u003e的\n内存模型通常都将 1/3 到 1/2 的时间用在垃圾回收上。在此期间，某些特意设计为多核的\n计算机会将专门的核用于垃圾回收。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e对象-图（Object-graph）语言重度依赖垃圾回收器\u003c/strong\u003e，这不仅是因为它们\u003cstrong\u003e相比于修改现有对\n象更倾向于分配新对象\u003c/strong\u003e，还因为它们\u003cstrong\u003e一般都会有大量的指针\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e从 COBOL 衍生的语言\n，例如 C 和 Golang，相比之下对垃圾回收期的依赖没有那么强烈\u003c/strong\u003e，因为它们：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e分配的次数更少，分配的也都是大对象\u003c/li\u003e\n  \u003cli\u003e倾向于在原有的对象上做修改，而不是新分配一个修改过的版本\u003c/li\u003e\n  \u003cli\u003e只要有可能，程序员都倾向于嵌套记录（nest records），而不是用指针将这些字段连\n起来，因此只有在多态（polymorphism）、nullability（可以认为是多态的一种特殊情\n况）或者别名（aliasing）的时候才会用到指针\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"45-序列化\"\u003e4.5 序列化\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e对对象图（object graph）做序列化有点棘手\u003c/strong\u003e，因为：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e其中可能包含循环引用（circular references）\u003c/li\u003e\n  \u003cli\u003e想序列化的部分可能包含对我们不想序列化的部分的引用\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这两种情况都需要做特殊处理。\u003c/p\u003e\n\n\u003cp\u003e例如，在某些系统中，一个类实例（class instance）会包含一个对这个类的引用（\nreference to its class），而类不仅包含对所有类方法的当前版本的引用，还包含\u003cstrong\u003e对它\n的超类（superclass）的引用\u003c/strong\u003e，而你可能不想每个序列化的对象中都对这个类的整个字节\n码（the entire bytecode for the class）做序列化。\u003c/p\u003e\n\n\u003cp\u003e另外，当反序列化两个共享同一引用（前面提到的两个账户共享同一个账户持有人）的对象\n时，你可能想保持这种共享性质。\u003c/p\u003e\n\n\u003cp\u003e因此，解决这些问题的方式可能会随着\u003cstrong\u003e做序列化的目的\u003c/strong\u003e的不同而不同。\u003c/p\u003e\n\n\u003ch2 id=\"46-私有属性\"\u003e4.6 私有属性\u003c/h2\u003e\n\n\u003cp\u003e与嵌套记录（nested-record）模型类似，对象图（object-graph）模型\u003cstrong\u003e允许将一个特定\n实体的所有属性定义为局部（local）的\u003c/strong\u003e —— 这些局部属性只会对程序的某一部分可见，\n不会泄露给程序的其他部分 —— \u003cstrong\u003e但无法将所有实体的某个特定属性定义为私有的（\nprivate）\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e但是，和嵌套记录不同，\u003cstrong\u003e对象图模型减少了节点的内存占用（memory size），\n这给面向对象的继承（object-oriented inheritance）打开了大门\u003c/strong\u003e，后者能够提供某些\n私有属性（private attributes），虽然它自身也有其他严重的问题。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/object-graph-ballpoint-circles.jpg\" width=\"35%\" height=\"35%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"47-对其他编程语言的影响\"\u003e4.7 对其他编程语言的影响\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e最近流行的一些编程语言都使用这种模型\u003c/strong\u003e。这不仅包括各种现代 Lisp，还包括\nHaskell、ML、Python、Ruby、PHP5、Lua、JavaScript、Erlang 以及 Smalltalk。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这些语言无一例外地都对内存中的\u003cstrong\u003e对象类型（set of object types）进行了扩展\u003c/strong\u003e，\n不再仅仅是原来简单的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(cdr, car)\u003c/code\u003e 对。\u003c/li\u003e\n  \u003cli\u003e通常情况下，它们还至少包含了\u003cstrong\u003e指针数组\u003c/strong\u003e（arrays of pointers）和\u003cstrong\u003e哈希表\u003c/strong\u003e，后\n者将字符串或指针映射到其他指针。哈希表尤其重要，如果一段运行中的代码使用了某实\n体，在大部分情况下，哈希表都能提供一种\u003cstrong\u003e在不影响代码正常运行的前提下，向这些实\n体添加新属性（new properties）的能力\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e其中一些语言还包括\u003cstrong\u003e带标签的 union（tagged union）\u003c/strong\u003e和\u003cstrong\u003e不可变记录\u003c/strong\u003e（immutable records）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/edge-labeled-graph-ballpoint-circles.jpg\" width=\"35%\" height=\"35%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e总的来说，在这些语言中，只能沿着图的边缘（graph edges）的指向行走，而且边缘标\n签（edge labels）\u003cstrong\u003e从源节点看是唯一的\u003c/strong\u003e（一个 cons 只有一个 car，不会有两个或十个）\n，\u003cstrong\u003e但从目的节点看不是唯一的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果要求在源节点和目的节点看都是唯一的，那 Ted\nNelson 的 ZigZag 数据结构是一个例子。UnQL，在某种程度上，是一次完全消除唯一性限\n制的尝试（n exploration of eliminating the uniqueness constraint entirely）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eJava （和 C#）使用的是这种内存模型的一个细微变种\u003c/strong\u003e：Java 内存中有\n非指针类型的东西，称为 “primitive types”。这意味着无法在常规的容器类型（\ncontainer types）中存储这些变量，虽然近些年 Java 极力试图掩盖这一缺陷。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_5\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"5-fortran-内存模型并行数组--内存是一系列数组\"\u003e5. FORTRAN 内存模型：并行数组 —— 内存是一系列数组\u003c/h1\u003e\n\n\u003ch2 id=\"51-背景和特点\"\u003e5.1 背景和特点\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/flat-parallel-arrays-ballpoint-circles.jpg\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eFORTRAN 是为\u003cstrong\u003e物理现象的数值建模（numerical modeling of physical phenomena）\u003c/strong\u003e设\n计的，这是最早需要使用计算机的场景之一，通常称为\u003cstrong\u003e“科学计算”（scientific\ncomputing）\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e在当时，\u003cstrong\u003e科学计算机\u003c/strong\u003e（scientific computers）和\u003cstrong\u003e商业计算机\u003c/strong\u003e（business\ncomputers，使用 COBOL 编程）是有很大区别的，\u003cstrong\u003e科学计算机的特点包括\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e使用二进制（binary）而不是十进制（decimal）\u003c/li\u003e\n  \u003cli\u003e没有 byte 的概念，只有固定长度 word（fixed-length words）\u003c/li\u003e\n  \u003cli\u003e支持浮点数学\u003c/li\u003e\n  \u003cli\u003e计算更快，但 I/O 较慢\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e通常，这些模型涉及到在\u003cstrong\u003e很大的数值数组\u003c/strong\u003e（large numerical arrays）之上的大量线性\n代数运算（linear algebra），要求计算地越快越好，而这也正是 FORTRAN（\u003cstrong\u003e后来称为\nFortran\u003c/strong\u003e）的优化方向：\u003cstrong\u003e高效地利用多维数组\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eFORTRAN 不仅\u003cstrong\u003e没有递归子过程、指针和记录\u003c/strong\u003e，它\u003cstrong\u003e最\n初连子过程（subroutines）都没有\u003c/strong\u003e！后来，我印象中是在 FORTRAN II 里，它才支持了参数\n，参数可以是数组，而这是 ALGOL 直到 ALGOL 60 还一直无法恰当实现的东西。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/flat-parallel-arrays-columns-ballpoint-circles.jpg\" width=\"25%\" height=\"25%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e因为\u003cstrong\u003e数组是唯一非基元类型（non-primitive type）\u003c/strong\u003e，因此数组元素唯一可能的类型就\n是那些 \u003cstrong\u003eprimitive types，例如整数和浮点数\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"52-三种查找-middle-name-算法\"\u003e5.2 三种查找 middle-name 算法\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/memory-models/shared-parallel-arrays-columns-ballpoint-circles.jpg\" width=\"30%\" height=\"30%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这个在 FORTRAN 世界中演进的并行数组（parallel-array）内存模型中，如果有同一类\n型的多个实体，那任意一个实体都可以通过数组的一个整数偏移量（integer offset）来识别，\n而访问一个特定实体的某个属性就是先通过一个偏移量在数组中找到该实体，然后在实体中\n通过另一个偏移量找到这个属性。\u003c/p\u003e\n\n\u003cp\u003e如果时间暂时回退到 20 世纪 50 年代，我们有一个数组，其中存放的元素都是基元字符类\n型（primitive character type），并且只使用并行数组这一种数据结构，那前面介绍的寻\n找 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount-holder\u003c/code\u003e 中的 middle name 的例子就能够用以下任意一种方式实现：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e方式一（针对 account-holder 的各属性分别存储在独立数组中的场景，译者注）\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  IM = IMDNAM(ICCHLD(IACCTN))\n  IA = ISTR(IM)\n  IE = ISTR(IM+1)\n\n  # 基本思想就是先找到存储 middle-name 属性的数组，然后再找到这个账户的\n  # middle-name 成员在该数组中的起始地址和结束地址，译者注）\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e在完成以上 4 次数组索引的查找操作（array-indexing operations）之后，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCCHARS\u003c/code\u003e\n  字符数组的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[IA, IE)\u003c/code\u003e 区间对应的就是 account-holder 的 middle-name 了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e方式二（针对 account-holder 的属性没有存储在独立数组中的场景，译者注）\u003c/p\u003e\n\n    \u003cp\u003e如果 account-holder 的属性没有存储在各自独立的数组中（很有可能），那可以这样\n  做：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  IM = IMDNAM(IACCTN)\n  IA = ISTR(IM)\n  IE = ISTR(IM+1)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e后面两步和方式一相同。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e方式三\u003c/p\u003e\n\n    \u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCMDNAM\u003c/code\u003e 而不是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIMDNAM\u003c/code\u003e，前者是一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNx12\u003c/code\u003e 的字符数组，每个\n  12-character 的列用于每个账户的 middle-name（with one 12-character column\n  for the middle name of each account holder）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"53-并行数组内存模型\"\u003e5.3 并行数组内存模型\u003c/h2\u003e\n\n\u003cp\u003e在这种内存模型中，对于\u003cstrong\u003e作为参数传给子过程（subroutine）的数组或者共享数组\u003c/strong\u003e，子过\n程能够访问这些数组的任意位置（any index）的，能够随机地对其进行读或写操作，并\n且没有次数限制。\u003c/p\u003e\n\n\u003cp\u003e这就是\u003cstrong\u003e“可以用任何语言进行 FORTRAN 式编程”（programming FORTRAN in any language\n）\u003c/strong\u003e表达的意思：几乎每种编程语言中都有数组（arrays of primitive types）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e即使是在汇编语言或 Forth 中，数组都不是很难构造。\u003c/li\u003e\n  \u003cli\u003eAwk、Perl4 和 Tcl 还额外提供了字典（dictionaries），虽然这些并不是一等对象（\nfirst-class objects），因为这些语言并不是对象图（object-graph）语言，但在对实\n体的属性进行排序方面，这些字典完全可以取代数组，允许用字符串而不是数组（by\nstrings instead of integers）来识别实体。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e一个有趣的细节是，\u003cstrong\u003e在简单的情况下，并行数组在机器层面产生的代码和嵌套记录模型（\nnested-record model）中通过指针引用的结构体成员产生的代码几乎是一模一样的\u003c/strong\u003e。例\n如，下面是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb-\u0026gt;foo\u003c/code\u003e 产生的代码，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e 是一个指向结构体变量的指针，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoo\u003c/code\u003e 是一\n个 32 位的成员变量：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e  40050c:   8b 47 08                mov    0x8(%rdi),%eax\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e而下面是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoos[b]\u003c/code\u003e 产生代码，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e 是 32 位数组 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoos\u003c/code\u003e 的一个索引（index）：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003e  400513:   8b 04 bd e0 d8 60 00    mov    0x60d8e0(,%rdi,4),%eax\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e以上两种情况下，这个代表某个属性的立即常量（immediate constant）都被加到一个存放\n在寄存器中的变量上，最终的结果就是我们在寻找的的那个实体。机器码层面的唯一区别是\n，在第二种情况下，我们将索引乘以了元素大小（item size），因此这个常量会更大一些\n。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e另外需要注意，两者的指令格式是不同的，而且不是所有 CPU 架构都支持如此大的常\n量偏移；在某些机器上，必须将数组的起始地址，或者某个足够大的结构体某字段偏移，\n加载到一个寄存器中。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.the-adam.com/adam/rantrave/st02.pdf\"\u003eAdam N. Rosenberg 提倡永远用并行数组风格来编程\n\u003c/a\u003e，并且用一本书的厚度来解释为什\n么应该这样做。我并不认为这一个好主义，但他是我见过的这种思想的最佳现代捍卫者。\u003c/p\u003e\n\n\u003ch2 id=\"54-优缺点\"\u003e5.4 优缺点\u003c/h2\u003e\n\n\u003ch3 id=\"优点\"\u003e优点\u003c/h3\u003e\n\n\u003cp\u003e简单来说，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e并行数组是缓存友好的\u003c/li\u003e\n  \u003cli\u003e支持不同属性有不同的可见度\u003c/li\u003e\n  \u003cli\u003e支持设置 watchpoints\u003c/li\u003e\n  \u003cli\u003e提供的序列是有意义的（provide a sequence that can be meaningful）\u003c/li\u003e\n  \u003cli\u003e支持多维索引（属性可以是 entity tuple，而并不仅仅是单个 entity）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e另外，并行数组还支持\u003cstrong\u003e编写子过程来在属性之上进行抽象\u003c/strong\u003e，因为它们\u003cstrong\u003e在运行时才对每\n个属性进行具体化\u003c/strong\u003e：你可以写一个能够应用到任何属性的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esum\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecovariance\u003c/code\u003e 函数 —\n— 这一点尤其有趣：虽然并行数组不支持让某个特定实体对某段特定程序可见（private）\n，但它支持让实体（变量）的某个 \u003cstrong\u003e属性\u003c/strong\u003e（attribute）是私有的（private）。\u003c/p\u003e\n\n\u003ch3 id=\"缺点\"\u003e缺点\u003c/h3\u003e\n\n\u003cp\u003e我不喜欢并行数组，因为它们非常容易导致错误。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e编译器\u003cstrong\u003e无法分辨数组的某个给定的索引是否合法\u003c/strong\u003e，调试器和垃圾回收器也不能。\u003c/li\u003e\n  \u003cli\u003e并行数组本质上\u003cstrong\u003e容易导致类型错误\u003c/strong\u003e（type error）—— 将某种类型的实体的某个标识\n符存储在一个另一种类型的数组中 —— 相比于编译时错误消息或运行时错误消息，这种方\n式会更容易导致错误（尤其是在没有打开数组范围检查的情况下）。\u003c/li\u003e\n  \u003cli\u003e另外，由于并行数组在\u003cstrong\u003e运行时具体化的是属性（attributes）而不是实体（entities）\u003c/strong\u003e，\n因此\u003cstrong\u003e创建和删除实体很容易出错\u003c/strong\u003e，\u003cstrong\u003e子过程倾向于有很多的参数（增加了抽象的\n成本，导致子过程的实现变长）\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e与嵌套记录模型中类似的 arbitrary limits 问题（即对内存中数组的大小没有施加限制\n，可以为任意大小，见上文。译者注）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e并行数组的序列化非常容易和高效，尤其是如果你不考虑 CPU 架构间的可移植性；但是它\n们一般是\u003cstrong\u003e以属性为维度\u003c/strong\u003e的，需要同时对涉及到的所有实体的某个属性进行序列化或反序\n列化。\u003c/p\u003e\n\n\u003ch2 id=\"55-对其他编程语言的影响\"\u003e5.5 对其他编程语言的影响\u003c/h2\u003e\n\n\u003cp\u003eFortran 并不是唯一一种推荐用并行数组组织内存的语言。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eOctave、Matlab、APL、J、K、PV-WAVE IDL、Lush、S、S-Plus 和 R 很大程度上都是面\n向并行数组（parallel-array-oriented）的编程语言\u003c/li\u003e\n  \u003cli\u003eNumpy、Pandas、和 OpenGL 是面向并行数组的库（parallel-array-oriented libraries）\u003c/li\u003e\n  \u003cli\u003e我前面还提到，Perl4、awk、和 Tcl 在一定程度上也是面向并行数组的\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上提到的某些语言为了\u003cstrong\u003e减少并行数组不一致（getting out of sync）的风险\u003c/strong\u003e，将数\n组设计为一旦创建就\u003cstrong\u003e不可变的\u003c/strong\u003e（immutable once populated），或者至少鼓励创建新数\n组；Pandas、K 和 那些并行字典衍生语言（parallel-dictionary variant）减少类型错误\n风险的方式是\u003cstrong\u003e鼓励用非数值方式访问数组\u003c/strong\u003e（index your arrays by things that aren’\nt integers）。\u003c/p\u003e\n\n\u003cp\u003e在并行数组模型中，我们可以很方便地将对某个实体集合进行循环的操作封装到一个叶子函\n数（leaf functions，即不会再调用其他自定义函数的函数），这可以降低解释开销（\ninterpretation overhead），因此即使是在 1960s 年代的某个解释器上 APL 都可以做高\n性能数值计算任务（high-performance numerical work）。\u003c/p\u003e\n\n\u003cp\u003e现代硬件的某些特性限制了并行数组取得更高的性能的可能性：CPU 和内存速度之间越来越\n大的 gap、GPU 的 SIMT 架构、CPU（为了增加 ALU 硅片面积相比于控制硅片面积的比例而\n增加的）SIMD 指令。最终，\u003cstrong\u003e游戏程序员开始\u003c/strong\u003e以“面向数据的设计”（data-oriented\ndesign）和（某种程度的）“实体系统”（entity systems）的名义\u003cstrong\u003e回归到并行数组\u003c/strong\u003e。\n\u003cstrong\u003e数值（科学）计算从未抛弃过并行数组\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_6\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"6-茶歇为什么没有-luaerlang-和-forth-内存模型\"\u003e6. 茶歇：为什么没有 Lua、Erlang 和 Forth 内存模型？\u003c/h1\u003e\n\n\u003cp\u003e以上就是对应以下三种基本\u003cstrong\u003e数据结构\u003c/strong\u003e的三种内存模型：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e记录（record）\u003c/li\u003e\n  \u003cli\u003e链表（linked list）\u003c/li\u003e\n  \u003cli\u003e数组（array）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但是，有几种其他的数据类型也是适用范围非常广泛的：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eLua 以有限映射表（finite maps）的方式组织内存；也叫字典（dictionaries），Lua\n中称为 “tables”\u003c/li\u003e\n  \u003cli\u003eErlang 基于\u003cstrong\u003e主动无共享进行模型\u003c/strong\u003e（active shared-nothing processes），将每个进\n程的消息放到各自的消息队列，这其实是 Hewitt 和 Agha 的 actor 模型的一个变种\u003c/li\u003e\n  \u003cli\u003eForth 基于栈（stack）组织\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e那么，为什么没有 Lua、Erlang 和 Forth 内存模型？我其实也不知道为什么。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eLua 和 Erlang 本质上是面向对象图（object-graph oriented）的语言\u003c/li\u003e\n  \u003cli\u003eForth 程序经常只使用并行数组，虽然 Forth dictionary 是链表（linked list） 的一\n个变种\u003c/li\u003e\n  \u003cli\u003e也许你可以构建一个系统，其中程序的内存视角是一个哈希表，或者某种类型的 actor\n变种（而不是对象图），或者两个或更多个栈。Linda 是这样的一次探索，它在 actor\n之间通过一个 tuple space 进行非图结构的通信（non-graph-structured\ncommunication ），也许这可以进一步扩展成一门完整的语言\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但本文不会就此深入展开，而是再来看其他几种已有的重要内存模型。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_7\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"7-磁带内存模型管道--写入等待数据继续写入\"\u003e7. 磁带内存模型：管道 —— 写入、等待数据、继续写入\u003c/h1\u003e\n\n\u003ch2 id=\"71-管道\"\u003e7.1 管道\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003eUnix 管道（pipe）在所有内存模型中是最简单的\u003c/strong\u003e（而且这些管道都是模拟相应的硬件\n）。管道支持的唯一几个操作是：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e写一个字节（或者，某些管道允许写多个字节，算是一种优化）\u003c/li\u003e\n  \u003cli\u003e读一个字节\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e除此之外可能还包括关闭操作（从任何一端）。（真实的磁带读写都是以块为单位，但我们\n这里不考虑这种情况）。通常情况下，不会在同一个程序中同时读和写同一个管道。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e事实证明，这种只能追加（append-only）的存储对某些算法来说完全足够了\u003c/strong\u003e；\nMapReduce 的工作方式不会比这种方式复杂多少，其他的，比如典型的令牌化问题（\ntokenization with lex）使用的就是这样一个最简接口作为它的输入。\u003c/p\u003e\n\n\u003cp\u003ePython 的迭代器（iterators ）和生成器（generators）、C++ STL 的前向迭代器（\nforward iterators）、D 语言的 forward ranges，以及 Golang 的 channel\n都是这种管道或 channel 的例子，它们都是纯顺序化的数据访问。\u003c/p\u003e\n\n\u003ch2 id=\"72-例子示例语言--管道实现合并排序\"\u003e7.2 例子：示例语言 + 管道实现合并排序\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e如果一种编程语言的内存模型完全基于管道，那将会是什么样子？\u003c/strong\u003e需要有从管道中读取\n数据元素（可能都只能是 primitive 类型的数据）和将数据元素写入管道的操作。考虑我\n们在文章开头定义的示例编程语言。给定管道和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eempty\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eget\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eput\u003c/code\u003e 子过程，我们就\n可以写一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emerge\u003c/code\u003e 函数，用于\u003cstrong\u003e合并排序\u003c/strong\u003e（merge sorting），虽然这样的实现并没有\nPython 或其他语言更方便。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003emerge\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ein2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ehave1\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eempty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eempty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ehave1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eempty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eval1\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ehave1\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eempty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein2\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eval2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"n\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ein2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ehave1\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eval2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003eval1\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eval2\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eval1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n                \u003cspan class=\"n\"\u003ehave1\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n                \u003cspan class=\"n\"\u003eput\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eval2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n                \u003cspan class=\"n\"\u003ehave2\u003c/span\u003e \u003cspan class=\"o\"\u003e:=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意上面的函数，以及会用到这个函数的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emergesort\u003c/code\u003e 函数（我太懒当前还不想写），这\n里唯一的几条假设是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e有至少四个管道\u003c/li\u003e\n  \u003cli\u003e每个管道有足够的空间用于存储数据\u003c/li\u003e\n  \u003cli\u003e函数能区分这些管道\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e该函数不需要创建、删除管道或通过管道传递管道（pass pipes through pipes）；\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ein1\u003c/code\u003e\n、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eout\u003c/code\u003e 等等参数，不必是某种类型的一等管道对象（first-class pipe object），它们\n可以只是数值类型。（\u003cstrong\u003e事实上这就是 Unix 程序如何处理 Unix 管道的：使用文件描述符\n索引。\u003c/strong\u003e）或者，它们也可以是可以作为参数传递的一等管道对象，但不能通过管道传递管\n道。\u003c/p\u003e\n\n\u003cp\u003e设想一个\u003cstrong\u003e多线程的控制流系统\u003c/strong\u003e：在其中可以 fork 出不同的线程，线程读取空的流（\nempty stream）时会阻塞，直到有数据到来。在这个系统里，你必须得使用管道而不是数组\n或记录，而且可能必须得为每个属性使用一个流。运行时会调度不同的管道处理线程（\npipe-processing threads），可能会将它们分散到不同机器上执行。\u003c/p\u003e\n\n\u003ch2 id=\"73-π-calculus是使用管道的内存模型\"\u003e7.3 π-calculus：是使用管道的内存模型\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e在某种程度上，π-calculus 是一种只使用管道的语言\u003c/strong\u003e；它是一种面向 channel 的并发\n语言（concurrent channel-oriented alternative），与 λ-calculus 类似。\u003c/p\u003e\n\n\u003cp\u003e按照 Jeannette Wing 的解释，用 P 和 Q 表示两个进程。那么：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eP | Q\u003c/code\u003e 表示一个由 P 和 Q 组成的进程，其中 \u003cstrong\u003eP 和 Q 并行运行\u003c/strong\u003e（running in\nparallel）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea(x).P\u003c/code\u003e 表示一个\u003cstrong\u003e等待从 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 中读取一个值 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 的进程\u003c/strong\u003e；读取到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 之\n后，该进程接下来的行为与进程 P 一样（behaves like P）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eā〈x〉.P\u003c/code\u003e 表示一个\u003cstrong\u003e等待在 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 中发送一个值 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 的进程\u003c/strong\u003e；在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 被对\n方接收之后，该进程接下来的行为与进程 P 一样（behaves like P）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(νa)P\u003c/code\u003e 保证 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 是 P 中的一个新 channel\u003c/strong\u003e（希腊单词 nu 表示 new）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!P\u003c/code\u003e 表示 \u003cstrong\u003eP 的无限次拷贝\u003c/strong\u003e，这些拷贝都在\u003cstrong\u003e并行运行\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eP + Q\u003c/code\u003e 表示一个\u003cstrong\u003e行为与 P 或 Q 一样的进程\u003c/strong\u003e（behaves like either P or Q）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 表示\u003cstrong\u003e什么都不做的进程\u003c/strong\u003e（inert process that does nothing）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e她给出的示例 π-calculus 代码是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e!incr(a, x).ā〈x+1〉 | (νa)( i̅n̅c̅r̅〈a, 17〉 | a(y) )\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!incr(a, x).ā〈x+1〉\u003c/code\u003e 解释如下：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!P\u003c/code\u003e 创建了一个有无数个进程的服务程序（server），这里 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eP\u003c/code\u003e 就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eincr(a, x).ā〈x+1〉\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e每个进程监听在 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eincr\u003c/code\u003e 上，等待接收一条消息；收到消息后会将其分别赋给\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e 两个变量\u003c/li\u003e\n  \u003cli\u003e在 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 上将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex+1\u003c/code\u003e 发送出去，然后进程终止\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e同时，还有两个与此并行运行的进程（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ei̅n̅c̅r̅〈a, 17〉\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea(y)\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这两个进程共享一个名字为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 的新 channel\u003c/li\u003e\n  \u003cli\u003e其中一个进程在 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eincr\u003c/code\u003e 上发送 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 和数值 17\u003c/li\u003e\n  \u003cli\u003e另一个进程在 channel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e 上等待接收数据，收到后将其绑定到变量 y\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eπ-calculus 可能不会成为一门实用的编程系统，其他与此类似的\u003cstrong\u003e进程代数（process\ncalculi）\u003c/strong\u003e也不会。但是，它至少说明了\u003cstrong\u003e只使用管道作为内存模型是有可能的\u003c/strong\u003e。但也\n要注意，以上版本其实用到了\u003cstrong\u003e元组\u003c/strong\u003e（tuple）和\u003cstrong\u003e进程间的关系图\u003c/strong\u003e（labeled graphs\nof processes）！如果不用这两个特性，我不确定这门语言的通用性还能剩多少。\u003c/p\u003e\n\n\u003ch2 id=\"74-其他基于管道的尝试\"\u003e7.4 其他基于管道的尝试\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e基于流的编程（Flow-based programming）\u003c/strong\u003e，例如 NSA 项目 Apache NiFi，是另一种\n对 Unix 管道和过滤器（pipes-and-filters）进行通用化的尝试方式。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_8\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"8-multics-内存模型目录--内存是一棵树\"\u003e8. MULTICS 内存模型：目录 —— 内存是一棵树\u003c/h1\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eDirectories, the Multics memory model:  memory is a string-labeled tree with\nblob leaves。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"81-模型特点目录树模型-vs-对象图模型\"\u003e8.1 模型特点（目录树模型 vs 对象图模型）\u003c/h2\u003e\n\n\u003cp\u003eUnix（或 Windows、MacOS、Multics）\u003cstrong\u003e层级文件系统是另一种内存组织方式\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种方式通常是是由 spinning rust（TODO？）组成的持久内存，shell 脚本尤其大量使用\n这种内存模型。\u003c/p\u003e\n\n\u003cp\u003e从基本形式上说，\u003cstrong\u003e这种内存模式是在对象图模型（object-graph model）的基础上加了一\n些限制得到的\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e其中的每个节点都有一个\u003cstrong\u003e唯一的父节点\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e每个节点要么是一个\u003cstrong\u003e目录\u003c/strong\u003e（directory），要么是一个\u003cstrong\u003e常规文件\u003c/strong\u003e（regular file）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e目录\u003c/strong\u003e是一个用字符串作为 key 索引的字典，其中\u003cstrong\u003e存放了指向子节点的链接\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e常规文件\u003c/strong\u003e是一个可变对象（mutable blob），其中\u003cstrong\u003e存储了字节序列\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e一个重要的不同是\u003cstrong\u003e添加了第三种节点类型：符号链接（symbolic link）\u003c/strong\u003e，这是一个可\n跟踪的路径（a path to follow），可以从 root 或其父目录开始跟踪，来找到期望的节\n点 —— 如果这个节点存在。\u003c/p\u003e\n\n\u003ch2 id=\"82-序列化和反序列化\"\u003e8.2 序列化和反序列化\u003c/h2\u003e\n\n\u003cp\u003e典型情况下，在一个层级文件系统中要\u003cstrong\u003e表示一个实体的属性\u003c/strong\u003e，需要\u003cstrong\u003e将这些属性（连同\n其他一些实体）序列化（serialize）到一个常规文件中\u003c/strong\u003e。但这样做的大部分原因是：系\n统调用的接口太慢太笨重了；另外就是每个节点的开销比较大，通常情况下在几百字节这样\n的级别。与此相比，你完全可以为每个实体使用一个目录，将它的每个属性都存储到这个目\n录中的一个单独文件中，例如属性 x 存储到名为 x 的文件中。\u003cstrong\u003eUnix 就是用这种方式存\n储某些信息的\u003c/strong\u003e，例如用户信息（information about users），或者软件包的版本信息，\n或者如何编译不同的软件包的信息。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e这种有唯一父节点的特性使得序列化和反序列化变得相对比较直接\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"83-局部变量\"\u003e8.3 局部变量\u003c/h2\u003e\n\n\u003cp\u003e对于局部变量，层级文件系统的做法比较折中（occupies a middle ground）。\u003c/p\u003e\n\n\u003cp\u003e典型情况下\n，任何节点都可以通过遍历这个树访问到，但我们相当确定，当前在文件系统的某部分运行\n的软件不会注意到文件系统的另一个部分中新加入的文件；而且，在大部分情况下，可以在\n不破坏已经在运行中的软件的情况下，向目录里添加新文件，虽然这一点是没有保证的。\u003c/p\u003e\n\n\u003ch2 id=\"84-对其他编程语言或系统的影响\"\u003e8.4 对其他编程语言或系统的影响\u003c/h2\u003e\n\n\u003cp\u003e有很多的编程系统或多或少就是以这种方式工作的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eMUMPS，一个仍然运行在美国退伍军人管理局（US Veteran’s Administration）的系统，\n或多或少就是这样工作的（虽然典型的“文件”会限制在 4096 字节以内，并且一个节点可\n以同时是目录和常规文件）。\u003c/li\u003e\n  \u003cli\u003eIBM 的 IMS database 也是一个仍然在广泛使用的系统，其数据模型也与此非常相似；\n其中的节点称为 “segments”，每个数据库上会有一个 schema。\u003c/li\u003e\n  \u003cli\u003e另外，几年之前，Mark Lentczner 开始基于这种内存模型开发一个名为\n\u003ca href=\"https://web.archive.org/web/20110830022448/http://www.wheatfarm.org\"\u003eWheat\u003c/a\u003e\n的现代面向对象编程环境，作为 PHP 之外的 web app 编程环境；我个人对此是有点喜欢的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIn Wheat, each function’s activation record is a “directory”, with its\nvariables as (dynamically typed, rather than blob) “files” in it.\nSome subtrees of the “filesystem” are persistent, but not others;\naccess to remotely hosted data is transparent.  Essentially, Wheat\nsought to eliminate the impedance mismatch between the persistent,\nhierarchically-named, globally-accessible resources of the Web, and\nthe program’s own conception of memory.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca name=\"ch_9\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"9-sql-内存模型关系--内存是一个可变多值有限函数集\"\u003e9. SQL 内存模型：关系 —— 内存是一个可变、多值有限函数集\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e某种程度上说，这是所有内存模型中最抽象的。\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"91-多值函数\"\u003e9.1 多值函数\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e“多值函数”（multivalued function）在数学中通常称为“关系”（relation）。\u003c/strong\u003e，例如\n：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecos\u003c/code\u003e 是一个\u003cstrong\u003e函数\u003c/strong\u003e：对于任何 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eθ\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecos(θ)\u003c/code\u003e 都是一个唯一的、定义良好的值\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecos⁻¹\u003c/code\u003e 是一个\u003cstrong\u003e关系\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecos⁻¹(0.5)\u003c/code\u003e 对应多个值 —— 虽然我们通常会将它转换成一\n个函数，只取其中的一个值\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可以将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecos\u003c/code\u003e 认为是一系列有序 pair 的集合，例如\n(0, 1), (π/2, 0), (π, -1), (3π/2, 0) 等等，因此逆操作（inversion operation）就是\n将 pair 内的两个数字反转的过程：(1, 0), (0, π/2), (-1, π), (0, 3π/2) 等等。\u003c/p\u003e\n\n\u003cp\u003e我们这里要考虑的关系（relation）要比二值关系（binary relation）更宽泛：相比于\n2-tuple 集合，我们要考虑的是 n-tuples 集合，其中 n 是某个整数。例如考虑\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(θ, cos(θ), sin(θ))\u003c/code\u003e 这个 3-tuple，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eθ\u003c/code\u003e 是角度：(0, 1, 0), (π/2, 0, 1), (π, -1,\n0)等等。\u003c/p\u003e\n\n\u003cp\u003e大部分关系编程系统（systems for relational programming）只对无限关系（infinite\nrelations，例如 cos）进行有限的支持（limited support），因为这种情况下很容易构造\n出不可解的问题（undecidable problems）。\u003c/p\u003e\n\n\u003ch2 id=\"92-sqlite-例子\"\u003e9.2 sqlite 例子\u003c/h2\u003e\n\n\u003cp\u003e举个具体的例子，下面是我的 Firefox 安装之后，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epermissions.sqlite\u003c/code\u003e 表中的一部分内\n容：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003esqlite\u0026gt; .mode column\nsqlite\u0026gt; .width 3 20 10 5 5 15 1 1\nsqlite\u0026gt; \u003cspan class=\"k\"\u003eselect\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e from moz_hosts limit 5\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"nb\"\u003eid   \u003c/span\u003ehost                  \u003cspan class=\"nb\"\u003etype        \u003c/span\u003epermi  expir  expireTime       a  i\n\u003cspan class=\"nt\"\u003e---\u003c/span\u003e  \u003cspan class=\"nt\"\u003e--------------------\u003c/span\u003e  \u003cspan class=\"nt\"\u003e----------\u003c/span\u003e  \u003cspan class=\"nt\"\u003e-----\u003c/span\u003e  \u003cspan class=\"nt\"\u003e-----\u003c/span\u003e  \u003cspan class=\"nt\"\u003e---------------\u003c/span\u003e  -  -\n1    addons.mozilla.org    \u003cspan class=\"nb\"\u003einstall     \u003c/span\u003e1      0      0                    \n2    getpersonas.com       \u003cspan class=\"nb\"\u003einstall     \u003c/span\u003e1      0      0                    \n5    github.com            sts/use     1      2      1475110629178        \n9    news.ycombinator.com  sts/use     1      2      1475236009514        \n10   news.ycombinator.com  sts/subd    1      2      1475236009514\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对于关系模型（relational model），这里的\u003cstrong\u003e每一列在某种程度上都是主键（primary\nkey）的一个函数\u003c/strong\u003e，而这里的主键就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 这一列；因此，可以说：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost(1)\u003c/code\u003e 就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaddons.mozilla.org\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost(2)\u003c/code\u003e 就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egetpersonas.com\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etype(5)\u003c/code\u003e 就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ests/use\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在这里的实现中，这是一张哈希表。\u003c/p\u003e\n\n\u003cp\u003e但是，这里\u003cstrong\u003e与常规的函数式编程（functional programming）不同的地方在于\u003c/strong\u003e：可以进\n行\u003cstrong\u003e逆操作\u003c/strong\u003e —— 除了可以访问 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost(9)\u003c/code\u003e，还可以访问 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost⁻\n¹(\u0026#39;news.ycombinator.com\u0026#39;)\u003c/code\u003e，后者得到的结果就是多个值（multivalued）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003esqlite\u0026gt; \u003cspan class=\"k\"\u003eselect \u003c/span\u003e\u003cspan class=\"nb\"\u003eid \u003c/span\u003efrom moz_hosts where host \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;news.ycombinator.com\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"nb\"\u003eid\u003c/span\u003e \n\u003cspan class=\"nt\"\u003e---\u003c/span\u003e\n9  \n10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e另外，你还可以将这些\u003cstrong\u003e多值函数\u003c/strong\u003e进行更复杂的组合：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003esqlite\u0026gt; .width 0\nsqlite\u0026gt; \u003cspan class=\"k\"\u003eselect \u003c/span\u003emin\u003cspan class=\"o\"\u003e(\u003c/span\u003eexpireTime\u003cspan class=\"o\"\u003e)\u003c/span\u003e from moz_hosts where host \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;news.ycombinator.com\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\nmin\u003cspan class=\"o\"\u003e(\u003c/span\u003eexpireTime\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e---------------\u003c/span\u003e\n1475236009514\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"93-sql-模型\"\u003e9.3 SQL 模型\u003c/h2\u003e\n\n\u003cp\u003e通常情况下，要在 SQL 中表示一个实体，需要表中的一行（a row in a table），也就是\n关系中的一个元组（a tuple in a relation）；要表示它和其他实体的关系，需要用某些\n\u003cstrong\u003e唯一的属性集合\u003c/strong\u003e来标识出这些实体，这个属性集合称为\u003cstrong\u003e键（key）\u003c/strong\u003e，例如前面的表\n中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e，然后在其他实体的某个列中包含这个实体的键。\u003c/p\u003e\n\n\u003cp\u003e现在回到我们前面的银行账户 middle name 的例子，在这里就可以表示成：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eselect \u003c/span\u003eaccountholder.middlename\nfrom accountholder, account\nwhere accountholder.id \u003cspan class=\"o\"\u003e=\u003c/span\u003e account.accountholderid\nand account.id \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3201\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e或者可以将最后一行去掉，这样得到的就不是一个账户的 middle name，而是所有账户的\nmiddle name。\u003c/p\u003e\n\n\u003cp\u003eSQL 并不是关系型模型（relational model）的唯一实现，但到目前为止，它是最流行的实\n现。另外，SQL \u003ca href=\"http://blog.coelho.net/database/2013/08/17/turing-sql-1/\"\u003e最近无意间变成了图灵完备（Turing-complete）的\n\u003c/a\u003e，因此原理上 SQL 是可\n以接管整个世界的。\u003c/p\u003e\n\n\u003cp\u003e与真正意义上的编程语言，例如 Lisp、FORTRAN 和 C 相比，这种模型看上去并不属于同一个\n范畴，这是因为 SQL 作为一个编程语言更多的是出于好奇而不是实用目的。但是，再考虑\n一下文章开头给出的示例编程语言。如果对这个示例语言进行扩展，支持 SQL 声明、\n将原生类型的结果存储到变量、对结果集合进行迭代，那它就会成为一个可用的编程系统 —\n— 虽然会是一个不够灵活的系统。（实际上，我描述的这门示例语言或多或少就是 PL/SQL。）\u003c/p\u003e\n\n\u003cp\u003e这不是说要改变这门语言中的类型（denoted or expressed types）。即使这门语言仍然只\n能将数值当做变量或表达式值处理，只要它能够将这些数值存储到关系中，并且能通过查询\n再将它们取出来，那这门语言的处理能力也会得到巨大提升。\u003c/p\u003e\n\n\u003ch2 id=\"94-sql-优缺点\"\u003e9.4 SQL 优缺点\u003c/h2\u003e\n\n\u003cp\u003eSQL 也有一些限制：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e表名（table names）在一个全局 namespace 中，行和列都是全局可访问的（你无法创建\n私有列或行，虽然在某种意义上说，每次查询得到的结果都是一张私有表，可以作为私有\n行和列使用）\u003c/li\u003e\n  \u003cli\u003e每列通常情况下只能 hold primitive 数据类型，例如数值和字符串（至少现代数据库已\n经不再像 COBOL 一样只支持固定宽度的字符串了）\u003c/li\u003e\n  \u003cli\u003e经常运行非常慢（painfully slow）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e从某个角度看，SQL 操作，以及它的优缺点，和并行数组非常相似：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003emoz_hosts_len\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003estrcmp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emoz_hosts_host\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;news.ycombinator.com\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eresults_len\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emoz_hosts_id\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e或者，下面的例子更清晰地展示了 SQL 如何节省了你写算法的 effort，用并行数组实现一\n个 sort-merge join 非常难于维护，而用 SQL：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eselect\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emiddlename\u003c/span\u003e\n\u003cspan class=\"n\"\u003efrom\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount\u003c/span\u003e\n\u003cspan class=\"n\"\u003ewhere\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eaccountholderid\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果用 C 语言和并行数组来实现同样的功能：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efksort\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eiota\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eaccount_len\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"n\"\u003esort_by_int_column\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eaccount_accountholderid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003efksort\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount_len\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003epksort\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eiota\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eaccountholder_len\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"n\"\u003esort_by_int_column\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eaccountholder_id\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003epksort\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder_len\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount_len\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eamp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eamp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ej\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder_len\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003efk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount_accountholderid\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003efksort\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]];\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003epk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder_id\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003epksort\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]];\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efk\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003epk\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eresult_id\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003efk\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eresult_middle_name\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eaccountholder_middlename\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003epksort\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"p\"\u003e]];\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e                \u003cspan class=\"c1\"\u003e// Supposing accountholder_id is unique.\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efk\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003epk\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ej\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003efree\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efksort\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"n\"\u003efree\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epksort\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiota\u003c/code\u003e 的实现是：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003eiota\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eresults\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalloc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eabort\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eresults\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esort_by_int_column\u003c/code\u003e 或多或少可以实现如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003esort_by_int_column\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eindices\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eindices_len\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eqsort_r\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eindices\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eindices_len\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eindices\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eindirect_int_comparator\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eindirect_int_comparator\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003evalues\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003earg\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eSQL 背后的实现使用了很多技巧，\u003cstrong\u003e牺牲了简单查询的效率，但提高了复杂查询的效率，\n而用户程序看到的抽象是一样的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"95-评论抽象层次\"\u003e9.5 评论：抽象层次\u003c/h2\u003e\n\n\u003cp\u003e人们经常说 SQL 是一门声明式语言（declarative language）：不需要说明应该如何计算\n结果（how a result is computed），只需要说明你希望的结果是什么（what result is desired）。\n我认为这种观点只是部分正确，而且\u003cstrong\u003e语言并不是只能分为声明式（declarativeness）或非\n声明式两种，这涉及的是描述的抽象层次\u003c/strong\u003e（level of abstraction of the description）\n，而这是一个无限连续体（infinite continuum）问题，如果只是出于性能原因，那些低于\n这个抽象层次但很实用的考虑一定会不可避免的侵入进来。\u003c/p\u003e\n\n\u003cp\u003e也许更有趣的是，\u003cstrong\u003eProlog 和 miniKANREN 实现了关系型模型\u003c/strong\u003e（虽然二者的实现并不纯粹\n），它们将关系型编程和对象图（object-graph）递归数据结构结合起来，\u003cstrong\u003e取得了真正令\n人惊叹的能力\u003c/strong\u003e。例如，一个非常简单的 miniKANREN 程序可以在一个合理的计算时间内，\n生成无限多个输出自身源代码的程序（quines）。\u003c/p\u003e\n\n\u003cp\u003e广义的有约束编程（constraint programming）领域中，只需指定期望的结果的一些特性（结\n果必须满足的“约束”），然后系统会承担寻找答案的任务，由于 SAT 和 SMT solvers 近些\n年取得的巨大进步，这个领域正在取得长足的发展。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_10\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"10-注释\"\u003e10 注释\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e《Essentials of Programming Languages》\u003c/strong\u003e 建议分析编程语言时，首先要看它可\n以表示什么类型的变量，以及可以对什么类型的表达式求值，这比仅仅分析其语法要有\n用的多，但是我认为这很大程度上忽略了更深层次的东西。\u003c/li\u003e\n  \u003cli\u003e我将其称为六种 \u003cstrong\u003e“内存模型”\u003c/strong\u003e，即使这个术语过去指的是 C 语言中与 8086 寻址模\n式相关的一个东西，而与本文所描述的内容关系不大（我倒是很希望为本文描述的东西\n找一个更好的术语）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/host-disconnect-caused-by-istio-sidecar-injection/\"\u003e\u003cspan\u003e« Host Disconnect Caused by Istio Sidecar Injection\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/c-is-not-a-low-level-language-zh/\"\u003e\u003cspan\u003e[译] C 不是一门低层（low-level）语言（acmqueue, 2018） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-11-09T00:00:00Z",
  "Author": "Arthur Chiao"
}