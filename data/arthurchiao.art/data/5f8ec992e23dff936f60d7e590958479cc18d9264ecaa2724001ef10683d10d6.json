{
  "Source": "arthurchiao.art",
  "Title": "[译] 拨乱反正：Ken Thompson 才是 UTF-8 的设计者（2003）",
  "Link": "https://arthurchiao.art/blog/utf-8-history-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 拨乱反正：Ken Thompson 才是 UTF-8 的设计者（2003）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-12-22 | Last Update 2019-12-22\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2003 年的一份网页存档：\u003ca href=\"https://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt\"\u003eUTF-8\nhistory\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e2003 年 4 月的最后一个夜晚即将从键盘上溜走时，作为 UTF-8 设计\n过程的亲眼见证者，坐在电脑前的 Rob Pike 终于决定写一封邮件来阻止 “UTF-8 编码是\nIBM 设计的” 这一错误的继续传播，本文的故事由此展开。\u003c/p\u003e\n\n\u003cp\u003eRob 在邮件中非常谦虚地隐去了自己作为联合设计者的功劳，只是轻描淡写地说了一句自己\n期间承担了 Ken 的鼓励师的角色。\u003c/p\u003e\n\n\u003cp\u003e假如对文中几位的名字感到陌生，以下事迹或头衔可略作参考：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eRob Pike\n    \u003cul\u003e\n      \u003cli\u003eUnix 开发者之一，Ken Thompson 在贝尔实验室的小老弟\u003c/li\u003e\n      \u003cli\u003ePlan 9 操作系统作者之一\u003c/li\u003e\n      \u003cli\u003eGo 语言设计团队第一任老大\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eKen Thompson\n    \u003cul\u003e\n      \u003cli\u003e与 Dennis Ritchie 一起发明了 Unix 和 C 语言，经典 C 语言标准 “K\u0026amp;R C” 中的 K\u003c/li\u003e\n      \u003cli\u003ePlan 9 操作系统作者之一\u003c/li\u003e\n      \u003cli\u003e图灵奖获得者（1983）\u003c/li\u003e\n      \u003cli\u003eGo 语言设计团队元老\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eRuss Cox\n    \u003cul\u003e\n      \u003cli\u003eGo 语言开发和设计：2008 年加入 Google 开发 Go，现（2019）为 Go 开发团队 leader\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e有了以上背景，也就不难理解为什么 Go 语言中的 UTF-8 支持如此原生了。\u003c/p\u003e\n\n\u003ch3 id=\"几封邮件及时间线\"\u003e几封邮件及时间线\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2003.04.30 22:32:32\u003c/code\u003e: \u003ca href=\"#ch_1\"\u003e1. Rob Pike：不要再说 UTF-8 是 IBM 设计的了\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2003.06.07 18:44:05\u003c/code\u003e: \u003ca href=\"#ch_2\"\u003e2. Rob Pike：我请了 Russ Cox 去存档中找当时的往来邮件\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2003.06.07  7:46 PM\u003c/code\u003e: \u003ca href=\"#ch_3\"\u003e3. Russ Cox：找到的相关邮件\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.04 03:37:39\u003c/code\u003e: \u003ca href=\"#ch_4\"\u003e4. Ken：能否让 utf.c 实现更整洁（存档邮件)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.08 03:22:07\u003c/code\u003e: \u003ca href=\"#ch_5\"\u003e5. Ken：UTF-8 提案及代码（存档邮件)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.08 03:24:58\u003c/code\u003e: \u003ca href=\"#ch_6\"\u003e6. Ken：抄送我自己的邮件还没收到（存档邮件)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.08 03:42:43\u003c/code\u003e: \u003ca href=\"#ch_7\"\u003e7. Ken：终于收到抄送了（存档邮件)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.02         \u003c/code\u003e: \u003ca href=\"#ch_8\"\u003e8. 第一份 UTF-8 提案：直接追加在原始 FSS-UTF 提案后面（存档邮件)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e\u003ca name=\"ch_1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"1-rob-pike不要再说-utf-8-是-ibm-设计的了\"\u003e1. Rob Pike：不要再说 UTF-8 是 IBM 设计的了\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eSubject: UTF-8 history\nFrom: \u0026#34;Rob \u0026#39;Commander\u0026#39; Pike\u0026#34; \u0026lt;r (at) google.com\u0026gt;\nDate: Wed, 30 Apr 2003 22:32:32 -0700 (Thu 06:32 BST)\nTo: mkuhn (at) acm.org, henry (at) spsystems.net\nCc: ken (at) entrisphere.com\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e回望 UTF-8 的过去，我看到一个错误的故事在不断传播。这个故事说：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eIBM 设计了 UTF-8\u003c/li\u003e\n  \u003cli\u003ePlan 9 实现了这份设计方案\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这不是事实。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e时间回到 1992 年 9 月前后，在新泽西（New Jersey）的某次晚餐上，我亲眼见\n证了 UTF-8 在一张餐桌纸上的诞生\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e下面这些才是事实：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e我们曾用最初的 ISO 10646 UTF 使 Plan 9 支持 16-bit 字符，但结果令我们非常不满\n意。在 Plan 9 系统即将交付的某个傍晚，我接到了几个人打来的一通电话，这些人应\n该是 IBM 的 —— 我记得他们当时在 Austin —— 正在参加一个 X/Open 委员会会议。他们\n打电话的目的是希望 Ken 和我评审他们的 FSS/UTF 设计方案。我们当时知道他们为什么\n要引入一个新的设计，\u003cstrong\u003e更重要的是，Ken 和我当时突然意识到，这是一个充分利用我俩\n的经验来设计一个真正优秀的标准的好机会，而标准推进的事情可以交给他们\u003c/strong\u003e。\u003c/p\u003e\n\n  \u003cp\u003e我们向对方表达了这种想法，得到的答复是：\u003cstrong\u003e只要我们能在尽量短的时间内给出一套方\n案，他们愿意去推进这件事情\u003c/strong\u003e。然后，我俩就去餐厅吃饭了，\u003cstrong\u003eKen 在吃饭期间确定了\nbit-packing 的设计\u003c/strong\u003e，当吃完回到实验室时，我们打给了 X/Open 的这几位朋友，向他\n们解释了我们的设计方案。\u003c/p\u003e\n\n  \u003cp\u003e我们以邮件的形式将这套规范的大纲（outline of our spec）发给了他们，\u003cstrong\u003e他们回复\n说这比他们自己设计的版本好多了\u003c/strong\u003e（我压根就没真正见过他们的提案；反正我是想\n不起来），并询问我们最快什么时候能实现它？我记得这是一个周三的晚上，我们回复\n说下周一之前一定可以提供一个完整的、可运行的系统，因为我记得下周一是他们投票表\n决的时间。\u003c/p\u003e\n\n  \u003cp\u003e因此，那个晚上 Ken 编写了 packing 和 unpacking 的代码，我将这些代码拆分成了 C 和\ngraphics 库。第二天所有的代码都好了之后，我们开始将系统上所有的文本文件转换成\nUTF-8 编码格式。到了周五的某个时刻，\u003cstrong\u003ePlan 9 运行起来了，并且完全运行在这种名为\nUTF-8 的编码之上\u003c/strong\u003e。然后我们打给了 X/Open 和其他一些人，但他们后来对此事的描述，\n却是一段略微修改过的历史。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e为什么我们不直接用他们的 FSS/UTF 设计方案呢？根据我的记忆，是因为在他们第一次打\n电话过来时，我提出了几个这类编码方案应该解决的问题， 而其中\u003cstrong\u003e至少有一个问题是\nFSS/UTF 方案无法解决的\u003c/strong\u003e —— 对于从中间开始获取的字节流，\u003cstrong\u003e在读取不超过一个字\n符的前提下就能对字节流进行同步的能力\u003c/strong\u003e（synchronize a byte stream picked up\nmid-run, with less that one character being consumed before synchronization）。\n正是因为缺乏这种能力，所以我们才可以自由地 —— 他们也给了我们自由 —— 来设计我们自\n己的方案。\u003c/p\u003e\n\n\u003cp\u003e我认为“IBM 设计了 UTF-8，Plan 9 实现了它”的故事最初是从 RFC2279 中来的。当时\n看到 UTF-8 如此流行我们非常高兴，因此就没有去纠正这段误传的历史。现在我和 Ken 都\n已经不在当初的实验室了，但我相信存档中一定有当时的邮件可以证明前面讲的内容，我\n也许能找人把这些邮件捞出来。\u003c/p\u003e\n\n\u003cp\u003e最后，\u003cstrong\u003e将 UTF-8 变成标准并且推广开来确实是 X/Open 和 IBM 那些人的功劳，但不管历\n史书上怎么说，UTF-8 都是 Ken 设计的\u003c/strong\u003e（我的贡献是期间中充当了 Ken 的鼓励师）。\u003c/p\u003e\n\n\u003cp\u003e（邮件落款）- rob\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"2-rob-pike我请了-russ-cox-去存档中找当时的往来邮件\"\u003e2. Rob Pike：我请了 Russ Cox 去存档中找当时的往来邮件\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eDate: Sat, 07 Jun 2003 18:44:05 -0700\nFrom: \u0026#34;Rob `Commander\u0026#39; Pike\u0026#34; \u0026lt;r (at) google.com\u0026gt;\nTo: Markus Kuhn \u0026lt;Markus.Kuhn (at) cl.cam.ac.uk\u0026gt;\ncc: henry (at) spsystems.net, ken (at) entrisphere.com, Greger Leijonhufvud \u0026lt;greger (at) friherr.com\u0026gt;\nSubject: Re: UTF-8 history\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e我请了 Russ Cox 帮忙去存档中寻找当时这些资料。下面附录了他的邮件。\n相信这些内容会让你相信之前邮件中所述均确有其事。\u003c/p\u003e\n\n\u003cp\u003e我们发给 X/Open 的邮件（我记得是 Ken 编辑和发送的那份设计文档）包括一个新的 设计\n考虑： \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#6\u003c/code\u003e 关于检测字符边界（discovering character boundaries）。我们无从知道\nX/Open 最初的提案如何影响了我们；这两份提案差别非常大，但确实也有某些相同点（\nvery different but do share some characteristics）。我不记得我曾仔细地看过他们的\n提案，这已经是很久之前的事情了。但我非常清楚地记得 Ken 在餐桌纸上完成了设计\n，我多么希望我们把那张纸保存了下来！\u003c/p\u003e\n\n\u003cp\u003e（邮件落款）- rob\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"3-russ-cox找到的相关邮件\"\u003e3. Russ Cox：找到的相关邮件\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eFrom: Russ Cox \u0026lt;rsc (at) plan9.bell-labs.com\u0026gt;\nTo: r (at) google.com\nSubject: utf digging\nDate-Sent: Saturday, June 07, 2003 7:46 PM -0400\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003chr/\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.04 19:51:55\u003c/code\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/src/libc/port/rune.c\u003c/code\u003e 文件的编码格式从原来老的大\n量使用除法（division-heavy）的 UTF 格式转换成了新的 UTF-8 格式\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.04\u003c/code\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/src/libc/port/rune.c\u003c/code\u003e 添加了注释，然后就没有再修改过了，直到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1996.11.14\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1996.11.14\u003c/code\u003e：对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunelen\u003c/code\u003e 做了加速优化：显式检查 rune 而不是使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunetochar\u003c/code\u003e 的返回值\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2001.5.26\u003c/code\u003e：下一次也是最后一次修改，添加了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunenlen()\u003c/code\u003e 函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面是在你的邮箱中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egrep\u003c/code\u003e utf 找到的几封邮件。第一封是关于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eutf.c\u003c/code\u003e，这个文件基本\n上是照抄了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewctomb\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003embtowc\u003c/code\u003e，用于处理 32 bit rune 的 full 6-byte utf-8 编码。\n这段代码非常丑陋，全部逻辑都在控制流中。\u003cstrong\u003e我认为在第一封邮件之后，这段代码变成了\n提案中的代码\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/usr/ken/utf/xutf\u003c/code\u003e 目录中，我找到了一份似乎是最初的无法自同步的（\nnot-self-synchronizing）编码提案，而 \u003cstrong\u003eutf-8 方案追加到了这\n份文件的末尾\u003c/strong\u003e（从 “We define 7 byte types” 开始）。这些内容也附在了下面。\u003c/p\u003e\n\n\u003cp\u003e下面贴的是第一版的邮件，时间是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.02 23:44:10\u003c/code\u003e。经过几次修改，在\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1992.09.08\u003c/code\u003e 号形成了第二封邮件，见下面。\u003c/p\u003e\n\n\u003cp\u003e邮件日志显式了第二封邮件发了出去，以及过了一段时间后抄送给 Ken 的邮件到达了。\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ehelix: Sep  8 03:22:13: ken: upas/sendmail: remote inet!xopen.co.uk!xojig \n\u0026gt; From ken Tue Sep  8 03:22:07 EDT 1992 (xojig@xopen.co.uk) 6833\nhelix: Sep  8 03:22:13: ken: upas/sendmail: delivered rob From ken Tue Sep 8 03:22:07 EDT 1992 6833\nhelix: Sep  8 03:22:16: ken: upas/sendmail: remote pyxis!andrew From ken Tue Sep  8 03:22:07 EDT 1992 (andrew) 6833\nhelix: Sep  8 03:22:19: ken: upas/sendmail: remote coma!dmr From ken Tue Sep  8 03:22:07 EDT 1992 (dmr) 6833\nhelix: Sep  8 03:25:52: ken: upas/sendmail: delivered rob From ken Tue Sep 8 03:24:58 EDT 1992 141\nhelix: Sep  8 03:36:13: ken: upas/sendmail: delivered ken From ken Tue Sep 8 03:36:12 EDT 1992 6833\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"ch_4\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"4-ken能否让-utfc-实现更整洁\"\u003e4. Ken：能否让 utf.c 实现更整洁\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u0026gt;From ken Fri Sep  4 03:37:39 EDT 1992\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e你可能需要看看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/usr/ken/utf/utf.c\u003c/code\u003e，以及能否让代码更整洁一点。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_5\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"5-kenutf-8-提案及代码\"\u003e5. Ken：UTF-8 提案及代码\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u0026gt;From ken Tue Sep  8 03:22:07 EDT 1992\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下面是我们修改之后的 FSS-UTF 提案。其中所用的术语和原提案中一样。我要为此向原提\n案的作者致歉。提案中的代码已经经过一定程度的测试（tested to some degree），比较\n整洁（should be pretty good shape）。我们已经设置 Plan 9 接下来使用这种编码格式\n（converted Plan 9 to use this encoding），并考虑发布一个版本（\nissue a distribution）给一部分大学用户使用。\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eFile System Safe Universal Character Set Transformation Format (FSS-UTF)\n--------------------------------------------------------------------------\n\nWith the approval of ISO/IEC 10646 (Unicode) as an international\nstandard and the anticipated wide spread use of this universal coded\ncharacter set (UCS), it is necessary for historically ASCII based\noperating systems to devise ways to cope with representation and\nhandling of the large number of characters that are possible to be\nencoded by this new standard.\n\nThere are several challenges presented by UCS which must be dealt with\nby historical operating systems and the C-language programming\nenvironment.  The most significant of these challenges is the encoding\nscheme used by UCS. More precisely, the challenge is the marrying of\nthe UCS standard with existing programming languages and existing\noperating systems and utilities.\n\nThe challenges of the programming languages and the UCS standard are\nbeing dealt with by other activities in the industry.  However, we are\nstill faced with the handling of UCS by historical operating systems\nand utilities.  Prominent among the operating system UCS handling\nconcerns is the representation of the data within the file system.  An\nunderlying assumption is that there is an absolute requirement to\nmaintain the existing operating system software investment while at\nthe same time taking advantage of the use the large number of\ncharacters provided by the UCS.\n\nUCS provides the capability to encode multi-lingual text within a\nsingle coded character set.  However, UCS and its UTF variant do not\nprotect null bytes and/or the ASCII slash (\u0026#34;/\u0026#34;) making these character\nencodings incompatible with existing Unix implementations.  The\nfollowing proposal provides a Unix compatible transformation format of\nUCS such that Unix systems can support multi-lingual text in a single\nencoding.  This transformation format encoding is intended to be used\nas a file code.  This transformation format encoding of UCS is\nintended as an intermediate step towards full UCS support.  However,\nsince nearly all Unix implementations face the same obstacles in\nsupporting UCS, this proposal is intended to provide a common and\ncompatible encoding during this transition stage.\n\n\nGoal/Objective\n--------------\n\nWith the assumption that most, if not all, of the issues surrounding\nthe handling and storing of UCS in historical operating system file\nsystems are understood, the objective is to define a UCS\ntransformation format which also meets the requirement of being usable\non a historical operating system file system in a non-disruptive\nmanner.  The intent is that UCS will be the process code for the\ntransformation format, which is usable as a file code.\n\nCriteria for the Transformation Format\n--------------------------------------\n\nBelow are the guidelines that were used in defining the UCS\ntransformation format:\n\n    1) Compatibility with historical file systems:\n\n\tHistorical file systems disallow the null byte and the ASCII\n\tslash character as a part of the file name.\n\n    2) Compatibility with existing programs:\n\n\tThe existing model for multibyte processing is that ASCII does\n\tnot occur anywhere in a multibyte encoding.  There should be\n\tno ASCII code values for any part of a transformation format\n\trepresentation of a character that was not in the ASCII\n\tcharacter set in the UCS representation of the character.\n\n    3) Ease of conversion from/to UCS.\n\n    4) The first byte should indicate the number of bytes to\n\tfollow in a multibyte sequence.\n\n    5) The transformation format should not be extravagant in\n\tterms of number of bytes used for encoding.\n\n    6) It should be possible to find the start of a character\n\tefficiently starting from an arbitrary location in a byte\n\tstream.\n\nProposed FSS-UTF\n----------------\n\nThe proposed UCS transformation format encodes UCS values in the range\n[0,0x7fffffff] using multibyte characters of lengths 1, 2, 3, 4, 5,\nand 6 bytes.  For all encodings of more than one byte, the initial\nbyte determines the number of bytes used and the high-order bit in\neach byte is set.  Every byte that does not start 10xxxxxx is the\nstart of a UCS character sequence.\n\nAn easy way to remember this transformation format is to note that the\nnumber of high-order 1\u0026#39;s in the first byte signifies the number of\nbytes in the multibyte character:\n\n   Bits  Hex Min  Hex Max  Byte Sequence in Binary\n1    7  00000000 0000007f 0vvvvvvv\n2   11  00000080 000007FF 110vvvvv 10vvvvvv\n3   16  00000800 0000FFFF 1110vvvv 10vvvvvv 10vvvvvv\n4   21  00010000 001FFFFF 11110vvv 10vvvvvv 10vvvvvv 10vvvvvv\n5   26  00200000 03FFFFFF 111110vv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv\n6   31  04000000 7FFFFFFF 1111110v 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv 10vvvvvv\n\nThe UCS value is just the concatenation of the v bits in the multibyte\nencoding.  When there are multiple ways to encode a value, for example\nUCS 0, only the shortest encoding is legal.\n\nBelow are sample implementations of the C standard wctomb() and\nmbtowc() functions which demonstrate the algorithms for converting\nfrom UCS to the transformation format and converting from the\ntransformation format to UCS. The sample implementations include error\nchecks, some of which may not be necessary for conformance:\n\ntypedef\nstruct\n{\n\tint\tcmask;\n\tint\tcval;\n\tint\tshift;\n\tlong\tlmask;\n\tlong\tlval;\n} Tab;\n\nstatic\nTab\ttab[] =\n{\n\t0x80,\t0x00,\t0*6,\t0x7F,\t\t0,\t\t/* 1 byte sequence */\n\t0xE0,\t0xC0,\t1*6,\t0x7FF,\t\t0x80,\t\t/* 2 byte sequence */\n\t0xF0,\t0xE0,\t2*6,\t0xFFFF,\t\t0x800,\t\t/* 3 byte sequence */\n\t0xF8,\t0xF0,\t3*6,\t0x1FFFFF,\t0x10000,\t/* 4 byte sequence */\n\t0xFC,\t0xF8,\t4*6,\t0x3FFFFFF,\t0x200000,\t/* 5 byte sequence */\n\t0xFE,\t0xFC,\t5*6,\t0x7FFFFFFF,\t0x4000000,\t/* 6 byte sequence */\n\t0,\t\t\t\t\t\t\t/* end of table */\n};\n\nint\nmbtowc(wchar_t *p, char *s, size_t n)\n{\n\tlong l;\n\tint c0, c, nc;\n\tTab *t;\n\n\tif(s == 0)\n\t\treturn 0;\n\n\tnc = 0;\n\tif(n \u0026lt;= nc)\n\t\treturn -1;\n\tc0 = *s \u0026amp; 0xff;\n\tl = c0;\n\tfor(t=tab; t-\u0026gt;cmask; t++) {\n\t\tnc++;\n\t\tif((c0 \u0026amp; t-\u0026gt;cmask) == t-\u0026gt;cval) {\n\t\t\tl \u0026amp;= t-\u0026gt;lmask;\n\t\t\tif(l \u0026lt; t-\u0026gt;lval)\n\t\t\t\treturn -1;\n\t\t\t*p = l;\n\t\t\treturn nc;\n\t\t}\n\t\tif(n \u0026lt;= nc)\n\t\t\treturn -1;\n\t\ts++;\n\t\tc = (*s ^ 0x80) \u0026amp; 0xFF;\n\t\tif(c \u0026amp; 0xC0)\n\t\t\treturn -1;\n\t\tl = (l\u0026lt;\u0026lt;6) | c;\n\t}\n\treturn -1;\n}\n\nint\nwctomb(char *s, wchar_t wc)\n{\n\tlong l;\n\tint c, nc;\n\tTab *t;\n\n\tif(s == 0)\n\t\treturn 0;\n\n\tl = wc;\n\tnc = 0;\n\tfor(t=tab; t-\u0026gt;cmask; t++) {\n\t\tnc++;\n\t\tif(l \u0026lt;= t-\u0026gt;lmask) {\n\t\t\tc = t-\u0026gt;shift;\n\t\t\t*s = t-\u0026gt;cval | (l\u0026gt;\u0026gt;c);\n\t\t\twhile(c \u0026gt; 0) {\n\t\t\t\tc -= 6;\n\t\t\t\ts++;\n\t\t\t\t*s = 0x80 | ((l\u0026gt;\u0026gt;c) \u0026amp; 0x3F);\n\t\t\t}\n\t\t\treturn nc;\n\t\t}\n\t}\n\treturn -1;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"ch_6\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"6-ken抄送我自己的邮件还没收到\"\u003e6. Ken：抄送我自己的邮件还没收到\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eFrom ken Tue Sep  8 03:24:58 EDT 1992\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e邮件我已经发出并抄送了自己，但它好像进入了黑洞。我还没收到（i didnt get my copy）。\n一定是彗星来临或天降异象，导致我的邮件卡在互联网上了。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_7\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"7-ken终于收到抄送了\"\u003e7. Ken：终于收到抄送了\u003c/h1\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eFrom ken Tue Sep  8 03:42:43 EDT 1992\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e终于收到抄送了（i finally got my copy）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_8\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"8-第一份-utf-8-提案直接追加在原始-fss-utf-提案后面存档邮件\"\u003e8. 第一份 UTF-8 提案：直接追加在原始 FSS-UTF 提案后面（存档邮件）\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以 “We define 7 byte types” 为分割点，之前的是原始提案，后面是 Ken 和 Pike\n添加的。 - 译者注\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e— /usr/ken/utf/xutf from dump of Sep 2 1992 —\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eFile System Safe Universal Character Set Transformation Format (FSS-UTF)\n--------------------------------------------------------------------------\n\nWith the approval of ISO/IEC 10646 (Unicode) as an international\nstandard and the anticipated wide spread use of this universal coded\ncharacter set (UCS), it is necessary for historically ASCII based\noperating systems to devise ways to cope with representation and\nhandling of the large number of characters that are possible to be\nencoded by this new standard.\n\nThere are several challenges presented by UCS which must be dealt with\nby historical operating systems and the C-language programming\nenvironment. The most significant of these challenges is the encoding\nscheme used by UCS.  More precisely, the challenge is the marrying of\nthe UCS standard with existing programming languages and existing\noperating systems and utilities.\n\nThe challenges of the programming languages and the UCS standard are\nbeing dealt with by other activities in the industry.\tHowever, we are\nstill faced with the handling of UCS by historical operating systems and\nutilities. Prominent among the operating system UCS handling concerns is\nthe representation of the data within the file system. An underlying\nassumption is that there is an absolute requirement to maintain the\nexisting operating system software investment while at the same time\ntaking advantage of the use the large number of characters provided by\nthe UCS.\n\nUCS provides the capability to encode multi-lingual text within a single\ncoded character set.  However, UCS and its UTF variant do not protect\nnull bytes and/or the ASCII slash (\u0026#34;/\u0026#34;) making these character encodings\nincompatible with existing Unix implementations.  The following proposal\nprovides a Unix compatible transformation format of UCS such that Unix\nsystems can support multi-lingual text in a single encoding.  This\ntransformation format encoding is intended to be used as a file code.\nThis transformation format encoding of UCS is intended as an\nintermediate step towards full UCS support.  However, since nearly all\nUnix implementations face the same obstacles in supporting UCS, this\nproposal is intended to provide a common and compatible encoding during\nthis transition stage.\n\n\nGoal/Objective\n--------------\n\nWith the assumption that most, if not all, of the issues surrounding the\nhandling and storing of UCS in historical operating system file systems\nare understood, the objective is to define a UCS transformation format\nwhich also meets the requirement of being usable on a historical\noperating system file system in a non-disruptive manner. The intent is\nthat UCS will be the process code for the transformation format, which\nis usable as a file code.\n\nCriteria for the Transformation Format\n--------------------------------------\n\nBelow are the guidelines that were used in defining the UCS\ntransformation format:\n\n    1) Compatibility with historical file systems:\n\n   Historical file systems disallow the null byte and the ASCII\n   slash character as a part of the file name.\n\n    2) Compatibility with existing programs:\n\n   The existing model for multibyte processing is that ASCII does\n   not occur anywhere in a multibyte encoding.  There should be no\n   ASCII code values for any part of a transformation format\n   representation of a character that was not in the ASCII character\n   set in the UCS representation of the character.\n\n    3) Ease of conversion from/to UCS.\n\n    4) The first byte should indicate the number of bytes to follow in a\n   multibyte sequence.\n\n    5) The transformation format should not be extravagant in terms of\n   number of bytes used for encoding.\n\n\nProposed FSS-UTF\n----------------\n\nThe proposed UCS transformation format encodes UCS values in the range\n[0,0x7fffffff] using multibyte characters of lengths 1, 2, 3, 4, and 5\nbytes.  For all encodings of more than one byte, the initial byte\ndetermines the number of bytes used and the high-order bit in each byte\nis set.\n\nAn easy way to remember this transformation format is to note that the\nnumber of high-order 1\u0026#39;s in the first byte is the same as the number of\nsubsequent bytes in the multibyte character:\n\n   Bits  Hex Min  Hex Max         Byte Sequence in Binary\n1    7  00000000 0000007f 0zzzzzzz\n2   13  00000080 0000207f 10zzzzzz 1yyyyyyy\n3   19  00002080 0008207f 110zzzzz 1yyyyyyy 1xxxxxxx\n4   25  00082080 0208207f 1110zzzz 1yyyyyyy 1xxxxxxx 1wwwwwww\n5   31  02082080 7fffffff 11110zzz 1yyyyyyy 1xxxxxxx 1wwwwwww 1vvvvvvv\n\nThe bits included in the byte sequence is biased by the minimum value\nso that if all the z\u0026#39;s, y\u0026#39;s, x\u0026#39;s, w\u0026#39;s, and v\u0026#39;s are zero, the minimum\nvalue is represented.\tIn the byte sequences, the lowest-order encoded\nbits are in the last byte; the high-order bits (the z\u0026#39;s) are in the\nfirst byte.\n\nThis transformation format uses the byte values in the entire range of\n0x80 to 0xff, inclusive, as part of multibyte sequences.  Given the\nassumption that at most there are seven (7) useful bits per byte, this\ntransformation format is close to minimal in its number of bytes used.\n\nBelow are sample implementations of the C standard wctomb() and\nmbtowc() functions which demonstrate the algorithms for converting from\nUCS to the transformation format and converting from the transformation\nformat to UCS.  The sample implementations include error checks, some\nof which may not be necessary for conformance:\n\n#define OFF1   0x0000080\n#define OFF2   0x0002080\n#define OFF3   0x0082080\n#define OFF4   0x2082080\n\nint wctomb(char *s, wchar_t wc)\n{\n       if (s == 0)\n\t       return 0;       /* no shift states */\n#ifdef wchar_t_is_signed\n       if (wc \u0026lt; 0)\n\t       goto bad;\n#endif\n       if (wc \u0026lt;= 0x7f)         /* fits in 7 bits */\n       {\n\t       s[0] = wc;\n\t       return 1;\n       }\n       if (wc \u0026lt;= 0x1fff + OFF1)        /* fits in 13 bits */\n       {\n\t       wc -= OFF1;\n\t       s[0] = 0x80 | (wc \u0026gt;\u0026gt; 7);\n\t       s[1] = 0x80 | (wc \u0026amp; 0x7f);\n\t       return 2;\n       }\n       if (wc \u0026lt;= 0x7ffff + OFF2)       /* fits in 19 bits */\n       {\n\t       wc -= OFF2;\n\t       s[0] = 0xc0 | (wc \u0026gt;\u0026gt; 14);\n\t       s[1] = 0x80 | ((wc \u0026gt;\u0026gt; 7) \u0026amp; 0x7f);\n\t       s[2] = 0x80 | (wc \u0026amp; 0x7f);\n\t       return 3;\n       }\n       if (wc \u0026lt;= 0x1ffffff + OFF3)     /* fits in 25 bits */\n       {\n\t       wc -= OFF3;\n\t       s[0] = 0xe0 | (wc \u0026gt;\u0026gt; 21);\n\t       s[1] = 0x80 | ((wc \u0026gt;\u0026gt; 14) \u0026amp; 0x7f);\n\t       s[2] = 0x80 | ((wc \u0026gt;\u0026gt; 7) \u0026amp; 0x7f);\n\t       s[3] = 0x80 | (wc \u0026amp; 0x7f);\n\t       return 4;\n       }\n#if !defined(wchar_t_is_signed) || defined(wchar_t_is_more_than_32_bits)\n       if (wc \u0026gt; 0x7fffffff)\n\t       goto bad;\n#endif\n       wc -= OFF4;\n       s[0] = 0xf0 | (wc \u0026gt;\u0026gt; 28);\n       s[1] = 0x80 | ((wc \u0026gt;\u0026gt; 21) \u0026amp; 0x7f);\n       s[2] = 0x80 | ((wc \u0026gt;\u0026gt; 14) \u0026amp; 0x7f);\n       s[3] = 0x80 | ((wc \u0026gt;\u0026gt; 7) \u0026amp; 0x7f);\n       s[4] = 0x80 | (wc \u0026amp; 0x7f);\n       return 5;\nbad:;\n       errno = EILSEQ;\n       return -1;\n}\n\n\nint mbtowc(wchar_t *p, const char *s, size_t n)\n{\n       unsigned char *uc;      /* so that all bytes are nonnegative */\n\n       if ((uc = (unsigned char *)s) == 0)\n\t       return 0;               /* no shift states */\n       if (n == 0)\n\t       return -1;\n       if ((*p = uc[0]) \u0026lt; 0x80)\n\t       return uc[0] != \u0026#39;\\0\u0026#39;;   /* return 0 for \u0026#39;\\0\u0026#39;, else 1 */\n       if (uc[0] \u0026lt; 0xc0)\n       {\n\t       if (n \u0026lt; 2)\n\t\t       return -1;\n\t       if (uc[1] \u0026lt; 0x80)\n\t\t       goto bad;\n\t       *p \u0026amp;= 0x3f;\n\t       *p \u0026lt;\u0026lt;= 7;\n\t       *p |= uc[1] \u0026amp; 0x7f;\n\t       *p += OFF1;\n\t       return 2;\n       }\n       if (uc[0] \u0026lt; 0xe0)\n       {\n\t       if (n \u0026lt; 3)\n\t\t       return -1;\n\t       if (uc[1] \u0026lt; 0x80 || uc[2] \u0026lt; 0x80)\n\t\t       goto bad;\n\t       *p \u0026amp;= 0x1f;\n\t       *p \u0026lt;\u0026lt;= 14;\n\t       *p |= (uc[1] \u0026amp; 0x7f) \u0026lt;\u0026lt; 7;\n\t       *p |= uc[2] \u0026amp; 0x7f;\n\t       *p += OFF2;\n\t       return 3;\n       }\n       if (uc[0] \u0026lt; 0xf0)\n       {\n\t       if (n \u0026lt; 4)\n\t\t       return -1;\n\t       if (uc[1] \u0026lt; 0x80 || uc[2] \u0026lt; 0x80 || uc[3] \u0026lt; 0x80)\n\t\t       goto bad;\n\t       *p \u0026amp;= 0x0f;\n\t       *p \u0026lt;\u0026lt;= 21;\n\t       *p |= (uc[1] \u0026amp; 0x7f) \u0026lt;\u0026lt; 14;\n\t       *p |= (uc[2] \u0026amp; 0x7f) \u0026lt;\u0026lt; 7;\n\t       *p |= uc[3] \u0026amp; 0x7f;\n\t       *p += OFF3;\n\t       return 4;\n       }\n       if (uc[0] \u0026lt; 0xf8)\n       {\n\t       if (n \u0026lt; 5)\n\t\t       return -1;\n\t       if (uc[1] \u0026lt; 0x80 || uc[2] \u0026lt; 0x80 || uc[3] \u0026lt; 0x80 || uc[4] \u0026lt; 0x80)\n\t\t       goto bad;\n\t       *p \u0026amp;= 0x07;\n\t       *p \u0026lt;\u0026lt;= 28;\n\t       *p |= (uc[1] \u0026amp; 0x7f) \u0026lt;\u0026lt; 21;\n\t       *p |= (uc[2] \u0026amp; 0x7f) \u0026lt;\u0026lt; 14;\n\t       *p |= (uc[3] \u0026amp; 0x7f) \u0026lt;\u0026lt; 7;\n\t       *p |= uc[4] \u0026amp; 0x7f;\n\t       if (((*p += OFF4) \u0026amp; ~(wchar_t)0x7fffffff) == 0)\n\t\t       return 5;\n       }\nbad:;\n       errno = EILSEQ;\n       return -1;\n}\n\nWe define 7 byte types:\n\nT0\t0xxxxxxx\t7 free bits\nTx\t10xxxxxx\t6 free bits\nT1\t110xxxxx\t5 free bits\nT2\t1110xxxx\t4 free bits\nT3\t11110xxx\t3 free bits\nT4\t111110xx\t2 free bits\nT5\t111111xx\t2 free bits\n\nEncoding is as follows.\n\n\u0026gt;From hex\tThru hex\tSequence\t\tBits\n00000000\t0000007f\tT0\t\t\t7\n00000080\t000007FF\tT1 Tx\t\t\t11\n00000800\t0000FFFF\tT2 Tx Tx\t\t16\n00010000\t001FFFFF\tT3 Tx Tx Tx\t\t21\n00200000\t03FFFFFF\tT4 Tx Tx Tx Tx\t\t26\n04000000\tFFFFFFFF\tT5 Tx Tx Tx Tx Tx\t32\n\nSome notes:\n\n1. The 2 byte sequence has 2^11 codes, yet only 2^11-2^7\nare allowed. The codes in the range 0-7f are illegal.\nI think this is preferable to a pile of magic additive\nconstants for no real benefit. Similar comment applies\nto all of the longer sequences.\n\n2. The 4, 5, and 6 byte sequences are only there for\npolitical reasons. I would prefer to delete these.\n\n3. The 6 byte sequence covers 32 bits, the FSS-UTF\nproposal only covers 31.\n\n4. All of the sequences synchronize on any byte that is\nnot a Tx byte.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/tty-demystified-zh/\"\u003e\u003cspan\u003e« [译] TTY 的前世今生（2008）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/short-history-of-okr-zh/\"\u003e\u003cspan\u003e[译] OKR 极简史（OReilly, 2016） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-12-22T00:00:00Z",
  "Author": "Arthur Chiao"
}