{
  "Source": "arthurchiao.art",
  "Title": "[译] ltrace 是如何工作的（2016）",
  "Link": "https://arthurchiao.art/blog/how-does-ltrace-work-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] ltrace 是如何工作的（2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-02-07 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2016 年的一篇英文博客 \u003ca href=\"https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/\"\u003eHow Does ltrace Work\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e阅读本文之前，强烈建议先阅读下面几篇之前的文章：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/system-call-definitive-guide-zh/\"\u003e(译) Linux 系统调用权威指南\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/how-does-strace-work-zh/\"\u003e(译) strace/ptrace 是如何工作的\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e其中包含了本文所需的部分预备知识。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003ch2 id=\"太长不读tldr\"\u003e太长不读（TL;DR）\u003c/h2\u003e\n\n\u003cp\u003e本文介绍 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 内部是如何工作的，和我们的前一篇文章 \u003ca href=\"/blog/how-does-strace-work-zh/\"\u003estrace 是如何工作的\n\u003c/a\u003e 是兄弟篇。\u003c/p\u003e\n\n\u003cp\u003e文章首先会对比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 的异同；然后介绍 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 是如何基于\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用获取被跟踪进程的\u003cstrong\u003e库函数调用\u003c/strong\u003e信息的。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#太长不读tldr\" id=\"markdown-toc-太长不读tldr\"\u003e太长不读（TL;DR）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-ltracestrace-和-ptrace\" id=\"markdown-toc-1-ltracestrace-和-ptrace\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-重要概念\" id=\"markdown-toc-2-重要概念\"\u003e2 重要概念\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-程序调用函数库的流程\" id=\"markdown-toc-21-程序调用函数库的流程\"\u003e2.1 程序调用函数库的流程\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#plt-trampoline-代码\" id=\"markdown-toc-plt-trampoline-代码\"\u003ePLT trampoline 代码\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#流程总结\" id=\"markdown-toc-流程总结\"\u003e流程总结\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-断点的工作原理\" id=\"markdown-toc-22-断点的工作原理\"\u003e2.2 断点的工作原理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-在程序中插入断点的实现\" id=\"markdown-toc-23-在程序中插入断点的实现\"\u003e2.3 在程序中插入断点的实现\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-ltrace\" id=\"markdown-toc-3-ltrace\"\u003e3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-结束语\" id=\"markdown-toc-4-结束语\"\u003e4 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-我们的相关文章\" id=\"markdown-toc-5-我们的相关文章\"\u003e5 我们的相关文章\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-ltracestrace-和-ptrace\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e是一个系统调用\u003c/mark\u003e\u003c/strong\u003e，也是一个信号跟踪器（signal tracer），\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e主要用于\u003cstrong\u003e\u003cmark\u003e跟踪系统调用\u003c/mark\u003e\u003c/strong\u003e，打印系统调用的参数、返回值、时间戳等很多信息。\u003c/li\u003e\n  \u003cli\u003e也可以跟踪和打印进程收到的信号。\u003c/li\u003e\n  \u003cli\u003e在前一篇文章\u003ca href=\"/blog/how-does-strace-work-zh/\"\u003estrace 是如何工作的\u003c/a\u003e\n中介绍过， \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e内部基于 ptrace\u003c/mark\u003e\u003c/strong\u003e 系统调用。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 是一个\u003cstrong\u003e\u003cmark\u003e函数库调用跟踪器\u003c/mark\u003e\u003c/strong\u003e（library call tracer），\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e顾名思义，主要用于\u003cstrong\u003e\u003cmark\u003e跟踪程序的函数库调用\u003c/mark\u003e\u003c/strong\u003e信息。\u003c/li\u003e\n  \u003cli\u003e它也可以像 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 一样跟踪系统调用和信号。\u003c/li\u003e\n  \u003cli\u003e它的命令行参数和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 很相似。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e也是基于 ptrace\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e虽然 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e底层都是基于 ptrace 系统调用\u003c/mark\u003e\u003c/strong\u003e，\n但跟踪库函数和跟踪系统调用还是有很大差别的，这就是为什么会有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 的原因。\u003c/p\u003e\n\n\u003ch1 id=\"2-重要概念\"\u003e2 重要概念\u003c/h1\u003e\n\n\u003cp\u003e在介绍细节之前，我们需要先了解几个概念。\u003c/p\u003e\n\n\u003ch2 id=\"21-程序调用函数库的流程\"\u003e2.1 程序调用函数库的流程\u003c/h2\u003e\n\n\u003cp\u003e共享库可以被加载到任意地址。这意味着，共享库内的函数地址只有在运行时加载以后才能确定。\n即使重复执行同一程序，加载同一动态库，库内的函数地址也是不同的。\u003c/p\u003e\n\n\u003cp\u003e那么，程序是如何调用地址未知的函数的呢？\u003c/p\u003e\n\n\u003cp\u003e简短版的回答是：\u003cstrong\u003e二进制格式\u003c/strong\u003e、\u003cstrong\u003e操作系统\u003c/strong\u003e，以及\u003cstrong\u003e加载器\u003c/strong\u003e。在 Linux 上，这是一\n支程序和动态加载器之间的曼妙舞蹈。\u003c/p\u003e\n\n\u003cp\u003e下面是详细版的回答。\u003c/p\u003e\n\n\u003cp\u003eLinux 程序使用 \u003ca href=\"https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\"\u003eELF binary format\u003c/a\u003e，它提供了\n许多特性。出于本文目的，我们这里只介绍两个：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e过程链接表（Procedure Linkage Table，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ePLT\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n  \u003cli\u003e全局偏移表（Global Offset Table，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eGOT\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e库函数在 PLT 里都有一组对应的汇编指令，通常称作 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etrampoline\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，在函数被调用的时候执行。\u003c/p\u003e\n\n\u003ch3 id=\"plt-trampoline-代码\"\u003ePLT trampoline 代码\u003c/h3\u003e\n\n\u003cp\u003ePLT trampoline 都遵循类似的格式，下面是一个例子：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003ePLT1: jmp *name1@GOTPCREL(%rip)\n      pushq $index1\n      jmp .PLT0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一行代码跳转到一个地址，这个地址的值存储在 GOT 中。\u003c/li\u003e\n  \u003cli\u003eGOT 存储了绝对地址。这些地址在程序启动时初始化，指向 PLT \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epushq\u003c/code\u003e 指令所在的地址（第二行代码）。\u003c/li\u003e\n  \u003cli\u003e第三行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epushq $index1\u003c/code\u003e 为动态连接器准备一些数据，然后通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp .PLT0\u003c/code\u003e 跳转到另一段代码，后者会进而调用动态链接器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e动态链接器通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e$index1\u003c/code\u003e 和其他一些数据来判断程序想调用的是哪个库函数，然后定位\n到函数地址，并将其写入 GOT，覆盖之前初始化时的默认值。\u003c/p\u003e\n\n\u003cp\u003e当后面再次调用到这个函数时，就会直接找到函数地址，而不需再经过以上的动态链接器查\n找过程。\u003c/p\u003e\n\n\u003cp\u003e想更详细地了解这个过程，可以查看 \u003ca href=\"http://www.x86-64.org/documentation/abi.pdf\"\u003eSystem V AMD64\nABI\u003c/a\u003e，从 75 页开始。\u003c/p\u003e\n\n\u003ch3 id=\"流程总结\"\u003e流程总结\u003c/h3\u003e\n\n\u003cp\u003e总结起来：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e程序加载到内存时，程序和每个动态共享库（例如 DSO）通过 PLT 和 GOT 映射到内存\u003c/li\u003e\n  \u003cli\u003e程序开始执行时，动态共享库里的函数的内存地址是未知的，因为动态库可以被加载到程序地址空间的任意地址\u003c/li\u003e\n  \u003cli\u003e首次执行到一个函数的时候，执行过程转到函数的 PLT，里面是一些汇编代码（trampoline）\u003c/li\u003e\n  \u003cli\u003etrampoline 组织数据，然后调用动态链接器\u003c/li\u003e\n  \u003cli\u003e动态链接器通过 PLT 准备的数据找到函数地址\u003c/li\u003e\n  \u003cli\u003e将地址写入 GOT 表，然后执行转到该函数\u003c/li\u003e\n  \u003cli\u003e后面再次调用到这个函数时，不再经过动态链接器，因为 GOT 里已经存储了函数地址，PLT 可以直接调用\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e为了能够 hook 库函数调用，ltrace 必须将自己插入以上流程中\u003c/mark\u003e\u003c/strong\u003e。\n它的实现方式：\u003cstrong\u003e在函数的 PLT 表项里设置一个软件断点\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"22-断点的工作原理\"\u003e2.2 断点的工作原理\u003c/h2\u003e\n\n\u003cp\u003e断点（breakpoint）是使函数在特定的地方停止执行，然后让另一个程序（例如调试器，跟踪器）介入的方式。\u003c/p\u003e\n\n\u003cp\u003e有两类断点：硬件断点和软件断点。\u003c/p\u003e\n\n\u003cp\u003e硬件断点是 CPU 特性，数量比较有限。在 amd64 CPU 上有 4 个特殊的寄存器，可以设置让程序停止执行的地址。\u003c/p\u003e\n\n\u003cp\u003e软件断点通过特殊的汇编指令触发，数量不受限制。在 amd64 CPU 上，通过如下汇编指令触发软件断点：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这条指令会使处理器触发编号为 3 的中断，这个中断是专门为调试器准备的，\nLinux 内核有对应的中断处理函数，在执行的时候会向被调试程序发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号。\u003c/p\u003e\n\n\u003cp\u003e回忆我们前一篇讲 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 的\u003ca href=\"https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/\"\u003e文章\u003c/a\u003e，\n里面提到跟踪器可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用 attach 到程序。\n所有发送给被跟踪程序的信号会使得程序暂停执行，然后通知跟踪程序。\u003c/p\u003e\n\n\u003cp\u003e因此：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e程序执行到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e，执行过程被暂停\u003c/li\u003e\n  \u003cli\u003e触发内核中 3 号中断对应的中断处理函数\u003c/li\u003e\n  \u003cli\u003e中断处理函数经过一些调用，最终向程序发送一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号\u003c/li\u003e\n  \u003cli\u003e如果程序已经被其他（跟踪）程序通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e attach 了，那后者会收到一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这和前一篇文章介绍的使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 参数的过程类似。\u003c/p\u003e\n\n\u003cp\u003e那么，跟踪器或调试器是\u003cstrong\u003e如何将这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 指令插入程序的呢\u003c/strong\u003e？\u003c/p\u003e\n\n\u003ch2 id=\"23-在程序中插入断点的实现\"\u003e2.3 在程序中插入断点的实现\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e：修改运行程序的内存。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用接受一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erequest\u003c/code\u003e 参数，当设置为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e 时，\u003cstrong\u003e允许\n修改运行中程序的内存\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e调试器和跟踪器可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e 将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 指令在程序运行的时候写到程\n序的特定内存。\u003cstrong\u003e这就是断点如何设置的。\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch1 id=\"3-ltrace\"\u003e3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e\u003c/h1\u003e\n\n\u003cp\u003e将以上讲到的所有内容结合起来就得到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e： \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e = \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e +\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 的工作原理：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e attach 到运行中的程序\u003c/li\u003e\n  \u003cli\u003e定位程序的 PLT\u003c/li\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e 选项，用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 指令覆盖库函数的 PLT 中的汇编 trampoline\u003c/li\u003e\n  \u003cli\u003e恢复程序执行\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e接下来当调用到库函数时，程序会执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 指令：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 指令\u003c/li\u003e\n  \u003cli\u003e对应的内核中断处理函数开始执行\u003c/li\u003e\n  \u003cli\u003e内核通知 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 被跟踪进程有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号待处理\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 查看程序在调用哪个库函数，打印函数名、参数、时间戳等参数\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e最后，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 必须将插入到 PLT 的代码 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 替换为原来的代码，然后程序就可以\n恢复正常执行了：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e 将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $3\u003c/code\u003e 替换原来的指令\u003c/li\u003e\n  \u003cli\u003e程序恢复执行\u003c/li\u003e\n  \u003cli\u003e程序恢复正常执行，因为插入的断点被移除了\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 如何跟踪库函数调用的。\u003c/p\u003e\n\n\u003ch1 id=\"4-结束语\"\u003e4 结束语\u003c/h1\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统调用非常强大，可以跟踪系统调用、重写运行中程序的内存、读取运行中程\n序的寄存器等等。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 都使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 跟踪系统调用。两者的大致工作过程类\n似：为被跟踪程序触发 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSIGTRAP\u003c/code\u003e 信号，暂停执行，通知跟踪程序（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 或\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e），然后跟踪程序被“唤醒”，分析被暂停的程序。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eltrace\u003c/code\u003e 还会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_POKETEXT\u003c/code\u003e 重写程序内存，以便通过特殊指令中断程序的执行。\u003c/p\u003e\n\n\u003cp\u003e想了解更多 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTRACE_SYSCALL\u003c/code\u003e 的内部细节，可以阅读我们前一篇介绍 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estrace\u003c/code\u003e 的\u003ca href=\"https://blog.packagecloud.io/eng/2016/03/14/how-does-ltrace-work/\"\u003e博客\n\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"5-我们的相关文章\"\u003e5 我们的相关文章\u003c/h1\u003e\n\n\u003cp\u003e如果对本文感兴趣，那么你可能对我们的以下文章也感兴趣：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/system-call-definitive-guide-zh/\"\u003e(译) Linux 系统调用权威指南\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/how-does-strace-work-zh/\"\u003e(译) strace 是如何工作的\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/how-does-strace-work-zh/\"\u003e\u003cspan\u003e« [译] strace 是如何工作的（2016）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cilium-code-cni-create-network/\"\u003e\u003cspan\u003eCilium Code Walk Through: CNI Create Network »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-02-07T00:00:00Z",
  "Author": "Arthur Chiao"
}