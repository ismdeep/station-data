{
  "Source": "arthurchiao.art",
  "Title": "[译] Cilium：BPF 和 XDP 参考指南（2021）",
  "Link": "https://arthurchiao.art/blog/cilium-bpf-xdp-reference-guide-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Cilium：BPF 和 XDP 参考指南（2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-07-18 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 Cilium \u003cstrong\u003e\u003cmark\u003e1.10\u003c/mark\u003e\u003c/strong\u003e 的官方文档：\n\u003ca href=\"https://docs.cilium.io/en/v1.10/bpf/\"\u003e\u003cstrong\u003eBPF and XDP Reference Guide\u003c/strong\u003e\u003c/a\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e几年前翻译过一版：\u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-2019-zh/\"\u003eCilium：BPF 和 XDP 参考指南（2019）\u003c/a\u003e，\n对应 Cilium v1.6。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e本文对排版做了一些调整，以更适合网页阅读。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e本文的目标读者是 \u003cstrong\u003e“希望在技术层面对 BPF 和 XDP 有更深入理解的开发者和用户”\u003c/strong\u003e。虽\n然阅读本文有助于拓宽读者对 Cilium 的认识，但这并不是使用 Cilium 的前提条件。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBPF 是 \u003cstrong\u003eLinux 内核中\u003c/strong\u003e一个非常灵活与高效的\u003cstrong\u003e类虚拟机\u003c/strong\u003e（virtual machine-like）组件，\n能够在许多内核 hook 点\u003cstrong\u003e\u003cmark\u003e安全地\u003c/mark\u003e\u003c/strong\u003e执行字节码（bytecode ）。很多\n\u003cstrong\u003e内核子系统\u003c/strong\u003e都已经使用了 BPF，例如常见的\u003cstrong\u003e网络\u003c/strong\u003e（networking）、\u003cstrong\u003e跟踪\u003c/strong\u003e（\ntracing）与\u003cstrong\u003e安全\u003c/strong\u003e（security ，例如沙盒）。\u003c/p\u003e\n\n\u003cp\u003eBPF 其实早在 1992 年就出现了，但本文介绍的是\u003cstrong\u003e扩展的 BPF\u003c/strong\u003e（extended Berkeley Packet\nFilter，eBPF）。eBPF 最早出现在 3.18 内核中，此后原来的 BPF 就被称为 \u003cstrong\u003e“经典”\nBPF\u003c/strong\u003e（classic BPF, cBPF），cBPF 现在基本已经过时了。很多人知道 cBPF 是因为它是\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e 的包过滤语言。\u003cstrong\u003e现在，Linux 内核只运行 eBPF，内核会将加载的 cBPF 字节码\n透明地转换成 eBPF 再执行\u003c/strong\u003e。如无特殊说明，本文中所说的 BPF 都是泛指 BPF 技术。\u003c/p\u003e\n\n\u003cp\u003e虽然“伯克利包过滤器”（Berkeley Packet Filter）这个名字听起来像是专用于数据包过\n滤的，但如今这个指令集已经足够通用和灵活，因此现在 BPF 也有很多网络之外的使用案例，\n下文会列出一些项目。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCilium 在其数据平面（datapath）中重度使用了 BPF 技术\u003c/strong\u003e，更多信息可参考其\n\u003ca href=\"https://docs.cilium.io/en/v1.10/concepts/ebpf/#ebpf-datapath\"\u003eeBPF datapath 架构\u003c/a\u003e\n文档。\u003cstrong\u003e\u003cmark\u003e本文的目标\u003c/mark\u003e\u003c/strong\u003e是提供一份 BPF 参考指南，这份指南能帮助我们更\n深入地理解 BPF、BPF 网络相关的使用方式（例如用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 加载 BPF 程序，XDP 程序\n），以及更好地开发 Cilium 中的 BPF 模板。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-bpf-架构\" id=\"markdown-toc-1-bpf-架构\"\u003e1 BPF 架构\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-指令集\" id=\"markdown-toc-11-指令集\"\u003e1.1 指令集\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#111-指令集\" id=\"markdown-toc-111-指令集\"\u003e1.1.1 指令集\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#112-bpf-寄存器和调用约定\" id=\"markdown-toc-112-bpf-寄存器和调用约定\"\u003e1.1.2 BPF 寄存器和调用约定\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#113-bpf-指令格式\" id=\"markdown-toc-113-bpf-指令格式\"\u003e1.1.3 BPF 指令格式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-辅助函数\" id=\"markdown-toc-12-辅助函数\"\u003e1.2 辅助函数\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-maps\" id=\"markdown-toc-13-maps\"\u003e1.3 Maps\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-object-pinning钉住对象\" id=\"markdown-toc-14-object-pinning钉住对象\"\u003e1.4 Object Pinning（钉住对象）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-尾调用tail-calls\" id=\"markdown-toc-15-尾调用tail-calls\"\u003e1.5 尾调用（Tail Calls）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#16-bpf-to-bpf-calls\" id=\"markdown-toc-16-bpf-to-bpf-calls\"\u003e1.6 BPF to BPF Calls\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#17-jit\" id=\"markdown-toc-17-jit\"\u003e1.7 JIT\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#18-加固hardening\" id=\"markdown-toc-18-加固hardening\"\u003e1.8 加固（Hardening）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#19-offloads\" id=\"markdown-toc-19-offloads\"\u003e1.9 Offloads\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-工具链\" id=\"markdown-toc-2-工具链\"\u003e2 工具链\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-开发环境\" id=\"markdown-toc-21-开发环境\"\u003e2.1 开发环境\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#fedora\" id=\"markdown-toc-fedora\"\u003eFedora\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ubuntu\" id=\"markdown-toc-ubuntu\"\u003eUbuntu\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#opensuse-tumbleweed\" id=\"markdown-toc-opensuse-tumbleweed\"\u003eopenSUSE Tumbleweed\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#编译-linux-内核\" id=\"markdown-toc-编译-linux-内核\"\u003e编译 Linux 内核\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#验证编译好的内核\" id=\"markdown-toc-验证编译好的内核\"\u003e验证编译好的内核\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#编译-iproute2\" id=\"markdown-toc-编译-iproute2\"\u003e编译 iproute2\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#编译-bpftool\" id=\"markdown-toc-编译-bpftool\"\u003e编译 bpftool\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-llvm\" id=\"markdown-toc-22-llvm\"\u003e2.2 LLVM\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-bpf-target目标平台\" id=\"markdown-toc-221-bpf-target目标平台\"\u003e2.2.1 BPF Target（目标平台）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-调试信息dwarfbtf\" id=\"markdown-toc-222-调试信息dwarfbtf\"\u003e2.2.2 调试信息（DWARF、BTF）\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#dwarf-格式和-llvm-objdump\" id=\"markdown-toc-dwarf-格式和-llvm-objdump\"\u003eDWARF 格式和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#llvm-ir\" id=\"markdown-toc-llvm-ir\"\u003eLLVM IR\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#btf\" id=\"markdown-toc-btf\"\u003eBTF\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#pahole\" id=\"markdown-toc-pahole\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#readelf\" id=\"markdown-toc-readelf\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#223-bpf-指令集\" id=\"markdown-toc-223-bpf-指令集\"\u003e2.2.3 BPF 指令集\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#224-指令和寄存器位宽6432-位\" id=\"markdown-toc-224-指令和寄存器位宽6432-位\"\u003e2.2.4 指令和寄存器位宽（64/32 位）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#225-c-bpf-代码注意事项\" id=\"markdown-toc-225-c-bpf-代码注意事项\"\u003e2.2.5 C BPF 代码注意事项\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#1-所有函数都需要内联inlined没有函数调用对于老版本-llvm或共享库调用\" id=\"markdown-toc-1-所有函数都需要内联inlined没有函数调用对于老版本-llvm或共享库调用\"\u003e1. 所有函数都需要内联（inlined）、没有函数调用（对于老版本 LLVM）或共享库调用\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#2-多个程序可以放在同一-c-文件中的不同-section\" id=\"markdown-toc-2-多个程序可以放在同一-c-文件中的不同-section\"\u003e2. 多个程序可以放在同一 C 文件中的不同 section\u003c/a\u003e                \u003cul\u003e\n                  \u003cli\u003e\u003ca href=\"#示例程序\" id=\"markdown-toc-示例程序\"\u003e示例程序\u003c/a\u003e\u003c/li\u003e\n                  \u003cli\u003e\u003ca href=\"#其他程序说明\" id=\"markdown-toc-其他程序说明\"\u003e其他程序说明\u003c/a\u003e\u003c/li\u003e\n                \u003c/ul\u003e\n              \u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#3-不允许全局变量\" id=\"markdown-toc-3-不允许全局变量\"\u003e3. 不允许全局变量\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#4-不支持常量字符串或数组const-strings-or-arrays\" id=\"markdown-toc-4-不支持常量字符串或数组const-strings-or-arrays\"\u003e4. 不支持常量字符串或数组（const strings or arrays）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#5-使用-llvm-内置的函数做内存操作\" id=\"markdown-toc-5-使用-llvm-内置的函数做内存操作\"\u003e5. 使用 LLVM 内置的函数做内存操作\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#6-目前还不支持循环\" id=\"markdown-toc-6-目前还不支持循环\"\u003e6. （目前还）不支持循环\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#7-尾调用的用途\" id=\"markdown-toc-7-尾调用的用途\"\u003e7. 尾调用的用途\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#8-bpf-最大栈空间-512-字节\" id=\"markdown-toc-8-bpf-最大栈空间-512-字节\"\u003e8. BPF 最大栈空间 512 字节\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#9-尝试使用-bpf-内联汇编\" id=\"markdown-toc-9-尝试使用-bpf-内联汇编\"\u003e9. 尝试使用 BPF 内联汇编\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#10-用-pragma-pack-禁止结构体填充struct-padding\" id=\"markdown-toc-10-用-pragma-pack-禁止结构体填充struct-padding\"\u003e10. 用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#pragma pack\u003c/code\u003e 禁止结构体填充（struct padding）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#11-通过未验证的引用invalidated-references访问包数据\" id=\"markdown-toc-11-通过未验证的引用invalidated-references访问包数据\"\u003e11. 通过未验证的引用（invalidated references）访问包数据\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-iproute2\" id=\"markdown-toc-23-iproute2\"\u003e2.3 iproute2\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-加载-xdp-bpf-对象文件\" id=\"markdown-toc-231-加载-xdp-bpf-对象文件\"\u003e2.3.1 加载 XDP BPF 对象文件\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#xdp-工作模式\" id=\"markdown-toc-xdp-工作模式\"\u003eXDP 工作模式\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-加载-tc-bpf-对象文件\" id=\"markdown-toc-232-加载-tc-bpf-对象文件\"\u003e2.3.2 加载 tc BPF 对象文件\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#用-tc-加载-bpf-程序\" id=\"markdown-toc-用-tc-加载-bpf-程序\"\u003e用 tc 加载 BPF 程序\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#查看已经-attach-的程序\" id=\"markdown-toc-查看已经-attach-的程序\"\u003e查看已经 attach 的程序\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#程序优先级pref和句柄handle\" id=\"markdown-toc-程序优先级pref和句柄handle\"\u003e程序优先级（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e）和句柄（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#用-tc-删除-bpf-程序\" id=\"markdown-toc-用-tc-删除-bpf-程序\"\u003e用 tc 删除 BPF 程序\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#offload-到网卡\" id=\"markdown-toc-offload-到网卡\"\u003eoffload 到网卡\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#233-通过-netdevsim-驱动测试-bpf-offload\" id=\"markdown-toc-233-通过-netdevsim-驱动测试-bpf-offload\"\u003e2.3.3 通过 netdevsim 驱动测试 BPF offload\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-bpftool\" id=\"markdown-toc-24-bpftool\"\u003e2.4 bpftool\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-bpf-sysctls\" id=\"markdown-toc-25-bpf-sysctls\"\u003e2.5 BPF sysctls\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#26-内核测试\" id=\"markdown-toc-26-内核测试\"\u003e2.6 内核测试\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#27-jit-debugging\" id=\"markdown-toc-27-jit-debugging\"\u003e2.7 JIT Debugging\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#28-内省introspection\" id=\"markdown-toc-28-内省introspection\"\u003e2.8 内省（Introspection）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#29-tracing-pipe\" id=\"markdown-toc-29-tracing-pipe\"\u003e2.9 Tracing pipe\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#210-其他miscellaneous\" id=\"markdown-toc-210-其他miscellaneous\"\u003e2.10 其他（Miscellaneous）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-程序类型\" id=\"markdown-toc-3-程序类型\"\u003e3 程序类型\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-xdp\" id=\"markdown-toc-31-xdp\"\u003e3.1 XDP\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-程序返回码\" id=\"markdown-toc-bpf-程序返回码\"\u003eBPF 程序返回码\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#xdp-使用案例\" id=\"markdown-toc-xdp-使用案例\"\u003eXDP 使用案例\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#xdp-工作模式-1\" id=\"markdown-toc-xdp-工作模式-1\"\u003eXDP 工作模式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#驱动支持\" id=\"markdown-toc-驱动支持\"\u003e驱动支持\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#支持-native-xdp-的驱动\" id=\"markdown-toc-支持-native-xdp-的驱动\"\u003e支持 native XDP 的驱动\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#支持-offloaded-xdp-的驱动\" id=\"markdown-toc-支持-offloaded-xdp-的驱动\"\u003e支持 offloaded XDP 的驱动\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-tc\" id=\"markdown-toc-32-tc\"\u003e3.2 tc\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#tc-和-xdp-bpf-程序的不同\" id=\"markdown-toc-tc-和-xdp-bpf-程序的不同\"\u003etc 和 XDP BPF 程序的不同\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#1-输入上下文\" id=\"markdown-toc-1-输入上下文\"\u003e1. 输入上下文\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#2-hook-触发点\" id=\"markdown-toc-2-hook-触发点\"\u003e2. hook 触发点\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#3-是否依赖驱动支持\" id=\"markdown-toc-3-是否依赖驱动支持\"\u003e3. 是否依赖驱动支持\u003c/a\u003e                \u003cul\u003e\n                  \u003cli\u003e\u003ca href=\"#ingress\" id=\"markdown-toc-ingress\"\u003eIngress\u003c/a\u003e\u003c/li\u003e\n                  \u003cli\u003e\u003ca href=\"#egress\" id=\"markdown-toc-egress\"\u003eEgress\u003c/a\u003e\u003c/li\u003e\n                \u003c/ul\u003e\n              \u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#cls_bpf-分类器\" id=\"markdown-toc-cls_bpf-分类器\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 分类器\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tc-bpf-程序返回码\" id=\"markdown-toc-tc-bpf-程序返回码\"\u003etc BPF 程序返回码\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#tc_act_unspec-和-tc_act_ok\" id=\"markdown-toc-tc_act_unspec-和-tc_act_ok\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#tc_act_shot-和-tc_act_stolen\" id=\"markdown-toc-tc_act_shot-和-tc_act_stolen\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_SHOT\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#tc_act_redirect\" id=\"markdown-toc-tc_act_redirect\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_REDIRECT\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tc-bpf-faq\" id=\"markdown-toc-tc-bpf-faq\"\u003etc BPF FAQ\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tc-bpf-使用案例\" id=\"markdown-toc-tc-bpf-使用案例\"\u003etc BPF 使用案例\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#驱动支持-1\" id=\"markdown-toc-驱动支持-1\"\u003e驱动支持\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#支持-offload-tc-bpf-程序的驱动\" id=\"markdown-toc-支持-offload-tc-bpf-程序的驱动\"\u003e支持 offload tc BPF 程序的驱动\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_arch\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"1-bpf-架构\"\u003e1 BPF 架构\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003eBPF 不仅仅是一个指令集，它还提供了围绕自身的一些基础设施\u003c/strong\u003e，例如：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003eBPF map\u003c/strong\u003e：高效的 key/value 存储\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e辅助函数\u003c/strong\u003e（helper function）：可以更方便地利用内核功能或与内核交互\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e尾调用\u003c/strong\u003e（tail call）：高效地调用其他 BPF 程序\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e安全加固原语\u003c/strong\u003e（security hardening primitives）\u003c/li\u003e\n  \u003cli\u003e用于 pin/unpin 对象（例如 map、程序）的\u003cstrong\u003e伪文件系统\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpffs\u003c/code\u003e），实现持久存储\u003c/li\u003e\n  \u003cli\u003e支持 BPF \u003cstrong\u003eoffload\u003c/strong\u003e（例如 offload 到网卡）的基础设施\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eLLVM 提供了一个 \u003cstrong\u003eBPF 后端\u003c/strong\u003e（back end），因此使用 clang 这样的工具就可以将 C 代\n码编译成 BPF \u003cstrong\u003e对象文件\u003c/strong\u003e（object file），然后再加载到内核。BPF 深度绑定 Linux\n内核，可以在 \u003cstrong\u003e\u003cmark\u003e不牺牲原生内核性能的前提下，实现对内核的完全可编程\u003c/mark\u003e\u003c/strong\u003e\n（full programmability）。\u003c/p\u003e\n\n\u003cp\u003e另外， \u003cstrong\u003e使用了 BPF 的内核子系统也是 BPF 基础设施的一部分\u003c/strong\u003e。本文将主要讨论\n\u003cstrong\u003e\u003cmark\u003etc和 XDP\u003c/mark\u003e\u003c/strong\u003e 这两个子系统，二者都支持 attach（附着）BPF 程序。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003eXDP BPF 程序\u003c/strong\u003e会被 attach 到\u003cstrong\u003e网络驱动的最早阶段\u003c/strong\u003e（earliest networking driver\nstage），\u003cstrong\u003e驱动收到包之后就会触发 BPF 程序的执行\u003c/strong\u003e。从定义上来说，这\u003cstrong\u003e可以取得\n最好的包处理性能\u003c/strong\u003e，因为这已经是\u003cstrong\u003e\u003cmark\u003e软件中最早可以处理包的位置\u003c/mark\u003e\u003c/strong\u003e了。但也正因为\n这一步的处理在网络栈中是如此之早，\u003cstrong\u003e\u003cmark\u003e协议栈此时还没有从包中提取出元数据\u003c/mark\u003e\u003c/strong\u003e（因此\nXDP BPF 程序无法利用这些元数据）。\u003c/li\u003e\n  \u003cli\u003etc BPF 程序在内核栈中稍后面的一些地方执行，因此它们\u003cstrong\u003e\u003cmark\u003e能够访问更多的元数据和一些核心的内核功能\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e除了 tc 和 XDP 程序之外，还有很多其他内核子系统也在使用 BPF，例如跟踪子系统（\nkprobes、uprobes、tracepoints 等等）。\u003c/p\u003e\n\n\u003cp\u003e下面的各小节进一步介绍 BPF 架构。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_instruction\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"11-指令集\"\u003e1.1 指令集\u003c/h2\u003e\n\n\u003ch3 id=\"111-指令集\"\u003e1.1.1 指令集\u003c/h3\u003e\n\n\u003cp\u003eBPF 是一个通用目的 RISC 指令集，其\u003cstrong\u003e最初的设计目标\u003c/strong\u003e是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e用 \u003cstrong\u003e\u003cmark\u003eC 语言\u003c/mark\u003e\u003c/strong\u003e的一个子集\u003cstrong\u003e\u003cmark\u003e编写\u003c/mark\u003e\u003c/strong\u003e程序，\u003c/li\u003e\n  \u003cli\u003e然后用一个\u003cstrong\u003e\u003cmark\u003e编译器后端\u003c/mark\u003e\u003c/strong\u003e（例如 LLVM）将其\u003cstrong\u003e\u003cmark\u003e编译\u003c/mark\u003e\u003c/strong\u003e成 BPF 指令，\u003c/li\u003e\n  \u003cli\u003e稍后内核再通过一个位于内核中的（in-kernel）\u003cstrong\u003e\u003cmark\u003e即时编译器（JIT Compiler）\u003c/mark\u003e\u003c/strong\u003e\n将 BPF 指令\u003cstrong\u003e\u003cmark\u003e映射\u003c/mark\u003e\u003c/strong\u003e成处理器的原生指令（opcode ），以获得在内核中的最佳执行性能。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e将这些指令\u003cstrong\u003e\u003cmark\u003e下放到内核中可以带来如下好处\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e无需在内核/用户空间切换\u003c/strong\u003e就可以实现内核的可编程。例如，Cilium 这种和网络相关\n的 BPF 程序能直接在内核中实现灵活的容器策略、负载均衡等功能，\n而\u003cstrong\u003e\u003cmark\u003e无需将包送先到用户空间，处理之后再送回内核\u003c/mark\u003e\u003c/strong\u003e。\n需要在 \u003cstrong\u003eBPF 程序之间或内核/用户空间之间共享状态\u003c/strong\u003e时，可以使用 BPF map。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e可编程 datapath\u003c/strong\u003e 具有很大的灵活性，因此程序能\u003cstrong\u003e在编译时将不需要的特性禁用掉，\n从而极大地优化程序的性能\u003c/strong\u003e。例如，如果容器不需要 IPv4，那编写 BPF 程序时就可以\n只处理 IPv6 的情况，从而节省了快速路径（fast path）中的资源。\u003c/li\u003e\n  \u003cli\u003e对于网络场景（例如 tc 和 XDP），BPF 程序可以在\u003cstrong\u003e无需重启内核、系统服务或容器的\n情况下实现原子更新，并且不会导致网络中断\u003c/strong\u003e。另外，\u003cstrong\u003e更新 BPF map 不会导致程序\n状态（program state）的丢失\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eBPF 给用户空间\u003cstrong\u003e提供了一个稳定的 ABI\u003c/strong\u003e，而且\u003cstrong\u003e不依赖任何第三方内核模块\u003c/strong\u003e。BPF\n是 Linux 内核的一个核心组成部分，而 Linux 已经得到了广泛的部署，因此可以保证现\n有的 BPF 程序能在新的内核版本上继续运行。这种保证与\u003cstrong\u003e系统调用\u003c/strong\u003e（内核提供给用\n户态应用的接口）是同一级别的。另外，BPF 程序\u003cstrong\u003e在不同平台上是可移植的\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eBPF 程序\u003cstrong\u003e与内核协同工作\u003c/strong\u003e，\u003cstrong\u003e复用已有的内核基础设施\u003c/strong\u003e（例如驱动、netdevice、\n隧道、协议栈和 socket）和工具（例如 iproute2），以及内核提供的安全保证。\n\u003cstrong\u003e和内核模块不同，BPF 程序会由一个位于内核中的校验器（in-kernel verifier）进行校验，\n以确保它们不会造成内核崩溃、程序永远会终止等等\u003c/strong\u003e。例如，XDP 程序会复用已有的内\n核驱动，能够直接操作存放在 DMA 缓冲区中的数据帧，而不用像某些模型（例如 DPDK）\n那样将这些数据帧甚至整个驱动暴露给用户空间。而且，XDP 程序\u003cstrong\u003e复用\u003c/strong\u003e内核协议栈而\n不是绕过它。\u003cstrong\u003e\u003cmark\u003eBPF 程序可以看做是内核设施之间的通用“胶水代码”\u003c/mark\u003e\u003c/strong\u003e，\n基于 BPF 可以设计巧妙的程序，解决特定的问题。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBPF 程序在内核中的执行总是\u003cstrong\u003e事件驱动\u003c/strong\u003e的！例如：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果网卡的 ingress 路径上 attach 了 BPF 程序，那当网卡收到包之后就会触发这\n个 BPF 程序的执行。\u003c/li\u003e\n  \u003cli\u003e在某个\u003cstrong\u003e有 kprobe 探测点的内核地址\u003c/strong\u003e attach 一段 BPF 程序后，当\n内核执行到这个地址时会发生\u003cstrong\u003e陷入\u003c/strong\u003e（trap），进而唤醒 \u003cstrong\u003ekprobe 的回调函数\u003c/strong\u003e，后\n者又会触发 attach 的 BPF 程序的执行。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"112-bpf-寄存器和调用约定\"\u003e1.1.2 BPF 寄存器和调用约定\u003c/h3\u003e\n\n\u003cp\u003eBPF 由下面几部分组成：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e11 个 64 位寄存器（这些寄存器包含 32 位子寄存器）\u003c/li\u003e\n  \u003cli\u003e一个程序计数器（program counter，PC）\u003c/li\u003e\n  \u003cli\u003e一个 512 字节大小的 BPF 栈空间（从实现的层面理解为什么有 512 字节的限制，\n  可参考 \u003ca href=\"/blog/linux-socket-filtering-aka-bpf-zh/\"\u003e\u003cmark\u003e(译) Linux Socket Filtering (LSF, aka BPF)（Kernel，2021）\u003c/mark\u003e\u003c/a\u003e，译注。）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e寄存器的名字从 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er10\u003c/code\u003e\u003c/strong\u003e。\u003cstrong\u003e默认的运行模式是 64 位\u003c/strong\u003e，32 位子寄存器只能\n通过特殊的 ALU（arithmetic logic unit）访问。向 32 位子寄存器写入时，会用 0 填充\n到 64 位。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er10\u003c/code\u003e 是唯一的只读寄存器，其中存放的是访问 BPF 栈空间的栈帧指针（frame pointer）\n地址。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er9\u003c/code\u003e 是可以被读/写的通用目的寄存器。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序可以调用核心内核（而不是内核模块）预定义的一些辅助函数。\u003cstrong\u003eBPF 调用约定\u003c/strong\u003e\n定义如下：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e 存放被调用的辅助函数的返回值\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er1\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er5\u003c/code\u003e 存放 BPF 调用内核辅助函数时传递的参数\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er6\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er9\u003c/code\u003e 由被调用方（callee）保存，在函数返回之后调用方（caller）可以读取\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBPF 调用约定足够通用，\u003cstrong\u003e能够直接映射到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm64\u003c/code\u003e 和其他 ABI\u003c/strong\u003e，因此所有\n的 \u003cstrong\u003e\u003cmark\u003eBPF 寄存器可以一一映射到硬件 CPU 寄存器\u003c/mark\u003e\u003c/strong\u003e，JIT 只需要发出一条调用指令，而不\n需要额外的放置函数参数（placing function arguments）动作。这套约定在不牺牲性能的\n前提下，考虑了尽可能通用的调用场景。目前不支持 6 个及以上参数的函数调用，内核中\nBPF 相关的辅助函数（从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CALL_0()\u003c/code\u003e 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CALL_5()\u003c/code\u003e 函数）也特意设计地与此相\n匹配。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e 寄存器还用于保存 \u003cstrong\u003eBPF 程序的退出值\u003c/strong\u003e。退出值的语义由程序类型决定。另外，\n当将执行权交回内核时，退出值是以 32 位传递的。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er1\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er5\u003c/code\u003e 寄存器是 \u003cstrong\u003escratch registers\u003c/strong\u003e，意思是说，如果要在多次辅助函数调用之\n间重用这些寄存器内的值，那 BPF 程序需要负责将这些值临时转储（spill）到 BPF 栈上\n，或者保存到被调用方（callee）保存的寄存器中。\u003cstrong\u003eSpilling\u003c/strong\u003e（倒出/转储）\n的意思是这些寄存器内的变量被移到了 BPF 栈中。相反的操作，即将变量从 BPF 栈移回寄\n存器，称为 \u003cstrong\u003efilling\u003c/strong\u003e（填充）。\u003cstrong\u003e\u003cmark\u003espilling/filling 的原因是寄存器数量有限\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序开始执行时，\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er1\u003c/code\u003e 寄存器中存放的是程序的上下文\u003c/strong\u003e（context）。上下文就是\n\u003cstrong\u003e程序的输入参数\u003c/strong\u003e（和典型 C 程序的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eargc/argv\u003c/code\u003e 类似）。\u003cstrong\u003eBPF 只能在单个上下文中\n工作\u003c/strong\u003e（restricted to work on a single context）。这个\u003cstrong\u003e\u003cmark\u003e上下文是由程序类型定义的\u003c/mark\u003e\u003c/strong\u003e，\n例如，网络程序可以将网络包的内核表示（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e）作为输入参数。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eBPF 的通用操作都是 64 位的\u003c/strong\u003e，这和默认的 64 位架构模型相匹配，这样可以对指针进\n行算术操作，以及在调用辅助函数时传递指针和 64 位值；另外，BPF 还支持 64 位原子操\n作。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e每个 BPF 程序的最大指令数限制在 4096 条以内\u003c/strong\u003e，这意味着从设计上就可以保证\u003cstrong\u003e每\n个程序都会很快结束\u003c/strong\u003e。\u003cstrong\u003e\u003cmark\u003e对于内核 5.1+，这个限制放大到了 100 万条\u003c/mark\u003e\u003c/strong\u003e。\n虽然指令集中包含前向和后向跳转，但内核中的 BPF 校验器禁止\n程序中有循环，因此可以永远保证程序会终止。因为 BPF 程序运行在内核，校验器的工作\n是保证这些程序在运行时是安全的，不会影响到系统的稳定性。这意味着，从指令集的角度\n来说循环是可以实现的，但校验器会对其施加限制。另外，BPF 中有尾调用的概念，允许一\n个 BPF 程序调用另一个 BPF 程序。类似地，这种调用也是有限制的，目前上限是 33 层调\n用；现在这个功能常用来对程序逻辑进行解耦，例如解耦成几个不同阶段。\u003c/p\u003e\n\n\u003ch3 id=\"113-bpf-指令格式\"\u003e1.1.3 BPF 指令格式\u003c/h3\u003e\n\n\u003cp\u003eBPF 指令格式（instruction format）建模为两操作数指令（two operand instructions），\n这种格式可以在 \u003cstrong\u003e\u003cmark\u003eJIT 阶段\u003c/mark\u003e\u003c/strong\u003e将 BPF 指令\u003cstrong\u003e\u003cmark\u003e映射（mapping）\u003c/mark\u003e\u003c/strong\u003e为原生指令。指令集是固定长\n度的，这意味着每条指令都是 64 比特编码的。目前已经实现了 87 条指令，并且在需要时\n可以对指令集进行进一步扩展。一条 64 位指令在大端机器上的编码格式如下，从重要性最\n高比特（most significant bit，MSB）到重要性最低比特（least significant bit，LSB）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eop:8, dst_reg:4, src_reg:4, off:16, imm:32\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimm\u003c/code\u003e 都是有符号类型。编码信息定义在内核头文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/bpf.h\u003c/code\u003e 中，这个头\n文件进一步 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einclude\u003c/code\u003e 了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/bpf_common.h\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 定了将要执行的操作。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 复用了大部分 cBPF 的编码定义。操作可以基于寄存器值\n，也可以基于立即操作数（immediate operands）。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 自身的编码信息中包含了应该使\n用的模式类型：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_X\u003c/code\u003e 指基于寄存器的操作数（register-based operations）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_K\u003c/code\u003e 指基于立即操作数（immediate-based operations）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e对于后者，目的操作数永远是一个寄存器（destination operand is always a register）。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_reg\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_reg\u003c/code\u003e 都提供了寄存器操作数（register operands，例如\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er9\u003c/code\u003e）的额外信息。在某些指令中，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff\u003c/code\u003e 用于表示一个相对偏移量（offset），\n例如，对那些 BPF 可用的栈或缓冲区（例如 map values、packet data 等等）进行寻\n址，或者跳转指令中用于跳转到目标。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimm\u003c/code\u003e 存储一个常量/立即值。\u003c/p\u003e\n\n\u003cp\u003e所有的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 指令可以分为若干类别。类别信息也编码到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 字段。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 字段分为（\n从 MSB 到 LSB）：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecode:4\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esource:1\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclass:3\u003c/code\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclass\u003c/code\u003e 是指令类型\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecode\u003c/code\u003e 指特定类型的指令中的某种特定操作码（operational code）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esource\u003c/code\u003e 可以告诉我们源操作数（source operand）是一个寄存器还是一个立即数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可能的指令类别包括：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LDX\u003c/code\u003e：\u003cstrong\u003e加载操作\u003c/strong\u003e（load operations）\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD\u003c/code\u003e 用于加载\u003cstrong\u003edouble word 长度的特殊指令\u003c/strong\u003e（占两个指令长度，源于\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimm:32\u003c/code\u003e 的限制），或byte / half-word / word 长度的\u003cstrong\u003e包数据\u003c/strong\u003e（packet data\n）。后者是从 cBPF 中延续过来的，主要为了保证 cBPF 到 BPF 翻译的高效，因为\n这里的 JIT code 是优化过的。对于 native BPF 来说，这些包加载指令在今天已经\n用的很少了。\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LDX\u003c/code\u003e 用于从内存中加载 byte / half-word / word / double-word，这里的内\n存包括栈内存、map value data、packet data 等等。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ST\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_STX\u003c/code\u003e：\u003cstrong\u003e存储操作\u003c/strong\u003e（store operations）\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_STX\u003c/code\u003e 与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LDX\u003c/code\u003e 相对，将某个寄存器中的值存储到内存中，同样，这里的\n内存可以是栈内存、map value、packet data 等等。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_STX\u003c/code\u003e 类包含一些 word\n和 double-word 相关的原子加操作，例如，可以用于计数器。\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ST\u003c/code\u003e 类与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_STX\u003c/code\u003e 类似，提供了将数据存储到内存的操作，只不过其源操作\n数（source operand）必须是一个立即值（immediate value）。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU64\u003c/code\u003e：\u003cstrong\u003e逻辑运算操作\u003c/strong\u003e（ALU operations）\u003c/p\u003e\n\n    \u003cp\u003eGenerally,\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU\u003c/code\u003e operations are in 32 bit mode and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU64\u003c/code\u003e in 64 bit mode.\n  Both ALU classes have basic operations with source operand which is register-based\n  and an immediate-based counterpart. Supported by both are add (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e+\u003c/code\u003e), sub (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-\u003c/code\u003e),\n  and (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026amp;\u003c/code\u003e), or (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e|\u003c/code\u003e), left shift (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;\u0026lt;\u003c/code\u003e), right shift (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;\u0026gt;\u003c/code\u003e), xor (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e^\u003c/code\u003e),\n  mul (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e*\u003c/code\u003e), div (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/\u003c/code\u003e), mod (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%\u003c/code\u003e), neg (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~\u003c/code\u003e) operations. Also mov (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;X\u0026gt; := \u0026lt;Y\u0026gt;\u003c/code\u003e)\n  was added as a special ALU operation for both classes in both operand modes.\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU64\u003c/code\u003e also contains a signed right shift. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ALU\u003c/code\u003e additionally\n  contains endianness conversion instructions for half-word / word / double-word\n  on a given source register.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_JMP\u003c/code\u003e：\u003cstrong\u003e跳转操作\u003c/strong\u003e（jump operations）\u003c/p\u003e\n\n    \u003cp\u003eJumps can be unconditional\n  and conditional. Unconditional jumps simply move the program counter forward, so\n  that the next instruction to be executed relative to the current instruction is\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff + 1\u003c/code\u003e, where \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff\u003c/code\u003e is the constant offset encoded in the instruction. Since\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff\u003c/code\u003e is signed, the jump can also be performed backwards as long as it does not\n  create a loop and is within program bounds. Conditional jumps operate on both,\n  register-based and immediate-based source operands. If the condition in the jump\n  operations results in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrue\u003c/code\u003e, then a relative jump to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff + 1\u003c/code\u003e is performed,\n  otherwise the next instruction (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0 + 1\u003c/code\u003e) is performed. This fall-through\n  jump logic differs compared to cBPF and allows for better branch prediction as it\n  fits the CPU branch predictor logic more naturally. Available conditions are\n  jeq (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e==\u003c/code\u003e), jne (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!=\u003c/code\u003e), jgt (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;\u003c/code\u003e), jge (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;=\u003c/code\u003e), jsgt (signed \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;\u003c/code\u003e), jsge\n  (signed \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;=\u003c/code\u003e), jlt (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;\u003c/code\u003e), jle (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;=\u003c/code\u003e), jslt (signed \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;\u003c/code\u003e), jsle (signed\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;=\u003c/code\u003e) and jset (jump if \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDST \u0026amp; SRC\u003c/code\u003e). Apart from that, there are three\n  special jump operations within this class: the exit instruction which will leave\n  the BPF program and return the current value in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e as a return code, the call\n  instruction, which will issue a function call into one of the available BPF helper\n  functions, and a hidden tail call instruction, which will jump into a different\n  BPF program.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eLinux 内核中内置了一个 BPF 解释器\u003c/strong\u003e，该解释器能够执行由 BPF 指令组成的程序。即\n使是 cBPF 程序，也可以在内核中透明地转换成 eBPF 程序，除非该架构仍然内置了 cBPF\nJIT，还没有迁移到 eBPF JIT。\u003c/p\u003e\n\n\u003cp\u003e目前下列架构都内置了内核 eBPF JIT 编译器：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eppc64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es390x\u003c/code\u003e\n、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emips64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esparc64\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e所有的 BPF 操作\u003c/mark\u003e\u003c/strong\u003e，例如加载程序到内核，或者创建 BPF map，\n\u003cstrong\u003e\u003cmark\u003e都是通过核心的 \u003ccode\u003ebpf()\u003c/code\u003e 系统调用完成的\u003c/mark\u003e\u003c/strong\u003e。它还用于管理 map 表项（查\n找/更新/删除），以及通过 pinning 将程序和 map 持久化到 BPF 文件系统。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_helper\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"12-辅助函数\"\u003e1.2 辅助函数\u003c/h2\u003e\n\n\u003cp\u003e辅助函数（Helper functions）使得 BPF 能够通过一组内核定义的函数调用（function\ncall）来从内核中查询数据，或者将数据推送到内核。\u003cstrong\u003e不同类型的 BPF 程序能够使用的\n辅助函数可能是不同的\u003c/strong\u003e，例如，与 attach 到 tc 层的 BPF 程序相比，attach 到\nsocket 的 BPF程序只能够调用前者可以调用的辅助函数的一个子集。另外一个例子是，\n\u003cstrong\u003e\u003cmark\u003e轻量级隧道\u003c/mark\u003e\u003c/strong\u003e（lightweight tunneling ）使用的封装和解封装（Encapsulation and\ndecapsulation）辅助函数，\u003cstrong\u003e\u003cmark\u003e只能被更低的 tc 层（lower tc layers）使用\u003c/mark\u003e\u003c/strong\u003e；而推送通知到\n用户态所使用的事件输出辅助函数，既可以被 tc 程序使用也可以被 XDP 程序使用。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e所有的辅助函数都共享同一个通用的、和系统调用类似的函数签名\u003c/strong\u003e。签名定义如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003efn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e前一节介绍的调用约定适用于所有的 BPF 辅助函数。\u003c/p\u003e\n\n\u003cp\u003e内核将辅助函数抽象成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CALL_0()\u003c/code\u003e 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CALL_5()\u003c/code\u003e 几个宏，形式和相应类型的系\n统调用类似。下面的例子是从某个辅助函数中抽取出来的，可以看到它通过调用相应 map\n的回调函数完成更新 map 元素的操作：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eBPF_CALL_4\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_map_update_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n           \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eWARN_ON_ONCE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ercu_read_lock_held\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eops\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003emap_update_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_func_proto\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map_update_elem_proto\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunc\u003c/span\u003e           \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map_update_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egpl_only\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eret_type\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eRET_INTEGER\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg1_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_CONST_MAP_PTR\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg2_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_PTR_TO_MAP_KEY\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg3_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_PTR_TO_MAP_VALUE\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg4_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_ANYTHING\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这种方式有很多优点：虽然 cBPF 允许其加载指令（load instructions）进行\n\u003cstrong\u003e\u003cmark\u003e超出范围的访问\u003c/mark\u003e\u003c/strong\u003e（overload），以便从一个\u003cstrong\u003e\u003cmark\u003e看似不可能的包偏移量\u003c/mark\u003e\u003c/strong\u003e（packet offset，负的）位置\n获取数据以唤醒多功能辅助函数，但每个 cBPF JIT 仍然需要为这个 cBPF extension 实现对应的支持。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多关于 Linux BPF extension 的内容，可参考\n\u003ca href=\"/blog/linux-socket-filtering-aka-bpf-zh/\"\u003e\u003cmark\u003e(译) Linux Socket Filtering (LSF, aka BPF)（Kernel，2021）\u003c/mark\u003e\u003c/a\u003e，\n译注中附录了一些相关的\u003cstrong\u003e\u003cmark\u003e内核实现\u003c/mark\u003e\u003c/strong\u003e。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e而在 eBPF 中，JIT 编译器会以一种透明和高效的方式编译新加入的辅助函数，这意味着 JIT 编\n译器只需要发射（emit）一条调用指令（call instruction），因为寄存器映射的方式使得\nBPF 排列参数的方式（assignments）已经和底层架构的调用约定相匹配了。这使得基于辅\n助函数扩展核心内核（core kernel）非常方便。\u003cstrong\u003e\u003cmark\u003e所有的 BPF 辅助函数都是核心内核的一部分\u003c/mark\u003e\u003c/strong\u003e，\n无法通过内核模块（kernel module）来扩展或添加。\u003c/p\u003e\n\n\u003cp\u003e前面提到的函数签名还允许校验器执行类型检测（type check）。上面的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_func_proto\u003c/code\u003e 用于存放\u003cstrong\u003e校验器必需知道的所有关于该辅助函数的信息\u003c/strong\u003e，这\n样校验器可以确保辅助函数期望的类型和 BPF 程序寄存器中的当前内容是匹配的。\u003c/p\u003e\n\n\u003cp\u003e参数类型范围很广，从任意类型的值，到限制只能为特定类型，例如 BPF 栈缓冲区（stack\nbuffer）的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epointer/size\u003c/code\u003e 参数对，辅助函数可以从这个位置读取数据或向其写入数据。\n对于这种情况，校验器还可以执行额外的检查，例如，缓冲区是否已经初始化过了。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e当前可用的 BPF 辅助函数已经有几十个，并且数量还在不断增加\u003c/strong\u003e，例如，写作本文时，tc\nBPF 程序可以使用38 种不同的 BPF 辅助函数。对于一个给定的 BPF 程序类型，内核的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_verifier_ops\u003c/code\u003e 包含了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eget_func_proto\u003c/code\u003e 回调函数，这个函数提供了从某个\n特定的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eenum bpf_func_id\u003c/code\u003e 到一个可用的辅助函数的映射。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_maps\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"13-maps\"\u003e1.3 Maps\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_map.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003emap 是\u003cstrong\u003e驻留在内核空间\u003c/strong\u003e中的高效键值仓库（key/value store）。map 中的数据可以被\nBPF 程序访问，如果想在 \u003cstrong\u003e多次 BPF 程序调用（invoke）之间保存状态\u003c/strong\u003e，可以将状态信\n息放到 map。map 还可以\u003cstrong\u003e\u003cmark\u003e从用户空间通过文件描述符访问\u003c/mark\u003e\u003c/strong\u003e，\n可以在任意 BPF 程序以及用户空间应用之间共享。\u003c/p\u003e\n\n\u003cp\u003e共享 map 的 BPF 程序不要求是相同的程序类型，例如 tracing 程序可以和网络程序共享\nmap。\u003cstrong\u003e单个 BPF 程序目前最多可直接访问 64 个不同 map\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003emap 的实现由核心内核（core kernel）提供\u003c/strong\u003e。有 per-CPU 及 non-per-CPU 的通用\nmap，这些 map 可以读/写任意数据，也有一些和辅助函数一起使用的非通用 map。\u003c/p\u003e\n\n\u003cp\u003e当前可用的 \u003cstrong\u003e通用 map\u003c/strong\u003e 有：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_HASH\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_ARRAY\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERCPU_HASH\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERCPU_ARRAY\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_LRU_HASH\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_LRU_PERCPU_HASH\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_LPM_TRIE\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上 map 都使用相同的一组 BPF 辅助函数来执行查找、更新或删除操作，但各自实现了不\n同的后端，这些后端各有不同的语义和性能特点。\u003c/p\u003e\n\n\u003cp\u003e当前内核中的 \u003cstrong\u003e非通用 map\u003c/strong\u003e 有：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERF_EVENT_ARRAY\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_CGROUP_ARRAY\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_STACK_TRACE\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_ARRAY_OF_MAPS\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_HASH_OF_MAPS\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/code\u003e 是一个数组 map，用于持有（hold）其他的 BPF 程序\n。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_ARRAY_OF_MAPS\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_HASH_OF_MAPS\u003c/code\u003e 都用于持有（hold）\n其他 map 的指针，这样\u003cstrong\u003e\u003cmark\u003e整个 map 就可以在运行时实现原子替换\u003c/mark\u003e\u003c/strong\u003e。这些类型的 map 都针对\n特定的问题，不适合单单通过一个 BPF 辅助函数实现，因为它们需要在各次 BPF 程序调用\n（invoke）之间时保持额外的（非数据）状态。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_obj_pinning\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"14-object-pinning钉住对象\"\u003e1.4 Object Pinning（钉住对象）\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_fs.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eBPF map 和 BPF program\u003c/mark\u003e\u003c/strong\u003e 作为内核资源\u003cstrong\u003e\u003cmark\u003e只能通过文件描述符访问\u003c/mark\u003e\u003c/strong\u003e，\n其背后是内核中的\u003cstrong\u003e\u003cmark\u003e匿名 inode\u003c/mark\u003e\u003c/strong\u003e。这有很多好处，例如：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e用户空间应用能够使用大部分文件描述符相关的 API，\u003c/li\u003e\n  \u003cli\u003e在 Unix socket 中传递文件描述符是透明的，等等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但同时，也有很多缺点：\u003cstrong\u003e\u003cmark\u003e文件描述符受限于进程的生命周期\u003c/mark\u003e\u003c/strong\u003e，使得\nmap 共享之类的操作非常笨重。\u003c/p\u003e\n\n\u003cp\u003e因此，这给某些特定的场景带来了很多复杂性，例如 iproute2，其中的 tc 或 XDP 在准备\n环境、加载程序到内核之后最终会退出。在这种情况下，从用户空间也无法访问这些 map\n了，而本来这些 map 其实是很有用的，例如，在 data path 的 ingress 和 egress 位置共\n享的 map（可以统计包数、字节数、PPS 等信息）。另外，第三方应用可能希望在 BPF 程\n序运行时监控或更新 map。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e为了解决这个问题，内核实现了一个最小内核空间 BPF 文件系统，BPF map 和 BPF 程序\n都可以钉到（pin）这个文件系统内\u003c/strong\u003e，这个过程称为 object pinning（钉住对象）。相应\n地，BPF 系统调用进行了扩展，添加了两个新命令，分别用于钉住（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_OBJ_PIN\u003c/code\u003e）一个\n对象和获取（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_OBJ_GET\u003c/code\u003e）一个被钉住的对象（pinned objects）。\u003c/p\u003e\n\n\u003cp\u003e例如，tc 之类的工具可以利用这个基础设施在 ingress 和 egress 之间共享 map。BPF\n相关的文件系统\u003cstrong\u003e不是单例模式\u003c/strong\u003e（singleton），它\u003cstrong\u003e\u003cmark\u003e支持多挂载实例、硬链接、软连接\u003c/mark\u003e\u003c/strong\u003e等等。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_tail_call\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"15-尾调用tail-calls\"\u003e1.5 尾调用（Tail Calls）\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_tailcall.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBPF 相关的另一个概念是尾调用（tail calls）。尾调用的机制是：一个 BPF 程序可以调\n用另一个 BPF 程序，并且调用完成后不用返回到原来的程序。和普通函数调用相比，这种\n调用方式开销最小，因为它是\u003cstrong\u003e用长跳转（long jump）实现的，复用了原来的栈帧\u003c/strong\u003e\n（stack frame）。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序都是独立验证的，因此要传递状态，要么使用 per-CPU map 作为 scratch 缓冲区\n，要么如果是 tc 程序的话，还可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 的某些字段（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecb[]\u003c/code\u003e）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e类型相同的 BPF 程序才可以尾调用\u003c/mark\u003e\u003c/strong\u003e，而且还要与 JIT 编译器相匹配，\n因此一个给定的 BPF 程序 要么是 JIT编译执行，要么是解释器执行（invoke interpreted\nprograms），而不能同时使用两种方式。\u003c/p\u003e\n\n\u003cp\u003e尾调用执行涉及\u003cstrong\u003e\u003cmark\u003e两个步骤\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e设置一个称为“程序数组”（program array）的特殊 map\u003c/mark\u003e\u003c/strong\u003e（map 类型 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/code\u003e\n），这个 map 可以从用户空间通过 key/value 操作，\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e调用辅助函数 bpf_tail_call()\u003c/mark\u003e\u003c/strong\u003e。两个参数：一个对程序数组的引用（a reference\nto the program array），一个查询 map 所用的 key。内核将这个辅助函数调用内联（\ninline）到一个特殊的 BPF 指令内。目前，这样的程序数组在用户空间侧是只写模式（\nwrite-only from user space side）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e内核根据传入的文件描述符查找相关的 BPF 程序，自动替换给定的 map slot（槽） 处的\n程序指针。如果没有找到给定的 key 对应的 value，内核会跳过（fall through）这一步\n，继续执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_tail_call()\u003c/code\u003e 后面的指令。\u003cstrong\u003e尾调用是一个强大的功能，例如，可以通\n过尾调用结构化地解析网络头\u003c/strong\u003e（network headers）。还可以在运行时（runtime）原子地\n添加或替换功能，即，动态地改变 BPF 程序的执行行为。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_to_bpf_call\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"16-bpf-to-bpf-calls\"\u003e1.6 BPF to BPF Calls\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_call.png\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e除了 BPF 辅助函数和 BPF 尾调用之外，BPF 核心基础设施最近刚加入了一个新特性：BPF\n到 BPF 调用（BPF to BPF calls）。\u003cstrong\u003e在这个特性引入内核之前，典型的 BPF C 程序必须\n将所有需要复用的代码进行特殊处理，例如，在头文件中声明为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealways_inline\u003c/code\u003e\u003c/strong\u003e。当\nLLVM 编译和生成 BPF 对象文件时，所有这些函数将被内联，因此会在生成的对象文件中重\n复多次，导致代码尺寸膨胀：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __inline\n# define __inline                         \\\n   inline __attribute__((always_inline))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003e__inline\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_drop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e之所以要这样做是因为 \u003cstrong\u003eBPF 程序的加载器、校验器、解释器和 JIT 中都缺少对函数调用的\n支持\u003c/strong\u003e。从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLinux 4.16\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLLVM 6.0\u003c/code\u003e 开始，这个限制得到了解决，BPF 程序不再需\n要到处使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealways_inline\u003c/code\u003e 声明了。因此，上面的代码可以更自然地重写为：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_drop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBPF 到 BPF 调用是一个重要的性能优化，极大减小了生成的 BPF 代码大小，因此\u003cstrong\u003e对 CPU\n指令缓存（instruction cache，i-cache）更友好\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eBPF 辅助函数的调用约定也适用于 BPF 函数间调用，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er1\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er5\u003c/code\u003e 用于传递参数，返回\n结果放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er1\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er5\u003c/code\u003e 是 scratch registers，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er6\u003c/code\u003e - \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er9\u003c/code\u003e 像往常一样是保留寄\n存器。最大嵌套调用深度是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e8\u003c/code\u003e。调用方可以传递指针（例如，指向调用方的栈帧的指针）\n给被调用方，但反过来不行。\u003c/p\u003e\n\n\u003cp\u003eBPF JIT 编译器为每个函数体发射独立的镜像（emit separate images for each function\nbody），稍后在最后一通 JIT 处理（final JIT pass）中再修改镜像中函数调用的地址\n。已经证明，这种方式需要对各种 JIT 做最少的修改，因为在实现中它们可以将 BPF 函数\n间调用当做常规的 BPF 辅助函数调用。\u003c/p\u003e\n\n\u003cp\u003e内核 5.9 版本之前，\u003cstrong\u003e\u003cmark\u003eBPF 尾调用和 BPF-to-BPF 调用是互斥的\u003c/mark\u003e\u003c/strong\u003e，只能二选一。\n尾调用的缺点是生成的程序镜像大、加载时间长。\n\u003cstrong\u003e\u003cmark\u003e内核 5.10 最终解决了这一问题\u003c/mark\u003e\u003c/strong\u003e，允许同时使用者两种调用类型，充分利用二者各自的优点。\u003c/p\u003e\n\n\u003cp\u003e但混合使用者两种调用类型是有限制的，否则会导致内核栈溢出（kernel stack overflow）。\n来看下面的例子：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_tailcall_subprograms.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e如上图所示，尾调用在真正跳转到目标程序（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efunc3\u003c/code\u003e）之前，只会展开（unwind）它当前\n所处层级的栈帧（stack frame）。也就是说，如果尾调用是从某个子函数发起的（occurs from\nwithin the sub-function），例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esubfunc1 --tailcall--\u0026gt; func2\u003c/code\u003e，那当程序在执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efunc2\u003c/code\u003e 时，\n所有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esubfunc1\u003c/code\u003e 之前的栈帧（在这里是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efunc1\u003c/code\u003e 的栈帧）都会出现在栈上。只有当最后\n一个函数（这里是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efunc3\u003c/code\u003e）执行结束时，所有前面的栈帧才将被展开（unwinded），然后控制返回\n到 BPF 程序的调用者（BPF program caller）。\u003c/p\u003e\n\n\u003cp\u003e内核引入了额外的逻辑来检测这种混用的情况。整个调用链中，\n\u003cstrong\u003e\u003cmark\u003e每个子程序的栈空间不能超过 256 字节\u003c/mark\u003e\u003c/strong\u003e（如果校验器检测到 bpf2bpf 调用，那主函数也会被当做\n子函数）。有了这个限制，\u003cstrong\u003e\u003cmark\u003eBPF 程序调用链最多能使用 8KB 的栈空间\u003c/mark\u003e\u003c/strong\u003e，计算方式：256\nbyte/stack 乘以尾调用数量上限 33。如果没有这个限制，BPF 程序将使用 512 字节栈空\n间，最终消耗最多 16KB 的总栈空间，在某些架构上会导致栈溢出。\u003c/p\u003e\n\n\u003cp\u003e另外需要说明，这种混合调用\u003cstrong\u003e\u003cmark\u003e目前只有 x86-64 架构支持\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_jit\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"17-jit\"\u003e1.7 JIT\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_jit.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e64 位的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eppc64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003es390x\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emips64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esparc64\u003c/code\u003e 和 32 位的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm\u003c/code\u003e\n、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_32\u003c/code\u003e 架构都内置了 in-kernel eBPF JIT 编译器，它们的功能都是一样的，可\n以用\u003cstrong\u003e\u003cmark\u003e如下方式打开\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_enable\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e32 位的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emips\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eppc\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esparc\u003c/code\u003e 架构目前内置的是一个 cBPF JIT 编译器。这些只有\ncBPF JIT 编译器的架构，以及那些甚至完全\u003cstrong\u003e\u003cmark\u003e没有 BPF JIT 编译器的架构\u003c/mark\u003e\u003c/strong\u003e，\n需要通过\u003cstrong\u003e\u003cmark\u003e内核中的解释器\u003c/mark\u003e\u003c/strong\u003e（in-kernel interpreter）执行 eBPF 程序。\u003c/p\u003e\n\n\u003cp\u003e要判断哪些平台支持 eBPF JIT，可以在内核源文件中 grep \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eHAVE_EBPF_JIT\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eHAVE_EBPF_JIT \u003cspan class=\"nb\"\u003earch\u003c/span\u003e/\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/arm/Kconfig:       \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003eCPU_ENDIAN_BE32\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/arm64/Kconfig:     \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/powerpc/Kconfig:   \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif \u003c/span\u003ePPC64\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/mips/Kconfig:      \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e64BIT \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003eCPU_MICROMIPS\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/s390/Kconfig:      \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif \u003c/span\u003ePACK_STACK \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e HAVE_MARCH_Z196_FEATURES\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/sparc/Kconfig:     \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif \u003c/span\u003eSPARC64\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/x86/Kconfig:       \u003cspan class=\"k\"\u003eselect \u003c/span\u003eHAVE_EBPF_JIT   \u003cspan class=\"k\"\u003eif \u003c/span\u003eX86_64\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eJIT 编译器可以极大加速 BPF 程序的执行，因为与解释器相比，它们可以降低每个指令的\n开销（reduce the per instruction cost）。通常，指令可以 1:1 映射到底层架构的原生\n指令。另外，这也会减少生成的可执行镜像的大小，因此对 CPU 的指令缓存更友好。特别\n地，对于 CISC 指令集（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86\u003c/code\u003e），JIT 做了很多特殊优化，目的是为给定的指令产生\n可能的最短操作码（emitting the shortest possible opcodes），以降低程序翻译过程所\n需的空间。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_hardening\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"18-加固hardening\"\u003e1.8 加固（Hardening）\u003c/h2\u003e\n\n\u003cp\u003e为了避免代码被损坏，BPF 会在程序的生命周期内，在内核中\u003cstrong\u003e\u003cmark\u003e将下面两个镜像锁定为只读的\u003c/mark\u003e\u003c/strong\u003e（read-only）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e经过 BPF 解释器\u003cstrong\u003e\u003cmark\u003e解释（翻译）之后的整个镜像\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_prog\u003c/code\u003e）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eJIT 编译之后的镜像\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_binary_header\u003c/code\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在这些位置发生的任何数据损坏（例如某些内核 bug 导致的）会触发通用的保护机制，因\n此会造成内核崩溃（crash），而不会让这种损坏静默地发生。\u003c/p\u003e\n\n\u003cp\u003e查看哪些平台支持将镜像内存（image memory）设置为只读的，可以通过下面的搜索：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eARCH_HAS_SET_MEMORY | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003e\u003cspan class=\"k\"\u003eselect\n\u003c/span\u003e\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/arm/Kconfig:    \u003cspan class=\"k\"\u003eselect \u003c/span\u003eARCH_HAS_SET_MEMORY\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/arm64/Kconfig:  \u003cspan class=\"k\"\u003eselect \u003c/span\u003eARCH_HAS_SET_MEMORY\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/s390/Kconfig:   \u003cspan class=\"k\"\u003eselect \u003c/span\u003eARCH_HAS_SET_MEMORY\n\u003cspan class=\"nb\"\u003earch\u003c/span\u003e/x86/Kconfig:    \u003cspan class=\"k\"\u003eselect \u003c/span\u003eARCH_HAS_SET_MEMORY\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_ARCH_HAS_SET_MEMORY\u003c/code\u003e 选项是不可配置的，因此平台要么内置支持，要么不支持\n。那些目前还不支持的架构未来可能也会支持。\u003c/p\u003e\n\n\u003cp\u003e对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e JIT 编译器，如果设置了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_RETPOLINE\u003c/code\u003e，尾调用的间接跳转（\nindirect jump）就会用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eretpoline\u003c/code\u003e 实现。写作本文时，在大部分现代 Linux 发行版上\n这个配置都是打开的。\u003c/p\u003e\n\n\u003cp\u003e将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/net/core/bpf_jit_harden\u003c/code\u003e 设置为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 会为非特权用户（\nunprivileged users）的 JIT 编译做一些额外的加固工作。这些额外加固会稍微降低程序\n的性能，但在有非受信用户在系统上进行操作的情况下，能够有效地减小（潜在的）受攻击\n面。但与完全切换到解释器相比，这些性能损失还是比较小的。\u003c/p\u003e\n\n\u003cp\u003e当前，启用加固会在 JIT 编译时\u003cstrong\u003e盲化\u003c/strong\u003e（blind）BPF 程序中用户提供的所有 32 位和\n64 位常量，以防御 \u003cstrong\u003eJIT spraying（喷射）攻击\u003c/strong\u003e，这些攻击会将原生操作码（native\nopcodes）作为立即数（immediate values）注入到内核。这种攻击有效是因为：\u003cstrong\u003e立即数\n驻留在可执行内核内存（executable kernel memory）中\u003c/strong\u003e，因此某些内核 bug 可能会触\n发一个跳转动作，如果跳转到立即数的开始位置，就会把它们当做原生指令开始执行。\u003c/p\u003e\n\n\u003cp\u003e盲化 JIT 常量通过对真实指令进行随机化（randomizing the actual instruction）实现\n。在这种方式中，通过对指令进行重写（rewriting the instruction），将原来\u003cstrong\u003e基于立\n即数的操作\u003c/strong\u003e转换成\u003cstrong\u003e基于寄存器的操作\u003c/strong\u003e。指令重写将加载值的过程分解为两部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e加载一个盲化后的（blinded）立即数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ernd ^ imm\u003c/code\u003e 到寄存器\u003c/li\u003e\n  \u003cli\u003e将寄存器和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ernd\u003c/code\u003e 进行异或操作（xor）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这样原始的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimm\u003c/code\u003e 立即数就驻留在寄存器中，可以用于真实的操作了。这里介绍的只是加\n载操作的盲化过程，实际上所有的通用操作都被盲化了。\u003c/p\u003e\n\n\u003cp\u003e下面是加固关闭的情况下，某个程序的 JIT 编译结果：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e0 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_harden\n\n  ffffffffa034f5e9 + \u0026lt;x\u0026gt;:\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n  39:   mov    \u003cspan class=\"nv\"\u003e$0xa8909090\u003c/span\u003e,%eax\n  3e:   mov    \u003cspan class=\"nv\"\u003e$0xa8909090\u003c/span\u003e,%eax\n  43:   mov    \u003cspan class=\"nv\"\u003e$0xa8ff3148\u003c/span\u003e,%eax\n  48:   mov    \u003cspan class=\"nv\"\u003e$0xa89081b4\u003c/span\u003e,%eax\n  4d:   mov    \u003cspan class=\"nv\"\u003e$0xa8900bb0\u003c/span\u003e,%eax\n  52:   mov    \u003cspan class=\"nv\"\u003e$0xa810e0c1\u003c/span\u003e,%eax\n  57:   mov    \u003cspan class=\"nv\"\u003e$0xa8908eb4\u003c/span\u003e,%eax\n  5c:   mov    \u003cspan class=\"nv\"\u003e$0xa89020b0\u003c/span\u003e,%eax\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e加固打开之后，以上程序被某个非特权用户通过 BPF 加载的结果（这里已经进行了常\n量盲化）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_harden\n\n  ffffffffa034f1e5 + \u0026lt;x\u0026gt;:\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n  39:   mov    \u003cspan class=\"nv\"\u003e$0xe1192563\u003c/span\u003e,%r10d\n  3f:   xor    \u003cspan class=\"nv\"\u003e$0x4989b5f3\u003c/span\u003e,%r10d\n  46:   mov    %r10d,%eax\n  49:   mov    \u003cspan class=\"nv\"\u003e$0xb8296d93\u003c/span\u003e,%r10d\n  4f:   xor    \u003cspan class=\"nv\"\u003e$0x10b9fd03\u003c/span\u003e,%r10d\n  56:   mov    %r10d,%eax\n  59:   mov    \u003cspan class=\"nv\"\u003e$0x8c381146\u003c/span\u003e,%r10d\n  5f:   xor    \u003cspan class=\"nv\"\u003e$0x24c7200e\u003c/span\u003e,%r10d\n  66:   mov    %r10d,%eax\n  69:   mov    \u003cspan class=\"nv\"\u003e$0xeb2a830e\u003c/span\u003e,%r10d\n  6f:   xor    \u003cspan class=\"nv\"\u003e$0x43ba02ba\u003c/span\u003e,%r10d\n  76:   mov    %r10d,%eax\n  79:   mov    \u003cspan class=\"nv\"\u003e$0xd9730af\u003c/span\u003e,%r10d\n  7f:   xor    \u003cspan class=\"nv\"\u003e$0xa5073b1f\u003c/span\u003e,%r10d\n  86:   mov    %r10d,%eax\n  89:   mov    \u003cspan class=\"nv\"\u003e$0x9a45662b\u003c/span\u003e,%r10d\n  8f:   xor    \u003cspan class=\"nv\"\u003e$0x325586ea\u003c/span\u003e,%r10d\n  96:   mov    %r10d,%eax\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e两个程序在语义上是一样的，但在第二种方式中，原来的立即数在反汇编之后的程序中不再\n可见。\u003c/p\u003e\n\n\u003cp\u003e同时，加固还会禁止任何 JIT 内核符号（kallsyms）暴露给特权用户，\n\u003cstrong\u003e\u003cmark\u003eJIT 镜像地址不再出现在 /proc/kallsyms 中\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e另外，Linux 内核提供了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_BPF_JIT_ALWAYS_ON\u003c/code\u003e 选项，打开这个开关后 \u003cstrong\u003e\u003cmark\u003eBPF 解释\n器将会从内核中完全移除\u003c/mark\u003e\u003c/strong\u003e，永远启用 JIT 编译器。此功能部分是为防御 Spectre v2 \n攻击开发的，如果应用在一个基于虚拟机的环境，客户机内核（guest kernel）将不会复用\n内核的 BPF 解释器，因此可以避免某些相关的攻击。如果是基于容器的环境，这个配置是\n可选的，如果 JIT 功能打开了，解释器仍然可能会在编译时被去掉，以降低内核的复杂度\n。因此，对于主流架构（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm64\u003c/code\u003e）上的 JIT \u003cstrong\u003e\u003cmark\u003e通常都建议打开这个开关。\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e另外，内核提供了一个配置项 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/kernel/unprivileged_bpf_disabled\u003c/code\u003e 来\n\u003cstrong\u003e\u003cmark\u003e禁止非特权用户使用 bpf(2) 系统调用\u003c/mark\u003e\u003c/strong\u003e，可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl\u003c/code\u003e 命令修改。\n比较特殊的一点是，这个配置项特意设计为\u003cstrong\u003e“一次性开关”\u003c/strong\u003e（one-time kill switch），\n这意味着一旦将它设为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e，就没有办法再改为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 了，除非重启内核。一旦设置为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e\n之后，只有初始命名空间中有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCAP_SYS_ADMIN\u003c/code\u003e 特权的进程才可以调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用\n。 \u003cstrong\u003e\u003cmark\u003eCilium 启动后也会将这个配置项设为 1\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/kernel/unprivileged_bpf_disabled\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"bpf_offloads\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"19-offloads\"\u003e1.9 Offloads\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_offload.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eBPF 网络程序，尤其是 tc 和 XDP BPF 程序在内核中都有一个 offload 到硬件的接口，这\n样就可以直接在网卡上执行 BPF 程序。\u003c/p\u003e\n\n\u003cp\u003e当前，Netronome 公司的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enfp\u003c/code\u003e 驱动支持通过 JIT 编译器 offload BPF，它会将 BPF 指令\n翻译成网卡实现的指令集。另外，它还支持将 BPF maps offload 到网卡，因此 offloaded\nBPF 程序可以执行 map 查找、更新和删除操作。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"toolchain\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"2-工具链\"\u003e2 工具链\u003c/h1\u003e\n\n\u003cp\u003e本节介绍 BPF 相关的用户态工具、内省设施（introspection facilities）和内核控制选项。\n注意，围绕 BPF 的工具和基础设施还在快速发展当中，因此本文提供的内容可能只覆\n盖了其中一部分。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"tool_dev_env\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"21-开发环境\"\u003e2.1 开发环境\u003c/h2\u003e\n\n\u003ch3 id=\"fedora\"\u003eFedora\u003c/h3\u003e\n\n\u003cp\u003eFedora \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e25+\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003ednf \u003cspan class=\"nb\"\u003einstall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-y\u003c/span\u003e git gcc ncurses-devel elfutils-libelf-devel bc \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  openssl-devel libcap-devel clang llvm graphviz bison flex glibc-static\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"ubuntu\"\u003eUbuntu\u003c/h3\u003e\n\n\u003cp\u003eUbuntu \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e17.04+\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eapt-get \u003cspan class=\"nb\"\u003einstall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-y\u003c/span\u003e make gcc libssl-dev bc libelf-dev libcap-dev \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  clang gcc-multilib llvm libncurses5-dev git pkg-config libmnl-dev bison flex \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  graphviz\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"opensuse-tumbleweed\"\u003eopenSUSE Tumbleweed\u003c/h3\u003e\n\n\u003cp\u003eopenSUSE Tumbleweed 和 openSUSE Leap \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e15.0+\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003ezypper \u003cspan class=\"nb\"\u003einstall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-y\u003c/span\u003e git gcc ncurses-devel libelf-devel bc libopenssl-devel \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n       libcap-devel clang llvm graphviz bison flex glibc-devel-static\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"tool_llvm\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"编译-linux-内核\"\u003e编译 Linux 内核\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e新的 BPF 特性都是在内核 net-next 源码树中开发的\u003c/mark\u003e\u003c/strong\u003e。获取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-netxt\u003c/code\u003e 源码树：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net-next.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果不关心提交历史，可以指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--depth 1\u003c/code\u003e，这会下载当前最新的版本，节省大量时间和\n磁盘空间。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e最新的 BPF fix 都在 net 源码树\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit clone git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e网络已经有大量关于如何编译 Linux 内核的教程，推荐\n\u003ca href=\"https://kernelnewbies.org/KernelBuild\"\u003e\u003cstrong\u003eKernel Newbies website\u003c/strong\u003e\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e要运行 BPF，需要确保生成的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.config\u003c/code\u003e 文件包含下列配置（Cilium 也需要这些配置）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"nv\"\u003eCONFIG_CGROUP_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_BPF_SYSCALL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_NET_SCH_INGRESS\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003em\n    \u003cspan class=\"nv\"\u003eCONFIG_NET_CLS_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003em\n    \u003cspan class=\"nv\"\u003eCONFIG_NET_CLS_ACT\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_BPF_JIT\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_LWTUNNEL_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_HAVE_EBPF_JIT\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_BPF_EVENTS\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n    \u003cspan class=\"nv\"\u003eCONFIG_TEST_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003em\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上的某些配置项是无法通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emake menuconfig\u003c/code\u003e 修改的。例如，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_HAVE_EBPF_JIT\u003c/code\u003e 是根据当前架构是否支持 eBPF JIT 自动设置的。在本节中，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_HAVE_EBPF_JIT\u003c/code\u003e 是可选但强烈推荐的配置。没有 eBPF JIT 编译器的架构只能\nfallback 到内核解释器，执行效率会大大降低。\u003c/p\u003e\n\n\u003ch3 id=\"验证编译好的内核\"\u003e验证编译好的内核\u003c/h3\u003e\n\n\u003cp\u003e用编译好的内核启动之后，进入 BPF 测试目录来验证 BPF 的功能：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd \u003c/span\u003etools/testing/selftests/bpf/\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emake\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo\u003c/span\u003e ./test_verifier\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e正常的话，会打印如下类似的结果：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eSummary: 847 PASSED, 0 SKIPPED, 0 FAILED\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：For kernel releases 4.16+ the BPF selftest has a dependency on LLVM 6.0+\ncaused by the BPF function calls which do not need to be inlined\nanymore. See section \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_to_bpf_calls\u003c/code\u003e or the cover letter mail\nfrom the kernel patch (https://lwn.net/Articles/741773/) for more information.\nNot every BPF program has a dependency on LLVM 6.0+ if it does not\nuse this new feature. If your distribution does not provide LLVM 6.0+\nyou may compile it by following the instruction in the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etooling_llvm\u003c/code\u003e\nsection.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e运行所有 BPF selftests：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003emake run_tests\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"编译-iproute2\"\u003e编译 iproute2\u003c/h3\u003e\n\n\u003cp\u003e与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet\u003c/code\u003e (fixes only) 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e (new features) 内核树类似，\niproute2 源码树有两个分支：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaster\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaster\u003c/code\u003e 分支基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet\u003c/code\u003e 内核源码树，\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e 分支基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e 内核树。这样，头文件的改动就会同步到 iproute2 源码树。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下载 iproute2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaster\u003c/code\u003e 分支代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit clone https://git.kernel.org/pub/scm/network/iproute2/iproute2.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下周 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e 分支代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egit clone \u003cspan class=\"nt\"\u003e-b\u003c/span\u003e net-next https://git.kernel.org/pub/scm/network/iproute2/iproute2.git\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e编译和安装：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd \u003c/span\u003eiproute2/\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./configure \u003cspan class=\"nt\"\u003e--prefix\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/usr\nTC schedulers\n ATM    no\n\nlibc has setns: \u003cspan class=\"nb\"\u003eyes\n\u003c/span\u003eSELinux support: \u003cspan class=\"nb\"\u003eyes\n\u003c/span\u003eELF support: \u003cspan class=\"nb\"\u003eyes\n\u003c/span\u003elibmnl support: no\nBerkeley DB: no\n\ndocs: latex: no\n WARNING: no docs can be built from LaTeX files\n sgml2html: no\n WARNING: no HTML docs can be built from SGML\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emake\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003emake \u003cspan class=\"nb\"\u003einstall\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e确保 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econfigure\u003c/code\u003e 脚本打印出了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eELF support: yes\u003c/code\u003e，这样 iproute2 才能处理 LLVM BPF\n后端产生的 ELF 文件。\u003c/p\u003e\n\n\u003ch3 id=\"编译-bpftool\"\u003e编译 bpftool\u003c/h3\u003e\n\n\u003cp\u003ebpftool 对调试和查看 BPF 程序及 BPF map 非常有用，它是\u003cstrong\u003e\u003cmark\u003e内核源码树的一部分\u003c/mark\u003e\u003c/strong\u003e，\n代码位于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/bpftool/\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003eMake sure to have cloned either the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-next\u003c/code\u003e kernel tree as described\nearlier. In order to build and install bpftool, the following steps are required:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e \u0026lt;kernel-tree\u0026gt;/tools/bpf/bpftool/\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emake\nAuto-detecting system features:\n...                        libbfd: \u003cspan class=\"o\"\u003e[\u003c/span\u003e on  \u003cspan class=\"o\"\u003e]\u003c/span\u003e\n...        disassembler-four-args: \u003cspan class=\"o\"\u003e[\u003c/span\u003e OFF \u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\n  CC       xlated_dumper.o\n  CC       prog.o\n  CC       common.o\n  CC       cgroup.o\n  CC       main.o\n  CC       json_writer.o\n  CC       cfg.o\n  CC       map.o\n  CC       jit_disasm.o\n  CC       disasm.o\nmake[1]: Entering directory \u003cspan class=\"s1\"\u003e\u0026#39;/home/foo/trees/net/tools/lib/bpf\u0026#39;\u003c/span\u003e\n\nAuto-detecting system features:\n...                        libelf: \u003cspan class=\"o\"\u003e[\u003c/span\u003e on  \u003cspan class=\"o\"\u003e]\u003c/span\u003e\n...                           bpf: \u003cspan class=\"o\"\u003e[\u003c/span\u003e on  \u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\n  CC       libbpf.o\n  CC       bpf.o\n  CC       nlattr.o\n  LD       libbpf-in.o\n  LINK     libbpf.a\nmake[1]: Leaving directory \u003cspan class=\"s1\"\u003e\u0026#39;/home/foo/trees/bpf/tools/lib/bpf\u0026#39;\u003c/span\u003e\n  LINK     bpftool\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003emake \u003cspan class=\"nb\"\u003einstall\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"22-llvm\"\u003e2.2 LLVM\u003c/h2\u003e\n\n\u003cp\u003e写作本文时，LLVM 是唯一提供 BPF 后端的编译器套件。gcc 目前还不支持。\u003c/p\u003e\n\n\u003cp\u003e主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安\n装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e典型的工作流\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e用 C 编写 BPF 程序\u003c/li\u003e\n  \u003cli\u003e用 LLVM 将 C 程序编译成对象文件（ELF）\u003c/li\u003e\n  \u003cli\u003e用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e加载器\u003c/mark\u003e\u003c/strong\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf()\u003c/code\u003e 系统调用\u003cstrong\u003e\u003cmark\u003e将解析后的对象文件注入内核\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e内核验证 BPF 指令，然后对其执行即时编译（JIT），\u003cstrong\u003e\u003cmark\u003e返回程序的一个新文件描述符\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e利用文件描述符 \u003cstrong\u003e\u003cmark\u003eattach 到内核子系统\u003c/mark\u003e\u003c/strong\u003e（例如网络子系统）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.2.1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"221-bpf-target目标平台\"\u003e2.2.1 BPF Target（目标平台）\u003c/h3\u003e\n\n\u003cp\u003e查看 LLVM 支持的 BPF target：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellc \u003cspan class=\"nt\"\u003e--version\u003c/span\u003e\nLLVM \u003cspan class=\"o\"\u003e(\u003c/span\u003ehttp://llvm.org/\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\nLLVM version 3.8.1\nOptimized build.\nDefault target: x86_64-unknown-linux-gnu\nHost CPU: skylake\n\nRegistered Targets:\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n  bpf        - BPF \u003cspan class=\"o\"\u003e(\u003c/span\u003ehost endian\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  bpfeb      - BPF \u003cspan class=\"o\"\u003e(\u003c/span\u003ebig endian\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  bpfel      - BPF \u003cspan class=\"o\"\u003e(\u003c/span\u003elittle endian\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e默认情况下，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target 使用编译时所在的 CPU 的大小端格式\u003c/strong\u003e，即，如果 CPU 是小\n端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运\n行时行为相匹配，这样的行为比较通用，而且大小端格式一致可以避免一些因为格式导致的\n架构劣势。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于\u003cstrong\u003e交叉编译\u003c/strong\u003e，\n引入了两个新目标 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpfeb\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpfel\u003c/code\u003e。注意前端也需要以相应的大小端方式运行。\u003c/p\u003e\n\n\u003cp\u003e在不存在大小端混用的场景下，建议使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target。例如，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e 平台上（小端\n），指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpfel\u003c/code\u003e 会产生相同的结果，因此触发编译的脚本不需要感知到大小端\n。\u003c/p\u003e\n\n\u003cp\u003e下面是\u003cstrong\u003e\u003cmark\u003e一个最小的完整 XDP 程序\u003c/mark\u003e\u003c/strong\u003e，实现丢弃包的功能（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp-example.c\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_drop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e用下面的命令\u003cstrong\u003e\u003cmark\u003e编译并加载到内核\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.o\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以上命令将一个 XDP 程序 attach 到一个网络设备，需要是 Linux 4.11 内核中支持\nXDP 的设备，或者 4.12+ 版本的内核。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eLLVM（\u0026gt;= 3.9） 使用\u003cstrong\u003e\u003cmark\u003e正式的 ISA 值\u003c/mark\u003e\u003c/strong\u003e（ELF header 中的 \u003ca href=\"https://en.wikipedia.org/wiki/Executable_and_Linkable_Format\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ee_machine\u003c/code\u003e 字段\u003c/a\u003e），即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEM_BPF\u003c/code\u003e（十进制 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e247\u003c/code\u003e\n，十六进制 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0xf7\u003c/code\u003e），来\u003cstrong\u003e生成对象文件\u003c/strong\u003e。在这个例子中，程序是用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target 在\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e 平台上编译的，因此下面显示的大小端标识是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLSB\u003c/code\u003e (和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSB\u003c/code\u003e 相反)：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003efile xdp-example.o\nxdp-example.o: ELF 64-bit LSB relocatable, \u003cspan class=\"k\"\u003e*\u003c/span\u003eunknown \u003cspan class=\"nb\"\u003earch \u003c/span\u003e0xf7\u003cspan class=\"k\"\u003e*\u003c/span\u003e version 1 \u003cspan class=\"o\"\u003e(\u003c/span\u003eSYSV\u003cspan class=\"o\"\u003e)\u003c/span\u003e, not stripped\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf -a xdp-example.o\u003c/code\u003e 能够打印 ELF 文件的更详细信息\u003c/strong\u003e，有时在检查生成的\nsection header、relocation entries 和符号表时会比较有用。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.2.2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"222-调试信息dwarfbtf\"\u003e2.2.2 调试信息（DWARF、BTF）\u003c/h3\u003e\n\n\u003cp\u003e若是要 debug，clang 可以生成下面这样的汇编器输出：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.S\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003exdp-example.S\n    .text\n    .section    prog,\u003cspan class=\"s2\"\u003e\u0026#34;ax\u0026#34;\u003c/span\u003e,@progbits\n    .globl      xdp_drop\n    .p2align    3\nxdp_drop:                             \u003cspan class=\"c\"\u003e# @xdp_drop\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# BB#0:\u003c/span\u003e\n    r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n    \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\n    .section    license,\u003cspan class=\"s2\"\u003e\u0026#34;aw\u0026#34;\u003c/span\u003e,@progbits\n    .globl    __license               \u003cspan class=\"c\"\u003e# @__license\u003c/span\u003e\n__license:\n    .asciz    \u003cspan class=\"s2\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eLLVM 从 6.0 开始，还包括了汇编解析器（assembler parser）的支持。可以\u003cstrong\u003e\u003cmark\u003e直接使用\nBPF 汇编指令编程\u003c/mark\u003e\u003c/strong\u003e，然后\u003cstrong\u003e\u003cmark\u003e使用 llvm-mc 将其汇编成一个目标文件\u003c/mark\u003e\u003c/strong\u003e。\n例如，可以将前面的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp-example.S\u003c/code\u003e 重新变回对象文件：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ llvm-mc -triple bpf -filetype=obj -o xdp-example.o xdp-example.S\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"dwarf-格式和-llvm-objdump\"\u003eDWARF 格式和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e另外，较新版本（\u0026gt;= 4.0）的 LLVM 还可以\u003cstrong\u003e\u003cmark\u003e将调试信息以 dwarf 格式存储到对象\n文件中\u003c/mark\u003e\u003c/strong\u003e。只要在编译时加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-g\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-g\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.o\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e--no-show-raw-insn\u003c/span\u003e xdp-example.o\n\nxdp-example.o:        file format ELF64-BPF\n\nDisassembly of section prog:\nxdp_drop:\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    0:        r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn \u003c/span\u003eXDP_DROP\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    1:        \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e 工具能够用编译的 C 源码对汇编输出添加注解（annotate ）\u003c/strong\u003e。这里\n的例子过于简单，没有几行 C 代码；但注意上面的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 行号，\u003cstrong\u003e\u003cmark\u003e这些行号直接对\n应到内核的校验器日志（见下面的输出）\u003c/mark\u003e\u003c/strong\u003e。这意味着假如 BPF 程序被校验器拒绝了，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e能帮助你将 BPF 指令关联到原始的 C 代码，对于分析来说非常有用。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj xdp-example.o verb\n\nProg section \u003cspan class=\"s1\"\u003e\u0026#39;prog\u0026#39;\u003c/span\u003e loaded \u003cspan class=\"o\"\u003e(\u003c/span\u003e5\u003cspan class=\"o\"\u003e)!\u003c/span\u003e\n - Type:         6\n - Instructions: 2 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0 over limit\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n - License:      GPL\n\nVerifier analysis:\n\n0: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n1: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\n\u003c/span\u003eprocessed 2 insns\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从上面的校验器分析可以看出，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e 的输出和内核中的 BPF 汇编是相同的。\u003c/p\u003e\n\n\u003cp\u003e去掉 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-no-show-raw-insn\u003c/code\u003e 选项还可以以十六进制格式在每行汇编代码前面打印原始的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_insn\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e xdp-example.o\n\nxdp-example.o:        file format ELF64-BPF\n\nDisassembly of section prog:\nxdp_drop:\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n   0:       b7 00 00 00 01 00 00 00     r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn \u003c/span\u003efoo\u003cspan class=\"o\"\u003e()\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n   1:       95 00 00 00 00 00 00 00     \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"llvm-ir\"\u003eLLVM IR\u003c/h4\u003e\n\n\u003cp\u003e对于 LLVM IR 调试，BPF 的编译过程可以分为两个步骤：首先生成一个二进制 LLVM IR 临\n时文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp-example.bc\u003c/code\u003e，然后将其传递给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellc\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-emit-llvm\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.bc\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellc xdp-example.bc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebpf \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e生成的 LLVM IR 还可以 dump 成人类可读的格式：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-emit-llvm\u003c/span\u003e \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e -\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"btf\"\u003eBTF\u003c/h4\u003e\n\n\u003cp\u003eLLVM 能将调试信息（例如对程序使用的数据的描述）attach 到 BPF 对象文件。默认情况\n下使用 DWARF 格式。\u003c/p\u003e\n\n\u003cp\u003eBPF 使用了一个高度简化的版本，称为 \u003cstrong\u003eBTF\u003c/strong\u003e (BPF Type Format)。生成的 DWARF 可以\n转换成 BTF 格式，然后通过 BPF 对象加载器加载到内核。内核验证 BTF 数据的正确性，\n并跟踪 BTF 数据中包含的数据类型。\u003c/p\u003e\n\n\u003cp\u003e这样的话，就可以用键和值对 BPF map 打一些注解（annotation）存储到 BTF 数据中，这\n样下次 dump map 时，除了 map 内的数据外还会打印出相关的类型信息。这对内省（\nintrospection）、调试和格式良好的打印都很有帮助。注意，BTF 是一种通用的调试数据\n格式，因此任何从 DWARF 转换成的 BTF 数据都可以被加载（例如，内核 vmlinux DWARF 数\n据可以转换成 BTF 然后加载）。后者对于未来 BPF 的跟踪尤其有用。\u003c/p\u003e\n\n\u003cp\u003e将 DWARF 格式的调试信息转换成 BTF 格式需要用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eelfutils\u003c/code\u003e (\u0026gt;= 0.173) 工具。\n如果没有这个工具，那需要在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellc\u003c/code\u003e 编译时打开 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mattr=dwarfris\u003c/code\u003e 选项：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebpf \u003cspan class=\"nt\"\u003e-mattr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003ehelp\u003c/span\u003e |\u0026amp; \u003cspan class=\"nb\"\u003egrep \u003c/span\u003edwarfris\ndwarfris - Disable MCAsmInfo DwarfUsesRelocationsAcrossSections.\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mattr=dwarfris\u003c/code\u003e 是因为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edwarfris\u003c/code\u003e (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edwarf relocation in section\u003c/code\u003e) 选项禁\n用了 DWARF 和 ELF 的符号表之间的 DWARF cross-section 重定位，因为 libdw 不支持\nBPF 重定位。不打开这个选项的话，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 这类工具将无法正确地从对象中 dump 结构。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eelfutils\u003c/code\u003e (\u0026gt;= 0.173) 实现了合适的 BPF 重定位，因此没有打开 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mattr=dwarfris\u003c/code\u003e 选\n项也能正常工作。它可以从对象文件中的 DWARF 或 BTF 信息 dump 结构。目前 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e\n使用 LLVM 生成的 DWARF 信息，但未来它可能会使用 BTF 信息。\u003c/p\u003e\n\n\u003ch4 id=\"pahole\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e将 DWARF 转换成 BTF 格式需要使用较新的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 版本（\u0026gt;= 1.12），然后指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-J\u003c/code\u003e 选项。\n检查所用的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 版本是否支持 BTF（注意，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 会用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objcopy\u003c/code\u003e，因此\n也要检查后者是否已安装）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ pahole --help | grep BTF\n-J, --btf_encode           Encode as BTF\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e生成调试信息还需要前端的支持，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang\u003c/code\u003e 编译时指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-g\u003c/code\u003e 选项，生成源码级别的调\n试信息。注意，不管 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellc\u003c/code\u003e 是否指定了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edwarfris\u003c/code\u003e 选项，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-g\u003c/code\u003e 都是需要指定的。生成目\n标文件的完整示例：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ clang -O2 -g -Wall -target bpf -emit-llvm -c xdp-example.c -o xdp-example.bc\n$ llc xdp-example.bc -march=bpf -mattr=dwarfris -filetype=obj -o xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e或者，只使用 clang 这一个工具来编译带调试信息的 BPF 程序（同样，如果有合适的\nelfutils 版本，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edwarfris\u003c/code\u003e 选项可以省略）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ clang -target bpf -O2 -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e基于 DWARF 信息 dump BPF 程序的数据结构：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ pahole xdp-example.o\nstruct xdp_md {\n        __u32                      data;                 /*     0     4 */\n        __u32                      data_end;             /*     4     4 */\n        __u32                      data_meta;            /*     8     4 */\n\n        /* size: 12, cachelines: 1, members: 3 */\n        /* last cacheline: 12 bytes */\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在对象文件中，DWARF 数据将仍然伴随着新加入的 BTF 数据一起保留。完整的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang\u003c/code\u003e 和\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 示例：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ clang -target bpf -O2 -Wall -g -c -Xclang -target-feature -Xclang +dwarfris -c xdp-example.c -o xdp-example.o\n$ pahole -J xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"readelf\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf\u003c/code\u003e 工具可以看到多了一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.BTF\u003c/code\u003e section：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ereadelf \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e xdp-example.o\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e18] .BTF              PROGBITS         0000000000000000  00000671\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBPF 加载器（例如 iproute2）会检测和加载 BTF section，因此给 BPF map 注释（\nannotate）类型信息。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.2.3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"223-bpf-指令集\"\u003e2.2.3 BPF 指令集\u003c/h3\u003e\n\n\u003cp\u003eLLVM 默认用 BPF \u003cstrong\u003e\u003cmark\u003e基础指令集\u003c/mark\u003e\u003c/strong\u003e（base instruction set）生成代码，\n以确保生成的对象文件也能被稍老的 LTS 内核（例如 4.9+）加载。\n但 LLVM 提供了一个 BPF 后端选项 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mcpu\u003c/code\u003e，用来\u003cstrong\u003e\u003cmark\u003e指定特定的 BPF 指令集版本\u003c/mark\u003e\u003c/strong\u003e，\n即 BPF 基础指令集之上的指令集扩展（instruction set extensions），以生成更高效和\n体积更小的代码。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mcpu\u003c/code\u003e 类型：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-mcpu\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003ehelp\n\u003c/span\u003eAvailable CPUs \u003cspan class=\"k\"\u003efor \u003c/span\u003ethis target:\n\n  generic - Select the generic processor.\n  probe   - Select the probe processor.\n  v1      - Select the v1 processor.\n  v2      - Select the v2 processor.\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egeneric\u003c/code\u003e processor 是默认的 processor，也是 \u003cstrong\u003e\u003cmark\u003eBPF v1 基础指令集\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev2\u003c/code\u003e processor 通常在交叉编译 BPF 的环境下比较有用，即编译 BPF 的平台\n和最终执行 BPF 的平台不同（因此 BPF 内核特性可能也会不同）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e推荐使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mcpu=probe\u003c/code\u003e ，这也是 Cilium 内部在使用的类型\u003c/strong\u003e。使用这种类型时，\nLLVM BPF 后端会向内核询问可用的 BPF 指令集扩展，如果找到可用的，就会使用相应的指\n令集来编译 BPF 程序。\u003c/p\u003e\n\n\u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellc\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mcpu=probe\u003c/code\u003e 的完整示例：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-emit-llvm\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e xdp-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.bc\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellc xdp-example.bc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebpf \u003cspan class=\"nt\"\u003e-mcpu\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eprobe \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e xdp-example.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.2.4\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"224-指令和寄存器位宽6432-位\"\u003e2.2.4 指令和寄存器位宽（64/32 位）\u003c/h3\u003e\n\n\u003cp\u003e通常来说，LLVM IR 生成是架构无关的。但使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang\u003c/code\u003e 编译时是否指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-target bpf\u003c/code\u003e\n是有几点小区别的，取决于不同的平台架构（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003earm64\u003c/code\u003e 或其他），\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-target\u003c/code\u003e 的\n默认配置可能不同。\u003c/p\u003e\n\n\u003cp\u003e引用内核文档 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDocumentation/bpf/bpf_devel_QA.txt\u003c/code\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eBPF 程序可以嵌套 include 头文件，只要头文件中都是文件作用域的内联汇编代码（\nfile scope inline assembly codes）。大部分情况下默认 target 都可以处理这种情况，\n但如果 BPF 后端汇编器无法理解这些汇编代码，那 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target 会失败。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果编译时没有指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-g\u003c/code\u003e，那额外的 elf sections（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.eh_frame\u003c/code\u003e\n和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.rela.eh_frame\u003c/code\u003e）可能会以默认 target 格式出现在对象文件中，但不会是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e\ntarget。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e默认 target 可能会将一个 C \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eswitch\u003c/code\u003e 声明转换为一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eswitch\u003c/code\u003e 表的查找和跳转操作。\n由于 switch 表位于全局的只读 section，因此 BPF 程序的加载会失败。 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target\n不支持 switch 表优化。clang 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-fno-jump-tables\u003c/code\u003e 选项可以禁止生成 switch 表。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果 clang 指定了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-target bpf\u003c/code\u003e，那指针或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elong\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunsigned long\u003c/code\u003e 类型将永远\n是 64 位的，不管底层的 clang 可执行文件或默认的 target（或内核）是否是 32\n位。但如果使用的是 native clang target，那 clang 就会根据底层的架构约定（\narchitecture’s conventions）来编译这些类型，这意味着对于 32 位的架构，BPF 上下\n文中的指针或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elong\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunsigned long\u003c/code\u003e 类型会是 32 位的，但此时的 BPF LLVM 后端仍\n然工作在 64 位模式。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enative\u003c/code\u003e target 主要用于跟踪（tracing）内核中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct pt_regs\u003c/code\u003e，这个结构体对\nCPU 寄存器进行映射，或者是跟踪其他一些能感知 CPU 寄存器位宽（CPU’s register\nwidth）的内核结构体。\u003cstrong\u003e\u003cmark\u003e除此之外的其他场景，例如网络场景，都建议使用 \u003ccode\u003eclang -target bpf\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e另外，LLVM 从 7.0 开始支持 32 位子寄存器和 BPF ALU32 指令。另外，新加入了一个代\n码生成属性 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealu32\u003c/code\u003e。当指定这个参数时，LLVM 会尝试尽可能地使用 32 位子寄存器，例\n如当涉及到 32 位操作时。32 位子寄存器及相应的 ALU 指令组成了 ALU32 指令。例如，\n对于下面的示例代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003e32-bit-example.c\nvoid cal\u003cspan class=\"o\"\u003e(\u003c/span\u003eunsigned int \u003cspan class=\"k\"\u003e*\u003c/span\u003ea, unsigned int \u003cspan class=\"k\"\u003e*\u003c/span\u003eb, unsigned int \u003cspan class=\"k\"\u003e*\u003c/span\u003ec\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  unsigned int \u003cspan class=\"nb\"\u003esum\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003ea + \u003cspan class=\"k\"\u003e*\u003c/span\u003eb\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"k\"\u003e*\u003c/span\u003ec \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003esum\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使用默认的代码生成选项，产生的汇编代码如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ clang -target bpf -emit-llvm -S 32-bit-example.c\n$ llc -march=bpf 32-bit-example.ll\n$ cat 32-bit-example.s\ncal:\n  r1 = *(u32 *)(r1 + 0)\n  r2 = *(u32 *)(r2 + 0)\n  r2 += r1\n  *(u32 *)(r3 + 0) = r2\n  exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到默认使用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er\u003c/code\u003e 系列寄存器，这些都是 64 位寄存器，这意味着其中的加法都\n是 64 位加法。现在，如果指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-mattr=+alu32\u003c/code\u003e 强制要求使用 32 位，生成的汇编代码\n如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ llc -march=bpf -mattr=+alu32 32-bit-example.ll\n$ cat 32-bit-example.s\ncal:\n  w1 = *(u32 *)(r1 + 0)\n  w2 = *(u32 *)(r2 + 0)\n  w2 += w1\n  *(u32 *)(r3 + 0) = w2\n  exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到这次使用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ew\u003c/code\u003e 系列寄存器，这些是 32 位子寄存器。\u003c/p\u003e\n\n\u003cp\u003e使用 32 位子寄存器可能会减小（最终生成的代码中）\u003cstrong\u003e类型扩展指令\u003c/strong\u003e（type extension\ninstruction）的数量。另外，它对 32 位架构的内核 eBPF JIT 编译器也有所帮助，因为\n原来这些编译器都是用 32 位模拟 64 位 eBPF 寄存器，其中使用了很多 32 位指令来操作\n高 32 bit。即使写 32 位子寄存器的操作仍然需要对高 32 位清零，但只要确保从 32 位\n子寄存器的读操作只会读取低 32 位，那只要 JIT 编译器已经知道某个寄存器的定义只有\n子寄存器读操作，那对高 32 位的操作指令就可以避免。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.2.5\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"225-c-bpf-代码注意事项\"\u003e2.2.5 C BPF 代码注意事项\u003c/h3\u003e\n\n\u003cp\u003e用 C 语言编写 BPF 程序不同于用 C 语言做应用开发，有一些陷阱需要注意。本节列出了\n二者的一些不同之处。\u003c/p\u003e\n\n\u003ch4 id=\"1-所有函数都需要内联inlined没有函数调用对于老版本-llvm或共享库调用\"\u003e1. 所有函数都需要内联（inlined）、没有函数调用（对于老版本 LLVM）或共享库调用\u003c/h4\u003e\n\n\u003cp\u003eBPF 不支持共享库（Shared libraries）。但是，可以将常规的库代码（library code）放\n到头文件中，然后在主程序中 include 这些头文件，例如 Cilium 就大量使用了这种方式\n（可以查看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf/lib/\u003c/code\u003e 文件夹）。另外，也可以 include 其他的一些头文件，例如内核\n或其他库中的头文件，复用其中的静态内联函数（static inline functions）或宏/定义（\nmacros / definitions）。\u003c/p\u003e\n\n\u003cp\u003e内核 4.16+ 和 LLVM 6.0+ 之后已经支持 BPF-to-BPF 函数调用。对于任意给定的程序片段\n，在此之前的版本只能将全部代码编译和内联成一个扁平的 BPF 指令序列（a flat\nsequence of BPF instructions）。在这种情况下，最佳实践就是为每个库函数都使用一个\n像 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__inline\u003c/code\u003e 一样的注解（annotation ），下面的例子中会看到。推荐使用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealways_inline\u003c/code\u003e，因为编译器可能会对只注解为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einline\u003c/code\u003e 的长函数仍然做 un-inline 操\n作。\u003c/p\u003e\n\n\u003cp\u003e如果是后者，LLVM 会在 ELF 文件中生成一个\u003cstrong\u003e重定位项\u003c/strong\u003e（relocation entry），BPF\nELF 加载器（例如 iproute2）无法解析这个重定位项，因此会产生一条错误，因为对加载器\n来说\u003cstrong\u003e\u003cmark\u003e只有 BPF maps 是合法的、能够处理的重定位项\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __inline\n# define __inline                         \\\n   inline __attribute__((always_inline))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003e__inline\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_drop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"2-多个程序可以放在同一-c-文件中的不同-section\"\u003e2. 多个程序可以放在同一 C 文件中的不同 section\u003c/h4\u003e\n\n\u003cp\u003e\u003cstrong\u003eBPF C 程序大量使用 section annotations\u003c/strong\u003e。一个 C 文件典型情况下会分为 3 个或更\n多个 section。BPF ELF \u003cstrong\u003e\u003cmark\u003e加载器利用这些名字来提取和准备相关的信息\u003c/mark\u003e\u003c/strong\u003e，\n然后通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf()\u003c/code\u003e 系统调用加载程序和 maps。例如，查找创建 map 所需的元数据和 BPF 程序的 license 信息\n时，iproute2 会分别使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elicense\u003c/code\u003e 作为默认的 section 名字。注意在程序\n创建时 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elicense\u003c/code\u003e section 也会加载到内核，如果程序使用的是兼容 GPL 的协议，这些信\n息就可以启用那些 GPL-only 的辅助函数，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ktime_get_ns()\u003c/code\u003e 和\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read()\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e其余的 section 名字都是和特定的 BPF 程序代码相关的，例如，下面经过修改之后的代码\n包含两个程序 section：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e。这个非常简单的示例展示了不同 section\n（这里是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e）之间可以共享 BPF map 和常规的静态内联辅助函数（\n例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccount_data()\u003c/code\u003e）。\u003c/p\u003e\n\n\u003ch5 id=\"示例程序\"\u003e示例程序\u003c/h5\u003e\n\n\u003cp\u003e这里将原来的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp-example.c\u003c/code\u003e 修改为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc-example.c\u003c/code\u003e，然后用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 命令加载，attach 到\n一个 netdevice 的 ingress 或 egress hook。该程序对传输的字节进行计数，存储在一\n个名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eacc_map\u003c/code\u003e 的 BPF map 中，这个 map 有两个槽（slot），分别用于 ingress hook\n和 egress hook 的流量统计。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/pkt_cls.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdint.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iproute2/bpf_elf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __inline\n# define __inline                         \\\n   inline __attribute__((always_inline))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef lock_xadd\n# define lock_xadd(ptr, val)              \\\n   ((void)__sync_fetch_and_add(ptr, val))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef BPF_FUNC\n# define BPF_FUNC(NAME, ...)              \\\n   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n#endif\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003eBPF_FUNC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emap_lookup_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_elf_map\u003c/span\u003e \u003cspan class=\"n\"\u003eacc_map\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;maps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e           \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_MAP_TYPE_ARRAY\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize_key\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize_value\u003c/span\u003e     \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epinning\u003c/span\u003e        \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePIN_GLOBAL_NS\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emax_elem\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003e__inline\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eaccount_data\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e \u003cspan class=\"n\"\u003edir\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ebytes\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003ebytes\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emap_lookup_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eacc_map\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003edir\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebytes\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"n\"\u003elock_xadd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebytes\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eTC_ACT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;ingress\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003etc_ingress\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount_data\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;egress\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003etc_egress\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eaccount_data\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5 id=\"其他程序说明\"\u003e其他程序说明\u003c/h5\u003e\n\n\u003cp\u003e这个例子还展示了其他一些很有用的东西，在开发过程中要注意。\u003c/p\u003e\n\n\u003cp\u003e首先，include 了内核头文件、标准 C 头文件和一个特定的 iproute2 头文件\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiproute2/bpf_elf.h\u003c/code\u003e，后者定义了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e。\u003cstrong\u003e\u003cmark\u003eiproute2 有一个通用的\nBPF ELF 加载器\u003c/mark\u003e\u003c/strong\u003e，因此 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e的定义对于 XDP 和 tc 类型的程序是完全一样的。\u003c/p\u003e\n\n\u003cp\u003e其次，程序中每条 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e 记录（entry）定义一个 map，这个记录包含了生成一\n个（ingress 和 egress 程序需要用到的）map 所需的全部信息（例如 key/value 大\n小）。这个结构体的定义必须放在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e section，这样加载器才能找到它。可以用这个\n结构体声明很多名字不同的变量，但这些声明前面必须加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__section(\u0026#34;maps\u0026#34;)\u003c/code\u003e 注解。\u003c/p\u003e\n\n\u003cp\u003e结构体 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e 是特定于 iproute2 的。\u003cstrong\u003e\u003cmark\u003e不同的 BPF ELF 加载器有不同的格式\u003c/mark\u003e\u003c/strong\u003e，\n例如，内核源码树中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibbpf\u003c/code\u003e（主要是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e 在用）就有一个不同的规范\n（结构体定义）。iproute2 保证 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e 的后向兼容性。\u003cstrong\u003eCilium 采用的\n是 iproute2 模型\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e另外，这个例子还展示了 BPF 辅助函数是如何映射到 C 代码以及如何被使用的。这里首先定义了\n一个宏 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_FUNC\u003c/code\u003e，接受一个函数名 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNAME\u003c/code\u003e 以及其他的任意参数。然后用这个宏声明了一\n个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNAME\u003c/code\u003e 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem\u003c/code\u003e 的函数，经过宏展开后会变成\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_FUNC_map_lookup_elem\u003c/code\u003e 枚举值，后者以辅助函数的形式定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003euapi/linux/bpf.h\u003c/code\u003e\n。当随后这个程序被加载到内核时，校验器会检查传入的参数是否是期望的类型，如果是，\n就将辅助函数调用重新指向（re-points）某个真正的函数调用。另外，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 还展示了 map 是如何传递给 BPF 辅助函数的。这里，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e\nsection 中的  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026amp;acc_map\u003c/code\u003e 作为第一个参数传递给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e由于程序中定义的数组 map （array map）是全局的，因此计数时需要使用原子操作，这里\n是使用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elock_xadd()\u003c/code\u003e。LLVM 将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__sync_fetch_and_add()\u003c/code\u003e 作为一个内置函数映射到\nBPF 原子加指令，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_STX | BPF_XADD | BPF_W\u003c/code\u003e（for word sizes）。\u003c/p\u003e\n\n\u003cp\u003e另外，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.pinning\u003c/code\u003e 字段初始化为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePIN_GLOBAL_NS\u003c/code\u003e，这意味\n着 tc 会将这个 map 作为一个节点（node）钉（pin）到 BPF 伪文件系统。默认情况下，\n这个变量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eacc_map\u003c/code\u003e 将被钉到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/tc/globals/acc_map\u003c/code\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e如果指定的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePIN_GLOBAL_NS\u003c/code\u003e，那 map 会被放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/tc/globals/\u003c/code\u003e\u003c/strong\u003e。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglobals\u003c/code\u003e 是一个跨对象文件的全局命名空间。\u003c/li\u003e\n  \u003cli\u003e如果指定的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePIN_OBJECT_NS\u003c/code\u003e，tc 将会为对象文件创建一个它的本地目录（local to\nthe object file）。例如，只要指定了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePIN_OBJECT_NS\u003c/code\u003e，不同的 C 文件都可以像上\n面一样定义各自的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eacc_map\u003c/code\u003e。在这种情况下，这个 map 会在不同 BPF 程序之间共享。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePIN_NONE\u003c/code\u003e 表示 map 不会作为节点（node）钉（pin）到 BPF 文件系统，因此当 tc 退\n出时这个 map 就无法从用户空间访问了。同时，这还意味着独立的 tc 命令会创建出独\n立的 map 实例，因此后执行的 tc 命令无法用这个 map 名字找到之前被钉住的 map。\n在路径 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/tc/globals/acc_map\u003c/code\u003e 中，map 名是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eacc_map\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，在加载 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 程序时，tc 会先查找这个 map 在 BPF 文件系统中是否存在，不\n存在就创建一个。创建成功后，map 会被钉（pin）到 BPF 文件系统，因此当 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e 程\n序通过 tc 加载之后，它就会发现这个 map 存在了，接下来会复用这个 map 而不是再创建\n一个新的。在 map 存在的情况下，加载器还会确保 map 的属性（properties）是匹配的，\n例如 key/value 大小等等。\u003c/p\u003e\n\n\u003cp\u003e就像 tc 可以从同一 map 获取数据一样，第三方应用也可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e 系统调用中的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_OBJ_GET\u003c/code\u003e 命令创建一个指向某个 map 实例的新文件描述符，然后用这个描述\n符来查看/更新/删除 map 中的数据。\u003c/p\u003e\n\n\u003cp\u003e通过 clang 编译和 iproute2 加载：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e tc-example.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e tc-example.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev em1 clsact\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress bpf da obj tc-example.o sec ingress\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 egress bpf da obj tc-example.o sec egress\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 ingress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1 tag c5f7825e5dac396f\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 egress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e2 tag b2fd5adc0f262714\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ebpf\nsysfs on /sys/fs/bpf \u003cspan class=\"nb\"\u003etype \u003c/span\u003esysfs \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,seclabel\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nbpf on /sys/fs/bpf \u003cspan class=\"nb\"\u003etype \u003c/span\u003ebpf \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,relatime,mode\u003cspan class=\"o\"\u003e=\u003c/span\u003e0700\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etree /sys/fs/bpf/\n/sys/fs/bpf/\n+-- ip -\u0026gt; /sys/fs/bpf/tc/\n+-- tc\n|   +-- globals\n|       +-- acc_map\n+-- xdp -\u0026gt; /sys/fs/bpf/tc/\n\n4 directories, 1 file\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上步骤指向完成后，当包经过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eem\u003c/code\u003e 设备时，BPF map 中的计数器就会递增。\u003c/p\u003e\n\n\u003ch4 id=\"3-不允许全局变量\"\u003e3. 不允许全局变量\u003c/h4\u003e\n\n\u003cp\u003e出于第 1 条中提到的原因（只支持 BPF maps 重定位，译者注），BPF 不能使用全局变量\n，而常规 C 程序中是可以的。\u003c/p\u003e\n\n\u003cp\u003e但是，我们有\u003cstrong\u003e间接的方式\u003c/strong\u003e实现全局变量的效果：BPF 程序可以使用一个\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERCPU_ARRAY\u003c/code\u003e 类型的、只有一个槽（slot）的、可以存放任意类型数据（\narbitrary value size）的 \u003cstrong\u003eBPF map\u003c/strong\u003e。这可以实现全局变量的效果\u003cstrong\u003e原因是\u003c/strong\u003e，\n\u003cstrong\u003e\u003cmark\u003eBPF 程序在执行期间不会被内核抢占\u003c/mark\u003e\u003c/strong\u003e，因此可以用单个 map entry 作为一个 scratch buffer\n使用，存储临时数据，例如扩展 BPF 栈的限制（512 字节）。这种方式在尾调用中也是可\n以工作的，因为\u003cstrong\u003e\u003cmark\u003e尾调用执行期间也不会被抢占\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e另外，如果要在不同次 BPF 程序执行之间保持状态，使用常规的 BPF map 就可以了。\u003c/p\u003e\n\n\u003ch4 id=\"4-不支持常量字符串或数组const-strings-or-arrays\"\u003e4. 不支持常量字符串或数组（const strings or arrays）\u003c/h4\u003e\n\n\u003cp\u003eBPF C 程序中不允许定义 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econst\u003c/code\u003e 字符串或其他数组，原因和第 1 点及第 3 点一样，即\n，ELF 文件中生成的\u003cstrong\u003e重定位项（relocation entries）会被加载器拒绝\u003c/strong\u003e，因为不符合加\n载器的 ABI（加载器也无法修复这些重定位项，因为这需要对已经编译好的 BPF 序列进行\n大范围的重写）。\u003c/p\u003e\n\n\u003cp\u003e将来 LLVM 可能会检测这种情况，提前将错误抛给用户。现在可以用下面的辅助函数来\n临时解决（work around）：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eBPF_FUNC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etrace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003efmt_size\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e...);\u003c/span\u003e\n\n\u003cspan class=\"cp\"\u003e#ifndef printk\n# define printk(fmt, ...)                                      \\\n    ({                                                         \\\n        char ____fmt[] = fmt;                                  \\\n        trace_printk(____fmt, sizeof(____fmt), ##__VA_ARGS__); \\\n    })\n#endif\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e有了上面的定义，程序就可以自然地使用这个宏，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintk(\u0026#34;skb len:%u\\n\u0026#34;, skb-\u0026gt;len);\u003c/code\u003e。\n\u003cstrong\u003e\u003cmark\u003e输出会写到 trace pipe\u003c/mark\u003e\u003c/strong\u003e，用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etc exec bpf dbg\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n命令可以获取这些打印的消息。\u003c/p\u003e\n\n\u003cp\u003e不过，使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrace_printk()\u003c/code\u003e 辅助函数也有一些不足，因此不建议在生产环境使用。每次\n调用这个辅助函数时，常量字符串（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;skb len:%u\\n\u0026#34;\u003c/code\u003e）都需要加载到 BPF 栈，但这\n个辅助函数最多只能接受 5 个参数，因此使用这个函数输出信息时只能传递三个参数。\u003c/p\u003e\n\n\u003cp\u003e因此，虽然这个辅助函数对快速调试很有用，但（对于网络程序）还是推荐使用\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eskb_event_output()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 或 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003exdp_event_output()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n辅助函数。这两个函数接受从 BPF 程序\n传递自定义的结构体类型参数，然后将参数以及可选的包数据（packet sample）放到 perf\nevent ring buffer。例如，Cilium monitor 利用这些辅助函数实现了一个调试框架，以及\n在发现违反网络策略时发出通知等功能。这些函数通过一个无锁的、内存映射的、\nper-CPU 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e ring buffer 传递数据，因此要远快于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrace_printk()\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"5-使用-llvm-内置的函数做内存操作\"\u003e5. 使用 LLVM 内置的函数做内存操作\u003c/h4\u003e\n\n\u003cp\u003e因为 BPF 程序除了调用 BPF 辅助函数之外无法执行任何函数调用，因此常规的库代码必须\n实现为内联函数。另外，LLVM 也提供了一些可以用于特定大小（这里是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003en\u003c/code\u003e）的内置函数\n，这些函数永远都会被内联：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#ifndef memset\n# define memset(dest, chr, n)   __builtin_memset((dest), (chr), (n))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef memcpy\n# define memcpy(dest, src, n)   __builtin_memcpy((dest), (src), (n))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef memmove\n# define memmove(dest, src, n)  __builtin_memmove((dest), (src), (n))\n#endif\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eLLVM 后端中的某个问题会导致内置的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememcmp()\u003c/code\u003e 有某些边界场景下无法内联，因此在这\n个问题解决之前不推荐使用这个函数。\u003c/p\u003e\n\n\u003ch4 id=\"6-目前还不支持循环\"\u003e6. （目前还）不支持循环\u003c/h4\u003e\n\n\u003cp\u003e内核中的 BPF 校验器除了对其他的控制流进行图验证（graph validation）之外，还会对\n所有程序路径执行深度优先搜索（depth first search），确保其中不存在循环。这样做的\n目的是确保程序永远会结束。\u003c/p\u003e\n\n\u003cp\u003e但可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#pragma unroll\u003c/code\u003e 指令实现常量的、不超过一定上限的循环。下面是一个例子\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#pragma unroll\n\u003c/span\u003e    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003eIPV6_MAX_HEADERS\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eswitch\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enh\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_NONE\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eDROP_INVALID_EXTHDR\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_FRAGMENT\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eDROP_FRAG_NOSUPPORT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_HOP\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_ROUTING\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_AUTH\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_DEST\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb_load_bytes\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eopthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eopthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n                \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eDROP_INVALID\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n            \u003cspan class=\"n\"\u003enh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eopthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enexthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enh\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eNEXTHDR_AUTH\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n                \u003cspan class=\"n\"\u003elen\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eipv6_authlen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eopthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n                \u003cspan class=\"n\"\u003elen\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eipv6_optlen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eopthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"nl\"\u003edefault:\u003c/span\u003e\n            \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enexthdr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enh\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e另外一种实现循环的方式是：用一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERCPU_ARRAY\u003c/code\u003e map 作为本地 scratch\nspace（存储空间），然后用尾调用的方式调用函数自身。虽然这种方式更加动态，但目前\n\u003cstrong\u003e\u003cmark\u003e最大只支持 34 层\u003c/mark\u003e\u003c/strong\u003e（原始程序，外加 33 次尾调用）嵌套调用。\u003c/p\u003e\n\n\u003cp\u003e将来 BPF 可能会提供一些更加原生、但有一定限制的循环。\u003c/p\u003e\n\n\u003ch4 id=\"7-尾调用的用途\"\u003e7. 尾调用的用途\u003c/h4\u003e\n\n\u003cp\u003e尾调用能够从一个程序调到另一个程序，提供了\u003cstrong\u003e在运行时（runtime）原子地改变程序行\n为\u003c/strong\u003e的灵活性。为了选择要跳转到哪个程序，尾调用使用了 \u003cstrong\u003e程序数组 map\u003c/strong\u003e（\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/code\u003e），将 map 及其索引（index）传递给将要跳转到的程序。跳\n转动作一旦完成，就没有办法返回到原来的程序；但如果给定的 map 索引中没有程序（无\n法跳转），执行会继续在原来的程序中执行。\u003c/p\u003e\n\n\u003cp\u003e例如，可以用尾调用实现解析器的不同阶段，可以在运行时（runtime）更新这些阶段的新\n解析特性。\u003c/p\u003e\n\n\u003cp\u003e尾调用的另一个用处是\u003cstrong\u003e事件通知\u003c/strong\u003e，例如，Cilium 可以在运行时（runtime）开启或关闭丢弃\n包的通知（packet drop notifications），其中对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb_event_output()\u003c/code\u003e 的调用就是发\n生在被尾调用的程序中。因此，在常规情况下，执行的永远是从上到下的路径（\nfall-through path），当某个程序被加入到相关的 map 索引之后，程序就会解析元数据，\n触发向用户空间守护进程（user space daemon）发送事件通知。\u003c/p\u003e\n\n\u003cp\u003e程序数组 map 非常灵活， map 中每个索引对应的程序可以实现各自的动作（actions）。\n例如，attach 到 tc 或 XDP 的 root 程序执行初始的、跳转到程序数组 map 中索引为 0\n的程序，然后执行流量抽样（traffic sampling），然后跳转到索引为 1 的程序，在那个\n程序中应用防火墙策略，然后就可以决定是丢地包还是将其送到索引为 2 的程序中继续\n处理，在后者中，可能可能会被 mangle 然后再次通过某个接口发送出去。在程序数据 map\n之中是可以随意跳转的。当达到尾调用的最大调用深度时，内核最终会执行 fall-through\npath。\u003c/p\u003e\n\n\u003cp\u003e一个使用尾调用的最小程序示例：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"p\"\u003e[...]\u003c/span\u003e\n\n\u003cspan class=\"cp\"\u003e#ifndef __stringify\n# define __stringify(X)   #X\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section_tail\n# define __section_tail(ID, KEY)          \\\n   __section(__stringify(ID) \u0026#34;/\u0026#34; __stringify(KEY))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef BPF_FUNC\n# define BPF_FUNC(NAME, ...)              \\\n   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_##NAME\n#endif\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define BPF_JMP_MAP_ID   1\n\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eBPF_FUNC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etail_call\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                     \u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_elf_map\u003c/span\u003e \u003cspan class=\"n\"\u003ejmp_map\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;maps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e           \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eid\u003c/span\u003e             \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_JMP_MAP_ID\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize_key\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003esize_value\u003c/span\u003e     \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003euint32_t\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epinning\u003c/span\u003e        \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePIN_GLOBAL_NS\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emax_elem\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section_tail\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBPF_JMP_MAP_ID\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003elooper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eprintk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;skb cb: %u\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etail_call\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ejmp_map\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eTC_ACT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eentry\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__sk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003etail_call\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ejmp_map\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eTC_ACT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e加载这个示例程序时，tc 会创建其中的程序数组（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp_map\u003c/code\u003e 变量），并将其钉（pin）到\nBPF 文件系统中全局命名空间下名为的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejump_map\u003c/code\u003e 位置。而且，iproute2 中的 BPF ELF\n加载器也会识别出标记为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__section_tail()\u003c/code\u003e 的 section。 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp_map\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 字段会\n跟\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__section_tail()\u003c/code\u003e 中的 id 字段（这里初始化为常量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eJMP_MAP_ID\u003c/code\u003e）做匹配，因此程\n序能加载到用户指定的索引（位置），在上面的例子中这个索引是 0。然后，所有的尾调用\nsection 将会被 iproute2 加载器处理，关联到 map 中。这个机制并不是 tc 特有的，\niproute2 支持的其他 BPF 程序类型（例如 XDP、lwt）也适用。\u003c/p\u003e\n\n\u003cp\u003e生成的 elf 包含 section headers，描述 map id 和 map 内的条目：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e--no-show-raw-insn\u003c/span\u003e prog_array.o | less\nprog_array.o:   file format ELF64-BPF\n\nDisassembly of section 1/0:\nlooper:\n       0:       r6 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n       1:       r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er6 + 48\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n       2:       r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r2\n       3:       r1 +\u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n       4:       \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er6 + 48\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n       5:       r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0 ll\n       7:       call \u003cspan class=\"nt\"\u003e-1\u003c/span\u003e\n       8:       r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r6\n       9:       r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0 ll\n      11:       r3 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n      12:       call 12\n      13:       r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n      14:       \u003cspan class=\"nb\"\u003eexit\n\u003c/span\u003eDisassembly of section prog:\nentry:\n       0:       r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n       1:       \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er1 + 48\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r2\n       2:       r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0 ll\n       4:       r3 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n       5:       call 12\n       6:       r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n       7:       exi\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在这个例子中，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esection 1/0\u003c/code\u003e 表示 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elooper()\u003c/code\u003e 函数位于 map \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 中，在 map \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 内的\n位置是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e被钉住（pinned）map 可以被用户空间应用（例如 Cilium daemon）读取，也可以被 tc 本\n身读取，因为 tc 可能会用新的程序替换原来的程序，此时可能需要读取 map 内容。\n更新是原子的。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003etc 执行尾调用 map 更新（tail call map updates）的例子\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nb\"\u003eexec \u003c/span\u003ebpf graft m:globals/jmp_map key 0 obj new.o sec foo\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果 iproute2 需要更新被钉住（pinned）的程序数组，可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egraft\u003c/code\u003e 命令。上面的\n例子中指向的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglobals/jmp_map\u003c/code\u003e，那 tc 将会用一个新程序更新位于 index/key 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 的 map，\n这个新程序位于对象文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enew.o\u003c/code\u003e 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoo\u003c/code\u003e section。\u003c/p\u003e\n\n\u003ch4 id=\"8-bpf-最大栈空间-512-字节\"\u003e8. BPF 最大栈空间 512 字节\u003c/h4\u003e\n\n\u003cp\u003eBPF 程序的最大栈空间是 512 字节，在使用 C 语言实现 BPF 程序时需要考虑到这一点。\n但正如在第 3 点中提到的，可以通过一个只有一条记录（single entry）的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MAP_TYPE_PERCPU_ARRAY\u003c/code\u003e map 来绕过这限制，增大 scratch buffer 空间。\u003c/p\u003e\n\n\u003ch4 id=\"9-尝试使用-bpf-内联汇编\"\u003e9. 尝试使用 BPF 内联汇编\u003c/h4\u003e\n\n\u003cp\u003eLLVM 6.0 以后支持 BPF 内联汇编，在某些场景下可能会用到。下面这个玩具示例程序（\n没有实际意义）展示了一个 64 位原子加操作。\u003c/p\u003e\n\n\u003cp\u003e由于文档不足，要获取更多信息和例子，目前可能只能参考 LLVM 源码中的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/Target/BPF/BPFInstrInfo.td\u003c/code\u003e 以及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest/CodeGen/BPF/\u003c/code\u003e。测试代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;prog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_test\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u64\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/* just a toy xadd example to show the syntax */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003easm\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;lock *(u64 *)(%0+0) += %1\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=r\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上面的程序会被编译成下面的 BPF 指令序列：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eVerifier analysis:\n\n0: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2\n1: \u003cspan class=\"o\"\u003e(\u003c/span\u003e7b\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 \u003cspan class=\"nt\"\u003e-8\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n2: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3\n3: \u003cspan class=\"o\"\u003e(\u003c/span\u003ebf\u003cspan class=\"o\"\u003e)\u003c/span\u003e r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r10\n4: \u003cspan class=\"o\"\u003e(\u003c/span\u003e07\u003cspan class=\"o\"\u003e)\u003c/span\u003e r2 +\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nt\"\u003e-8\u003c/span\u003e\n5: \u003cspan class=\"o\"\u003e(\u003c/span\u003edb\u003cspan class=\"o\"\u003e)\u003c/span\u003e lock \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er2 +0\u003cspan class=\"o\"\u003e)\u003c/span\u003e +\u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n6: \u003cspan class=\"o\"\u003e(\u003c/span\u003e79\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 \u003cspan class=\"nt\"\u003e-8\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n7: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\n\u003c/span\u003eprocessed 8 insns \u003cspan class=\"o\"\u003e(\u003c/span\u003elimit 131072\u003cspan class=\"o\"\u003e)\u003c/span\u003e, stack depth 8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"10-用-pragma-pack-禁止结构体填充struct-padding\"\u003e10. 用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#pragma pack\u003c/code\u003e 禁止结构体填充（struct padding）\u003c/h4\u003e\n\n\u003cp\u003e现代编译器默认会对数据结构进行\u003cstrong\u003e内存对齐\u003c/strong\u003e（align），以实现更加高效的访问。结构\n体成员会被对齐到数倍于其自身大小的内存位置，不足的部分会进行填充（padding），因\n此结构体最终的大小可能会比预想中大。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003esector\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 4-byte\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 20-byte ?\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;size of %d-byte\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 24-byte\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Actual compiled composition of struct called_info\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 0x0(0)                   0x8(8)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  ↓________________________↓\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |        start (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |         end  (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |  sector(4) |  PADDING  | \u0026lt;= address aligned to 8\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |____________|___________|     with 4-byte PADDING.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e内核中的 BPF 校验器会检查栈边界（stack boundary），BPF 程序不会访问栈边界外的空\n间，或者是未初始化的栈空间。如果将结构体中填充出来的内存区域作为一个 map 值进行\n访问，那调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_load()\u003c/code\u003e 时就会报 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einvalid indirect read from stack\u003c/code\u003e 错误。\u003c/p\u003e\n\n\u003cp\u003e示例代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003esector\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map_def\u003c/span\u003e \u003cspan class=\"n\"\u003eSEC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;maps\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info_map\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etype\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_MAP_TYPE_HASH\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekey_size\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003evalue_size\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003emax_entries\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e4096\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eSEC\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;kprobe/submit_bio\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003esubmit_bio_entry\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ept_regs\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;submit_bio(bio=0x%lx) called: %llu\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003estart_time\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_ktime_get_ns\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003ebio_ptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ePT_REGS_PARM1\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003estart_time\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n            \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebi_sector\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003ebpf_map_update_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalled_info_map\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ebio_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF_ANY\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efmt\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ebio_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estart_time\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// On bpf_load_program\u003c/span\u003e\n\u003cspan class=\"n\"\u003ebpf_load_program\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"n\"\u003eerr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e13\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebf\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003er6\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e19\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eb7\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e20\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e72\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e21\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e80\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er7\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e22\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e63\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\n\u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"mi\"\u003e30\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e85\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map_update_elem\u003c/span\u003e\u003cspan class=\"err\"\u003e#\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\n\u003cspan class=\"n\"\u003einvalid\u003c/span\u003e \u003cspan class=\"n\"\u003eindirect\u003c/span\u003e \u003cspan class=\"n\"\u003eread\u003c/span\u003e \u003cspan class=\"n\"\u003efrom\u003c/span\u003e \u003cspan class=\"n\"\u003estack\u003c/span\u003e \u003cspan class=\"n\"\u003eoff\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e80\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e20\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e \u003cspan class=\"mi\"\u003e24\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_load()\u003c/code\u003e 中会调用 BPF 校验器的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_check()\u003c/code\u003e 函数，后者会调用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003echeck_func_arg() -\u0026gt; check_stack_boundary()\u003c/code\u003e 来检查栈边界。从上面的错误可以看出\n，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct called_info\u003c/code\u003e 被编译成 24 字节，错误信息提示从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e+20\u003c/code\u003e 位置读取数据是“非\n法的间接读取”（invalid indirect read）。从我们更前面给出的内存布局图中可以看到，\n地址 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x14(20)\u003c/code\u003e 是填充（PADDING ）开始的地方。这里再次画出内存布局图以方便对比：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// Actual compiled composition of struct called_info\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 0x10(16)    0x14(20)    0x18(24)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  ↓____________↓___________↓\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |  sector(4) |  PADDING  | \u0026lt;= address aligned to 8\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |____________|___________|     with 4-byte PADDING.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003echeck_stack_boundary()\u003c/code\u003e 会遍历每一个从开始指针出发的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccess_size\u003c/code\u003e (24) 字节，\n确保它们位于栈边界内部，并且栈内的所有元素都初始化了。因此填充的部分是不允许使用\n的，所以报了 “invalid indirect read from stack” 错误。要避免这种错误，需要将结\n构体中的填充去掉。这是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#pragma pack(n)\u003c/code\u003e 原语实现的：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#pragma pack(4)\n\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003esector\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 4-byte\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 20-byte ?\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;size of %d-byte\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 20-byte\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Actual compiled composition of packed struct called_info\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 0x0(0)                   0x8(8)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  ↓________________________↓\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |        start (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |         end  (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |  sector(4) |             \u0026lt;= address aligned to 4\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |____________|                 with no PADDING.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct called_info\u003c/code\u003e 前面加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#pragma pack(4)\u003c/code\u003e 之后，编译器会以 4 字节为单位\n进行对齐。上面的图可以看到，这个结构体现在已经变成 20 字节大小，没有填充了。\u003c/p\u003e\n\n\u003cp\u003e但是，去掉填充也是有弊端的。例如，编译器产生的代码没有原来优化的好。去掉填充之后\n，处理器访问结构体时触发的是非对齐访问（unaligned access），可能会导致性能下降。\n并且，某些架构上的校验器可能会直接拒绝非对齐访问。\u003c/p\u003e\n\n\u003cp\u003e不过，我们也有一种方式可以避免产生自动填充：手动填充。我们简单地在结构体中加入一\n个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu32 pad\u003c/code\u003e 成员来显式填充，这样既避免了自动填充的问题，又解决了非对齐访问的问\n题。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 8-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003esector\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 4-byte\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003epad\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 4-byte\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 24-byte ?\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;size of %d-byte\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecalled_info\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e \u003cspan class=\"c1\"\u003e// size of 24-byte\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Actual compiled composition of struct called_info with explicit padding\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 0x0(0)                   0x8(8)\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  ↓________________________↓\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |        start (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |         end  (8)       |\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |________________________|\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |  sector(4) |  pad (4)  | \u0026lt;= address aligned to 8\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e//  |____________|___________|     with explicit PADDING.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"11-通过未验证的引用invalidated-references访问包数据\"\u003e11. 通过未验证的引用（invalidated references）访问包数据\u003c/h4\u003e\n\n\u003cp\u003e某些网络相关的 BPF 辅助函数，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_skb_store_bytes\u003c/code\u003e，可能会修改包的大小。校验\n器无法跟踪这类改动，因此它会将所有之前对包数据的引用都视为过期的（未验证的）\n。因此，为避免程序被校验器拒绝，在访问数据之外需要先更新相应的引用。\u003c/p\u003e\n\n\u003cp\u003e来看下面的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eETH_HLEN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eskb_store_bytes\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eoffsetof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003enew_saddr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eprotocol\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eIPPROTO_TCP\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// do something\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e校验器会拒绝这段代码，因为它认为在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb_store_bytes\u003c/code\u003e 执行之后，引用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip4-\u0026gt;protocol\u003c/code\u003e 是未验证的（invalidated）:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003eR1\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003epkt_end\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,off\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,imm\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR2\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003epkt\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,off\u003cspan class=\"o\"\u003e=\u003c/span\u003e34,r\u003cspan class=\"o\"\u003e=\u003c/span\u003e34,imm\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR3\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv0\n  \u003cspan class=\"nv\"\u003eR6\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ectx\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,off\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,imm\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR7\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,umax_value\u003cspan class=\"o\"\u003e=\u003c/span\u003e4294967295,var_off\u003cspan class=\"o\"\u003e=(\u003c/span\u003e0x0\u003cspan class=\"p\"\u003e;\u003c/span\u003e 0xffffffff\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003eR8\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv4294967162 \u003cspan class=\"nv\"\u003eR9\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003epkt\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,off\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,r\u003cspan class=\"o\"\u003e=\u003c/span\u003e34,imm\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003efp0,call_-1\n  ...\n  18: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call bpf_skb_store_bytes#9\n  19: \u003cspan class=\"o\"\u003e(\u003c/span\u003e7b\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 \u003cspan class=\"nt\"\u003e-56\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r7\n  \u003cspan class=\"nv\"\u003eR0\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR6\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ectx\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,off\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,imm\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR7\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,umax_value\u003cspan class=\"o\"\u003e=\u003c/span\u003e2,var_off\u003cspan class=\"o\"\u003e=(\u003c/span\u003e0x0\u003cspan class=\"p\"\u003e;\u003c/span\u003e 0x3\u003cspan class=\"o\"\u003e))\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003eR8\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv4294967162 \u003cspan class=\"nv\"\u003eR9\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einv\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003eR10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003efp0,call_-1 fp-48\u003cspan class=\"o\"\u003e=\u003c/span\u003emmmm???? fp-56\u003cspan class=\"o\"\u003e=\u003c/span\u003emmmmmmmm\n  21: \u003cspan class=\"o\"\u003e(\u003c/span\u003e61\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er9 +23\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  R9 invalid mem access \u003cspan class=\"s1\"\u003e\u0026#39;inv\u0026#39;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要解决这个问题，必须更新（重新计算） \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip4\u003c/code\u003e 的地址：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eETH_HLEN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eskb_store_bytes\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eoffsetof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003enew_saddr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eip4\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eETH_HLEN\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eprotocol\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eIPPROTO_TCP\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// do something\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"tool_iproute2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"23-iproute2\"\u003e2.3 iproute2\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e很多前端工具，例如 bcc、perf、iproute2，都可以将 BPF 程序加载到内核\u003c/mark\u003e\u003c/strong\u003e。\nLinux 内核源码树中还提供了一个用户空间库 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/lib/bpf/\u003c/code\u003e（即 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elibbpf\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e），\n目前主要是 perf 在使用，用于加载 BPF 程序到内核，这个库的开发也主要是由 perf 在驱动。但这个库是通用的，并非\n只能被 perf 使用。bcc 是一个 BPF 工具套件，里面提供了很多有用的 BPF 程序，主要用\n于跟踪（tracing）；这些程序通过一个专门的 Python 接口加载，Python 代码中内嵌了\nBPF C 代码。\u003c/p\u003e\n\n\u003cp\u003e但通常来说，\u003cstrong\u003e\u003cmark\u003e不同前端在实现 BPF 程序时，语法和语义稍有不同\u003c/mark\u003e\u003c/strong\u003e。另外，\n内核源码树（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esamples/bpf/\u003c/code\u003e）中也有一些示例程序，它们解析生成的对象文件，通过系统\n调用直接加载代码到内核。\u003c/p\u003e\n\n\u003cp\u003e本节和前一节主要关注\u003cstrong\u003e如何使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiproute2\u003c/code\u003e 提供的 BPF 前端加载 XDP、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elwt\u003c/code\u003e\n类型的网络程序\u003c/strong\u003e，因为 \u003cstrong\u003eCilium 的 BPF 程序就是面向这个加载器实现的\u003c/strong\u003e。将来\nCilium 会实现自己原生的 BPF 加载器，但为了开发和调试方便，程序仍会保持与\niproute2 套件的兼容性。\u003c/p\u003e\n\n\u003cp\u003e所有 iproute2 支持的 BPF 程序都共享相同的 BPF 加载逻辑，因为它们使用相同的加载器\n后端（以函数库的形式，在 iproute2 中对应的代码是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/bpf.c\u003c/code\u003e）。\u003c/p\u003e\n\n\u003cp\u003e前面 LLVM 小节介绍了一些和编写 BPF C 程序相关的 iproute2 内容，本文接下来将关注\n编写这些程序时，和 tc 与 XDP 特定的方面。因此，本节将关注焦点放置使用例子上，展示\n\u003cstrong\u003e\u003cmark\u003e如何使用 iproute2 加载对象文件，以及加载器的一些通用机制\u003c/mark\u003e\u003c/strong\u003e。本节\n不会覆盖所有细节，但对于入门来说足够了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eiproute2/tc 加载 BPF 程序到内核的\u003cstrong\u003e\u003cmark\u003e底层实现\u003c/mark\u003e\u003c/strong\u003e，可参考\n\u003ca href=\"/blog/firewalling-with-bpf-xdp/\"\u003eFirewalling with BPF/XDP: Examples and Deep Dive\u003c/a\u003e，译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.3.1\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"231-加载-xdp-bpf-对象文件\"\u003e2.3.1 加载 XDP BPF 对象文件\u003c/h3\u003e\n\n\u003cp\u003e给定一个为 XDP 编译的 BPF 对象文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog.o\u003c/code\u003e，可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip\u003c/code\u003e 命令加载到支持 XDP 的\nnetdevice \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eem1\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj prog.o \u003cspan class=\"c\"\u003e# 等价于 ip link set dev em1 xdp obj prog.o sec prog\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上命令\u003cstrong\u003e\u003cmark\u003e假设程序代码存储在默认的 section\u003c/mark\u003e\u003c/strong\u003e，在 XDP 的场景下就是\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog\u003c/code\u003e section。如果是在其他 section，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoobar\u003c/code\u003e，那就需要用如下命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj prog.o sec foobar\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意，我们\u003cstrong\u003e\u003cmark\u003e还可以从默认的 \u003ccode\u003e.text\u003c/code\u003e section 加载程序\u003c/mark\u003e\u003c/strong\u003e：\n修改程序，从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_drop\u003c/code\u003e 入口去掉 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__section()\u003c/code\u003e 注解（这样程序默认就会放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.text\u003c/code\u003e 区域）：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/bpf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#ifndef __section\n# define __section(NAME)                  \\\n   __attribute__((section(NAME), used))\n#endif\n\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003exdp_drop\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_md\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"n\"\u003e__license\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"n\"\u003e__section\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;license\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;GPL\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后通过如下命令加载：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj prog.o sec .text\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认情况下，如果 XDP 程序已经 attach 到网络接口，那再次加载会报错，这样设计是为\n了防止程序被无意中覆盖。要\u003cstrong\u003e\u003cmark\u003e强制替换当前正在运行的 XDP 程序\u003c/mark\u003e\u003c/strong\u003e，必须\n指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-force\u003c/code\u003e 参数：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj prog.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e今天，大部分支持 XDP 的驱动都能够在\u003cstrong\u003e\u003cmark\u003e不会引起流量中断（traffic interrupt）的前提\n下，原子地替换运行中的程序\u003c/mark\u003e\u003c/strong\u003e。出于性能考虑，支持 XDP 的驱动只允许 attach 一个程序\n，不支持程序链（a chain of programs）。但正如上一节讨论的，如果有必要，可以\n通过尾调用来对程序进行拆分，以达到与程序链类似的效果。\u003c/p\u003e\n\n\u003cp\u003e如果一个接口上有 XDP 程序 attach，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link\u003c/code\u003e 命令会显示一个 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp\u003c/code\u003e 标记\u003c/strong\u003e。因\n此，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link | grep xdp\u003c/code\u003e 列出\u003cstrong\u003e\u003cmark\u003e所有有 XDP 程序在运行的网络接口\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip -d link\u003c/code\u003e 可以查看进一步信息；\u003c/li\u003e\n  \u003cli\u003e另外，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpftool\u003c/code\u003e 指定 BPF 程序 ID 可以获取 attached 程序的信息，其中程序 ID 可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link\u003c/code\u003e 看到。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e从接口\u003cstrong\u003e\u003cmark\u003e删除 XDP 程序\u003c/mark\u003e\u003c/strong\u003e，执行下面的命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要将驱动的工作模式从 non-XDP 切换到 native XDP ，或者相反，通常情况下驱动都需要\n重新配置它的接收（和发送）环形缓冲区，以保证接收的数据包在单个页面内是线性排列的，\n这样 BPF 程序才可以读取或写入。一旦完成这项配置后，大部分驱动只需要执行一次原子\n的程序替换，将新的 BPF 程序加载到设备中。\u003c/p\u003e\n\n\u003ch4 id=\"xdp-工作模式\"\u003eXDP 工作模式\u003c/h4\u003e\n\n\u003cp\u003eXDP 总共支持三种工作模式（operation mode），这三种模式 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiproute2\u003c/code\u003e 都实现了：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpdrv\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpdrv\u003c/code\u003e 表示 \u003cstrong\u003enative XDP\u003c/strong\u003e（原生 XDP）, 意味着 BPF 程序\u003cstrong\u003e直接在驱动的接收路\n  径上运行\u003c/strong\u003e，理论上这是软件层最早可以处理包的位置（the earliest possible\n  point）。这是\u003cstrong\u003e常规/传统的 XDP 模式，需要驱动实现对 XDP 的支持\u003c/strong\u003e，目前 Linux\n  内核中主流的 10G/40G 网卡都已经支持。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpgeneric\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpgeneric\u003c/code\u003e 表示 \u003cstrong\u003egeneric XDP\u003c/strong\u003e（通用 XDP），用于给那些还没有原生支持 XDP\n  的驱动进行试验性测试。generic XDP hook 位于内核协议栈的主接收路径（main\n  receive path）上，接受的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 格式的包，但由于 \u003cstrong\u003e这些 hook 位于 ingress\n  路径的很后面\u003c/strong\u003e，因此与 native XDP 相比性能有明显下降。因\n  此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpgeneric\u003c/code\u003e 大部分情况下只能用于试验目的，很少用于生产环境。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpoffload\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e最后，一些智能网卡（例如支持 Netronome’s nfp 驱动的网卡）实现了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpoffload\u003c/code\u003e 模式\n  ，允许将整个 BPF/XDP 程序 offload 到硬件，因此程序在网卡收到包时就直接在网卡进行\n  处理。这提供了比 native XDP 更高的性能，虽然在这种模式中某些 BPF map 类型\n  和 BPF 辅助函数是不能用的。BPF 校验器检测到这种情况时会直\n  接报错，告诉用户哪些东西是不支持的。除了这些不支持的 BPF 特性之外，其他方面与\n  native XDP 都是一样的。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link set dev em1 xdp obj [...]\u003c/code\u003e 命令时，内核会\u003cstrong\u003e\u003cmark\u003e先尝试以 native XDP\n模式加载程序，如果驱动不支持再自动回退到 generic XDP 模式\u003c/mark\u003e\u003c/strong\u003e。如果显式指定了\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpdrv\u003c/code\u003e 而不是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp\u003c/code\u003e，那驱动不支持 native XDP 时加载就会直接失败，而不再尝试\ngeneric XDP 模式。\u003c/p\u003e\n\n\u003cp\u003e一个例子：以 native XDP 模式强制加载一个 BPF/XDP 程序，打印链路详情，最后再卸载程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpdrv obj prog.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink \u003c/span\u003eshow\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n6: em1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 xdp qdisc mq state UP mode DORMANT group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n    prog/xdp \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1 tag 57cd311f2e27366b\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpdrv off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e还是这个例子，但强制以 generic XDP 模式加载（即使驱动支持 native XDP），另外用\nbpftool 打印 attached 的这个 dummy 程序内具体的 BPF 指令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric obj prog.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink \u003c/span\u003eshow\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n6: em1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 xdpgeneric qdisc mq state UP mode DORMANT group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n    prog/xdp \u003cspan class=\"nb\"\u003eid \u003c/span\u003e4 tag 57cd311f2e27366b                \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e BPF program ID 4\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog dump xlated \u003cspan class=\"nb\"\u003eid \u003c/span\u003e4                       \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e Dump of instructions running on em1\n0: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n1: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后卸载 XDP，用 bpftool 打印程序信息，查看其中的一些元数据：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ ip -force link set dev em1 xdpoffload obj prog.o\n\n$ ip link show\n[...]\n6: em1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000\n    link/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n    prog/xdp id 8 tag 57cd311f2e27366b\n[...]\n\n$ bpftool prog show id 8\n8: xdp  tag 57cd311f2e27366b dev em1                  \u0026lt;-- Also indicates a BPF program offloaded to em1\n    loaded_at Apr 11/20:38  uid 0\n    xlated 16B  not jited  memlock 4096B\n\n$ ip link set dev em1 xdpoffload off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意，每个程序只能选择用一种 XDP 模式加载，无法同时使用多种模式，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpdrv\u003c/code\u003e\n和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdpgeneric\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e无法原子地在不同 XDP 模式之间切换\u003c/mark\u003e\u003c/strong\u003e，例如从 generic 模式切换到\nnative 模式。但重复设置为同一种模式是可以的：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric obj prog.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpoffload obj prog.o\nRTNETLINK answers: File exists\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpdrv obj prog.o\nRTNETLINK answers: File exists\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric obj prog.o    \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e Succeeds due to xdpgeneric\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在不同模式之间切换时，需要先退出当前的操作模式，然后才能进入新模式：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric obj prog.o\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpgeneric off\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpoffload obj prog.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip l\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n6: em1: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 xdpoffload qdisc mq state UP mode DORMANT group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether be:08:4d:b6:85:65 brd ff:ff:ff:ff:ff:ff\n    prog/xdp \u003cspan class=\"nb\"\u003eid \u003c/span\u003e17 tag 57cd311f2e27366b\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdpoffload off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.3.2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"232-加载-tc-bpf-对象文件\"\u003e2.3.2 加载 tc BPF 对象文件\u003c/h3\u003e\n\n\u003ch4 id=\"用-tc-加载-bpf-程序\"\u003e用 tc 加载 BPF 程序\u003c/h4\u003e\n\n\u003cp\u003e给定一个为 tc 编译的 BPF 对象文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog.o\u003c/code\u003e， 可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 命令将其加载到一个网\n络设备（netdevice）。但\u003cstrong\u003e与 XDP 不同，设备是否支持 attach BPF 程序并不依赖驱动\u003c/strong\u003e\n（即\u003cstrong\u003e\u003cmark\u003e任何网络设备都支持 tc BPF\u003c/mark\u003e\u003c/strong\u003e）。下面的命令可以将程序 attach 到\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eem1\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 网络：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev em1 clsact\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress bpf da obj prog.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e第一步创建了一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclsact\u003c/code\u003e qdisc (Linux 排队规则，Linux \u003cstrong\u003equeueing discipline\u003c/strong\u003e)。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclsact\u003c/code\u003e 是一个 \u003cstrong\u003e\u003cmark\u003edummy qdisc\u003c/mark\u003e\u003c/strong\u003e，和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e qdisc 类似，用于\n  \u003cstrong\u003e\u003cmark\u003e持有（hold）分类器和动作\u003c/mark\u003e\u003c/strong\u003e（classifier and actions），但\n  \u003cstrong\u003e\u003cmark\u003e不执行真正的排队\u003c/mark\u003e\u003c/strong\u003e（queueing）。后面 attach \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e 分类器需要用到它。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclsact\u003c/code\u003e qdisc 提供了\u003cstrong\u003e\u003cmark\u003e两个特殊的 hook\u003c/mark\u003e\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e，分类器可以\n  attach 到这两个 hook 点。这两个 hook 都位于 datapath 的关键收发路径上，设备\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eem1\u003c/code\u003e 的每个包都会经过这两个点。二者的内核调用路径：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e hook：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e__netif_receive_skb_core() -\u0026gt; sch_handle_ingress()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e hook：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e__dev_queue_xmit() -\u0026gt; sch_handle_egress()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e类似地，将程序 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e hook 的命令：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc filter add dev em1 egress bpf da obj prog.o\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclsact\u003c/code\u003e qdisc \u003cstrong\u003e\u003cmark\u003e在 ingress 和 egress 方向以无锁（lockless）方式执行\u003c/mark\u003e\u003c/strong\u003e，\n  而且可以 attach 到\u003cstrong\u003e\u003cmark\u003e虚拟的、无队列的设备\u003c/mark\u003e\u003c/strong\u003e（virtual,\nqueue-less devices），例如连接容器和宿主机的 \u003cstrong\u003e\u003cmark\u003eveth 设备\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e第二条命令，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc filter\u003c/code\u003e 选择了在 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eda\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（direct-action）模式中使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eda\u003c/code\u003e 是\n推荐的模式，并且应该永远指定这个参数。简单来说，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eda\u003c/code\u003e 模式表示 \u003cstrong\u003e\u003cmark\u003ebpf 分类器不需要调用外部的 tc action 模块\u003c/mark\u003e\u003c/strong\u003e。\n事实上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e 分类器也完全不需要调用外部模块，因为所有的 packet mangling、\n转发或其他类型的 action 都可以在这单个 BPF 程序内完成，因此执行会明显更快。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多关于 da 模式的信息，可参考：\n\u003ca href=\"/blog/understanding-tc-da-mode-zh/\"\u003e\u003cmark\u003e(译) 深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/mark\u003e\u003c/a\u003e 译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e配置了这两条命令之后，程序就 attach 完成了，接下来只要有包经过这个设备，就会触发\n这个程序执行。和 XDP 类似，如果没有使用默认 section 名字，那可以在加载时指定，例\n如指定 section 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoobar\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 egress bpf da obj prog.o sec foobar\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eiproute2 BPF 加载器的命令行语法对不同的程序类型都是一样的，因此\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eobj prog.o sec foobar\u003c/code\u003e 命令行格式和前面看到的 XDP 的加载是类似的。\u003c/p\u003e\n\n\u003ch4 id=\"查看已经-attach-的程序\"\u003e查看已经 attach 的程序\u003c/h4\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 ingress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 prog.o:[ingress] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1 tag c5f7825e5dac396f\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 egress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 prog.o:[egress] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e2 tag b2fd5adc0f262714\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e输出中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog.o:[ingress]\u003c/code\u003e 表示 section \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 中的程序是从 文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog.o\u003c/code\u003e 加\n载的，而且 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e 工作在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 模式。上面还打印了程序的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etag\u003c/code\u003e，\n其中 \u003cstrong\u003e\u003cmark\u003etag 是指令序列的哈希\u003c/mark\u003e\u003c/strong\u003e，可以\n\u003cstrong\u003e\u003cmark\u003e关联到对应的对象文件或用 perf 查看调用栈信息\u003c/mark\u003e\u003c/strong\u003e。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 是一个操作系统层唯一的 BPF 程序标识符，可以\u003cstrong\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpftool\u003c/code\u003e 进一步查看或 dump 相关的程序信息\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003etc 可以 attach 多个 BPF 程序，并提供了其他的一些分类器，这些分类器可以 chain 到\n一起使用。但是，attach 单个 BPF 程序已经完全足够了，因为有了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eda\u003c/code\u003e 模式，所有的包\n操作都可以放到同一个程序中，这意味着 BPF 程序自身将会返回 tc action verdict，例\n如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_SHOT\u003c/code\u003e 等等。出于最佳性能和灵活性考虑，这（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eda\u003c/code\u003e 模式）是推\n荐的使用方式。\u003c/p\u003e\n\n\u003ch4 id=\"程序优先级pref和句柄handle\"\u003e程序优先级（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e）和句柄（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cp\u003e在上面的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eshow\u003c/code\u003e 命令中，tc 还打印出了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref 49152\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle 0x1\u003c/code\u003e。如果之前没有\n通过命令行显式指定，这两个数据就会自动生成。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e 表示\u003cstrong\u003e\u003cmark\u003e优先级\u003c/mark\u003e\u003c/strong\u003e，如果指定了\u003cstrong\u003e\u003cmark\u003e多个分类器\u003c/mark\u003e\u003c/strong\u003e，它们会按照\u003cstrong\u003e\u003cmark\u003e优先级从高到低依次执行\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e 是一个标识符，在\u003cstrong\u003e\u003cmark\u003e加载了同一分类器的多个实例\u003c/mark\u003e\u003c/strong\u003e并且它们的优先级（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e）都一样的情况下会用到这个标识符。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因为\u003cstrong\u003e\u003cmark\u003e在 BPF 的场景下，单个程序就足够了\u003c/mark\u003e\u003c/strong\u003e，因此 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e 通常情况下都可以忽略。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e除非打算后面原子地替换 attached BPF 程序\u003c/mark\u003e\u003c/strong\u003e，否则不建议在加载时显式指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e显式指定这两个参数的好处是，后面执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereplace\u003c/code\u003e 操作时，就不需要再去动态地查询这两个值。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e显式指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epref\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e 时的加载命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 prog.o:[foobar] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1 tag c5f7825e5dac396f\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对应的原子 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereplace\u003c/code\u003e 命令：将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e hook 处的已有程序替换为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog.o\u003c/code\u003e 文件中\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoobar\u003c/code\u003e section 中的新 BPF 程序，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter replace dev em1 ingress pref 1 handle 1 bpf da obj prog.o sec foobar\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"用-tc-删除-bpf-程序\"\u003e用 tc 删除 BPF 程序\u003c/h4\u003e\n\n\u003cp\u003e最后，要分别从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e 删除所有 attach 的程序，执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter del dev em1 ingress\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter del dev em1 egress\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要从 netdevice 删除整个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclsact\u003c/code\u003e qdisc（会隐式地删除 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e 和\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eegress\u003c/code\u003e hook 上面的所有程序），执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc del dev em1 clsact\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"offload-到网卡\"\u003eoffload 到网卡\u003c/h4\u003e\n\n\u003cp\u003e和 XDP BPF 程序类似，如果网卡驱动支持 tc BPF 程序，那也可以将它们 offload 到网卡\n。Netronome 的 nfp 网卡对 XDP 和 tc BPF 程序都支持 offload。\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ tc qdisc add dev em1 clsact\n$ tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o\nError: TC offload is disabled on net device.\nWe have an error talking to the kernel\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果显式以上错误，那需要先启用网卡的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ehw-tc-offload\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 功能：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ ethtool -K em1 hw-tc-offload on\n\n$ tc qdisc add dev em1 clsact\n$ tc filter replace dev em1 ingress pref 1 handle 1 bpf skip_sw da obj prog.o\n$ tc filter show dev em1 ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 prog.o:[classifier] direct-action skip_sw in_hw id 19 tag 57cd311f2e27366b\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ein_hw\u003c/code\u003e 标志表示这个程序已经被 offload 到网卡了。\u003c/p\u003e\n\n\u003cp\u003e注意，tc 和 XDP offload 无法同时加载，因此必须要指明是 tc 还是 XDP offload 选项\n。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"ch_2.3.3\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"233-通过-netdevsim-驱动测试-bpf-offload\"\u003e2.3.3 通过 netdevsim 驱动测试 BPF offload\u003c/h3\u003e\n\n\u003cp\u003enetdevsim 驱动是 Linux 内核的一部分，它是一个 dummy driver，实现了 XDP BPF 和 tc\nBPF 程序的 offload 接口，以及其他一些设施，这些设施可以用来测试内核的改动，或者\n某些利用内核的 UAPI 实现了一个控制平面功能的底层用户空间程序。\u003c/p\u003e\n\n\u003cp\u003e可以用如下命令创建一个 netdevsim 设备：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emodprobe netdevsim\n// \u003cspan class=\"o\"\u003e[\u003c/span\u003eID] \u003cspan class=\"o\"\u003e[\u003c/span\u003ePORT_COUNT]\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;1 1\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /sys/bus/netdevsim/new_device\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edevlink dev\nnetdevsim/netdevsim1\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edevlink port\nnetdevsim/netdevsim1/0: \u003cspan class=\"nb\"\u003etype \u003c/span\u003eeth netdev eth0 flavour physical\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip l\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n4: eth0: \u0026lt;BROADCAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后就可以加载 XDP 或 tc BPF 程序，命令和前面的一些例子一样：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev eth0 xdpoffload obj prog.o\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip l\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n4: eth0: \u0026lt;BROADCAST,NOARP,UP,LOWER_UP\u0026gt; mtu 1500 xdpoffload qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 2a:d5:cd:08:d1:3f brd ff:ff:ff:ff:ff:ff\n    prog/xdp \u003cspan class=\"nb\"\u003eid \u003c/span\u003e16 tag a04f5eef06a7f555\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这是用 iproute2 加载 XDP/tc BPF 程序的两个标准步骤。\u003c/p\u003e\n\n\u003cp\u003e还有很多对 XDP 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 都适用的 \u003cstrong\u003eBPF 加载器高级选项\u003c/strong\u003e，下面列出其中一些。为简单\n起见，这里只列出了 XDP 的例子。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e打印更多 log（Verbose），即使命令执行成功\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e在命令最后加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003everb\u003c/code\u003e 选项可以打印校验器的日志：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp obj xdp-example.o verb\n\n Prog section \u003cspan class=\"s1\"\u003e\u0026#39;prog\u0026#39;\u003c/span\u003e loaded \u003cspan class=\"o\"\u003e(\u003c/span\u003e5\u003cspan class=\"o\"\u003e)!\u003c/span\u003e\n  - Type:         6\n  - Instructions: 2 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0 over limit\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  - License:      GPL\n\n Verifier analysis:\n\n 0: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n 1: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\n \u003c/span\u003eprocessed 2 insns\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e加载已经 pin 在 BPF 文件系统中的程序\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e除了从对象文件加载程序之外，iproute2 还可以从 BPF 文件系统加载程序。在某些场\n 景下，一些外部实体会将 BPF 程序 pin 在 BPF 文件系统并 attach 到设备。加载命\n 令：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp pinned /sys/fs/bpf/prog\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eiproute2 还可以使用更简短的相对路径方式（相对于 BPF 文件系统的挂载点）：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev em1 xdp pinned m:prog\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在加载 BPF 程序时，iproute2 会自动检测挂载的文件系统实例。如果发现还没有挂载，tc\n就会自动将其挂载到\u003cstrong\u003e\u003cmark\u003e默认位置\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果发现已经挂载了一个 BPF 文件系统实例，接下来就会使用这个实例，不会再挂载新的\n了：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003emkdir\u003c/span\u003e /var/run/bpf\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount \u003cspan class=\"nt\"\u003e--bind\u003c/span\u003e /var/run/bpf /var/run/bpf\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e bpf bpf /var/run/bpf\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress bpf da obj tc-example.o sec prog\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etree /var/run/bpf\n/var/run/bpf\n+-- ip -\u0026gt; /run/bpf/tc/\n+-- tc\n|   +-- globals\n|       +-- jmp_map\n+-- xdp -\u0026gt; /run/bpf/tc/\n\n4 directories, 1 file\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e默认情况下，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 会创建一个如上面所示的初始目录，所有子系统的用户都会通过符号\n链接（symbolic links）指向相同的位置，也是就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglobals\u003c/code\u003e 命名空间\u003c/strong\u003e，因此 pinned\nBPF maps 可以被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiproute2\u003c/code\u003e 中不同类型的 BPF 程序使用。如果文件系统实例已经挂载、\n目录已经存在，那 tc 是不会覆盖这个目录的。因此对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elwt\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp\u003c/code\u003e 这几种类\n型的 BPF maps，可以从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglobals\u003c/code\u003e 中分离出来，放到各自的目录存放。\u003c/p\u003e\n\n\u003cp\u003e在前面的 LLVM 小节中简要介绍过，安装 iproute2 时会向系统中安装一个头文件，BPF 程\n序可以直接以标准路径（standard include path）来 include 这个头文件：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;iproute2/bpf_elf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个头文件中提供的 API 可以让程序使用 maps 和默认 section 名字。它是\n\u003cstrong\u003e\u003cmark\u003eiproute2 和 BPF 程序之间的一份稳定契约\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eiproute2 中 map 的定义是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e\u003c/strong\u003e。这个结构体内的成员变量已经在\nLLVM 小节中介绍过了。\u003c/p\u003e\n\n\u003cp\u003eWhen parsing the BPF object file, the iproute2 loader will walk through\nall ELF sections. It initially fetches ancillary sections like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e and\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elicense\u003c/code\u003e. For \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e array will be checked\nfor validity and whenever needed, compatibility workarounds are performed.\nSubsequently all maps are created with the user provided information, either\nretrieved as a pinned object, or newly created and then pinned into the BPF\nfile system. Next the loader will handle all program sections that contain\nELF relocation entries for maps, meaning that BPF instructions loading\nmap file descriptors into registers are rewritten so that the corresponding\nmap file descriptors are encoded into the instructions immediate value, in\norder for the kernel to be able to convert them later on into map kernel\npointers. After that all the programs themselves are created through the BPF\nsystem call, and tail called maps, if present, updated with the program’s file\ndescriptors.\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"tool_iproute2\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"24-bpftool\"\u003e2.4 bpftool\u003c/h2\u003e\n\n\u003cp\u003ebpftool 是\u003cstrong\u003e查看和调试 BPF 程序\u003c/strong\u003e的主要工具。它随内核一起开发，在内核中的路径是\n\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/bpftool/\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e这个工具可以完成\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003edump 当前已经加载到系统中的所有 BPF 程序和 map\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e列出和指定程序相关的所有 BPF map\u003c/li\u003e\n  \u003cli\u003edump 整个 map 中的 key/value 对\u003c/li\u003e\n  \u003cli\u003e查看、更新、删除特定 key\u003c/li\u003e\n  \u003cli\u003e查看给定 key 的相邻 key（neighbor key）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e要执行这些操作可以指定 BPF 程序、map ID，或者指定 BPF 文件系统中程序或 map 的位\n置。另外，这个工具还提供了将 map 或程序钉（pin）到 BPF 文件系统的功能。\u003c/p\u003e\n\n\u003cp\u003e查看系统当前已经加载的 BPF 程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog\n398: sched_cls  tag 56207908be8ad877\n   loaded_at Apr 09/16:24  uid 0\n   xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14\n399: sched_cls  tag abc95fb4835a6ec9\n   loaded_at Apr 09/16:24  uid 0\n   xlated 344B  jited 223B  memlock 4096B  map_ids 18\n400: sched_cls  tag afd2e542b30ff3ec\n   loaded_at Apr 09/16:24  uid 0\n   xlated 1720B  jited 1001B  memlock 4096B  map_ids 17\n401: sched_cls  tag 2dbbd74ee5d51cc8\n   loaded_at Apr 09/16:24  uid 0\n   xlated 3728B  jited 2099B  memlock 4096B  map_ids 17\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e类似地，查看所有的 active maps：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool map\n5: \u003cspan class=\"nb\"\u003ehash  \u003c/span\u003eflags 0x0\n    key 20B  value 112B  max_entries 65535  memlock 13111296B\n6: \u003cspan class=\"nb\"\u003ehash  \u003c/span\u003eflags 0x0\n    key 20B  value 20B  max_entries 65536  memlock 7344128B\n7: \u003cspan class=\"nb\"\u003ehash  \u003c/span\u003eflags 0x0\n    key 10B  value 16B  max_entries 8192  memlock 790528B\n8: \u003cspan class=\"nb\"\u003ehash  \u003c/span\u003eflags 0x0\n    key 22B  value 28B  max_entries 8192  memlock 987136B\n9: \u003cspan class=\"nb\"\u003ehash  \u003c/span\u003eflags 0x0\n    key 20B  value 8B  max_entries 512000  memlock 49352704B\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ebpftool 的每个命令都提供了以 json 格式打印的功能，在命令末尾指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--json\u003c/code\u003e 就行了。\n另外，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--pretty\u003c/code\u003e 会使得打印更加美观，看起来更清楚。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog \u003cspan class=\"nt\"\u003e--json\u003c/span\u003e \u003cspan class=\"nt\"\u003e--pretty\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要 dump 特定 BPF 程序的 post-verifier BPF 指令镜像（instruction image），可以先\n从查看一个具体程序开始，例如，查看 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eingress\u003c/code\u003e hook 上的程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev cilium_host egress\nfilter protocol all pref 1 bpf chain 0\nfilter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n                    direct-action not_in_hw \u003cspan class=\"nb\"\u003eid \u003c/span\u003e406 tag e0362f5bd9163a0a jited\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个程序是从对象文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_host.o\u003c/code\u003e 加载来的，程序位于对象文件的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-netdev\u003c/code\u003e\nsection，程序 ID 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e406\u003c/code\u003e。基于以上信息 bpftool 可以提供一些关于这个程序的上层元\n数据：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog show \u003cspan class=\"nb\"\u003eid \u003c/span\u003e406\n406: sched_cls  tag e0362f5bd9163a0a\n     loaded_at Apr 09/16:24  uid 0\n     xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从上面的输出可以看到：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e程序 ID 为 406，类型是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esched_cls\u003c/code\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_SCHED_CLS\u003c/code\u003e），有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etag\u003c/code\u003e\n为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ee0362f5bd9163a0a\u003c/code\u003e（指令序列的 SHA sum）\u003c/li\u003e\n  \u003cli\u003e这个程序被 root \u003ccode class=\"language-plaintext highlighter-rouge\"\u003euid 0\u003c/code\u003e 在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eApr 09/16:24\u003c/code\u003e 加载\u003c/li\u003e\n  \u003cli\u003eBPF 指令序列有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e11,144 bytes\u003c/code\u003e 长，JIT 之后的镜像有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e7,721 bytes\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e程序自身（不包括 maps）占用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12,288 bytes\u003c/code\u003e，这部分空间使用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003euid 0\u003c/code\u003e 用户\n的配额\u003c/li\u003e\n  \u003cli\u003eBPF 程序使用了 ID 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e18\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e20\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e8\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e14\u003c/code\u003e 的 BPF map。可以用这些 ID\n进一步 dump map 自身或相关信息\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外，bpftool 可以 dump 出运行中程序的 BPF 指令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog dump xlated \u003cspan class=\"nb\"\u003eid \u003c/span\u003e406\n 0: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r7 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n 1: \u003cspan class=\"o\"\u003e(\u003c/span\u003e63\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er1 +60\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r7\n 2: \u003cspan class=\"o\"\u003e(\u003c/span\u003e63\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er1 +56\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r7\n 3: \u003cspan class=\"o\"\u003e(\u003c/span\u003e63\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu32 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er1 +52\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r7\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n47: \u003cspan class=\"o\"\u003e(\u003c/span\u003ebf\u003cspan class=\"o\"\u003e)\u003c/span\u003e r4 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r10\n48: \u003cspan class=\"o\"\u003e(\u003c/span\u003e07\u003cspan class=\"o\"\u003e)\u003c/span\u003e r4 +\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nt\"\u003e-40\u003c/span\u003e\n49: \u003cspan class=\"o\"\u003e(\u003c/span\u003e79\u003cspan class=\"o\"\u003e)\u003c/span\u003e r6 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 \u003cspan class=\"nt\"\u003e-104\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n50: \u003cspan class=\"o\"\u003e(\u003c/span\u003ebf\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r6\n51: \u003cspan class=\"o\"\u003e(\u003c/span\u003e18\u003cspan class=\"o\"\u003e)\u003c/span\u003e r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e map[id:18]                    \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e BPF map \u003cspan class=\"nb\"\u003eid \u003c/span\u003e18\n53: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r5 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 32\n54: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call bpf_skb_event_output#5656112  \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e BPF helper call\n55: \u003cspan class=\"o\"\u003e(\u003c/span\u003e69\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu16 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er6 +192\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如上面的输出所示，bpftool 将指令流中的 BPF map ID、BPF 辅助函数或其他 BPF 程序都\n做了关联。\u003c/p\u003e\n\n\u003cp\u003e和内核的 BPF 校验器一样，bpftool dump 指令流时复用了同一个使输出更美观的打印程序\n（pretty-printer）。\u003c/p\u003e\n\n\u003cp\u003e由于程序被 JIT，因此真正执行的是生成的 JIT 镜像（从上面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exlated\u003c/code\u003e 中的指令生成的\n），这些指令也可以通过 bpftool 查看：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ bpftool prog dump jited id 406\n 0:        push   %rbp\n 1:        mov    %rsp,%rbp\n 4:        sub    $0x228,%rsp\n b:        sub    $0x28,%rbp\n f:        mov    %rbx,0x0(%rbp)\n13:        mov    %r13,0x8(%rbp)\n17:        mov    %r14,0x10(%rbp)\n1b:        mov    %r15,0x18(%rbp)\n1f:        xor    %eax,%eax\n21:        mov    %rax,0x20(%rbp)\n25:        mov    0x80(%rdi),%r9d\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e另外，还可以指定在输出中将反汇编之后的指令关联到 opcodes，这个功能主要对 BPF JIT\n开发者比较有用：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ bpftool prog dump jited id 406 opcodes\n 0:        push   %rbp\n           55\n 1:        mov    %rsp,%rbp\n           48 89 e5\n 4:        sub    $0x228,%rsp\n           48 81 ec 28 02 00 00\n b:        sub    $0x28,%rbp\n           48 83 ed 28\n f:        mov    %rbx,0x0(%rbp)\n           48 89 5d 00\n13:        mov    %r13,0x8(%rbp)\n           4c 89 6d 08\n17:        mov    %r14,0x10(%rbp)\n           4c 89 75 10\n1b:        mov    %r15,0x18(%rbp)\n           4c 89 7d 18\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e同样，也可以将常规的 BPF 指令关联到 opcodes，有时在内核中进行调试时会比较有用：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ bpftool prog dump xlated id 406 opcodes\n 0: (b7) r7 = 0\n    b7 07 00 00 00 00 00 00\n 1: (63) *(u32 *)(r1 +60) = r7\n    63 71 3c 00 00 00 00 00\n 2: (63) *(u32 *)(r1 +56) = r7\n    63 71 38 00 00 00 00 00\n 3: (63) *(u32 *)(r1 +52) = r7\n    63 71 34 00 00 00 00 00\n 4: (63) *(u32 *)(r1 +48) = r7\n    63 71 30 00 00 00 00 00\n 5: (63) *(u32 *)(r1 +64) = r7\n    63 71 40 00 00 00 00 00\n [...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e此外，还可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egraphviz\u003c/code\u003e 以可视化的方式展示程序的基本组成部分。bpftool 提供了一\n个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evisual\u003c/code\u003e dump 模式，这种模式下输出的不是 BPF \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exlated\u003c/code\u003e 指令文本，而是一张点图（\ndot graph），后者可以转换成 png 格式的图片：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ bpftool prog dump xlated id 406 visual \u0026amp;\u0026gt; output.dot\n\n$ dot -Tpng output.dot -o output.png\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e也可以用 dotty 打开生成的点图文件：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edotty output.dot\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_host.o\u003c/code\u003e 程序的效果如\n下图所示（一部分）：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-bpf-xdp-guide/bpf_dot.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e注意，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exlated\u003c/code\u003e 中 dump 出来的指令是经过校验器之后（post-verifier）的 BPF 指令镜\n像，即和 BPF 解释器中执行的版本是一样的。\u003c/p\u003e\n\n\u003cp\u003e在内核中，校验器会对 BPF 加载器提供的原始指令执行各种重新（rewrite）。一个例子就\n是对辅助函数进行内联化（inlining）以提高运行时性能，下面是对一个哈希表查找的优化：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ bpftool prog dump xlated id 3\n 0: (b7) r1 = 2\n 1: (63) *(u32 *)(r10 -4) = r1\n 2: (bf) r2 = r10\n 3: (07) r2 += -4\n 4: (18) r1 = map[id:2]                      \u0026lt;-- BPF map id 2\n 6: (85) call __htab_map_lookup_elem#77408   \u0026lt;-+ BPF helper inlined rewrite\n 7: (15) if r0 == 0x0 goto pc+2                |\n 8: (07) r0 += 56                              |\n 9: (79) r0 = *(u64 *)(r0 +0)                \u0026lt;-+\n10: (15) if r0 == 0x0 goto pc+24\n11: (bf) r2 = r10\n12: (07) r2 += -4\n[...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ebpftool 通过 kallsyms 来对辅助函数或 BPF-to-BPF 调用进行关联。因此，确保 JIT 之\n后的 BPF 程序暴露到了 kallsyms（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_kallsyms\u003c/code\u003e），并且 kallsyms 地址是明确的\n（否则调用显示的就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall bpf_unspec#0\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ echo 0 \u0026gt; /proc/sys/kernel/kptr_restrict\n$ echo 1 \u0026gt; /proc/sys/net/core/bpf_jit_kallsyms\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBPF-to-BPF 调用在解释器和 JIT 镜像中也做了关联。对于后者，子程序的 tag 会显示为\n调用目标（call target）。在两种情况下，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epc+2\u003c/code\u003e 都是调用目标的程序计数器偏移（\npc-relative offset），表示就是子程序的地址。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog dump xlated \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1\n0: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call pc+2#__bpf_prog_run_args32\n1: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n2: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\n\u003c/span\u003e3: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2\n4: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对应的 JIT 版本：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog dump xlated \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1\n0: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call pc+2#bpf_prog_3b185187f1855c4c_F\n1: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 1\n2: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\n\u003c/span\u003e3: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2\n4: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在尾调用中，内核会将它们映射为同一个指令，但 bpftool 还是会将它们作为辅助函数进\n行关联，以方便调试：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog dump xlated \u003cspan class=\"nb\"\u003eid \u003c/span\u003e2\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n10: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 8\n11: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call bpf_trace_printk#-41312\n12: \u003cspan class=\"o\"\u003e(\u003c/span\u003ebf\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r6\n13: \u003cspan class=\"o\"\u003e(\u003c/span\u003e18\u003cspan class=\"o\"\u003e)\u003c/span\u003e r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e map[id:1]\n15: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r3 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n16: \u003cspan class=\"o\"\u003e(\u003c/span\u003e85\u003cspan class=\"o\"\u003e)\u003c/span\u003e call bpf_tail_call#12\n17: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 42\n18: \u003cspan class=\"o\"\u003e(\u003c/span\u003e6b\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu16 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er6 +46\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n19: \u003cspan class=\"o\"\u003e(\u003c/span\u003eb7\u003cspan class=\"o\"\u003e)\u003c/span\u003e r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n20: \u003cspan class=\"o\"\u003e(\u003c/span\u003e95\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool map show \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1\n1: prog_array  flags 0x0\n      key 4B  value 4B  max_entries 1  memlock 4096B\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap dump\u003c/code\u003e 子命令可以 dump 整个 map，它会遍历所有的 map 元素，输出 key/value。\u003c/p\u003e\n\n\u003cp\u003e如果 map 中没有可用的 BTF 数据，那 key/value 会以十六进制格式输出：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool map dump \u003cspan class=\"nb\"\u003eid \u003c/span\u003e5\nkey:\nf0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6\n02 00 00 00\nvalue:\n00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\nkey:\n0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00\n01 00 00 00\nvalue:\n00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00\n00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\nFound 6 elements\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果有 BTF 数据，map 就有了关于 key/value 结构体的调试信息。例如，BTF 信息加上 BPF\nmap 以及 iproute2 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ANNOTATE_KV_PAIR()\u003c/code\u003e 会产生下面的输出（内核 selftests\n中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest_xdp_noinline.o\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003etools/testing/selftests/bpf/test_xdp_noinline.c\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n   struct ctl_value \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n         union \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n                 __u64 value\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                 __u32 ifindex\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                 __u8 mac[6]\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n         \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n   \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n   struct bpf_map_def __attribute__ \u003cspan class=\"o\"\u003e((\u003c/span\u003esection\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;maps\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e, used\u003cspan class=\"o\"\u003e))\u003c/span\u003e ctl_array \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n          .type\t\t\u003cspan class=\"o\"\u003e=\u003c/span\u003e BPF_MAP_TYPE_ARRAY,\n          .key_size\t\u003cspan class=\"o\"\u003e=\u003c/span\u003e sizeof\u003cspan class=\"o\"\u003e(\u003c/span\u003e__u32\u003cspan class=\"o\"\u003e)\u003c/span\u003e,\n          .value_size\t\u003cspan class=\"o\"\u003e=\u003c/span\u003e sizeof\u003cspan class=\"o\"\u003e(\u003c/span\u003estruct ctl_value\u003cspan class=\"o\"\u003e)\u003c/span\u003e,\n          .max_entries\t\u003cspan class=\"o\"\u003e=\u003c/span\u003e 16,\n          .map_flags\t\u003cspan class=\"o\"\u003e=\u003c/span\u003e 0,\n   \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n   BPF_ANNOTATE_KV_PAIR\u003cspan class=\"o\"\u003e(\u003c/span\u003ectl_array, __u32, struct ctl_value\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n   \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ANNOTATE_KV_PAIR()\u003c/code\u003e 宏强制每个 map-specific ELF section 包含一个空的\nkey/value，这样 iproute2 BPF 加载器可以将 BTF 数据关联到这个 section，因此在加载\nmap 时可用从 BTF 中选择响应的类型。\u003c/p\u003e\n\n\u003cp\u003e使用 LLVM 编译，并使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epahole\u003c/code\u003e 基于调试信息产生 BTF：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"o\"\u003e[\u003c/span\u003e...] \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-g\u003c/span\u003e \u003cspan class=\"nt\"\u003e-emit-llvm\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e test_xdp_noinline.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e - |\n  llc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebpf \u003cspan class=\"nt\"\u003e-mcpu\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eprobe \u003cspan class=\"nt\"\u003e-mattr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003edwarfris \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e test_xdp_noinline.o\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003epahole \u003cspan class=\"nt\"\u003e-J\u003c/span\u003e test_xdp_noinline.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e加载到内核，然后使用 bpftool dump 这个 map：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nt\"\u003e-force\u003c/span\u003e \u003cspan class=\"nb\"\u003elink set \u003c/span\u003edev lo xdp obj test_xdp_noinline.o sec xdp-test\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip a\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 xdpgeneric/id:227 qdisc noqueue state UNKNOWN group default qlen 1000\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host\n       valid_lft forever preferred_lft forever\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog show \u003cspan class=\"nb\"\u003eid \u003c/span\u003e227\n227: xdp  tag a85e060c275c5616  gpl\n    loaded_at 2018-07-17T14:41:29+0000  uid 0\n    xlated 8152B  not jited  memlock 12288B  map_ids 381,385,386,382,384,383\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool map dump \u003cspan class=\"nb\"\u003eid \u003c/span\u003e386\n \u003cspan class=\"o\"\u003e[{\u003c/span\u003e\n      \u003cspan class=\"s2\"\u003e\u0026#34;key\u0026#34;\u003c/span\u003e: 0,\n      \u003cspan class=\"s2\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n              \u003cspan class=\"s2\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e: 0,\n              \u003cspan class=\"s2\"\u003e\u0026#34;ifindex\u0026#34;\u003c/span\u003e: 0,\n              \u003cspan class=\"s2\"\u003e\u0026#34;mac\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e[]\u003c/span\u003e\n          \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"s2\"\u003e\u0026#34;key\u0026#34;\u003c/span\u003e: 1,\n      \u003cspan class=\"s2\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n          \u003cspan class=\"s2\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n              \u003cspan class=\"s2\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e: 0,\n              \u003cspan class=\"s2\"\u003e\u0026#34;ifindex\u0026#34;\u003c/span\u003e: 0,\n              \u003cspan class=\"s2\"\u003e\u0026#34;mac\u0026#34;\u003c/span\u003e: \u003cspan class=\"o\"\u003e[]\u003c/span\u003e\n          \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e针对 map 的某个 key，也可用通过 bpftool 查看、更新、删除和获取下一个 key（’get\nnext key’）。\u003c/p\u003e\n\n\u003cp\u003e如果带 BTF 调试信息的 BPF 程序已经成功加载，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog show\u003c/code\u003e 命令的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebtf_id\u003c/code\u003e 字段显示\n的就是 \u003cstrong\u003e\u003cmark\u003eBTF ID\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool prog show \u003cspan class=\"nb\"\u003eid \u003c/span\u003e72\n72: xdp  name balancer_ingres  tag acf44cabb48385ed  gpl\n   loaded_at 2020-04-13T23:12:08+0900  uid 0\n   xlated 19104B  jited 10732B  memlock 20480B  map_ids 126,130,131,127,129,128\n   btf_id 60\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e此外，还可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebtf show\u003c/code\u003e 命令来 \u003cstrong\u003e\u003cmark\u003edump 系统中已经加载的所有 BTF 对象\n\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# bpftool btf show\u003c/span\u003e\n60: size 12243B  prog_ids 72  map_ids 126,130,131,127,129,128\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e还可以用子命令 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebtf dump\u003c/code\u003e 来检查 BTF 中携带了哪些 debug 信息。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eformat\u003c/code\u003e 类型可以\n是 ‘raw’ 或 ‘c’：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ebpftool btf dump \u003cspan class=\"nb\"\u003eid \u003c/span\u003e60 format c\n  \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n   struct ctl_value \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n         union \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n                 __u64 value\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                 __u32 ifindex\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                 __u8 mac[6]\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n         \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n   \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n   typedef unsigned int u32\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n   \u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"tool_bpf_sysctls\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"25-bpf-sysctls\"\u003e2.5 BPF sysctls\u003c/h2\u003e\n\n\u003cp\u003eLinux 内核提供了一些 BPF 相关的 sysctl 配置。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/net/core/bpf_jit_enable\u003c/code\u003e：启用或禁用 BPF JIT 编译器。\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  +-------+-------------------------------------------------------------------+\n  | Value | Description                                                       |\n  +-------+-------------------------------------------------------------------+\n  | 0     | Disable the JIT and use only interpreter (kernel\u0026#39;s default value) |\n  +-------+-------------------------------------------------------------------+\n  | 1     | Enable the JIT compiler                                           |\n  +-------+-------------------------------------------------------------------+\n  | 2     | Enable the JIT and emit debugging traces to the kernel log        |\n  +-------+-------------------------------------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e后面会介绍到，当 JIT 编译设置为调试模式（option \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2\u003c/code\u003e）时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_disasm\u003c/code\u003e\n  工具能够处理调试跟踪信息（debugging traces）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/net/core/bpf_jit_harden\u003c/code\u003e：启用会禁用 BPF JIT 加固。\u003c/p\u003e\n\n    \u003cp\u003e注意，启用加固会降低性能，但能够降低 \u003cstrong\u003e\u003cmark\u003eJIT spraying（喷射）攻击\u003c/mark\u003e\u003c/strong\u003e，因为它会禁止\n  （blind）BPF 程序使用立即值（immediate values）。对于通过解释器处理的程序，\n  禁用（blind）立即值是没有必要的（也是没有去做的）。\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  +-------+-------------------------------------------------------------------+\n  | Value | Description                                                       |\n  +-------+-------------------------------------------------------------------+\n  | 0     | Disable JIT hardening (kernel\u0026#39;s default value)                    |\n  +-------+-------------------------------------------------------------------+\n  | 1     | Enable JIT hardening for unprivileged users only                  |\n  +-------+-------------------------------------------------------------------+\n  | 2     | Enable JIT hardening for all users                                |\n  +-------+-------------------------------------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/net/core/bpf_jit_kallsyms\u003c/code\u003e：是否允许 \u003cstrong\u003e\u003cmark\u003eJIT 后的程序作为内核符号暴露到\u003c/mark\u003e\u003c/strong\u003e\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/kallsyms\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e启用后，这些符号可以被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e 这样的工具识别，使内核在做 stack unwinding 时\n  能感知到这些地址，例如，在 dump stack trace 的时候，符合名中会包含 BPF 程序\n  tag（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_\u0026lt;tag\u0026gt;\u003c/code\u003e）。如果启用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_harden\u003c/code\u003e，这个特性就会自动被禁用\n  。\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  +-------+-------------------------------------------------------------------+\n  | Value | Description                                                       |\n  +-------+-------------------------------------------------------------------+\n  | 0     | Disable JIT kallsyms export (kernel\u0026#39;s default value)              |\n  +-------+-------------------------------------------------------------------+\n  | 1     | Enable JIT kallsyms export for privileged users only              |\n  +-------+-------------------------------------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/kernel/unprivileged_bpf_disabled\u003c/code\u003e：\u003cstrong\u003e\u003cmark\u003e是否允许非特权用户使用\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用。\u003c/p\u003e\n\n    \u003cp\u003e内核默认允许非特权用户使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用，但一旦将这个开关关闭，必须重启\n  内核才能再次将其打开。因此这是一个一次性开关（one-time switch），一旦关闭，\n  不管是应用还是管理员都无法再次修改。这个开关不影响 \u003cstrong\u003ecBPF 程序\u003c/strong\u003e（例如 seccomp）\n  或 \u003cstrong\u003e传统的没有使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用的 socket 过滤器\u003c/strong\u003e 加载程序到内核。\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  +-------+-------------------------------------------------------------------+\n  | Value | Description                                                       |\n  +-------+-------------------------------------------------------------------+\n  | 0     | Unprivileged use of bpf syscall enabled (kernel\u0026#39;s default value)  |\n  +-------+-------------------------------------------------------------------+\n  | 1     | Unprivileged use of bpf syscall disabled                          |\n  +-------+-------------------------------------------------------------------+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"tool_kernel_testing\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"26-内核测试\"\u003e2.6 内核测试\u003c/h2\u003e\n\n\u003cp\u003eLinux 内核自带了一个 selftest 套件，在内核源码树中的路径是\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/testing/selftests/bpf/\u003c/code\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd \u003c/span\u003etools/testing/selftests/bpf/\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emake\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emake run_tests\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e测试用例包括：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBPF 校验器、程序 tags、BPF map 接口和 map 类型的很多测试用例\u003c/li\u003e\n  \u003cli\u003e用于 LLVM 后端的运行时测试，用 C 代码实现\u003c/li\u003e\n  \u003cli\u003e用于解释器和 JIT 的测试，运行在内核，用 eBPF 和 cBPF 汇编实现\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"tool_jit_debug\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"27-jit-debugging\"\u003e2.7 JIT Debugging\u003c/h2\u003e\n\n\u003cp\u003eFor JIT developers performing audits or writing extensions, each compile run\ncan output the generated JIT image into the kernel log through:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e2 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_enable\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWhenever a new BPF program is loaded, the JIT compiler will dump the output,\nwhich can then be inspected with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edmesg\u003c/code\u003e, for example:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935842] \u003cspan class=\"nv\"\u003eflen\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e6 \u003cspan class=\"nv\"\u003eproglen\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e70 \u003cspan class=\"nv\"\u003epass\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e3 \u003cspan class=\"nv\"\u003eimage\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003effffffffa0069c8f \u003cspan class=\"nv\"\u003efrom\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003etcpdump \u003cspan class=\"nv\"\u003epid\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e20583\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflen\u003c/code\u003e is the length of the BPF program (here, 6 BPF instructions), and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eproglen\u003c/code\u003e\ntells the number of bytes generated by the JIT for the opcode image (here, 70 bytes\nin size). \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epass\u003c/code\u003e means that the image was generated in 3 compiler passes, for\nexample, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e can have various optimization passes to further reduce the image\nsize when possible. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimage\u003c/code\u003e contains the address of the generated JIT image, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom\u003c/code\u003e\nand \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epid\u003c/code\u003e the user space application name and PID respectively, which triggered the\ncompilation process. The dump output for eBPF and cBPF JITs is the same format.\u003c/p\u003e\n\n\u003cp\u003eIn the kernel tree under \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/\u003c/code\u003e, there is a tool called \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_disasm\u003c/code\u003e. It\nreads out the latest dump and prints the disassembly for further inspection:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_jit_disasm\n70 bytes emitted from JIT compiler \u003cspan class=\"o\"\u003e(\u003c/span\u003epass:3, flen:6\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nffffffffa0069c8f + \u0026lt;x\u0026gt;:\n   0:       push   %rbp\n   1:       mov    %rsp,%rbp\n   4:       sub    \u003cspan class=\"nv\"\u003e$0x60\u003c/span\u003e,%rsp\n   8:       mov    %rbx,-0x8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rbp\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   c:       mov    0x68\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n  10:       sub    0x6c\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n  14:       mov    0xd8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r8\n  1b:       mov    \u003cspan class=\"nv\"\u003e$0xc\u003c/span\u003e,%esi\n  20:       callq  0xffffffffe0ff9442\n  25:       cmp    \u003cspan class=\"nv\"\u003e$0x800\u003c/span\u003e,%eax\n  2a:       jne    0x0000000000000042\n  2c:       mov    \u003cspan class=\"nv\"\u003e$0x17\u003c/span\u003e,%esi\n  31:       callq  0xffffffffe0ff945e\n  36:       cmp    \u003cspan class=\"nv\"\u003e$0x1\u003c/span\u003e,%eax\n  39:       jne    0x0000000000000042\n  3b:       mov    \u003cspan class=\"nv\"\u003e$0xffff\u003c/span\u003e,%eax\n  40:       jmp    0x0000000000000044\n  42:       xor    %eax,%eax\n  44:       leaveq\n  45:       retq\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAlternatively, the tool can also dump related opcodes along with the disassembly.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_jit_disasm \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e\n70 bytes emitted from JIT compiler \u003cspan class=\"o\"\u003e(\u003c/span\u003epass:3, flen:6\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nffffffffa0069c8f + \u0026lt;x\u0026gt;:\n   0:       push   %rbp\n    55\n   1:       mov    %rsp,%rbp\n    48 89 e5\n   4:       sub    \u003cspan class=\"nv\"\u003e$0x60\u003c/span\u003e,%rsp\n    48 83 ec 60\n   8:       mov    %rbx,-0x8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rbp\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n    48 89 5d f8\n   c:       mov    0x68\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n    44 8b 4f 68\n  10:       sub    0x6c\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n    44 2b 4f 6c\n  14:       mov    0xd8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r8\n    4c 8b 87 d8 00 00 00\n  1b:       mov    \u003cspan class=\"nv\"\u003e$0xc\u003c/span\u003e,%esi\n    be 0c 00 00 00\n  20:       callq  0xffffffffe0ff9442\n    e8 1d 94 ff e0\n  25:       cmp    \u003cspan class=\"nv\"\u003e$0x800\u003c/span\u003e,%eax\n    3d 00 08 00 00\n  2a:       jne    0x0000000000000042\n    75 16\n  2c:       mov    \u003cspan class=\"nv\"\u003e$0x17\u003c/span\u003e,%esi\n    be 17 00 00 00\n  31:       callq  0xffffffffe0ff945e\n    e8 28 94 ff e0\n  36:       cmp    \u003cspan class=\"nv\"\u003e$0x1\u003c/span\u003e,%eax\n    83 f8 01\n  39:       jne    0x0000000000000042\n    75 07\n  3b:       mov    \u003cspan class=\"nv\"\u003e$0xffff\u003c/span\u003e,%eax\n    b8 ff ff 00 00\n  40:       jmp    0x0000000000000044\n    eb 02\n  42:       xor    %eax,%eax\n    31 c0\n  44:       leaveq\n    c9\n  45:       retq\n    c3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMore recently, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpftool\u003c/code\u003e adapted the same feature of dumping the BPF JIT\nimage based on a given BPF program ID already loaded in the system (see\nbpftool section).\u003c/p\u003e\n\n\u003cp\u003eFor performance analysis of JITed BPF programs, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e can be used as\nusual. As a prerequisite, JITed programs need to be exported through kallsyms\ninfrastructure.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_enable\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_kallsyms\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eEnabling or disabling \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_kallsyms\u003c/code\u003e does not require a reload of the\nrelated BPF programs. Next, a small workflow example is provided for profiling\nBPF programs. A crafted tc BPF program is used for demonstration purposes,\nwhere perf records a failed allocation inside \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_clone_redirect()\u003c/code\u003e helper.\nDue to the use of direct write, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_try_make_head_writable()\u003c/code\u003e failed, which\nwould then release the cloned \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e again and return with an error message.\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e thus records all \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekfree_skb\u003c/code\u003e events.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev em1 clsact\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress bpf da obj prog.o sec main\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 ingress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle 0x1 prog.o:[main] direct-action \u003cspan class=\"nb\"\u003eid \u003c/span\u003e1 tag 8227addf251b7543\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/kallsyms\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\nffffffffc00349e0 t fjes_hw_init_command_registers    \u003cspan class=\"o\"\u003e[\u003c/span\u003efjes]\nffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    \u003cspan class=\"o\"\u003e[\u003c/span\u003efjes]\nffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    \u003cspan class=\"o\"\u003e[\u003c/span\u003efjes]\nffffffffc004b000 t bpf_prog_8227addf251b7543\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eperf record \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e \u003cspan class=\"nt\"\u003e-g\u003c/span\u003e \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e skb:kfree_skb \u003cspan class=\"nb\"\u003esleep \u003c/span\u003e60\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eperf script \u003cspan class=\"nt\"\u003e--kallsyms\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/proc/kallsyms\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\nksoftirqd/0     6 \u003cspan class=\"o\"\u003e[\u003c/span\u003e000]  1004.578402:    skb:kfree_skb: \u003cspan class=\"nv\"\u003eskbaddr\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0xffff9d4161f20a00 \u003cspan class=\"nv\"\u003eprotocol\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e2048 \u003cspan class=\"nv\"\u003elocation\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0xffffffffc004b52c\n   7fffb8745961 bpf_clone_redirect \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffc004e52c bpf_prog_8227addf251b7543 \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffc05b6283 cls_bpf_classify \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb875957a tc_classify \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb8729840 __netif_receive_skb_core \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb8729e38 __netif_receive_skb \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb872ae05 process_backlog \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb872a43e net_rx_action \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb886176c __do_softirq \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb80ac5b9 run_ksoftirqd \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb80ca7fa smpboot_thread_fn \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb80c6831 kthread \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n   7fffb885e09c ret_from_fork \u003cspan class=\"o\"\u003e(\u003c/span\u003e/lib/modules/4.10.0+/build/vmlinux\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThe stack trace recorded by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e will then show the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_8227addf251b7543()\u003c/code\u003e\nsymbol as part of the call trace, meaning that the BPF program with the\ntag \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e8227addf251b7543\u003c/code\u003e was related to the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekfree_skb\u003c/code\u003e event, and\nsuch program was attached to netdevice \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eem1\u003c/code\u003e on the ingress hook as\nshown by tc.\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"tool_introspection\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"28-内省introspection\"\u003e2.8 内省（Introspection）\u003c/h2\u003e\n\n\u003cp\u003eLinux 内核围绕 BPF 和 XDP 提供了多种 tracepoints，这些 tracepoints 可以用于进一\n步查看系统内部行为，例如，跟踪用户空间程序和 bpf 系统调用的交互。\u003c/p\u003e\n\n\u003cp\u003eBPF 相关的 tracepoints：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eperf list | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ebpf:\nbpf:bpf_map_create                                 \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_map_delete_elem                            \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_map_lookup_elem                            \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_map_next_key                               \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_map_update_elem                            \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_obj_get_map                                \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_obj_get_prog                               \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_obj_pin_map                                \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_obj_pin_prog                               \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_prog_get_type                              \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_prog_load                                  \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\nbpf:bpf_prog_put_rcu                               \u003cspan class=\"o\"\u003e[\u003c/span\u003eTracepoint event]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e跟踪 BPF 系统调用\u003c/mark\u003e\u003c/strong\u003e（这里用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esleep\u003c/code\u003e 只是展示用法，实际场景中应该执行 tc 等命令）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ perf record -a -e bpf:* sleep 10\n$ perf script\nsock_example  6197 [005]   283.980322: bpf:bpf_map_create: map type=ARRAY ufd=4 key=4 val=8 max=256 flags=0\nsock_example  6197 [005]   283.980721: bpf:bpf_prog_load: prog=a5ea8fa30ea6849c type=SOCKET_FILTER ufd=5\nsock_example  6197 [005]   283.988423: bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c type=SOCKET_FILTER\nsock_example  6197 [005]   283.988443: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=4 key=[06 00 00 00] val=[00 00 00 00 00 00 00 00]\n[...]\nsock_example  6197 [005]   288.990868: bpf:bpf_map_lookup_elem: map type=ARRAY ufd=4 key=[01 00 00 00] val=[14 00 00 00 00 00 00 00]\n     swapper     0 [005]   289.338243: bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c type=SOCKET_FILTER\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对于 BPF 程序，以上命令会打印出每个程序的 tag。\u003c/p\u003e\n\n\u003cp\u003e对于调试，XDP 还有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp:xdp_exception\u003c/code\u003e tracepoint，在抛异常的时候触发：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ perf list | grep xdp:\nxdp:xdp_exception                                  [Tracepoint event]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e异常在下面情况下会触发：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBPF 程序返回一个非法/未知的 XDP action code.\u003c/li\u003e\n  \u003cli\u003eBPF 程序返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_ABORTED\u003c/code\u003e，这表示非优雅的退出（non-graceful exit）\u003c/li\u003e\n  \u003cli\u003eBPF 程序返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e，但发送时发生错误，例如，由于端口没有启用、发送缓冲区已\n满、分配内存失败等等\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这两类 tracepoint 也都可以通过 attach BPF 程序，用这个 BPF 程序本身来收集进一步\n信息，将结果放到一个 BPF map 或以事件的方式发送到用户空间收集器，例如利用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_perf_event_output()\u003c/code\u003e 辅助函数。\u003c/p\u003e\n\n\u003ch2 id=\"29-tracing-pipe\"\u003e2.9 Tracing pipe\u003c/h2\u003e\n\n\u003cp\u003e在 BPF 程序中执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e，输出会打到内核的跟踪管道（tracing pipe）。\n用户可以在用户态读取这些输出：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ tail -f /sys/kernel/debug/tracing/trace_pipe\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ca name=\"tool_misc\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"210-其他miscellaneous\"\u003e2.10 其他（Miscellaneous）\u003c/h2\u003e\n\n\u003cp\u003e和 perf 类似，\u003cstrong\u003e\u003cmark\u003eBPF 程序和 BPF map 占用的内存是受 RLIMIT_MEMLOCK 限制的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eulimit -l\u003c/code\u003e 可以查看当前能锁定的内存大小，单位是页面（system pages）。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetrlimit()\u003c/code\u003e 系统调用的 man page 提供了更多细节。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这个限制通常导致\u003cstrong\u003e\u003cmark\u003e无法加载复杂的 BPF 程序或很大的 BPF map\u003c/mark\u003e\u003c/strong\u003e，此时 BPF 系统调用会返回\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEPERM\u003c/code\u003e 错误。这种情况需要将限制调大，或者用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eulimit -l unlimited\u003c/code\u003e 来临时解决。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRLIMIT_MEMLOCK\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e主要是针对非特权用户施加限制\u003c/mark\u003e\u003c/strong\u003e；对于特权用户，\n根据实际场景，设置一个较高的阈值通常是可以接受的。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"prog_type\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch1 id=\"3-程序类型\"\u003e3 程序类型\u003c/h1\u003e\n\n\u003cp\u003e写作本文时，一共有 \u003cstrong\u003e18 种\u003c/strong\u003e不同的 BPF 程序类型，本节接下来进一步介绍其中两种和\n网络相关的类型，即 XDP BPF 程序和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e BPF 程序。这两种类型的程序在 LLVM、\niproute2 和其他工具中使用的例子已经在前一节“工具链”中介绍过了。本节将关注其架\n构、概念和使用案例。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"prog_type_xdp\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"31-xdp\"\u003e3.1 XDP\u003c/h2\u003e\n\n\u003cp\u003eXDP（eXpress Data Path）提供了一个\u003cstrong\u003e内核态、高性能、可编程 BPF 包处理框架\u003c/strong\u003e（a\nframework for BPF that enables high-performance programmable packet processing\nin the Linux kernel）。这个框架在软件中最早可以处理包的位置（即网卡驱动收到包的\n时刻）运行 BPF 程序。\u003c/p\u003e\n\n\u003cp\u003eXDP hook 位于网络驱动的快速路径上，XDP 程序直接从接收缓冲区（receive ring）中将\n包拿下来，无需执行任何耗时的操作，例如分配 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 然后将包推送到网络协议栈，或者\n将包推送给 GRO 引擎等等。因此，只要有 CPU 资源，XDP BPF 程序就能够在最早的位置执\n行处理。\u003c/p\u003e\n\n\u003cp\u003eXDP 和 Linux 内核及其基础设施协同工作，这意味着 \u003cstrong\u003eXDP 并不会绕过（bypass）内核\u003c/strong\u003e\n；作为对比，很多完全运行在用户空间的网络框架（例如 DPDK）是绕过内核的。将包留在\n内核空间可以带来几方面重要好处：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eXDP 可以\u003cstrong\u003e复用所有上游开发的内核网络驱动、用户空间工具，以及其他一些可用的内核\n基础设施\u003c/strong\u003e，例如 BPF 辅助函数在调用自身时可以使用系统路由表、socket 等等。\u003c/li\u003e\n  \u003cli\u003e因为驻留在内核空间，因此 XDP 在\u003cstrong\u003e访问硬件时与内核其他部分有相同的安全模型\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e无需跨内核/用户空间边界\u003c/strong\u003e，因为正在被处理的包已经在内核中，因此可以灵活地将\n其转发到内核内的其他实体，例如容器的命名空间或内核网络栈自身。Meltdown 和\nSpectre 漏洞尤其与此相关（\u003cstrong\u003eSpectre 论文中一个例子就是用 ebpf 实现的\u003c/strong\u003e，译者注\n）。\u003c/li\u003e\n  \u003cli\u003e将包从 XDP 送到内核中非常简单，可以\u003cstrong\u003e复用内核\u003c/strong\u003e中这个健壮、高效、使用广泛的\nTCP/IP \u003cstrong\u003e协议栈\u003c/strong\u003e，而不是像一些用户态框架一样需要自己维护一个独立的 TCP/IP 协\n议栈。\u003c/li\u003e\n  \u003cli\u003e基于 BPF 可以\u003cstrong\u003e实现内核的完全可编程\u003c/strong\u003e，保持 ABI 的稳定，保持内核的系统调用 ABI\n“永远不会破坏用户空间的兼容性”（never-break-user-space）的保证。而且，\u003cstrong\u003e与内核\n模块（modules）方式相比，它还更加安全\u003c/strong\u003e，这来源于 BPF 校验器，它能保证内核操作\n的稳定性。\u003c/li\u003e\n  \u003cli\u003eXDP 轻松地\u003cstrong\u003e支持在运行时（runtime）原子地创建（spawn）新程序，而不会导致任何网\n络流量中断\u003c/strong\u003e，甚至不需要重启内核/系统。\u003c/li\u003e\n  \u003cli\u003eXDP 允许对负载进行灵活的结构化（structuring of workloads），然后集成到内核。例\n如，它可以工作在\u003cstrong\u003e“不停轮询”（busy polling）或“中断驱动”（interrupt driven）模\n式\u003c/strong\u003e。不需要显式地将专门 CPU 分配给 XDP。没有特殊的硬件需求，它也不依赖\nhugepage（大页）。\u003c/li\u003e\n  \u003cli\u003eXDP \u003cstrong\u003e不需要任何第三方内核模块或许可\u003c/strong\u003e（licensing）。它是一个长期的架构型解决\n方案（architectural solution），\u003cstrong\u003e是 Linux 内核的一个核心组件，而且是由内核社\n区开发\u003c/strong\u003e的。\u003c/li\u003e\n  \u003cli\u003e主流发行版中，4.8+ 的内核已经内置并启用了 XDP，并\u003cstrong\u003e支持主流的 10G 及更高速网络\n驱动\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e作为一个\u003cstrong\u003e在驱动中运行 BPF 的框架\u003c/strong\u003e，XDP 还保证了\u003cstrong\u003e包是线性放置并且可以匹配到单\n个 DMA 页面\u003c/strong\u003e，这个页面对 BPF 程序来说是可读和可写的。XDP 还提供了额外的 256 字\n节 headroom 给 BPF 程序，后者可以利用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_xdp_adjust_head()\u003c/code\u003e 辅助函数实现自定义\n封装头，或者通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_xdp_adjust_meta()\u003c/code\u003e 在包前面添加自定义元数据。\u003c/p\u003e\n\n\u003cp\u003e下一节会深入介绍 XDP 动作码（action code），BPF 程序会根据返回的动作码来指导驱动\n接下来应该对这个包做什么，而且它还使得我们可以原子地替换运行在 XDP 层的程序。XDP\n在设计上就是定位于高性能场景的。BPF 允许以“直接包访问”（direct packet access）的\n方式访问包中的数据，这意味着\u003cstrong\u003e程序直接将数据的指针放到了寄存器中，然后将内容加载\n到寄存器，相应地再将内容从寄存器写到包中\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e数据包在 XDP 中的表示形式是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e，这也是传递给 BPF 程序的结构体（BPF 上下\n文）：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_buff\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata_meta\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata_hard_start\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_rxq_info\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erxq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata\u003c/code\u003e 指向页面（page）中包数据的起始位置，从名字可以猜出，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_end\u003c/code\u003e 执行包数据\n的结尾位置。XDP 支持 headroom，因此 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_hard_start\u003c/code\u003e 指向页面中最大可能的\nheadroom 开始位置，即，当对包进行封装（加 header）时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata\u003c/code\u003e 会逐渐向\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_hard_start\u003c/code\u003e 靠近，这是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_xdp_adjust_head()\u003c/code\u003e 实现的，该辅助函数还支\n持解封装（去 header）。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_meta\u003c/code\u003e 开始时指向与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata\u003c/code\u003e 相同的位置，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_xdp_adjust_meta()\u003c/code\u003e 能够将其朝着\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_hard_start\u003c/code\u003e 移动，这样可以给自定义元数据提供空间，这个空间对内核网\n络栈是不可见的，但对 tc BPF 程序可见，因为 tc 需要将它从 XDP 转移到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e。\n反之亦然，这个辅助函数也可以将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_meta\u003c/code\u003e 移动到离 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_hard_start\u003c/code\u003e 比较远的位\n置，这样就可以达到删除或缩小这个自定义空间的目的。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_meta\u003c/code\u003e 还可以单纯用于在尾调用时传递状态，和 tc BPF 程序中用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;cb[]\u003c/code\u003e 控\n制块（control block）类似。\u003c/p\u003e\n\n\u003cp\u003e这样，我们就可以得到这样的结论，对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct xdp_buff\u003c/code\u003e 中数据包的指针，有：\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edata_hard_start \u0026lt;= data_meta \u0026lt;= data \u0026lt; data_end\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erxq\u003c/code\u003e 字段指向某些额外的、和每个接收队列相关的元数据：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_rxq_info\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enet_device\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edev\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003equeue_index\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003ereg_state\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"n\"\u003e____cacheline_aligned\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这些元数据是在缓冲区设置时确定的（并不是在 XDP 运行时）。\u003c/p\u003e\n\n\u003cp\u003eBPF 程序可以从 netdevice 自身获取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003equeue_index\u003c/code\u003e 以及其他信息，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifindex\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-程序返回码\"\u003eBPF 程序返回码\u003c/h3\u003e\n\n\u003cp\u003eXDP BPF 程序执行结束后会返回一个判决结果（verdict），告诉驱动接下来如何处理这个\n包。在系统头文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/bpf.h\u003c/code\u003e 中列出了所有的判决类型。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003exdp_action\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eXDP_ABORTED\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eXDP_DROP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eXDP_PASS\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eXDP_TX\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eXDP_REDIRECT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_DROP\u003c/code\u003e 表示立即在驱动层将包丢弃。这样可以节省很多资源，对于 DDoS\nmitigation 或通用目的防火墙程序来说这尤其有用。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_PASS\u003c/code\u003e 表示允许将这个包送到内核网络栈。同时，当前正在处理这个包的 CPU 会\n\u003cstrong\u003e分配一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e\u003c/strong\u003e，做一些初始化，然后将其\u003cstrong\u003e送到 GRO 引擎\u003c/strong\u003e。这是没有 XDP 时默\n认的包处理行为是一样的。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e 是 BPF 程序的一个高效选项，能够在收到包的网卡上直接将包再发送出去。对\n于实现防火墙+负载均衡的程序来说这非常有用，因为这些部署了 BPF 的节点可以作为一\n个 hairpin （发卡模式，从同一个设备进去再出来）模式的负载均衡器集群，将收到的\n包在 XDP BPF 程序中重写（rewrite）之后直接发送回去。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e 类似，但是通过另一个网卡将包发出去。另外，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 还可以将包重定向到一个 BPF cpumap，即，当前执行 XDP 程序的 CPU\n可以将这个包交给某个远端 CPU，由后者将这个包送到更上层的内核栈，当前 CPU 则继\n续在这个网卡执行接收和处理包的任务。这\u003cstrong\u003e和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_PASS\u003c/code\u003e 类似，但当前 CPU 不用去\n做将包送到内核协议栈的准备工作（分配 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e，初始化等等），这部分开销还是很大的\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_ABORTED\u003c/code\u003e 表示程序产生异常，其行为和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_DROP\u003c/code\u003e，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_ABORTED\u003c/code\u003e 会经过\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrace_xdp_exception\u003c/code\u003e tracepoint，因此可以通过 tracing 工具来监控这种非正常行为。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"xdp-使用案例\"\u003eXDP 使用案例\u003c/h3\u003e\n\n\u003cp\u003e本节列出了 XDP 的几种主要使用案例。这里列出的并不全，而且考虑到 XDP 和 BPF 的可\n编程性和效率，人们能容易地将它们适配到其他领域。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eDDoS 防御、防火墙\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eXDP BPF 的一个基本特性就是用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_DROP\u003c/code\u003e 命令驱动将包丢弃，由于这个丢弃的位置\n  非常早，因此这种方式可以实现高效的网络策略，平均到每个包的开销非常小（\n  per-packet cost）。这对于那些需要处理任何形式的 DDoS 攻击的场景来说是非常理\n  想的，而且由于其通用性，使得它能够在 BPF 内实现任何形式的防火墙策略，开销几乎为零，\n  例如，作为 standalone 设备（例如通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e 清洗流量）；或者广泛部署在节点\n  上，保护节点的安全（通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_PASS\u003c/code\u003e 或 cpumap \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 允许“好流量”经\n  过）。\u003c/p\u003e\n\n    \u003cp\u003eOffloaded XDP 更进一步，将本来就已经很小的 per-packet cost 全部下放到网卡以\n  线速（line-rate）进行处理。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e转发和负载均衡\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eXDP 的另一个主要使用场景是包转发和负载均衡，这是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e 或\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 动作实现的。\u003c/p\u003e\n\n    \u003cp\u003eXDP 层运行的 BPF 程序能够任意修改（mangle）数据包，即使是 BPF 辅助函数都能增\n  加或减少包的 headroom，这样就可以在将包再次发送出去之前，对包进行任何的封装/解封装。\u003c/p\u003e\n\n    \u003cp\u003e利用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_TX\u003c/code\u003e 能够实现 hairpinned（发卡）模式的负载均衡器，这种均衡器能够\n  在接收到包的网卡再次将包发送出去，而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 动作能够将包转发到另一个\n  网卡然后发送出去。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_REDIRECT\u003c/code\u003e 返回码还可以和 BPF cpumap 一起使用，对那些目标是本机协议栈、\n  将由 non-XDP 的远端（remote）CPU 处理的包进行负载均衡。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e栈前（Pre-stack）过滤/处理\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e除了策略执行，XDP 还可以用于加固内核的网络栈，这是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eXDP_DROP\u003c/code\u003e 实现的。\n  这意味着，XDP 能够在可能的最早位置丢弃那些与本节点不相关的包，这个过程发生在\n  内核网络栈看到这些包之前。例如假如我们已经知道某台节点只接受 TCP 流量，那任\n  何 UDP、SCTP 或其他四层流量都可以在发现后立即丢弃。\u003c/p\u003e\n\n    \u003cp\u003e这种方式的好处是包不需要再经过各种实体（例如 GRO 引擎、内核的\n  flow dissector 以及其他的模块），就可以判断出是否应该丢弃，因此减少了内核的\n  受攻击面。正是由于 XDP 的早期处理阶段，这有效地对内核网络栈“假装”这些包根本\n  就没被网络设备看到。\u003c/p\u003e\n\n    \u003cp\u003e另外，如果内核接收路径上某个潜在 bug 导致 ping of death 之类的场景，那我们能\n  够利用 XDP 立即丢弃这些包，而不用重启内核或任何服务。而且由于能够原子地替换\n  程序，这种方式甚至都不会导致宿主机的任何流量中断。\u003c/p\u003e\n\n    \u003cp\u003e栈前处理的另一个场景是：在内核分配 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 之前，XDP BPF 程序可以对包进行任意\n  修改，而且对内核“假装”这个包从网络设备收上来之后就是这样的。对于某些自定义包\n  修改（mangling）和封装协议的场景来说比较有用，在这些场景下，包在进入 GRO 聚\n  合之前会被修改和解封装，否则 GRO 将无法识别自定义的协议，进而无法执行任何形\n  式的聚合。\u003c/p\u003e\n\n    \u003cp\u003eXDP 还能够在包的前面 push 元数据（非包内容的数据）。这些元数据对常规的内核栈\n  是不可见的（invisible），但能被 GRO 聚合（匹配元数据），稍后可以和 tc ingress BPF 程\n  序一起处理，tc BPF 中携带了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 的某些上下文，例如，设置了某些 skb 字段。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e流抽样（Flow sampling）和监控\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eXDP 还可以用于包监控、抽样或其他的一些网络分析，例如作为流量路径中间节点\n  的一部分；或运行在终端节点上，和前面提到的场景相结合。对于复杂的包分析，XDP\n  提供了设施来高效地将网络包（截断的或者是完整的 payload）或自定义元数据 push\n  到 perf 提供的一个快速、无锁、per-CPU 内存映射缓冲区，或者是一\n  个用户空间应用。\u003c/p\u003e\n\n    \u003cp\u003e这还可以用于流分析和监控，对每个流的初始数据进行分析，一旦确定是正常流量，这个流随\n  后的流量就会跳过这个监控。感谢 BPF 带来的灵活性，这使得我们可以实现任何形式\n  的自定义监控或采用。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eXDP BPF 在生产环境使用的一个例子是 Facebook 的 SHIV 和 Droplet 基础设施，实现了\n它们的 L4 负载均衡和 DDoS 测量。从基于 netfilter 的 IPV（IP\nVirtual Server）迁移到 XDP BPF 使它们的生产基础设施获得了 10x 的性能提升。这方面\n的工作最早在 netdev 2.1 大会上做了分享：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.netdevconf.info/2.1/slides/apr6/zhou-netdev-xdp-2017.pdf\"\u003e演讲 Slides\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://youtu.be/YEU2ClcGqts\"\u003e演讲视频\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另一个例子是 Cloudflare 将 XDP 集成到它们的 DDoS 防御流水线中，替换了原来基于\ncBPF 加 iptables 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ext_bpf\u003c/code\u003e 模块所做的签名匹配（signature matching）。\n基于 iptables 的版本在发生攻击时有严重的性能问题，因此它们考虑了基于用户态、\nbypass 内核的一个方案，但这种方案也有自己的一些缺点，并且需要不停轮询（busy poll\n）网卡，并且在将某些包重新注入内核协议栈时代价非常高。迁移到 eBPF/XDP 之后，两种\n方案的优点都可以利用到，直接在内核中实现了高性能、可编程的包处理过程：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.netdevconf.info/2.1/slides/apr6/bertin_Netdev-XDP.pdf\"\u003eSlides\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://youtu.be/7OuOukmuivg\"\u003eVideo\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"xdp-工作模式-1\"\u003eXDP 工作模式\u003c/h3\u003e\n\n\u003cp\u003eXDP 有三种工作模式，默认是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enative\u003c/code\u003e（原生）模式，当讨论 XDP 时通常隐含的都是指这\n种模式。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eNative XDP\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e默认模式，在这种模式中，XDP BPF 程序直接运行在网络驱动的早期接收路径上（\n  early receive path）。大部分广泛使用的 10G 及更高速的网卡都已经支持这种模式\n  。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eOffloaded XDP\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e在这种模式中，XDP BPF 程序直接 offload 到网卡，而不是在主机的 CPU 上执行。\n  因此，本来就已经很低的 per-packet 开销完全从主机下放到网卡，能够比运行在\n  native XDP 模式取得更高的性能。这种 offload 通常由智能网卡实现，这些网卡有多\n  线程、多核流处理器（flow processors），一个位于内核中的 JIT 编译器（\n  in-kernel JIT compiler）将 BPF 翻译成网卡的原生指令。\u003c/p\u003e\n\n    \u003cp\u003e支持 offloaded XDP 模式的驱动通常也支持 native XDP 模式，因为 BPF 辅助函数可\n  能目前还只支持后者。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eGeneric XDP\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e对于还没有实现 native 或 offloaded XDP 的驱动，内核提供了一个 generic XDP 选\n  项，这种模式不需要任何驱动改动，因为相应的 XDP 代码运行在网络栈很后面的一个\n  位置（a much later point）。\u003c/p\u003e\n\n    \u003cp\u003e这种设置主要面向的是用内核的 XDP API 来编写和测试程序的开发者，并且无法达到\n  前面两种模式能达到的性能。对于在生产环境使用 XDP，推荐要么选择 native 要么选择\n  offloaded 模式。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"驱动支持\"\u003e驱动支持\u003c/h3\u003e\n\n\u003cp\u003e由于 BPF 和 XDP 的特性和驱动支持还在快速发展和变化，因此这里的列表只统计到了\n4.17 内核支持的 native 和 offloaded XDP 驱动。\u003c/p\u003e\n\n\u003ch4 id=\"支持-native-xdp-的驱动\"\u003e支持 native XDP 的驱动\u003c/h4\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eBroadcom\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003ebnxt\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eCavium\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003ethunderx\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eIntel\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eixgbe\u003c/li\u003e\n      \u003cli\u003eixgbevf\u003c/li\u003e\n      \u003cli\u003ei40e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eMellanox\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003emlx4\u003c/li\u003e\n      \u003cli\u003emlx5\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eNetronome\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003enfp\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eOthers\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003etun\u003c/li\u003e\n      \u003cli\u003evirtio_net\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eQlogic\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eqede\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eSolarflare\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003esfc （XDP for sfc available via out of tree driver as of kernel 4.17, but\n will be upstreamed soon）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"支持-offloaded-xdp-的驱动\"\u003e支持 offloaded XDP 的驱动\u003c/h4\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eNetronome\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003enfp （Some BPF helper functions such as retrieving the current CPU number\nwill not be available in an offloaded setting）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"prog_type_tc\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"32-tc\"\u003e3.2 tc\u003c/h2\u003e\n\n\u003cp\u003e除了 XDP 等类型的程序之外，BPF 还可以用于内核数据路径的 tc (traffic control，流\n量控制)层。\u003c/p\u003e\n\n\u003ch3 id=\"tc-和-xdp-bpf-程序的不同\"\u003etc 和 XDP BPF 程序的不同\u003c/h3\u003e\n\n\u003cp\u003e从高层看，tc BPF 程序和 XDP BPF 程序有三点主要不同：\u003c/p\u003e\n\n\u003ch4 id=\"1-输入上下文\"\u003e1. 输入上下文\u003c/h4\u003e\n\n\u003cp\u003e\u003cstrong\u003eBPF 的输入上下文（input context）是一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e 而不是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e\u003c/strong\u003e。当内核\n协议栈收到一个包时（说明包通过了 XDP 层），它会分配一个缓冲区，解析包，并存储包\n的元数据。表示这个包的结构体就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e。这个结构体会暴露给 BPF 输入上下文，\n因此 tc ingress 层的 BPF 程序就可以利用这些（由协议栈提取的）包的元数据。这些元\n数据很有用，但在包达到 tc 的 hook 点之前，\u003cstrong\u003e协议栈执行的缓冲区分配、元数据提取和\n其他处理等过程也是有开销的\u003c/strong\u003e。从定义来看，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e 不需要访问这些元数据，因为\n\u003cstrong\u003e\u003cmark\u003eXDP hook 在协议栈之前就会被调用。这是 XDP 和 tc hook 性能差距的重要原因之一\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e因此，attach 到 tc BPF hook 的 BPF 程序可以读取 skb 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emark\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epkt_type\u003c/code\u003e、\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprotocol\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriority\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003equeue_mapping\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enapi_id\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecb[]\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehash\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc_classid\u003c/code\u003e\n、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc_index\u003c/code\u003e、vlan 元数据、XDP 层传过来的自定义元数据以及其他信息。\ntc BPF 的 BPF 上下文中使用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct __sk_buff\u003c/code\u003e，这个结构体中的所有成员字段都定\n义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/bpf.h\u003c/code\u003e 系统头文件。\u003c/p\u003e\n\n\u003cp\u003e通常来说，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e 完全不同，二者各有优劣。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e 修改与其关联的元数据（its associated metadata）非常方便，但它包含了大量协议相关的信息\n（例如 GSO 相关的状态），这使得无法仅仅通过重写包数据来切换协议（switch protocols by solely rewriting the packet data）。\n 这是因为\u003cstrong\u003e\u003cmark\u003e协议栈是基于元数据处理包的，而不是每次都去读包的内容\u003c/mark\u003e\u003c/strong\u003e。因此，\n BPF 辅助函数需要额外的转换，并且还要正确处理 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e 内部信息。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e 没有这些问题，因为它所处的阶段非常早，此时内核还没有分配 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e，\n因此\u003cstrong\u003e\u003cmark\u003e很容易实现各种类型的数据包重写\u003c/mark\u003e\u003c/strong\u003e（packet rewrite）。\n但是，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003exdp_buff\u003c/code\u003e 的缺点是在它这个阶段进行 mangling 的时候，无法利用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e\n元数据。解决这个问题的方式是从 XDP BPF 传递自定义的元数据到 tc BPF。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这样，根据使用场景的不同，可以同时利用这两者 BPF 程序，以达到互补的效果。\u003c/p\u003e\n\n\u003ch4 id=\"2-hook-触发点\"\u003e2. hook 触发点\u003c/h4\u003e\n\n\u003cp\u003etc BPF 程序在数据路径上的 ingress 和 egress 点都可以触发；而\n\u003cstrong\u003e\u003cmark\u003eXDP BPF 程序只能在 ingress 点触发\u003c/mark\u003e\u003c/strong\u003e（不支持 egress XDP）。\u003c/p\u003e\n\n\u003cp\u003e内核两个 hook 点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eingress hook \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_handle_ingress()\u003c/code\u003e：由 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e__netif_receive_skb_core()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 触发\u003c/li\u003e\n  \u003cli\u003eegress hook \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_handle_egress()\u003c/code\u003e：由 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e__dev_queue_xmit()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 触发\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__netif_receive_skb_core()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__dev_queue_xmit()\u003c/code\u003e 是 \u003cstrong\u003edatapath 的主要收包/发包函数\u003c/strong\u003e，\n不考虑 XDP 的话（XDP 可能会拦截或修改，导致不经过这两个 hook 点），\n\u003cstrong\u003e\u003cmark\u003e每个进入或离开系统的包都会经过这两个点\u003c/mark\u003e\u003c/strong\u003e，从而使得 \u003cstrong\u003etc BPF 程序具备完全可观测性\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"3-是否依赖驱动支持\"\u003e3. 是否依赖驱动支持\u003c/h4\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003etc BPF 程序不需要驱动做任何改动\u003c/mark\u003e\u003c/strong\u003e，因为它们运行在\u003cstrong\u003e网络栈通用层\u003c/strong\u003e中的 hook 点。\n因此，它们\u003cstrong\u003e可以 attach 到任何类型的网络设备上\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch5 id=\"ingress\"\u003eIngress\u003c/h5\u003e\n\n\u003cp\u003e这提供了很好的灵活性，但跟运行在原生 XDP 层的程序相比，性能要差一些。然而，tc\nBPF 程序仍然是内核的通用 datapath \u003cstrong\u003e\u003cmark\u003e做完 GRO 之后、且处理任何协议之前\u003c/mark\u003e\u003c/strong\u003e\n最早的处理点。\u003cstrong\u003e传统的 iptables 防火墙也是在这里处理的\u003c/strong\u003e，例如 iptables PREROUTING 或\nnftables ingress hook 或其他数据包包处理过程。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eHowever, tc BPF programs still come at the earliest point in the generic\nkernel’s networking data path after GRO has been run but \u003cstrong\u003ebefore\u003c/strong\u003e any\nprotocol processing, traditional iptables firewalling such as iptables\nPREROUTING or nftables ingress hooks or other packet processing takes place.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch5 id=\"egress\"\u003eEgress\u003c/h5\u003e\n\n\u003cp\u003e类似的，对于 egress，tc BPF 程序在\u003cstrong\u003e\u003cmark\u003e将包交给驱动之前的最晚地方\u003c/mark\u003e\u003c/strong\u003e（latest point）\n执行，这个地方在\u003cstrong\u003e传统 iptables 防火墙 hook 之后\u003c/strong\u003e（例如 iptables POSTROUTING），\n但在\u003cstrong\u003e内核 GSO 引擎之前\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eLikewise on egress, tc BPF programs execute\nat the latest point before handing the packet to the driver itself for\ntransmission, meaning \u003cstrong\u003eafter\u003c/strong\u003e traditional iptables firewalling hooks like\niptables POSTROUTING, but still before handing the packet to the kernel’s\nGSO engine.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e唯一需要驱动做改动的场景是：将 tc BPF 程序 offload 到网卡。形式通常和 XDP\noffload 类似，只是特性列表不同，因为二者的 BPF 输入上下文、辅助函数和返回码（\nverdict）不同。\u003c/p\u003e\n\n\u003ch3 id=\"cls_bpf-分类器\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 分类器\u003c/h3\u003e\n\n\u003cp\u003e运行在 tc 层的 BPF 程序使用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 分类器。\u003cstrong\u003e在 tc 术语中 “BPF 附着点”被\n称为“分类器”\u003c/strong\u003e，但这个词其实有点误导，因为它\u003cstrong\u003e\u003cmark\u003e少描述了（under-represent）前者可以做的事情\u003c/mark\u003e\u003c/strong\u003e。\nattachment point 是一个完全可编程的包处理器，不仅能够读取 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 元数据\n和包数据，还可以任意 mangle 这两者，最后结束 tc 处理过程，返回一个裁定结果（\nverdict）。因此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 可以认为是一个\n\u003cstrong\u003e\u003cmark\u003e管理和执行 tc BPF 程序的自包含实体\u003c/mark\u003e\u003c/strong\u003e（self-contained entity）。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 可以持有（hold）一个或多个 tc BPF 程序。Cilium 在部署 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 程序时\n，\u003cstrong\u003e对于一个给定的 hook 点只会附着一个程序\u003c/strong\u003e，并且用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 模式。\n典型情况下，在传统 tc 方案中，分类器（classifier ）和动作模块（action modules）\n之间是分开的，每个分类器可以 attach 多个 action，当匹配到这个分类器时这些 action\n就会执行。在现代世界，在软件 data path 中使用 tc 做复杂包处理时这种模型扩展性不好。\n考虑到附着到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 的 tc BPF 程序\n是完全自包含的，因此它们有效地将解析和 action 过程融合到了单个单元（unit）中。得\n益于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 模式，它只需要返回 tc action 判决结果，然后立即\n终止处理流水线。这使得能够在网络 data path 中实现可扩展可编程的包处理，避免动作\n的线性迭代。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 是 tc 层中唯一支持这种快速路径（fast-path）的一个分类器模块。\u003c/p\u003e\n\n\u003cp\u003e和 XDP BPF 程序类似，tc BPF 程序能在运行时（runtime）通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 原子地更新，\n而不会导致任何网络流量中断，也不用重启服务。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 可以附着的 tc ingress 和 egress hook 点都是由一个名为 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e 的\n伪 qdisc\u003c/strong\u003e 管理的，它\u003cstrong\u003e是 ingress qdisc 的一个超集\u003c/strong\u003e（superset），可以无缝替换后\n者，因为它既可以管理 ingress tc hook 又可以管理 egress tc hook。对于\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__dev_queue_xmit()\u003c/code\u003e 内的 tc egress hook，需要注意的是这个 hook\n\u003cstrong\u003e\u003cmark\u003e并不是在内核的 qdisc root lock 下执行的\u003c/mark\u003e\u003c/strong\u003e。因此，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eingress 和 egress hook 都是在\u003cstrong\u003e\u003cmark\u003e快速路径中以无锁（lockless）方式执行\u003c/mark\u003e\u003c/strong\u003e的。\u003c/li\u003e\n  \u003cli\u003e不管是 ingress 还是 egress，抢占（preemption ）都被关闭，执行发生在 RCU 读侧（execution happens under RCU read side）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e通常在 egress 的场景下，有很多类型的 qdisc 会 attach 到 netdevice，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_mq\u003c/code\u003e,\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_fq\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_fq_codel\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_htb\u003c/code\u003e，其中某些是 classful qdiscs，这些 qdisc 包\n含 subclasses 因此需要一个对包进行分类的机制，决定将包 demux 到哪里。这个机制是\n由调用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etcf_classify()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 实现的，这个函数会进一步调用 tc 分类器（如果提供了）。\n在这种场景下， \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 也可以被 attach 和使用。这种操作通常发生在 qdisc root\nlock 下面，因此会面临锁竞争的问题。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e qdisc 的 egress hook 点位于更前\n面，没有落入这个锁的范围内，因此完全独立于常规 egress qdisc 而执行。\n因此对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_htb\u003c/code\u003e 这种场景，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e qdisc 可以将繁重的包分类工作放到 tc\nBPF 程序，在 qdisc root lock 之外执行，在这些 tc BPF 程序中设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;mark\u003c/code\u003e 或\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;priority\u003c/code\u003e ，因此随后 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_htb\u003c/code\u003e 只需要一个简单的映射，没有原来在 root lock\n下面昂贵的包分类开销，还减少了锁竞争。\u003c/p\u003e\n\n\u003cp\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e in combination with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 场景下支持 Offloaded tc BPF 程序，\n在这种场景下，原来加载到智能网卡驱动的 BPF 程序被 JIT，在网卡原生执行。\n只有工作在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 模式的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 程序支持 offload。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 只支持 offload 单个程序，不支持同时 offload 多个程序。另外，只有\ningress hook 支持 offloading BPF 程序。\u003c/p\u003e\n\n\u003cp\u003e一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 实例内部可以 hold 多个 tc BPF 程序。如果由多个程序，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 程序返回码就是让继续执行列表中的下一个程序。但这种方式的缺点是：\n每个程序都需要解析一遍数据包，性能会下降。\u003c/p\u003e\n\n\u003ch3 id=\"tc-bpf-程序返回码\"\u003etc BPF 程序返回码\u003c/h3\u003e\n\n\u003cp\u003etc ingress 和 egress hook 共享相同的返回码（动作判决），定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/pkt_cls.h\u003c/code\u003e\n系统头文件：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#define TC_ACT_UNSPEC         (-1)\n#define TC_ACT_OK               0\n#define TC_ACT_SHOT             2\n#define TC_ACT_STOLEN           4\n#define TC_ACT_REDIRECT         7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e系统头文件中还有一些 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_*\u003c/code\u003e 动作判决，也用在了这两个 hook 中。但是，这些判决\n和上面列出的那几个共享相同的语义。这意味着，从 tc BPF 的角度看，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_RECLASSIFY\u003c/code\u003e 有相同的语义，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_QUEUED\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_TRAP\u003c/code\u003e 返回码也是类似的情况。因此，\n对于这些情况，我们只描述 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e 操作码。\u003c/p\u003e\n\n\u003ch4 id=\"tc_act_unspec-和-tc_act_ok\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 表示“未指定的动作”（unspecified action），在三种情况下会用到：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eattach 了一个 offloaded tc BPF 程序，tc ingress hook 正在运行，被 offload 的\n程序的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 表示会返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e为了在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 多程序的情况下，继续下一个 tc BPF 程序。这种情况可以和\n第一种情况中提到的 offloaded tc BPF 程序一起使用，此时第一种情况返回的\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 继续执行下一个没有被 offloaded BPF 程序？\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 还用于单个程序从场景，只是通知内核继续执行 skb 处理，但不要带\n来任何副作用（without additional side-effects）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 在某些方面和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e 非常类似，因为二者都是将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 向下一个\n处理阶段传递，在 ingress 的情况下是传递给内核协议栈的更上层，在 egress 的情况下\n是传递给网络设备驱动。唯一的不同是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_OK\u003c/code\u003e 基于 tc BPF 程序设置的 classid 来\n设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tc_index\u003c/code\u003e，而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_UNSPEC\u003c/code\u003e 是通过 tc BPF 程序之外的 BPF 上下文中的\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tc_classid\u003c/code\u003e 设置。\u003c/p\u003e\n\n\u003ch4 id=\"tc_act_shot-和-tc_act_stolen\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_SHOT\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e这两个返回码指示内核将包丢弃。这两个返回码很相似，只有少数几个区别：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_SHOT\u003c/code\u003e 提示内核 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 是通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekfree_skb()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 释放的，并返回\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNET_XMIT_DROP\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 给调用方，作为立即反馈\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e 通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003econsume_skb()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 释放 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e，\n返回 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNET_XMIT_SUCCESS\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 给上层假装这个包已经被正确发送了\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eperf 的丢包监控（drop monitor）是跟踪的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekfree_skb()\u003c/code\u003e，因此在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_STOLEN\u003c/code\u003e 的\n场景下它无法看到任何丢包统计，因为从语义上说，此时这些 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 是被 “consumed” 或\nqueued 而不是被 dropped。\u003c/p\u003e\n\n\u003ch4 id=\"tc_act_redirect\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_REDIRECT\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e这个返回码加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_redirect()\u003c/code\u003e 辅助函数，允许重定向一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 到同一个或另一个\n设备的 ingress 或 egress 路径。能够将包注入另一个设备的 ingress 或 egress 路径使\n得基于 BPF 的包转发具备了完全的灵活性。对目标网络设备没有额外的要求，只要本身是\n一个网络设备就行了，在目标设备上不需要运行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 实例或其他限制。\u003c/p\u003e\n\n\u003ch3 id=\"tc-bpf-faq\"\u003etc BPF FAQ\u003c/h3\u003e\n\n\u003cp\u003e本节列出一些经常被问的、与 tc BPF 程序有关的问题。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 作为 tc action module 怎么样，现在用的还多吗？\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e不多\u003c/mark\u003e\u003c/strong\u003e。虽然对于 tc BPF 程序来说 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 有相同的功能\n  ，但前者更加灵活，因为它是后者的一个超集（superset）。tc 的工作原理是将 tc\n  actions attach 到 tc 分类器。要想实现与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 一样的灵活性，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 需要\n  被 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_matchall\u003c/code\u003e 分类器。如名字所示，为了将包传递给 attached tc\n  action 去处理，这个分类器会匹配每一个包。相比于工作在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 模式的\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 这种方式会导致较低的包处理性能。如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 用在\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_matchall\u003c/code\u003e 之外的其他分类器，那性能会更差，这是由 tc 分类器的\n  操作特性（nature of operation of tc classifiers）决定的。同时，如果分类器 A 未\n  匹配，那包会传给分类器 B，B 会重新解析这个包以及重复后面的流量，因此这是一个线\n  性过程，在最坏的情况下需要遍历 N 个分类器才能匹配和（在匹配的分类器上）执行\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e。因此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 从未大规模使用过。另外，和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 相比，\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e 也没有提供 tc offload 接口。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e是否推荐在使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 时选择 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 之外的其他模式?\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e不推荐\u003c/mark\u003e\u003c/strong\u003e。原因和上面的问题类似，选择其他模式无法应对更加复杂的处理情况。tc BPF\n  程序本身已经能以一种高效的方式做任何处理，因此除了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edirect-action\u003c/code\u003e 这个模式\n  之外，不需要其他的任何东西了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eoffloaded \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 offloaded XDP 有性能差异吗？\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e没有\u003c/mark\u003e\u003c/strong\u003e。二者都是由内核内的同一个编译器 JIT 的，这个编译器负责 offload 到智能网卡，\n  并且对二者的加载机制是非常相似的。因此，要在 NIC 上原生执行，BPF 程序\u003cstrong\u003e\u003cmark\u003e会被翻译成相同的目标指令\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003etc BPF 和 XDP BPF 这两种程序类型有不同的特性集合，因此根据使用场景的不同，\n  可以选择 tc BPF 或者是 XDP BPF，例如，二者的在 offload 场景下的辅助函数可能会有差异。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"tc-bpf-使用案例\"\u003etc BPF 使用案例\u003c/h3\u003e\n\n\u003cp\u003e本节列出了 tc BPF 程序的主要使用案例。但要注意，这里列出的并不是全部案例，而且考\n虑到 tc BPF 的可编程性和效率，人们很容易对它进行定制化（tailor）然后集成到编排系\n统，用来解决特定的问题。XDP 的一些案例可能有重叠，但 tc BPF 和 XDP BPF 大部分情\n况下都是互补的，可以单独使用，也可以同时使用，就看哪种情况更适合解决给定的问题了\n。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e容器安全策略（Policy enforcement）\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003etc BPF 程序适合用来给容器实现安全策略、自定义防火墙或类似的安全工具。在传统方\n  式中，容器隔离是通过网络命名空间时实现的，veth pair 的一端连接到宿主机的初始命\n  名空间，另一端连接到容器的命名空间。因为 veth pair 的\n  一端移动到了容器的命名空间，而另一端还留在宿主机上（默认命名空间），容器所有的\n  网络流量都需要经过主机端的 veth 设备，因此可以在这个 veth 设备的 tc ingress 和\n  egress hook 点 attach tc BPF 程序。目标地址是容器的网络流量会经过主机端的 veth\n  的 tc egress hook，而从容器出来的网络流量会经过主机端的 veth 的 tc ingress\n  hook。\u003c/p\u003e\n\n    \u003cp\u003e对于像 veth 这样的虚拟设备，XDP 在这种场景下是不合适的，因为内核在这里只操作\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e，而通用 XDP 有几个限制，导致无法操作克隆的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e。而克隆 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 在 TCP/IP\n  协议栈中用的非常多，目的是持有（hold）准备重传的数据片（data segments），而通\n  用 XDP hook 在这种情况下回被直接绕过。另外，generic XDP 需要顺序化（linearize ）整个\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 导致严重的性能下降。相比之下， tc BPF 非常灵活，因为设计中它就是工作在接\n  收 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e 格式的输入上下文中，因此没有 generic XDP 遇到的那些问题。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e转发和负载均衡\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e转发和负载均衡的使用场景和 XDP 很类似，只是目标更多的是在东西向容器流量而不是\n  南北向（虽然两者都可以用于东西向或南北向场景）。XDP 只能在 ingress 方向使用，\n  tc BPF 程序还可以在 egress 方向使用，例如，可以在初始命名空间内（宿主机上的\n  veth 设备上），通过 BPF 对容器的 egress 流量同时做地址转化（NAT）和负载均衡，\n  整个过程对容器是透明的。由于在内核网络栈的实现中，egress 流量已经是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_buff\u003c/code\u003e\n  形式的了，因此很适合 tc BPF 对其进行重写（rewrite）和重定向（redirect）。\n  使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_redirect()\u003c/code\u003e 辅助函数，BPF 就可以接管转发逻辑，将包推送到另一个网络设\n  备的 ingress 或 egress 路径上。因此，有了 tc BPF 程序实现的转发网格（\n  forwarding fabric），网桥设备都可以不用了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e流抽样（Flow sampling）、监控\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e和 XDP 类似，可以通过高性能无锁 per-CPU 内存映射 perf 环形缓冲区（ring buffer\n  ）实现流抽样（flow sampling）和监控，在这种场景下，BPF 程序能够将自定义数据、\n  全部或截断的包内容或者二者同时推送到一个用户空间应用。在 tc BPF 程序中这是通过\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_skb_event_output()\u003c/code\u003e BPF 辅助函数实现的，它和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_xdp_event_output()\u003c/code\u003e 有相\n  同的函数签名和语义。\u003c/p\u003e\n\n    \u003cp\u003e考虑到 tc BPF 程序可以同时 attach 到 ingress 和 egress，而 XDP 只能 attach 到\n  ingress，另外，这两个 hook 都在（通用）网络栈的更低层，这使得可以监控每台节点\n  的所有双向网络流量。这和 tcpdump 和 Wireshark 使用的 cBPF 比较相关，但是，不\n  需要克隆 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e，而且因为其可编程性而更加灵活，例如。BPF 能够在内核中完成聚合\n  ，而不用将所有数据推送到用户空间；也可以对每个放到 ring buffer 的包添加自定义\n  的 annotations。Cilium 大量使用了后者，对被 drop 的包进一步 annotate，关联到\n  容器标签以及 drop 的原因（例如因为违反了安全策略），提供了更丰富的信息。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e包调度器预处理\u003c/strong\u003e（Packet scheduler pre-processing）\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e’s egress hook 被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_handle_egress()\u003c/code\u003e 调用，在内核 qdisc\n  root lock 之前执行，因此 tc BPF 程序可以在包被发送到一个真实的 full blown qdis\n  （例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_htb\u003c/code\u003e）之前，用来执行包分类和 mangling 等所有这些高开销工作。\n  这种 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e 和后面的发送阶段的真实 qdisc（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_htb\u003c/code\u003e） 之间的交互，\n  能够减少发送时的锁竞争，因为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e 的 egress hook 是在无锁的上下文中执行的。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e同时使用 tc BPF 和 XDP BPF 程序的一个具体例子是 Cilium。Cilium 是一个开源软件，\n透明地对（K8S 这样的容器编排平台中的）容器之间的网络连接进行安全保护，工作在\nL3/L4/L7。Cilium 的核心基于 BPF，用来实现安全策略、负载均衡和监控。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.slideshare.net/ThomasGraf5/dockercon-2017-cilium-network-and-application-security-with-bpf-and-xdp\"\u003eSlides\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://youtu.be/ilKlmTDdFgk\"\u003eVideo\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium\"\u003eGithub\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"驱动支持-1\"\u003e驱动支持\u003c/h3\u003e\n\n\u003cp\u003e由于 tc BPF 程序是从内核网络栈而不是直接从驱动触发的，因此它们不需要任何额外的驱\n动改动，因此可以运行在任何网络设备之上。唯一的例外是当需要将 tc BPF 程序 offload\n到网卡时。\u003c/p\u003e\n\n\u003ch4 id=\"支持-offload-tc-bpf-程序的驱动\"\u003e支持 offload tc BPF 程序的驱动\u003c/h4\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003eNetronome\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003enfp\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/bpf-advanced-notes-3-zh/\"\u003e\u003cspan\u003e« BPF 进阶笔记（三）：BPF Map 内核实现\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/xdp-paper-acm-2018-zh/\"\u003e\u003cspan\u003e[译] [论文] XDP (eXpress Data Path)：在操作系统内核中实现快速、可编程包处理（ACM，2018） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-07-18T00:00:00Z",
  "Author": "Arthur Chiao"
}