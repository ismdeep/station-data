{
  "Source": "arthurchiao.art",
  "Title": "[译] Cilium：基于 BPF+EDT+FQ+BBR 实现更好的带宽管理（KubeCon, 2022）",
  "Link": "https://arthurchiao.art/blog/better-bandwidth-management-with-ebpf-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Cilium：基于 BPF+EDT+FQ+BBR 实现更好的带宽管理（KubeCon, 2022）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-10-30 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 KubeCon+CloudNativeCon Europe 2022 的一篇分享：\n\u003ca href=\"https://kccnceu2022.sched.com/event/ytsQ/better-bandwidth-management-with-ebpf-daniel-borkmann-christopher-m-luciano-isovalent\"\u003eBetter Bandwidth Management with eBPF\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e作者 Daniel Borkmann, Christopher, Nikolay 都来自 Isovalent（Cilium 母公司）。\n翻译时补充了一些背景知识、代码片段和链接，以方便理解。\u003c/p\u003e\n\n\u003cp\u003e翻译已获得 Daniel 授权。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-问题描述\" id=\"markdown-toc-1-问题描述\"\u003e1 问题描述\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-容器部署密度与cpu内存资源管理\" id=\"markdown-toc-11-容器部署密度与cpu内存资源管理\"\u003e1.1 容器部署密度与（CPU、内存）资源管理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-网络资源管理带宽控制模型\" id=\"markdown-toc-12-网络资源管理带宽控制模型\"\u003e1.2 网络资源管理：带宽控制模型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-k8s-中的-pod-带宽管理\" id=\"markdown-toc-13-k8s-中的-pod-带宽管理\"\u003e1.3 K8s 中的 pod 带宽管理\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#131-bandwidth-meta-plugin\" id=\"markdown-toc-131-bandwidth-meta-plugin\"\u003e1.3.1 Bandwidth meta plugin\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#132-入向ingress限速存在的问题\" id=\"markdown-toc-132-入向ingress限速存在的问题\"\u003e1.3.2 入向（ingress）限速存在的问题\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#133-出向egress限速存在的问题\" id=\"markdown-toc-133-出向egress限速存在的问题\"\u003e1.3.3 出向（egress）限速存在的问题\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#134-bandwidth-meta-plugin-问题总结\" id=\"markdown-toc-134-bandwidth-meta-plugin-问题总结\"\u003e1.3.4 Bandwidth meta plugin 问题总结\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-解决思路\" id=\"markdown-toc-2-解决思路\"\u003e2 解决思路\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-回归源头tcp-尽可能快发送模型存在的缺陷\" id=\"markdown-toc-21-回归源头tcp-尽可能快发送模型存在的缺陷\"\u003e2.1 回归源头：TCP “尽可能快”发送模型存在的缺陷\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-思路转变不再基于排队queue而是基于时间戳edt\" id=\"markdown-toc-22-思路转变不再基于排队queue而是基于时间戳edt\"\u003e2.2 思路转变：不再基于排队（queue），而是基于时间戳（EDT）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-3-edttiming-wheel-应用到-k8s\" id=\"markdown-toc-23-3-edttiming-wheel-应用到-k8s\"\u003e2.3 3 EDT/timing-wheel 应用到 K8s\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-cilium-原生-pod-限速方案\" id=\"markdown-toc-3-cilium-原生-pod-限速方案\"\u003e3 Cilium 原生 pod 限速方案\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-整体设计基于-bpfedt-实现容器限速\" id=\"markdown-toc-31-整体设计基于-bpfedt-实现容器限速\"\u003e3.1 整体设计：基于 BPF+EDT 实现容器限速\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-工作流程\" id=\"markdown-toc-32-工作流程\"\u003e3.2 工作流程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-数据包处理过程\" id=\"markdown-toc-33-数据包处理过程\"\u003e3.3 数据包处理过程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-性能对比cilium-vs-bandwidth-meta-plugin\" id=\"markdown-toc-34-性能对比cilium-vs-bandwidth-meta-plugin\"\u003e3.4 性能对比：Cilium vs. Bandwidth meta plugin\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-小结\" id=\"markdown-toc-34-小结\"\u003e3.4 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-公网传输cilium-基于-bbr-的带宽管理\" id=\"markdown-toc-4-公网传输cilium-基于-bbr-的带宽管理\"\u003e4 公网传输：Cilium 基于 BBR 的带宽管理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-bbr-基础\" id=\"markdown-toc-41-bbr-基础\"\u003e4.1 BBR 基础\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#411-设计初衷\" id=\"markdown-toc-411-设计初衷\"\u003e4.1.1 设计初衷\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#412-性能对比bbr-vs-cubic\" id=\"markdown-toc-412-性能对比bbr-vs-cubic\"\u003e4.1.2 性能对比：bbr vs. cubic\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-bbr--k8scilium\" id=\"markdown-toc-42-bbr--k8scilium\"\u003e4.2 BBR + K8s/Cilium\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#421-存在的问题跨-netns-时skb-tstamp-被重置\" id=\"markdown-toc-421-存在的问题跨-netns-时skb-tstamp-被重置\"\u003e4.2.1 存在的问题：跨 netns 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 被重置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#422-为什么被重置\" id=\"markdown-toc-422-为什么被重置\"\u003e4.2.2 为什么被重置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#423-能将-skb-tstamp-统一到同一种时钟吗\" id=\"markdown-toc-423-能将-skb-tstamp-统一到同一种时钟吗\"\u003e4.2.3 能将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 统一到同一种时钟吗？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#424-解决\" id=\"markdown-toc-424-解决\"\u003e4.2.4 解决\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-demo略\" id=\"markdown-toc-43-demo略\"\u003e4.3 Demo（略）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-bbr-使用注意事项\" id=\"markdown-toc-44-bbr-使用注意事项\"\u003e4.4 BBR 使用注意事项\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-总结及致谢\" id=\"markdown-toc-5-总结及致谢\"\u003e5 总结及致谢\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-问题回顾与总结\" id=\"markdown-toc-51-问题回顾与总结\"\u003e5.1 问题回顾与总结\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-致谢\" id=\"markdown-toc-52-致谢\"\u003e5.2 致谢\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-cilium-限速方案存在的问题译注\" id=\"markdown-toc-6-cilium-限速方案存在的问题译注\"\u003e6 Cilium 限速方案存在的问题（译注）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-问题描述\"\u003e1 问题描述\u003c/h1\u003e\n\n\u003ch2 id=\"11-容器部署密度与cpu内存资源管理\"\u003e1.1 容器部署密度与（CPU、内存）资源管理\u003c/h2\u003e\n\n\u003cp\u003e下面两张图来自 Sysdig 2022 的一份调研报告，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/container-usage-trends.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eSource: Sysdig 2022 Cloud Native Security and Usage Report\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e左图是容器的\u003cstrong\u003e\u003cmark\u003e部署密度分布\u003c/mark\u003e\u003c/strong\u003e，比如 33% 的 k8s 用户中，每个 node 上平均会部署 16~25 个 Pod；\u003c/li\u003e\n  \u003cli\u003e右图是\u003cstrong\u003e\u003cmark\u003e每台宿主机上的容器中位数\u003c/mark\u003e\u003c/strong\u003e，可以看到过去几年明显在不断增长。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这两个图说明：容器的部署密度越来越高。这导致的 CPU、内存等\u003cstrong\u003e\u003cmark\u003e资源竞争将更加激烈\u003c/mark\u003e\u003c/strong\u003e，\n如何管理资源的分配或配额就越来越重要。具体到 CPU 和 memory 这两种资源，\nK8s 提供了 \u003cstrong\u003e\u003cmark\u003eresource requests/limits\u003c/mark\u003e\u003c/strong\u003e 机制，用户或管理员可以指定一个\nPod \u003cstrong\u003e\u003cmark\u003e需要用到的资源量（requests）\u003c/mark\u003e\u003c/strong\u003e和\u003cstrong\u003e\u003cmark\u003e最大能用的资源量（limits）\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-yaml highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"na\"\u003eapiVersion\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"na\"\u003ekind\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003ePod\u003c/span\u003e\n\u003cspan class=\"na\"\u003emetadata\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"na\"\u003ename\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003efrontend\u003c/span\u003e\n\u003cspan class=\"na\"\u003espec\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"na\"\u003econtainers\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"pi\"\u003e-\u003c/span\u003e \u003cspan class=\"na\"\u003ename\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003eapp\u003c/span\u003e\n    \u003cspan class=\"na\"\u003eimage\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003enginx-slim:0.8\u003c/span\u003e\n    \u003cspan class=\"na\"\u003eresources\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n      \u003cspan class=\"na\"\u003erequests\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e         \u003cspan class=\"c1\"\u003e# 容器需要的资源量，kubelet 会将 pod 调度到剩余资源大于这些声明的 node 上去 \u003c/span\u003e\n        \u003cspan class=\"na\"\u003ememory\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s\"\u003e64Mi\u0026#34;\u003c/span\u003e\n        \u003cspan class=\"na\"\u003ecpu\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s\"\u003e250m\u0026#34;\u003c/span\u003e\n      \u003cspan class=\"na\"\u003elimits\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e           \u003cspan class=\"c1\"\u003e# 容器能使用的硬性上限（hard limit），超过这个阈值容器就会被 OOM kill\u003c/span\u003e\n        \u003cspan class=\"na\"\u003ememory\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s\"\u003e128Mi\u0026#34;\u003c/span\u003e\n        \u003cspan class=\"na\"\u003ecpu\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"s\"\u003e500m\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekube-scheduler\u003c/code\u003e 会将 pod 调度到能满足 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eresource.requests\u003c/code\u003e 声明的资源需求的 node 上；\u003c/li\u003e\n  \u003cli\u003e如果 pod 运行之后使用的内存超过了 memory limits，就会被操作系统以 OOM （Out Of Memory）为由干掉。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这种针对 CPU 和 memory 的资源管理机制还是不错的，\n那么，\u003cstrong\u003e\u003cmark\u003e网络方面有没有类似的机制呢\u003c/mark\u003e\u003c/strong\u003e？\u003c/p\u003e\n\n\u003ch2 id=\"12-网络资源管理带宽控制模型\"\u003e1.2 网络资源管理：带宽控制模型\u003c/h2\u003e\n\n\u003cp\u003e先回顾下基础的网络知识。\n下图是往返时延（Round-Trip）与 TCP 拥塞控制效果之间的关系，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/tcp-cc-states.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e结合\n\u003ca href=\"/blog/traffic-control-from-queue-to-edt-zh/\"\u003e\u003cmark\u003e流量控制（TC）五十年：从基于缓冲队列（Queue）到基于时间戳（EDT）的演进（Google, 2018）\u003c/mark\u003e\u003c/a\u003e，\n这里只做几点说明：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eTCP 的发送模型是\u003cstrong\u003e\u003cmark\u003e尽可能快\u003c/mark\u003e\u003c/strong\u003e（As Fast As Possible, AFAP）\u003c/li\u003e\n  \u003cli\u003e网络流量主要是靠\u003cstrong\u003e\u003cmark\u003e网络设备上的出向队列\u003c/mark\u003e\u003c/strong\u003e（device output queue）做\u003cstrong\u003e\u003cmark\u003e整形\u003c/mark\u003e\u003c/strong\u003e（shaping）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e队列长度\u003c/mark\u003e\u003c/strong\u003e（queue length）和\u003cstrong\u003e\u003cmark\u003e接收窗口\u003c/mark\u003e\u003c/strong\u003e（receive window）决定了传输中的数据速率（in-flight rate）\u003c/li\u003e\n  \u003cli\u003e“多快”（how fast）取决于\u003cstrong\u003e\u003cmark\u003e队列的 drain rate\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e现在回到我们刚才提出的问题（k8s 网络资源管理），\n在 K8s 中，有什么机制能限制 pod 的网络资源（带宽）使用量吗？\u003c/p\u003e\n\n\u003ch2 id=\"13-k8s-中的-pod-带宽管理\"\u003e1.3 K8s 中的 pod 带宽管理\u003c/h2\u003e\n\n\u003ch3 id=\"131-bandwidth-meta-plugin\"\u003e1.3.1 Bandwidth meta plugin\u003c/h3\u003e\n\n\u003cp\u003eK8s 自带了一个限速（bandwidth enforcement）机制，但到目前为止还是 experimental 状态；\n实现上是通过第三方的 bandwidth meta plugin，它会解析特定的 pod annotation，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekubernetes.io/ingress-bandwidth=XX\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekubernetes.io/egress-bandwidth=XX\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e然后转化成对 pod 的具体限速规则，如下图所示，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/k8s-bw-plugin.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Bandwidth meta plugin 解析 pod annotation，并通过 TC TBF 实现限速\u003c/p\u003e\n\n\u003cp\u003ebandwidth meta plugin 是一个 CNI plugin，底层利用 Linux TC 子系统中的 TBF，\n所以最后转化成的是 \u003cstrong\u003e\u003cmark\u003eTC 限速规则，加在容器的 veth pair 上（宿主机端）\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种方式确实能实现 pod 的限速功能，但也存在很严重的问题，我们来分别看一下出向和入向的工作机制。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e在进入下文之前，有两点重要说明：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e限速只能在出向（egress）做。为什么？可参考 \u003ca href=\"/blog/lartc-qdisc-zh/\"\u003e\u003cmark\u003e《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽\u003c/mark\u003e\u003c/a\u003e；\u003c/li\u003e\n    \u003cli\u003eveth pair 宿主机端的流量方向与 pod 的流量方向完全相反，也就是\n\u003cstrong\u003e\u003cmark\u003epod 的 ingress 对应宿主机端 veth 的 egress\u003c/mark\u003e\u003c/strong\u003e，反之亦然。\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"132-入向ingress限速存在的问题\"\u003e1.3.2 入向（ingress）限速存在的问题\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e对于 pod ingress 限速，需要在宿主机端 veth 的 egress 路径上设置规则\u003c/mark\u003e\u003c/strong\u003e。\n例如，对于入向 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubernetes.io/ingress-bandwidth=\u0026#34;50M\u0026#34;\u003c/code\u003e 的声明，会落到 veth 上的 TBF qdisc 上：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bw-plugin-ingress-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTBF（Token Bucket Filter）是个令牌桶，所有连接/流量都要经过\u003cstrong\u003e\u003cmark\u003e单个队列\u003c/mark\u003e\u003c/strong\u003e排队处理，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bw-plugin-ingress-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在设计上存在的问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eTBF qdisc \u003cstrong\u003e\u003cmark\u003e所有 CPU 共享一个锁\u003c/mark\u003e\u003c/strong\u003e（著名的 qdisc root lock），因此存在锁竞争；流量越大锁开销越大；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eveth pair 是单队列\u003c/mark\u003e\u003c/strong\u003e（single queue）虚拟网络设备，因此物理网卡的\n  多队列（multi queue，不同 CPU 处理不同 queue，并发）优势到了这里就没用了，\n  大家还是要走到同一个队列才能进到 pod；\u003c/li\u003e\n  \u003cli\u003e在入向排队是不合适的（no-go），会占用大量系统资源和缓冲区开销（bufferbloat）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"133-出向egress限速存在的问题\"\u003e1.3.3 出向（egress）限速存在的问题\u003c/h3\u003e\n\n\u003cp\u003e出向工作原理：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ePod egress 对应 veth 主机端的 ingress，\u003cstrong\u003e\u003cmark\u003eingress 是不能做整形的，因此加了一个 ifb 设备\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e所有从 veth 出来的流量会被重定向到 ifb 设备，通过 ifb TBF qdisc 设置容器限速。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bw-plugin-egress-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e存在的问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e原来只需要在物理网卡排队\u003c/mark\u003e\u003c/strong\u003e（一般都会设置一个默认 qdisc，例如\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast/fq_codel/noqueue\u003c/code\u003e），现在又多了一层 ifb 设备排队，缓冲区膨胀（bufferbloat）；\u003c/li\u003e\n  \u003cli\u003e与 ingress 一样，存在 \u003cstrong\u003e\u003cmark\u003eroot qdisc lock 竞争\u003c/mark\u003e\u003c/strong\u003e，所有 CPU 共享；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e干扰 TCP Small Queues (TSQ) 正常工作\u003c/mark\u003e\u003c/strong\u003e；TSQ 作用是\u003cstrong\u003e\u003cmark\u003e减少 bufferbloat\u003c/mark\u003e\u003c/strong\u003e，\n  工作机制是觉察到发出去的包还没有被有效处理之后就减少发包；ifb 使得包都缓存在 qdisc 中，\n  使 TSQ 误以为这些包都已经发出去了，实际上还在主机内。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e延迟显著增加\u003c/mark\u003e\u003c/strong\u003e：每个 pod 原来只需要 2 个网络设备，现在需要 3 个，增加了大量 queueing 逻辑。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/lots-of-queues.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"134-bandwidth-meta-plugin-问题总结\"\u003e1.3.4 Bandwidth meta plugin 问题总结\u003c/h3\u003e\n\n\u003cp\u003e总结起来：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e扩展性差，性能无法随 CPU 线性扩展（root qdisc lock 被所有 CPU 共享导致）；\u003c/li\u003e\n  \u003cli\u003e导致额外延迟；\u003c/li\u003e\n  \u003cli\u003e占用额外资源，缓冲区膨胀。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此\u003cstrong\u003e\u003cmark\u003e不适用于生产环境\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n\u003ch1 id=\"2-解决思路\"\u003e2 解决思路\u003c/h1\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这一节是介绍 Google 的基础性工作，作者引用了 \n\u003ca href=\"https://www.youtube.com/watch?v=MAni0_lN7zE\"\u003eEvolving from AFAP: Teaching NICs about time (Netdev, 2018)\u003c/a\u003e\n中的一些内容；之前我们已翻译，见\n\u003ca href=\"/blog/traffic-control-from-queue-to-edt-zh/\"\u003e\u003cmark\u003e流量控制（TC）五十年：从基于缓冲队列（Queue）到基于时间（EDT）的演进（Google, 2018）\u003c/mark\u003e\u003c/a\u003e，\n因此一些内容不再赘述，只列一下要点。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"21-回归源头tcp-尽可能快发送模型存在的缺陷\"\u003e2.1 回归源头：TCP “尽可能快”发送模型存在的缺陷\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/traffic-control-from-queue-to-edt/queue-bottleneck.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 根据排队论，实际带宽接近瓶颈带宽时，延迟将急剧上升\u003c/p\u003e\n\n\u003ch2 id=\"22-思路转变不再基于排队queue而是基于时间戳edt\"\u003e2.2 思路转变：不再基于排队（queue），而是基于时间戳（EDT）\u003c/h2\u003e\n\n\u003cp\u003e两点核心转变：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个包（skb）打上一个\u003cstrong\u003e\u003cmark\u003e最早离开时间\u003c/mark\u003e\u003c/strong\u003e（Earliest Departure Time, EDT），也就是最早可以发送的时间戳；\u003c/li\u003e\n  \u003cli\u003e用\u003cstrong\u003e\u003cmark\u003e时间轮调度器\u003c/mark\u003e\u003c/strong\u003e（timing-wheel scheduler）替换原来的\u003cstrong\u003e\u003cmark\u003e出向缓冲队列\u003c/mark\u003e\u003c/strong\u003e（qdisc queue）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/traffic-control-from-queue-to-edt/token-bucket-vs-edt.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 传统基于 queue 的流量整形器 vs. 新的基于 EDT 的流量整形器\u003c/p\u003e\n\n\u003ch2 id=\"23-3-edttiming-wheel-应用到-k8s\"\u003e2.3 3 EDT/timing-wheel 应用到 K8s\u003c/h2\u003e\n\n\u003cp\u003e有了这些技术基础，我们接下来看如何应用到 K8s。\u003c/p\u003e\n\n\u003ch1 id=\"3-cilium-原生-pod-限速方案\"\u003e3 Cilium 原生 pod 限速方案\u003c/h1\u003e\n\n\u003ch2 id=\"31-整体设计基于-bpfedt-实现容器限速\"\u003e3.1 整体设计：基于 BPF+EDT 实现容器限速\u003c/h2\u003e\n\n\u003cp\u003eCilium 的 bandwidth manager，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e基于 eBPF+EDT，实现了\u003cstrong\u003e\u003cmark\u003e无锁\u003c/mark\u003e\u003c/strong\u003e 的 pod 限速功能；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e在物理网卡（或 bond 设备）而不是 veth 上限速\u003c/mark\u003e\u003c/strong\u003e，避免了 bufferbloat，也不会扰乱 TCP TSQ 功能。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e不需要进入协议栈\u003c/mark\u003e\u003c/strong\u003e，Cilium 的 BPF host routing 功能，使得 FIB\nlookup 等过程\u003cstrong\u003e\u003cmark\u003e完全在 TC eBPF 层完成\u003c/mark\u003e\u003c/strong\u003e，并且能\u003cstrong\u003e\u003cmark\u003e直接转发到网络设备\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e在物理网卡（或 bond 设备）上添加 MQ/FQ，实现\u003cstrong\u003e\u003cmark\u003e时间轮调度\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/cilium-bw-rate-limit.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"32-工作流程\"\u003e3.2 工作流程\u003c/h2\u003e\n\n\u003cp\u003e在之前的分享\n\u003ca href=\"/blog/bpf-datapath-extensions-for-k8s-zh/\"\u003e\u003cmark\u003e为 K8s workload 引入的一些 BPF datapath 扩展（LPC, 2021）\u003c/mark\u003e\u003c/a\u003e\n中已经有比较详细的介绍，这里在重新整理一下。\u003c/p\u003e\n\n\u003cp\u003eCilium attach 到宿主机的物理网卡（或 bond 设备），在 BPF 程序中为每个包设置 timestamp，\n然后通过 earliest departure time 在 fq 中实现限速，下图：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：容器限速是在\u003cstrong\u003e\u003cmark\u003e物理网卡\u003c/mark\u003e\u003c/strong\u003e上做的，而不是在每个 pod 的 veth 设备上。这跟之前基于 ifb 的限速方案有很大不同。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/pod-egress-rate-limit.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Cilium 基于 BPF+EDT 的容器限速方案（逻辑架构）\u003c/p\u003e\n\n\u003cp\u003e从上到下三个步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eBPF 程序\u003c/mark\u003e\u003c/strong\u003e：管理（计算和设置） skb 的 departure timestamp；\u003c/li\u003e\n  \u003cli\u003eTC \u003cstrong\u003e\u003cmark\u003eqdisc (multi-queue) 发包调度\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e物理网卡的队列\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e如果宿主机使用了 bond，那么\u003cstrong\u003e\u003cmark\u003e根据 bond 实现方式的不同，FQ 的数量会不一样\u003c/mark\u003e\u003c/strong\u003e，\n可通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etc -s -d qdisc show dev {bond}\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 查看实际状态。具体来说，\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eLinux bond \u003ca href=\"https://www.kernel.org/doc/Documentation/networking/bonding.txt\"\u003e默认支持多队列（multi-queue），会默认创建 16 个 queue\u003c/a\u003e，\n每个 queue 对应一个 FQ，挂在一个 MQ 下面，也就是上面图中画的；\u003c/li\u003e\n    \u003cli\u003eOVS bond 不支持 MQ，因此只有一个 FQ（v2.3 等老版本行为，新版本不清楚）。\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003ebond 设备的 TXQ 数量，可以通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003els /sys/class/net/{dev}/queues/\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 查看。\n物理网卡的 TXQ 数量也可以通过以上命令看，但 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eethtool -l {dev}\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n看到的信息更多，包括了最大支持的数量和实际启用的数量。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"33-数据包处理过程\"\u003e3.3 数据包处理过程\u003c/h2\u003e\n\n\u003cp\u003e先复习下 Cilium datapath，细节见 2020 年的分享：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-forwarding.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eegress 限速工作流程：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-works-today.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ePod egress 流量从容器进入宿主机，此时会发生 \u003cstrong\u003e\u003cmark\u003enetns 切换\u003c/mark\u003e\u003c/strong\u003e，但 socket 信息 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eskb-\u0026gt;sk\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 不会丢失；\u003c/li\u003e\n  \u003cli\u003eHost 端 \u003cstrong\u003e\u003cmark\u003eveth 上的 BPF\u003c/mark\u003e\u003c/strong\u003e 标记（marking）包的 aggregate（queue_mapping），见 \u003ca href=\"https://github.com/cilium/cilium/blob/v1.10/bpf/lib/edt.h\"\u003eCilium 代码\u003c/a\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e物理网卡上的 BPF\u003c/mark\u003e\u003c/strong\u003e 程序根据 aggregate 设置的限速参数，\u003cstrong\u003e\u003cmark\u003e设置每个包的时间戳\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eFQ+MQ\u003c/mark\u003e\u003c/strong\u003e 基本实现了一个 timing-wheel 调度器，根据 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 调度发包。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e过程中用\u003cstrong\u003e\u003cmark\u003e到了 bpf map 存储 aggregate 信息\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"34-性能对比cilium-vs-bandwidth-meta-plugin\"\u003e3.4 性能对比：Cilium vs. Bandwidth meta plugin\u003c/h2\u003e\n\n\u003cp\u003enetperf 压测。\u003c/p\u003e\n\n\u003cp\u003e同样限速 100M，延迟下降：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/edt-vs-tbf-perf-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e同样限速 100M，TPS：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/edt-vs-tbf-perf-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"34-小结\"\u003e3.4 小结\u003c/h2\u003e\n\n\u003cp\u003e主机内的问题解决了，那更大范围 —— 即公网带宽 —— 管理呢？\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/internet-traffic.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e别着急，\u003cstrong\u003e\u003cmark\u003eEDT 还能支持 BBR\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"4-公网传输cilium-基于-bbr-的带宽管理\"\u003e4 公网传输：Cilium 基于 BBR 的带宽管理\u003c/h1\u003e\n\n\u003ch2 id=\"41-bbr-基础\"\u003e4.1 BBR 基础\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e完整 BBR 设计可参考\n\u003ca href=\"{ % link _posts/2022-01-02-bbr-paper-zh.md %}\"\u003e\u003cmark\u003e(论文) BBR：基于拥塞（而非丢包）的拥塞控制（ACM, 2017）\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"411-设计初衷\"\u003e4.1.1 设计初衷\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bbr-1.png\" width=\"95%\" height=\"95%\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"412-性能对比bbr-vs-cubic\"\u003e4.1.2 性能对比：bbr vs. cubic\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bbr-vs-cubic-table.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eCUBIC + fq_codel\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bbr-vs-cubic-perf-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eBBR + FQ (for EDT)\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bbr-vs-cubic-perf-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e效果非常明显。\u003c/p\u003e\n\n\u003ch2 id=\"42-bbr--k8scilium\"\u003e4.2 BBR + K8s/Cilium\u003c/h2\u003e\n\n\u003ch3 id=\"421-存在的问题跨-netns-时skb-tstamp-被重置\"\u003e4.2.1 存在的问题：跨 netns 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 被重置\u003c/h3\u003e\n\n\u003cp\u003eBBR 能不能用到 k8s 里面呢？\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eBBR + FQ 机制上是能协同工作的；但是，\u003c/li\u003e\n  \u003cli\u003e内核在 skb 离开 pod netns 时，将 skb 的时间戳清掉了，导致包进入 host netns 之后没有时间戳，FQ 无法工作\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e问题如下图所示，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/pod-bbr-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"422-为什么被重置\"\u003e4.2.2 为什么被重置\u003c/h3\u003e\n\n\u003cp\u003e下面介绍一些背景，为什么这个 ts 会被重置。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e几种时间规范：https://www.cl.cam.ac.uk/~mgk25/posix-clocks.html\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e对于包的时间戳 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e，内核\u003cstrong\u003e\u003cmark\u003e根据包的方向（RX/TX）不同而使用的两种时钟源\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eIngress 使用 CLOCK_TAI\u003c/mark\u003e\u003c/strong\u003e (TAI: international atomic time)\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eEgress 使用 CLOCK_MONOTONIC\u003c/mark\u003e\u003c/strong\u003e（也是 \u003cstrong\u003e\u003cmark\u003eFQ 使用的时钟类型\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果不重置，将包\u003cstrong\u003e\u003cmark\u003e从 RX 转发到 TX 会导致包在 FQ 中被丢弃\u003c/mark\u003e\u003c/strong\u003e，因为\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L463\"\u003e超过 FQ 的 drop horizon\u003c/a\u003e。\nFQ \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehorizon\u003c/code\u003e \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L950\"\u003e默认是 10s\u003c/a\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehorizon\u003c/code\u003e 是 FQ 的一个配置项，表示一个时间长度，\n在 \u003ca href=\"https://github.com/torvalds/linux/commit/39d010504e6b\"\u003enet_sched: sch_fq: add horizon attribute\u003c/a\u003e 引入，\u003c/p\u003e\n\n  \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eQUIC servers would like to use SO_TXTIME, without having CAP_NET_ADMIN,\nto efficiently pace UDP packets.\n\nAs far as sch_fq is concerned, we need to add safety checks, so\nthat a buggy application does not fill the qdisc with packets\nhaving delivery time far in the future.\n\nThis patch adds a configurable horizon (default: 10 seconds),\nand a configurable policy when a packet is beyond the horizon\nat enqueue() time:\n- either drop the packet (default policy)\n- or cap its delivery time to the horizon.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e简单来说，如果一个\u003cstrong\u003e\u003cmark\u003e包的时间戳离现在太远，就直接将这个包\n丢弃，或者将其改为一个上限值\u003c/mark\u003e\u003c/strong\u003e（cap），以便节省队列空间；否则，这种\n包太多的话，队列可能会被塞满，导致时间戳比较近的包都无法正常处理。\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L436\"\u003e内核代码\u003c/a\u003e如下：\u003c/p\u003e\n\n  \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003efq_packet_beyond_horizon\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003efq_sched_data\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eunlikely\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003es64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etstamp\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es64\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ektime_cache\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ehorizon\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e另外，现在给定一个包，我们\u003cstrong\u003e\u003cmark\u003e无法判断它用的是哪种 timestamp\u003c/mark\u003e\u003c/strong\u003e，因此只能用这种 reset 方式。\u003c/p\u003e\n\n\u003ch3 id=\"423-能将-skb-tstamp-统一到同一种时钟吗\"\u003e4.2.3 能将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 统一到同一种时钟吗？\u003c/h3\u003e\n\n\u003cp\u003e其实最开始，TCP \u003cstrong\u003e\u003cmark\u003eEDT 用的也是 CLOCK_TAI 时钟\u003c/mark\u003e\u003c/strong\u003e。\n但有人在\u003ca href=\"https://lore.kernel.org/netdev/2185d09d-90e1-81ef-7c7f-346eeb951bf4@gmail.com/\"\u003e邮件列表\u003c/a\u003e\n里反馈说，某些特殊的嵌入式设备上重启会导致时钟漂移 50 多年。所以后来\n\u003cstrong\u003e\u003cmark\u003eEDT 又回到了 monotonic 时钟\u003c/mark\u003e\u003c/strong\u003e，而我们必须跨 netns 时 reset。\u003c/p\u003e\n\n\u003cp\u003e我们做了个原型验证，新加一个 bit \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp_base\u003c/code\u003e 来解决这个问题，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e0 表示使用的 TAI，\u003c/li\u003e\n  \u003cli\u003e1 表示使用的 MONO，\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e然后，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eTX/RX 通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb_set_tstamp_{mono,tai}(skb, ktime)\u003c/code\u003e helper 来获取这个值，\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efq_enqueue()\u003c/code\u003e 先检查 timestamp 类型，如果不是 MONO，就 reset \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e此外，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e转发逻辑中所有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp = 0\u003c/code\u003e 都可以删掉了\u003c/li\u003e\n  \u003cli\u003eskb_mstamp_ns union 也可能删掉了\u003c/li\u003e\n  \u003cli\u003e在 RX 方向，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_timestamp_check()\u003c/code\u003e 必须推迟到 tc ingress 之后执行\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"424-解决\"\u003e4.2.4 解决\u003c/h3\u003e\n\n\u003cp\u003e我们和 Facebook 的朋友合作，已经解决了这个问题，在跨 netns 时保留时间戳，\npatch 并合并到了 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekernel 5.18+\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\n因此 BBR+EDT 可以工作了，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/pod-bbr-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"43-demo略\"\u003e4.3 Demo（略）\u003c/h2\u003e\n\n\u003cp\u003eK8s/Cilium backed video streaming service: CUBIC vs. BBR\u003c/p\u003e\n\n\u003ch2 id=\"44-bbr-使用注意事项\"\u003e4.4 BBR 使用注意事项\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果同一个环境（例如数据中心）同时启用了 BBR 和 CUBIC，那使用 \u003cstrong\u003e\u003cmark\u003eBBR 的机器会抢占更多的带宽\u003c/mark\u003e\u003c/strong\u003e，造成不公平（unfaireness）；\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/better-bw-manage-with-ebpf/bbr-usage-considerations.png\" width=\"95%\" height=\"95%\"/\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eBBR 会触发\u003cstrong\u003e\u003cmark\u003e更高的 TCP 重传速率\u003c/mark\u003e\u003c/strong\u003e，这源自它\u003cstrong\u003e\u003cmark\u003e更加主动或激进的探测机制\u003c/mark\u003e\u003c/strong\u003e\n  （higher TCP retransmission rate due to more aggressive probing）；\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eBBRv2 致力于解决以上问题\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"5-总结及致谢\"\u003e5 总结及致谢\u003c/h1\u003e\n\n\u003ch2 id=\"51-问题回顾与总结\"\u003e5.1 问题回顾与总结\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003eK8s 带宽限速功能可以做地更好；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eCilium 的原生带宽限速功能（v1.12 GA）\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e基于 BPF+EDT 的高效实现\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e第一个支持 Pod 使用 BBR (及 socket pacing）的 CNI 插件\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n      \u003cli\u003e特别说明：\u003cstrong\u003e\u003cmark\u003e要实现这样的架构，只能用 eBPF\u003c/mark\u003e\u003c/strong\u003e（realizing such architecture only possible with eBPF）\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"52-致谢\"\u003e5.2 致谢\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003eVan Jacobson\u003c/li\u003e\n  \u003cli\u003eEric Dumazet\u003c/li\u003e\n  \u003cli\u003eVytautas Valancius\u003c/li\u003e\n  \u003cli\u003eStanislav Fomichev\u003c/li\u003e\n  \u003cli\u003eMartin Lau\u003c/li\u003e\n  \u003cli\u003eJohn Fastabend\u003c/li\u003e\n  \u003cli\u003eCilium, eBPF \u0026amp; netdev kernel community\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"6-cilium-限速方案存在的问题译注\"\u003e6 Cilium 限速方案存在的问题（译注）\u003c/h1\u003e\n\n\u003cp\u003eCilium 的限速功能\u003ca href=\"/blog/trip-large-scale-cloud-native-networking-and-security-with-cilium-ebpf/\"\u003e我们\u003c/a\u003e\n在 v1.10 就在用了，但是使用下来发现两个问题，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cdel\u003e启用 bandwidth manager 之后，Cilium 会 hardcode somaxconn、netdev_max_backlog 等内核参数，覆盖掉用户自己的内核调优；\u003c/del\u003e\n  \u003ca href=\"https://github.com/cilium/cilium/pull/22468\"\u003e2022.12 已解决\u003c/a\u003e\u003c/p\u003e\n\n    \u003cp\u003e例如，如果 node \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_max_backlog=8192\u003c/code\u003e，那 Cilium 启动之后，\n就会把它强制覆盖成 1000，导致在大流量场景因为宿主机这个配置太小而出现丢包。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e启用 bandwidth manager 再禁用时，并不会恢复到原来的 qdisc 配置\u003c/mark\u003e\u003c/strong\u003e，MQ/FQ 是残留的，导致大流量容器被限流（throttle）。\u003c/p\u003e\n\n    \u003cp\u003e例如，如果原来物理网卡使用的默认 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc，或者 bond 设备默认使用\n 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enoqueue\u003c/code\u003e，那启用再禁用之后，并不会恢复到原来的 qdisc 配置。残留 FQ 的一\n 个副作用就是\u003cstrong\u003e\u003cmark\u003e大流量容器的偶发网络延迟\u003c/mark\u003e\u003c/strong\u003e，因为 FQ 要保证 flow\n 级别的公平（而实际上很多场景下并不需要这个公平，总带宽不超就行了）。\u003c/p\u003e\n\n    \u003cp\u003e查看曾经启用 bandwidth manager，但现在已经禁用它的 node，可以看到 MQ/FQ 还在，\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show dev bond0\n qdisc mq 8042: root\n qdisc fq 0: parent 8042:10 limit 10000p flow_limit 100p buckets 1024 quantum 3028 initial_quantum 15140\n qdisc fq 0: parent 8042:f limit 10000p flow_limit 100p buckets 1024 quantum 3028 initial_quantum 15140\n ...\n qdisc fq 0: parent 8042:b limit 10000p flow_limit 100p buckets 1024 quantum 3028 initial_quantum 15140\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e是否发生过限流可以在 tc qdisc 统计中看到：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e qdisc show dev bond0\n qdisc fq 800b: root refcnt 2 limit 10000p flow_limit 100p buckets 1024 orphan_mask 1023 quantum 3028 initial_quantum 15140 refill_delay 40.0ms\n  Sent 1509456302851808 bytes 526229891 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 176, overlimits 0 requeues 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  backlog 3028b 2p requeues 0\n   15485 flows \u003cspan class=\"o\"\u003e(\u003c/span\u003e15483 inactive, 1 throttled\u003cspan class=\"o\"\u003e)\u003c/span\u003e, next packet delay 19092780 ns\n   2920858688 gc, 0 highprio, 28601458986 throttled, 6397 ns latency, 176 flows_plimit\n   6 too long pkts, 0 alloc errors\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e要恢复原来的配置，目前我们只能手动删掉 MQ/FQ。根据内核代码分析及实际测试，删除 qdisc 的操作是无损的，\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc del dev bond0 root\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show dev bond0\n qdisc noqueue 0: root refcnt 2\n qdisc clsact ffff: parent ffff:fff1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/traffic-control-from-queue-to-edt-zh/\"\u003e\u003cspan\u003e« [译] 流量控制（TC）五十年：从基于缓冲队列（Queue）到基于时间（EDT）的演进（Google, 2018）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cilium-tomorrow-networking-data-plane-zh/\"\u003e\u003cspan\u003e[译] Cilium 未来数据平面：支撑 100Gbit/s k8s 集群（KubeCon, 2022） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-10-30T00:00:00Z",
  "Author": "Arthur Chiao"
}