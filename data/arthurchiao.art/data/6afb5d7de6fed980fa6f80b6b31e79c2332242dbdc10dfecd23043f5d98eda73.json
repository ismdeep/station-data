{
  "Source": "arthurchiao.art",
  "Title": "OVS Deep Dive 6: Internal Port",
  "Link": "https://arthurchiao.art/blog/ovs-deep-dive-6-internal-port/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eOVS Deep Dive 6: Internal Port\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2017-03-08 | Last Update 2020-03-17\u003c/p\u003e\n  \n  \u003cp\u003eThis post makes an exploration into OVS \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"1-bridge\"\u003e1. Bridge\u003c/h2\u003e\n\n\u003cp\u003eA bridge is a self-learning L2 forwarding device.\n\u003ca href=\"https://en.wikipedia.org/wiki/IEEE_802.1D\"\u003eIEEE 802.1D\u003c/a\u003e describes the bridge\ndefinition.\u003c/p\u003e\n\n\u003cp\u003eBridge maintains a forwarding table, which stores \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e{src_mac, in_port}\u003c/code\u003e pairs,\nand forwards packets (more accurately, frames) based on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor example, when a packet with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac=ff:00:00:00:01\u003c/code\u003e enters the bridge\nthrough port 1 (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ein_port=1\u003c/code\u003e), the bridge learns that host \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eff:00:00:00:01\u003c/code\u003e\nconnected to it via port 1. Then it will add (if the entry is not cached yet) an\nentry \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac=ff:00:00:00:01, in_port=1\u003c/code\u003e into its forwarding table.  After\nthat, if a packet with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac=ff:00:00:00:01\u003c/code\u003e enters bridge, it decides that\nthis packet is intended for host \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eff:00:00:00:01\u003c/code\u003e, and that host is connected to\nit via port 1, so it should be forwarded to port 1.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/connect_via_bridge.jpg\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.1.1 Hosts connected by a bridge\u003c/p\u003e\n\n\u003cp\u003eFrom the forwarding process we could see, \u003cstrong\u003ea hypothetical bridge works entirely in L2\u003c/strong\u003e.\nBut in real environments, a bridge is always configured with an IP address.\nThis seems a paradox: \u003cstrong\u003ewhy we configure a L2 device with an IP address?\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eThe reason is that for real a bridge, it must provide some remote management\nabilities to be practically useful.\nSo there must be an access port that we could control the bridge (e.g.\nrestart) remotely.\u003c/p\u003e\n\n\u003cp\u003eAccess ports are IP based, so it is \u003cstrong\u003eL3 ports\u003c/strong\u003e. This is is different from\nother ports which just work in L2 for traffic forwarding - for the latter\nno IPs are configured on them, they are \u003cstrong\u003eL2 ports\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eL2 ports works in dataplane (DP), for traffic forwarding; L3 ports works in\ncontrol plane (CP), for management.\u003c/strong\u003e They are different physical ports.\u003c/p\u003e\n\n\u003ch2 id=\"2-linux-bridge\"\u003e2. Linux Bridge\u003c/h2\u003e\n\n\u003cp\u003eLinux bridge is a software bridge, it implements a subset of the ANSI/IEEE\n802.1d standard.  It manages both physical NICs on the host, as well as virutal\ndevices, e.g. tap devices.\u003c/p\u003e\n\n\u003cp\u003ePhysical port managed by Linux bridge are all dataplane ports (\u003cstrong\u003eL2 ports\u003c/strong\u003e),\nthey just forward packets inside the bridge. We’ve mentioned that L2 ports do\nnot have IPs configured on them.\u003c/p\u003e\n\n\u003cp\u003eSo a problem occurs when all the physical ports are added to the linux bridge:\n\u003cstrong\u003ethe host loses connection!\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eTo keep the host reachable, there are two solutions:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eleave at least one physical port as accessing port\u003c/li\u003e\n  \u003cli\u003euse virtual accessing port\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"21-solution-1-physical-access-port\"\u003e2.1 Solution 1: Physical Access Port\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/phy_access_port.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.2.1 Physical Access Port\u003c/p\u003e\n\n\u003cp\u003eIn this solution, a physical port is reserved for host accessing, and not\nconnected to Linux bridge. It will be configured with an IP (thus L3 port),\nand all CP traffic will be transmited through it. Other ports are connected\nto Linux bridge (L2 ports), for DP forwarding.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003epros:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eCP/DP traffic isolation\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003erobustness\u003c/p\u003e\n\n    \u003cp\u003eeven linux bridge misbehaves (e.g. crash), the host is still accessible\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003econs:\u003c/strong\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eresource under-utilized\u003c/p\u003e\n\n    \u003cp\u003ethe access port is dedicated for accessing, which is wasteful\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"22-solution-2-virtual-accessing-port\"\u003e2.2 Solution 2: Virtual Accessing Port\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/virtual_access_port.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.2.2 Virtual Access Port\u003c/p\u003e\n\n\u003cp\u003eIn this solution, a virtual port is created on the host, and configured with\nan IP address, used as accessing port. Since all physical ports are connected\nto Linux host, to make this accessing port reachable from outside, it has to\nconnected to Linux bridge, too!\u003c/p\u003e\n\n\u003cp\u003eThen, some triky things come.\u003c/p\u003e\n\n\u003cp\u003eFirst, CP traffic, will also be sent/received through DP ports, as\nphysical ports are the only places that could interact with outside, and all\nphysical ports are DP ports.\u003c/p\u003e\n\n\u003cp\u003eSecondly, all egress packets of this host, are with source MAC that is none of\nthe physical port MACs. For example, if you ping this host,\nthe ICPM reply packet will be sent out from one of the physical ports, \u003cstrong\u003ebut\u003c/strong\u003e,\nthe source MAC of this packet is not the MAC of the physical port via which it\nis sent out.\u003c/p\u003e\n\n\u003cp\u003eWe will verify this later. Now let’s continue to OVS - a more powerful software\nbridge.\u003c/p\u003e\n\n\u003ch2 id=\"3-ovs-internal-port\"\u003e3. OVS \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eOVS is more powerful bridge than linux bridge, but since it is\nstill a L2 bridge, some general bridge conventions it has to conform to.\u003c/p\u003e\n\n\u003cp\u003eAmong those basic rules, one is that it should provide the ability to hold an IP\nfor an OVS bridge: to be more clear, it should provide a similar functionality as\nLinux bridge’s virtual accessing port does. With this functionality, even if\nall physical port are added\nto OVS bridge, the host could still be accessible from outside (as we\ndiscussed in secion 2, without this, the host will\nlose connection).\u003c/p\u003e\n\n\u003cp\u003eOVS \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e is just for this purpose.\u003c/p\u003e\n\n\u003ch3 id=\"31-usage\"\u003e3.1 Usage\u003c/h3\u003e\n\n\u003cp\u003eWhen creating an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e on OVS bridge, an IP could be configured on it,\nand the host is accessible by this IP address.  Ordinary OVS users should not\nworry about the implementation details, they just need to know that \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal\nports\u003c/code\u003e act similar as linux tap devices.\u003c/p\u003e\n\n\u003cp\u003eCreate an internal port \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evlan1000\u003c/code\u003e on bridge \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebr0\u003c/code\u003e, and configure\nand IP on it:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eovs-vsctl add-port br0 vlan1000 \u003cspan class=\"nt\"\u003e--\u003c/span\u003e \u003cspan class=\"nb\"\u003eset \u003c/span\u003eInterface vlan1000 \u003cspan class=\"nb\"\u003etype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003einternal\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eifconfig vlan1000\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eifconfig vlan1000 \u0026lt;ip\u0026gt; netmask \u0026lt;mask\u0026gt; up\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"32-some-experiments\"\u003e3.2 Some Experiments\u003c/h3\u003e\n\n\u003cp\u003eWe have \u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e, and\nthe OVS bridge on \u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e looks like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eroot@hostA \u003cspan class=\"c\"\u003e# ovs-vsctl show\u003c/span\u003e\nce8cf3e9-6c97-4c83-9560-1082f1ae94e7\n    Bridge br-bond\n        Port br-bond\n            Interface br-bond\n                \u003cspan class=\"nb\"\u003etype\u003c/span\u003e: internal\n        Port \u003cspan class=\"s2\"\u003e\u0026#34;vlan1000\u0026#34;\u003c/span\u003e\n            tag: 1000\n            Interface \u003cspan class=\"s2\"\u003e\u0026#34;vlan1000\u0026#34;\u003c/span\u003e\n                \u003cspan class=\"nb\"\u003etype\u003c/span\u003e: internal\n        Port \u003cspan class=\"s2\"\u003e\u0026#34;bond1\u0026#34;\u003c/span\u003e\n            Interface \u003cspan class=\"s2\"\u003e\u0026#34;eth1\u0026#34;\u003c/span\u003e\n            Interface \u003cspan class=\"s2\"\u003e\u0026#34;eth0\u0026#34;\u003c/span\u003e\n    ovs_version: \u003cspan class=\"s2\"\u003e\u0026#34;2.3.1\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eTwo physical ports \u003cem\u003eeth0\u003c/em\u003e and \u003cem\u003eeth1\u003c/em\u003e is added to the bridge (bond), two internal\nports \u003cem\u003ebr-bond\u003c/em\u003e (the default one of this bridge, not used) and \u003cem\u003evlan1000\u003c/em\u003e (we\ncreated it).  We make \u003cem\u003evlan1000\u003c/em\u003e as the accessing port of this host by\nconfiguring an IP address on it:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eroot@hostA \u003cspan class=\"c\"\u003e# ifconfig vlan1000 10.18.138.168 netmask 255.255.255.0 up\u003c/span\u003e\n\nroot@hostA \u003cspan class=\"c\"\u003e# ifconfig vlan1000\u003c/span\u003e\nvlan1000  Link encap:Ethernet  HWaddr a6:f2:f7:d0:1d:e6  \n          inet addr:10.18.138.168  Bcast:10.18.138.255  Mask:255.255.255.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eping \u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e from another host \u003cstrong\u003e\u003cem\u003ehostB\u003c/em\u003e\u003c/strong\u003e (with IP 10.32.4.123), capture\n the packets on \u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e and show the MAC address\nof L2 frames:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eroot@hostA \u003cspan class=\"c\"\u003e# tcpdump -e -i vlan1000 \u0026#39;icmp\u0026#39;\u003c/span\u003e\n10:28:24.176777 64:f6:9d:5a:bd:13 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e a6:f2:f7:d0:1d:e6, 10.32.4.123   \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e 10.18.138.168: ICMP \u003cspan class=\"nb\"\u003eecho \u003c/span\u003erequest\n10:28:24.176833 a6:f2:f7:d0:1d:e6 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e aa:bb:cc:dd:ee:ff, 10.18.138.168 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e 10.32.4.123:   ICMP \u003cspan class=\"nb\"\u003eecho \u003c/span\u003ereply\n10:28:25.177262 64:f6:9d:5a:bd:13 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e a6:f2:f7:d0:1d:e6, 10.32.4.123   \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e 10.18.138.168: ICMP \u003cspan class=\"nb\"\u003eecho \u003c/span\u003erequest\n10:28:25.177294 a6:f2:f7:d0:1d:e6 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e aa:bb:cc:dd:ee:ff, 10.18.138.168 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e 10.32.4.123:   ICMP \u003cspan class=\"nb\"\u003eecho \u003c/span\u003ereply\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWe could see that the \u003cstrong\u003esource MAC (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea6:f2:f7:d0:1d:e6\u003c/code\u003e) of ICMP echo reply\npackets\u003c/strong\u003e is just the \u003cstrong\u003evlan1000’s address, not eth0 or eth1’s - although the\npackets will be sent out from either eth0, or eth1\u003c/strong\u003e. What this implies is that,\nfrom the outside view, \u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e is seen to have only one interface with\nMAC address \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea6:f2:f7:d0:1d:e6\u003c/code\u003e, and no matter how many physical ports are on\n\u003cstrong\u003e\u003cem\u003ehostA\u003c/em\u003e\u003c/strong\u003e, as long as they are managed by the OVS (or linux bridge), these\nphysical ports will never be seen from the outside.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/bridge_managed_host_outside_view.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.2.3 Outside L2/L3 View of Bridge Managed Host: Only L3 ports could be seen\u003c/p\u003e\n\n\u003ch3 id=\"33-implementation-todo-update\"\u003e3.3 Implementation (TODO: update)\u003c/h3\u003e\n\n\u003cp\u003eIn the underlying, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e is implemented through \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap\u003c/code\u003e interface.\u003c/p\u003e\n\n\u003cp\u003eQuota some info from [1,2,3]:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eThe internal interface and port in each bridge is both an implementation\nrequirem ent and exists for historical reasons relating to the implementation of\nLinux bridging module.\n\nThe purpose is to hold the IP for the bridge itself (just like some physical\nbridges do). This is also useful in cases where a bridge has a physical\ninterface that would normally have its own IP. Since assigning a port to an IP\nwouldn\u0026#39;t happen in a physical bridge, assigning an IP to the physical interface\nwould be incorrect, as packets would stop at the port and not be passed across\nthe bridge.\n\nA physical Ethernet device that is part of an Open vSwitch bridge should not\nhave an IP address. You can restore functionality by moving the IP address to an\nOpen vSwitch \u0026#34;internal\u0026#34; device, such as the network device named after the\nbridge itself.\n\nThere is no compelling reason why Open vSwitch must work this way. However, this\nis the way that the Linux kernel bridge module has always worked, so it\u0026#39;s a\nmodel that those accustomed to Linux bridging are already used to. Also, the\nmodel that most people expect is not implementable without kernel changes on all\nthe versions of Linux that Open vSwitch supports.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"4-advanced-usage-interanl-port-as-container-vnic\"\u003e4. Advanced Usage: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einteranl port\u003c/code\u003e as Container vNIC\u003c/h2\u003e\n\n\u003cp\u003eYou could create multiple internal ports on one OVS bridge, and more\nimportantly, since \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e is L3-accessible from outside and\nsocket-based (thus kernel stack based), it could be\nused as virtual NIC, for VM or containers.\u003c/p\u003e\n\n\u003cp\u003eAs containers have their own network namespaces, we could not connect container\nto OVS directly, the latter works in the default namespace. The typical way to\nsolve this is to create a veth pair: move one end to container, and the other\n end attached to OVS.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/container_default_connection.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.4.1 Connect to OVS via veth pair\u003c/p\u003e\n\n\u003cp\u003eThis is simple and straitforward in concept, but will suffer from performance\nissues. Could container\nbe connected to OVS directly? The answer is yes! We will use \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e to\naccomplish this.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/ovs-deep-dive/container_connect_via_ovs_internal_port.png\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig.4.2 Connect to OVS via OVS Internal Port\u003c/p\u003e\n\n\u003ch3 id=\"41-connect-container-to-ovs-via-ovs-internal-port\"\u003e4.1 Connect container to OVS via OVS Internal Port\u003c/h3\u003e\n\n\u003cp\u003eThe main steps are as follows:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eget the container’s network namespace, e.g. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens1\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003ecreate an OVS internal port e.g. with name \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap_1\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003emove \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap_1\u003c/code\u003e from default namespace to container’s namespace \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens1\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003edisable the default network deive in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens1\u003c/code\u003e, mostly probably, this is\nnamed \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003econfigure IP for \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etap_1\u003c/code\u003e, set it as the default network device of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens1\u003c/code\u003e, add\ndefault route\u003c/li\u003e\n  \u003cli\u003eFINISH\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eI encapsulated the above procedures into scripts, here is the steps with this\nscripts:\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003econnect container to ovs via ovs \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einternal port\u003c/code\u003e\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e     |------------------------|    |------------------------|\n     |       container1       |    |       container2       |\n     |                        |    |                        |\n     |   eth0   tap1  lo      |    |   eth0   tap2  lo      |\n     |-----------|------------|    |-----------|------------|\n                 |                             |\n                 |                             |  container\u003cspan class=\"s1\"\u003e\u0026#39;s network namespace\n-----------------|-----------------------------|------------------------------\n                 |                             |  default network namespace\n                 |                             |\n                 ---------------OVS-------------\n                                 |\n                               ------\n                              /      \\\n                             |        |\n                 (physical) eth0      eth1 (physical)\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# 1. create two containers\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./run-containers.sh centos_1 centos_2\n\n\u003cspan class=\"c\"\u003e# 2. show container netns IDs, we will use these later\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./expose-container-netns.sh centos_1\n\u0026lt;netns1\u0026gt;\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./expose-container-netns.sh centos_2\n\u0026lt;netns2\u0026gt;\n\n\u003cspan class=\"c\"\u003e# 3. add a tap device to each container, the tap is on OVS and has type=internal\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./add-tap-to-container.sh centos_1 tap1 br0\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./add-tap-to-container.sh centos_2 tap2 br0\n\n\u003cspan class=\"c\"\u003e# 4. configure ip address, add default route\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns1\u0026gt; ifconfig tap1 \u0026lt;ip1\u0026gt; netmask \u0026lt;netmask\u0026gt; up\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns1\u0026gt; route add default gw \u0026lt;gw\u0026gt; dev tap1\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns2\u0026gt; ifconfig tap2 \u0026lt;ip2\u0026gt; netmask \u0026lt;netmask\u0026gt; up\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns2\u0026gt; route add default gw \u0026lt;gw\u0026gt; dev tap2\n\n\u003cspan class=\"c\"\u003e# 5. disable eth0\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns1\u0026gt; ifconfig eth0 down\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip netns \u003cspan class=\"nb\"\u003eexec\u003c/span\u003e \u0026lt;netns2\u0026gt; ifconfig eth0 down\n\n\u003cspan class=\"c\"\u003e# 6. verify connectivity\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./attach-container.sh centos_1\nroot@\u0026lt;centos_1\u0026gt;#: ping \u0026lt;centos_2 ip\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cstrong\u003eUPDATE\u003c/strong\u003e (2020.03): explicitly exposing container netns is cumbersome,\ninstead, you could achieve the same effect as step 4 \u0026amp; 5 with tool \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensenter\u003c/code\u003e, see\nmy later post \u003ca href=\"/blog/cilium-network-topology-on-aws/\"\u003eCilium Network Topology and Traffic Path on AWS\u003c/a\u003e\nfor an example.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"42-performance-comparison-todo-update\"\u003e4.2 Performance Comparison (TODO: update)\u003c/h3\u003e\n\n\u003cp\u003eConnect to OVS via internal port achieves (\u003cstrong\u003e\u003cem\u003eslightly?\u003c/em\u003e\u003c/strong\u003e) better performance\nthan via veth-pair.\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003ehttps://ask.openstack.org/en/question/4276/what-is-the-internal-interface-and-port-for-on-openvswitch/\u003c/li\u003e\n  \u003cli\u003ehttps://mail.openvswitch.org/pipermail/ovs-discuss/2013-August/030855.html\u003c/li\u003e\n  \u003cli\u003ehttp://blog.scottlowe.org/2012/10/30/running-host-management-on-open-vswitch/\u003c/li\u003e\n  \u003cli\u003ehttps://wiki.linuxfoundation.org/networking/bridge\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"appendix-scripts-used-in-this-post\"\u003eAppendix: Scripts used in this post\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/assets/img/ovs-deep-dive/run-containers.sh\"\u003erun-containers.sh\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/assets/img/ovs-deep-dive/add-tap-to-container.sh\"\u003eadd-tap-to-container.sh\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/assets/img/ovs-deep-dive/expose_container_netns.sh\"\u003eexpose-container-netns.sh\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/assets/img/ovs-deep-dive/attach-container.sh\"\u003eattach-container.sh\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/ovs-deep-dive-5-datapath-tx-offloading/\"\u003e\u003cspan\u003e« OVS Deep Dive 5: Datapath and TX Offloading\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/x86-asm-guide-zh/\"\u003e\u003cspan\u003e[译] 简明 x86 汇编指南（2017） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2017-03-08T00:00:00Z",
  "Author": "Arthur Chiao"
}