{
  "Source": "arthurchiao.art",
  "Title": "Linux 服务器功耗与性能管理（二）：几个内核子系统的设计（2024）",
  "Link": "https://arthurchiao.art/blog/linux-cpu-2-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux 服务器功耗与性能管理（二）：几个内核子系统的设计（2024）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2024-02-15 | Last Update 2024-02-15\u003c/p\u003e\n  \n  \u003cp\u003e整理一些 Linux 服务器性能相关的 CPU 硬件基础及内核子系统知识。\u003c/p\u003e\n\n\u003cp\u003e水平有限，文中不免有错误或过时之处，请酌情参考。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-1-zh/\"\u003eLinux 服务器功耗与性能管理（一）：CPU 硬件基础（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-2-zh/\"\u003eLinux 服务器功耗与性能管理（二）：几个内核子系统的设计（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-3-zh/\"\u003eLinux 服务器功耗与性能管理（三）：cpuidle 子系统的实现（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-4-zh/\"\u003eLinux 服务器功耗与性能管理（四）：监控、配置、调优（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-5-zh/\"\u003eLinux 服务器功耗与性能管理（五）：问题讨论（2024）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-cpu-相关的内核子系统\" id=\"markdown-toc-1-cpu-相关的内核子系统\"\u003e1 CPU 相关的内核子系统\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-调度器时分复用--任务调度--sched\" id=\"markdown-toc-11-调度器时分复用--任务调度--sched\"\u003e1.1 调度器：时分复用 + 任务调度 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esched\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-有任务用哪个频率执行任务-cpufreq\" id=\"markdown-toc-13-有任务用哪个频率执行任务-cpufreq\"\u003e1.3 有任务：用哪个频率执行任务？—— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpufreq\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-无任务执行轻量级占坑程序--idle-task\" id=\"markdown-toc-14-无任务执行轻量级占坑程序--idle-task\"\u003e1.4 无任务：执行轻量级占坑程序 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle task\u003c/code\u003e\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#141-直接降低电压和频率节能\" id=\"markdown-toc-141-直接降低电压和频率节能\"\u003e1.4.1 直接降低电压和频率，节能\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#142-仍然全速运行保持最低唤醒延迟\" id=\"markdown-toc-142-仍然全速运行保持最低唤醒延迟\"\u003e1.4.2 仍然全速运行，保持最低唤醒延迟\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#143-动态降低电压和频率节能--cpuidle-和-c-states\" id=\"markdown-toc-143-动态降低电压和频率节能--cpuidle-和-c-states\"\u003e1.4.3 动态降低电压和频率，节能 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ec-states\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-idle-loop-模式之三空闲时间管理--cpuidle\" id=\"markdown-toc-15-idle-loop-模式之三空闲时间管理--cpuidle\"\u003e1.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle loop\u003c/code\u003e 模式之三：空闲时间管理 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#16-cpuidle--响应延迟保证电源管理服务等级--pm-qos\" id=\"markdown-toc-16-cpuidle--响应延迟保证电源管理服务等级--pm-qos\"\u003e1.6 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e + 响应延迟保证：电源管理服务等级 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePM QoS\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#17-小结各子系统的关系图\" id=\"markdown-toc-17-小结各子系统的关系图\"\u003e1.7 小结：各子系统的关系图\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-cpu-频率管理子系统cpufreq调节运行任务时的-p-state\" id=\"markdown-toc-2-cpu-频率管理子系统cpufreq调节运行任务时的-p-state\"\u003e2 CPU 频率管理子系统（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpufreq\u003c/code\u003e）：调节运行任务时的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ep-state\u003c/code\u003e\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-原理cpu-performancefrequency-scaling\" id=\"markdown-toc-21-原理cpu-performancefrequency-scaling\"\u003e2.1 原理：CPU performance/frequency scaling\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-架构governordriver\" id=\"markdown-toc-22-架构governordriver\"\u003e2.2 架构：governor+driver\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#governors\" id=\"markdown-toc-governors\"\u003egovernors\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#drivers\" id=\"markdown-toc-drivers\"\u003edrivers\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-配置\" id=\"markdown-toc-23-配置\"\u003e2.3 配置\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-查看两台具体-node\" id=\"markdown-toc-24-查看两台具体-node\"\u003e2.4 查看两台具体 node\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#241-intel-cpu-node\" id=\"markdown-toc-241-intel-cpu-node\"\u003e2.4.1 Intel CPU node\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#242-amd-cpu-node\" id=\"markdown-toc-242-amd-cpu-node\"\u003e2.4.2 AMD CPU node\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-idle-task没有-runnable-tasks-时占坑\" id=\"markdown-toc-3-idle-task没有-runnable-tasks-时占坑\"\u003e3 idle task：没有 runnable tasks 时占坑\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-idle-task-历史\" id=\"markdown-toc-31-idle-task-历史\"\u003e3.1 idle task 历史\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-linux-idle-task-设计\" id=\"markdown-toc-32-linux-idle-task-设计\"\u003e3.2 Linux idle task 设计\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-实现idle-loop\" id=\"markdown-toc-33-实现idle-loop\"\u003e3.3 实现：idle loop\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-运行时\" id=\"markdown-toc-34-运行时\"\u003e3.4 运行时\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#341-1-号进程pid1\" id=\"markdown-toc-341-1-号进程pid1\"\u003e3.4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 号进程（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#342-0-号进程pid0\" id=\"markdown-toc-342-0-号进程pid0\"\u003e3.4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 号进程（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=0\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#343-idle-task0-号进程的一部分\" id=\"markdown-toc-343-idle-task0-号进程的一部分\"\u003e3.4.3 idle task：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 号进程的一部分\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-从-idle-task-进入-c-state-管理逻辑\" id=\"markdown-toc-35-从-idle-task-进入-c-state-管理逻辑\"\u003e3.5 从 idle task 进入 c-state 管理逻辑\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-cpu-空闲管理子系统cpudile空闲时如何节能c-state\" id=\"markdown-toc-4-cpu-空闲管理子系统cpudile空闲时如何节能c-state\"\u003e4 CPU 空闲管理子系统（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpudile\u003c/code\u003e）：空闲时如何节能（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ec-state\u003c/code\u003e）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-区分不同的-cpu-空闲级别引入-c-state-idle-state\" id=\"markdown-toc-41-区分不同的-cpu-空闲级别引入-c-state-idle-state\"\u003e4.1 区分不同的 CPU 空闲级别：引入 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ec-state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e (idle state)\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#411-acpi-p-states--c-states\" id=\"markdown-toc-411-acpi-p-states--c-states\"\u003e4.1.1 ACPI p-states \u0026amp; c-states\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#412-c-state-定义\" id=\"markdown-toc-412-c-state-定义\"\u003e4.1.2 C-State 定义\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#413-和-p-state-的区别\" id=\"markdown-toc-413-和-p-state-的区别\"\u003e4.1.3 和 p-state 的区别\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#414-定义不同-idle-状态--c-states-的决定因素\" id=\"markdown-toc-414-定义不同-idle-状态--c-states-的决定因素\"\u003e4.1.4 定义不同 idle 状态 / c-states 的决定因素\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-如何选择-c-stategovernor--driver\" id=\"markdown-toc-42-如何选择-c-stategovernor--driver\"\u003e4.2 如何\u003cstrong\u003e\u003cmark\u003e选择 c-state\u003c/mark\u003e\u003c/strong\u003e：governor + driver\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#421-为什么会有这么多-governors\" id=\"markdown-toc-421-为什么会有这么多-governors\"\u003e4.2.1 为什么会有这么多 governors？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#422-governor\" id=\"markdown-toc-422-governor\"\u003e4.2.2 governor\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#menu-governor\" id=\"markdown-toc-menu-governor\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emenu\u003c/code\u003e governor\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#haltpoll\" id=\"markdown-toc-haltpoll\"\u003ehaltpoll\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#ladder\" id=\"markdown-toc-ladder\"\u003eladder\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#teo-timer-events-oriented\" id=\"markdown-toc-teo-timer-events-oriented\"\u003eteo (Timer Events Oriented)\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#423-driver\" id=\"markdown-toc-423-driver\"\u003e4.2.3 driver\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-实地查看两台-linux-node\" id=\"markdown-toc-43-实地查看两台-linux-node\"\u003e4.3 实地查看两台 Linux node\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#431-intel-cpu-node\" id=\"markdown-toc-431-intel-cpu-node\"\u003e4.3.1 Intel CPU node\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#432-amd-cpu-node\" id=\"markdown-toc-432-amd-cpu-node\"\u003e4.3.2 AMD CPU node\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#433-内核启动日志\" id=\"markdown-toc-433-内核启动日志\"\u003e4.3.3 内核启动日志\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-cpu-功耗管理pmqospm_qos保证响应时间\" id=\"markdown-toc-5-cpu-功耗管理pmqospm_qos保证响应时间\"\u003e5 CPU 功耗管理（PM）QoS：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epm_qos\u003c/code\u003e，保证响应时间\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-解决的问题\" id=\"markdown-toc-51-解决的问题\"\u003e5.1 解决的问题\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-原理\" id=\"markdown-toc-52-原理\"\u003e5.2 原理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-例子\" id=\"markdown-toc-53-例子\"\u003e5.3 例子\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-系统定时器timer对空闲管理的影响\" id=\"markdown-toc-6-系统定时器timer对空闲管理的影响\"\u003e6 系统定时器（timer）对空闲管理的影响\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-经典方式scheduler-tick固定-hz\" id=\"markdown-toc-61-经典方式scheduler-tick固定-hz\"\u003e6.1 经典方式：scheduler tick（固定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eHZ\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-改进tickless-mode-nohz\" id=\"markdown-toc-62-改进tickless-mode-nohz\"\u003e6.2 改进：tickless mode (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enohz\u003c/code\u003e)\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-再改进-adaptive-tick\" id=\"markdown-toc-63-再改进-adaptive-tick\"\u003e6.3 再改进 adaptive tick\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-cpu-相关的内核子系统\"\u003e1 CPU 相关的内核子系统\u003c/h1\u003e\n\n\u003ch2 id=\"11-调度器时分复用--任务调度--sched\"\u003e1.1 调度器：时分复用 + 任务调度 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esched\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e如下图所示，内核给每个 CPU 创建一个\u003cstrong\u003e\u003cmark\u003e任务队列\u003c/mark\u003e\u003c/strong\u003e或称运行队列（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003erun queue\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e），\n根据算法（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCFS\u003c/code\u003e）将 runnable 任务依次放到 CPU 上执行，这个过程就称为调度。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cfs-design-and-implementation/cfs-rq-sched-entity.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eLinux kernel scheduler: CFS\n\u003ca href=\"https://medium.com/@maxwell9215/cfs-bandwidth-control-warmup-b03af4cc1cc4\"\u003eImage source\u003c/a\u003e\n\u003c/p\u003e\n\n\u003cp\u003e本质上就是一个时分复用系统。\u003c/p\u003e\n\n\u003cp\u003e更多信息：\u003ca href=\"/blog/linux-cfs-design-and-implementation-zh/\"\u003e\u003cmark\u003eLinux CFS 调度器：原理、设计与内核实现\u003c/mark\u003e（2023）\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"13-有任务用哪个频率执行任务-cpufreq\"\u003e1.3 有任务：用哪个频率执行任务？—— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpufreq\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eCPU 有任务需要执行时，该以哪个频率/电压来执行呢？\n这里就需要一个管理组件，它的主要功能就是\u003cstrong\u003e\u003cmark\u003e管理 CPU 执行任务时所用的频率/电压\u003c/mark\u003e\u003c/strong\u003e，\n回忆上一篇，这个功能其实就是为 CPU 选择一个合适的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ep-state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eLinux 内核中，对应的就是 cpufreq 子系统。\u003c/p\u003e\n\n\u003ch2 id=\"14-无任务执行轻量级占坑程序--idle-task\"\u003e1.4 无任务：执行轻量级占坑程序 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle task\u003c/code\u003e\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e事实证明，\u003cstrong\u003e\u003cmark\u003e什么都不做，比大家想象中要复杂地多\u003c/mark\u003e\u003c/strong\u003e\n（Doing nothing, it turns out, is more complicated than one might think） [5].\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e如果 run queue 中没有 runnable tasks，CPU 无事可做，内核调度器该做什么？\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e从原理来说，非常简单。\u003cstrong\u003e\u003cmark\u003e产品经理：什么都不做\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e从实现来说，非常模糊。\u003cstrong\u003e\u003cmark\u003e程序员：“什么都不做”的代码怎么写？\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e开发 leader 理解一下需求，从中翻译一下：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e先保证一个目标：有任务变成 runnable 时（比如等到了键盘输入），能够恢复调度执行 ——\n这决定了内核不能完全退出，比如至少要能主动或被动的响应系统事件；\u003c/li\u003e\n      \u003cli\u003e在保证以上目标的前提下，内核做的事情越少越好 —— 节能减排，延迟处理器使用寿命，降本增效。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e最终方案：引入一个特殊任务 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle task\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（很多资料中也叫 idle loop），\n没有其他任务可调度时，就调度执行它。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e从功能上来说，可以认为是一个优先级最低的占坑任务。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e从实现来说，idle task 里面\u003cstrong\u003e\u003cmark\u003e做什么都可以\u003c/mark\u003e\u003c/strong\u003e —— 反正这时候这个 CPU 上没有任何其他 runnable tasks。\n根据目的的不同，具体实现可以分为两大类：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e节能；\u003c/li\u003e\n      \u003cli\u003e低延迟。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e区分 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e\u0026#34;idle task\u0026#34;\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 和 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e\u0026#34;task idle\u0026#34;\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n  \u003ctable\u003e\n    \u003cthead\u003e\n      \u003ctr\u003e\n        \u003cth style=\"text-align: left\"\u003eidle task\u003c/th\u003e\n        \u003cth style=\"text-align: left\"\u003etask idle\u003c/th\u003e\n      \u003c/tr\u003e\n    \u003c/thead\u003e\n    \u003ctbody\u003e\n      \u003ctr\u003e\n        \u003ctd style=\"text-align: left\"\u003e一个\u003cstrong\u003e\u003cmark\u003e特殊进程\u003c/mark\u003e\u003c/strong\u003e（任务）\u003c/td\u003e\n        \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e普通进程\u003c/mark\u003e\u003c/strong\u003e的一种特殊\u003cstrong\u003e\u003cmark\u003e状态\u003c/mark\u003e\u003c/strong\u003e（例如在等待 IO），在这种状态下不需要 CPU 来执行\u003c/td\u003e\n      \u003c/tr\u003e\n    \u003c/tbody\u003e\n  \u003c/table\u003e\n\n  \u003cp\u003e在 Linux 中，如果\u003cstrong\u003e\u003cmark\u003e除了 \u0026#34;idle task\u0026#34;\u003c/mark\u003e\u003c/strong\u003e 已经没有其他任务可运行时，\n这个 CPU 就是空闲的，即 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle CPU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"141-直接降低电压和频率节能\"\u003e1.4.1 直接降低电压和频率，节能\u003c/h3\u003e\n\n\u003cp\u003e这是主流行为，idle task 里面实现某种降低功耗的逻辑，避免 CPU 空转，节能。\n典型配置如 Linux 内核启动项 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle=halt\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种方式的缺点是从较低功耗（某种程度的睡眠状态）唤醒时有一定的延迟。\u003c/p\u003e\n\n\u003ch3 id=\"142-仍然全速运行保持最低唤醒延迟\"\u003e1.4.2 仍然全速运行，保持最低唤醒延迟\u003c/h3\u003e\n\n\u003cp\u003e这类场景比较特殊，比如追求极低延迟的高频交易场景。\n没有任务时仍然\u003cstrong\u003e\u003cmark\u003e让 CPU 保持电压和频率空转\u003c/mark\u003e\u003c/strong\u003e，不要降压降频，\n这样有任务变成 runnable 时可以立即切换执行，延迟最低。\n在 Linux 启动项中，对应 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle=poll\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 配置，后面几篇我们还会多次看到（尤其是这种配置的潜在风险）。\u003c/p\u003e\n\n\u003ch3 id=\"143-动态降低电压和频率节能--cpuidle-和-c-states\"\u003e1.4.3 动态降低电压和频率，节能 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ec-states\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e通过一个单独的子系统（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e）来实现不同级别的节能（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ec-states\u003c/code\u003e）。\u003c/p\u003e\n\n\u003cp\u003e这里注意和 turbo freq 的区别：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eturbo 是部分 CORE 空闲时，\u003cstrong\u003e\u003cmark\u003e有任务在运行的 CORE\u003c/mark\u003e\u003c/strong\u003e 可以\u003cstrong\u003e\u003cmark\u003e动态超频\u003c/mark\u003e\u003c/strong\u003e，\n目的是提高这几个有任务在运行的 CORE 的性能；\u003c/li\u003e\n  \u003cli\u003ecpuidle/c-states 是当前 CORE/CPU \u003cstrong\u003e\u003cmark\u003e没有任务要运行\u003c/mark\u003e\u003c/strong\u003e（空闲 CPU），通过\u003cstrong\u003e\u003cmark\u003e动态降频\u003c/mark\u003e\u003c/strong\u003e来节能。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"15-idle-loop-模式之三空闲时间管理--cpuidle\"\u003e1.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle loop\u003c/code\u003e 模式之三：空闲时间管理 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e再稍微展开介绍下上面第三种：\n队列中如果没有 runnable task，比如所有任务都在等待 IO 事件。\n这时候是没有任务需要 CPU 的，因此称为 \u003cstrong\u003e\u003cmark\u003eCPU 空闲状态\u003c/mark\u003e\u003c/strong\u003e（idle states）。\u003c/p\u003e\n\n\u003cp\u003e空闲状态的下 CPU 该怎么管理，也是一门学问，因此内核又引入了另外一个子系统：\ncpu 空闲时间管理子系统 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpudile\u003c/code\u003e。具体工作内容后面介绍。\u003c/p\u003e\n\n\u003ch2 id=\"16-cpuidle--响应延迟保证电源管理服务等级--pm-qos\"\u003e1.6 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e + 响应延迟保证：电源管理服务等级 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePM QoS\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e如果没有任务时 cpuidle 选择进入某种低电压/低频率的节能模式，当有任务到来时，\n它的唤醒时间可能无法满足要求。针对这种情况，内核又引入了功耗管理或称\u003cstrong\u003e\u003cmark\u003e电源管理 服务等级\u003c/mark\u003e\u003c/strong\u003e\n（PM QoS）子系统。\u003c/p\u003e\n\n\u003cp\u003ePM QoS 允许应用注册一个最大 latency，内核确保唤醒时间不会高于这个阈值，\n在尽量节能的同时实现快速响应。\n具体原理也在后面单独章节介绍。\u003c/p\u003e\n\n\u003ch2 id=\"17-小结各子系统的关系图\"\u003e1.7 小结：各子系统的关系图\u003c/h2\u003e\n\n\u003cp\u003e最后用一张图梳理一下前面涉及到的各内核子系统：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cpu/cpu-kernel-subsystems.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Relationship of some CPU-related kernel subsystems and tasks\u003c/p\u003e\n\n\u003cp\u003e接下来深入到几个子系统的内部看看。\u003c/p\u003e\n\n\u003ch1 id=\"2-cpu-频率管理子系统cpufreq调节运行任务时的-p-state\"\u003e2 CPU 频率管理子系统（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpufreq\u003c/code\u003e）：调节运行任务时的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ep-state\u003c/code\u003e\u003c/h1\u003e\n\n\u003ch2 id=\"21-原理cpu-performancefrequency-scaling\"\u003e2.1 原理：CPU performance/frequency scaling\u003c/h2\u003e\n\n\u003cp\u003e处理器硬件有接口暴露给内核，可以设置 CPU 的运行 frequency/voltage，或者说选择不同的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eP-state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003e一般来说，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e内核调度器会在一些重要事件发生时（例如新建或销毁进程），\n或者定期（every iteration of the scheduler tick）回调 cpufreq update 方法，更新 cpufreq 状态。\u003c/li\u003e\n  \u003cli\u003ecpufreq 根据状态状态信息，可以动态调整 p-state 级别。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这个功能称为 CPU performance scaling or CPU frequency scaling。\u003c/p\u003e\n\n\u003cp\u003e内核文档 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/admin-guide/pm/cpufreq.rst\"\u003eCPU Performance Scaling\u003c/a\u003e [9]\n有详细介绍。\u003c/p\u003e\n\n\u003ch2 id=\"22-架构governordriver\"\u003e2.2 架构：governor+driver\u003c/h2\u003e\n\n\u003cp\u003e代码分为三块：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ethe core：模型实现和状态维护；\u003c/li\u003e\n  \u003cli\u003escaling governors：不同的管理算法；\u003c/li\u003e\n  \u003cli\u003escaling drivers：与硬件对接的驱动。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"governors\"\u003egovernors\u003c/h3\u003e\n\n\u003cp\u003e几个比较重要的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eperformance：性能优先\u003c/li\u003e\n  \u003cli\u003epowersave：节能优先\u003c/li\u003e\n  \u003cli\u003euserspace：折中\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"drivers\"\u003edrivers\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eacpi-cpufreq\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eintel_pstate\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"23-配置\"\u003e2.3 配置\u003c/h2\u003e\n\n\u003cp\u003e在 sysfs 目录，每个 CPU 一个目录 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/sys/devices/system/cpu/cpu{id}/cpufreq/\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e /sys/devices/system/cpu/cpu0/cpufreq/\naffected_cpus                cpuinfo_min_freq             related_cpus                 scaling_cur_freq             scaling_governor             scaling_min_freq\ncpuinfo_max_freq             cpuinfo_transition_latency   scaling_available_governors  scaling_driver               scaling_max_freq             scaling_setspeed\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"24-查看两台具体-node\"\u003e2.4 查看两台具体 node\u003c/h2\u003e\n\n\u003ch3 id=\"241-intel-cpu-node\"\u003e2.4.1 Intel CPU node\u003c/h3\u003e\n\n\u003cp\u003e先来看一台 Intel CPU 的机器，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eintel node\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower frequency-info\nanalyzing CPU 0:\n  driver: intel_pstate                                                \u003cspan class=\"c\"\u003e# 驱动，源码在内核树\u003c/span\u003e\n  CPUs which run at the same hardware frequency: 0\n  CPUs which need to have their frequency coordinated by software: 0\n  maximum transition latency:  Cannot determine or is not supported.\n  hardware limits: 800 MHz - 3.40 GHz                                 \u003cspan class=\"c\"\u003e# 硬件支持的频率范围\u003c/span\u003e\n  available cpufreq governors: performance powersave\n  current policy: frequency should be within 800 MHz and 3.40 GHz.\n                  The governor \u003cspan class=\"s2\"\u003e\u0026#34;performance\u0026#34;\u003c/span\u003e may decide which speed to use within this range.\n  current CPU frequency: Unable to call hardware\n  current CPU frequency: 2.60 GHz \u003cspan class=\"o\"\u003e(\u003c/span\u003easserted by call to kernel\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  boost state support:\n    Supported: \u003cspan class=\"nb\"\u003eyes\n    \u003c/span\u003eActive: \u003cspan class=\"nb\"\u003eyes\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003edriver：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eintel_pstate\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，这个 driver 比较特殊，它绕过了 governor layer，直接在驱动里实现了频率调整算法 [9]。\u003c/li\u003e\n  \u003cli\u003eCPU 频率范围硬限制：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e800MHz - 3.4GHz\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e可用 cpufreq governors：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperformance\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epowersave\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e正在使用的 cpufreq governor：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eperformance\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e当前策略\u003c/mark\u003e\u003c/strong\u003e：\n    \u003cul\u003e\n      \u003cli\u003e频率范围运行在 800MHz - 3.4GHz 之间；\u003c/li\u003e\n      \u003cli\u003e具体频率由 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperformance\u003c/code\u003e governor 决定。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e当前 CPU 的频率：\n    \u003cul\u003e\n      \u003cli\u003e从硬件未获取到；\u003c/li\u003e\n      \u003cli\u003e从内核获取到的是 2.6GHz\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e是否支持 boost，即 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eturbo frequency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n    \u003cul\u003e\n      \u003cli\u003e支持\u003c/li\u003e\n      \u003cli\u003e当前已经开启\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"242-amd-cpu-node\"\u003e2.4.2 AMD CPU node\u003c/h3\u003e\n\n\u003cp\u003e再看一个 AMD CPU node：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eamd node\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower frequency-info\nanalyzing CPU 0:\n  driver: acpi-cpufreq                                                \u003cspan class=\"c\"\u003e# 驱动，源码在内核树\u003c/span\u003e\n  CPUs which run at the same hardware frequency: 0\n  CPUs which need to have their frequency coordinated by software: 0\n  maximum transition latency:  Cannot determine or is not supported.\n  hardware limits: 1.50 GHz - 3.74 GHz                                \u003cspan class=\"c\"\u003e# 硬件支持的频率范围\u003c/span\u003e\n  available frequency steps:  2.80 GHz, 2.10 GHz, 1.50 GHz\n  available cpufreq governors: conservative ondemand userspace powersave performance schedutil\n  current policy: frequency should be within 1.50 GHz and 2.80 GHz.\n                  The governor \u003cspan class=\"s2\"\u003e\u0026#34;performance\u0026#34;\u003c/span\u003e may decide which speed to use within this range.\n  current CPU frequency: 2.80 GHz \u003cspan class=\"o\"\u003e(\u003c/span\u003easserted by call to hardware\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  boost state support:\n    Supported: \u003cspan class=\"nb\"\u003eyes\n    \u003c/span\u003eActive: \u003cspan class=\"nb\"\u003eyes\n    \u003c/span\u003eBoost States: 0\n    Total States: 3\n    Pstate-P0:  2800MHz\n    Pstate-P1:  2100MHz\n    Pstate-P2:  1500MHz\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003edriver：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eacpi-cpufreq\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003eCPU 频率范围硬限制：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.5GHz - 3.74GHz\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e可用的频率步长：1.5G 2.1G 2.8G\u003c/li\u003e\n  \u003cli\u003e可用 cpufreq governors：conservative ondemand userspace powersave performance schedutil\u003c/li\u003e\n  \u003cli\u003e正在使用的 cpufreq governor：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eperformance\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e当前策略\u003c/mark\u003e\u003c/strong\u003e：\n    \u003cul\u003e\n      \u003cli\u003e频率范围运行在 1.5GHz - 2.8GHz 之间；\u003c/li\u003e\n      \u003cli\u003e具体频率由 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperformance\u003c/code\u003e governor 决定。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e当前 CPU 的频率：\n    \u003cul\u003e\n      \u003cli\u003e从硬件获取到 2.8GHz；\u003c/li\u003e\n      \u003cli\u003e从内核获取到的是 2.6GHz\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e是否支持 boost，即 turbo\n    \u003cul\u003e\n      \u003cli\u003e支持\u003c/li\u003e\n      \u003cli\u003e当前已经开启\u003c/li\u003e\n      \u003cli\u003e支持的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ep-state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 频率\n        \u003cul\u003e\n          \u003cli\u003ePstate-P0:  2800MHz\u003c/li\u003e\n          \u003cli\u003ePstate-P1:  2100MHz\u003c/li\u003e\n          \u003cli\u003ePstate-P2:  1500MHz\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"3-idle-task没有-runnable-tasks-时占坑\"\u003e3 idle task：没有 runnable tasks 时占坑\u003c/h1\u003e\n\n\u003cp\u003e如果调度队列（rq）为空，或者队列中的所有任务都处于 non runnable 状态，我们就称这个 CPU 是空闲的，\n接下来就可以进入某个 c-state 以便降低功耗。从设计上来说，这里可以有两种选择：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e将进入 c-state 的逻辑直接暴露给调度器，由调度器直接控制；\u003c/li\u003e\n  \u003cli\u003e将进入 c-state 的逻辑封装成一个标准的任务（task），放到调度队列里，作为优先级最低的任务。\n  如果没有任何其他任务可执行，就调度执行这个特殊任务。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eLinux 选择的第二种，引入的特殊任务称为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e\u0026#34;idle task\u0026#34;\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e严格来说，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e早期系统中真的是进程（线程），优先级最低；干掉这个线程可能是搞垮小型机最简单的方式之一 [3]；\u003c/li\u003e\n  \u003cli\u003e现代系统中，比如 Linux 内核中，已经是更加轻量级的实现（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps\u003c/code\u003e 搜索 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle\u003c/code\u003e 等字样看不到这些进程） 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e一般都是在 CPU 无事可做时通过某种形式的 wait 指令让 CPU 降低功耗。\u003c/p\u003e\n\n\u003ch2 id=\"31-idle-task-历史\"\u003e3.1 idle task 历史\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e处理器比大多数人想象中要空闲的多。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eUnix\u003c/p\u003e\n\n    \u003cp\u003eUnix 似乎一直都有一个某种形式的 idle loop（但不一定是一个真正的 idle task）。\n 比如在 V1 中，它使用了一个 \u003ca href=\"https://github.com/dspinellis/unix-history-repo/blob/Research-V1-Snapshot-Development/u3.s#L156\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWAIT\u003c/code\u003e 指令\u003c/a\u003e，\n 实现了让处理器停止工作，直到中断触发，处理器重新开始执行。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eDOS、OS/2、早期 Windows\u003c/p\u003e\n\n    \u003cp\u003e包括 DOS、IBM \u003ca href=\"http://www.os2museum.com/wp/os2-2-0-xmas-91-edition/\"\u003eOS/2\u003c/a\u003e、早期 Windows 等操作系统，\n 都使用 busy loops 实现 idle task。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-linux-idle-task-设计\"\u003e3.2 Linux idle task 设计\u003c/h2\u003e\n\n\u003cp\u003e为了保证设计的一致性，Linux 引入了一个特殊的进程 idle task，没有其他 task 可调度时，就执行它。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e复用标准进程结构 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct task\u003c/code\u003e，将“无事可做时做什么”的逻辑封装为 idle task；\u003c/li\u003e\n  \u003cli\u003e为每个 CPU 创建一个这样的进程（idle task），只会在这个 CPU 上运行；\u003c/li\u003e\n  \u003cli\u003e无事可做时就调度这个 task 执行（因此优先级最低），所花的时间记录在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etop\u003c/code\u003e 等命令的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle\u003c/code\u003e 字段里。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etop\ntop - 09:38:34 up 22 days, 22:46,  8 \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e,  load average: 0.24, 0.14, 0.10\nTasks: 168 total,   1 running, 165 sleeping,   2 stopped,   0 zombie\n\n\u003cspan class=\"c\"\u003e#            user    system             idle     wait              softirq\u003c/span\u003e\n%Cpu0  :  0.0 us,  0.0 sy,  0.0 ni,100.0 \u003cspan class=\"nb\"\u003eid\u003c/span\u003e,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n%Cpu1  :  0.0 us,  3.1 sy,  0.0 ni, 96.9 \u003cspan class=\"nb\"\u003eid\u003c/span\u003e,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"33-实现idle-loop\"\u003e3.3 实现：idle loop\u003c/h2\u003e\n\n\u003cp\u003e这里只是很简单的看一下，下一篇专门介绍内核实现。\u003c/p\u003e\n\n\u003cp\u003e简化之后，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eneed_resched\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecpuidle_idle_call\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/*\n      [Note: Switch to a different task. We will return to this loop when the\n      idle task is again selected to run.]\n    */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eschedule_preempt_disabled\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果没有其他任务，就执行 idle。从累积时间来说，idle 函数可能是人类历史上执行时间最长的函数。 [2]\u003c/p\u003e\n\n\u003ch2 id=\"34-运行时\"\u003e3.4 运行时\u003c/h2\u003e\n\n\u003ch3 id=\"341-1-号进程pid1\"\u003e3.4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e 号进程（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e）\u003c/h3\u003e\n\n\u003cp\u003e我们经常能在教科书或网上看到说，系统启动之后的第一个进程是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003einit\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 进程，\n它的 PID 是 1，所有其他进程都是这个进程的（N 代）子进程。这句话也不算错，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einit\u003c/code\u003e 其实是一个逻辑概念，\n真正的 1 号进程名字可能并不叫 “init”。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e查看一台 ubuntu 机器：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003eubuntu\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/1/cmdline | \u003cspan class=\"nb\"\u003etr\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\\0\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39; \u0026#39;\u003c/span\u003e\n /sbin/init splash\n    \n \u003cspan class=\"c\"\u003e# /sbin/init is a symlink\u003c/span\u003e\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ahl\u003c/span\u003e /sbin/init\n lrwxrwxrwx 1 root root /sbin/init -\u0026gt; /lib/systemd/systemd\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e可以看到最终是执行的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003esystemd\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e再来看一台 CentOS 机器，\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003ecentos\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/1/cmdline | \u003cspan class=\"nb\"\u003etr\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;\\0\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39; \u0026#39;\u003c/span\u003e\n /usr/lib/systemd/systemd \u003cspan class=\"nt\"\u003e--switched-root\u003c/span\u003e \u003cspan class=\"nt\"\u003e--system\u003c/span\u003e \u003cspan class=\"nt\"\u003e--deserialize\u003c/span\u003e 28\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e直接执行的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystemd\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epstree\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 可以直接看到从 PID 1 开始的\u003cstrong\u003e\u003cmark\u003e进程树\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003epstree \u003cspan class=\"nt\"\u003e-p\u003c/span\u003e | \u003cspan class=\"nb\"\u003ehead\n\u003c/span\u003esystemd\u003cspan class=\"o\"\u003e(\u003c/span\u003e1\u003cspan class=\"o\"\u003e)\u003c/span\u003e-+-agetty\u003cspan class=\"o\"\u003e(\u003c/span\u003e13499\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           |-atd\u003cspan class=\"o\"\u003e(\u003c/span\u003e9614\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           |-auditd\u003cspan class=\"o\"\u003e(\u003c/span\u003e9442\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"nt\"\u003e---\u003c/span\u003e\u003cspan class=\"o\"\u003e{\u003c/span\u003eauditd\u003cspan class=\"o\"\u003e}(\u003c/span\u003e9443\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           |-chronyd\u003cspan class=\"o\"\u003e(\u003c/span\u003e9665\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           |-containerd\u003cspan class=\"o\"\u003e(\u003c/span\u003e10324\u003cspan class=\"o\"\u003e)\u003c/span\u003e-+-containerd-shim\u003cspan class=\"o\"\u003e(\u003c/span\u003e14126\u003cspan class=\"o\"\u003e)\u003c/span\u003e-+-pause\u003cspan class=\"o\"\u003e(\u003c/span\u003e14200\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           |                   |                        |-\u003cspan class=\"o\"\u003e{\u003c/span\u003econtainerd-shim\u003cspan class=\"o\"\u003e}(\u003c/span\u003e14127\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n           ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e 进程是谁创建出来的？有没有可能存在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=0\u003c/code\u003e 的进程？\u003c/p\u003e\n\n\u003ch3 id=\"342-0-号进程pid0\"\u003e3.4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 号进程（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=0\u003c/code\u003e）\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps\u003c/code\u003e 查看所有进程，指定 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e-a\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 按 PID 升序排列，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eps \u003cspan class=\"nt\"\u003e-eaf\u003c/span\u003e | \u003cspan class=\"nb\"\u003ehead\n\u003c/span\u003eUID    PID   PPID   CMD\nroot     1      0   /usr/lib/systemd/systemd \u003cspan class=\"nt\"\u003e--switched-root\u003c/span\u003e \u003cspan class=\"nt\"\u003e--system\u003c/span\u003e \u003cspan class=\"nt\"\u003e--deserialize\u003c/span\u003e 28\nroot     2      0   \u003cspan class=\"o\"\u003e[\u003c/span\u003ekthreadd] \u003cspan class=\"c\"\u003e# kernel thread daemon. All kthreads are forked from this thread\u003c/span\u003e\nroot     3      2   \u003cspan class=\"o\"\u003e[\u003c/span\u003ercu_gp]\nroot     4      2   \u003cspan class=\"o\"\u003e[\u003c/span\u003ercu_par_gp]\n..\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e还真能看到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 号进程，不过它只出现在父进程 PPID 列，是两个进程的父进程：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003esystemd\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e，前面介绍过了，\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekthreadd\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=2\u003c/code\u003e，这是\u003cstrong\u003e\u003cmark\u003e所有内核进程/线程的父进程\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e内核进程是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps\u003c/code\u003e 输出中用中括号 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 括起来的进程，比如上面看到的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[rcu_gp]\u003c/code\u003e；\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这也说明上一节我们关于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einit\u003c/code\u003e 的说明也不太准确，更准确来说，系统启动后\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e所有\u003cstrong\u003e\u003cmark\u003e系统进程\u003c/mark\u003e\u003c/strong\u003e（操作系统服务）和\u003cstrong\u003e\u003cmark\u003e用户进程\u003c/mark\u003e\u003c/strong\u003e都是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einit\u003c/code\u003e 进程直接或间接 fork 出来的；\u003c/li\u003e\n  \u003cli\u003e所有\u003cstrong\u003e\u003cmark\u003e内核进程\u003c/mark\u003e\u003c/strong\u003e都是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=2\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekthreadd\u003c/code\u003e 进程 fork 出来的；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e回到我们的问题，\u003ca href=\"https://unix.stackexchange.com/questions/83322/which-process-has-pid-0\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=0\u003c/code\u003e 是什么呢\u003c/a\u003e？\n\u003ca href=\"https://en.wikipedia.org/wiki/Process_identifier\"\u003ewikipedia.org/wiki/Process_identifier\u003c/a\u003e\n中有定义，本文不深入，简单把它理解成内核本身（内核最最骨干的执行逻辑），\n在所有进程之上，能管理左膀（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=1\u003c/code\u003e）和右臂（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePID=2\u003c/code\u003e）。\u003c/p\u003e\n\n\u003ch3 id=\"343-idle-task0-号进程的一部分\"\u003e3.4.3 idle task：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e 号进程的一部分\u003c/h3\u003e\n\n\u003cp\u003e做了以上那么多关于 PID 的铺垫，这里回到正题：idle task，是几号进程呢？\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e它的优先级最低，没有其他进程可调度时才会调度到它；\u003c/li\u003e\n  \u003cli\u003e它叫“进程”（任务，task），但不是普通进程，而是 \u003cstrong\u003e\u003cmark\u003e0 号进程的一部分\u003c/mark\u003e\u003c/strong\u003e，或者说是内核的一部分。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e从执行上来说，它是直接在内核本身内执行，而并不是切换到某个进程执行。\u003c/p\u003e\n\n\u003ch2 id=\"35-从-idle-task-进入-c-state-管理逻辑\"\u003e3.5 从 idle task 进入 c-state 管理逻辑\u003c/h2\u003e\n\n\u003cp\u003e内核切换到 idle task 代码之后，接下来怎么选择 c-state 以及怎么切换过去，\n就是算法、架构和对接特定处理器的实现问题了。\n我们下面一节来讨论。\u003c/p\u003e\n\n\u003ch1 id=\"4-cpu-空闲管理子系统cpudile空闲时如何节能c-state\"\u003e4 CPU 空闲管理子系统（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpudile\u003c/code\u003e）：空闲时如何节能（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ec-state\u003c/code\u003e）\u003c/h1\u003e\n\n\u003cp\u003e如果队列中没有任务，或者任务都是 wait 状态，\n内核调度器该做什么呢？取决于处理器提供的能力，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果处理器本身非常简单（特定场景的低成本处理器），没有什么功耗控制能力，调度器就只能执行一些无意义的指令来让处理器空转了；\u003c/li\u003e\n  \u003cli\u003e现代处理器都有功耗控制能力，一般都是关闭部分 processor，进入到某种程度的 sleep 状态，实现节能。\n但是，\u003cstrong\u003e\u003cmark\u003e中断控制器\u003c/mark\u003e\u003c/strong\u003e（interrupt controller）必现保持开启状态。外设触发中断时，能给处理器发信号，唤醒处理器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e实际上，现代处理器有着非常复杂的电源/能耗管理系统。\nOS 能预测处理器停留在 idle mode 的时长，选择不同的 low-power modes.\n每个 mode 功耗高低、进出耗时、频率等等都是不同的。\u003c/p\u003e\n\n\u003ch2 id=\"41-区分不同的-cpu-空闲级别引入-c-state-idle-state\"\u003e4.1 区分不同的 CPU 空闲级别：引入 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ec-state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e (idle state)\u003c/h2\u003e\n\n\u003cp\u003e为了增强灵活性，引入了 c-state，在处理器 idle 时节能 [7]。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cpu/intel-C-states.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e\np-states (optimization of the voltage and CPU frequency during operation) and c-states (optimization of the power consumption if a core does not have to execute any instructions)\n\u003ca href=\"https://www.thomas-krenn.com/en/wiki/Processor_P-states_and_C-states\"\u003eImage Source\u003c/a\u003e\n\u003c/p\u003e\n\n\u003ch3 id=\"411-acpi-p-states--c-states\"\u003e4.1.1 ACPI p-states \u0026amp; c-states\u003c/h3\u003e\n\n\u003cp\u003eACPI 定义了处理器电源管理的规范，里面有两种状态，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003ePower performance states (\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eACPI P states\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e)\u003c/p\u003e\n\n    \u003cp\u003e不同厂商、不同处理器的 p-states 一般都不同。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eProcessor idle sleep states (\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eACPI C states\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e)\u003c/p\u003e\n\n    \u003cp\u003e关闭 CPU 部分功能。不同处理器支持的 C-states 可能不同，区别在于能关掉哪些部分。\n 数字越大，关掉的功能越多，约省电。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"412-c-state-定义\"\u003e4.1.2 C-State 定义\u003c/h3\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eMode\u003c/th\u003e\n      \u003cth\u003eDefinition\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC0\u003c/td\u003e\n      \u003ctd\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eOperational state. CPU fully turned on.\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC1\u003c/td\u003e\n      \u003ctd\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eFirst idle state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e. Stops CPU main internal clocks via software. Bus interface unit and APIC are kept running at full speed.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC2\u003c/td\u003e\n      \u003ctd\u003eStops CPU main internal clocks via hardware. State in which the processor maintains all software-visible states, but may take longer to wake up through interrupts.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eC3\u003c/td\u003e\n      \u003ctd\u003eStops all CPU internal clocks. The processor does not need to keep its cache coherent, but maintains other states. Some processors have variations of the C3 state that differ in how long it takes to wake the processor through interrupts.\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ec0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 比较特殊，是\u003cstrong\u003e\u003cmark\u003e工作状态\u003c/mark\u003e\u003c/strong\u003e；\n但是工作在什么频率/电压，或者工作在哪个 p-state，是可以配置的，比如为了省电工作在较低的频率和电压；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ec1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 是第一个空闲状态，表示 cpu 无事可干时，进入这个状态比 c0 省电。\u003c/li\u003e\n  \u003cli\u003ec2 c3 … 可选的更低功耗 idle 状态，唤醒延迟相应也越大。较深的睡眠状态唤醒时还\u003cstrong\u003e\u003cmark\u003e可能会破坏 L2 cache\u003c/mark\u003e\u003c/strong\u003e 数据。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"413-和-p-state-的区别\"\u003e4.1.3 和 p-state 的区别\u003c/h3\u003e\n\n\u003cp\u003e区别：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ec-state 独立于厂商和处理器，p-state 跟厂商和具体处理器直接相关\u003c/li\u003e\n  \u003cli\u003e要想运行在某个 p-state，处理器必现工作在 C0 状态，也就是说处理器得进入工作状态，而不是空闲状态；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cpu/cstate-pstate.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eC-States vs. P-States\n\u003c/p\u003e\n\n\u003ch3 id=\"414-定义不同-idle-状态--c-states-的决定因素\"\u003e4.1.4 定义不同 idle 状态 / c-states 的决定因素\u003c/h3\u003e\n\n\u003cp\u003e每个 idle state 考虑两个参数来描述，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etarget residency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（目标驻留时间）\u003c/p\u003e\n\n    \u003cp\u003e硬件能够保证的在这个状态下的最短时间，包括进入该状态所需的时间（可能很长）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e（最坏情况下的）\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eexit latency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（退出延迟）\u003c/p\u003e\n\n    \u003cp\u003e从该状态唤醒后开始执行第一条指令所需的最长时间。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"42-如何选择-c-stategovernor--driver\"\u003e4.2 如何\u003cstrong\u003e\u003cmark\u003e选择 c-state\u003c/mark\u003e\u003c/strong\u003e：governor + driver\u003c/h2\u003e\n\n\u003cp\u003e跟 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpufreq\u003c/code\u003e 子系统类似，将管理部分封装为一个 governor，有结构体和方法，\n通过 driver 实现 governor 的一些方法。\u003c/p\u003e\n\n\u003cp\u003e使得架构独立于厂商和处理器。\u003c/p\u003e\n\n\u003cp\u003e四种 cpuidle governor：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emenu\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTEO\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eladder\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehaltpoll\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"421-为什么会有这么多-governors\"\u003e4.2.1 为什么会有这么多 governors？\u003c/h3\u003e\n\n\u003cp\u003e有两类信息可以影响 governor 的决策。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e下一个事件何时到来\u003c/mark\u003e\u003c/strong\u003e。分为两种情况：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e定时器事件\u003c/mark\u003e\u003c/strong\u003e。这个是确定的，因为内核控制着定时器（the kernel programs timers），所以 governor 知道何时触发。\n在下一个定时器到来之前，就是这个 CPU 所在硬件可以在 idle state 下花费的最长时间，包括进入和退出所需的时间。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e非定时器事件\u003c/mark\u003e\u003c/strong\u003e。CPU 可能随时被非定时器事件唤醒，而且通常不可预测。\ngovernor 只能在 CPU 被唤醒后看到 CPU 实际上空闲了多长时间（这段时间将被称为\u003cem\u003eidle duration\u003c/em\u003e），\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003egovernor 可以基于以上两种时间，来估计未来的 idle duration。\n如何使用这些信息取决于算法，这也是为什么有多个 governor 的主要原因。\u003c/p\u003e\n\n\u003ch3 id=\"422-governor\"\u003e4.2.2 governor\u003c/h3\u003e\n\n\u003ch4 id=\"menu-governor\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emenu\u003c/code\u003e governor\u003c/h4\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emenu\u003c/code\u003e governor 是 tickless 系统的默认 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e governor。\n非常复杂，但基本原理很简单：预测 idle duration，使用预测值进行 c-state 选择。\u003c/p\u003e\n\n\u003ch4 id=\"haltpoll\"\u003ehaltpoll\u003c/h4\u003e\n\n\u003ch4 id=\"ladder\"\u003eladder\u003c/h4\u003e\n\n\u003ch4 id=\"teo-timer-events-oriented\"\u003eteo (Timer Events Oriented)\u003c/h4\u003e\n\n\u003cp\u003e用于 tickless systems。\n跟 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emenu\u003c/code\u003e 一样，永远寻找最深的 idle state。\n但算法不同。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ekernel-doc: drivers/cpuidle/governors/teo.c\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"423-driver\"\u003e4.2.3 driver\u003c/h3\u003e\n\n\u003cp\u003e用哪个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuidle\u003c/code\u003e driver 通常取决于内核运行的平台，例如，有大多数 Intel 平台都支持两种驱动：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eintel_idle\u003c/code\u003e hardcode 了一些 idle state 信息；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eacpi_idle\u003c/code\u003e 从系统的 ACPI 表中读取 idle state 信息。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"43-实地查看两台-linux-node\"\u003e4.3 实地查看两台 Linux node\u003c/h2\u003e\n\n\u003cp\u003e下面的信息跟服务器的配置直接相关，我们这里只是随便挑两台看下，\n不代表任何配置建议。\u003c/p\u003e\n\n\u003ch3 id=\"431-intel-cpu-node\"\u003e4.3.1 Intel CPU node\u003c/h3\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower idle-info\nCPUidle driver: intel_idle\nCPUidle governor: menu\nanalyzing CPU 0:\n\nNumber of idle states: 4\nAvailable idle states: POLL C1 C1E C6\n  POLL:\n    Flags/Description: CPUIDLE CORE POLL IDLE\n    Latency: 0\n    Usage: 4927634\n    Duration: 49239413\n  C1:\n    Flags/Description: MWAIT 0x00\n    Latency: 2\n    Usage: 954516883\n    Duration: 1185768447670\n  C1E:\n    Flags/Description: MWAIT 0x01\n    Latency: 10\n    Usage: 7804\n    Duration: 7491626\n  C6 \u003cspan class=\"o\"\u003e(\u003c/span\u003eDISABLED\u003cspan class=\"o\"\u003e)\u003c/span\u003e :\n    Flags/Description: MWAIT 0x20\n    Latency: 92\n    Usage: 0\n    Duration: 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecpuidle driver：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eintel_idle\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003ecpuidle governor: \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003emenu\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e支持的 idle states 种类：4 种\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003ePOLL：即 C0，无事可做时执行一个轻量级线程，避免处理器进入 C1 状态；\u003c/li\u003e\n      \u003cli\u003eC1\u003c/li\u003e\n      \u003cli\u003eC1E\u003c/li\u003e\n      \u003cli\u003eC6：未启用\u003c/li\u003e\n    \u003c/ol\u003e\n\n    \u003cp\u003e此外还提供了每种 idle 状态的延迟、使用率、累积时长等等统计信息。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e还可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpupower monitor\u003c/code\u003e 查看每个 CPU 的具体状态分布：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower monitor\n              | Nehalem                   \u003cspan class=\"o\"\u003e||\u003c/span\u003e Mperf              \u003cspan class=\"o\"\u003e||\u003c/span\u003e Idle_Stats\n PKG|CORE| CPU| C3   | C6   | PC3  | PC6   \u003cspan class=\"o\"\u003e||\u003c/span\u003e C0   | Cx   | Freq  \u003cspan class=\"o\"\u003e||\u003c/span\u003e POLL | C1   | C1E  | C6\n   0|   0|   0|  0.00|  0.00|  0.00|  0.00||  3.10| 96.90|  2692||  0.00| 96.96|  0.00|  0.00\n   0|   0|  20|  0.00|  0.00|  0.00|  0.00||  2.05| 97.95|  2692||  0.00| 98.04|  0.00|  0.00\n   0|   1|   4|  0.00|  0.00|  0.00|  0.00||  0.80| 99.20|  2692||  0.00| 99.23|  0.00|  0.00\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"432-amd-cpu-node\"\u003e4.3.2 AMD CPU node\u003c/h3\u003e\n\n\u003cp\u003e第一台 node：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower idle-info\nCPUidle driver: none   \u003cspan class=\"c\"\u003e# 没有 driver\u003c/span\u003e\nCPUidle governor: menu\nanalyzing CPU 0:\n\nCPU 0: No idle states  \u003cspan class=\"c\"\u003e# 没有 idle state，CPU 工作在 idle=poll 模式\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e第二台 node：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower idle-info\nCPUidle driver: acpi_idle      \u003cspan class=\"c\"\u003e# acpi_idle driver\u003c/span\u003e\nCPUidle governor: menu\nanalyzing CPU 0:\n\nNumber of idle states: 2\nAvailable idle states: POLL C1 \u003cspan class=\"c\"\u003e# 最大睡眠深度 C1\u003c/span\u003e\n  POLL:\n    Flags/Description: CPUIDLE CORE POLL IDLE\n    Latency: 0\n    Usage: 11905032\n    Duration: 88450207\n  C1:\n    Flags/Description: ACPI FFH MWAIT 0x0\n    Latency: 1\n    Usage: 3238141749\n    Duration: 994766079630\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower monitor | \u003cspan class=\"nb\"\u003ehead\u003c/span\u003e\n              | Mperf              \u003cspan class=\"o\"\u003e||\u003c/span\u003e Idle_Stats\n PKG|CORE| CPU| C0   | Cx   | Freq  \u003cspan class=\"o\"\u003e||\u003c/span\u003e POLL | C1\n   0|   0|   0| 18.29| 81.71|  2394||  0.01| 81.69\n   0|   0|  64| 13.88| 86.12|  2394||  0.01| 86.12\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e第三台 node：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower idle-info\nCPUidle driver: acpi_idle         \u003cspan class=\"c\"\u003e# acpi_idle driver\u003c/span\u003e\nCPUidle governor: menu\nanalyzing CPU 0:\n\nNumber of idle states: 3\nAvailable idle states: POLL C1 C2 \u003cspan class=\"c\"\u003e# 最大睡眠深度 C2\u003c/span\u003e\n  POLL:\n    Flags/Description: CPUIDLE CORE POLL IDLE\n    Latency: 0\n    Usage: 281497562\n    Duration: 1622947419\n  C1:\n    Flags/Description: ACPI FFH MWAIT 0x0\n    Latency: 1\n    Usage: 59069668293\n    Duration: 21144523673762\n  C2:\n    Flags/Description: ACPI IOPORT 0x814\n    Latency: 30\n    Usage: 9864\n    Duration: 16089926\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower monitor | \u003cspan class=\"nb\"\u003ehead\u003c/span\u003e\n              | Mperf              \u003cspan class=\"o\"\u003e||\u003c/span\u003e Idle_Stats\n PKG|CORE| CPU| C0   | Cx   | Freq  \u003cspan class=\"o\"\u003e||\u003c/span\u003e POLL | C1   | C2\n   0|   0|   0| 24.83| 75.17|  1886||  0.00| 75.32|  0.00\n   0|   0|  64| 22.04| 77.96|  1890||  0.00| 78.03|  0.00\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"433-内核启动日志\"\u003e4.3.3 内核启动日志\u003c/h3\u003e\n\n\u003cp\u003e内核启动日志说可以看到一些 idle task 相关的信息：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edmesg | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eidle\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.018727] clocksource: refined-jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1910969940391419 ns\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.177760] clocksource: hpet: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 79635855245 ns\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.189880] clocksource: tsc-early: mask: 0xffffffffffffffff max_cycles: 0x1fb633008a4, max_idle_ns: 440795292230 ns\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.227518] process: using mwait \u003cspan class=\"k\"\u003ein \u003c/span\u003eidle threads\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.555478] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 1911260446275000 ns\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.558415] cpuidle: using governor menu\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    1.139909] clocksource: acpi_pm: mask: 0xffffff max_cycles: 0xffffff, max_idle_ns: 2085701024 ns\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    1.194196] ACPI: \u003cspan class=\"se\"\u003e\\_\u003c/span\u003eSB_.SCK0.CP00: Found 1 idle states\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    2.194148] clocksource: tsc: mask: 0xffffffffffffffff max_cycles: 0x1fa32b623c0, max_idle_ns: 440795289684 ns\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"5-cpu-功耗管理pmqospm_qos保证响应时间\"\u003e5 CPU 功耗管理（PM）QoS：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epm_qos\u003c/code\u003e，保证响应时间\u003c/h1\u003e\n\n\u003ch2 id=\"51-解决的问题\"\u003e5.1 解决的问题\u003c/h2\u003e\n\n\u003cp\u003ec-state 引入的一个问题是：当有任务到来时，从低功耗状态切回运行状态会有一定的延迟，\n对于某些应用来说可能无法接受。为了解决这个问题，应用可以通过\nPower Management Quality of Service (PM QoS) 接口。\u003c/p\u003e\n\n\u003cp\u003e这是一个内核框架，允许 kernel code and user space processes 向内核声明延迟需求，避免性能过低。\u003c/p\u003e\n\n\u003ch2 id=\"52-原理\"\u003e5.2 原理\u003c/h2\u003e\n\n\u003cp\u003e系统会在节能的前提下，尽量模拟 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle=poll processor.max_cstate=1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的效果，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eidle=poll 会阻止处理器进入 idle state；\u003c/li\u003e\n  \u003cli\u003eprocessor.max_cstate=1 阻止处理器进入较深的 C-states。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e使用方式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e应用程序打开 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/dev/cpu_dma_latency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e ，\n写入能接受的最大响应时间，这是一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint32\u003c/code\u003e 类型，单位是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eus\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e注意：保持这个文件处于 open 状态；关闭这个文件后，PM QoS 就停止工作了。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"53-例子\"\u003e5.3 例子\u003c/h2\u003e\n\n\u003cp\u003e来自 RedHat\n\u003ca href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux_for_real_time/8/html/optimizing_rhel_8_for_real_time_for_low_latency_operation/assembly_controlling-power-management-transitions_optimizing-rhel8-for-real-time-for-low-latency-operation\"\u003eControlling power management transitions\u003c/a\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eos\u003c/span\u003e\n\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003eos.path\u003c/span\u003e\n\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003esignal\u003c/span\u003e\n\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003esys\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"ow\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eexists\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#39;/dev/cpu_dma_latency\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n \t\u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;no PM QOS interface on this system!\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n \t\u003cspan class=\"n\"\u003esys\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"n\"\u003efd\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eopen\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#39;/dev/cpu_dma_latency\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eO_WRONLY\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n \t \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ewrite\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"sa\"\u003eb\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"se\"\u003e\\0\\0\\0\\0\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n \t \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Press ^C to close /dev/cpu_dma_latency and exit\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003esignal\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003epause\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"k\"\u003eexcept\u003c/span\u003e \u003cspan class=\"nb\"\u003eKeyboardInterrupt\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;closing /dev/cpu_dma_latency\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eos\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eclose\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003efd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003esys\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里写入的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e，表示\u003cstrong\u003e\u003cmark\u003e完全禁用 c-states\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e此外，也可以读写 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/devices/system/cpu/cpu\u0026lt;N\u0026gt;/power/pm_qos_resume_latency_us\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"6-系统定时器timer对空闲管理的影响\"\u003e6 系统定时器（timer）对空闲管理的影响\u003c/h1\u003e\n\n\u003cp\u003e最后，我们看一个影响空闲管理性能的东西：timer。\u003c/p\u003e\n\n\u003cp\u003e如果我们很关心一件事情的进展，但是出于某些原因，对方不会或无法向我们主动同步进展，\n我们该怎么办呢？—— 定期主动去问进展，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e翻译成计算机术语：轮询；\u003c/li\u003e\n  \u003cli\u003e具体到内核，依赖的底层机制：\u003cstrong\u003e\u003cmark\u003e定时器\u003c/mark\u003e\u003c/strong\u003e（timer）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"61-经典方式scheduler-tick固定-hz\"\u003e6.1 经典方式：scheduler tick（固定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eHZ\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e如果一个 CPU 上有多个 runnable task，从公平角度考虑 [12]，应该让它们轮流执行。\n实现轮流的底层机制就是定时器。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003escheduler tick 是一个定时器，定期触发，不管 CPU 上有没有任务执行；\u003c/li\u003e\n  \u003cli\u003etimer 触发之后，停止当前任务的执行，根据 scheduling class、优先级等的因素，选出下一个任务放到 CPU 上执行。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cpu/idle.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\u003ca href=\"https://manybutfinite.com/img/os/idle.png\"\u003eImage source\u003c/a\u003e\n\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-cpu/idleCycles.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e\n\u003ca href=\"https://manybutfinite.com/img/os/idleCycles.png\"\u003eImage source\u003c/a\u003e\n\u003c/p\u003e\n\n\u003cp\u003escheduler tick 的触发频率就是系统 HZ，这个是内核编译时指定的，范围是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100~1000\u003c/code\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003egrep\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;CONFIG_HZ=\u0026#39;\u003c/span\u003e /boot/config-\u003cspan class=\"si\"\u003e$(\u003c/span\u003e\u003cspan class=\"nb\"\u003euname\u003c/span\u003e \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e\u003cspan class=\"si\"\u003e)\u003c/span\u003e\n\u003cspan class=\"nv\"\u003eCONFIG_HZ\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e250\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e即这台机器每秒都要中断 250 次，\n从 CPU 空闲时间管理的角度来看，如果 CPU 很空闲，这样频繁触发就很浪费，\n增加处理开销。\u003c/p\u003e\n\n\u003ch2 id=\"62-改进tickless-mode-nohz\"\u003e6.2 改进：tickless mode (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enohz\u003c/code\u003e)\u003c/h2\u003e\n\n\u003cp\u003etickless 模式，也叫 dynamic tick 模式，见内核文档\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/timers/no_hz.rst\"\u003eDocumentation/timers/no_hz.rst\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e基本原理：CPU 空闲时，\n如果内核知道下一个任务何时到来（例如，一个进程设置了 5s 的定时器），\n就 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.17/Documentation/timers/highres.txt#L215\"\u003e关闭或延迟\u003c/a\u003e\ntimer interrupt。\u003c/p\u003e\n\n\u003cp\u003e好处是更节能。\u003c/p\u003e\n\n\u003cp\u003e编译设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_NO_HZ_IDLE\u003c/code\u003e 或启动命令行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enohz=off\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"63-再改进-adaptive-tick\"\u003e6.3 再改进 adaptive tick\u003c/h2\u003e\n\n\u003cp\u003e内核文档 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/timers/no_hz.rst\"\u003eNO_HZ: Reducing Scheduling-Clock Ticks\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果是一个 CPU 密集型的，那跟完全 idle 是类似的，都不希望每 4ms 被打扰一次。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/admin-guide/pm/cpuidle.rst\"\u003eCPU Idle Time Management\u003c/a\u003e, cpuidle kernel doc, 5.15\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://manybutfinite.com/post/what-does-an-idle-cpu-do/\"\u003eWhat Does An Idle CPU Do\u003c/a\u003e, manybutfinite.com, 2014\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://unix.stackexchange.com/questions/361245/what-does-an-idle-cpu-process-do\"\u003ewhat-does-an-idle-cpu-process-do\u003c/a\u003e, stackexchange.com\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/timers/no_hz.rst\"\u003eno hz\u003c/a\u003e, kernel doc, 5.15\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/Articles/384146/\"\u003eThe cpuidle subsystem\u003c/a\u003e, lwn.net, 2013\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cfs-design-and-implementation-zh/\"\u003eLinux CFS 调度器：原理、设计与内核实现（2023）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://doc.opensuse.org/documentation/leap/archive/42.2/tuning/html/book.sle.tuning/cha.tuning.power.html\"\u003eSystem Analysis and Tuning Guide: Power Management\u003c/a\u003e, opensuse.org\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.thomas-krenn.com/en/wiki/Processor_P-states_and_C-states\"\u003eProcessor P-states and C-states\u003c/a\u003e, thomas-krenn.com\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/admin-guide/pm/cpufreq.rst\"\u003eCPU Performance Scaling\u003c/a\u003e, cpufreq kernel doc, 5.15\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://lwn.net/Articles/682391/\"\u003eImprovements in CPU frequency management\u003c/a\u003e, lwn.net, 2016\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://wiki.linuxfoundation.org/realtime/documentation/howto/applications/cpuidle\"\u003eCPU idle power saving methods for real-time workloads\u003c/a\u003e, wiki.linuxfoundation.org\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cfs-design-and-implementation-zh/\"\u003eLinux CFS 调度器：原理、设计与内核实现（2023）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/linux-cpu-1-zh/\"\u003e\u003cspan\u003e« Linux 服务器功耗与性能管理（一）：CPU 硬件基础（2024）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/linux-cpu-3-zh/\"\u003e\u003cspan\u003eLinux 服务器功耗与性能管理（三）：cpuidle 子系统的实现（2024） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2024-02-15T00:00:00Z",
  "Author": "Arthur Chiao"
}