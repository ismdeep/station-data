{
  "Source": "arthurchiao.art",
  "Title": "[译] Linux 系统调用权威指南（2016）",
  "Link": "https://arthurchiao.art/blog/system-call-definitive-guide-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Linux 系统调用权威指南（2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-01-30 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch2 id=\"译者序\"\u003e译者序\u003c/h2\u003e\n\n\u003cp\u003e本文翻译自 2016 年的一篇英文博客 \u003ca href=\"https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/\"\u003eThe Definitive Guide to Linux System\nCalls\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003ch2 id=\"太长不读tldr\"\u003e太长不读（TL;DR）\u003c/h2\u003e\n\n\u003cp\u003e本文介绍了 Linux 程序是如何调用内核函数的。包括：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e几种发起系统调用的方式\u003c/li\u003e\n  \u003cli\u003e如何手动写汇编代码发起系统调用（包括示例）\u003c/li\u003e\n  \u003cli\u003e系统调用的内核入口（entry points）和内核出口（exit points）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e wrappers\u003c/li\u003e\n  \u003cli\u003e系统调用相关的内核 bug\u003c/li\u003e\n  \u003cli\u003e其他更多内容\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#太长不读tldr\" id=\"markdown-toc-太长不读tldr\"\u003e太长不读（TL;DR）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-系统调用是什么\" id=\"markdown-toc-1-系统调用是什么\"\u003e1 系统调用是什么?\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-预备知识\" id=\"markdown-toc-2-预备知识\"\u003e2 预备知识\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-硬件和软件\" id=\"markdown-toc-21-硬件和软件\"\u003e2.1 硬件和软件\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-用户程序内核和-cpu-特权级别\" id=\"markdown-toc-22-用户程序内核和-cpu-特权级别\"\u003e2.2 用户程序、内核和 CPU 特权级别\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-触发特权级别切换方式之一中断\" id=\"markdown-toc-23-触发特权级别切换方式之一中断\"\u003e2.3 触发特权级别切换（方式之一）：中断\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-型号特定寄存器msr\" id=\"markdown-toc-24-型号特定寄存器msr\"\u003e2.4 型号特定寄存器（MSR）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-不要手写汇编代码发起系统调用\" id=\"markdown-toc-25-不要手写汇编代码发起系统调用\"\u003e2.5 不要手写汇编代码发起系统调用\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-传统系统调用legacy-system-calls\" id=\"markdown-toc-3-传统系统调用legacy-system-calls\"\u003e3 传统系统调用（Legacy system calls）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-用户程序端写汇编发起传统系统调用\" id=\"markdown-toc-31-用户程序端写汇编发起传统系统调用\"\u003e3.1 用户程序端：写汇编发起传统系统调用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-内核端int-0x80-入口\" id=\"markdown-toc-32-内核端int-0x80-入口\"\u003e3.2 内核端：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $0x80\u003c/code\u003e 入口\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-iret-系统调用返回\" id=\"markdown-toc-33-iret-系统调用返回\"\u003e3.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e: 系统调用返回\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-快速系统调用\" id=\"markdown-toc-4-快速系统调用\"\u003e4 快速系统调用\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-32-bit-快速系统调用\" id=\"markdown-toc-41-32-bit-快速系统调用\"\u003e4.1 32-bit 快速系统调用\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#411-sysentersysexit\" id=\"markdown-toc-411-sysentersysexit\"\u003e4.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#412-__kernel_vsyscall-实现\" id=\"markdown-toc-412-__kernel_vsyscall-实现\"\u003e4.1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 实现\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#413-用户程序端写汇编调用-sysenter\" id=\"markdown-toc-413-用户程序端写汇编调用-sysenter\"\u003e4.1.3 用户程序端：写汇编调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#414-内核端sysenter-入口\" id=\"markdown-toc-414-内核端sysenter-入口\"\u003e4.1.4 内核端：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 入口\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#415-sysexit从-sysenter-返回\" id=\"markdown-toc-415-sysexit从-sysenter-返回\"\u003e4.1.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e：从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 返回\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-64-bit-快速系统调用\" id=\"markdown-toc-42-64-bit-快速系统调用\"\u003e4.2 64-bit 快速系统调用\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#421-syscallsysret\" id=\"markdown-toc-421-syscallsysret\"\u003e4.2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#422-用户空间发起系统调用\" id=\"markdown-toc-422-用户空间发起系统调用\"\u003e4.2.2 用户空间：发起系统调用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#423-内核空间syscall-入口\" id=\"markdown-toc-423-内核空间syscall-入口\"\u003e4.2.3 内核空间：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 入口\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#424-sysret系统调用返回\" id=\"markdown-toc-424-sysret系统调用返回\"\u003e4.2.4 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e：系统调用返回\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-通过-syscall2-半手动发起系统调用\" id=\"markdown-toc-5-通过-syscall2-半手动发起系统调用\"\u003e5 通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall(2)\u003c/code\u003e 半手动发起系统调用\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#glibc-syscall-wrapper-内部实现\" id=\"markdown-toc-glibc-syscall-wrapper-内部实现\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e wrapper 内部实现\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-虚拟系统调用\" id=\"markdown-toc-6-虚拟系统调用\"\u003e6 虚拟系统调用\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-vdso-在内核中的实现\" id=\"markdown-toc-61-vdso-在内核中的实现\"\u003e6.1 vDSO 在内核中的实现\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-在内存中定位-vdso\" id=\"markdown-toc-62-在内存中定位-vdso\"\u003e6.2 在内存中定位 vDSO\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-glibc-中的-vdso\" id=\"markdown-toc-63-glibc-中的-vdso\"\u003e6.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 中的 vDSO\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-glibc-系统调用-wrappers\" id=\"markdown-toc-7-glibc-系统调用-wrappers\"\u003e7 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 系统调用 wrappers\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-syscall-相关的有趣-bugs\" id=\"markdown-toc-8-syscall-相关的有趣-bugs\"\u003e8 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 相关的有趣 bugs\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#81-cve-2010-3301\" id=\"markdown-toc-81-cve-2010-3301\"\u003e8.1 CVE-2010-3301\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#82-android-sysenter-abi-hardcode\" id=\"markdown-toc-82-android-sysenter-abi-hardcode\"\u003e8.2 Android \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e ABI hardcode\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-结束语\" id=\"markdown-toc-9-结束语\"\u003e9 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-相关文章\" id=\"markdown-toc-10-相关文章\"\u003e10 相关文章\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"1-系统调用是什么\"\u003e1 系统调用是什么?\u003c/h1\u003e\n\n\u003cp\u003e当程序调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eopen\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efor\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eread\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite\u003c/code\u003e 等函数时，就是在进行系统调用。\u003c/p\u003e\n\n\u003cp\u003e系统调用是一种 \u003cstrong\u003e程序进入内核执行任务\u003c/strong\u003e的方式。程序利用系统调用进行一系列操作，例如\n创建进程、处理网络、读写文件等等。 通过 \u003ca href=\"http://man7.org/linux/man-pages/man2/syscalls.2.html\"\u003esyscall(2) man\npage\u003c/a\u003e 可以查看完整的系统调用列表。\u003c/p\u003e\n\n\u003cp\u003e应用程序有\u003cstrong\u003e\u003cmark\u003e多种发起系统调用的方式\u003c/mark\u003e\u003c/strong\u003e，其中涉及的底层指令会因 CPU 不同而有所差异。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e应用开发者通常无需考虑系统调用是如何实现的\u003c/mark\u003e\u003c/strong\u003e，只需 include 相应头文件，\n像调正常函数一样调用系统调用函数即可。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 提供的 wrapper 封装了底层代码，\n如果使用这些 wrapper 函数，只需要传递相应的参数给它就可以进入内核。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"2-预备知识\"\u003e2 预备知识\u003c/h1\u003e\n\n\u003cp\u003e在开始研究系统调用之前先定义一些术语，并介绍几个后面将会用到的核心理念。\u003c/p\u003e\n\n\u003ch2 id=\"21-硬件和软件\"\u003e2.1 硬件和软件\u003c/h2\u003e\n\n\u003cp\u003e本文将基于如下假设：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e读者使用的是 32 位或 64 位 Intel 或 AMD CPU。本文内容对其他类型的系统可能也有\n参考意义，但部分示例代码是和 CPU 相关的\u003c/li\u003e\n  \u003cli\u003e基于 Linux \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3.13.0\u003c/code\u003e 内核。介绍到实现的时候会给出一些 github 上的链接。其他\n内核版本与此类似，但文件路径、具体行号等可能会有差别\u003c/li\u003e\n  \u003cli\u003e读者对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 或其衍生版本（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeglibc\u003c/code\u003e ）的实现有兴趣\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ex86-64 在本文中将指基于 x86 架构的 64 位 Intel 或 AMD CPU。\u003c/p\u003e\n\n\u003ch2 id=\"22-用户程序内核和-cpu-特权级别\"\u003e2.2 用户程序、内核和 CPU 特权级别\u003c/h2\u003e\n\n\u003cp\u003e用户程序（例如编辑器、终端、ssh daemon 等）需要和 Linux 内核交互，内核代替它们完\n成一些它们自身无法完成的操作。\u003c/p\u003e\n\n\u003cp\u003e例如，如果用户程序需要做 IO 操作（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eopen\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eread\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite\u003c/code\u003e 等），或者需要修改它的\n内存地址（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emmpa\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esbrk\u003c/code\u003e 等），那它必须触发内核替它完成。\n\u003cstrong\u003e\u003cmark\u003e什么禁止用户程序做这些操作\u003c/mark\u003e\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e原来，x86-64 CPU 有一个\u003ca href=\"https://en.wikipedia.org/wiki/Privilege_level\"\u003e特权级别\u003c/a\u003e\n（privilege levels）的概念。这个概念很复杂，完全可以单独写一篇博客。\n出于本文讨论目的，我们将其（大大地）简化为如下：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e特权级别是\u003cstrong\u003e权限控制的一种方式\u003c/strong\u003e。当前的特权级别决定了允许执行哪些 CPU 指令和操作\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e内核运行在最高级别\u003c/strong\u003e，称为 “\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eRing 0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e”；\n  用户程序运行在稍低的一个级别，一般称作 “\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eRing 3\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e”\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e用户程序要进行特权操作必须触发一次\u003cstrong\u003e特权级别切换\u003c/strong\u003e（从 “Ring 3” 到 “Ring 0”），\n由内核（替它）执行。\u003cstrong\u003e\u003cmark\u003e触发特权级别切换有多种方式\u003c/mark\u003e\u003c/strong\u003e，我们先从最常见的方式开始：中断。\u003c/p\u003e\n\n\u003ch2 id=\"23-触发特权级别切换方式之一中断\"\u003e2.3 触发特权级别切换（方式之一）：中断\u003c/h2\u003e\n\n\u003cp\u003e可以将中断想象成\u003cstrong\u003e硬件或软件产生（或“触发”）的事件\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e硬件中断是由硬件设备触发的，以此通知内核发生了特定的事件。一个常见的例子是网卡收\n到数据包时触发的硬中断。\u003c/li\u003e\n  \u003cli\u003e软件中断是由执行中的程序触发的。在 x86-64 系统上，软件中断可以通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eint\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 指令触发。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e中断都有编号，其中一些编号有特定的意义。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e可以想象内存中的一个数组，数组中的每项（entry）分别对应一个中断号。\u003c/li\u003e\n  \u003cli\u003e每项的内容包括 \u003cstrong\u003e中断发生时 CPU 需要执行的函数（回调函数，或称中断处理函数）的地址\u003c/strong\u003e\n以及其他一些选项，例如以哪个特权级别执行中断处理函数。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面是 Intel CPU 手册中提供的一个中断项（entry）的内存布局视图：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/system-call-definitive-guide/idt.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e注意其中有一个 2 bit 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDPL\u003c/code\u003e（Descriptor Privilege Level，描述符特权级别）字段\n，这个值表示执行中断处理函数时 CPU 所应满足的最小特权级别。\u003c/p\u003e\n\n\u003cp\u003e这就是当一个特定类型的中断事件发生时，\u003cstrong\u003e\u003cmark\u003eCPU 如何知道中断函数的地址\u003c/mark\u003e\u003c/strong\u003e，\n以及它\u003cstrong\u003e\u003cmark\u003e应该以哪个特权级别执行中断函数\u003c/mark\u003e\u003c/strong\u003e的原理。\u003c/p\u003e\n\n\u003cp\u003e实际上 x86-64 系统的中断还有很多其他方式。想了解更多可阅读：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"http://wiki.osdev.org/8259_PIC\"\u003e8259 可编程中断控制器\u003c/a\u003e（8259 Programmable Interrupt Controller）\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://wiki.osdev.org/APIC\"\u003e高级中断控制器\u003c/a\u003e（Advanced Interrupt Controllers）\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://wiki.osdev.org/IOAPIC\"\u003eIO 高级中断控制器\u003c/a\u003e（IO Advanced Interrupt Controllers）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e处理硬件和软件中断时还有其他一些复杂之处，例如中断号冲突（collision）和重映射\n（remapping）。在本篇中我们不考虑这些方面。\u003c/p\u003e\n\n\u003ch2 id=\"24-型号特定寄存器msr\"\u003e2.4 型号特定寄存器（MSR）\u003c/h2\u003e\n\n\u003cp\u003e（CPU）型号特定寄存器（Model Specific Registers， MSR）是用于特殊目的的控制寄存\n器，可以控制 CPU 的特定特性。CPU 文档里列出了每个 MSR 的地址。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdmsr\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrmsr\u003c/code\u003e 指令可以读写 MSR，也有命令行工具可以读写 MSR，但是不推荐这样\n做，因为改变这些值（尤其是系统正在运行时）是非常危险的，除非你非常小心，知道自己\n在做什么。\u003c/p\u003e\n\n\u003cp\u003e如果不怕导致系统不稳定或造成不可逆的数据损坏，那可以安装 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emsr-tools\u003c/code\u003e 并加载\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emsr\u003c/code\u003e 内核模块，然后就可以读写 MSR：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eapt-get \u003cspan class=\"nb\"\u003einstall \u003c/span\u003emsr-tools\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003emodprobe msr\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003erdmsr\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e本文接下来的一些系统调用使用了 MSR。\u003c/p\u003e\n\n\u003ch2 id=\"25-不要手写汇编代码发起系统调用\"\u003e2.5 不要手写汇编代码发起系统调用\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e手写汇编代码来发起系统调用并不是一个好主意\u003c/strong\u003e。其中一个重要原因是，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 中有\n一些额外代码在系统调用之前或之后执行（而你自己写的汇编代码没有做这些类似的工作）\n。\u003c/p\u003e\n\n\u003cp\u003e接下来的例子中我们使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调用。事实上你可以用\n\u003ca href=\"http://man7.org/linux/man-pages/man3/atexit.3.html\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eatexit\u003c/code\u003e\u003c/a\u003e函数向 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 注册\n回调函数，在它退出的时候就会执行。这些函数是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 里调用的，而不是内核。因\n此，如果你自己写的汇编代码调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e，那注册的回调函数就不会被执行，因为这种方\n式绕过了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e然而，徒手写汇编来调系统调用是一次很好的学习方式。\u003c/p\u003e\n\n\u003ch1 id=\"3-传统系统调用legacy-system-calls\"\u003e3 传统系统调用（Legacy system calls）\u003c/h1\u003e\n\n\u003cp\u003e根据前面的知识我们知道了两件事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint\u003c/code\u003e 指令可以产生软中断\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e软中断可以触发\u003c/strong\u003e内核执行系统调研\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e两者结合，我们就来到了 Linux 传统（Legacy）的系统调用接口。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eLinux 内核预留了一个特殊的软中断号\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e128\u003c/code\u003e (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x80\u003c/code\u003e)，\n用户空间程序使用它可以进入内核执行系统调用，对应的中断处理函数是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eia32_syscall\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e接下来看代码实现。\n从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etrap_init\u003c/code\u003e 函数开始，\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770\"\u003earch/x86/kernel/traps.c\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003evoid __init trap_init\u003cspan class=\"o\"\u003e(\u003c/span\u003evoid\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        /\u003cspan class=\"k\"\u003e*\u003c/span\u003e ..... other code ... \u003cspan class=\"k\"\u003e*\u003c/span\u003e/\n\n        set_system_intr_gate\u003cspan class=\"o\"\u003e(\u003c/span\u003eIA32_SYSCALL_VECTOR, ia32_syscall\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIA32_SYSCALL_VECTOR\u003c/code\u003e 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x80\u003c/code\u003e，定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/traps.c#L770\"\u003earch/x86/include/asm/irq_vectors.h.\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e但是， \u003cstrong\u003e如果内核只给用户空间程序预留了一个软中断，内核如何知道中断触发的时候，该去\n执行哪个系统调用呢？\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e答案是，用户程序会将系统调用编号放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeax\u003c/code\u003e 寄存器，系统调用所需的参数放到其他的\n通用寄存器上。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L378-L397\"\u003earch/x86/ia32/ia32entry.S\u003c/a\u003e 对这个过程做了注释：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eEmulated\u003c/span\u003e \u003cspan class=\"n\"\u003eIA32\u003c/span\u003e \u003cspan class=\"n\"\u003esystem\u003c/span\u003e \u003cspan class=\"n\"\u003ecalls\u003c/span\u003e \u003cspan class=\"n\"\u003evia\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x80\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eArguments\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eeax\u003c/span\u003e \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg1\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eecx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg2\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg3\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eesi\u003c/span\u003e \u003cspan class=\"n\"\u003eArg4\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedi\u003c/span\u003e \u003cspan class=\"n\"\u003eArg5\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebp\u003c/span\u003e \u003cspan class=\"n\"\u003eArg6\u003c/span\u003e    \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enote\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003esaved\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003estack\u003c/span\u003e \u003cspan class=\"n\"\u003eframe\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eshould\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003ebe\u003c/span\u003e \u003cspan class=\"n\"\u003etouched\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在我们知道了如何发起系统调用，也知道了系统调用的参数应该放到哪里，接下来就写一\n些内联汇编来试试。\u003c/p\u003e\n\n\u003ch2 id=\"31-用户程序端写汇编发起传统系统调用\"\u003e3.1 用户程序端：写汇编发起传统系统调用\u003c/h2\u003e\n\n\u003cp\u003e发起一次传统系统调用只需要少量内联汇编。虽然从学习的角度来说很有趣，但是我建议读\n者永远不要（在生产环境）这样做。\u003c/p\u003e\n\n\u003cp\u003e在这个例子中，我们将调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调用，它只有一个参数：返回值。\u003c/p\u003e\n\n\u003cp\u003e首先，我们要找到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 的系统调用编号。内核有一个文件列出了所有的系统调用编号。\n在编译期间，这个文件会被多个脚本处理，最后生成用户空间会用到的头文件。这个列表位\n于\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_32.tbl\"\u003earch/x86/syscalls/syscall_32.tbl\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"n\"\u003ei386\u003c/span\u003e  \u003cspan class=\"n\"\u003eexit\u003c/span\u003e      \u003cspan class=\"n\"\u003esys_exit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 的系统调用编号是 1。根据前面的信息，我们只需要将系统调用编号放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeax\u003c/code\u003e 寄\n存器，然后将第一个参数（返回值）放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eebx\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e如下是实现这个功能的简单 C 代码，其中包括几行内联汇编。这里将返回值设置为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e42\u003c/code\u003e。\n(这个程序其实还可以进一步简化，这样写是为了让没有 GCC 内联汇编基础的读者更容易看\n懂。)\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eargc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e[])\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003easm\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;movl %0, %%eax\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n       \u003cspan class=\"s\"\u003e\u0026#34;movl %1, %%ebx\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n       \u003cspan class=\"s\"\u003e\u0026#34;int $0x80\u0026#34;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* output parameters, we aren\u0026#39;t outputting anything, no none */\u003c/span\u003e\n      \u003cspan class=\"cm\"\u003e/* (none) */\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* input parameters mapped to %0 and %1, repsectively */\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* registers that we are \u0026#34;clobbering\u0026#34;, unneeded since we are calling exit */\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;eax\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;ebx\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e编译运行，查看返回值：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egcc \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e \u003cspan class=\"nb\"\u003etest \u003c/span\u003etest.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./test\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$?\u003c/span\u003e\n42\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e成功！我们通过触发一个软中断完成了一次传统系统调用。\u003c/p\u003e\n\n\u003ch2 id=\"32-内核端int-0x80-入口\"\u003e3.2 内核端：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $0x80\u003c/code\u003e 入口\u003c/h2\u003e\n\n\u003cp\u003e上面看到了如何从用户端触发一个系统调用，接下来看内核端是如何实现的。\u003c/p\u003e\n\n\u003cp\u003e前面提到内核注册了一个系统调用回调函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_syscall\u003c/code\u003e。这个函数定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L426\"\u003earch/x86/ia32/ia32entry.S\u003c/a\u003e\n。函数里最重要的一件事情，就是调用 \u003cstrong\u003e真正的系统调用\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nl\"\u003eia32_do_call:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eIA32_ARG_FIXUP\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eia32_sys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e(,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"err\"\u003e#\u003c/span\u003e \u003cspan class=\"n\"\u003exxx\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003erip\u003c/span\u003e \u003cspan class=\"n\"\u003erelative\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e宏 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIA32_ARG_FIXUP\u003c/code\u003e 的作用是对传入的参数进行重新排列，以便能被当前的系统调用层正\n确处理。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_sys_call_table\u003c/code\u003e 是一个中断号列表，定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/syscall_ia32.c#L18-L25\"\u003earch/x86/ia32/syscall_ia32.c\u003c/a\u003e\n，注意代码结束处的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003esys_call_ptr_t\u003c/span\u003e \u003cspan class=\"n\"\u003eia32_sys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e__NR_ia32_syscall_max\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/*\n         * Smells like a compiler bug -- it doesn\u0026#39;t work\n         * when the \u0026amp; below is removed.\n         */\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"n\"\u003e__NR_ia32_syscall_max\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecompat_ni_syscall\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;asm/syscalls_32.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e回忆前面在 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69\"\u003earch/x86/syscalls/syscall_64.tbl\u003c/a\u003e\n中看到了系统调用列表的定义。有几个脚本会在内核编译期间运行，通过这个文件生成\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscalls_32.h\u003c/code\u003e 头文件，后者是合法的 C 代码文件，通过上面看到的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include\u003c/code\u003e 插入到\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_sys_call_table\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e这就是通过 \u003cstrong\u003e传统系统调用方式\u003c/strong\u003e进入内核的过程。\u003c/p\u003e\n\n\u003ch2 id=\"33-iret-系统调用返回\"\u003e3.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e: 系统调用返回\u003c/h2\u003e\n\n\u003cp\u003e至此我们已经看到了如何通过软中断进入内核，那么，系统调用结束后，内核又是如何释放\n特权级别回到用户空间的呢？\u003c/p\u003e\n\n\u003cp\u003e如果查看 \u003ca href=\"ftp://download.intel.com/design/processor/manuals/253668.pdf\"\u003eIntel Software Developer’s\nManual\u003c/a\u003e（警告：很\n大的 PDF），里面有一张非常有帮助的图，它解释了当特权级别变化时，程序栈是如何组织的：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/system-call-definitive-guide/isr_stack.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e执行转交给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_syscall\u003c/code\u003e 时会发生特权级别切换，其结果是进入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_syscall\u003c/code\u003e 时的\n栈会变成如上图所示的样子。从中可以看出，\u003cstrong\u003e返回地址、包含特权级别的 CPU flags 以\n及其他一些参数都在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_syscall\u003c/code\u003e 执行之前压入栈顶\u003c/strong\u003e。所以，内核只需要\u003cstrong\u003e将这些值\n从栈里复制回它们原来所在的寄存器，程序就可以回到用户空间继续执行\u003c/strong\u003e。那么，如何做\n呢？\u003c/p\u003e\n\n\u003cp\u003e有几种方式，其中最简单的是通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e 指令。\u003c/p\u003e\n\n\u003cp\u003eIntel 指令集手册解释说 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e 指令从栈上依次 pop 返回地址和保存的寄存器值：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eAs with a real-address mode interrupt return, the IRET instruction pops the\nreturn instruction pointer, return code segment selector, and EFLAGS image\nfrom the stack to the EIP, CS, and EFLAGS registers, respectively, and then\nresumes execution of the interrupted program or procedure.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e要在内核中找到相应的代码有点困难，因为它隐藏在多层宏后面，系统依赖这些宏处理很\n多事情，比例信号和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eptrace\u003c/code\u003e 系统返回跟踪。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eirq_return\u003c/code\u003e 定义在 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L1042-L1043\"\u003earch/x86/kernel/entry_64.S\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nl\"\u003eirq_return:\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eINTERRUPT_RETURN\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eINTERRUPT_RETURN\u003c/code\u003e 定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L132\"\u003earch/x86/include/asm/irqflags.h\u003c/a\u003e\n，就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiretq\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e以上就是传统系统调用如何工作的。\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch1 id=\"4-快速系统调用\"\u003e4 快速系统调用\u003c/h1\u003e\n\n\u003cp\u003e传统系统调用看起来合情合理，但也有新的方式，它们不需要软中断，因此更快。\u003c/p\u003e\n\n\u003cp\u003e两种快速方法都包含两个指令：一个进入内核的指令和一个离开内核的指令。在 Intel CPU\n文档中，两种方法都被称作\u003cstrong\u003e“快速系统调用”（Fast System Call）\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e但当 CPU 是 32bit 或 64bit 模式时，哪种方法是合法的，Intel 和 AMD 的实现不同。为\n了最大化 Intel 和 AMD CPU 的兼容性：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e在 32bit 系统上：使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e在 64bit 系统上：使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"41-32-bit-快速系统调用\"\u003e4.1 32-bit 快速系统调用\u003c/h2\u003e\n\n\u003ch3 id=\"411-sysentersysexit\"\u003e4.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 发起系统调用比使用传统中断方式复杂很多，涉及更多用户程序（通过\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e）和内核之间的协作。\u003c/p\u003e\n\n\u003cp\u003e我们逐步来看，一窥其中乾坤。首先来看 \u003ca href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf\"\u003eIntel Instruction Set\nReference\u003c/a\u003e\n（警告：很大的 PDF）如何描述 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 的，以及如何使用它。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ePrior to executing the SYSENTER instruction, software must specify the\nprivilege level 0 code segment and code entry point, and the privilege level 0\nstack segment and stack pointer by writing values to the following MSRs:\u003c/p\u003e\n\n  \u003cp\u003e• IA32_SYSENTER_CS (MSR address 174H) — The lower 16 bits of this MSR are the\nsegment selector for the privilege level 0 code segment. This value is also\nused to determine the segment selector of the privilege level 0 stack segment\n(see the Operation section). This value cannot indicate a null selector.\u003c/p\u003e\n\n  \u003cp\u003e• IA32_SYSENTER_EIP (MSR address 176H) — The value of this MSR is loaded into\nRIP (thus, this value references the first instruction of the selected\noperating procedure or routine). In protected mode, only bits 31:0 are loaded.\u003c/p\u003e\n\n  \u003cp\u003e• IA32_SYSENTER_ESP (MSR address 175H) — The value of this MSR is loaded into\nRSP (thus, this value contains the stack pointer for the privilege level 0\nstack). This value cannot represent a non-canonical address. In protected\nmode, only bits 31:0 are loaded.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e换言之，为了使 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 能够接收到系统调用请求，内核必须设置 3 个 MSR。这里最\n有意思的 MSR 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIA32_SYSENTER_EIP\u003c/code\u003e（地址 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x176\u003c/code\u003e），内核将回调函数地址放在这里\n，当 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 指令执行的时候，就触发调用相应的回调函数。\u003c/p\u003e\n\n\u003cp\u003e内核里写 MSR 的地方\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32-setup.c#L240\"\u003earch/x86/vdso/vdso32-setup.c\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eenable_sep_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* ... other code ... */\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003ewrmsr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMSR_IA32_SYSENTER_EIP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eia32_sysenter_target\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR_IA32_SYSENTER_EIP\u003c/code\u003e 定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L54\"\u003earch/x86/include/uapi/asm/msr-index.h\u003c/a\u003e\n，值为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x00000176\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e和传统软中断系统调用类似，使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 创建快速系统调用时也需要一个约定（\nconvention ）。内核的 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L99-L117\"\u003earch/x86/ia32/ia32entry.S\u003c/a\u003e 这里对这一过程做了注释说明：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"n\"\u003ebit\u003c/span\u003e \u003cspan class=\"n\"\u003eSYSENTER\u003c/span\u003e \u003cspan class=\"n\"\u003einstruction\u003c/span\u003e \u003cspan class=\"n\"\u003eentry\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eArguments\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eeax\u003c/span\u003e \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg1\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eecx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg2\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e \u003cspan class=\"n\"\u003eArg3\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eesi\u003c/span\u003e \u003cspan class=\"n\"\u003eArg4\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedi\u003c/span\u003e \u003cspan class=\"n\"\u003eArg5\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebp\u003c/span\u003e \u003cspan class=\"n\"\u003euser\u003c/span\u003e \u003cspan class=\"n\"\u003estack\u003c/span\u003e\n \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eArg6\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e回忆前面讲的，传统系统调用方式包含一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e 指令，用于在调用结束时返回用户程序。\u003c/p\u003e\n\n\u003cp\u003e跟踪 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 工作的逻辑是一项相当复杂的工作，因为和软中断不同，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 并\n不保存返回地址。内核在调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 之前所做的工作随着内核版本在不断变化（已经\n变了，接下来在 Bugs 小节会看到）。\u003c/p\u003e\n\n\u003cp\u003e为了消除将来的变动带来的影响，用户程序使用一个叫 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e\n的函数，它在内核实现，但每个用户进程启动的时候它会映射到用户进程。这颇为怪异，它\n是内核函数，但在用户空间运行。其实，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 是一种被称为\u003cstrong\u003e虚拟动态共\n享库\u003c/strong\u003e（virtual Dynamic Shared Object, vDSO）的一部分，这种技术允许\u003cstrong\u003e在用户空间\n执行内核代码\u003c/strong\u003e。我们后面会深入介绍 vDSO 的原理和用途。现在，先看\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 的实现。\u003c/p\u003e\n\n\u003ch3 id=\"412-__kernel_vsyscall-实现\"\u003e4.1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 实现\u003c/h3\u003e\n\n\u003cp\u003e内核函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 封装了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 调用约定（calling convention）,见\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso32/sysenter.S#L31-L40\"\u003earch/x86/vdso/vdso32/sysenter.S\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nl\"\u003e__kernel_vsyscall:\u003c/span\u003e\n\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLSTART_vsyscall\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epush\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eecx\u003c/span\u003e\n\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLpush_ecx\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epush\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e\n\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLpush_edx\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epush\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebp\u003c/span\u003e\n\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eLenter_kernel\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovl\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eesp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eebp\u003c/span\u003e\n        \u003cspan class=\"n\"\u003esysenter\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 属于 vDSO 的一部分，vDSO 是共享库，那用户程序是如何在运行时\n确定函数地址的呢？\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 的地址写入了 \u003ca href=\"https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html\"\u003eELF auxiliary\nvector\u003c/a\u003e\n（辅助功能矢量），用户程序能（典型情况下通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e）找到后者并使用它。寻找 ELF\nauxiliary vector 有多种方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e通过 \u003ca href=\"http://man7.org/linux/man-pages/man3/getauxval.3.html\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egetauxval\u003c/code\u003e\u003c/a\u003e，带 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO\u003c/code\u003e 参数\u003c/li\u003e\n  \u003cli\u003e遍历环境变量，从内存解析\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e方法 1 是最简单的方式，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 2.16+ 才支持。下面的示例代码使用方法 2.\u003c/p\u003e\n\n\u003cp\u003e我们已经看到，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 在调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 之前做了一些 bookkeeping 工\n作。因此，要手动进入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e，我们需要：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e在 ELF auxiliary vector 中搜索 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO\u003c/code\u003e 字段，这是写 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e\n地址的地方\u003c/li\u003e\n  \u003cli\u003e将系统调用编号和参数写入寄存器，这一步和传统系统调用的步骤类似\u003c/li\u003e\n  \u003cli\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e不要试图自己写进入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 的 wrapper 函数，因为内核和它的进出系统调用的约定\n随着时间在变，最终你的代码会变得不可用。应该永远使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 进入\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"413-用户程序端写汇编调用-sysenter\"\u003e4.1.3 用户程序端：写汇编调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e和传统系统调用的例子一样，我们手动调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e ，设置返回值为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e42\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调号是 1，根据上面描述的调用接口，我们需要将系统调用编号放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeax\u003c/code\u003e 寄\n存器，第一个参数（返回值）放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eebx\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e(这个程序其实还可以进一步简化，这样写是为了让没有 GCC 内联汇编基础的读者更容易看\n懂。)\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdlib.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;elf.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eargc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e[],\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eenvp\u003c/span\u003e\u003cspan class=\"p\"\u003e[])\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"n\"\u003eElf32_auxv_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eauxv\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"cm\"\u003e/* auxilliary vectors are located after the end of the environment\n   * variables\n   *\n   * check this helpful diagram: https://static.lwn.net/images/2012/auxvec.png\n   */\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eenvp\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n  \u003cspan class=\"cm\"\u003e/* envp is now pointed at the auxilliary vectors, since we\u0026#39;ve iterated\n   * through the environment variables.\n   */\u003c/span\u003e\n  \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eauxv\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eElf32_auxv_t\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eenvp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003eauxv\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea_type\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003eAT_NULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003eauxv\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"n\"\u003eauxv\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea_type\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003eAT_SYSINFO\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"k\"\u003ebreak\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"cm\"\u003e/* NOTE: in glibc 2.16 and higher you can replace the above code with\n   * a call to getauxval(3):  getauxval(AT_SYSINFO)\n   */\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003easm\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;movl %0,  %%eax    \u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;movl %1, %%ebx    \u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;call *%2          \u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* output parameters, we aren\u0026#39;t outputting anything, no none */\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* (none) */\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* input parameters mapped to %0 and %1, repsectively */\u003c/span\u003e\n        \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eauxv\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ea_un\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ea_val\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* registers that we are \u0026#34;clobbering\u0026#34;, unneeded since we are calling exit */\u003c/span\u003e\n        \u003cspan class=\"s\"\u003e\u0026#34;eax\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;ebx\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e(译者注：这里 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain\u003c/code\u003e 函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain(int argc, char* argv[], char* envp[])\u003c/code\u003e的签名很特\n殊，常见的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain\u003c/code\u003e 都是不带参数或带两个参数，带三个参数的平时还是比较少见。)\u003c/p\u003e\n\n\u003cp\u003e编译，运行，查看返回值：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egcc \u003cspan class=\"nt\"\u003e-m32\u003c/span\u003e \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e \u003cspan class=\"nb\"\u003etest \u003c/span\u003etest.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./test\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$?\u003c/span\u003e\n42\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e成功！我们使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 方法调用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调用，而不是通过触发软件中断的方式。\u003c/p\u003e\n\n\u003ch3 id=\"414-内核端sysenter-入口\"\u003e4.1.4 内核端：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 入口\u003c/h3\u003e\n\n\u003cp\u003e现在已经看到了如何在用户程序中通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 方式进入系\n统调用，接下来看一下内核端的实现。\u003c/p\u003e\n\n\u003cp\u003e回忆前面，内核注册了一个系统调用回调函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_sysenter_taret\u003c/code\u003e。这个函数在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L162-L163\"\u003earch/x86/ia32/ia32entry.S\u003c/a\u003e\n。看下执行系统调用的时候 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeax\u003c/code\u003e 寄存器中的值如何被使用的：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nl\"\u003esysenter_dispatch:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecall\u003c/span\u003e    \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eia32_sys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e(,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这和前面传统系统调用的代码完全相同：用系统调用编号作为索引去\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_sys_call_table\u003c/code\u003e 列表查找回调函数。也就是说，做完必须的 bookkeeping 工作后，\n传统方式和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 方式通过相同的机制（表+索引）分发系统调用。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eia32_sys_call_table\u003c/code\u003e 是如何定义及构建出来的可以查看前面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $0x80 入口\u003c/code\u003e 小节。\u003c/p\u003e\n\n\u003cp\u003e这就是通过 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 系统调用方式\u003c/strong\u003e进入内核的原理。\u003c/p\u003e\n\n\u003ch3 id=\"415-sysexit从-sysenter-返回\"\u003e4.1.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e：从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 返回\u003c/h3\u003e\n\n\u003cp\u003e内核使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e 指令恢复用户程序的执行。\u003c/p\u003e\n\n\u003cp\u003e这个指令的使用并不像 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiret\u003c/code\u003e 那样直接。调用者必须将需要返回的地址放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e 寄存\n器，将需要使用的栈地址放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ercx\u003c/code\u003e 寄存器。这意味着\u003cstrong\u003e应用程序需要自己计算程序恢复\n执行时的地址\u003c/strong\u003e，保存这个值，然后在调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e 之前恢复它。这个过程的代码实现\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/ia32/ia32entry.S#L169-L185\"\u003earch/x86/ia32/ia32entry.S\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nl\"\u003esysexit_from_sys_call:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eandl\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"o\"\u003e~\u003c/span\u003e\u003cspan class=\"n\"\u003eTS_COMPAT\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eTI_status\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003eTHREAD_INFO\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eRIP\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eARGOFFSET\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* clear IF, that popfq doesn\u0026#39;t enable interrupts early */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eandl\u003c/span\u003e  \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"o\"\u003e~\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x200\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eEFLAGS\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eR11\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovl\u003c/span\u003e    \u003cspan class=\"n\"\u003eRIP\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eR11\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e              \u003cspan class=\"cm\"\u003e/* User %eip */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eCFI_REGISTER\u003c/span\u003e \u003cspan class=\"n\"\u003erip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003erdx\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eRESTORE_ARGS\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e24\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n        \u003cspan class=\"n\"\u003exorq\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8\u003c/span\u003e\n        \u003cspan class=\"n\"\u003exorq\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er9\u003c/span\u003e\n        \u003cspan class=\"n\"\u003exorq\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e\n        \u003cspan class=\"n\"\u003exorq\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er11\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er11\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epopfq_cfi\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/*CFI_RESTORE rflags*/\u003c/span\u003e\n        \u003cspan class=\"n\"\u003epopq_cfi\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ercx\u003c/span\u003e                           \u003cspan class=\"cm\"\u003e/* User %esp */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eCFI_REGISTER\u003c/span\u003e \u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ercx\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eTRACE_IRQS_ON\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eENABLE_INTERRUPTS_SYSEXIT32\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eENABLE_INTERRUPTS_SYSEXIT32\u003c/code\u003e 宏封装了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e，定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L139-L143\"\u003earch/x86/include/asm/irqflags.h\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e这就是 \u003cstrong\u003e32 位系统上的快速系统调用\u003c/strong\u003e是如何工作的。\u003c/p\u003e\n\n\u003ch2 id=\"42-64-bit-快速系统调用\"\u003e4.2 64-bit 快速系统调用\u003c/h2\u003e\n\n\u003cp\u003e接下来看 64 位系统的快速系统调用的工作原理，它用到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e 两个\n指令。\u003c/p\u003e\n\n\u003ch3 id=\"421-syscallsysret\"\u003e4.2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-2b-manual.pdf\"\u003eIntel Instruction Set\nReference\u003c/a\u003e\n(警告：很大的 PDF）解释了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 是如何工作的：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eSYSCALL invokes an OS system-call handler at privilege level 0. It does so by\nloading RIP from the IA32_LSTAR MSR (after saving the address of the\ninstruction following SYSCALL into RCX).\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e意思是，要使内核接收系统调用请求，必须将对应的回调函数地址写到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIA32_LSTAR\u003c/code\u003e MSR\n。相应的代码实现在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/cpu/common.c#L1128\"\u003earch/x86/kernel/cpu/common.c\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003esyscall_init\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/* ... other code ... */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ewrmsrl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eMSR_LSTAR\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esystem_call\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR_LSART\u003c/code\u003e 的值是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0xc0000082\u003c/code\u003e，定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/uapi/asm/msr-index.h#L9\"\u003earch/x86/include/uapi/asm/msr-index.h\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e和传统系统调用类似，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 方式需要定义一种调用约定（convention）：\n\u003cstrong\u003e用户空间程序将系统调用编号放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erax\u003c/code\u003e 寄存器，参数放到通用寄存器。\u003c/strong\u003e\n这定义在 \u003ca href=\"http://www.x86-64.org/documentation/abi.pdf\"\u003ex86-64 ABI\u003c/a\u003e 的 A.2.1 小节:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003col\u003e\n    \u003cli\u003eUser-level applications use as integer registers for passing the sequence\n%rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface uses %rdi, %rsi,\n%rdx, %r10, %r8 and %r9.\u003c/li\u003e\n    \u003cli\u003eA system-call is done via the syscall instruction. The kernel destroys\nregisters %rcx and %r11.\u003c/li\u003e\n    \u003cli\u003eThe number of the syscall has to be passed in register %rax.\u003c/li\u003e\n    \u003cli\u003eSystem-calls are limited to six arguments,no argument is passed directly on\nthe stack.\u003c/li\u003e\n    \u003cli\u003eReturning from the syscall, register %rax contains the result of the\nsystem-call. A value in the range between -4095 and -1 indicates an error,\nit is -errno.\u003c/li\u003e\n    \u003cli\u003eOnly values of class INTEGER or class MEMORY are passed to the kernel.\u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e内核源文件 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L569-L591\"\u003earch/x86/kernel/entry_64.S\u003c/a\u003e 也对这个有注释说明。\u003c/p\u003e\n\n\u003cp\u003e接下来写汇编试验一下。\u003c/p\u003e\n\n\u003ch3 id=\"422-用户空间发起系统调用\"\u003e4.2.2 用户空间：发起系统调用\u003c/h3\u003e\n\n\u003cp\u003e还是前面的例子，手动写代码调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调用，设置返回值为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e42\u003c/code\u003e 。\u003c/p\u003e\n\n\u003cp\u003e首先找 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 的系统调用编号，这次定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl#L69\"\u003earch/x86/syscalls/syscall_64.tbl\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"mi\"\u003e60\u003c/span\u003e      \u003cspan class=\"n\"\u003ecommon\u003c/span\u003e  \u003cspan class=\"n\"\u003eexit\u003c/span\u003e                    \u003cspan class=\"n\"\u003esys_exit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e按照调用约定，需要将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e60\u003c/code\u003e 放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erax\u003c/code\u003e 寄存器，第一个参数（返回值）放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdi\u003c/code\u003e 寄存\n器。\u003c/p\u003e\n\n\u003cp\u003e相应的 C 代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eargc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e[])\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e60\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003easm\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;movq %0, %%rax\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n       \u003cspan class=\"s\"\u003e\u0026#34;movq %1, %%rdi\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\n       \u003cspan class=\"s\"\u003e\u0026#34;syscall\u0026#34;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* output parameters, we aren\u0026#39;t outputting anything, no none */\u003c/span\u003e\n      \u003cspan class=\"cm\"\u003e/* (none) */\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* input parameters mapped to %0 and %1, repsectively */\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;m\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* registers that we are \u0026#34;clobbering\u0026#34;, unneeded since we are calling exit */\u003c/span\u003e\n      \u003cspan class=\"s\"\u003e\u0026#34;rax\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;rdi\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e编译，运行，查看返回值：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egcc \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e \u003cspan class=\"nb\"\u003etest \u003c/span\u003etest.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./test\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$?\u003c/span\u003e\n42\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e成功！我们通过 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 方式\u003c/strong\u003e完成了一次系统调用，避免了软中断，从而速度更快。\u003c/p\u003e\n\n\u003ch3 id=\"423-内核空间syscall-入口\"\u003e4.2.3 内核空间：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 入口\u003c/h3\u003e\n\n\u003cp\u003e接下来看内核端是如何实现的。\u003c/p\u003e\n\n\u003cp\u003e回忆前面，我们看到一个名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem_call\u003c/code\u003e 函数的地址写到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLSTAR\u003c/code\u003e MSR。\n我们来看下这个函数的实现，看它如何使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erax\u003c/code\u003e 将执行交给系统调用的，\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L629\"\u003earch/x86/kernel/entry_64.S\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e        \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e(,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \u003cspan class=\"err\"\u003e#\u003c/span\u003e \u003cspan class=\"n\"\u003eXXX\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e    \u003cspan class=\"n\"\u003erip\u003c/span\u003e \u003cspan class=\"n\"\u003erelative\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e和传统系统调用方式类似，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esys_call_table\u003c/code\u003e 是一个数组，定义在 C 文件，通过\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include\u003c/code\u003e 方式生成。\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/syscall_64.c#L25-L32\"\u003earch/x86/kernel/syscall_64.c\u003c/a\u003e\n，注意末尾的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#include\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003easmlinkage\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003esys_call_ptr_t\u003c/span\u003e \u003cspan class=\"n\"\u003esys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003e__NR_syscall_max\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"cm\"\u003e/*\n         * Smells like a compiler bug -- it doesn\u0026#39;t work\n         * when the \u0026amp; below is removed.\n         */\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"p\"\u003e...\u003c/span\u003e \u003cspan class=\"n\"\u003e__NR_syscall_max\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003esys_ni_syscall\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;asm/syscalls_64.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 数组定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/syscalls/syscall_64.tbl\"\u003earch/x86/syscalls/syscall_64.tbl\u003c/a\u003e\n。也和传统方式类似，在内核编译期间脚本通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall_64.tbl\u003c/code\u003e 生成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscalls_64.h\u003c/code\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e这就是如何通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 方式的系统调用进入内核的过程。\u003c/p\u003e\n\n\u003ch3 id=\"424-sysret系统调用返回\"\u003e4.2.4 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e：系统调用返回\u003c/h3\u003e\n\n\u003cp\u003e内核通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e 指令将执行过程返还给用户程序。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e 比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysexit\u003c/code\u003e 要简单，因\n为当执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 的时候，恢复执行的地址复制到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ercx\u003c/code\u003e。只要将值缓存到某处，在\n调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e 离开之前再把它恢复到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ercx\u003c/code\u003e，那执行过程就能恢复到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 之前的程\n序和状态。这比 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 方便，因为后者还需要应用程序自己计算恢复执行的地址，需\n要用到额外的寄存器。\u003c/p\u003e\n\n\u003cp\u003e相应的代码 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/kernel/entry_64.S#L650-L655\"\u003earch/x86/kernel/entry_64.S\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"n\"\u003eRIP\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eARGOFFSET\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ercx\u003c/span\u003e\n\u003cspan class=\"n\"\u003eCFI_REGISTER\u003c/span\u003e    \u003cspan class=\"n\"\u003erip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003ercx\u003c/span\u003e\n\u003cspan class=\"n\"\u003eRESTORE_ARGS\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eARG_SKIP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\n\u003cspan class=\"cm\"\u003e/*CFI_REGISTER  rflags,r11*/\u003c/span\u003e\n\u003cspan class=\"n\"\u003emovq\u003c/span\u003e    \u003cspan class=\"n\"\u003ePER_CPU_VAR\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eold_rsp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\n\u003cspan class=\"n\"\u003eUSERGS_SYSRET64\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eUSERGS_SYSRET64\u003c/code\u003e 宏封装了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysret\u003c/code\u003e，定义在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/include/asm/irqflags.h#L133-L135\"\u003earch/x86/include/asm/irqflags.h\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e这就是 \u003cstrong\u003e64 位系统上快速系统调用\u003c/strong\u003e如何工作的。\u003c/p\u003e\n\n\u003ch1 id=\"5-通过-syscall2-半手动发起系统调用\"\u003e5 通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall(2)\u003c/code\u003e 半手动发起系统调用\u003c/h1\u003e\n\n\u003cp\u003e现在，我们已经看到如何手动写汇编通过几种不同方式触发系统调用了。通常不需要自己写\n汇编程序，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 已经提供了 wrapper 函数处理这些事情。然而，有些系统调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e\n没有提供 wrapper，一个例子是\n\u003ca href=\"http://man7.org/linux/man-pages/man7/futex.7.html#NOTES\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efutex\u003c/code\u003e\u003c/a\u003e，\u003cstrong\u003e快速用户空\n间锁（fast userspace locking）\u003c/strong\u003e系统调用。为什么没有为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efutex\u003c/code\u003e 实现一个 wrapper\n呢？\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efutex\u003c/code\u003e 的设计里它\u003cstrong\u003e只会被库函数（library）调用，并不会被应用程序直接调用\u003c/strong\u003e。因\n此，要调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efutex\u003c/code\u003e，你有两种方式可选：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e为每个你希望支持的平台生成汇编 stubs（桩函数）\u003c/li\u003e\n  \u003cli\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e wrapper\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果要使用一个没有 wrapper 的系统，你应该首选方法 2。\u003c/p\u003e\n\n\u003cp\u003e接下来看如何使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e，返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e42\u003c/code\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eargc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003echar\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eargv\u003c/span\u003e\u003cspan class=\"p\"\u003e[])\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e60\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e42\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003esyscall\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esyscall_nr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eexit_status\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e编译，运行，查看返回值：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egcc \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e \u003cspan class=\"nb\"\u003etest \u003c/span\u003etest.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./test\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"nv\"\u003e$?\u003c/span\u003e\n42\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e成功！我们用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e wrapper 发起了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 系统调用。\u003c/p\u003e\n\n\u003ch2 id=\"glibc-syscall-wrapper-内部实现\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e wrapper 内部实现\u003c/h2\u003e\n\n\u003cp\u003e代码 \u003ca href=\"https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/syscall.S#L24-L42\"\u003esysdeps/unix/sysv/linux/x86_64/syscall.S\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* Usage: long syscall (syscall_number, arg1, arg2, arg3, arg4, arg5, arg6)\n   We need to do some arg shifting, the syscall_number will be in\n   rax.  */\u003c/span\u003e\n\n\n        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etext\u003c/span\u003e\n\u003cspan class=\"n\"\u003eENTRY\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esyscall\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdi\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e         \u003cspan class=\"cm\"\u003e/* Syscall number -\u0026gt; rax.  */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersi\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdi\u003c/span\u003e         \u003cspan class=\"cm\"\u003e/* shift arg1 - arg5.  */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersi\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ercx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdx\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er10\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8\u003c/span\u003e\n        \u003cspan class=\"n\"\u003emovq\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er9\u003c/span\u003e        \u003cspan class=\"cm\"\u003e/* arg6 is on the stack.  */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003esyscall\u003c/span\u003e                 \u003cspan class=\"cm\"\u003e/* Do the system call.  */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecmpq\u003c/span\u003e \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e4095\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e       \u003cspan class=\"cm\"\u003e/* Check %rax for error.  */\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ejae\u003c/span\u003e \u003cspan class=\"n\"\u003eSYSCALL_ERROR_LABEL\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* Jump to error handler if error.  */\u003c/span\u003e\n\u003cspan class=\"n\"\u003eL\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epseudo_end\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eret\u003c/span\u003e                     \u003cspan class=\"cm\"\u003e/* Return to caller.  */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e前面我们介绍过 x86_64 ABI 文档，描述了用户态和内核态的调用约定。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e这段汇编 stub 代码非常酷，因为它同时展示了两个调用约定\u003c/strong\u003e：传递给这个函数的参数\n符合 \u003cstrong\u003e用户空间调用约定\u003c/strong\u003e，然后将这些参数移动到其他寄存器，使得它们在通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e\n进入内核之前符合 \u003cstrong\u003e内核调用约定\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e wrapper 如何工作的。\u003c/p\u003e\n\n\u003ch1 id=\"6-虚拟系统调用\"\u003e6 虚拟系统调用\u003c/h1\u003e\n\n\u003cp\u003e到目前为止，我们已经展示了通过多种触发系统调用的方式从用户空间进入内核的过程。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e能否让用户程序不进入内核，就可以发起特定的系统调用呢？\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e这就是 Linux \u003cstrong\u003e虚拟动态共享库\u003c/strong\u003e（VDSO）技术。Linux vDSO 是一段内核代码，但映射到\n用户空间，因而可以被用户空间程序直接调用。其设计思想就是部分系统调用无需用户程序\n进入内核就可以调用，\u003cstrong\u003e一个例子就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 的程序无需进入内核，而是调用内核提供的、运行在用户空间的代码\n。无需软中断，无需复杂的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 等 bookkeeping 工作，就像一个正\n常的函数调用一样。\u003c/p\u003e\n\n\u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eldd\u003c/code\u003e 查看时，可以看到列出的第一个已加载库就是 vDSO：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eldd \u003cspan class=\"sb\"\u003e`\u003c/span\u003ewhich bash\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\n  linux-vdso.so.1 \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e  \u003cspan class=\"o\"\u003e(\u003c/span\u003e0x00007fff667ff000\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  libtinfo.so.5 \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e /lib/x86_64-linux-gnu/libtinfo.so.5 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0x00007f623df7d000\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  libdl.so.2 \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e /lib/x86_64-linux-gnu/libdl.so.2 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0x00007f623dd79000\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  libc.so.6 \u003cspan class=\"o\"\u003e=\u0026gt;\u003c/span\u003e /lib/x86_64-linux-gnu/libc.so.6 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0x00007f623d9ba000\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  /lib64/ld-linux-x86-64.so.2 \u003cspan class=\"o\"\u003e(\u003c/span\u003e0x00007f623e1ae000\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e接下来看 vDSO 在内核是如何实现的。\u003c/p\u003e\n\n\u003ch2 id=\"61-vdso-在内核中的实现\"\u003e6.1 vDSO 在内核中的实现\u003c/h2\u003e\n\n\u003cp\u003evDSO 的代码位于\n\u003ca href=\"https://github.com/torvalds/linux/tree/v3.13/arch/x86/vdso\"\u003earch/x86/vdso/\u003c/a\u003e，由\n一些汇编、C 和一个连接器脚本组成。\u003c/p\u003e\n\n\u003cp\u003e连接器脚本是一个很酷的东西，\n\u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vdso.lds.S\"\u003earch/x86/vdso/vdso.lds.S\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e/\u003cspan class=\"k\"\u003e*\u003c/span\u003e\n \u003cspan class=\"k\"\u003e*\u003c/span\u003e This controls what userland symbols we \u003cspan class=\"nb\"\u003eexport \u003c/span\u003efrom the vDSO.\n \u003cspan class=\"k\"\u003e*\u003c/span\u003e/\nVERSION \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        LINUX_2.6 \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        global:\n                clock_gettime\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                __vdso_clock_gettime\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                gettimeofday\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                __vdso_gettimeofday\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                getcpu\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                __vdso_getcpu\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                \u003cspan class=\"nb\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n                __vdso_time\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"nb\"\u003elocal\u003c/span\u003e: \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"o\"\u003e}\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e链接器脚本是一个很有用的东西，但知道的人并不多。这个脚本排列了即将通过 vDSO 导出\n的符号（函数）。我们能看到它导出了 4 个函数，每个函数都有两个名字。每个函数的定义\n可以在这个目录中的 C 文件中找到。\u003c/p\u003e\n\n\u003cp\u003e例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 在 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L281-L282\"\u003earch/x86/vdso/vclock_gettime.c\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eint gettimeofday\u003cspan class=\"o\"\u003e(\u003c/span\u003estruct timeval \u003cspan class=\"k\"\u003e*\u003c/span\u003e, struct timezone \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n        __attribute__\u003cspan class=\"o\"\u003e((\u003c/span\u003eweak, \u003cspan class=\"nb\"\u003ealias\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;__vdso_gettimeofday\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e)))\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里定义了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__vdso_gettimeofday\u003c/code\u003e 的\u003ca href=\"https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html\"\u003eweak\nalias\u003c/a\u003e。\n后者的定义在 \u003ca href=\"https://github.com/torvalds/linux/blob/v3.13/arch/x86/vdso/vclock_gettime.c#L260-L280\"\u003e同一个源文件\n\u003c/a\u003e\n中，当用户程序调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 时，实际执行的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__vdso_gettimeofday\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"62-在内存中定位-vdso\"\u003e6.2 在内存中定位 vDSO\u003c/h2\u003e\n\n\u003cp\u003e由于\u003ca href=\"https://en.wikipedia.org/wiki/Address_space_layout_randomization\"\u003e地址空间布局随机化\n\u003c/a\u003e（address\nspace layout randomization）的存在，vDSO 会在程序启动时加载到一个随机地址。\n那么，用户程序是如何找到 vDSO 的呢？\u003c/p\u003e\n\n\u003cp\u003e前面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 章节，我们看到用户程序应该调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 而\n不是写他们自己的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 汇编代码。这个函数其实就是 vDSO 的一部分。\n相同的代码用于在 \u003ca href=\"https://www.gnu.org/software/libc/manual/html_node/Auxiliary-Vector.html\"\u003eELF auxiliary\nheaders\u003c/a\u003e\n里搜索一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO\u003c/code\u003e 类型的头，以此来定位 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e 的位置。\u003c/p\u003e\n\n\u003cp\u003e类似地，要确定 vDSO 的地址，用户程序可以搜索 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO_EHDR\u003c/code\u003e 类型 ELF auxiliary\nheader，它包含了 vDSO 的 ELF 头的内存地址。\u003c/p\u003e\n\n\u003cp\u003e以上两种情况，内核都在程序加载时将 vDSO 地址写入 ELF 头，这就是为什么 vDSO 的地\n址永远出现在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO_EHDR\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAT_SYSINFO\u003c/code\u003e 的原因。\u003c/p\u003e\n\n\u003cp\u003e定位到 header 之后，用户程序就可以解析 ELF 对象（例如通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibelf\u003c/code\u003e），调用里面的函数\n。这种方式很好，因为这意味着 vDSO 可以用到一些 ELF 特性，例如 \u003ca href=\"https://www.akkadia.org/drepper/symbol-versioning\"\u003e符号版本\n\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e内核文档\n\u003ca href=\"https://github.com/torvalds/linux/tree/v3.13/Documentation/vDSO\"\u003eDocumentation/vDSO/\u003c/a\u003e\n提供了一个解析和调用 vDSO 中函数的例子。\u003c/p\u003e\n\n\u003ch2 id=\"63-glibc-中的-vdso\"\u003e6.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 中的 vDSO\u003c/h2\u003e\n\n\u003cp\u003e很多情况下大家已经用到了 vDSO，只是没意识到，这是因为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 使用我们前面介绍的\n接口对它做了封装。\u003c/p\u003e\n\n\u003cp\u003e当程序加载的时候，\u003ca href=\"http://man7.org/linux/man-pages/man8/ld.so.8.html\"\u003e动态连接器和加载器\n\u003c/a\u003e会加载程序依赖的动态链接库（\nDSO），其中就包括 vDSO。\u003c/p\u003e\n\n\u003cp\u003e解析 ELF 头的时候，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 保存了 vDSO 的位置信息等数据，后面加载的时候会用上。另\n外，它还包含了一个很短的 stub 函数，在系统调用真正发生之前在 vDSO 中查找符号（函数\n）。\u003c/p\u003e\n\n\u003cp\u003e例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 函数，\n\u003ca href=\"https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/sysv/linux/x86_64/gettimeofday.c#L26-L37\"\u003esysdeps/unix/sysv/linux/x86_64/gettimeofday.c\u003c/a\u003e\n：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003egettimeofday_ifunc\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003e__asm__\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;__gettimeofday\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"nf\"\u003egettimeofday_ifunc\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"n\"\u003ePREPARE_VERSION\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elinux26\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;LINUX_2.6\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e61765110\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n  \u003cspan class=\"cm\"\u003e/* If the vDSO is not available we fall back on the old vsyscall.  */\u003c/span\u003e\n  \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_dl_vdso_vsym\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;gettimeofday\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003elinux26\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n          \u003cspan class=\"o\"\u003e?:\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"n\"\u003eVSYSCALL_ADDR_vgettimeofday\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"kr\"\u003e__asm\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;.type __gettimeofday, %gnu_indirect_function\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这段代码在 vDSO 中寻找 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 函数的地址并返回，它使用了\u003ca href=\"http://willnewton.name/uncategorized/using-gnu-indirect-functions/\"\u003e重定向函\n数\u003c/a\u003e（\nindirect function）来优雅地完成这一过程。\u003c/p\u003e\n\n\u003cp\u003e应用程序就是通过这种方式经 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 调用 vDSO 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egettimeofday\u003c/code\u003e 函数，从而避免了\n切换到内核、提升特权级别以及触发软中断等过程。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e以上就是 Linux 32 和 64 位系统上所有的发起系统调用的方法\u003c/strong\u003e，适用于 Intel 和 AMD CPU。\u003c/p\u003e\n\n\u003ch1 id=\"7-glibc-系统调用-wrappers\"\u003e7 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 系统调用 wrappers\u003c/h1\u003e\n\n\u003cp\u003e前面讨论的都是 Linux 系统调用本身，接下来将范围稍微向外一些，看一看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 作为\n更上层库是如何处理系统调用的。\u003c/p\u003e\n\n\u003cp\u003e对于很多系统调用，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 只用到了一个简单的 wrapper 程序：将参数放到合适的寄存器\n，然后执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eint $0x80\u003c/code\u003e 指令，或者调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e。这个过程\n用到了一系列的列表，这些列表的核心内容定义在几个文本文件里，然后被脚本文件处理之\n后生成 C 代码。\u003c/p\u003e\n\n\u003cp\u003e例如，\n\u003ca href=\"https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/syscalls.list\"\u003esysdeps/unix/syscalls.list\u003c/a\u003e\n文件描述了一些常规系统调用：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eaccess\u003c/span\u003e          \u003cspan class=\"o\"\u003e-\u003c/span\u003e       \u003cspan class=\"n\"\u003eaccess\u003c/span\u003e          \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003esi\u003c/span\u003e    \u003cspan class=\"n\"\u003e__access\u003c/span\u003e        \u003cspan class=\"n\"\u003eaccess\u003c/span\u003e\n\u003cspan class=\"n\"\u003eacct\u003c/span\u003e            \u003cspan class=\"o\"\u003e-\u003c/span\u003e       \u003cspan class=\"n\"\u003eacct\u003c/span\u003e            \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e     \u003cspan class=\"n\"\u003eacct\u003c/span\u003e\n\u003cspan class=\"n\"\u003echdir\u003c/span\u003e           \u003cspan class=\"o\"\u003e-\u003c/span\u003e       \u003cspan class=\"n\"\u003echdir\u003c/span\u003e           \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003es\u003c/span\u003e     \u003cspan class=\"n\"\u003e__chdir\u003c/span\u003e         \u003cspan class=\"n\"\u003echdir\u003c/span\u003e\n\u003cspan class=\"n\"\u003echmod\u003c/span\u003e           \u003cspan class=\"o\"\u003e-\u003c/span\u003e       \u003cspan class=\"n\"\u003echmod\u003c/span\u003e           \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"n\"\u003esi\u003c/span\u003e    \u003cspan class=\"n\"\u003e__chmod\u003c/span\u003e         \u003cspan class=\"n\"\u003echmod\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要了解每一列代表什么，请查看这个文件里的注释：\n\u003ca href=\"https://github.molgen.mpg.de/git-mirror/glibc/blob/glibc-2.15/sysdeps/unix/make-syscalls.sh\"\u003esysdeps/unix/make-syscalls.sh\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e更复杂的系统调用，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e，并没有包含在这样的文本文件中，因为它们涉及到独立\n的 C 或汇编处理函数实现。\u003c/p\u003e\n\n\u003cp\u003e我们将来的博客会针对有趣的系统调用来探索 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 的实现以及 Linux 内核相关的内容。\u003c/p\u003e\n\n\u003ch1 id=\"8-syscall-相关的有趣-bugs\"\u003e8 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 相关的有趣 bugs\u003c/h1\u003e\n\n\u003cp\u003e如果不趁此机会介绍几个与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e 相关的著名的 bug，就未免太过遗憾了。\u003c/p\u003e\n\n\u003cp\u003e我们来看两个。\u003c/p\u003e\n\n\u003ch2 id=\"81-cve-2010-3301\"\u003e8.1 CVE-2010-3301\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"http://cve.mitre.org/cgi-bin/cvename.cgi?name=2010-3301\"\u003e这个安全漏洞\u003c/a\u003e允许本地\n用户获取 root 权限。\u003c/p\u003e\n\n\u003cp\u003e根本原因是汇编代码有一个小 bug，在 x86-64 平台上允许用户程序进行传统方式的系统调\n用。恶意代码非常聪明：它用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emmap\u003c/code\u003e 在一个特定地址生成一块内存区域，然后利用整形溢\n出（integer overflow）使得如下代码（还记得这段代码吗？在前面的传统系统调用小节我\n们介绍过）将执行移交到一段任意地址，以内核代码模式运行，将进程的特权级别升级到\nroot 级。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eia32_sys_call_table\u003c/span\u003e\u003cspan class=\"p\"\u003e(,\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"82-android-sysenter-abi-hardcode\"\u003e8.2 Android \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e ABI hardcode\u003c/h2\u003e\n\n\u003cp\u003e还记得前面说过，不要在应用程序中 hardcode \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e ABI 吗？\u003c/p\u003e\n\n\u003cp\u003e不幸的是，android-x86 的开发者犯了这个错误，导致内核 API 变了之后，android-x86\n突然停止工作。\u003c/p\u003e\n\n\u003cp\u003e内核开发者只好恢复了老版 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e ABI，以避免那些 hardcode ABI 的 android 设备\n无法使用。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://git.kernel.org/cgit/linux/kernel/git/tip/tip.git/commit/?id=30bfa7b3488bfb1bb75c9f50a5fcac1832970c60\"\u003e这是\n\u003c/a\u003e\n内核的修复代码，可以从中找到导致这次问题的 android 代码的 commit 地址。\u003c/p\u003e\n\n\u003cp\u003e记住：永远不要自己写 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysenter\u003c/code\u003e 汇编代码。如果出于某些原因不得不自己实现，请使\n用和我们上面给出的例子类似的代码，至少要经过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e API。\u003c/p\u003e\n\n\u003ch1 id=\"9-结束语\"\u003e9 结束语\u003c/h1\u003e\n\n\u003cp\u003eLinux 内核的系统调用基础架构相当复杂。有多种方式可以发起系统调用，各有优缺点。\u003c/p\u003e\n\n\u003cp\u003e通常来说，自己写汇编代码来发起系统调用并不是一个好主意，因为内核的 ABI 可能会有\n不兼容更新。内核和 libc 实现通常（可能）会为每个系统自动选择最快的系统调用方式。\u003c/p\u003e\n\n\u003cp\u003e如果无法使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglibc\u003c/code\u003e 提供的 wrapper（或者没有 wrapper 可用），你至少应该使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esyscall\u003c/code\u003e\nwrapper，或者尝试 vDSO 提供的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__kernel_vsyscall\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e保持关注本博客，我们将来会针对单个系统调用及其实现进行研究。\u003c/p\u003e\n\n\u003ch1 id=\"10-相关文章\"\u003e10 相关文章\u003c/h1\u003e\n\n\u003cp\u003e如果对本文感兴趣，那么你可能对我们的以下文章也感兴趣：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/how-does-strace-work-zh/\"\u003e(译) strace 是如何工作的\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/how-does-ltrace-work-zh/\"\u003e(译) ltrace 是如何工作的\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/bcc-ebpf-tutorial-zh/\"\u003e\u003cspan\u003e« bcc/ebpf 安装及示例（2019）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/how-does-strace-work-zh/\"\u003e\u003cspan\u003e[译] strace 是如何工作的（2016） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-01-30T00:00:00Z",
  "Author": "Arthur Chiao"
}