{
  "Source": "arthurchiao.art",
  "Title": "Linux 网络栈接收数据（RX）：配置调优（2022）",
  "Link": "https://arthurchiao.art/blog/linux-net-stack-tuning-rx-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux 网络栈接收数据（RX）：配置调优（2022）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-07-02 | Last Update 2024-02-15\u003c/p\u003e\n  \n  \u003cp\u003e本文尝试从技术研发与工程实践（而非纯理论学习）角度，在原理与实现、监控告警、\n配置调优三方面介绍内核 5.10 网络栈。由于内容非常多，因此分为了几篇系列文章。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e原理与实现\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-net-stack-zh/\"\u003eLinux 网络栈原理、监控与调优：前言\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-irq-softirq-zh/\"\u003eLinux 中断（IRQ/softirq）基础：原理及内核实现\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-net-stack-implementation-rx-zh/\"\u003eLinux 网络栈接收数据（RX）：原理及内核实现\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e监控\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/monitoring-network-stack/\"\u003eMonitoring Linux Network Stack\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e调优\u003c/strong\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-net-stack-tuning-rx-zh/\"\u003eLinux 网络栈接收数据（RX）：配置调优\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-网络设备驱动初始化\" id=\"markdown-toc-1-网络设备驱动初始化\"\u003e1 网络设备驱动初始化\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-调整-rx-队列数量ethtool--l-l\" id=\"markdown-toc-11-调整-rx-队列数量ethtool--l-l\"\u003e1.1 调整 RX 队列数量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -l/-L\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-调整-rx-队列大小ethtool--g-g\" id=\"markdown-toc-12-调整-rx-队列大小ethtool--g-g\"\u003e1.2 调整 RX 队列大小（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -g/-G\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-调整-rx-队列权重ethtool--x-x\" id=\"markdown-toc-14-调整-rx-队列权重ethtool--x-x\"\u003e1.4 调整 RX 队列权重（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -x/-X\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-调整-rss-rx-哈希字段ethtool--n-n\" id=\"markdown-toc-15-调整-rss-rx-哈希字段ethtool--n-n\"\u003e1.5 调整 RSS RX 哈希字段（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -n/-N\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#16-flow-绑定到-cpuntuple-filteringethtool--k-k--u-u\" id=\"markdown-toc-16-flow-绑定到-cpuntuple-filteringethtool--k-k--u-u\"\u003e1.6 Flow 绑定到 CPU：ntuple filtering（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -k/-K, -u/-U\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-网卡收包\" id=\"markdown-toc-2-网卡收包\"\u003e2 网卡收包\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-dma-将包复制到-rx-队列\" id=\"markdown-toc-3-dma-将包复制到-rx-队列\"\u003e3 DMA 将包复制到 RX 队列\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-irq\" id=\"markdown-toc-4-irq\"\u003e4 IRQ\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-中断合并interrupt-coalescingethtool--c-c\" id=\"markdown-toc-41-中断合并interrupt-coalescingethtool--c-c\"\u003e4.1 中断合并（Interrupt coalescing，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -c/-C\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-调整硬中断亲和性irq-affinitiesprocirqidsmp_affinity\" id=\"markdown-toc-42-调整硬中断亲和性irq-affinitiesprocirqidsmp_affinity\"\u003e4.2 调整硬中断亲和性（IRQ affinities，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/irq/\u0026lt;id\u0026gt;/smp_affinity\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-softirq\" id=\"markdown-toc-5-softirq\"\u003e5 SoftIRQ\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-问题讨论\" id=\"markdown-toc-51-问题讨论\"\u003e5.1 问题讨论\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#关于-napi-pool-机制\" id=\"markdown-toc-关于-napi-pool-机制\"\u003e关于 NAPI pool 机制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#perf-跟踪-irqsoftirq-调用\" id=\"markdown-toc-perf-跟踪-irqsoftirq-调用\"\u003eperf 跟踪 IRQ/Softirq 调用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#procnetsoftnet_stat-各字段说明\" id=\"markdown-toc-procnetsoftnet_stat-各字段说明\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/net/softnet_stat\u003c/code\u003e 各字段说明\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-调整-softirq-收包预算sysctl-netdev_budgetnetdev_budget_usecs\" id=\"markdown-toc-52-调整-softirq-收包预算sysctl-netdev_budgetnetdev_budget_usecs\"\u003e5.2 调整 softirq 收包预算：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl netdev_budget/netdev_budget_usecs\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-softirq从-ring-buffer-收包送到协议栈\" id=\"markdown-toc-6-softirq从-ring-buffer-收包送到协议栈\"\u003e6 softirq：从 ring buffer 收包送到协议栈\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-修改-gro-配置ethtool--k-k\" id=\"markdown-toc-61-修改-gro-配置ethtool--k-k\"\u003e6.1 修改 GRO 配置（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -k/-K\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-sysctl-gro_normal_batch\" id=\"markdown-toc-62-sysctl-gro_normal_batch\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl gro_normal_batch\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-rps-调优\" id=\"markdown-toc-63-rps-调优\"\u003e6.3 RPS 调优\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-调优打开-rfs\" id=\"markdown-toc-64-调优打开-rfs\"\u003e6.4 调优：打开 RFS\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#65-调优-启用-arfs\" id=\"markdown-toc-65-调优-启用-arfs\"\u003e6.5 调优: 启用 aRFS\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-协议栈l2-处理\" id=\"markdown-toc-7-协议栈l2-处理\"\u003e7 协议栈：L2 处理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-调优-何时给包打时间戳sysctl-netcorenetdev_tstamp_prequeue\" id=\"markdown-toc-71-调优-何时给包打时间戳sysctl-netcorenetdev_tstamp_prequeue\"\u003e7.1 调优: 何时给包打时间戳（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.netdev_tstamp_prequeue\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-调优老驱动\" id=\"markdown-toc-72-调优老驱动\"\u003e7.2 调优（老驱动）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#netdev_max_backlog\" id=\"markdown-toc-netdev_max_backlog\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_max_backlog\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#napi-weight-of-the-backlog-poll-loop\" id=\"markdown-toc-napi-weight-of-the-backlog-poll-loop\"\u003eNAPI weight of the backlog poll loop\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#73-调优sysctl-netcoreflow_limit_table_len\" id=\"markdown-toc-73-调优sysctl-netcoreflow_limit_table_len\"\u003e7.3 调优：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.flow_limit_table_len\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-协议栈l3-处理ipv4\" id=\"markdown-toc-8-协议栈l3-处理ipv4\"\u003e8 协议栈：L3 处理（IPv4）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#81-调优-打开或关闭-ip-协议的-early-demux-选项\" id=\"markdown-toc-81-调优-打开或关闭-ip-协议的-early-demux-选项\"\u003e8.1 调优: 打开或关闭 IP 协议的 early demux 选项\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-协议栈l4-处理udp\" id=\"markdown-toc-9-协议栈l4-处理udp\"\u003e9 协议栈：L4 处理（UDP）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#91-调优-socket-receive-buffersysctl-netcorermem_defaultrmem_max\" id=\"markdown-toc-91-调优-socket-receive-buffersysctl-netcorermem_defaultrmem_max\"\u003e9.1 调优: socket receive buffer（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.rmem_default/rmem_max\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-全局调优一些影响网络性能的非网络配置\" id=\"markdown-toc-10-全局调优一些影响网络性能的非网络配置\"\u003e10 全局调优：一些影响网络性能的非网络配置\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#101-cpu-节能模式cstates导致收发包不及时\" id=\"markdown-toc-101-cpu-节能模式cstates导致收发包不及时\"\u003e10.1 CPU 节能模式（cstates）导致收发包不及时\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e网络栈非常复杂，没有一种放之四海而皆准的通用配置。如果网络性能和指标对你们团队和业务非常重要，\n那别无选择，只能投入大量的时间、精力和资源去深入理解系统的各个部分是如何工作的。\n理想情况下，应该监控\u003cstrong\u003e\u003cmark\u003e网络栈各个层级的丢包及其他健康状态\u003c/mark\u003e\u003c/strong\u003e，\n这样遇到问题时就能快速缩小范围，判断哪个组件或模块需要调优。\u003c/p\u003e\n\n\u003cp\u003e本文展示一些从下到上的配置调优示例，但注意这些配置并不作为任何特定配置或默认配置的建议。此外，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在任何配置变更之前，应该有一个能够对系统进行\u003ca href=\"/blog/monitoring-network-stack/\"\u003e\u003cmark\u003e监控\u003c/mark\u003e\u003c/a\u003e的框架，以确认调整是否带来预期的效果；\u003c/li\u003e\n  \u003cli\u003e对远程连接上的机器进行网络变更是相当危险的，机器很可能失联；\u003c/li\u003e\n  \u003cli\u003e不要在生产环境直接调整配置；尽量先在线下或新机器上验证效果，然后灰度到生产。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e本文章号与图中对应。 接下来就从最底层的网卡开始。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-net-stack/rx-overview.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Steps of Linux kernel receiving data process and the corresponding chapters in this post\u003c/p\u003e\n\n\u003ch1 id=\"1-网络设备驱动初始化\"\u003e1 网络设备驱动初始化\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eRX 队列的数量和大小可以通过 ethtool 进行配置，这两个参数会对收包或丢包产生显著影响。\u003c/li\u003e\n  \u003cli\u003e网卡通过对 packet 头（例如源地址、目的地址、端口等）做哈希来决定将 packet 放到\n  哪个 RX 队列。对于支持自定义哈希的网卡，可以通过自定义算法将特定\n  的 flow 发到特定的队列，甚至可以做到在硬件层面直接将某些包丢弃。\u003c/li\u003e\n  \u003cli\u003e一些网卡支持调整 RX 队列的权重，将流量按指定的比例发到指定的 queue。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"11-调整-rx-队列数量ethtool--l-l\"\u003e1.1 调整 RX 队列数量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -l/-L\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e如果网卡及其驱动支持 RSS/多队列，可以调整 RX queue（也叫 RX channel）的数量。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e eth0\nChannel parameters \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0:\nPre-set maximums:\nRX:             0\nTX:             0\nOther:          0\nCombined:       40\nCurrent hardware settings:\nRX:             0\nTX:             0\nOther:          0\nCombined:       40\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到硬件最多支持 40 个，当前也用满了 40 个。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：\u003cstrong\u003e\u003cmark\u003e不是所有网卡驱动都支持这个操作\u003c/mark\u003e\u003c/strong\u003e。不支持的网卡会报如下错误：\u003c/p\u003e\n\n  \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e eth0\nChannel parameters \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0:\nCannot get device channel parameters\n: Operation not supported\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e这意味着驱动没有实现 ethtool 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eget_channels()\u003c/code\u003e 方法。可能原因：该网卡不支持\n调整 RX queue 数量，不支持 RSS/multiqueue 等。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eethtool -L\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 可以修改 RX queue 数量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool\u003c/code\u003e 参数\n有个惯例，小写一般都是查询某个配置，对应的大写表示修改这个配置）。不过这里需要注意，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e某些厂商的网卡中，RX 队列和 TX 队列是可以独立调整的，例如修改 RX queue 数量：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-L\u003c/span\u003e eth0 rx 8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e另一些厂商网卡中，二者是一一绑定的，称为 \u003cstrong\u003e\u003cmark\u003ecombined queue\u003c/mark\u003e\u003c/strong\u003e，这种模式下，\n调整 RX 队列的数量也会同时调整 TX queue 的数量，例如\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-L\u003c/span\u003e eth0 combined 8 \u003cspan class=\"c\"\u003e# 将 RX 和 TX queue 数量都设为了 8\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e注意：\u003cstrong\u003e\u003cmark\u003e对于大部分驱动，修改以上配置会使网卡先 down 再 up，因此会造成丢包！\u003c/mark\u003e\u003c/strong\u003e\n请谨慎操作。\u003c/p\u003e\n\n\u003ch2 id=\"12-调整-rx-队列大小ethtool--g-g\"\u003e1.2 调整 RX 队列大小（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -g/-G\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e也就是调整每个 RX 队列中 descriptor 的数量，一个 descriptor 对应一个包。\n这个能不能调整也要看具体的网卡和驱动。增大 ring buffer 可以在 PPS（packets per\nsecond）很大时缓解丢包问题。\u003c/p\u003e\n\n\u003cp\u003e查看 queue 的大小：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-g\u003c/span\u003e eth0\nRing parameters \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0:\nPre-set maximums:\nRX:   4096\nRX Mini:  0\nRX Jumbo: 0\nTX:   4096\nCurrent hardware settings:\nRX:   512\nRX Mini:  0\nRX Jumbo: 0\nTX:   512\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上输出显示网卡最多支持 4096 个 RX/TX descriptor，但是现在只用到了 512 个。\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eethtool -G\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 修改 queue 大小：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-G\u003c/span\u003e eth0 rx 4096\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意：对于大部分驱动，\u003cstrong\u003e\u003cmark\u003e修改以上配置会使网卡先 down 再 up，因此会造成丢包\u003c/mark\u003e\u003c/strong\u003e。请谨慎操作。\u003c/p\u003e\n\n\u003ch2 id=\"14-调整-rx-队列权重ethtool--x-x\"\u003e1.4 调整 RX 队列权重（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -x/-X\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e一些网卡支持给不同的 queue 设置不同的权重（weight），权重越大，\n每次网卡 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epoll()\u003c/code\u003e 能处理的包越多。如果网卡支持以下功能，就可以设置权重：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e支持 flow indirection；\u003c/li\u003e\n  \u003cli\u003e驱动实现了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eget_rxfh_indir_size()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eget_rxfh_indir()\u003c/code\u003e 方法；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e检查 flow indirection 设置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-x\u003c/span\u003e eth0\nRX flow \u003cspan class=\"nb\"\u003ehash \u003c/span\u003eindirection table \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0 with 40 RX ring\u003cspan class=\"o\"\u003e(\u003c/span\u003es\u003cspan class=\"o\"\u003e)\u003c/span\u003e:\n    0:      0     1     2     3     4     5     6     7\n    8:      8     9    10    11    12    13    14    15\n   16:     16    17    18    19    20    21    22    23\n   24:     24    25    26    27    28    29    30    31\n   32:     32    33    34    35    36    37    38    39\n   40:      0     1     2     3     4     5     6     7\n   48:      8     9    10    11    12    13    14    15\n   ...\nRSS \u003cspan class=\"nb\"\u003ehash \u003c/span\u003ekey:\n9a:b0:e3:53:ed:d4:14:7a:a0:...:e5:57:e8:6a:ec\nRSS \u003cspan class=\"nb\"\u003ehash \u003c/span\u003e\u003cspan class=\"k\"\u003efunction\u003c/span\u003e:\n    toeplitz: off\n    xor: on\n    crc32: off\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e第一列是改行的第一个哈希值，冒号后面的每个哈希值对应的 RX queue。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一行的哈希值是 0~7，分别对应 RX queue 0~7；\u003c/li\u003e\n  \u003cli\u003e第六行的哈希值是 40~47，分别对应的也是 RX queue 0~7。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# 在前两个 RX queue 之间均匀的分发接收到的包\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-X\u003c/span\u003e eth0 equal 2\n\n\u003cspan class=\"c\"\u003e# 设置自定义权重：给 rx queue 0 和 1 不同的权重：6 和 2\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-X\u003c/span\u003e eth0 weight 6 2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意 queue 一般是和 CPU 绑定的，因此这也意味着相应的 CPU 也会花更多的时间片在收包上。\n一些网卡还支持修改计算 hash 时使用哪些字段。\u003c/p\u003e\n\n\u003ch2 id=\"15-调整-rss-rx-哈希字段ethtool--n-n\"\u003e1.5 调整 RSS RX 哈希字段（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -n/-N\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e可以用 ethtool 调整 RSS 计算哈希时所使用的字段。\u003c/p\u003e\n\n\u003cp\u003e例子：查看 UDP RX flow 哈希所使用的字段：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e eth0 rx-flow-hash udp4\nUDP over IPV4 flows use these fields \u003cspan class=\"k\"\u003efor \u003c/span\u003ecomputing Hash flow key:\nIP SA\nIP DA\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到只用到了源 IP（SA：Source Address）和目的 IP。\u003c/p\u003e\n\n\u003cp\u003e我们修改一下，加入源端口和目的端口：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-N\u003c/span\u003e eth0 rx-flow-hash udp4 sdfn\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esdfn\u003c/code\u003e 的具体含义解释起来有点麻烦，请查看 ethtool 的帮助（man page）。\u003c/p\u003e\n\n\u003cp\u003e调整 hash 所用字段是有用的，而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003entuple\u003c/code\u003e 过滤对于更加细粒度的 flow control 更加有用。\u003c/p\u003e\n\n\u003ch2 id=\"16-flow-绑定到-cpuntuple-filteringethtool--k-k--u-u\"\u003e1.6 Flow 绑定到 CPU：ntuple filtering（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -k/-K, -u/-U\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e一些网卡支持 “ntuple filtering” 特性。该特性允许用户（通过 ethtool ）指定一些参数来\n在硬件上过滤收到的包，然后将其直接放到特定的 RX queue。例如，用户可以指定到特定目\n端口的 TCP 包放到 RX queue 1。\u003c/p\u003e\n\n\u003cp\u003eIntel 的网卡上这个特性叫 Intel Ethernet Flow Director，其他厂商可能也有他们的名字\n，这些都是出于市场宣传原因，底层原理是类似的。\u003c/p\u003e\n\n\u003cp\u003entuple filtering 其实是 Accelerated Receive Flow Steering (aRFS) 功能的核心部分之一，\n这个功能在原理篇中已经介绍过了。aRFS 使得 ntuple filtering 的使用更加方便。\u003c/p\u003e\n\n\u003cp\u003e适用场景：最大化数据局部性（data locality），提高 CPU 处理网络数据时的\n缓存命中率。例如，考虑运行在 80 口的 web 服务器：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ewebserver 进程运行在 80 口，并绑定到 CPU 2\u003c/li\u003e\n  \u003cli\u003e和某个 RX queue 关联的硬中断绑定到 CPU 2\u003c/li\u003e\n  \u003cli\u003e目的端口是 80 的 TCP 流量通过 ntuple filtering 绑定到 CPU 2\u003c/li\u003e\n  \u003cli\u003e接下来所有到 80 口的流量，从数据包进来到数据到达用户程序的整个过程，都由 CPU 2 处理\u003c/li\u003e\n  \u003cli\u003e监控系统的缓存命中率、网络栈的延迟等信息，以验证以上配置是否生效\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e检查 ntuple filtering 特性是否打开：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-k\u003c/span\u003e eth0\nOffload parameters \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0:\n...\nntuple-filters: off\nreceive-hashing: on\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，上面的 ntuple 是关闭的。\u003c/p\u003e\n\n\u003cp\u003e打开：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-K\u003c/span\u003e eth0 ntuple on\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e打开 ntuple filtering 功能，并确认打开之后，可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -u\u003c/code\u003e 查看当前的 ntuple\nrules：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-u\u003c/span\u003e eth0\n40 RX rings available\nTotal 0 rules\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到当前没有 rules。\u003c/p\u003e\n\n\u003cp\u003e我们来加一条：目的端口是 80 的放到 RX queue 2：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-U\u003c/span\u003e eth0 flow-type tcp4 dst-port 80 action 2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e也可以用 ntuple filtering \u003cstrong\u003e\u003cmark\u003e在硬件层面直接 drop 某些 flow 的包\u003c/mark\u003e\u003c/strong\u003e。\n当特定 IP 过来的流量太大时，这种功能可能会派上用场。更多关于 ntuple 的信息，参考 ethtool man page。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -S \u0026lt;DEVICE\u0026gt;\u003c/code\u003e 的输出统计里，Intel 的网卡有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efdir_match\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efdir_miss\u003c/code\u003e 两项，\n是和 ntuple filtering 相关的。关于具体、详细的统计计数，需要查看相应网卡的设备驱\n动和 data sheet。\u003c/p\u003e\n\n\u003ch1 id=\"2-网卡收包\"\u003e2 网卡收包\u003c/h1\u003e\n\n\u003ch1 id=\"3-dma-将包复制到-rx-队列\"\u003e3 DMA 将包复制到 RX 队列\u003c/h1\u003e\n\n\u003ch1 id=\"4-irq\"\u003e4 IRQ\u003c/h1\u003e\n\n\u003ch2 id=\"41-中断合并interrupt-coalescingethtool--c-c\"\u003e4.1 中断合并（Interrupt coalescing，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -c/-C\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e中断合并会将多个中断事件放到一起，累积到一定阈值后才向 CPU 发起中断请求。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e优点：防止\u003cstrong\u003e中断风暴\u003c/strong\u003e，提升吞吐，降低 CPU 使用量\u003c/li\u003e\n  \u003cli\u003e缺点：延迟变大\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e查看：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e eth0\nCoalesce parameters \u003cspan class=\"k\"\u003efor \u003c/span\u003eeth0:\nAdaptive RX: on  TX: on        \u003cspan class=\"c\"\u003e# 自适应中断合并\u003c/span\u003e\nstats-block-usecs: 0\nsample-interval: 0\npkt-rate-low: 0\npkt-rate-high: 0\n\nrx-usecs: 8\nrx-frames: 128\nrx-usecs-irq: 0\nrx-frames-irq: 0\n\ntx-usecs: 8\ntx-frames: 128\ntx-usecs-irq: 0\ntx-frames-irq: 0\n\nrx-usecs-low: 0\nrx-frame-low: 0\ntx-usecs-low: 0\ntx-frame-low: 0\n\nrx-usecs-high: 0\nrx-frame-high: 0\ntx-usecs-high: 0\ntx-frame-high: 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e不是所有网卡都支持这些配置。根据 ethtool 文档：\u003cstrong\u003e“驱动没有实现的接口将会被静默忽略”\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e某些驱动支持“自适应 RX/TX 硬中断合并”，效果是带宽比较低时降低延迟，带宽比较高时\n提升吞吐。这个特性一般是在硬件实现的。\u003c/p\u003e\n\n\u003cp\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -C\u003c/code\u003e 打开自适应 RX IRQ 合并：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-C\u003c/span\u003e eth0 adaptive-rx on\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e还可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -C\u003c/code\u003e 更改其他配置。常用的包括：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erx-usecs\u003c/code\u003e: How many usecs to delay an RX interrupt after a packet arrives.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erx-frames\u003c/code\u003e: Maximum number of data frames to receive before an RX interrupt.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erx-usecs-irq\u003c/code\u003e: How many usecs to delay an RX interrupt while an interrupt is being serviced by the host.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erx-frames-irq\u003c/code\u003e: Maximum number of data frames to receive before an RX interrupt is generated while the system is servicing an interrupt.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e每个配置项的含义见\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/uapi/linux/ethtool.h\"\u003einclude/uapi/linux/ethtool.h\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e注意：虽然硬中断合并看起来是个不错的优化项，但需要网络栈的其他一些\n部分做针对性调整。只合并硬中断很可能并不会带来多少收益。\u003c/p\u003e\n\n\u003ch2 id=\"42-调整硬中断亲和性irq-affinitiesprocirqidsmp_affinity\"\u003e4.2 调整硬中断亲和性（IRQ affinities，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/irq/\u0026lt;id\u0026gt;/smp_affinity\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e这种方式能手动配置哪个 CPU 负责处理哪个 IRQ。\n但在配置之前，需要先确保关闭 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eirqbalance\u003c/code\u003e 进程（或者设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--banirq\u003c/code\u003e 指定不要对那些 CPU 做 balance）\n否则它会定期自动平衡 IRQ 和 CPU 映射关系，覆盖我们的手动配置。\u003c/p\u003e\n\n\u003cp\u003e然后，通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat /proc/interrupts\u003c/code\u003e 查看网卡的每个 RX 队列对应的 IRQ 编号。\u003c/p\u003e\n\n\u003cp\u003e最后，通过设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/irq/\u0026lt;IRQ_NUMBER\u0026gt;/smp_affinity\u003c/code\u003e 来指定哪个 CPU 来处理这个 IRQ。\n注意这里的格式是 16 进制的 bitmask。\u003c/p\u003e\n\n\u003cp\u003e例子：指定 CPU 0 来处理 IRQ 8：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003ebash \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;echo 1 \u0026gt; /proc/irq/8/smp_affinity\u0026#39;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"5-softirq\"\u003e5 SoftIRQ\u003c/h1\u003e\n\n\u003ch2 id=\"51-问题讨论\"\u003e5.1 问题讨论\u003c/h2\u003e\n\n\u003ch3 id=\"关于-napi-pool-机制\"\u003e关于 NAPI pool 机制\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这是 Linux 内核中的一种通用抽象，任何等待\u003cstrong\u003e不可抢占状态\u003c/strong\u003e发生（wait for a\npreemptible state to occur）的模块，都可以使用这种注册回调函数的方式。\u003c/li\u003e\n  \u003cli\u003e驱动注册的这个 poll 是一个\u003cstrong\u003e主动式 poll\u003c/strong\u003e（active poll），一旦执行就会持续处理\n，直到没有数据可供处理，然后进入 idle 状态。\u003c/li\u003e\n  \u003cli\u003e在这里，执行 poll 方法的是运行在某个或者所有 CPU 上的\u003cstrong\u003e内核线程\u003c/strong\u003e（kernel thread）。\n虽然这个线程没有数据可处理时会进入 idle 状态，但如前面讨论的，在当前大部分分布\n式系统中，这个线程大部分时间内都是在运行的，不断从驱动的 DMA 区域内接收数据包。\u003c/li\u003e\n  \u003cli\u003epoll 会告诉网卡不要再触发硬件中断，使用\u003cstrong\u003e软件中断\u003c/strong\u003e（softirq）就行了。此后这些\n内核线程会轮询网卡的 DMA 区域来收包。之所以会有这种机制，是因为硬件中断代价太\n高了，因为它们比系统上几乎所有东西的优先级都要高。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e我们接下来还将多次看到这个广义的 NAPI 抽象，因为它不仅仅处理驱动，还能处理许多\n其他场景。内核用 NAPI 抽象来做驱动读取（driver reads）、epoll 等等。\u003c/p\u003e\n\n\u003cp\u003eNAPI 驱动的 poll 机制将数据从 DMA 区域读取出来，对数据做一些准备工作，然后交给比\n它更上一层的内核协议栈。\u003c/p\u003e\n\n\u003cp\u003e软中断的信息可以从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/softirqs\u003c/code\u003e 读取：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/softirqs\n                    CPU0       CPU1       CPU2       CPU3\n          HI:          0          0          0          0\n       TIMER: 2831512516 1337085411 1103326083 1423923272\n      NET_TX:   15774435     779806     733217     749512\n      NET_RX: 1671622615 1257853535 2088429526 2674732223\n       BLOCK: 1800253852    1466177    1791366     634534\nBLOCK_IOPOLL:          0          0          0          0\n     TASKLET:         25          0          0          0\n       SCHED: 2642378225 1711756029  629040543  682215771\n     HRTIMER:    2547911    2046898    1558136    1521176\n         RCU: 2056528783 4231862865 3545088730  844379888\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e监控这些数据可以得到软中断的执行频率信息。\u003c/p\u003e\n\n\u003cp\u003e例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNET_RX\u003c/code\u003e 一行显示的是软中断在 CPU 间的分布。如果分布非常不均匀，那某一列的\n值就会远大于其他列，这预示着下面要介绍的 Receive Packet Steering / Receive Flow\nSteering 可能会派上用场。但也要注意：不要太相信这个数值，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNET_RX\u003c/code\u003e 太高并不一定都\n是网卡触发的，其他地方也有可能触发。\u003c/p\u003e\n\n\u003cp\u003e调整其他网络配置时，可以留意下这个指标的变动。\u003c/p\u003e\n\n\u003ch3 id=\"perf-跟踪-irqsoftirq-调用\"\u003eperf 跟踪 IRQ/Softirq 调用\u003c/h3\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eperf record \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e irq:irq_handler_entry,irq:irq_handler_exit \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e irq:softirq_entry \u003cspan class=\"nt\"\u003e--filter\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;vec == 3\u0026#34;\u003c/span\u003e \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e irq:softirq_exit \u003cspan class=\"nt\"\u003e--filter\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;vec == 3\u0026#34;\u003c/span\u003e  \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e napi:napi_poll \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e-C\u003c/span\u003e 1 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    \u003cspan class=\"nt\"\u003e--\u003c/span\u003e \u003cspan class=\"nb\"\u003esleep \u003c/span\u003e2\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eperf script\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eperf \u003cspan class=\"nb\"\u003estat\u003c/span\u003e \u003cspan class=\"nt\"\u003e-C\u003c/span\u003e 1 \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e irq:softirq_entry,irq:softirq_exit,irq:softirq_raise \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e \u003cspan class=\"nb\"\u003esleep \u003c/span\u003e10\n\n Performance counter stats \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;system wide\u0026#39;\u003c/span\u003e:\n\n             1,161      irq:softirq_entry\n             1,161      irq:softirq_exit\n             1,215      irq:softirq_raise\n\n      10.001100401 seconds \u003cspan class=\"nb\"\u003etime \u003c/span\u003eelapsed\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"procnetsoftnet_stat-各字段说明\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/net/softnet_stat\u003c/code\u003e 各字段说明\u003c/h3\u003e\n\n\u003cp\u003e前面看到，如果 budget 或者 time limit 到了而仍有包需要处理，那 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_rx_action\u003c/code\u003e 在退出\n循环之前会更新统计信息。这个信息存储在该 CPU 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct softnet_data\u003c/code\u003e 变量中。\u003c/p\u003e\n\n\u003cp\u003e这些统计信息打到了\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/net/softnet_stat\u003c/code\u003e，但不幸的是，关于这个的文档很少。每一\n列代表什么并没有标题，而且列的内容会随着内核版本可能发生变化，所以应该以内核源码为准，\n下面是内核 5.10，可以看到每列分别对应什么：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/net/core/net-procfs.c#L172\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003esoftnet_seq_show\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eseq_file\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eseq_printf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n           \u003cspan class=\"s\"\u003e\u0026#34;%08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x %08x\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n           \u003cspan class=\"n\"\u003esd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eprocessed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edropped\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etime_squeeze\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n           \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* was fastroute */\u003c/span\u003e\n           \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e    \u003cspan class=\"cm\"\u003e/* was cpu_collision */\u003c/span\u003e\n           \u003cspan class=\"n\"\u003esd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ereceived_rps\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflow_limit_count\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n           \u003cspan class=\"n\"\u003esoftnet_backlog_len\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esd\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eseq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/net/softnet_stat\n6dcad223 00000000 00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n6f0e1565 00000000 00000002 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n660774ec 00000000 00000003 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n61c99331 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n6794b1b3 00000000 00000005 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n6488cb92 00000000 00000001 00000000 00000000 00000000 00000000 00000000 00000000 00000000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e每一行代表一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct softnet_data\u003c/code\u003e 变量。因为每个 CPU 只有一个该变量，所以每行其实代表一个 CPU；\n数字都是 16 进制表示。字段说明：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esd-\u0026gt;processed\u003c/code\u003e：处理的网络帧数量。\u003cstrong\u003e\u003cmark\u003e如果用了 ethernet bonding，那这个值会大于总帧数\u003c/mark\u003e\u003c/strong\u003e，\n因为 bond 驱动有时会触发帧的重处理（re-processed）；\u003c/li\u003e\n  \u003cli\u003e第二列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esd-\u0026gt;dropped\u003c/code\u003e：因为处理不过来而 drop 的网络帧数量；具体见原理篇；\u003c/li\u003e\n  \u003cli\u003e第三列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esd-\u0026gt;time_squeeze\u003c/code\u003e：由于 budget 或 time limit 用完而退出 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_rx_action()\u003c/code\u003e 循环的次数；原理篇中有更多分析；\u003c/li\u003e\n  \u003cli\u003e接下来的 5 列全是 0；\u003c/li\u003e\n  \u003cli\u003e第九列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esd-\u0026gt;cpu_collision\u003c/code\u003e：为发送包而获取锁时冲突的次数；\u003c/li\u003e\n  \u003cli\u003e第十列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esd-\u0026gt;received_rps\u003c/code\u003e：当前 CPU 被其他 CPU 唤醒去收包的次数；\u003c/li\u003e\n  \u003cli\u003e最后一列，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflow_limit_count\u003c/code\u003e：达到 flow limit 的次数；这是 RPS 特性。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"52-调整-softirq-收包预算sysctl-netdev_budgetnetdev_budget_usecs\"\u003e5.2 调整 softirq 收包预算：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl netdev_budget/netdev_budget_usecs\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e权威解释见 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/Documentation/admin-guide/sysctl/net.rst#netdev_budget\"\u003e内核文档\u003c/a\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003enetdev_budget\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：一个 \u003cstrong\u003e\u003cmark\u003eCPU 单次轮询所允许的最大收包数量\u003c/mark\u003e\u003c/strong\u003e。\n单次 poll 收包时，所有注册到这个 CPU 的 NAPI 变量收包数量之和不能大于这个阈值。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003enetdev_budget_usecs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：每次 NAPI poll cycle 的最长允许时间，单位是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eus\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e触发二者中任何一个条件后，都会导致一次轮询结束。\u003c/p\u003e\n\n\u003cp\u003e查看当前配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003enetdev_budget\nnet.core.netdev_budget \u003cspan class=\"o\"\u003e=\u003c/span\u003e 300         \u003cspan class=\"c\"\u003e# kernel 5.10 默认值\u003c/span\u003e\nnet.core.netdev_budget_usecs \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2000  \u003cspan class=\"c\"\u003e# kernel 5.10 默认值\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e修改配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.netdev_budget\u003cspan class=\"o\"\u003e=\u003c/span\u003e3000\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.netdev_budget_usecs \u003cspan class=\"o\"\u003e=\u003c/span\u003e 10000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e要保证重启不丢失，需要将这个配置写到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/sysctl.conf\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"6-softirq从-ring-buffer-收包送到协议栈\"\u003e6 softirq：从 ring buffer 收包送到协议栈\u003c/h1\u003e\n\n\u003ch2 id=\"61-修改-gro-配置ethtool--k-k\"\u003e6.1 修改 GRO 配置（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eethtool -k/-K\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e查看 GRO 配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-k\u003c/span\u003e eth0 | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003egeneric-receive-offload\ngeneric-receive-offload: on\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e修改 GRO 配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003eethtool \u003cspan class=\"nt\"\u003e-K\u003c/span\u003e eth0 gro on\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意：对于大部分驱动，修改 GRO 配置会涉及先 down 再 up 这个网卡，因此这个网卡上的连接都会中断。\u003c/p\u003e\n\n\u003ch2 id=\"62-sysctl-gro_normal_batch\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl gro_normal_batch\u003c/code\u003e\u003c/h2\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esysctl net.core.gro_normal_batch\nnet.core.gro_normal_batch \u003cspan class=\"o\"\u003e=\u003c/span\u003e 8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"63-rps-调优\"\u003e6.3 RPS 调优\u003c/h2\u003e\n\n\u003cp\u003e使用 RPS 需要在内核做配置，而且需要一个掩码（bitmask）指定哪些 CPU 可以处理那些 RX 队列。相关信息见\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/Documentation/networking/scaling.rst\"\u003e内核文档\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003ebitmask 配置位于：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/class/net/DEVICE_NAME/queues/QUEUE/rps_cpus\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e例如，对于 eth0 的 queue 0，需要更改\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/class/net/eth0/queues/rx-0/rps_cpus\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e注意：打开 RPS 之后，原来不需要处理软中断（softirq）的 CPU 这时也会参与处理。因此相\n应 CPU 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNET_RX\u003c/code\u003e 数量，以及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esi\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esitime\u003c/code\u003e 占比都会相应增加。可以对比启用 RPS 前后的\n数据，以此来确定配置是否生效以及是否符合预期（哪个 CPU 处理哪个网卡的哪个中断）。\u003c/p\u003e\n\n\u003ch2 id=\"64-调优打开-rfs\"\u003e6.4 调优：打开 RFS\u003c/h2\u003e\n\n\u003cp\u003eRPS 记录一个全局的 hash table，包含所有 flow 的信息，这个 hash table 的大小是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet.core.rps_sock_flow_entries\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003erps_\nnet.core.rps_sock_flow_entries \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0 \u003cspan class=\"c\"\u003e# kernel 5.10 默认值\u003c/span\u003e\n\n\u003cspan class=\"c\"\u003e# 如果要修改\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.rps_sock_flow_entries\u003cspan class=\"o\"\u003e=\u003c/span\u003e32768\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其次，可以设置每个 RX queue 的 flow 数量，对应着 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erps_flow_cnt\u003c/code\u003e：\u003c/p\u003e\n\n\u003cp\u003e例如，eth0 的 RX queue0 的 flow 数量调整到 2048：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ sudo bash -c \u0026#39;echo 2048 \u0026gt; /sys/class/net/eth0/queues/rx-0/rps_flow_cnt\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"65-调优-启用-arfs\"\u003e6.5 调优: 启用 aRFS\u003c/h2\u003e\n\n\u003cp\u003e假如网卡支持 aRFS，可以开启它并做如下配置：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e打开并配置 RPS\u003c/li\u003e\n  \u003cli\u003e打开并配置 RFS\u003c/li\u003e\n  \u003cli\u003e内核中编译期间指定了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_RFS_ACCEL\u003c/code\u003e 选项\u003c/li\u003e\n  \u003cli\u003e打开网卡的 ntuple 支持。可以用 ethtool 查看当前的 ntuple 设置\u003c/li\u003e\n  \u003cli\u003e配置 IRQ（硬中断）中每个 RX 和 CPU 的对应关系\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上配置完成后，aRFS 就会自动将 RX queue 数据移动到指定 CPU 的内存，每个 flow 的包都会\n到达同一个 CPU，不需要再通过 ntuple 手动指定每个 flow 的配置了。\u003c/p\u003e\n\n\u003ch1 id=\"7-协议栈l2-处理\"\u003e7 协议栈：L2 处理\u003c/h1\u003e\n\n\u003ch2 id=\"71-调优-何时给包打时间戳sysctl-netcorenetdev_tstamp_prequeue\"\u003e7.1 调优: 何时给包打时间戳（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.netdev_tstamp_prequeue\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e决定包被收到后，何时给它打时间戳。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esysctl net.core.netdev_tstamp_prequeue\n1 \u003cspan class=\"c\"\u003e# 内核 5.10 默认值\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"72-调优老驱动\"\u003e7.2 调优（老驱动）\u003c/h2\u003e\n\n\u003ch3 id=\"netdev_max_backlog\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_max_backlog\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e如果启用了 RPS，或者你的网卡驱动调用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetif_rx()\u003c/code\u003e（大部分网卡都不会再调用这个函数了），\n那增加 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enetdev_max_backlog\u003c/code\u003e 可以改善在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eenqueue_to_backlog\u003c/code\u003e 里的丢包：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.netdev_max_backlog\u003cspan class=\"o\"\u003e=\u003c/span\u003e3000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认值是 1000。\u003c/p\u003e\n\n\u003ch3 id=\"napi-weight-of-the-backlog-poll-loop\"\u003eNAPI weight of the backlog poll loop\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet.core.dev_weight\u003c/code\u003e 决定了 backlog poll loop 可以消耗的整体 budget（参考前面更改\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet.core.netdev_budget\u003c/code\u003e 的章节）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.dev_weight\u003cspan class=\"o\"\u003e=\u003c/span\u003e600\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认值是 64。\u003c/p\u003e\n\n\u003cp\u003e记住，backlog 处理逻辑和设备驱动的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epoll\u003c/code\u003e 函数类似，都是在软中断（softirq）的上下文\n中执行，因此受整体 budget 和处理时间的限制。\u003c/p\u003e\n\n\u003ch2 id=\"73-调优sysctl-netcoreflow_limit_table_len\"\u003e7.3 调优：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.flow_limit_table_len\u003c/code\u003e\u003c/h2\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.flow_limit_table_len\u003cspan class=\"o\"\u003e=\u003c/span\u003e8192\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认值是 4096。\u003c/p\u003e\n\n\u003cp\u003e这只会影响新分配的 flow hash table。所以，如果想增加 table size 的话，应该在打开\nflow limit 功能之前设置这个值。\u003c/p\u003e\n\n\u003cp\u003e打开 flow limit 功能的方式是，在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/sys/net/core/flow_limit_cpu_bitmap\u003c/code\u003e 中指定一\n个 bitmask，和通过 bitmask 打开 RPS 的操作类似。\u003c/p\u003e\n\n\u003ch1 id=\"8-协议栈l3-处理ipv4\"\u003e8 协议栈：L3 处理（IPv4）\u003c/h1\u003e\n\n\u003ch2 id=\"81-调优-打开或关闭-ip-协议的-early-demux-选项\"\u003e8.1 调优: 打开或关闭 IP 协议的 early demux 选项\u003c/h2\u003e\n\n\u003cp\u003e查看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eearly_demux\u003c/code\u003e 配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003esysctl net.ipv4.ip_early_demux\n1 \u003cspan class=\"c\"\u003e# 内核 5.10 默认值\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认是 1，即该功能默认是打开的。\u003c/p\u003e\n\n\u003cp\u003e添加这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl\u003c/code\u003e 开关的原因是，一些用户报告说，在某些场景下 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eearly_demux\u003c/code\u003e 优化会导\n致 ~5% 左右的吞吐量下降。\u003c/p\u003e\n\n\u003ch1 id=\"9-协议栈l4-处理udp\"\u003e9 协议栈：L4 处理（UDP）\u003c/h1\u003e\n\n\u003ch2 id=\"91-调优-socket-receive-buffersysctl-netcorermem_defaultrmem_max\"\u003e9.1 调优: socket receive buffer（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl net.core.rmem_default/rmem_max\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e判断 socket 接收队列是否满了是和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk-\u0026gt;sk_rcvbuf\u003c/code\u003e 做比较。\n这个值可以通过 sysctl 配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-a\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ermem                \u003cspan class=\"c\"\u003e# kernel 5.10 defaults\u003c/span\u003e\nnet.core.rmem_default \u003cspan class=\"o\"\u003e=\u003c/span\u003e 212992                   \u003cspan class=\"c\"\u003e# ~200KB\u003c/span\u003e\nnet.core.rmem_max \u003cspan class=\"o\"\u003e=\u003c/span\u003e 212992                       \u003cspan class=\"c\"\u003e# ~200KB\u003c/span\u003e\nnet.ipv4.tcp_rmem \u003cspan class=\"o\"\u003e=\u003c/span\u003e 4096        131072  6291456\nnet.ipv4.udp_rmem_min \u003cspan class=\"o\"\u003e=\u003c/span\u003e 4096\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e默认的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e200KB\u003c/code\u003e 可能太小了，例如 QUIC 可能需要 \u003ca href=\"https://github.com/lucas-clemente/quic-go/wiki/UDP-Receive-Buffer-Size\"\u003eMB 级别的配置\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e有两种修改方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e全局：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esysctl\u003c/code\u003e 或 echo sysfs 方式\u003c/li\u003e\n  \u003cli\u003e应用程序级别：在应用程序里通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt\u003c/code\u003e 带上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_RCVBUF\u003c/code\u003e flag 来修改这个值 (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk-\u0026gt;sk_rcvbuf\u003c/code\u003e)，能设置的最大值不超过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet.core.rmem_max\u003c/code\u003e。\n  如果有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCAP_NET_ADMIN\u003c/code\u003e 权限，也可以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt\u003c/code\u003e 带上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_RCVBUFFORCE\u003c/code\u003e 来覆盖 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet.core.rmem_max\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e实际中比较灵活的方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ermem_default\u003c/code\u003e 不动，这样 UDP 应用默认将仍然使用系统预设值；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ermem_max\u003c/code\u003e 调大（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.5MB\u003c/code\u003e），有需要的应用可以自己通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt()\u003c/code\u003e 来调大自己的 buffer。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"10-全局调优一些影响网络性能的非网络配置\"\u003e10 全局调优：一些影响网络性能的非网络配置\u003c/h1\u003e\n\n\u003ch2 id=\"101-cpu-节能模式cstates导致收发包不及时\"\u003e10.1 CPU 节能模式（cstates）导致收发包不及时\u003c/h2\u003e\n\n\u003cp\u003e业务现象：已经是独占 CPU（cpuset）类型的 pod，访问别人有偶发超时。\u003c/p\u003e\n\n\u003cp\u003e排查过程：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e查看容器和宿主机 CPU 利用率、load 之类的，都不算高，但 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etime_squeeze\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 计数一直断断续续有增加，说明收发包的 softirq 时间片不够；\u003c/li\u003e\n  \u003cli\u003e综合几个 case 看，发现出问题的都是 AMD 机型，怀疑跟 CPU 有关系；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elscpu\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 发现频率、缓存等等跟 Intel CPU 确实差异比较大；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e针对 AMD 机型配置看板，发现这些 node CPU 频率一直在变，\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-net-stack/amd-nodes-cpuhz.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n    \u003cp align=\"center\"\u003eFig. CPU HZ of the AMD nodes\u003c/p\u003e\n\n    \u003cp\u003e运行 HZ 在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat /proc/cpuinfo\u003c/code\u003e 里面可以拿到，是 per-cpu 的。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e根据以上信息，判断这些 AMD 机器的 CPU 处在节能模式，根据负载高低自动调整频率。\u003c/p\u003e\n\n\u003cp\u003e解决方式：修改系统启动项，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/etc/default/grub\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 添加如下内容：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eAMD_pstat=disable idle=poll nohz=off iommu=pt\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e说明：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003enohz=off\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;nohz=off\u0026#34; == \u0026#34;enable hz\u0026#34;\u003c/code\u003e，\n  也就是保留\u003cstrong\u003e\u003cmark\u003e系统每秒 HZ 次\u003c/mark\u003e\u003c/strong\u003e（默认 1000）的 \u003cstrong\u003e\u003cmark\u003etick 定时时钟中断，定期唤醒 CPU\u003c/mark\u003e\u003c/strong\u003e，\n  防止 CPU 在 IDLE 时进入较深的睡眠状态；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eidle=poll\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\n  使 CPU \u003cstrong\u003e\u003cmark\u003e永远工作在 c0 模式（最高性能）\u003c/mark\u003e\u003c/strong\u003e。\n  本质上就是让 cpu 在 idle 时去执行一个轻量级空转函数，避免进入 c1/c2 等性能较低的工作模式；\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e注意：设置成 c0 可能有副作用\u003c/mark\u003e\u003c/strong\u003e，没有很特殊的需求，建议设置到 c1 就够了，见后面。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eiommu=pt\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e (pass through)：这个是网络虚拟化 SR-IOV 用的，跟我们这次的 case 没有直接关系，\n  但既然要改启动项，就一起加上了，否则下次要用 SR-IOV 的功能还得再改一次启动项。\u003c/p\u003e\n\n    \u003cp\u003e\u003ca href=\"https://enterprise-support.nvidia.com/s/article/understanding-the-iommu-linux-grub-file-configuration\"\u003e更多信息\u003c/a\u003e：\n When in pass-through mode, the adapter does not need to use DMA translation to the memory, and this improves the performance.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e然后使配置生效：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egrub2-mkconfig \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e /boot/grub2/grub.cfg\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ereboot now\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e验证配置是否生效，几种方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e查看系统启动参数\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/cmdline \u003cspan class=\"c\"\u003e# 生效前\u003c/span\u003e\n \u003cspan class=\"nv\"\u003eBOOT_IMAGE\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/vmlinuz-5.10.56-xxx ... \u003cspan class=\"nv\"\u003ebiosdevname\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0 \u003cspan class=\"nv\"\u003eclocksource\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003etsc \u003cspan class=\"nv\"\u003etsc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ereliable\n\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/cmdline \u003cspan class=\"c\"\u003e# 生效后\u003c/span\u003e\n \u003cspan class=\"nv\"\u003eBOOT_IMAGE\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/vmlinuz-5.10.56-xxx ... \u003cspan class=\"nv\"\u003ebiosdevname\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0 \u003cspan class=\"nv\"\u003eclocksource\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003etsc \u003cspan class=\"nv\"\u003etsc\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ereliable \u003cspan class=\"nv\"\u003eAMD_pstat\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003edisable \u003cspan class=\"nv\"\u003eidle\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003epoll \u003cspan class=\"nv\"\u003enohz\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eoff \u003cspan class=\"nv\"\u003eiommu\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ept\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e看监控，频率固定在 3.7GHz 了（这个频率是通过较老版本的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elscpu\u003c/code\u003e 输出收集的，\n  表示的应该是所有 CPU 中运行频率最高的那个；实际上 per-CPU 展示更合理，详见\n  本站后面的 Linux 服务器系列文章 [4]）；而且即使负载比原来更高，也不会有 time_squeeze 了，\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-net-stack/cpuhz-vs-time_squeeze.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n    \u003cp align=\"center\"\u003eFig. Changing CPU mode from to performance\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpupower\u003c/code\u003e 查看 CPU 运行模式\u003c/p\u003e\n\n    \u003cp\u003e调整前：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower monitor\n               | Mperf              \u003cspan class=\"o\"\u003e||\u003c/span\u003e Idle_Stats\n  PKG|CORE| CPU| C0   | Cx   | Freq  \u003cspan class=\"o\"\u003e||\u003c/span\u003e POLL | C1   | C2\n    0|   0|   0| 19.87| 80.13|  2394||  0.00| 80.29|  0.00\n    0|   0|  64|  6.32| 93.68|  2393||  0.00| 93.77|  0.00\n    0|   1|   1| 27.10| 72.90|  2394||  0.00| 73.10|  0.00\n    0|   1|  65| 34.41| 65.59|  2394||  0.00| 65.58|  0.00\n    0|   2|   2| 33.27| 66.73|  2394||  0.01| 66.71|  0.00\n    0|   2|  66| 36.77| 63.23|  2394||  0.00| 63.00|  0.00\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e调整后：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecpupower monitor\n               | Mperf\n  PKG|CORE| CPU| C0   | Cx   | Freq\n    0|   0|   0| 99.57|  0.43|  3701\n    0|   0|  64| 99.57|  0.43|  3701\n    0|   1|   1| 99.58|  0.42|  3701\n    0|   1|  65| 99.57|  0.43|  3701\n    0|   2|   2| 99.58|  0.42|  3701\n    0|   2|  66| 99.57|  0.43|  3701\n    0|   3|   3| 99.58|  0.42|  3701\n    0|   3|  67| 99.58|  0.42|  3701\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e最后，更常见的启动项配置可能是这样：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eAMD_idle.max_cstate=1 processor.max_cstate=1 ...\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\n这两个参数表示：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e限制 CPU 的 cstate 模式最大深度睡眠是 c1，c1 状态可以快速切换到 c0 状态，带来的业务延迟相对较小；\u003c/li\u003e\n  \u003cli\u003e效果是在节能（省电）和高性能之间折中。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-irq-softirq-zh/\"\u003eLinux 中断（IRQ/softirq）基础：原理及内核实现\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-net-stack-implementation-rx-zh/\"\u003eLinux 网络栈接收数据（RX）：原理及内核实现\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/monitoring-network-stack/\"\u003eMonitoring Linux Network Stack\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-4-zh/\"\u003eLinux 服务器功耗与性能管理（四）：监控、配置、调优（2024）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/linux-net-stack-implementation-rx-zh/\"\u003e\u003cspan\u003e« Linux 网络栈接收数据（RX）：原理及内核实现（2022）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/linux-net-stack-zh/\"\u003e\u003cspan\u003eLinux 网络栈原理、监控与调优：前言（2022） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-07-02T00:00:00Z",
  "Author": "Arthur Chiao"
}