{
  "Source": "arthurchiao.art",
  "Title": "[笔记] Building Microservices（O'Reily 2015）",
  "Link": "https://arthurchiao.art/blog/building-microservices-notes-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[笔记] Building Microservices（O\u0026#39;Reily 2015）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2019-06-15 | Last Update 2019-06-15\u003c/p\u003e\n  \n  \u003ch3 id=\"前言\"\u003e前言\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.amazon.com/Building-Microservices-Designing-Fine-Grained-Systems/dp/1491950358/ref=sr_1_1\"\u003eBuilding Microservices: Designing Fine Grained\nSystems\u003c/a\u003e\n读书笔记。\u003c/p\u003e\n\n\u003cp\u003e本书偏理论而非实现，可作为内功心法，适合架构师或有经验的系统工程师。\u003c/p\u003e\n\n\u003cp\u003e常读常新。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#前言\" id=\"markdown-toc-前言\"\u003e前言\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#前言-1\" id=\"markdown-toc-前言-1\"\u003e前言\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-微服务\" id=\"markdown-toc-1-微服务\"\u003e1 微服务\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#什么是微服务\" id=\"markdown-toc-什么是微服务\"\u003e什么是微服务？\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#主要好处\" id=\"markdown-toc-主要好处\"\u003e主要好处\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#soa-与微服务\" id=\"markdown-toc-soa-与微服务\"\u003eSOA 与微服务\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#其他拆分方式\" id=\"markdown-toc-其他拆分方式\"\u003e其他拆分方式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#没有银弹\" id=\"markdown-toc-没有银弹\"\u003e没有银弹\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#总结\" id=\"markdown-toc-总结\"\u003e总结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-演进式架构师the-evolutionary-architect\" id=\"markdown-toc-2-演进式架构师the-evolutionary-architect\"\u003e2 演进式架构师（The Evolutionary Architect）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#软件工程和建筑工程的角色对比\" id=\"markdown-toc-软件工程和建筑工程的角色对比\"\u003e软件工程和建筑工程的角色对比\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#架构师应具备的演进式愿景\" id=\"markdown-toc-架构师应具备的演进式愿景\"\u003e架构师应具备的演进式愿景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#zoning服务或服务组边界\" id=\"markdown-toc-zoning服务或服务组边界\"\u003eZoning（服务或服务组边界）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#a-principled-approach\" id=\"markdown-toc-a-principled-approach\"\u003eA Principled Approach\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#the-required-standard\" id=\"markdown-toc-the-required-standard\"\u003eThe Required Standard\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#监控\" id=\"markdown-toc-监控\"\u003e监控\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#接口api\" id=\"markdown-toc-接口api\"\u003e接口（API）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#架构安全性architectural-safety\" id=\"markdown-toc-架构安全性architectural-safety\"\u003e架构安全性（Architectural Safety）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#确保代码符合规范governance-through-code\" id=\"markdown-toc-确保代码符合规范governance-through-code\"\u003e确保代码符合规范（Governance Through Code）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#exemplars\" id=\"markdown-toc-exemplars\"\u003eExemplars\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tailored-service-templates\" id=\"markdown-toc-tailored-service-templates\"\u003eTailored Service Templates\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#技术债technical-debt\" id=\"markdown-toc-技术债technical-debt\"\u003e技术债（Technical Debt）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#例外处理\" id=\"markdown-toc-例外处理\"\u003e例外处理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#总结-1\" id=\"markdown-toc-总结-1\"\u003e总结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-如何对服务建模\" id=\"markdown-toc-3-如何对服务建模\"\u003e3 如何对服务建模\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#良好的微服务的标准\" id=\"markdown-toc-良好的微服务的标准\"\u003e良好的微服务的标准\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#低耦合\" id=\"markdown-toc-低耦合\"\u003e低耦合\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#高内聚\" id=\"markdown-toc-高内聚\"\u003e高内聚\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#有界上下文the-bounded-context\" id=\"markdown-toc-有界上下文the-bounded-context\"\u003e有界上下文（The Bounded Context）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#shared-and-hidden-model\" id=\"markdown-toc-shared-and-hidden-model\"\u003eShared and Hidden Model\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#modules-and-services\" id=\"markdown-toc-modules-and-services\"\u003eModules and Services\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#过早拆分premature-decomposition\" id=\"markdown-toc-过早拆分premature-decomposition\"\u003e过早拆分（Premature Decomposition）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#业务功能business-capabilities\" id=\"markdown-toc-业务功能business-capabilities\"\u003e业务功能（Business Capabilities）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#turtles-all-the-way-down\" id=\"markdown-toc-turtles-all-the-way-down\"\u003eTurtles All the Way Down\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#communication-in-terms-of-business-concepts\" id=\"markdown-toc-communication-in-terms-of-business-concepts\"\u003eCommunication in Terms of Business Concepts\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#the-technical-boundary\" id=\"markdown-toc-the-technical-boundary\"\u003eThe Technical Boundary\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#summary\" id=\"markdown-toc-summary\"\u003eSummary\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-集成\" id=\"markdown-toc-4-集成\"\u003e4 集成\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#确定最佳的集成技术\" id=\"markdown-toc-确定最佳的集成技术\"\u003e确定最佳的集成技术\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#避免不兼容改动breaking-changes\" id=\"markdown-toc-避免不兼容改动breaking-changes\"\u003e避免不兼容改动（breaking changes）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#保持-api-技术无感知technology-agnostic\" id=\"markdown-toc-保持-api-技术无感知technology-agnostic\"\u003e保持 API 技术无感知（technology-agnostic）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#使服务对客户尽量简单\" id=\"markdown-toc-使服务对客户尽量简单\"\u003e使服务对客户尽量简单\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#避免暴露内部实现\" id=\"markdown-toc-避免暴露内部实现\"\u003e避免暴露内部实现\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#共享数据库\" id=\"markdown-toc-共享数据库\"\u003e共享数据库\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#异步还同步\" id=\"markdown-toc-异步还同步\"\u003e异步还同步\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#orchestration-versus-choreography管弦乐编排-vs-舞蹈编排\" id=\"markdown-toc-orchestration-versus-choreography管弦乐编排-vs-舞蹈编排\"\u003eOrchestration Versus Choreography（管弦乐编排 vs 舞蹈编排）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#管弦乐编排同步模式\" id=\"markdown-toc-管弦乐编排同步模式\"\u003e管弦乐编排（同步）模式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#舞蹈编排异步模式\" id=\"markdown-toc-舞蹈编排异步模式\"\u003e舞蹈编排（异步）模式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#rpc\" id=\"markdown-toc-rpc\"\u003eRPC\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#rest\" id=\"markdown-toc-rest\"\u003eREST\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#基于事件的异步协作实现\" id=\"markdown-toc-基于事件的异步协作实现\"\u003e基于事件的异步协作实现\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#技术选择technology-choices\" id=\"markdown-toc-技术选择technology-choices\"\u003e技术选择（Technology Choices）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#异步架构的复杂之处\" id=\"markdown-toc-异步架构的复杂之处\"\u003e异步架构的复杂之处\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#服务即状态机services-as-state-machines\" id=\"markdown-toc-服务即状态机services-as-state-machines\"\u003e服务即状态机（Services as State Machines）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#dry-和微服务里的代码重用\" id=\"markdown-toc-dry-和微服务里的代码重用\"\u003eDRY 和微服务里的代码重用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#access-by-reference\" id=\"markdown-toc-access-by-reference\"\u003eAccess by Reference\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#versioning\" id=\"markdown-toc-versioning\"\u003eVersioning\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#defer-it-as-long-as-possible\" id=\"markdown-toc-defer-it-as-long-as-possible\"\u003eDefer It as Long as Possible\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#catch-breaking-changes-early\" id=\"markdown-toc-catch-breaking-changes-early\"\u003eCatch Breaking Changes Early\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#use-semantic-versioning\" id=\"markdown-toc-use-semantic-versioning\"\u003eUse Semantic Versioning\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#coexist-different-endpoints同时支持不同版本的-api\" id=\"markdown-toc-coexist-different-endpoints同时支持不同版本的-api\"\u003eCoexist Different Endpoints（同时支持不同版本的 API）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#integration-with-third-party-software\" id=\"markdown-toc-integration-with-third-party-software\"\u003eIntegration with Third-Party Software\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#the-strangler-pattern阻气门模式\" id=\"markdown-toc-the-strangler-pattern阻气门模式\"\u003eThe Strangler Pattern（阻气门模式）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#总结-2\" id=\"markdown-toc-总结-2\"\u003e总结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-拆分单体应用\" id=\"markdown-toc-5-拆分单体应用\"\u003e5 拆分单体应用\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#its-all-about-seams\" id=\"markdown-toc-its-all-about-seams\"\u003eIt’s All About Seams\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#拆分单体应用的原因\" id=\"markdown-toc-拆分单体应用的原因\"\u003e拆分单体应用的原因\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#1-局部频繁变化pace-of-change\" id=\"markdown-toc-1-局部频繁变化pace-of-change\"\u003e1. 局部频繁变化（Pace of Change）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#2-团队结构变化team-structure\" id=\"markdown-toc-2-团队结构变化team-structure\"\u003e2. 团队结构变化（Team Structure）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#3-新技术应用方便technology\" id=\"markdown-toc-3-新技术应用方便technology\"\u003e3. 新技术应用方便（Technology）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#错综复杂的依赖tangled-dependencies\" id=\"markdown-toc-错综复杂的依赖tangled-dependencies\"\u003e错综复杂的依赖（Tangled Dependencies）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#例子外键关联\" id=\"markdown-toc-例子外键关联\"\u003e例子：外键关联\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#例子共享的静态数据\" id=\"markdown-toc-例子共享的静态数据\"\u003e例子：共享的静态数据\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#例子共享的可变数据mutable-data\" id=\"markdown-toc-例子共享的可变数据mutable-data\"\u003e例子：共享的可变数据（mutable data）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#例子共享表\" id=\"markdown-toc-例子共享表\"\u003e例子：共享表\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#数据库重构\" id=\"markdown-toc-数据库重构\"\u003e数据库重构\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#staging-the-break\" id=\"markdown-toc-staging-the-break\"\u003eStaging the Break\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#事务边界transactional-boundaries\" id=\"markdown-toc-事务边界transactional-boundaries\"\u003e事务边界（Transactional Boundaries）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#重试try-again-later\" id=\"markdown-toc-重试try-again-later\"\u003e重试（Try Again Later）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#全部回退abort-the-entire-operation\" id=\"markdown-toc-全部回退abort-the-entire-operation\"\u003e全部回退（Abort The Entire Operation）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#分布式事务\" id=\"markdown-toc-分布式事务\"\u003e分布式事务\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#到底怎么办呢\" id=\"markdown-toc-到底怎么办呢\"\u003e到底怎么办呢？\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#报表reporting\" id=\"markdown-toc-报表reporting\"\u003e报表（Reporting）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#模型-1数据库复制\" id=\"markdown-toc-模型-1数据库复制\"\u003e模型 1：数据库复制\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#模型-2pull-模型\" id=\"markdown-toc-模型-2pull-模型\"\u003e模型 2：Pull 模型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#模型-3push-模型\" id=\"markdown-toc-模型-3push-模型\"\u003e模型 3：Push 模型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#模型-4事件或消息队列模型\" id=\"markdown-toc-模型-4事件或消息队列模型\"\u003e模型 4：事件或消息队列模型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#模型-5备份数据模型\" id=\"markdown-toc-模型-5备份数据模型\"\u003e模型 5：备份数据模型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#实时性\" id=\"markdown-toc-实时性\"\u003e实时性\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-部署deployment\" id=\"markdown-toc-6-部署deployment\"\u003e6 部署（Deployment）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#持续集成简史\" id=\"markdown-toc-持续集成简史\"\u003e持续集成简史\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#持续发布\" id=\"markdown-toc-持续发布\"\u003e持续发布\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-测试\" id=\"markdown-toc-7-测试\"\u003e7 测试\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-监控\" id=\"markdown-toc-8-监控\"\u003e8 监控\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-安全\" id=\"markdown-toc-9-安全\"\u003e9 安全\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-康威定律和系统设计\" id=\"markdown-toc-10-康威定律和系统设计\"\u003e10 康威定律和系统设计\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#反面教材windows-vista\" id=\"markdown-toc-反面教材windows-vista\"\u003e反面教材：Windows Vista\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#证明教材amazon-和-netflix\" id=\"markdown-toc-证明教材amazon-和-netflix\"\u003e证明教材：Amazon 和 Netflix\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#11-大规模微服务\" id=\"markdown-toc-11-大规模微服务\"\u003e11 大规模微服务\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#服务降级\" id=\"markdown-toc-服务降级\"\u003e服务降级\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#架构安全\" id=\"markdown-toc-架构安全\"\u003e架构安全\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#措施\" id=\"markdown-toc-措施\"\u003e措施\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#cap-极简笔记\" id=\"markdown-toc-cap-极简笔记\"\u003eCAP 极简笔记\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-总结\" id=\"markdown-toc-12-总结\"\u003e12 总结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch3 id=\"前言-1\"\u003e前言\u003c/h3\u003e\n\n\u003cp\u003e微服务是分布式系统提高\u003cstrong\u003e细粒度服务\u003c/strong\u003e（use of finely grained services）使用的一种\n方式，在这种模式中，每个服务都有自己\u003cstrong\u003e独立的生命周期\u003c/strong\u003e，所有服务共同合作完成整体\n的功能。\u003c/p\u003e\n\n\u003cp\u003e微服务主要是\u003cstrong\u003e针对业务领域建模\u003c/strong\u003e的（modeled around business domains），因此可以\n避免传统\u003cstrong\u003e分层架构\u003c/strong\u003e（tiered architecture）的一些缺点。\u003c/p\u003e\n\n\u003cp\u003e微服务价格提供了越来越多的\u003cstrong\u003e自治性\u003c/strong\u003e（increased autonomy）。\u003c/p\u003e\n\n\u003ch2 id=\"1-微服务\"\u003e1 微服务\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eDomain Driven Design\u003c/em\u003e\u003c/strong\u003e：如何对系统建模。\u003c/p\u003e\n\n\u003cp\u003e领域驱动设计（DDD）、持续交付（CD）、按需虚拟化（On-demand virtualization）、基\n础设施自动化（Infrastructure automation）、小自治团队（Small autonomous teams）\n、大规模系统（Systems at scale）：这些都是微服务产生的前提。\u003c/p\u003e\n\n\u003cp\u003e微服务并不是凭空设计的，而是真实需求催生的。\u003c/p\u003e\n\n\u003ch3 id=\"什么是微服务\"\u003e什么是微服务？\u003c/h3\u003e\n\n\u003cp\u003e微服务：小的、自治的、一起工作的服务。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e小：专注、只做好一件事情\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e很难确定多小才算小，但是比较容易确定多大就算大\u003c/mark\u003e\u003c/strong\u003e：如果你觉得一个系统该拆分了，那它就是太大了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e自治\u003c/p\u003e\n\n    \u003cp\u003e判断标准：对一个服务进行改动升级，不影响其他服务。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"主要好处\"\u003e主要好处\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e技术异质性（Technology Heterogeneity）\n    \u003cul\u003e\n      \u003cli\u003e不同组件可以采用不同语言、框架、数据库类型等等。综合考虑功能、性能、成本等\n，选择最优的方案\u003c/li\u003e\n      \u003cli\u003e新技术落地更方便\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e容错性（Resilience）\n    \u003cul\u003e\n      \u003cli\u003e容错工程的一个核心概念：\u003cstrong\u003e\u003cmark\u003ebulkhead\u003c/mark\u003e\u003c/strong\u003e（防水壁）。一个组件出错，\n错误不应该瀑布式传递给其他系统（cascading），做到错误隔离\u003c/li\u003e\n      \u003cli\u003e但也应该认识到，微服务（分布式系统）跟单体应用相比，会引入新的故障源（\nsources of failure），例如网络故障、机器故障\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e扩展性（Scaling）\u003c/li\u003e\n  \u003cli\u003e易于部署（Ease of Deployment）\u003c/li\u003e\n  \u003cli\u003e架构和组织对齐（Organizational Alignment）\n    \u003cul\u003e\n      \u003cli\u003e多个小团队维护独立的较小的代码库，而不是大家一起维护一个很大的代码库\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e可组合性（Composability）\n    \u003cul\u003e\n      \u003cli\u003e单个服务可以同时被不同平台使用，例如一个后端同时服务 PC、Mobile、Tablet 的访\n  问\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e易于替换组件（Optimizing for Replaceability）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"soa-与微服务\"\u003eSOA 与微服务\u003c/h3\u003e\n\n\u003cp\u003e面向服务的架构（Service-oriented architecture，SOA）是一种多个服务协同工作来提供\n最终功能集合（end set of capabilities）的设计方式。这里的服务通常是操作系统中\n\u003cstrong\u003e完全独立的进程\u003c/strong\u003e。服务间的调用是跨网络的，而不是进程内的函数调用。\u003c/p\u003e\n\n\u003cp\u003eSOA 的出现是为了应对\u003cstrong\u003e庞大的单体应用\u003c/strong\u003e（large monolithic applications）带来的挑战。\n它的\u003cstrong\u003e目的是提高软件的重用性\u003c/strong\u003e（reusability of software），例如多个终端用户应用\n使用同一个后端服务。SOA 致力于\u003cstrong\u003e使软件更易维护和开发\u003c/strong\u003e，只要保持服务的语义不变，\n理论上换掉一个服务其他服务都感知不到。\u003c/p\u003e\n\n\u003cp\u003eSOA 的思想是好的，但是，\u003cstrong\u003e关于如何做好 SOA，业界并没有达成共识\u003c/strong\u003e。在我看来，\u003cstrong\u003e很\n多厂商鼓吹 SOA 只是为了兜售他们的产品\u003c/strong\u003e，而对业界大部分人对 SOA 本身还缺少全面和\n深入的思考。\u003c/p\u003e\n\n\u003cp\u003eSOA 门前的问题包括：通信协议（e.g. SOAP）、厂商中间件、对服务粒度缺乏指导、对在\n哪切分单体应用的错误指导等等。愤青（cynic）可能会觉得，厂商参与 SOA 只是为他们卖\n自家产品铺路，而这些大同小异的（selfsame）产品反而会削弱（undermine） SOA 的目标。\u003c/p\u003e\n\n\u003cp\u003eSOA 的常规实践经验（conventional wisdom）并不能帮助你确定如何对一个大应用进行拆分。\n例如，它不会讨论多大算大，不会讨论实际项目中如何避免服务间的过耦合。\n而这些没有讨论的东西都是 SOA 真正潜在的坑。\u003c/p\u003e\n\n\u003cp\u003e微服务源自真实世界的使用（real-world use），因此它对系统和架构的考虑比 SOA 要更\n多。可以做如下类比：\u003cstrong\u003e微服务之与 SOA 就像极限编程（XP）之与敏捷开发（Agile\n）\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"其他拆分方式\"\u003e其他拆分方式\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e共享库（Shared Libraries）：语言、操作系统、编译器等绑定\u003c/li\u003e\n  \u003cli\u003e模块（Modules）：模块/代码动态更新，服务不停。例如 Erlang\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"没有银弹\"\u003e没有银弹\u003c/h3\u003e\n\n\u003cp\u003e微服务并不是银弹，错误的选择会导致微服务变成闪着金光的锤子（a golden hammer）。\n微服务带来的挑战主要源自分布式系统自有的特质。需要在部署、测试、监控等方面下功夫\n，才能解锁服务器带来的好处。\u003c/p\u003e\n\n\u003ch3 id=\"总结\"\u003e总结\u003c/h3\u003e\n\n\u003ch2 id=\"2-演进式架构师the-evolutionary-architect\"\u003e2 演进式架构师（The Evolutionary Architect）\u003c/h2\u003e\n\n\u003ch3 id=\"软件工程和建筑工程的角色对比\"\u003e软件工程和建筑工程的角色对比\u003c/h3\u003e\n\n\u003cp\u003e计算机和软件行业很年轻，才六七十年。“工程师”、\u003cstrong\u003e\u003cmark\u003e“架构师”（architect，在英文里和建筑师是同一个单词）\u003c/mark\u003e\u003c/strong\u003e\n等头衔都是从其他行业借鉴过来的。但是，同样的头衔在不同行业所需承担的职责是有很大差别的，\n简单来说就是：\u003cstrong\u003e\u003cmark\u003e软件行业中的头衔普遍虚高，且对自己工作成果所需承担的责任都很小\u003c/mark\u003e\u003c/strong\u003e。\n例如，建筑师设计的房子倒塌的概率，要比架构师设计的软件崩溃的概率小得多。\u003c/p\u003e\n\n\u003cp\u003e另一方面，软件工程设计和建筑工程设计也确实有不同。例如桥梁，设计建好之后基本桥就\n不动了，而软件面向的是一直在变化的用户需求，架构要有比较好的可演进性。\u003c/p\u003e\n\n\u003cp\u003e建筑设计师更多的会考虑物理定律和建材特性，而\u003cstrong\u003e\u003cmark\u003e软件架构师容易飘飘然，与实现脱节，\n最后变成纸上谈兵，设计出灾难性的架构\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"架构师应具备的演进式愿景\"\u003e架构师应具备的演进式愿景\u003c/h3\u003e\n\n\u003cp\u003e客户的需求变化总是比架构师想象中来的更快，软件行业的技术和工具迭代速度也比传统行\n业快得多。\u003cstrong\u003e\u003cmark\u003e架构师不应该执着于设计出完美的终极架构，而更应该着眼于可演进的架构\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e软件架构师的角色与游戏《模拟城市》（\u003cstrong\u003e\u003cem\u003eSimCity\u003c/em\u003e\u003c/strong\u003e）里镇长（town planner）的角色\n非常相似，做出每个决策时都需要考虑到未来。\u003c/p\u003e\n\n\u003cp\u003e人们经常忽视的一个事实是：\u003cstrong\u003e软件系统并不仅仅是给用户使用的，开发和运维工程师也\n要围绕它工作，因此系统设计的也要对开发和运维友好\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eArchitects have a duty to ensure that a system is \u003cstrong\u003e\u003cem\u003ehabitable\u003c/em\u003e\u003c/strong\u003e for\ndevelopers too.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e总结起来一句话：设计一个让\u003cstrong\u003e用户\u003c/strong\u003e和\u003cstrong\u003e开发者\u003c/strong\u003e都喜欢的系统。\u003c/p\u003e\n\n\u003cp\u003e那么，如何才能设计出这样的系统呢？\u003c/p\u003e\n\n\u003ch3 id=\"zoning服务或服务组边界\"\u003eZoning（服务或服务组边界）\u003c/h3\u003e\n\n\u003cp\u003e架构师应该更多地关心\u003cstrong\u003e服务间\u003c/strong\u003e发生的事情，而不是\u003cstrong\u003e服务内\u003c/strong\u003e发生的事情。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBe worried about what happens between boxs, and be liberal in what happens\ninside.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e每个服务可以灵活选择自己的技术栈，但如果综合起来技术栈太过分散庞杂，那成本也会非\n常高，并且规模很难做大。需要在技术栈选择的灵活性和整体开发运维成本之间取得一个\n平衡。举例，Netflix 大部分服务都是使用 Cassandra。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e参与写代码的架构师（The coding architect）\u003c/p\u003e\n\n  \u003cp\u003e架构师花一部分时间参与到写代码，对项目的推进会比只是画图、开会、code review 要\n有效得多。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"a-principled-approach\"\u003eA Principled Approach\u003c/h3\u003e\n\n\u003cp\u003e架构设计就是一个不断做出选择（折中）的过程（all about trade-offs），微服务架构给\n我们的选择尤其多。\u003c/p\u003e\n\n\u003cp\u003e原则化（Framing）：Strategic Goals -\u0026gt; Principles -\u0026gt; Practices.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eA great way to help frame our decision making is to define a set of principles\nand practices that guide it, based on goals that we are trying to achieve.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/2-1.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 2-1 一个真实世界的原则和实践（principles and practices）的例子\u003c/p\u003e\n\n\u003cp\u003e最好提供\u003cstrong\u003e文档\u003c/strong\u003e和\u003cstrong\u003e示例代码\u003c/strong\u003e，甚至是额外的工具，来解释这些原则和实践标准。\u003c/p\u003e\n\n\u003ch3 id=\"the-required-standard\"\u003eThe Required Standard\u003c/h3\u003e\n\n\u003cp\u003e一个好的微服务应该长什么样：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIt needs to be a cohesive system made of many small parts with autonomous life\ncycles but all coming together.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4 id=\"监控\"\u003e监控\u003c/h4\u003e\n\n\u003cp\u003e建议所有的服务都对外暴露健康和监控信息。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ePush 模型：主动向外发送信息，例如 telegraf\u003c/li\u003e\n  \u003cli\u003ePull 模型：暴露端口，被动地被其他组件收集，例如 prometheus\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"接口api\"\u003e接口（API）\u003c/h4\u003e\n\n\u003cp\u003eAPI 有多种可选的实现方式。\n从粗的维度包括 HTTP/REST、RPC 等等，细的维度还包括它们各自内部的各自标准。例如，\nHTTP/REST API 里用动词还是名词、如何处理分页、如何处理不同 API 版本等等。\u003c/p\u003e\n\n\u003cp\u003e尽量保持在两种以内。\u003c/p\u003e\n\n\u003ch4 id=\"架构安全性architectural-safety\"\u003e架构安全性（Architectural Safety）\u003c/h4\u003e\n\n\u003cp\u003e不能因为一个服务挂掉，导致整个系统崩溃。\u003cstrong\u003e每个服务都应该在设计时就考虑到依\n赖的组件崩溃的情况\u003c/strong\u003e。这包括：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e线程池的连接数量\u003c/li\u003e\n  \u003cli\u003e熔断（circut breaker）\u003c/li\u003e\n  \u003cli\u003e快速失败（fast fail）\u003c/li\u003e\n  \u003cli\u003e统一的错误码（例如 HTTP Code）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"确保代码符合规范governance-through-code\"\u003e确保代码符合规范（Governance Through Code）\u003c/h3\u003e\n\n\u003cp\u003e两项有效的方式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eexemplars\u003c/li\u003e\n  \u003cli\u003eservice templates\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"exemplars\"\u003eExemplars\u003c/h4\u003e\n\n\u003ch4 id=\"tailored-service-templates\"\u003eTailored Service Templates\u003c/h4\u003e\n\n\u003cp\u003e将同样的东西统一化，可以库、代码模板或其他形式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e健康检查\u003c/li\u003e\n  \u003cli\u003eHTTP Handler\u003c/li\u003e\n  \u003cli\u003e输出监控信息的方式\u003c/li\u003e\n  \u003cli\u003e熔断器/方式\u003c/li\u003e\n  \u003cli\u003e容错处理\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但注意不要喧宾夺主，过于庞大的模板和库也是一种灾难。\u003c/p\u003e\n\n\u003ch3 id=\"技术债technical-debt\"\u003e技术债（Technical Debt）\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e技术债不一定都是由拙劣的设计导致的\u003c/strong\u003e。例如，如果后期的发展方向偏离了最初的设计\n目标，那部分（甚至大部分）系统也会成为技术债。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e技术债也并不是一经发现就要投入精力消除\u003c/strong\u003e。\n架构师应该从更高的层面审视这个问题，在”立即还债”和”继续忍耐”之间取得一个平衡。\u003c/p\u003e\n\n\u003cp\u003e维护一个技术债列表，定期 review。\u003c/p\u003e\n\n\u003ch3 id=\"例外处理\"\u003e例外处理\u003c/h3\u003e\n\n\u003cp\u003e如果你所在的公司对开发者的限制非常多，那微服务并不是适合你们。\u003c/p\u003e\n\n\u003ch3 id=\"总结-1\"\u003e总结\u003c/h3\u003e\n\n\u003cp\u003e演进式架构师的核心职责：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e技术愿景（Vision）：对系统有清晰的技术愿景，并且与团队充分沟通，系统满足客户和\n公司的需求\u003c/li\u003e\n  \u003cli\u003e深入实际（Empathy，理解）：理解你的决定对客户和同事产生的影响\u003c/li\u003e\n  \u003cli\u003e团结合作（Collaboration）：与同事紧密合作来定义、优化和执行技术愿景\u003c/li\u003e\n  \u003cli\u003e拥抱变化（Adaptability，自适应性）：技术愿景能随着客户需求的变化而变化\u003c/li\u003e\n  \u003cli\u003e服务自治（Autonomy，自治性）：在标准化和允许团队自治之间取得平衡\u003c/li\u003e\n  \u003cli\u003e落地把控（Governance）：确保系统是按照技术愿景实现的\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这是一个长期的寻求平衡的过程，需要经验的不断积累。\u003c/p\u003e\n\n\u003ch2 id=\"3-如何对服务建模\"\u003e3 如何对服务建模\u003c/h2\u003e\n\n\u003cp\u003e划分微服务的边界。\u003c/p\u003e\n\n\u003ch3 id=\"良好的微服务的标准\"\u003e良好的微服务的标准\u003c/h3\u003e\n\n\u003cp\u003e标准：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e低耦合（loose coupling）\u003c/li\u003e\n  \u003cli\u003e高内聚（high cohesive）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这两个术语在很多场合，尤其是面向对象系统（object oriented systems）中已经被用烂\n了，但我们还是要解释它们在微服务领域里表示什么。\u003c/p\u003e\n\n\u003ch4 id=\"低耦合\"\u003e低耦合\u003c/h4\u003e\n\n\u003cp\u003e哪些事情会导致高耦合？一种典型的场景是\u003cstrong\u003e错误的系统对接（integration）方式\u003c/strong\u003e，导致依赖其他服务。\u003c/p\u003e\n\n\u003cp\u003e低耦合的系统对其他系统知道的越少越好，这意味着，我们也许应该减少服务间通信的种类\n。啰嗦（chatty）的通信除了性能问题之外，还会导致高耦合。\u003c/p\u003e\n\n\u003ch4 id=\"高内聚\"\u003e高内聚\u003c/h4\u003e\n\n\u003cp\u003e相关的逻辑集中到一起，改动升级时便只涉及一个组件。因此，核心问题转变成：\u003cstrong\u003e确\n定问题域的边界\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"有界上下文the-bounded-context\"\u003e有界上下文（The Bounded Context）\u003c/h3\u003e\n\n\u003cp\u003e《领域驱动设计》：对真实世界域（real-world domains）进行建模来设计系统。\n其中一个重要概念：\u003cstrong\u003e\u003cem\u003ebounded context\u003c/em\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBounded Context: Any given domain consists of multiple bounded contexts, and\nresiding within each are things that do not need to communicate outside as\nwell as things that are shared externally with other bounded contexts. Each\nbounded context has an explicit interface, where it decides what models to\nshare with other contexts.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eBounded context 的另一种定义：\u003cstrong\u003e由显式的边界定义的具体的责任\u003c/strong\u003e（a specific\nresponsibility enforced by explicit boundarries）。类比：细胞膜（membrance），细\n胞之间的边界，决定了哪些可以通过，哪些需要保持在细胞内部。\u003c/p\u003e\n\n\u003ch4 id=\"shared-and-hidden-model\"\u003eShared and Hidden Model\u003c/h4\u003e\n\n\u003cp\u003e一般来说，如果一个 model 需要对外暴露，那对外的和内部使用的 model 也应该是不同的\n，因为很多细节是只有内部才需要的，没有必要暴露给外部，因此会分为：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eshared models：bounded context 对外暴露的 models\u003c/li\u003e\n  \u003cli\u003ehidden models：bounded context 内部使用的 models\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e举例：订单的模型，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eHidden model：在数据库中的表示\u003c/li\u003e\n  \u003cli\u003eShared model：在 REST API 中的表示\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"modules-and-services\"\u003eModules and Services\u003c/h4\u003e\n\n\u003cp\u003eShared model 和 hidden model 使得服务间不依赖内部细节，实现了解耦。\u003c/p\u003e\n\n\u003cp\u003e确保 bounded context 实现成一个代码模块（module），以实现高内聚。这些模块化的边\n界，就是微服务的理想分割点。\u003c/p\u003e\n\n\u003cp\u003e如果\u003cstrong\u003e服务的边界\u003c/strong\u003e和问题域的 bounded context 边界是对齐的，而且我们的微服务能够\n表示（represent）这些 bounded context，那么我们就走在了低耦合和高内聚的正确道路\n上。\u003c/p\u003e\n\n\u003ch4 id=\"过早拆分premature-decomposition\"\u003e过早拆分（Premature Decomposition）\u003c/h4\u003e\n\n\u003cp\u003e项目早期，边界一直在变化，不适合拆分成微服务。应该等边界比较稳定之后再开始。\u003c/p\u003e\n\n\u003ch3 id=\"业务功能business-capabilities\"\u003e业务功能（Business Capabilities）\u003c/h3\u003e\n\n\u003cp\u003e设计一个 bounded context 首先应该考虑的不是\u003cstrong\u003e共享什么数据\u003c/strong\u003e，而是这个 bounded\ncontext \u003cstrong\u003e能为域内的其他服务提供什么功能（capability）\u003c/strong\u003e。如果一上来就考虑数据模\n型，很容易设计出缺乏活力的（anemic）、基于 CRUD （增删查改）的服务。\u003c/p\u003e\n\n\u003ch3 id=\"turtles-all-the-way-down\"\u003eTurtles All the Way Down\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/3-2.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 3-2 Microservices representing nested bounded contexts\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/3-3.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 3-3 The bounded contexts being popped up into their own top-level contexts\u003c/p\u003e\n\n\u003cp\u003e选择哪种需要视组织结构：如果上面三个服务是同一个团队负责的，那 3-2 比较合适；如\n果是三个不同团队负责的，那 3-3 比较合适。康威定律。\u003c/p\u003e\n\n\u003cp\u003e另外，测试的难易程度也会有差异。\u003c/p\u003e\n\n\u003ch3 id=\"communication-in-terms-of-business-concepts\"\u003eCommunication in Terms of Business Concepts\u003c/h3\u003e\n\n\u003ch3 id=\"the-technical-boundary\"\u003eThe Technical Boundary\u003c/h3\u003e\n\n\u003cp\u003e避免：\u003cstrong\u003e洋葱架构\u003c/strong\u003e（onion architecture）。软件层级非常多，从上往下切的时候，会让\n人忍不住掉眼泪。\u003c/p\u003e\n\n\u003ch3 id=\"summary\"\u003eSummary\u003c/h3\u003e\n\n\u003cp\u003e本章学习了什么是一个好的服务，如何找出问题域的边界，以及由此带来的两个好处：低耦\n合和高内聚。Bounded context 是帮助我们完成这一目的的利器。\u003c/p\u003e\n\n\u003cp\u003e《领域驱动设计》描述了如何找出恰当的边界，这本书非常经典，本章只是涉及了它的一点\n皮毛（scratched the surface）。另外，推荐《领域驱动设计实现》（\u003cstrong\u003e\u003cem\u003eImplementing\nDomain-Driven Design\u003c/em\u003e\u003c/strong\u003e），以帮助更好的理解 DDD 的实践。\u003c/p\u003e\n\n\u003ch2 id=\"4-集成\"\u003e4 集成\u003c/h2\u003e\n\n\u003cp\u003e我个人认为，\u003cstrong\u003e集成（integration）是微服务中最重要的一方面\u003c/strong\u003e。集成方案设计的好，\n万事 OK；设计的不好，坑（pitfall）会一个接着一个。\u003c/p\u003e\n\n\u003ch3 id=\"确定最佳的集成技术\"\u003e确定最佳的集成技术\u003c/h3\u003e\n\n\u003cp\u003eSOAP、XML-RPC、REST、ProtoBuf 等等。\u003c/p\u003e\n\n\u003ch4 id=\"避免不兼容改动breaking-changes\"\u003e避免不兼容改动（breaking changes）\u003c/h4\u003e\n\n\u003cp\u003e尽最大努力。\u003c/p\u003e\n\n\u003ch4 id=\"保持-api-技术无感知technology-agnostic\"\u003e保持 API 技术无感知（technology-agnostic）\u003c/h4\u003e\n\n\u003cp\u003e如果你在 IT 行业已经混了 15 分钟以上，那就不用我提醒你这个行业变化有多快了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIf you have been in the IT industry for more than 15 minutes, you don’t need\nme to tell you that we work in a space that is changing rapidly.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e新的技术、平台、工具不断涌现，其中一些用好了可以极大提高效率，因此 API 不应该绑\n死到一种技术栈。\u003c/p\u003e\n\n\u003ch4 id=\"使服务对客户尽量简单\"\u003e使服务对客户尽量简单\u003c/h4\u003e\n\n\u003cp\u003e从选择的角度讲，应该允许客户使用任何技术来访问服务。\u003c/p\u003e\n\n\u003cp\u003e从方便的角度讲，给客户提供一个客户端库会大大方便他们的使用。但也也会造成和服务端\n的耦合，需要权衡。\u003c/p\u003e\n\n\u003ch4 id=\"避免暴露内部实现\"\u003e避免暴露内部实现\u003c/h4\u003e\n\n\u003cp\u003e暴露内部实现会增加耦合。任何会导致暴露内部实现的技术，都应该避免使用。\u003c/p\u003e\n\n\u003ch3 id=\"共享数据库\"\u003e共享数据库\u003c/h3\u003e\n\n\u003cp\u003e这也是最简单、最常用的集成方式是：\u003cstrong\u003e数据库集成\u003c/strong\u003e（DB integration，使用同一个数据库）。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/4-1.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 4-1 数据库集成\u003c/p\u003e\n\n\u003cp\u003e缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e允许外部组件直接查看和绑定内部实现细节\n    \u003col\u003e\n      \u003cli\u003e修改数据库的字段会影响所有相关服务\u003c/li\u003e\n      \u003cli\u003e回归测试麻烦\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e外部组件被迫绑定到特定技术（数据库实现）\n    \u003col\u003e\n      \u003cli\u003e如果要从关系数据库切换到非关系数据库，外部组件也得跟着改\u003c/li\u003e\n      \u003cli\u003e高耦合\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e外部组件包含相同逻辑，例如查询，修改数据库\n    \u003col\u003e\n      \u003cli\u003e要修一个 bug 或加一个 feature，得改每一个组件\u003c/li\u003e\n      \u003cli\u003e低内聚\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e微服务的两个标准：低耦合和高内聚，被破坏殆尽。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eDatabase integration makes it easy for services to share data, but does\nnothing about \u003cem\u003esharing behavior\u003c/em\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"异步还同步\"\u003e异步还同步\u003c/h3\u003e\n\n\u003cp\u003e同步和异步会导致不同的协助模式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e同步：请求/响应式（request/response）\n    \u003cul\u003e\n      \u003cli\u003e客户端主动发起请求，然后等待结果\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e同步请求 + 回调函数\u003c/strong\u003e的方式也属于请求/响应模式\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e异步：事件驱动式（event-based）\n    \u003cul\u003e\n      \u003cli\u003e服务端主动通知客户端发生了某事件\u003c/li\u003e\n      \u003cli\u003e从本质上（by nature）就是异步的\u003c/li\u003e\n      \u003cli\u003e处理逻辑更分散，而不是集中到一个系统\u003c/li\u003e\n      \u003cli\u003e低耦合，服务只负责发事件通知，谁会对此事件作出反应，它并不知道，也不关心\u003c/li\u003e\n      \u003cli\u003e添加新的订阅者时，客户端无感知\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e选择哪种模式？重要标准：\u003cstrong\u003e哪个更适合解决常见的复杂场景问题\u003c/strong\u003e，例如跨多个服务的请\n求调用。\u003c/p\u003e\n\n\u003ch3 id=\"orchestration-versus-choreography管弦乐编排-vs-舞蹈编排\"\u003eOrchestration Versus Choreography（管弦乐编排 vs 舞蹈编排）\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e管弦乐编排\u003c/strong\u003e：有一个中心的指挥家（conductor），指示每个乐队成员该做什么\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e舞蹈编排\u003c/strong\u003e：没有指挥家，每个舞蹈演员各司其职\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以创建一个新用户的流程为例：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/4-2.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 4-2 The process for creating a new customer\u003c/p\u003e\n\n\u003ch4 id=\"管弦乐编排同步模式\"\u003e管弦乐编排（同步）模式\u003c/h4\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/4-3.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 4-3 Handling customer creation via orchestration\u003c/p\u003e\n\n\u003cp\u003e优点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e很容易将流程图转变成代码实现，甚至有工具做这种事情，例如合适的规则引擎（rule\nengine）。另外还有很多商业软件专门做这种事情（business process modeling\nsoftware）\u003c/li\u003e\n  \u003cli\u003e如果使用同步方式，编排器（大脑）还能知道每个阶段的调用是否成功\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e编排器成为核心，很大一部分逻辑都实现在这里\u003c/li\u003e\n  \u003cli\u003e单点及性能问题\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"舞蹈编排异步模式\"\u003e舞蹈编排（异步）模式\u003c/h4\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/4-4.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 4-4 Handling customer creation via choreography\u003c/p\u003e\n\n\u003cp\u003e优点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e耦合更低、更灵活、更易扩展\u003c/li\u003e\n  \u003cli\u003e添加新订阅者方便，不需要改编排器代码\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e架构更松散，只能隐式地反映流程图\u003c/li\u003e\n  \u003cli\u003e需要更好的监控和跟踪系统，才能高效排障\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e总体来说优先推荐舞蹈编排模式。也可以两者结合使用。\u003c/p\u003e\n\n\u003cp\u003e请求/响应式设计时两者常见的通信方式：RPC 和 REST。\u003c/p\u003e\n\n\u003ch3 id=\"rpc\"\u003eRPC\u003c/h3\u003e\n\n\u003cp\u003e存在的几个问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e远程过程调用和本地（函数）调用看起来一模一样，但实际上不一样，性能差很多\u003c/li\u003e\n  \u003cli\u003e契约字段基本上只增不减（expand only），否则会破坏老版本兼容性，最后导致大量不\n用的字段留在协议里\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eCompared to database integration, RPC is certainly an improvement when we\nthink about options for request/response collaboration.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eRPC 的性能一般更好，因为它们可以采用二进制格式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e消息体更小\u003c/li\u003e\n  \u003cli\u003e延迟更低\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"rest\"\u003eREST\u003c/h3\u003e\n\n\u003cp\u003e资源\u003cstrong\u003e对外的表现形式\u003c/strong\u003e（JSON、XML 等）和它们\u003cstrong\u003e在服务内的存储形式\u003c/strong\u003e是完全分开的。\u003c/p\u003e\n\n\u003cp\u003eREST 本身并没有限定底层协议，但事实上用的最多的还是 HTTP 一种。\u003c/p\u003e\n\n\u003cp\u003e虽然性能没有 RPC 好，但很多情况下， REST/HTTP 仍然是服务间通信的首选。\u003c/p\u003e\n\n\u003ch3 id=\"基于事件的异步协作实现\"\u003e基于事件的异步协作实现\u003c/h3\u003e\n\n\u003ch4 id=\"技术选择technology-choices\"\u003e技术选择（Technology Choices）\u003c/h4\u003e\n\n\u003cp\u003e需要消息队列这样的中间件。\u003c/p\u003e\n\n\u003cp\u003e中间件应该\u003cstrong\u003e聚焦其功能本身\u003c/strong\u003e，其他逻辑都实现在服务中：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eMake sure you know what you’re getting: keep your middleware dumb, and\nkeep the smarts in the endpoints.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4 id=\"异步架构的复杂之处\"\u003e异步架构的复杂之处\u003c/h4\u003e\n\n\u003cp\u003e建议在上异步架构之前，做好\u003cstrong\u003e监控和追踪方案\u003c/strong\u003e（例如生成关联 ID，在不同服务\n间跟踪请求）。\u003c/p\u003e\n\n\u003cp\u003e强烈建议 \u003cstrong\u003e\u003cem\u003eEnterprise Integration Pattern\u003c/em\u003e\u003c/strong\u003e 一书。\u003c/p\u003e\n\n\u003ch3 id=\"服务即状态机services-as-state-machines\"\u003e服务即状态机（Services as State Machines）\u003c/h3\u003e\n\n\u003cp\u003e每个服务都限定在一个 bounded context 内，所有与此 context 相关的逻辑都封装在其内\n部。服务控制着 context 内对象的整个生命周期。\u003c/p\u003e\n\n\u003ch3 id=\"dry-和微服务里的代码重用\"\u003eDRY 和微服务里的代码重用\u003c/h3\u003e\n\n\u003cp\u003eDRY：Don’t Repeat Yourself.\u003c/p\u003e\n\n\u003cp\u003eDRY 一般已经简化为避免\u003cstrong\u003e代码\u003c/strong\u003e重复，但实际上更严格地说，它指的是避免系统\u003cstrong\u003e行为和\n知识\u003c/strong\u003e的重复。\u003c/p\u003e\n\n\u003cp\u003eDRY 落实到实现层面就是将公用的部分抽象成库，但注意，这在微服务里可能会导致问题。\n例如，如果所有服务都依赖一个公用库，那这些服务也就形成了耦合。当其中一个服务想（\n不兼容）更新这个库的时候，其他服务都得跟着升级，导致服务间独立升级的假设被打破。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eRule of thumb: don’t violate DRY within a microservice, but be relaxed about\nviolating DRY across all services.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e耦合的代价比代码重复的代价高的多。\u003c/p\u003e\n\n\u003cp\u003e典型的例子：客户端程序。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e写服务端的团队最好不要同时提供标配客户端\u003c/strong\u003e，否则服务端实现细节会不知不觉地泄漏\n到客户端程序，导致耦合。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eif the same people create both the server API and the client\nAPI, there is the danger that logic that should exist on the server starts\nleaking into the client.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这方面做的比较好的：AWS。AWS API 通过 SDK 的形式访问，而这些 SDK 要么是有社区自\n发开发的，要么是 AWS API 以外的团队开发的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003emake sure that the clients are in charge of when to upgrade their client\nlibraries: we need to ensure we maintain the ability to release our services\nindependently of each other!\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"access-by-reference\"\u003eAccess by Reference\u003c/h3\u003e\n\n\u003cp\u003e当一个订单确定之后，需要以事件的方式通知邮件系统给用户发一封邮件。两种选择：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e将订单信息放到消息体里，邮件系统收到消息后就发送邮件\u003c/li\u003e\n  \u003cli\u003e将订单索引放到消息体里，邮件系统收到消息后先去另外一个系统去获取订单详情，再\n发送邮件\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在基于事件的方式中，我们经常说这个事件\u003cstrong\u003e发生了\u003c/strong\u003e（\u003cem\u003ethis happened\u003c/em\u003e），但我们需要\n知道的是：\u003cstrong\u003e发生了什么\u003c/strong\u003e（\u003cem\u003ewhat happened\u003c/em\u003e）。\u003c/p\u003e\n\n\u003cp\u003e第三种选择：同时带上订单信息和索引，这样事件发生时，邮件系统既能及时得到最新通知\n，在未来一段时间又能主动根据索引去查询当前详情。\u003c/p\u003e\n\n\u003ch3 id=\"versioning\"\u003eVersioning\u003c/h3\u003e\n\n\u003ch4 id=\"defer-it-as-long-as-possible\"\u003eDefer It as Long as Possible\u003c/h4\u003e\n\n\u003cp\u003e客户端对消息的解析要有足够的兼容性，老版本客户端收到新字段时不做处理，称为\n\u003cstrong\u003eTolerant Reader\u003c/strong\u003e 模式。\u003c/p\u003e\n\n\u003cp\u003e健壮性定理（the robustness principle）：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eBe conservative in what you do, be liberal in what you accept from others.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4 id=\"catch-breaking-changes-early\"\u003eCatch Breaking Changes Early\u003c/h4\u003e\n\n\u003cp\u003e消费者驱动型合约（consumer-driven contracts）。\u003c/p\u003e\n\n\u003ch4 id=\"use-semantic-versioning\"\u003eUse Semantic Versioning\u003c/h4\u003e\n\n\u003cp\u003e版本号格式：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;major\u0026gt;.\u0026lt;minor\u0026gt;.\u0026lt;patch\u0026gt;\u003c/code\u003e，含义：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;major\u0026gt;\u003c/code\u003e：大版本号，递增时表示有不兼容式（incompatible）更新\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;minor\u0026gt;\u003c/code\u003e：小版本号，递增时表示有新的特性，兼容以前的版本\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;patch\u0026gt;\u003c/code\u003e：补丁号，递增时表示修复 bug\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"coexist-different-endpoints同时支持不同版本的-api\"\u003eCoexist Different Endpoints（同时支持不同版本的 API）\u003c/h4\u003e\n\n\u003cp\u003e引入不兼容 API 时，同时支持新老版本：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/4-5.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 4-5 \u003c/p\u003e\n\n\u003cp\u003e这是\u003cstrong\u003e扩展与合约模式\u003c/strong\u003e（expand and contract pattern）的一个例子，用于分阶段引入\n不兼容更新（phase breaking changes in）。首先扩展（expand）我们提供的功能，同时\n提供新老方式；当老用户迁移到新方式后，按照 API 合约（contract），删除老功能。\u003c/p\u003e\n\n\u003ch3 id=\"integration-with-third-party-software\"\u003eIntegration with Third-Party Software\u003c/h3\u003e\n\n\u003ch4 id=\"the-strangler-pattern阻气门模式\"\u003eThe Strangler Pattern（阻气门模式）\u003c/h4\u003e\n\n\u003cp\u003e在老系统前面加一层服务专门做代理，屏蔽背后的系统。这样后面的系统不论是升级、改造\n甚至完全换掉，对其他系统都是无感知的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003ewith a strangler you capture and intercept calls to the old system. This\nallows you to decide if you route these calls to existing, legacy code, or\ndirect them to new code you may have written. This allows you to replace\nfunctionality over time without requiring a big bang rewrite.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"总结-2\"\u003e总结\u003c/h3\u003e\n\n\u003cp\u003e保持系统解耦的建议：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e不要通过数据库集成\u003c/li\u003e\n  \u003cli\u003e理解 REST 和 RPC 的区别，推荐先从基于 REST 的 request/response 模式开始做起\u003c/li\u003e\n  \u003cli\u003e优先考虑\u003cstrong\u003e舞蹈编排模式\u003c/strong\u003e（Prefer choreography over orchestration）\u003c/li\u003e\n  \u003cli\u003e避免不兼容更新，理解版本化的必要，理解健壮性定理、tolerant reader 模式\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"5-拆分单体应用\"\u003e5 拆分单体应用\u003c/h2\u003e\n\n\u003ch3 id=\"its-all-about-seams\"\u003eIt’s All About Seams\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cem\u003eWorking Effictively with Legacy Code\u003c/em\u003e\u003c/strong\u003e（Prentice Hall）一书中定义了 Seam 的\n概念：隔离的、独立的代码块。\u003c/p\u003e\n\n\u003cp\u003eBounded contexts make excellent seams.\u003c/p\u003e\n\n\u003cp\u003e一些语言提供了 namespace，可以隔离代码。\u003c/p\u003e\n\n\u003cp\u003e将不同部分实现为不同模块（module 或 package）。\u003c/p\u003e\n\n\u003cp\u003e应该采用渐进式拆分。\u003c/p\u003e\n\n\u003ch3 id=\"拆分单体应用的原因\"\u003e拆分单体应用的原因\u003c/h3\u003e\n\n\u003ch4 id=\"1-局部频繁变化pace-of-change\"\u003e1. 局部频繁变化（Pace of Change）\u003c/h4\u003e\n\n\u003cp\u003e预见到某一部分接下来会频繁变化，将其单独抽离出来。更新部署会更快，单元测试也更\n方便。\u003c/p\u003e\n\n\u003ch4 id=\"2-团队结构变化team-structure\"\u003e2. 团队结构变化（Team Structure）\u003c/h4\u003e\n\n\u003cp\u003e团队拆分、合并等变化，软件系统能跟随组织结构变化，会提高开发效率。康威定律。\u003c/p\u003e\n\n\u003ch4 id=\"3-新技术应用方便technology\"\u003e3. 新技术应用方便（Technology）\u003c/h4\u003e\n\n\u003cp\u003e便于某一部分功能采用新技术，如新语言、新框架等等。\u003c/p\u003e\n\n\u003ch3 id=\"错综复杂的依赖tangled-dependencies\"\u003e错综复杂的依赖（Tangled Dependencies）\u003c/h3\u003e\n\n\u003cp\u003e有向无环图（DAG）可以帮助分析依赖。\u003c/p\u003e\n\n\u003cp\u003eThe mother of all tangled dependencies: the database.\u003c/p\u003e\n\n\u003cp\u003e使用一些可视化工具查看数据库表之间的依赖，例如 SchemaSpy 等。\u003c/p\u003e\n\n\u003ch4 id=\"例子外键关联\"\u003e例子：外键关联\u003c/h4\u003e\n\n\u003cp\u003e数据库依赖解耦：去除不同 bounded context 之间的外键关联。\u003c/p\u003e\n\n\u003ch4 id=\"例子共享的静态数据\"\u003e例子：共享的静态数据\u003c/h4\u003e\n\n\u003cp\u003e例如，国家代码，原来可能存在数据库，所有组件都访问。\u003c/p\u003e\n\n\u003cp\u003e解决方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个服务都复制一份：以代码或配置文件的方式存储；如果数据会被修改，需要解决数据一致性问题\u003c/li\u003e\n  \u003cli\u003e单独抽象一个服务，提供静态数据服务：适用于静态数据很复杂的场景\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"例子共享的可变数据mutable-data\"\u003e例子：共享的可变数据（mutable data）\u003c/h4\u003e\n\n\u003cp\u003e两个服务都需要更新同一张表。\u003c/p\u003e\n\n\u003cp\u003e解决方式：需要抽象出两个服务间的公共部分，单独一个组件，完成对表的更新。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-5.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-5 Accessing customer data: are we missing something?\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-6.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-6 Recognizing the bounded context of the customer\u003c/p\u003e\n\n\u003ch4 id=\"例子共享表\"\u003e例子：共享表\u003c/h4\u003e\n\n\u003cp\u003e拆表。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-7.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-7 Tables being shared between different contexts\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-8.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-8 Pulling apart the shared table\u003c/p\u003e\n\n\u003ch3 id=\"数据库重构\"\u003e数据库重构\u003c/h3\u003e\n\n\u003cp\u003eBook: \u003cstrong\u003e\u003cem\u003eRefactoring Database\u003c/em\u003e\u003c/strong\u003e, Addison-Wesley\u003c/p\u003e\n\n\u003ch4 id=\"staging-the-break\"\u003eStaging the Break\u003c/h4\u003e\n\n\u003cp\u003e先拆分库，再拆分服务，步子不要迈得太大：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-9.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-9 Staging a service separation\u003c/p\u003e\n\n\u003ch3 id=\"事务边界transactional-boundaries\"\u003e事务边界（Transactional Boundaries）\u003c/h3\u003e\n\n\u003cp\u003e拆分成独立服务后，原来单体应用中的事务边界就丢失了，拆分后需要解决原子性的问题。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-10.png\" width=\"35%\" height=\"35%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-10 Updating two tables in a single transaction\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-11.png\" width=\"35%\" height=\"35%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-11 Spanning transactional boundaries for a single operation\u003c/p\u003e\n\n\u003ch4 id=\"重试try-again-later\"\u003e重试（Try Again Later）\u003c/h4\u003e\n\n\u003cp\u003e将失败的操作放到一个 queue 或 logfile 里，稍后重试。对于一部分类型的应用来说这样\n是可行的。\u003c/p\u003e\n\n\u003cp\u003e属于\u003cstrong\u003e最终一致性\u003c/strong\u003e（eventual consistency）。第 11 章会详细讨论。\u003c/p\u003e\n\n\u003ch4 id=\"全部回退abort-the-entire-operation\"\u003e全部回退（Abort The Entire Operation）\u003c/h4\u003e\n\n\u003cp\u003e需要一个补偿事务（compensating transaction）执行回退操作。\u003c/p\u003e\n\n\u003cp\u003e如果补偿事务又失败了怎么办？\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e重试\u003c/li\u003e\n  \u003cli\u003e直接报错，人工介入清理脏数据\u003c/li\u003e\n  \u003cli\u003e有相应的后台进程或服务，定期清理脏数据\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e当只有两个步骤时，保持两个事务的原子性还算简单。但假如有三个、四个、五个步骤时呢\n？补偿事务方式显然将极其复杂，这时候就要用到分布式事务。\u003c/p\u003e\n\n\u003ch4 id=\"分布式事务\"\u003e分布式事务\u003c/h4\u003e\n\n\u003cp\u003e有一个中心的 transaction manager。跨服务编排事务。\u003c/p\u003e\n\n\u003cp\u003e最常见的 short-lived transaction 算法：两阶段提交（two-phase commit）。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e投票（voting）阶段：每个参与方分别向事务管理员汇报它是否可以执行事务\u003c/li\u003e\n  \u003cli\u003e提交（commit）阶段：如果所有参与方投票都是 yes，事务管理员就下达提交命令，参\n与方开始执行事务\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e依赖一个中心的 transaction manager 发号施令，transaction manager 出问题时整个\n系统将无法执行事务操作\u003c/li\u003e\n  \u003cli\u003e任何一个参与方无法应答 transaction manager 时，事务都会无法进行\u003c/li\u003e\n  \u003cli\u003e参与方提交阶段失败：\u003cstrong\u003e两阶段提交算法假设每个参与方的提交阶段只会成功不会失败\u003c/strong\u003e，\n但这个假设并不成立。这意味着这个算法在理论上不是\u003cstrong\u003e可靠的\u003c/strong\u003e（foolproof），\n只能解决大部分场景（参与方提交成功的场景）\u003c/li\u003e\n  \u003cli\u003e提交失败的情况：参与方会锁住资源无法释放，极大限制了系统的可扩展性\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e两阶段提交算法原理简单，实现复杂，因为可能导致失败的条件非常多，代码都得做相应处理。\u003c/p\u003e\n\n\u003cp\u003e建议：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e能不用就不用\u003c/li\u003e\n  \u003cli\u003e必须得用时，优先考虑找一个已有的实现，而不是自己写\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"到底怎么办呢\"\u003e到底怎么办呢？\u003c/h4\u003e\n\n\u003cp\u003e分布式事务不可靠，补偿事务太复杂，那到底该怎么办呢？\u003c/p\u003e\n\n\u003cp\u003e面对这种问题时，首先考虑，是否真的需要保持分布式事务属性？能否用多个本地事务加最\n终一致性代替？后者更容易构建和扩展。\u003c/p\u003e\n\n\u003cp\u003e如果真的是必须要保持事务属性，那建议：尽最大努力保持为单个事务，不要做事务拆分。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIf you do encounter state that really, really wants to be kept consistent, do\neverything you can to avoid splitting it up in the first place. Try really\nhard. If you really need to go ahead with the split, think about moving from a\npurely technical view of the process (e.g., a database transaction) and\nactually create a concrete concept to represent the transaction itself.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"报表reporting\"\u003e报表（Reporting）\u003c/h3\u003e\n\n\u003cp\u003e将位于一个或多个地方的数据集中到一起，生成报表。\u003c/p\u003e\n\n\u003ch3 id=\"模型-1数据库复制\"\u003e模型 1：数据库复制\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-12.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-12 Standard read replication\u003c/p\u003e\n\n\u003cp\u003e典型的报表数据库是独立的，定期从主数据库同步。\u003c/p\u003e\n\n\u003cp\u003e优点：简单直接。\u003c/p\u003e\n\n\u003cp\u003e缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e主数据库的表结构共享给力报表系统，二者产生了耦合。主数据库的修改可能会 break\n报表系统；而且，表结构修改阻力更大，因为对接的团队肯定不想总是跟着改\u003c/li\u003e\n  \u003cli\u003e数据库优化手段会更受限：到底是该为主业务进行优化，还是该对报表系统进行优化，\n二者可能是冲突的\u003c/li\u003e\n  \u003cli\u003e报表系统和主业务绑定到了一种数据库，无法用到比较新的、可能更合适的数据库，例\n如非关系型数据库\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"模型-2pull-模型\"\u003e模型 2：Pull 模型\u003c/h3\u003e\n\n\u003cp\u003e通过服务调用的方式主动去拉取所需的数据。\u003c/p\u003e\n\n\u003cp\u003e存在的问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e服务方的 API 不是为报表系统设计的，取一份想要的数据得调用多次 API\u003c/li\u003e\n  \u003cli\u003e取回来的数据量可能很大，而且还不能做缓存，因为原始数据可能会被修改，导致缓存\n失效\u003c/li\u003e\n  \u003cli\u003e数据量太大，API 太慢，解决方式：提供批量 API\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e批量 API 参考流程：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e客户端调用批量 API\u003c/li\u003e\n  \u003cli\u003e服务端返回 202：请求已接受，但还没开始处理\u003c/li\u003e\n  \u003cli\u003e客户端轮询状态\u003c/li\u003e\n  \u003cli\u003e服务端返回 201：已创建\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ePull 模型的缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e请求量很大时，HTTP 头开销比较大\u003c/li\u003e\n  \u003cli\u003e服务端可能还要专门为报表系统提供 API\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"模型-3push-模型\"\u003e模型 3：Push 模型\u003c/h3\u003e\n\n\u003cp\u003e主动向报表系统推送数据。\u003c/p\u003e\n\n\u003cp\u003e一个单独的程序从数据源拉取数据，存储到报表系统的数据库。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-13.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-13 Using a data pump to periodically push data to a central reporting database\u003c/p\u003e\n\n\u003cp\u003e效果如下，每个模块也可有自己独立的报表数据库 schema：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-14.png\" width=\"35%\" height=\"35%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-14 Utilizing materialized views to form a single monolithic reporting schema\u003c/p\u003e\n\n\u003ch3 id=\"模型-4事件或消息队列模型\"\u003e模型 4：事件或消息队列模型\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/5-15.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 5-15 An event data pump using state change events to populate a reporting database\u003c/p\u003e\n\n\u003cp\u003e优点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e比定时同步的方式时效性更高\u003c/li\u003e\n  \u003cli\u003e耦合更低\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e缺点：当数据量非常大时，效率没有基于数据库层的 push 模型高。\u003c/p\u003e\n\n\u003ch3 id=\"模型-5备份数据模型\"\u003e模型 5：备份数据模型\u003c/h3\u003e\n\n\u003cp\u003e和数据库复制类似，但复制的是文件或其他元数据，存储在对象存储系统中，再用 Hadoop\n之类的平台读取文件进行分析。适用于超大规模系统的报表。\u003c/p\u003e\n\n\u003ch3 id=\"实时性\"\u003e实时性\u003c/h3\u003e\n\n\u003cp\u003e不同类型的报表对实时性的要求是不同的。\u003c/p\u003e\n\n\u003ch2 id=\"6-部署deployment\"\u003e6 部署（Deployment）\u003c/h2\u003e\n\n\u003ch3 id=\"持续集成简史\"\u003e持续集成简史\u003c/h3\u003e\n\n\u003cp\u003eWith CI, the core goal is to keep everyone in sync with each other, which we\nachieve by\nmaking sure that newly checked-in code properly integrates with existing code.\nTo do this,\na CI server detects that the code has been committed, checks it out, and carries\nout some\nverification like making sure the code compiles and that tests pass.\u003c/p\u003e\n\n\u003ch3 id=\"持续发布\"\u003e持续发布\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/6-2.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 6-2 A standard release process modeled as a build pipeline\u003c/p\u003e\n\n\u003ch2 id=\"7-测试\"\u003e7 测试\u003c/h2\u003e\n\n\u003ch2 id=\"8-监控\"\u003e8 监控\u003c/h2\u003e\n\n\u003ch2 id=\"9-安全\"\u003e9 安全\u003c/h2\u003e\n\n\u003ch2 id=\"10-康威定律和系统设计\"\u003e10 康威定律和系统设计\u003c/h2\u003e\n\n\u003cp\u003eMelvin Conway, 1968：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eAny organization that designs a system will inevitably produce a design whose\nstructure is a copy of the organization’s communication structure.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eEric S. Raymond，\u003cstrong\u003e\u003cem\u003eThe New Hacker’s Dictionary\u003c/em\u003e\u003c/strong\u003e (MIT Press)：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIf you have four groups working on a compiler, you’ll get a 4-pass compiler.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e讽刺的是，康威的论文提交给《哈佛商业评论》的时候被拒了，理由是这个定理未经证明。\u003c/p\u003e\n\n\u003ch3 id=\"反面教材windows-vista\"\u003e反面教材：Windows Vista\u003c/h3\u003e\n\n\u003ch3 id=\"证明教材amazon-和-netflix\"\u003e证明教材：Amazon 和 Netflix\u003c/h3\u003e\n\n\u003cp\u003eAmazon 很早就意识到了每个团队负责自己的系统的整个生命周期的重要性。另外，它也意\n识到小团队比大团队运转起来更加高效。\u003c/p\u003e\n\n\u003cp\u003e这产生了著名的 \u003cstrong\u003etwo-pizza team\u003c/strong\u003e：如果一个团队两个披萨还吃不饱，那这个团队就该\n拆分了。\u003c/p\u003e\n\n\u003cp\u003eNetflix 也是从一开始就规划为小的、独立的团队。\u003c/p\u003e\n\n\u003ch2 id=\"11-大规模微服务\"\u003e11 大规模微服务\u003c/h2\u003e\n\n\u003ch3 id=\"服务降级\"\u003e服务降级\u003c/h3\u003e\n\n\u003ch3 id=\"架构安全\"\u003e架构安全\u003c/h3\u003e\n\n\u003cp\u003e避免系统雪崩，级联崩溃。\u003c/p\u003e\n\n\u003ch3 id=\"措施\"\u003e措施\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e超时\u003c/li\u003e\n  \u003cli\u003e熔断\u003c/li\u003e\n  \u003cli\u003ebulkhead（防水仓），来自 \u003cstrong\u003e\u003cem\u003eRelease It!\u003c/em\u003e\u003c/strong\u003e 的概念，丢弃发生错误的部分，保持核\n心功能的正常\u003c/li\u003e\n  \u003cli\u003e隔离（isolation）：及时隔离发生故障的下游应用，这样上游压力就会减轻\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e回源的系统，需要考虑到极端情况下全部 miss 时，所有请求都将打到源节点，是否会发生\n雪崩。其中一种解决方式是：隐藏源站，miss 时直接返回 404，源站异步地将内容同步到\n缓存。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/11-7.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 11-7 Hiding the origin from the client and populating the cache asynchronously\u003c/p\u003e\n\n\u003cp\u003e这种方式只对一部分系统有参考意义，但它至少能在下游发生故障的时候，保护自己不受影\n响。\u003c/p\u003e\n\n\u003ch3 id=\"cap-极简笔记\"\u003eCAP 极简笔记\u003c/h3\u003e\n\n\u003cp\u003e三句话：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e三者无法同时满足\u003c/li\u003e\n  \u003cli\u003e无 P 不成分布式系统\u003c/li\u003e\n  \u003cli\u003e可选：CP 或 AP\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"12-总结\"\u003e12 总结\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/building-microservices-notes-zh/12-1.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图 12-1 Principles of microservices\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eChange is inevitable. Embrace it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cloudflare-arch-and-bpf-zh/\"\u003e\u003cspan\u003e« [译] Cloudflare 边缘网络架构：无处不在的 BPF（2019）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cilium-code-series/\"\u003e\u003cspan\u003eCilium Code Walk Through Series »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2019-06-15T00:00:00Z",
  "Author": "Arthur Chiao"
}