{
  "Source": "arthurchiao.art",
  "Title": "Life of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics",
  "Link": "https://arthurchiao.art/blog/cilium-life-of-a-packet-pod-to-service/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLife of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2020-09-12 | Last Update 2020-09-12\u003c/p\u003e\n  \n  \u003cblockquote\u003e\n  \u003cp\u003eNote: this post also provides a\n\u003ca href=\"/blog/cilium-life-of-a-packet-pod-to-service-zh/\"\u003eChinese version\u003c/a\u003e,\nbut may update less timely as this one.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#introduction\" id=\"markdown-toc-introduction\"\u003eIntroduction\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#problem-faced\" id=\"markdown-toc-problem-faced\"\u003eProblem faced\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#purpose-of-this-post\" id=\"markdown-toc-purpose-of-this-post\"\u003ePurpose of this post\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#environments-and-configurations\" id=\"markdown-toc-environments-and-configurations\"\u003eEnvironments and configurations\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#other-aspects\" id=\"markdown-toc-other-aspects\"\u003eOther aspects\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-1-pod1-eth0-accessing-a-service\" id=\"markdown-toc-step-1-pod1-eth0-accessing-a-service\"\u003eStep 1: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e: accessing a Service\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-accessing-serviceip\" id=\"markdown-toc-11-accessing-serviceip\"\u003e1.1 Accessing ServiceIP\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-determine-dst_mac-routing-side-pod1\" id=\"markdown-toc-12-determine-dst_mac-routing-side-pod1\"\u003e1.2 Determine \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e: routing side POD1\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-next-hop-further-digging\" id=\"markdown-toc-13-next-hop-further-digging\"\u003e1.3 Next hop: further digging\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-2-pod1-lxc-device-pod1-egress-bpf-processing\" id=\"markdown-toc-step-2-pod1-lxc-device-pod1-egress-bpf-processing\"\u003eStep 2: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc\u003c/code\u003e device: POD1 egress BPF processing\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-check-the-loaded-bpf-program\" id=\"markdown-toc-21-check-the-loaded-bpf-program\"\u003e2.1 Check the loaded BPF program\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-from-container-bpf-code-analysis\" id=\"markdown-toc-22-from-container-bpf-code-analysis\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF Code Analysis\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-3-node1-kernel-routing\" id=\"markdown-toc-step-3-node1-kernel-routing\"\u003eStep 3: NODE1: kernel routing\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-4-node1-bondnic-egress-bpf-processing\" id=\"markdown-toc-step-4-node1-bondnic-egress-bpf-processing\"\u003eStep 4: NODE1 bond/NIC: egress BPF processing\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-check-the-loaded-bpf-program\" id=\"markdown-toc-41-check-the-loaded-bpf-program\"\u003e4.1 Check the loaded BPF program\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-to-netdev-bpf-code-analysis\" id=\"markdown-toc-42-to-netdev-bpf-code-analysis\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-netdev\u003c/code\u003e BPF Code Analysis\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-determine-src_mac-and-dst_mac\" id=\"markdown-toc-43-determine-src_mac-and-dst_mac\"\u003e4.3 Determine \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-5-data-center-network-routing\" id=\"markdown-toc-step-5-data-center-network-routing\"\u003eStep 5: Data center network: routing\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-6-node2-nicbond-ingress-bpf-processing\" id=\"markdown-toc-step-6-node2-nicbond-ingress-bpf-processing\"\u003eStep 6: NODE2 NIC/bond: ingress BPF processing\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-check-the-loaded-bpf-program\" id=\"markdown-toc-61-check-the-loaded-bpf-program\"\u003e6.1 Check the loaded BPF program\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-from-netdev-bpf-code-analysis\" id=\"markdown-toc-62-from-netdev-bpf-code-analysis\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-netdev\u003c/code\u003e BPF Code Analysis\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-7-pod4-ingress-bpf-processing\" id=\"markdown-toc-step-7-pod4-ingress-bpf-processing\"\u003eStep 7: POD4: ingress BPF processing\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-check-the-loaded-bpf-program\" id=\"markdown-toc-71-check-the-loaded-bpf-program\"\u003e7.1 Check the loaded BPF program\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-to-container-bpf-code-analysis\" id=\"markdown-toc-72-to-container-bpf-code-analysis\"\u003e7.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF Code Analysis\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-8-arrived-pod4s-eth0\" id=\"markdown-toc-step-8-arrived-pod4s-eth0\"\u003eStep 8: Arrived POD4’s \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#conclusion\" id=\"markdown-toc-conclusion\"\u003eConclusion\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#references\" id=\"markdown-toc-references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\n\u003ch2 id=\"problem-faced\"\u003eProblem faced\u003c/h2\u003e\n\n\u003cp\u003eTraditional network virtualization schemes mostly base on L2 forwarding (Linux\nbridge, Netfilter/iptables, OVS, etc) and/or L3 routing. Under these schemes,\n\u003cstrong\u003ethere is usually a very clear packet traversing path\u003c/strong\u003e, where you could\ndetermine the next hop of a packet with common network tools, and ended with a\npicture like following [1]:\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/neutron-ovs-path.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 1. Network topology inside an OpenStack compute node\u003c/p\u003e\n\n\u003cp\u003eWhen network problems are reported, such as one container not reaching another\none, you could capture the traffic along the forwarding path, and by combining\nrouting table and ARP table information, most of the time you could quickly\nlocate the problem.\u003c/p\u003e\n\n\u003cp\u003eUnfortunately, \u003cstrong\u003ethe topology is no longer that straight forward in Cilium\nnetworking solution\u003c/strong\u003e. For example, below is the network topology inside\nCilium-powered nodes with the default installation:\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/network-topology.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 2. Network topology inside an Cilium-powered k8s node\u003c/p\u003e\n\n\u003cp\u003eAs can be seen, network devices now seems to be “disconnected from each other”,\nthere are no bridging devices or normal forwarding/routing rules that connect\nthem. If capturing the traffic with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e, you may see that the traffic\ndisappears somewhere, then suddenly spring out in another place. \u003cstrong\u003eIt\nconfuses people how the traffic is transferred between the devices\u003c/strong\u003e, and to\nthe best we could guess is that it is done by BPF.\u003c/p\u003e\n\n\u003cp\u003eThis might be \u003cstrong\u003ethe biggest headache when you are trouble-shooting in Cilium\nclusters\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eThis post intends to alleviate this.\u003c/p\u003e\n\n\u003ch2 id=\"purpose-of-this-post\"\u003ePurpose of this post\u003c/h2\u003e\n\n\u003cp\u003eIn this post, we will \u003cstrong\u003eexplore or discover the detailed packet forwarding path\nin Cilium\u003c/strong\u003e with such an example: accesing a ServiceIP from a Pod on a node,\nwhere the backend Pods of the Service run on another node.\u003c/p\u003e\n\n\u003cp\u003eWe will achieve this goal by utilizing some commonly used Linux command line\ntools, and by analyzing the BPF source code in Cilium. Our final output will be\na topology picture like below:\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/pod-to-service-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 3. Traffic path of Pod-to-ServiceIP\u003c/p\u003e\n\n\u003cp\u003eReferences [2,3,5] also covered this topic, but they stay at a high-level.  We\nin this post will dig into the code level.  We \u003cstrong\u003estrongly suggest readers to\nfirst read [2,3] before continuing\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"environments-and-configurations\"\u003eEnvironments and configurations\u003c/h2\u003e\n\n\u003cp\u003eForwarding path in Cilium varies according to the different \u003cstrong\u003ecross-host\nnetworking solutions\u003c/strong\u003e you choose, we assume in this post that:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCross-host networking solution: \u003cstrong\u003edirect routing\u003c/strong\u003e (via BGP [4]).\u003c/li\u003e\n  \u003cli\u003eLinux kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4.19\u003c/code\u003e: Cilium/eBPF relies on this for the features we use.\u003c/li\u003e\n  \u003cli\u003eCilium \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.8.2\u003c/code\u003e, with configurations:\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekube-proxy-replacement=probe\u003c/code\u003e (default)\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eenable-ipv4=true\u003c/code\u003e (default)\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edatapath-mode=veth\u003c/code\u003e (default)\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eNo network policies (default).\u003c/li\u003e\n  \u003cli\u003eOn each node, there are two NICs and they are bonded, with node IP configured\non bond device.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eWith 2 \u0026amp; 3, all the hooking and modification jobs on the traffic will be\nfulfilled by BPF code, thus completely removes Netfilter/iptables dependency,\nthis is the so-called \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekube-proxy\u003c/code\u003e free\u003c/strong\u003e mode.\u003c/p\u003e\n\n\u003ch2 id=\"other-aspects\"\u003eOther aspects\u003c/h2\u003e\n\n\u003cp\u003eFor ease of illustration, we will use a host command \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensenter-ctn\u003c/code\u003e to\nexecute commands inside containers. It’s actually a simple wrapper over\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensenter\u003c/code\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e ~/.bashrc\n...\n\u003cspan class=\"k\"\u003efunction \u003c/span\u003ensenter-ctn \u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003eCTN\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003e$1\u003c/span\u003e  \u003cspan class=\"c\"\u003e# container ID or name\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003ePID\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"si\"\u003e$(\u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003edocker inspect \u003cspan class=\"nt\"\u003e--format\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;{{.State.Pid}}\u0026#34;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$CTN\u003c/span\u003e\u003cspan class=\"si\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003eshift \u003c/span\u003e1 \u003cspan class=\"c\"\u003e# remove the first argument, shift others to the left\u003c/span\u003e\n    nsenter \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e \u003cspan class=\"nv\"\u003e$PID\u003c/span\u003e \u003cspan class=\"nv\"\u003e$@\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis is equivalent to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edocker exec \u0026lt;ctn\u0026gt; \u0026lt;command\u0026gt;\u003c/code\u003e, for more info, refer to\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eman nseneter\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"step-1-pod1-eth0-accessing-a-service\"\u003eStep 1: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e: accessing a Service\u003c/h1\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eFollowing devices are no longer needed in our conditions, so we just omit them\nin the subsequent pictures:\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_net/cilium_host\u003c/code\u003e: no longer performs real actions in Kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4.19\u003c/code\u003e +\nCilium \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.8\u003c/code\u003e (and the community is considering to remove it).\u003c/li\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_vxlan\u003c/code\u003e: responsible for tunnel encap/decap, only appears in\ntunnel mode.\u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-1.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 1.\u003c/p\u003e\n\n\u003ch2 id=\"11-accessing-serviceip\"\u003e1.1 Accessing ServiceIP\u003c/h2\u003e\n\n\u003cp\u003eStart from accessing a ServiceIP from a Pod, such as:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# * -n: execute command in pod\u0026#39;s network namespace\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# * 10.224.1.1: ServiceIP\u003c/span\u003e\n\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn pod1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e curl 10.224.1.1:80\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ePackets will be sent out via \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e of POD1, we can determine that for these\npackets,\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_ip=POD1_IP\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac=POD1_MAC\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip=ServiceIP\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThese are easy to understand, but how about \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e?\u003c/p\u003e\n\n\u003ch2 id=\"12-determine-dst_mac-routing-side-pod1\"\u003e1.2 Determine \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e: routing side POD1\u003c/h2\u003e\n\n\u003cp\u003eFor determining \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e, we need to look at the \u003cstrong\u003erouting table and ARP table\ninside POD1\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eFirst, the routing table:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn pod1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e route \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.1.1.1        0.0.0.0         UG    0      0        0 eth0\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 eth0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis node manages PodCIDR \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.0/24\u003c/code\u003e, and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e is the gateway of this\nPodCIDR, configured on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_host\u003c/code\u003e device, you could verify this by executing\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifconfig cilium_host\u003c/code\u003e on the node. Cilium agent configures this\nautomatically on starting.\u003c/p\u003e\n\n\u003cp\u003eAccording to the above routing rules:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eAll packets targeted to gateway \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e will hit the second rule.\u003c/li\u003e\n  \u003cli\u003eAll other packets,  hit the first rule (default rule).\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eAs ServiceIP is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.224.1.1\u003c/code\u003e, it will hit the default rule, so \u003cstrong\u003ethe next hop is\ngateway \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e\u003c/strong\u003e.  Thus, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e should be the MAC corresponding to\nIP address \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e. This mapping info stores in ARP table.\u003c/p\u003e\n\n\u003cp\u003eNow \u003cstrong\u003echeck the ARP table inside POD1\u003c/strong\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e(NODE1) $ nsenter-ctn pod1 -n arp -n\nAddress               HWtype  HWaddress           Flags Mask            Iface\n10.1.1.1              ether   3e:74:f2:60:ab:9b   C                     eth0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eGot the MAC address we are looking for: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3e:74:f2:60:ab:9b\u003c/code\u003e. And\nnow, the packet could be sent out correctly with this MAC as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"13-next-hop-further-digging\"\u003e1.3 Next hop: further digging\u003c/h2\u003e\n\n\u003cp\u003eIf you search the above MAC address on NODE1, you will find that it actually\ndoesn’t belongs to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_host/cilium_net\u003c/code\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eifconfig cilium_host\ncilium_host: \u003cspan class=\"nv\"\u003eflags\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4291\u0026lt;UP,BROADCAST,RUNNING,NOARP,MULTICAST\u0026gt;  mtu 1500\n        inet 10.1.1.1  netmask 255.255.255.255  broadcast 0.0.0.0\n        ether 3e:7d:6b:32:44:8e  txqueuelen 1000  \u003cspan class=\"o\"\u003e(\u003c/span\u003eEthernet\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n        ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eand,\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003e3e:74:f2:60:ab:9b \u003cspan class=\"nt\"\u003e-B\u003c/span\u003e 1\n699: lxc00aa@if698: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 3e:74:f2:60:ab:9b brd ff:ff:ff:ff:ff:ff link-netnsid 4\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAs the output shows, it is the address of a device named \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e.\n\u003cstrong\u003eThe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e@\u003c/code\u003e symbol indicates that it is one end of a veth pair, with interface\nindex (ifindex) 699, and its peer end has an ifindex 698\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eWith this in mind, execute \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link\u003c/code\u003e inside POD1:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn pod1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e ip \u003cspan class=\"nb\"\u003elink\n\u003c/span\u003e698: eth0@if699: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 5e:d9:e5:0d:a1:ed brd ff:ff:ff:ff:ff:ff link-netnsid 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e inside POD1 is just the peer end of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eNow it’s clear: \u003cstrong\u003eCilium hijacks ARP table of POD1, forces the next hop to be\nthe peer end (host side) of the veth pair\u003c/strong\u003e. We will not go further\ninto the design, but just remind you that this is not a Cilium-specific\ndesign, there are also other networking solutions that behave so.\u003c/p\u003e\n\n\u003ch1 id=\"step-2-pod1-lxc-device-pod1-egress-bpf-processing\"\u003eStep 2: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc\u003c/code\u003e device: POD1 egress BPF processing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-2.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 2.\u003c/p\u003e\n\n\u003ch2 id=\"21-check-the-loaded-bpf-program\"\u003e2.1 Check the loaded BPF program\u003c/h2\u003e\n\n\u003cp\u003eThe packet sent out from \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e will be received by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e, so at the\n\u003cstrong\u003etc ingress hook\u003c/strong\u003e (rather than the egress hook), it can do filtering\nand processing on the packets sent out from POD1.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003ePOD1’s egress corresponds to lxc’s ingress.\u003c/li\u003e\n    \u003cli\u003ePOD1’s ingress corresponds to lxc’s egress.\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eNow check the loaded BPF programs at the tc ingress hook:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev lxc00aa ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_lxc.o:[from-container] direct-action not_in_hw tag 3855f578c6616972\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eas shown above, there is indeed a BPF program, \u003cstrong\u003eloaded at section\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e\u003c/strong\u003e.  The section label \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e is a \u003cstrong\u003eunique\nidentifier for this program\u003c/strong\u003e, we can easily find the program code in Cilium\nrepository by searching this identifier.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIn veth pair mode, you could also use the above tc command to list the loaded BPF\nprograms at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e’s ingress/egress hooks and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e’s egress hooking points, then\nyou will find that there are not any BPF programs at these places.\u003c/p\u003e\n\n  \u003cp\u003eThen the question is: \u003cstrong\u003ehow will Cilium perform ingress processing if there\nare no corresponding BPF programs\u003c/strong\u003e? We will reveal this later.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eNow let’s see what this BPF program will do.\u003c/p\u003e\n\n\u003ch2 id=\"22-from-container-bpf-code-analysis\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF Code Analysis\u003c/h2\u003e\n\n\u003cp\u003eAll BPF codes in Cilium lay at the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf/\u003c/code\u003e folder in Cilium source code\ntree. To avoid to be too lengthy, we will only show the call stacks of\neach BPF program.\u003c/p\u003e\n\n\u003cp\u003eNow let’s see the first one in this post,\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;from-container\u0026#34;)\nhandle_xgress                                                                   // bpf/bpf_lxc.c\n  |-validate_ethertype(skb, \u0026amp;proto)\n  |-switch (proto) {\n      case ETH_P_IP:\n          tail_handle_ipv4                                                     // bpf/bpf_lxc.c\n            |-handle_ipv4_from_lxc                                             // bpf/bpf_lxc.c\n                |-if dst is k8s Service\n                |    lb4_local()\n                |      |-ct_create4\n                |      |-lb4_lookup_backend\n                |      |-lb4_xlate\n                |\n                |-policy_can_egress4()\n                |\n                |-if tunnel\n                |     encap vxlan\n                | else // direct routing, pass to kernel stack (continue normal routing)\n                |     ipv4_l3()                       // dec TTL, set src/dst MAC\n                |     asm_set_seclabel_identity(skb); // set identity to skb\n                |-return TC_ACT_OK;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMain actions:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eValidate the packet (skb), and \u003cstrong\u003eextract L3 protocol\u003c/strong\u003e.\u003c/li\u003e\n  \u003cli\u003eIf L3 proto is IPv4, call \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e for further processing.\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e further calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4_from_lxc()\u003c/code\u003e, the latter performs:\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003eService load balancing\u003c/strong\u003e: select a proper Pod from backend list, we assume POD4 on NODE2 is selected.\u003c/li\u003e\n      \u003cli\u003eCreate or update \u003cstrong\u003econnection tracking\u003c/strong\u003e (CT or conntrack) record.\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003ePerform DNAT\u003c/strong\u003e, replace ServiceIP with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e for the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e field in IP header.\u003c/li\u003e\n      \u003cli\u003ePerform egress \u003cstrong\u003enetwork policy checking\u003c/strong\u003e.\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003ePerform encapsulation if in tunnel mode, or pass the packet to kernel\nstack if in direct routing mode.\u003c/strong\u003e, we will see the latter one.\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eBefore passing to kernel stack, it calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_l3()\u003c/code\u003e, which will set TTL、\nMAC addresses, etc:\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003eipv4_l3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__ctx_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eipv4_dec_ttl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n       \u003cspan class=\"n\"\u003eeth_store_saddr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eeth_store_daddr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eCTX_ACT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAt last, BPF program \u003cstrong\u003ereturns \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACK_OK\u003c/code\u003e\u003c/strong\u003e to the kernel, then this packet\n\u003cstrong\u003eenters kernel stack for further processing\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"step-3-node1-kernel-routing\"\u003eStep 3: NODE1: kernel routing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-3.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 3.\u003c/p\u003e\n\n\u003cp\u003eAfter the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF program finishes processing in Step 2, \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e\nnow has been the real Pod IP (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e)\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eNow the kernel will perform routing for this packet. \u003cstrong\u003eKernel acts as a software\nrouter now\u003c/strong\u003e: it looks up routing table with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e, then determines the next\nhop.\u003c/p\u003e\n\n\u003cp\u003eKernel routing table of NODE1:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eroute \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0\n10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAccording to above rules, \u003cstrong\u003eall packets with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e not fall into PodCIDR\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.0/24\u003c/code\u003e will hit the default rule\u003c/strong\u003e (first rule in the above), and will be\nsent out via \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e device:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eFor more information on kernel routing subsystem (L3 routing), neighbor\nsubsystem (L2 forwarding), I recommend the thick book \u003cstrong\u003e\u003cem\u003eUnderstanding Linux Network Internals\u003c/em\u003e\u003c/strong\u003e.\nThe book uses an older kernel, but the general routing \u0026amp; forwarding design\nstill validates.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSo in the next the packet will arrive at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e device.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNodes in this post are shipped with two NICs, bonded into \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e. For nodes with only one NIC, e.g. eth0,\nand the host IP is configured on this NIC, the packet will arrive eth0\ninstead of bond0 here. The devices which hold host IPs are called “native\ndevicess” in Cilium, you may encounter them when reading the doc or code.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-4-node1-bondnic-egress-bpf-processing\"\u003eStep 4: NODE1 bond/NIC: egress BPF processing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-4.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 4.\u003c/p\u003e\n\n\u003ch2 id=\"41-check-the-loaded-bpf-program\"\u003e4.1 Check the loaded BPF program\u003c/h2\u003e\n\n\u003cp\u003eCheck the BPF program loaded at the egress direction, this is the last tc BPF\nhook before the packet leaves this host:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev bond0 egress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_netdev_bond0.o:[to-netdev] direct-action not_in_hw tag b536a7e2744a4cdb\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eNext, let’s see the code implementation.\u003c/p\u003e\n\n\u003ch2 id=\"42-to-netdev-bpf-code-analysis\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-netdev\u003c/code\u003e BPF Code Analysis\u003c/h2\u003e\n\n\u003cp\u003eCall stack,\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;to-netdev\u0026#34;)\nto_netdev\n  |-policy_clear_mark\n  |-src_id = resolve_srcid_ipv4\n  |   |-lookup_ip4_remote_endpoint\n  |       |-ipcache_lookup4\n  |-ipv4_host_policy_egress(src_id)\n      |-policy_can_egress4\n      |-ret = ct_lookup4()\n      |-switch (ret) {\n          case CT_NEW        : ct_create4(); break;\n          case CT_ESTABLISHED:\n          case CT_RELATED    :\n          case CT_REPLY      :               break;\n          default            : ret = DROP;   break;\n        }\n        return ret;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eRoughly say, for our case, this BPF actually does nothing important, it just\nreturns \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACK_OK\u003c/code\u003e to let the packet go.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cstrong\u003eBPF programs on native devices are mainly used for North-South traffic\u003c/strong\u003e\nprocessing, namely, the external (in \u0026amp; out k8s cluster) traffic [3]. This\nincludes,\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eTraffic of LoadBalancer Services\u003c/li\u003e\n    \u003cli\u003eTraffic of ClusterIP Services with externalIPs\u003c/li\u003e\n    \u003cli\u003eTraffic of NodePort Services\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIn the next, kernel will lookup routing table and ARP table, and encap the L2\nheader for the packet.\u003c/p\u003e\n\n\u003ch2 id=\"43-determine-src_mac-and-dst_mac\"\u003e4.3 Determine \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003eSame as 1.2, we omit analysis process, just give the result:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0\n10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host\n\n$ arp -n\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n10.255.255.1             ether   00:00:5e:00:01:0c   C                     bond0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis packet will hit the default routing rule on the kernel routing table, so it\ndetermines,\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e’s MAC to be \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e\u003c/strong\u003e: MAC addresses are only meaningful inside a\nL2 network, the host and Pod are in different L2 networks (Cilium manages a\ndistinct CIDR/network), so the host will set its own MAC address as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e\nwhen forwarding this packet.\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003eThe MAC of host’s gateway (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.255.255.1\u003c/code\u003e) to be \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e\u003c/strong\u003e: next hop is\nhost’s gateway.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThen, the packet will be sent to the underlying data center network via bond0 (and physical NICS).\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eFor validation, you could capture the packets with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e and\nNICs, specify \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-e\u003c/code\u003e to print MAC addresses.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-5-data-center-network-routing\"\u003eStep 5: Data center network: routing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-4.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 5.\u003c/p\u003e\n\n\u003cp\u003eData center network \u003cstrong\u003eroutes packets based on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cp\u003eAs \u003cstrong\u003eNODE2 has already announced that \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePodCIDR2\u003c/code\u003e via BGP, and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e falls into\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePodCIDR2\u003c/code\u003e, so routers will pass this packet to NODE2\u003c/strong\u003e.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNetwork Virtualization: cross-host networking.\u003c/p\u003e\n\n  \u003cp\u003eFrom network layer’s perspective, there are two kinds of cross-host networking\nschemes:\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003eL2/LL2 (Large L2): run a \u003cstrong\u003esoftware switch or software bridge\u003c/strong\u003e inside each\nnode, typical: OpenStack Neutron+OVS [1].\u003c/li\u003e\n    \u003cli\u003eL3: run a \u003cstrong\u003esoftware router\u003c/strong\u003e inside each node (actually kernel itself is\nthe router), each node is a layer 3 node, typical: Cilium+BGP [4].\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003eOne big difference when trouble shooting:\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003eIn L2/LL2 network, \u003cstrong\u003esrc_mac stays unchanged during the entire path\u003c/strong\u003e, so\nreceiver sees the same src_mac as sender does; L2 forwarding only changes\ndst_mac;\u003c/li\u003e\n    \u003cli\u003eIn L3 network, both src_mac and dst_mac will be changed.\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003eUnderstanding this is important when you capture packets.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-6-node2-nicbond-ingress-bpf-processing\"\u003eStep 6: NODE2 NIC/bond: ingress BPF processing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-6.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 6.\u003c/p\u003e\n\n\u003cp\u003eTake Intel 10G ixgbe NIC as example, the calling stack starting from driver,\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e// kernel source tree, 4.19\n\nixgbe_poll\n |-ixgbe_clean_rx_irq\n    |-if support XDP offload\n    |    skb = ixgbe_run_xdp()\n    |-skb = ixgbe_construct_skb()\n    |-ixgbe_rx_skb\n       |-napi_gro_receive\n          |-napi_skb_finish(dev_gro_receive(skb))\n             |-netif_receive_skb_internal\n                |-if generic XDP\n                |  |-if do_xdp_generic() != XDP_PASS\n                |       return NET_RX_DROP\n                |-__netif_receive_skb(skb)\n                   |-__netif_receive_skb_one_core\n                      |-__netif_receive_skb_core(\u0026amp;pt_prev)\n                         |-for tap in taps:\n                         |   deliver_skb\n                         |-sch_handle_ingress                     // net/core/dev.c\n                            |-tcf_classify                        // net/sched/cls_api.c\n                               |-for tp in tps:\n                                   tp-\u0026gt;classify\n                                       |-cls_bpf_classify         // net/sched/cls_bpf.c\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMain steps:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eNIC received a packet.\u003c/li\u003e\n  \u003cli\u003eExecute XDP programs if there are XDP programs and NIC supports XDP offload (not our case here).\u003c/li\u003e\n  \u003cli\u003eCreate \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e.\u003c/li\u003e\n  \u003cli\u003eDo GRO, assemble fragemented packets.\u003c/li\u003e\n  \u003cli\u003eGeneric XDP processing: if NIC doesn’t support XDP offload, then XDP programs will be delayed to execute here from step 2.\u003c/li\u003e\n  \u003cli\u003eTap processing (not our case here).\u003c/li\u003e\n  \u003cli\u003eTC ingress processing, execute TC programs, and tc BPF program is one kind.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"61-check-the-loaded-bpf-program\"\u003e6.1 Check the loaded BPF program\u003c/h2\u003e\n\n\u003cp\u003eCheck the BPF program loaded at tc ingress hook:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev bond0 ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_netdev_bond0.o:[from-netdev] direct-action not_in_hw tag 75f509de02b2dfaf\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis piece of BPF will process \u003cstrong\u003ethe traffic coming into bond0 via physical NICs\u003c/strong\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"62-from-netdev-bpf-code-analysis\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-netdev\u003c/code\u003e BPF Code Analysis\u003c/h2\u003e\n\n\u003cp\u003eCall stack:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;from-netdev\u0026#34;)\nfrom_netdev\n  |-handle_netdev\n      |-validate_ethertype\n      |-do_netdev\n          |-identity = resolve_srcid_ipv4()                // extract src identity from ctx (skb)\n          |-ctx_store_meta(CB_SRC_IDENTITY, identity)      // save identity to ctx-\u0026gt;cb[CB_SRC_IDENTITY]\n          |-ep_tail_call(ctx, CILIUM_CALL_IPV4_FROM_LXC)   // tail call\n                               |\n |------------------------------\n |\n__section_tail(CILIUM_MAP_CALLS, CILIUM_CALL_IPV4_FROM_LXC)\ntail_handle_ipv4_from_netdev\n  |-tail_handle_ipv4\n      |-handle_ipv4\n          |-ep = lookup_ip4_endpoint()\n          |-ipv4_local_delivery(ctx, ep)\n              |-tail_call_dynamic(ctx, \u0026amp;POLICY_CALL_MAP, ep-\u0026gt;lxc_id);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMain logics:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eCall \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_netdev()\u003c/code\u003e to process \u003cstrong\u003ethe packets that will enter Cilium-managed network from host\u003c/strong\u003e,\n specific things including,\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003eExtract identity of this packet\u003c/strong\u003e (Cilium relies on identity for policy enforcement), and save it to packet’s metadata.\n        \u003cul\u003e\n          \u003cli\u003eIn direct routing mode, \u003cstrong\u003elookup identity from ipcache\u003c/strong\u003e (ipcache syncs itself with cilium’s kvstore).\u003c/li\u003e\n          \u003cli\u003eIn tunnel mode, identity is encapsulated in VxLAN header, so no need to lookup ipcache.\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003eTail call to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4_from_netdev()\u003c/code\u003e.\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4_from_netdev()\u003c/code\u003e calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e, the\nlatter further calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4()\u003c/code\u003e. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4()\u003c/code\u003e performs:\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003eDetermine the endpoint (POD4) that \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e relates to\u003c/strong\u003e.\u003c/li\u003e\n      \u003cli\u003eCall \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_local_delivery()\u003c/code\u003e, this method will \u003cstrong\u003etail call to endpoint’s BPF for Pod egress processing\u003c/strong\u003e.\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"step-7-pod4-ingress-bpf-processing\"\u003eStep 7: POD4: ingress BPF processing\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-7.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 7.\u003c/p\u003e\n\n\u003ch2 id=\"71-check-the-loaded-bpf-program\"\u003e7.1 Check the loaded BPF program\u003c/h2\u003e\n\n\u003cp\u003eJust as previous sections, let’s look at the egress hook of POD4’s \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00dd\u003c/code\u003e\n(this corresponding to POD4’s ingress),\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE2\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev lxc00dd egress\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003eNot any loaded BPF programs, why\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003eIt’s because in Cilium’s design (\u003cstrong\u003eperformance optimization\u003c/strong\u003e), the Pod ingress\nprogram is not triggered to execute (normal way), but directly via tail call\n(short-cut) from \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e’s BPF:\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003etail_call_dynamic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ePOLICY_CALL_MAP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003elxc_id\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eSo the ingress BPF needs not to be loaded to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00dd\u003c/code\u003e, and this also answers\nthe question we asked in section 2.1.\u003c/p\u003e\n\n\u003ch2 id=\"72-to-container-bpf-code-analysis\"\u003e7.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF Code Analysis\u003c/h2\u003e\n\n\u003cp\u003eThe tail-call calls to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF. Call stack:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;to-container\u0026#34;)\nhandle_to_container                                            //    bpf/bpf_lxc.c\n  |-inherit_identity_from_host(skb, \u0026amp;identity)                 // -\u0026gt; bpf/lib/identity.h\n  |-tail_ipv4_to_endpoint                                      //    bpf/bpf_lxc.c\n      |-ipv4_policy                                            //    bpf/bpf_lxc.c\n          |-policy_can_access_ingress                          //    bpf/lib/policy.h\n              |-__policy_can_access                            //    bpf/lib/policy.h\n                  |-if p = map_lookup_elem(l3l4_key); p     // L3+L4 policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(l4only_key); p   // L4-Only policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(l3only_key); p   // L3-Only policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(allowall_key); p // Allow-all policy\n                  |    return TC_ACK_OK\n                  |-return DROP_POLICY;                     // DROP\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThings done by this piece of BPF:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eExtract src identity of this packet, actually this info is already in packet’s\nmetadata.\u003c/li\u003e\n  \u003cli\u003eCall \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_ipv4_to_endpoint()\u003c/code\u003e, which will further call \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_policy()\u003c/code\u003e, the\nlatter performs POD4’s \u003cstrong\u003eingress network policy checking\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eIf the packet is not denied by network policy, it will be forwarded to\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00dd\u003c/code\u003e’s peer end, namely, POD4’s virtual NIC \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch1 id=\"step-8-arrived-pod4s-eth0\"\u003eStep 8: Arrived POD4’s \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/pod-to-service-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 8.\u003c/p\u003e\n\n\u003cp\u003eOn arriving \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e of POD4, it could be processed by upper layers.\u003c/p\u003e\n\n\u003ch1 id=\"conclusion\"\u003eConclusion\u003c/h1\u003e\n\n\u003cp\u003eThis post explored the end-to-end traversing path of Pod-to-Service traffic, and\nalso analyzed the BPF logics in each tc BPF hooking point.\u003c/p\u003e\n\n\u003cp\u003eFor space limit, we only showed the request path (POD1 to POD4). But, the reply\npath (POD4 to POD1) is quite similar, and we leave this to the readers who are\ninterested.\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/round-trip-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAt last, there is one important thing that needs to be noted: \u003cstrong\u003edo not make any\nperformance assumptions by comparing the number of hops between Cilium/eBPF and\nOpenStack/OVS topologies\u003c/strong\u003e as shown in this post, as “hop” in Cilium/eBPF is a\ndifferent concept in this post, mainly used for illustrating the processing\nsteps, and it is not comparable with a traditional “hop”. For example, Step 6 to\nStep 7 is just a function call, it costs almost nothing in terms of forwarding\nbenchmarks.\u003c/p\u003e\n\n\u003ch1 id=\"references\"\u003eReferences\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/ctrip-network-arch-evolution/\"\u003eCtrip Network Architecture Evolution in the Cloud Computing Era (2019)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://kccncna19.sched.com/event/Uae7/understanding-and-troubleshooting-the-ebpf-datapath-in-cilium-nathan-sweet-digitalocean\"\u003eUnderstanding (and Troubleshooting) the eBPF Datapath\nin Cilium\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://kccnceu20.sched.com/event/ZemQ/ebpf-and-kubernetes-little-helper-minions-for-scaling-microservices-daniel-borkmann-cilium\"\u003eeBPF and Kubernetes: Little Helper Minions for Scaling Microservices\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://docs.cilium.io/en/v1.8/gettingstarted/bird/\"\u003eUsing BIRD to run BGP — Cilium 1.8.3 documentation\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-network-topology-on-aws/\"\u003eCilium Network Topology and Traffic Path on AWS\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cilium-life-of-a-packet-pod-to-service-zh/\"\u003e\u003cspan\u003e« Life of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/lartc-qdisc-zh/\"\u003e\u003cspan\u003e[译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-09-12T00:00:00Z",
  "Author": "Arthur Chiao"
}