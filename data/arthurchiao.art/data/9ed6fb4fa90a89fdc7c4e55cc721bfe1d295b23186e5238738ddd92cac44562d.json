{
  "Source": "arthurchiao.art",
  "Title": "Linux 中断（IRQ/softirq）基础：原理及内核实现（2022）",
  "Link": "https://arthurchiao.art/blog/linux-irq-softirq-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux 中断（IRQ/softirq）基础：原理及内核实现（2022）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2022-07-02 | Last Update 2022-07-18\u003c/p\u003e\n  \n  \u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-什么是中断\" id=\"markdown-toc-1-什么是中断\"\u003e1 什么是中断？\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-硬中断\" id=\"markdown-toc-2-硬中断\"\u003e2 硬中断\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-中断处理流程\" id=\"markdown-toc-21-中断处理流程\"\u003e2.1 中断处理流程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-中断类型\" id=\"markdown-toc-22-中断类型\"\u003e2.2 中断类型\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#系统支持的最大硬中断数量\" id=\"markdown-toc-系统支持的最大硬中断数量\"\u003e系统支持的最大硬中断数量\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#msimessage-signaled-interrupts-msi-x\" id=\"markdown-toc-msimessage-signaled-interrupts-msi-x\"\u003eMSI（Message Signaled Interrupts）/ MSI-X\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-maskable-and-non-maskable可关闭和不可关闭中断\" id=\"markdown-toc-23-maskable-and-non-maskable可关闭和不可关闭中断\"\u003e2.3 Maskable and non-maskable（可关闭和不可关闭中断）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-问题执行足够快-vs-逻辑比较复杂\" id=\"markdown-toc-24-问题执行足够快-vs-逻辑比较复杂\"\u003e2.4 问题：执行足够快 vs 逻辑比较复杂\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-解决方式延后中断处理deferred-interrupt-handling\" id=\"markdown-toc-25-解决方式延后中断处理deferred-interrupt-handling\"\u003e2.5 解决方式：延后中断处理（deferred interrupt handling）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-软中断\" id=\"markdown-toc-3-软中断\"\u003e3 软中断\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-软中断子系统\" id=\"markdown-toc-31-软中断子系统\"\u003e3.1 软中断子系统\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-主处理\" id=\"markdown-toc-32-主处理\"\u003e3.2 主处理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-避免软中断占用过多-cpu\" id=\"markdown-toc-33-避免软中断占用过多-cpu\"\u003e3.3. 避免软中断占用过多 CPU\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-硬中断---软中断-调用栈\" id=\"markdown-toc-34-硬中断---软中断-调用栈\"\u003e3.4 硬中断 -\u0026gt; 软中断 调用栈\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-软中断触发执行的步骤\" id=\"markdown-toc-35-软中断触发执行的步骤\"\u003e3.5 软中断触发执行的步骤\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-三种推迟执行方式softirqtaskletworkqueue\" id=\"markdown-toc-4-三种推迟执行方式softirqtaskletworkqueue\"\u003e4 三种推迟执行方式（softirq/tasklet/workqueue）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-softirq静态机制内核编译时确定\" id=\"markdown-toc-41-softirq静态机制内核编译时确定\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esoftirq\u003c/code\u003e：静态机制，内核编译时确定\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#内部组织\" id=\"markdown-toc-内部组织\"\u003e内部组织\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#触发唤醒softirq\" id=\"markdown-toc-触发唤醒softirq\"\u003e触发（唤醒）softirq\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-tasklet动态机制基于-softirq\" id=\"markdown-toc-42-tasklet动态机制基于-softirq\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etasklet\u003c/code\u003e：动态机制，基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esoftirq\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-workqueue动态机制运行在进程上下文\" id=\"markdown-toc-43-workqueue动态机制运行在进程上下文\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eworkqueue\u003c/code\u003e：动态机制，运行在进程上下文\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#使用场景\" id=\"markdown-toc-使用场景\"\u003e使用场景\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#结构体\" id=\"markdown-toc-结构体\"\u003e结构体\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-idle-process-与中断\" id=\"markdown-toc-5-idle-process-与中断\"\u003e5 idle process 与中断\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-为什么需要-idle-process\" id=\"markdown-toc-51-为什么需要-idle-process\"\u003e5.1 为什么需要 idle process\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-idle-process-实现\" id=\"markdown-toc-52-idle-process-实现\"\u003e5.2 idle process 实现\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e中断（IRQ），尤其是软中断（softirq）的重要使用场景之一是网络收发包，\n但并未唯一场景。本文整理 IRQ/softirq 的通用基础，这些东西和网络收发包没有直接关系，\n虽然整理本文的直接目的是为了更好地理解网络收发包。\u003c/p\u003e\n\n\u003ch1 id=\"1-什么是中断\"\u003e1 什么是中断？\u003c/h1\u003e\n\n\u003cp\u003eCPU 通过时分复用来处理很多任务，这其中包括一些硬件任务，例如磁盘读写、键盘输入，也包括一些软件任务，例如网络包处理。\n在任意时刻，一个 CPU 只能处理一个任务。\n当某个硬件或软件任务此刻没有执行，但它希望 CPU 来立即处理时，就会\u003cstrong\u003e\u003cmark\u003e给 CPU 发送一个中断请求\u003c/mark\u003e\u003c/strong\u003e ——\n\u003cstrong\u003e\u003cmark\u003e希望 CPU 停下手头的工作，优先服务“我”\u003c/mark\u003e\u003c/strong\u003e。\n中断是以事件的方式通知 CPU 的，因此我们常看到 “XX 条件下会触发 XX 中断事件” 的表述。\u003c/p\u003e\n\n\u003cp\u003e两种类型：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e外部或硬件产生的中断，例如键盘按键。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e软件产生的中断，异常事件产生的中断，例如\u003cstrong\u003e\u003cmark\u003e除以零\u003c/mark\u003e\u003c/strong\u003e 。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e管理中断的设备：Advanced Programmable Interrupt Controller（APIC，高级可编程中断控制器）。\u003c/p\u003e\n\n\u003ch1 id=\"2-硬中断\"\u003e2 硬中断\u003c/h1\u003e\n\n\u003ch2 id=\"21-中断处理流程\"\u003e2.1 中断处理流程\u003c/h2\u003e\n\n\u003cp\u003e中断随时可能发生，发生之后必须马上得到处理。收到中断事件后的处理流程：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e抢占当前任务\u003c/mark\u003e\u003c/strong\u003e：内核必须暂停正在执行的进程；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e执行中断处理函数\u003c/mark\u003e\u003c/strong\u003e（ISR）：找到对应的中断处理函数，将 CPU 交给它（执行）；\u003c/p\u003e\n\n    \u003cp\u003eISR 位于 Interrupt Vector table，这个 table 位于内存中的固定地址。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e中断处理完成之后\u003c/mark\u003e\u003c/strong\u003e：第 1 步被抢占的进程恢复执行。\u003c/p\u003e\n\n    \u003cp\u003e在中断处理完成之后，处理器恢复执行被中断的进程（resume the interrupted process）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"22-中断类型\"\u003e2.2 中断类型\u003c/h2\u003e\n\n\u003cp\u003e在内核中，发生异常（exception）之后一般是给被中断的进程发送一个 Unix 信号，以此来唤醒它，这也是为什么内核能如此迅速地处理异常的原因。\u003c/p\u003e\n\n\u003cp\u003e但对于外部硬件中断（external hardware interrupts）这种方式是不行的，\n\u003cstrong\u003e\u003cmark\u003e外部中断处理取决于中断的类型\u003c/mark\u003e\u003c/strong\u003e（type）：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eI/O interrupts（\u003cstrong\u003e\u003cmark\u003eIO 中断\u003c/mark\u003e\u003c/strong\u003e）;\u003c/p\u003e\n\n    \u003cp\u003e例如 PCI 总线架构，多个设备共享相同的 IRQ line。必须处理非常快。内核典型处理过程：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e将 IRQ 值和寄存器状态保存到内核栈上（kernel stack）；\u003c/li\u003e\n      \u003cli\u003e给负责这个 IRQ line 的硬件控制器发送一个确认通知；\u003c/li\u003e\n      \u003cli\u003e执行与这个设备相关的中断服务例程（ISR）；\u003c/li\u003e\n      \u003cli\u003e恢复寄存器状态，从中断中返回。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003eTimer interrupts（\u003cstrong\u003e\u003cmark\u003e定时器中断\u003c/mark\u003e\u003c/strong\u003e）;\u003c/li\u003e\n  \u003cli\u003eInterprocessor interrupts（IPI，\u003cstrong\u003e\u003cmark\u003e进程间中断\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"系统支持的最大硬中断数量\"\u003e系统支持的最大硬中断数量\u003c/h3\u003e\n\n\u003cp\u003e查看系统支持的\u003cstrong\u003e\u003cmark\u003e最大硬中断数量\u003c/mark\u003e\u003c/strong\u003e（与编译参数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFIG_X86_IO_APIC\u003c/code\u003e 有关）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edmesg | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eNR_IRQS\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e    0.146022] NR_IRQS: 524544, nr_irqs: 1624, preallocated irqs: 16\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中有 16 个是预分配的 IRQs。\u003c/p\u003e\n\n\u003ch3 id=\"msimessage-signaled-interrupts-msi-x\"\u003eMSI（Message Signaled Interrupts）/ MSI-X\u003c/h3\u003e\n\n\u003cp\u003e除了预分配中断，\n还有另一种称为 \u003ca href=\"https://en.wikipedia.org/wiki/Message_Signaled_Interrupts\"\u003eMessage Signaled Interrupts\u003c/a\u003e\n的中断，位于 \u003cstrong\u003e\u003cmark\u003ePCI 系统\u003c/mark\u003e\u003c/strong\u003e中。\u003c/p\u003e\n\n\u003cp\u003e相比于分配一个固定的中断号，它允许设备在特定的内存地址（particular address of\nRAM, in fact, the display on the Local APIC）记录消息（message）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eMSI 支持每个设备能分配 1, 2, 4, 8, 16 or 32 个中断，\u003c/li\u003e\n  \u003cli\u003eMSI-X 支持每个设备分配多达 2048 个中断。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e内核函数 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003erequest_irq()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 注册一个中断处理函数，并启用给定的中断线（enables a given interrupt line）。\u003c/p\u003e\n\n\u003ch2 id=\"23-maskable-and-non-maskable可关闭和不可关闭中断\"\u003e2.3 Maskable and non-maskable（可关闭和不可关闭中断）\u003c/h2\u003e\n\n\u003cp\u003eMaskable interrupts 在 x64_64 上可以用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003esti/cli\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n两个指令来屏蔽（关闭）和恢复：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003enative_irq_disable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003easm\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;cli\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;memory\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 清除 IF 标志位\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003enative_irq_enable\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003easm\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;sti\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;memory\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 设置 IF 标志位\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在屏蔽期间，这种类型的中断不会再触发新的中断事件。\n\u003cstrong\u003e\u003cmark\u003e大部分 IRQ 都属于这种类型。例子：网卡的收发包硬件中断\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eNon-maskable interrupts\u003c/mark\u003e\u003c/strong\u003e 不可屏蔽，所以在效果上属于\u003cstrong\u003e\u003cmark\u003e更紧急的类型\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"24-问题执行足够快-vs-逻辑比较复杂\"\u003e2.4 问题：执行足够快 vs 逻辑比较复杂\u003c/h2\u003e\n\n\u003cp\u003eIRQ handler 的两个特点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e执行要非常快，否则会导致事件（和数据）丢失；\u003c/li\u003e\n  \u003cli\u003e需要做的事情可能非常多，逻辑很复杂，例如收包\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这里就有了内在矛盾。\u003c/p\u003e\n\n\u003ch2 id=\"25-解决方式延后中断处理deferred-interrupt-handling\"\u003e2.5 解决方式：延后中断处理（deferred interrupt handling）\u003c/h2\u003e\n\n\u003cp\u003e传统上，解决这个内在矛盾的方式是将中断处理分为两部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003etop half\u003c/li\u003e\n  \u003cli\u003ebottom half\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这种方式称为中断的\u003cstrong\u003e\u003cmark\u003e推迟处理或延后处理\u003c/mark\u003e\u003c/strong\u003e。以前这是唯一的推迟方式，但现在不是了。\n现在已经是个通用术语，泛指各种推迟执行中断处理的方式。\n按这种方式，中断会分为两部分：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一部分：只进行最重要、\u003cstrong\u003e\u003cmark\u003e必须得在硬中断上下文中执行\u003c/mark\u003e\u003c/strong\u003e的部分；剩下的处理作为第二部分，放入一个待处理队列；\u003c/li\u003e\n  \u003cli\u003e第二部分：一般是调度器根据轻重缓急来调度执行，\u003cstrong\u003e\u003cmark\u003e不在硬中断上下文中执行\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eLinux 中的\u003cstrong\u003e\u003cmark\u003e三种推迟中断\u003c/mark\u003e\u003c/strong\u003e（deferred interrupts）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003esoftirq\u003c/li\u003e\n  \u003cli\u003etasklet\u003c/li\u003e\n  \u003cli\u003eworkqueue\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e后面会具体介绍。\u003c/p\u003e\n\n\u003ch1 id=\"3-软中断\"\u003e3 软中断\u003c/h1\u003e\n\n\u003ch2 id=\"31-软中断子系统\"\u003e3.1 软中断子系统\u003c/h2\u003e\n\n\u003cp\u003e软中断是一个内核子系统：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e每个 CPU 上会初始化一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eksoftirqd\u003c/code\u003e 内核线程，负责处理各种类型的 softirq 中断事件；\u003c/p\u003e\n\n    \u003cp\u003e用 cgroup ls 或者 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eps -ef\u003c/code\u003e 都能看到：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003esystemd-cgls \u003cspan class=\"nt\"\u003e-k\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003esoftirq \u003cspan class=\"c\"\u003e# -k: include kernel threads in the output\u003c/span\u003e\n ├─    12 \u003cspan class=\"o\"\u003e[\u003c/span\u003eksoftirqd/0]\n ├─    19 \u003cspan class=\"o\"\u003e[\u003c/span\u003eksoftirqd/1]\n ├─    24 \u003cspan class=\"o\"\u003e[\u003c/span\u003eksoftirqd/2]\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e软中断事件的 handler 提前注册到 softirq 子系统， 注册方式 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eopen_softirq(softirq_id, handler)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e例如，注册网卡收发包（RX/TX）软中断处理函数：\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c1\"\u003e// net/core/dev.c\u003c/span\u003e\n\n \u003cspan class=\"n\"\u003eopen_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eNET_TX_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enet_tx_action\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n \u003cspan class=\"n\"\u003eopen_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eNET_RX_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enet_rx_action\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e软中断占 CPU 的总开销\u003c/mark\u003e\u003c/strong\u003e：可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etop\u003c/code\u003e 查看，里面 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esi\u003c/code\u003e 字段就是系统的软中断开销（第三行倒数第二个指标）：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etop \u003cspan class=\"nt\"\u003e-n1\u003c/span\u003e | \u003cspan class=\"nb\"\u003ehead\u003c/span\u003e \u003cspan class=\"nt\"\u003e-n3\u003c/span\u003e\n top - 18:14:05 up 86 days, 23:45,  2 \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e,  load average: 5.01, 5.56, 6.26\n Tasks: 969 total,   2 running, 733 sleeping,   0 stopped,   2 zombie\n %Cpu\u003cspan class=\"o\"\u003e(\u003c/span\u003es\u003cspan class=\"o\"\u003e)\u003c/span\u003e: 13.9 us,  3.2 sy,  0.0 ni, 82.7 \u003cspan class=\"nb\"\u003eid\u003c/span\u003e,  0.0 wa,  0.0 hi,  0.1 si,  0.0 st\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-主处理\"\u003e3.2 主处理\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/kernel/smpboot.c\"\u003ekernel/smpboot.c\u003c/a\u003e\n类似于一个\u003cstrong\u003e\u003cmark\u003e事件驱动的循环\u003c/mark\u003e\u003c/strong\u003e，里面会调度到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eksoftirqd\u003c/code\u003e\n线程，执行 pending 的软中断。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eksoftirqd\u003c/code\u003e 里面会进一步调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__do_softirq\u003c/code\u003e，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e判断哪些 softirq 需要处理，\u003c/li\u003e\n  \u003cli\u003e执行 softirq handler\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"33-避免软中断占用过多-cpu\"\u003e3.3. 避免软中断占用过多 CPU\u003c/h2\u003e\n\n\u003cp\u003e软中断方式的潜在影响：推迟执行部分（比如 softirq）可能会占用较长的时间，在这个时间段内，\n用户空间线程只能等待。反映在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etop\u003c/code\u003e 里面，就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esi\u003c/code\u003e 占比。\u003c/p\u003e\n\n\u003cp\u003e不过 softirq 调度循环对此也有改进，通过 budget 机制来避免 softirq 占用过久的 CPU 时间。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejiffies\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eMAX_SOFTIRQ_TIME\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"n\"\u003erestart\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003esoftirq_bit\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003effs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epending\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eaction\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eh\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 这里面其实也有机制，避免 softirq 占用太多 CPU\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"n\"\u003epending\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003elocal_softirq_pending\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epending\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etime_before\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejiffies\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003eneed_resched\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e--\u003c/span\u003e\u003cspan class=\"n\"\u003emax_restart\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 避免 softirq 占用太多 CPU\u003c/span\u003e\n            \u003cspan class=\"k\"\u003egoto\u003c/span\u003e \u003cspan class=\"n\"\u003erestart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"34-硬中断---软中断-调用栈\"\u003e3.4 硬中断 -\u0026gt; 软中断 调用栈\u003c/h2\u003e\n\n\u003cp\u003e前面提到，softirq 是一种推迟中断处理机制，将 IRQ 的大部分处理逻辑推迟到了这里执行。\n\u003cstrong\u003e\u003cmark\u003e两条路径\u003c/mark\u003e\u003c/strong\u003e都会执行到 \u003cstrong\u003e\u003cmark\u003esoftirq 主处理逻辑\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__do_softirq()\u003c/code\u003e，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCPU 调度到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eksoftirqd\u003c/code\u003e 线程时，会执行到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__do_softirq()\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e每次硬中断（IRQ）handler 退出时： \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edo_IRQ() -\u0026gt; ...\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edo_IRQ()\u003c/code\u003e 是内核中最主要的 IRQ 处理方式。它执行结束时，会调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexiting_irq()\u003c/code\u003e，这会展开成 \n \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eirq_exit()\u003c/code\u003e。后者会检查是否有 pending 的 softirq，有的话就唤醒：\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c1\"\u003e// arch/x86/kernel/irq.c\u003c/span\u003e\n\n \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ein_interrupt\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003elocal_softirq_pending\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n     \u003cspan class=\"n\"\u003einvoke_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e进而会使 CPU 执行到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__do_softirq()\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"35-软中断触发执行的步骤\"\u003e3.5 软中断触发执行的步骤\u003c/h2\u003e\n\n\u003cp\u003e每个软中断会经过下面几个阶段：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eopen_softirq()\u003c/code\u003e 注册软中断处理函数；\u003c/li\u003e\n  \u003cli\u003e通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eraise_softirq()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 将一个软中断\n  \u003cstrong\u003e\u003cmark\u003e标记为 deferred interrupt\u003c/mark\u003e\u003c/strong\u003e，这会\u003cstrong\u003e\u003cmark\u003e唤醒该软中断（但还没有开始处理）\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e内核调度器\u003cstrong\u003e\u003cmark\u003e调度到 \u003ccode\u003eksoftirqd\u003c/code\u003e 内核线程\u003c/mark\u003e\u003c/strong\u003e时，会将所有等待处理的 deferred interrupt\n  （也就是 softirq）拿出来，执行对应的处理方法（softirq handler）；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e以收包软中断为例，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eIRQ handler 并不执行 NAPI，只是触发它\u003c/mark\u003e\u003c/strong\u003e，在里面会执行到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eraise NET_RX_SOFTIRQ\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e真正的执行在 softirq，里面会调用网卡的 poll() 方法收包；\u003c/li\u003e\n  \u003cli\u003eIRQ handler 中会调用 napi_schedule()，然后启动 NAPI poll()。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这里需要注意，虽然 IRQ handler 做的事情非常少，但是接下来\n\u003cstrong\u003e\u003cmark\u003e处理这个包的 softirq 和 IRQ 在同一个 CPU 运行\u003c/mark\u003e\u003c/strong\u003e。\n这就是说，如果大量的包都放到了同一个 RX queue，那虽然 IRQ 的开销可能并不多，\n但这个 CPU 仍然会非常繁忙，都花在 softirq 上了。\n解决方式：RPS。它并不会降低延迟，只是将包重新分发： RXQ -\u0026gt; CPU。\u003c/p\u003e\n\n\u003ch1 id=\"4-三种推迟执行方式softirqtaskletworkqueue\"\u003e4 三种推迟执行方式（softirq/tasklet/workqueue）\u003c/h1\u003e\n\n\u003cp\u003e前面提到，Linux 中的三种推迟中断执行的方式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003esoftirq\u003c/li\u003e\n  \u003cli\u003etasklet\u003c/li\u003e\n  \u003cli\u003eworkqueue\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e其中，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003esoftirq 和 tasklet 依赖软中断子系统，\u003cstrong\u003e\u003cmark\u003e运行在软中断上下文中\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003eworkqueue 不依赖软中断子系统，\u003cstrong\u003e\u003cmark\u003e运行在进程上下文中\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"41-softirq静态机制内核编译时确定\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esoftirq\u003c/code\u003e：静态机制，内核编译时确定\u003c/h2\u003e\n\n\u003cp\u003e前面已经看到， Linux 在每个 CPU 上会创建一个 ksoftirqd 内核线程。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003esoftirqs 是在 Linux 内核编译时就确定好的\u003c/mark\u003e\u003c/strong\u003e，例如网络收包对应的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNET_RX_SOFTIRQ\u003c/code\u003e 软中断。\n因此是一种\u003cstrong\u003e\u003cmark\u003e静态机制\u003c/mark\u003e\u003c/strong\u003e。如果想加一种新 softirq 类型，就需要修改并重新编译内核。\u003c/p\u003e\n\n\u003ch3 id=\"内部组织\"\u003e内部组织\u003c/h3\u003e\n\n\u003cp\u003e在内部是用一个数组（或称向量）来管理的，每个软中断号对应一个 softirq handler。\n数组和注册：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/softirq.c\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// NR_SOFTIRQS 是 enum softirq type 的最大值，在 5.10 中是 10，见下面\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esoftirq_action\u003c/span\u003e \u003cspan class=\"n\"\u003esoftirq_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003eNR_SOFTIRQS\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"n\"\u003e__cacheline_aligned_in_smp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eopen_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003enr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eaction\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esoftirq_action\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003esoftirq_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003enr\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eaction\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eaction\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e5.10 中所有类型的 softirq：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// include/linux/interrupt.h\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eHI_SOFTIRQ\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// tasklet\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eTIMER_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e         \u003cspan class=\"c1\"\u003e// timer\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNET_TX_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// networking\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNET_RX_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// networking\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eBLOCK_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e         \u003cspan class=\"c1\"\u003e// IO\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eIRQ_POLL_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eTASKLET_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// tasklet\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eSCHED_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e         \u003cspan class=\"c1\"\u003e// schedule\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eHRTIMER_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// timer\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eRCU_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e           \u003cspan class=\"c1\"\u003e// lock\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eNR_SOFTIRQS\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e也就是在 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecat /proc/softirqs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 看到的那些，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/softirqs\n                  CPU0     CPU1  ...    CPU46    CPU47\n          HI:        2        0  ...        0        1\n       TIMER:   443727   467971  ...   313696   270110\n      NET_TX:    57919    65998  ...    42287    54840\n      NET_RX:    28728  5262341  ...    81106    55244\n       BLOCK:      261     1564  ...   268986   463918\n    IRQ_POLL:        0        0  ...        0        0\n     TASKLET:       98      207  ...      129      122\n       SCHED:  1854427  1124268  ...  5154804  5332269\n     HRTIMER:    12224    68926  ...    25497    24272\n         RCU:  1469356   972856  ...  5961737  5917455\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"触发唤醒softirq\"\u003e触发（唤醒）softirq\u003c/h3\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003eraise_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003enr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003elocal_irq_save\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 关闭 IRQ\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eraise_softirq_irqoff\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enr\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 唤醒 ksoftirqd 线程（但执行不在这里，在 ksoftirqd 线程中）\u003c/span\u003e\n        \u003cspan class=\"n\"\u003elocal_irq_restore\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 打开 IRQ\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"n\"\u003ein_interrupt\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ewakeup_softirqd\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003ewakeup_softirqd\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etask_struct\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etsk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e__this_cpu_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eksoftirqd\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etsk\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003etsk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003estate\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003eTASK_RUNNING\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ewake_up_process\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etsk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以收包软中断为例，\nIRQ handler 并不执行 NAPI，只是触发它，在里面会执行到 raise NET_RX_SOFTIRQ；真正的执行在 softirq，里面会调用网卡的 poll() 方法收包。\nIRQ handler 中会调用 napi_schedule()，然后启动 NAPI poll()。\u003c/p\u003e\n\n\u003ch2 id=\"42-tasklet动态机制基于-softirq\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etasklet\u003c/code\u003e：动态机制，基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esoftirq\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e如果对内核源码有一定了解就会发现，\u003cstrong\u003e\u003cmark\u003esoftirq 用到的地方非常少\u003c/mark\u003e\u003c/strong\u003e，原因之一就是上面提到的，它是静态编译的，\n靠内置的 ksoftirqd 线程来调度内置的那 9 种 softirq。如果想新加一种，就得修改并重新编译内核，\n所以开发成本非常高。\u003c/p\u003e\n\n\u003cp\u003e实际上，实现推迟执行的\u003cstrong\u003e\u003cmark\u003e更常用方式 tasklet\u003c/mark\u003e\u003c/strong\u003e。它\u003cstrong\u003e\u003cmark\u003e构建在 softirq 机制之上\u003c/mark\u003e\u003c/strong\u003e，\n具体来说就是使用了上面提到的两种 softirq：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eHI_SOFTIRQ\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eTASKLET_SOFTIRQ\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e换句话说，tasklet 是可以\u003cstrong\u003e\u003cmark\u003e在运行时（runtime）创建和初始化的 softirq\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003e__init\u003c/span\u003e \u003cspan class=\"nf\"\u003esoftirq_init\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efor_each_possible_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eper_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003etail\u003c/span\u003e    \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eper_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eper_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_hi_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003etail\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eper_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_hi_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eopen_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eTASKLET_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003etasklet_action\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eopen_softirq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eHI_SOFTIRQ\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003etasklet_hi_action\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e内核软中断子系统初始化了两个 per-cpu 变量：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003etasklet_vec：\u003cstrong\u003e\u003cmark\u003e普通 tasklet\u003c/mark\u003e\u003c/strong\u003e，回调 tasklet_action()\u003c/li\u003e\n  \u003cli\u003etasklet_hi_vec：\u003cstrong\u003e\u003cmark\u003e高优先级 tasklet\u003c/mark\u003e\u003c/strong\u003e，回调 tasklet_hi_action()\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etasklet_struct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etasklet_struct\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003estate\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eatomic_t\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003etasklet 再执行针对 list 的循环：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003etasklet_action\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esoftirq_action\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elocal_irq_disable\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elist\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003e__this_cpu_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__this_cpu_write\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__this_cpu_write\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etail\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethis_cpu_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_vec\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"n\"\u003elocal_irq_enable\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elist\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etasklet_trylock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003etasklet_unlock\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003etasklet 在内核中的使用非常广泛。\n不过，后面又出现了第三种方式：workqueue。\u003c/p\u003e\n\n\u003ch2 id=\"43-workqueue动态机制运行在进程上下文\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eworkqueue\u003c/code\u003e：动态机制，运行在进程上下文\u003c/h2\u003e\n\n\u003cp\u003e这也是一种推迟执行机制，与 tasklet 有点类似，但也有很大不同。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003etasklet 是运行在 softirq 上下文中；\u003c/li\u003e\n  \u003cli\u003eworkqueue 运行在内核\u003cstrong\u003e\u003cmark\u003e进程上下文中\u003c/mark\u003e\u003c/strong\u003e； 这意味着 wq 不能像 tasklet 那样是原子的；\u003c/li\u003e\n  \u003cli\u003etasklet \u003cstrong\u003e\u003cmark\u003e永远运行在指定 CPU\u003c/mark\u003e\u003c/strong\u003e，这是初始化时就确定了的；\u003c/li\u003e\n  \u003cli\u003eworkqueue 默认行为也是这样，但是可以通过\u003cstrong\u003e\u003cmark\u003e配置修改\u003c/mark\u003e\u003c/strong\u003e这种行为。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"使用场景\"\u003e使用场景\u003c/h3\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e// Documentation/core-api/workqueue.rst：\n\nThere are many cases where an asynchronous process execution context\nis needed and the workqueue (wq) API is the most commonly used\nmechanism for such cases.\n\nWhen such an asynchronous execution context is needed, a work item\ndescribing which function to execute is put on a queue.  An\nindependent thread serves as the asynchronous execution context.  The\nqueue is called workqueue and the thread is called worker.\n\nWhile there are work items on the workqueue the worker executes the\nfunctions associated with the work items one after the other.  When\nthere is no work item left on the workqueue the worker becomes idle.\nWhen a new work item gets queued, the worker begins executing again.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e简单来说，workqueue 子系统提供了一个接口，通过这个接口可以\u003cstrong\u003e\u003cmark\u003e创建内核线程来处理从其他地方 enqueue 过来的任务\u003c/mark\u003e\u003c/strong\u003e。\n这些内核线程就称为 worker threads，\u003cstrong\u003e\u003cmark\u003e内置的 per-cpu worker threads\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esystemd-cgls \u003cspan class=\"nt\"\u003e-k\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ekworker\n├─    5 \u003cspan class=\"o\"\u003e[\u003c/span\u003ekworker/0:0H]\n├─   15 \u003cspan class=\"o\"\u003e[\u003c/span\u003ekworker/1:0H]\n├─   20 \u003cspan class=\"o\"\u003e[\u003c/span\u003ekworker/2:0H]\n├─   25 \u003cspan class=\"o\"\u003e[\u003c/span\u003ekworker/3:0H]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"结构体\"\u003e结构体\u003c/h3\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// include/linux/workqueue.h\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eworker_pool\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003espinlock_t\u003c/span\u003e              \u003cspan class=\"n\"\u003elock\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e                     \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e                     \u003cspan class=\"n\"\u003enode\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e                     \u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e            \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elist_head\u003c/span\u003e        \u003cspan class=\"n\"\u003eworklist\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e                     \u003cspan class=\"n\"\u003enr_workers\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ework_struct\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eatomic_long_t\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elist_head\u003c/span\u003e \u003cspan class=\"n\"\u003eentry\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ework_func_t\u003c/span\u003e \u003cspan class=\"n\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elockdep_map\u003c/span\u003e \u003cspan class=\"n\"\u003elockdep_map\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003ekworker 线程调度 workqueues，原理与 ksoftirqd 线程调度 softirqs 一样\u003c/mark\u003e\u003c/strong\u003e。\n但可以为 workqueue 创建新的线程，而 softirq 则不行。\u003c/p\u003e\n\n\u003ch1 id=\"5-idle-process-与中断\"\u003e5 idle process 与中断\u003c/h1\u003e\n\n\u003ch2 id=\"51-为什么需要-idle-process\"\u003e5.1 为什么需要 idle process\u003c/h2\u003e\n\n\u003cp\u003eidle process 用于 process accouting，以及降低能耗。\u003c/p\u003e\n\n\u003cp\u003e在设计上，调度器没有进程可调度时（例如所有进程都在等待输入），需要停下来，什么都不做，等待下一个中断把它唤醒。\n中断可能来自外设（例如网络包、磁盘读操作完成），也可能来自某个进程的定时器。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eLinux 调度器中，实现这种“什么都不做”的方式就是引入了 idle 进程\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e只有当\u003cstrong\u003e\u003cmark\u003e没有任何其他进程需要调度时，才会调度到 idle 进程\u003c/mark\u003e\u003c/strong\u003e（因此它的优先级是最低的）。\u003c/li\u003e\n  \u003cli\u003e在实现上，这个 idle 进程其实就是内核自身的一部分。\u003c/li\u003e\n  \u003cli\u003e当执行到 idle 进程时，它的行为就是\u003cstrong\u003e\u003cmark\u003e“等待中断事件”\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eLinux 会为\u003cstrong\u003e\u003cmark\u003e每个 CPU 创建一个 idle task\u003c/mark\u003e\u003c/strong\u003e（因为每个 CPU 上一个调度器），并固定在这个 CPU 上执行。\n当这个 CPU 上没有其他进程可执行时，就会调度到 idle 进程。它的开销就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etop\u003c/code\u003e 里面的\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eid\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 统计。\u003c/p\u003e\n\n\u003cp\u003e注意，这个 idle process 和 process 的 idle 状态是两个完全不相关的东西，后者指的是 process 在等待\n某个事件（例如 I/O 事件）。\u003c/p\u003e\n\n\u003ch2 id=\"52-idle-process-实现\"\u003e5.2 idle process 实现\u003c/h2\u003e\n\n\u003cp\u003eidle 如何实现视具体处理器和操作系统而定，但\u003cstrong\u003e\u003cmark\u003e目的都是一样的：减少能耗\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e最基本的实现方式：\u003ca href=\"https://en.wikipedia.org/wiki/HLT_%28x86_instruction%29\"\u003eHLT\u003c/a\u003e\n指令会让处理器停止执行（并进入节能模式），直到下一个中断触发它继续执行。\n不过有个模块肯定是要保持启用的：中断控制器（interrupt controller）。\n当外设触发中断时，中断控制器会通过特定针脚给 CPU 发送信号，唤醒处理器的执行。\n实际上现代处理器的行为要比这个复杂的多，但主要还是在节能和快速响应之间做出折中。\n有的 CPU 还会在 idle 期间降低处理器频率，以实现节能目标。\u003c/p\u003e\n\n\u003cp\u003eLinux 中 x86 的\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/arch/x86/kernel/process.c#L678\"\u003e实现\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eLinux Inside (online book), \u003ca href=\"https://0xax.gitbooks.io/linux-insides/content/Interrupts/linux-interrupts-9.html\"\u003eInterrupts and Interrupt Handling\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003estackexchange.com, \u003ca href=\"https://unix.stackexchange.com/questions/361245/what-does-an-idle-cpu-process-do\"\u003eWhat does an idle CPU process do?\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/k8s-is-about-apis-zh/\"\u003e\u003cspan\u003e« K8s 的核心是 API 而非容器（一）：从理论到 CRD 实践（2022）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/linux-net-stack-implementation-rx-zh/\"\u003e\u003cspan\u003eLinux 网络栈接收数据（RX）：原理及内核实现（2022） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-07-02T00:00:00Z",
  "Author": "Arthur Chiao"
}