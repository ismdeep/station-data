{
  "Source": "arthurchiao.art",
  "Title": "[译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽",
  "Link": "https://arthurchiao.art/blog/lartc-qdisc-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2020-10-08 | Last Update 2022-10-27\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文内容来自 \u003ca href=\"https://lartc.org/howto/index.html\"\u003eLinux Advanced Routing \u0026amp; Traffic Control HOWTO\u003c/a\u003e (2012) ，\n这是一份在线文档（小书），直译为\u003cstrong\u003e《Linux 高级路由与流量控制手册》\u003c/strong\u003e。\n本文翻译第九章 \u003ca href=\"https://lartc.org/howto/lartc.qdisc.html\"\u003eChapter 9. Queueing Disciplines for Bandwidth Management\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e这份文档年代略久，但 qdisc 部分整体并未过时，并且是我目前看过的内容最详实、\n可读性最好的 tc qdisc 教程。\u003c/p\u003e\n\n\u003cp\u003e另外，看到 [1,2] 中几张 qdisc 图画的非常不错，形象直观，易于理解，因此拿来插入到译文中。\n此外还加入了一些原文没有覆盖到的内容，例如 MQ、FQ、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efq_codel\u003c/code\u003e 等。\u003c/p\u003e\n\n\u003cp\u003etc/qdisc 是 Cilium/eBPF 依赖的最重要的网络基础设施之一。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#91-队列queues和排队规则queueing-disciplines\" id=\"markdown-toc-91-队列queues和排队规则queueing-disciplines\"\u003e9.1 队列（Queues）和排队规则（Queueing Disciplines）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#92-simple-classless-qdisc简单不分类排队规则\" id=\"markdown-toc-92-simple-classless-qdisc简单不分类排队规则\"\u003e9.2 Simple, classless qdisc（简单、不分类排队规则）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#921-pfifo_fast先入先出队列\" id=\"markdown-toc-921-pfifo_fast先入先出队列\"\u003e9.2.1 pfifo_fast（先入先出队列）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9211-参数与用法\" id=\"markdown-toc-9211-参数与用法\"\u003e9.2.1.1 参数与用法\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9212-举例译注\" id=\"markdown-toc-9212-举例译注\"\u003e9.2.1.2 举例（译注）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#922-tbftoken-bucket-filter令牌桶过滤器\" id=\"markdown-toc-922-tbftoken-bucket-filter令牌桶过滤器\"\u003e9.2.2 TBF（Token Bucket Filter，令牌桶过滤器）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9221-参数与用法\" id=\"markdown-toc-9221-参数与用法\"\u003e9.2.2.1 参数与用法\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9222-示例配置\" id=\"markdown-toc-9222-示例配置\"\u003e9.2.2.2 示例配置\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#923-sfqstochastic-fairness-queueing随机公平排队\" id=\"markdown-toc-923-sfqstochastic-fairness-queueing随机公平排队\"\u003e9.2.3 SFQ（Stochastic Fairness Queueing，随机公平排队）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9231-参数与用法\" id=\"markdown-toc-9231-参数与用法\"\u003e9.2.3.1 参数与用法\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9232-示例配置\" id=\"markdown-toc-9232-示例配置\"\u003e9.2.3.2 示例配置\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#924-fqfair-queue公平排队2013译注\" id=\"markdown-toc-924-fqfair-queue公平排队2013译注\"\u003e9.2.4 FQ（Fair Queue，公平排队，2013），译注\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#93-使用建议何时选择哪种队列\" id=\"markdown-toc-93-使用建议何时选择哪种队列\"\u003e9.3 使用建议：何时选择哪种队列？\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#94-术语\" id=\"markdown-toc-94-术语\"\u003e9.4 术语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#95-classful-qdisc分类别排队规则\" id=\"markdown-toc-95-classful-qdisc分类别排队规则\"\u003e9.5 Classful qdisc（分类别排队规则）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#951-classful-qdisc--class-中的-flow\" id=\"markdown-toc-951-classful-qdisc--class-中的-flow\"\u003e9.5.1 Classful qdisc \u0026amp; class 中的 flow\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#952-qdisc-大家庭roots-handles-siblings-and-parents\" id=\"markdown-toc-952-qdisc-大家庭roots-handles-siblings-and-parents\"\u003e9.5.2 qdisc 大家庭：roots, handles, siblings and parents\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9521-如何用过滤器filters-对流量进行分类\" id=\"markdown-toc-9521-如何用过滤器filters-对流量进行分类\"\u003e9.5.2.1 如何用过滤器（filters ）对流量进行分类\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9522-包是如何从-qdisc-出队dequeue然后交给硬件的\" id=\"markdown-toc-9522-包是如何从-qdisc-出队dequeue然后交给硬件的\"\u003e9.5.2.2 包是如何从 qdisc 出队（dequeue）然后交给硬件的\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#953-prio-qdisc优先级排队规则\" id=\"markdown-toc-953-prio-qdisc优先级排队规则\"\u003e9.5.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc（优先级排队规则）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9531-参数与用法\" id=\"markdown-toc-9531-参数与用法\"\u003e9.5.3.1 参数与用法\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9532-示例配置\" id=\"markdown-toc-9532-示例配置\"\u003e9.5.3.2 示例配置\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#954-著名的-cbqclass-based-queueingqdisc\" id=\"markdown-toc-954-著名的-cbqclass-based-queueingqdisc\"\u003e9.5.4 著名的 CBQ（Class Based Queueing）qdisc\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9541-cbq-shaping-详解\" id=\"markdown-toc-9541-cbq-shaping-详解\"\u003e9.5.4.1 CBQ shaping 详解\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9542-cbq-classful-behaviour\" id=\"markdown-toc-9542-cbq-classful-behaviour\"\u003e9.5.4.2 CBQ classful behaviour\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9543-决定-link-sharing--borrowing-的-cbq-参数\" id=\"markdown-toc-9543-决定-link-sharing--borrowing-的-cbq-参数\"\u003e9.5.4.3 决定 link sharing \u0026amp; borrowing 的 CBQ 参数\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#9544-示例配置\" id=\"markdown-toc-9544-示例配置\"\u003e9.5.4.4 示例配置\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#9545-cbq-其他参数split--defmap\" id=\"markdown-toc-9545-cbq-其他参数split--defmap\"\u003e9.5.4.5 CBQ 其他参数：split \u0026amp; defmap\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#955-htbhierarchical-token-bucket层级令牌桶\" id=\"markdown-toc-955-htbhierarchical-token-bucket层级令牌桶\"\u003e9.5.5 HTB（Hierarchical Token Bucket，层级令牌桶）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#9551-示例配置\" id=\"markdown-toc-9551-示例配置\"\u003e9.5.5.1 示例配置\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#956-fq_codelfair-queuing-controlled-delay延迟受控的公平排队译注\" id=\"markdown-toc-956-fq_codelfair-queuing-controlled-delay延迟受控的公平排队译注\"\u003e9.5.6 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efq_codel\u003c/code\u003e（Fair Queuing Controlled Delay，延迟受控的公平排队），译注\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#957-mq-multi-queue2009译注\" id=\"markdown-toc-957-mq-multi-queue2009译注\"\u003e9.5.7 MQ （Multi Queue，2009），译注\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#96-用过滤器对流量进行分类\" id=\"markdown-toc-96-用过滤器对流量进行分类\"\u003e9.6 用过滤器对流量进行分类\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#961-一些简单的流量过滤filtering示例\" id=\"markdown-toc-961-一些简单的流量过滤filtering示例\"\u003e9.6.1 一些简单的流量过滤（filtering）示例\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#962-常用-filtering-命令\" id=\"markdown-toc-962-常用-filtering-命令\"\u003e9.6.2 常用 filtering 命令\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#97-imqintermediate-queueing-device中转排队设备\" id=\"markdown-toc-97-imqintermediate-queueing-device中转排队设备\"\u003e9.7 IMQ（Intermediate queueing device，中转排队设备）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#971-示例配置\" id=\"markdown-toc-971-示例配置\"\u003e9.7.1 示例配置\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#扩展阅读译注\" id=\"markdown-toc-扩展阅读译注\"\u003e扩展阅读（译注）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e初识 Linux 的这些功能时，我感到无比震惊。Linux 的\u003cstrong\u003e\u003cmark\u003e带宽管理能力\u003c/mark\u003e\u003c/strong\u003e\n足以媲美许多高端、专用的带宽管理系统。\u003c/p\u003e\n\n\u003ch1 id=\"91-队列queues和排队规则queueing-disciplines\"\u003e9.1 队列（Queues）和排队规则（Queueing Disciplines）\u003c/h1\u003e\n\n\u003cp\u003e通过对数据包进行\u003cstrong\u003e排队\u003c/strong\u003e（queuing），我们可以决定数据的\u003cstrong\u003e发送\u003c/strong\u003e方式。这里非常\n重要的一点是：我们\u003cstrong\u003e\u003cmark\u003e只能对发送数据（transmit）进行整形\u003c/mark\u003e\u003c/strong\u003e（shape the data）。\n\u003cstrong\u003e互联网的工作机制\u003c/strong\u003e决定了\u003cstrong\u003e接收端无法直接控制发送端的行为\u003c/strong\u003e。这就像你家的（实体！）\n信箱一样：除非能联系到所有人（告诉他们未经同意不要寄信过来），\n否则你无法控制多少封信会飞到你的信箱里。\u003c/p\u003e\n\n\u003cp\u003e但与实际生活不同的是，互联网基于 TCP/IP 协议栈，这多少会带来一些帮助。TCP/IP\n无法提前知道两台主机之间的网络带宽，因此开始时它会以越来越快的速度发送数据（慢启\n动），直到开始出现丢包，这时它知道已经没有可用空间来存储这些待发送的包了，因此就会\n降低发送速度。TCP/IP 的实际工作过程比这个更智能一点，后面会再讨论。\u003c/p\u003e\n\n\u003cp\u003e这就好比你留下一半的信件在信箱里不取，期望别人看到这个状况后会停止给你寄新的信件。\n不幸的是，\u003cstrong\u003e这种方式只对互联网管用，对你的实体信箱无效\u003c/strong\u003e :-)\u003c/p\u003e\n\n\u003cp\u003e如果内网有一台路由器，你希望\u003cstrong\u003e限制某几台主机的下载速度\u003c/strong\u003e，那首先应该找到主机直连的\n路由器接口，然后在这些接口上做出向\u003cstrong\u003e\u003cmark\u003e流量整形\u003c/mark\u003e\u003c/strong\u003e（traffic shaping，整流）。\n此外，还要确保链路瓶颈（bottleneck of the link）也在你的控制范围内。例如，\n如果网卡是 100Mbps，但路由器的链路带宽是 256Kbps，那首先应该确保不要发送过多数据\n给路由器，因为它扛不住。否则，\u003cstrong\u003e链路控制和带宽整形的决定权就不在主机侧而到路由器侧了\u003c/strong\u003e。\n\u003cstrong\u003e\u003cmark\u003e要达到限速目的，需要对“发送队列”有完全的把控\u003c/mark\u003e\u003c/strong\u003e，\n这里的“发送队列”也就是\u003cstrong\u003e整条链路上最慢的一段\u003c/strong\u003e（slowest link in the chain）。\n幸运的是，大多数情况下这个条件都是能满足的。\u003c/p\u003e\n\n\u003ch1 id=\"92-simple-classless-qdisc简单不分类排队规则\"\u003e9.2 Simple, classless qdisc（简单、不分类排队规则）\u003c/h1\u003e\n\n\u003cp\u003e如前所述，\u003cstrong\u003e排队规则（queueing disciplines）改变了数据的发送方式\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e不分类（或称无类别）排队规则\u003c/strong\u003e（classless queueing disciplines）可以对某个网络\n接口（interface）上的所有流量进行\u003cstrong\u003e无差别整形\u003c/strong\u003e。包括对数据进行：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e重新调度（reschedule）\u003c/li\u003e\n  \u003cli\u003e增加延迟（delay）\u003c/li\u003e\n  \u003cli\u003e丢弃（drop）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e与 classless qdisc\n对应的是 classful qdisc，即\u003cstrong\u003e有类别（或称分类别）排队规则\u003c/strong\u003e，后者是\u003cstrong\u003e一个排队规则中又包含其他\n排队规则（qdisc-containing-qdiscs）\u003c/strong\u003e！先理解了 classless qdisc，才能理解\nclassful qdisc。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e目前最常用的 classless qdisc 是 pfifo_fast\u003c/mark\u003e\u003c/strong\u003e，这也是很多系统上的\n\u003cstrong\u003e\u003cmark\u003e默认排队规则\u003c/mark\u003e\u003c/strong\u003e。\n这也解释了为什么这些高级功能如此健壮：本质上来说，它们\n\u003cstrong\u003e\u003cmark\u003e不过是“另一个队列”而已\u003c/mark\u003e\u003c/strong\u003e（nothing more than ‘just another queue’）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"pfifo_fast\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"921-pfifo_fast先入先出队列\"\u003e9.2.1 pfifo_fast（先入先出队列）\u003c/h3\u003e\n\n\u003cp\u003e如名字所示，这是一个先入先出队列（First In, First Out），因此对所有包都一视同仁。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/pfifo_fast-qdisc.png\" width=\"40%\" height=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [1]\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003epfifo_fast 有三个所谓的 “band”\u003c/strong\u003e（可理解为三个队列），编号分别为 0、1、2：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e每个 band 上分别执行 FIFO 规则\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e如果 band 0 有数据，就不会处理 band 1\u003c/strong\u003e；同理，band 1 有数据时，不会去处理 band 2。\u003c/li\u003e\n  \u003cli\u003e内核会检查数据包的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eTOS\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 字段，\u003cstrong\u003e将“最小延迟”的包放到 band 0\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e不要将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast qdisc\u003c/code\u003e 与后面介绍的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO qdisc\u003c/code\u003e 混淆，后者是 classful 的！\n虽然二者行为类似，但 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e 是无类别的，这意味无法用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 命令向\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e 内添加另一个 qdisc\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"9211-参数与用法\"\u003e9.2.1.1 参数与用法\u003c/h4\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast qdisc\u003c/code\u003e 默认配置是写死的（the hardwired default），因此无法更改。\u003c/p\u003e\n\n\u003cp\u003e下面介绍这份写死的配置是什么样的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriomap\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriomap\u003c/code\u003e 决定了\u003cstrong\u003e如何将内核设置的 packet priority 映射到 band\u003c/strong\u003e。priority\n  位于包的 TOS 字段：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e     0     1     2     3     4     5     6     7\n  +-----+-----+-----+-----+-----+-----+-----+-----+\n  |                 |                       |     |\n  |   PRECEDENCE    |          TOS          | MBZ |\n  |                 |                       |     |\n  +-----+-----+-----+-----+-----+-----+-----+-----+\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eTOS 字段占用 4 个比特，各 bit 含义如下：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  Binary Decimcal  Meaning\n  -----------------------------------------\n  1000   8         Minimize delay (md)\n  0100   4         Maximize throughput (mt)\n  0010   2         Maximize reliability (mr)\n  0001   1         Minimize monetary cost (mmc)\n  0000   0         Normal Service\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etcpdump -vv\u003c/code\u003e 会打印包的 TOS 字段\u003c/mark\u003e\u003c/strong\u003e，其中的 TOS 值对应下面的第一列：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  TOS     Bits  Means                    Linux Priority    Band\n  ------------------------------------------------------------\n  0x0     0     Normal Service           0 Best Effort     1\n  0x2     1     Minimize Monetary Cost   1 Filler          2\n  0x4     2     Maximize Reliability     0 Best Effort     1\n  0x6     3     mmc+mr                   0 Best Effort     1\n  0x8     4     Maximize Throughput      2 Bulk            2\n  0xa     5     mmc+mt                   2 Bulk            2\n  0xc     6     mr+mt                    2 Bulk            2\n  0xe     7     mmc+mr+mt                2 Bulk            2\n  0x10    8     Minimize Delay           6 Interactive     0\n  0x12    9     mmc+md                   6 Interactive     0\n  0x14    10    mr+md                    6 Interactive     0\n  0x16    11    mmc+mr+md                6 Interactive     0\n  0x18    12    mt+md                    4 Int. Bulk       1\n  0x1a    13    mmc+mt+md                4 Int. Bulk       1\n  0x1c    14    mr+mt+md                 4 Int. Bulk       1\n  0x1e    15    mmc+mr+mt+md             4 Int. Bulk       1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e第二列是对应的十进制表示，第三列是对应的含义。例如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e15\u003c/code\u003e 表示这个包期望\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMinimal Monetary Cost\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMaximum Reliability\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMaximum Throughput\u003c/code\u003e +\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMinimum Delay\u003c/code\u003e。我把这样的包称为“荷兰包”（a ‘Dutch Packet’。荷兰人比较\n  节俭/抠门，译注）。\u003cstrong\u003e\u003cmark\u003e第四列是对应到 Linux 内核的优先级；最后一列是映射到的 band\u003c/mark\u003e\u003c/strong\u003e，\n  从命令行输出看，形式为：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e例如，priority 4 会映射到 band 1。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriomap\u003c/code\u003e 还能列出 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriority \u0026gt; 7\u003c/code\u003e 的那些\n  不是由 TOS 映射、而是由其他方式设置的优先级。例如，下表列出了\u003cstrong\u003e应\n  用（application）是如何设置它们的 TOS 字段的\u003c/strong\u003e，来自 RFC 1349（更多信息可阅\n  读全文），\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  TELNET                   1000           (minimize delay)\n  FTP     Control          1000           (minimize delay)\n          Data             0100           (maximize throughput)\n\n  TFTP                     1000           (minimize delay)\n\n  SMTP    Command phase    1000           (minimize delay)\n          DATA phase       0100           (maximize throughput)\n\n  DNS     UDP Query        1000           (minimize delay)\n          TCP Query        0000\n          Zone Transfer    0100           (maximize throughput)\n\n  NNTP                     0001           (minimize monetary cost)\n\n  ICMP    Errors           0000\n          Requests         0000 (mostly)\n          Responses        \u0026lt;same as request\u0026gt; (mostly)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etxqueuelen\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e发送队列长度，是一个网络接口（interface）参数，可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifconfig\u003c/code\u003e 命令设置。例\n  如，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifconfig eth0 txqueuelen 10\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 命令无法修改这个值。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"9212-举例译注\"\u003e9.2.1.2 举例（译注）\u003c/h4\u003e\n\n\u003cp\u003e下面是一台两个网卡的机器，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0 -\u0026gt; eth0/eth1\u003c/code\u003e active-standby 模式：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show dev bond0 ingress\nqdisc noqueue 0: root refcnt 2\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class show dev bond0\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev bond0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show dev eth0 ingress \u003cspan class=\"c\"\u003e# 注意 parent :\u0026lt;N\u0026gt; 是十六进制\u003c/span\u003e\nqdisc mq 0: root\nqdisc pfifo_fast 0: parent :28 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :27 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :26 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n...\nqdisc pfifo_fast 0: parent :b  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :a  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :9  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :8  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :7  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :6  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :5  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :4  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :3  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :2  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\nqdisc pfifo_fast 0: parent :1  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e qdisc show dev eth0 \u003cspan class=\"c\"\u003e# -s 打印详细信息\u003c/span\u003e\nqdisc mq 0: root\n Sent 24132018546 bytes 32764201 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 5644\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 5644\n\nqdisc pfifo_fast 0: parent :28 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 4761407 bytes 3607 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 2\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 2\n\nqdisc pfifo_fast 0: parent :27 bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 4810246 bytes 3996 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 1\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 1\n...\nqdisc pfifo_fast 0: parent :1  bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 2255173769 bytes 2847811 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 425\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 425\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e \u003cspan class=\"nt\"\u003e-p\u003c/span\u003e class show dev eth0 \u003cspan class=\"c\"\u003e# 注意 mq :\u0026lt;N\u0026gt; 是十六进制\u003c/span\u003e\nclass mq :1 root\n Sent 2277361407 bytes 2893507 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 426\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 426\nclass mq :2 root\n Sent 1840467735 bytes 2426113 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 466\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 466\n...\nclass mq :28 root\n Sent 4828555 bytes 3677 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 2\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 2\n\nclass mq :29 root  \u003cspan class=\"c\"\u003e# 从 0x29 开始往后的 sent/backlog 全是 0 了\u003c/span\u003e\n Sent 0 bytes 0 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 0\n...\nclass mq :47 root\n Sent 0 bytes 0 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0 requeues 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n backlog 0b 0p requeues 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev eth0\n\u003cspan class=\"c\"\u003e# nothing\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e拓扑：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e                                    1:                                     # root qdisc\n                                    |\n     +------------------------------+---------------------------------+\n     |    |    |    |    |    |     |    |   |    |    |    |    |    |\n     |    |    |    |    |    |     |    |   |    |    |    |    |    |\n    :1   :2    :3   :4   :5   :6   ...      :28   ...          :46   :47   # class (classifier)\n     |    |    |    |    |    |     |    |   |\n     |    |    |    |    |    |     |    |   |\n pfifo_fast           ...                 pfifo_fast                       # qdisc (pfifo_fast)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"922-tbftoken-bucket-filter令牌桶过滤器\"\u003e9.2.2 TBF（Token Bucket Filter，令牌桶过滤器）\u003c/h3\u003e\n\n\u003cp\u003eTBF 是一个简单 qdisc，对于\u003cstrong\u003e没有超过预设速率的流量直接透传\u003c/strong\u003e，但也能容忍\u003cstrong\u003e超过预\n设速率的短时抖动\u003c/strong\u003e（short bursts in excess of this rate）。\nTBF 非常简洁，对网络和处理器都很友好（network- and processor friendly）。\n\u003cstrong\u003e如果只是想实现接口限速，那 TBF 是第一选择。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/tbf-qdisc.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [1]\u003c/p\u003e\n\n\u003cp\u003eTBF 实现包括几部分：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eA buffer (bucket)：bucket 最重要的参数是它的大小，即\u003cstrong\u003e能容纳的 token 数量\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eTokens：token 会以特定的速率（specific rate）填充 bucket 缓冲区。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e当一个包到来时，会从 bucket 中拿到一个 token，然后收集这个包的信息，最后从\nbucket 中删除这个 token。\n这个算法和 token flow、data flow 结合起来，会产生三种可能的场景：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e数据速率 == token 速率\u003c/code\u003e：每个包都能找到一个对应的token，然后直接从队列出去，没有延时（delay）。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e数据速率 \u0026lt; token 速率\u003c/code\u003e：正常到来的数据都能及时发送出去，然后删除一个 token。\n由于 token 速率大于数据速率，\u003cstrong\u003e会产生 bucket 积压\u003c/strong\u003e，极端情况会将\nbucket 占满。\u003cstrong\u003e如果数据速率突然高于 token 速率，就可以消耗这些积压的 token\u003c/strong\u003e\n。因此积压的 token 有一个额外好处：\u003cstrong\u003e能够容忍短时数据速率抖动（burst）\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e数据速率 \u0026gt; token 速率\u003c/code\u003e：token 很快就会用完，然后 \u003cstrong\u003eTBF 会关闭（throttle ）一会\u003c/strong\u003e。这种\n情况称为 \u003cstrong\u003eoverlimit\u003c/strong\u003e（超过限制）。如果包还是源源不断地到来，就会产生丢包。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e第三种非常重要，因为它使我们能够\u003cstrong\u003e对数据可用的带宽进行整形\u003c/strong\u003e（administratively shape the bandwidth）。\u003c/p\u003e\n\n\u003cp\u003e积压的 token 使得超过限速的短时抖动数据仍然能发送，不会丢包，但持续的\noverload 会导致数据不断被 delay，然后被丢弃。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：在实际的实现中，\u003cstrong\u003etoken 是基于字节数，而不是包数\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4 id=\"9221-参数与用法\"\u003e9.2.2.1 参数与用法\u003c/h4\u003e\n\n\u003cp\u003e虽然通常情况下并不需要修改 TBF 配置参数，但我们还是可以看一下有哪些。\u003c/p\u003e\n\n\u003cp\u003e首先，永远可用的（always available）参数：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003elimit or latency\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003elimit：因等待可用 token 而被放入队列的字节数。\u003c/li\u003e\n      \u003cli\u003elatency：每个包在 TBF 中停留的最长时间。随后会基于 latency、bucket size、rate 和 peakrate（如果设置了）来计算 limit。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eburst/buffer/maxburst\u003c/p\u003e\n\n    \u003cp\u003ebucket 的大小，\u003cstrong\u003e单位是字节\u003c/strong\u003e。这是累积可用的 token 所支持的最大字节数（\n  maximum amount of bytes that tokens can be available for instantaneously）。总\n  体来说，\u003cstrong\u003e越大的整流速率（shaping rates）需要越大的缓冲区\u003c/strong\u003e。要在 Intel 网卡\n  上实现 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10Mbps\u003c/code\u003e 整流，你至少需要 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10KB\u003c/code\u003e 缓冲区。\u003c/p\u003e\n\n    \u003cp\u003e如果缓冲区太小，可能会丢包，因为 token 到来太快导致无法放入 bucket 中。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003empu\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e“零长度”的包占用的并不是零带宽\u003c/strong\u003e（A zero-sized packet does not use zero\n  bandwidth）。例如对于以太网，任何一个包的字节数不会少于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e64\u003c/code\u003e。\n  Minimum Packet Unit（最小包单元）决定了一个包所使用的最小 token 量（the\n  minimal token usage for a packet）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003erate\u003c/p\u003e\n\n    \u003cp\u003e速度旋钮（speedknob）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果当前 bucket 中有 token，并且没有禁止 bucket 的 token 删除动作，那默认情况下\n，它会\u003cstrong\u003e全速删除\u003c/strong\u003e。如果不期望这种行为，那可以设置下面几个参数：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003epeakrate\u003c/p\u003e\n\n    \u003cp\u003e如前所述，默认情况下，包到了之后只要有 token 就会被立即发送。这可能不是你期\n  望的，尤其当 bucket 很大的时候。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epeakrate\u003c/code\u003e 可指定 \u003cstrong\u003ebucket 发送数据的最快速度\u003c/strong\u003e。通常来说，这需要做的\n  就是：放行一个包 - 等待恰当的时长 - 放行下一个包。通过计算等待时长，最终实现\n  了 peakrate 效果。\u003c/p\u003e\n\n    \u003cp\u003e但实际中，由于 Unix 默认的 10ms 定时器精读限制，如果平均每个包 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10K bits\u003c/code\u003e ，\n  我们只能做到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1Mbps\u003c/code\u003e peakrate！（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10Kb/10ms = 1000Kbps = 1Mbps\u003c/code\u003e，译注）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003emtu/minburst\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1Mbit/s\u003c/code\u003e 的 peakrate 通常并不是很有用，因为实际中的带宽要远大于此。实现更高\n  peakrate 的一种方式是：每个 timer tick 发送多个包，在效果上就好像我们创建\n  了第二个 bucket！\u003c/p\u003e\n\n    \u003cp\u003e这第二个 bucket 默认只有一个包（defaults to a single packet），完全算不上一个 bucket。\u003c/p\u003e\n\n    \u003cp\u003e计算最大可能的 peakrate 时，用 MTU 乘以 100（更准确地说，乘以 HZ 数，例如\n  Intel 上是 100，Alpha 上是 1024）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"9222-示例配置\"\u003e9.2.2.2 示例配置\u003c/h4\u003e\n\n\u003cp\u003e一个简单但\u003cstrong\u003e非常\u003c/strong\u003e有用的配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev ppp0 root tbf rate 220kbit latency 50ms burst 1540\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e为什么说这个配置很有用呢？如果你有一个 queue 很大的网络设备，例如 DSL modem 或\ncable modem，而且用一个快速设备（例如以太网接口）连接到这个网络设备，那你会发现\n\u003cstrong\u003e大文件上传会严重影响实时交互\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这是因为上传的数据会被缓存到 modem 的 queue 里，而且缓存的数据量很大（以提升吞吐）\n。但这并不是期望的，你希望的是 queue 不要太大，这样能保证交换式数据的实时性，因\n此能在上传数据过程中同时做其他事情。\u003c/p\u003e\n\n\u003cp\u003e上面的配置\u003cstrong\u003e将发送速率降低到了 modem 不会对数据进行排队缓存（queuing）的水平\u003c/strong\u003e ——\n\u003cstrong\u003e此时 queue 前移到了 Linux 中\u003c/strong\u003e，而我们可以将它控制在一个合理的范围内。\u003c/p\u003e\n\n\u003cp\u003e这里的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e220kbit\u003c/code\u003e 是\u003cstrong\u003e上行链路的真实带宽乘以一个系数\u003c/strong\u003e，如果你的 modem 足\n够快，可以将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eburst\u003c/code\u003e 调大一些。\u003c/p\u003e\n\n\u003ch3 id=\"923-sfqstochastic-fairness-queueing随机公平排队\"\u003e9.2.3 SFQ（Stochastic Fairness Queueing，随机公平排队）\u003c/h3\u003e\n\n\u003cp\u003e随机公平排队（SFQ）是公平排队算法族的一个简单实现。相比其他算法，\u003cstrong\u003eSFQ 精准性要差\n一些，但它所需的计算量也更少\u003c/strong\u003e，而结果几乎是完全公平的（almost perfectly fair）。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/sfq-qdisc.png\" width=\"45%\" height=\"45%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [1]\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSFQ 中的核心是 conversion（会话）或 flow（流）\u003c/strong\u003e，大部分情况下都对应一个 TCP\nsession 或 UDP stream。\u003cstrong\u003e每个 conversion 对应一个 FIFO queue\u003c/strong\u003e，然后将流量分到不\n同 queue。\u003cmark\u003e发送数据时，按照 round robin 方式，每个 session 轮流发送\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种机制会产生非常公平的结果，不会因为单个 conversion 太大而把其他 conversion 的带宽都\n挤占掉。\u003cstrong\u003eSFQ 被称为“随机的”（stochastic）是因为它其实并没有为每个 session\n分配一个 queue\u003c/strong\u003e，而是用算法\u003cstrong\u003e将流量哈希到了一组有限的 queue\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e但这里会出现另一个问题：\u003cstrong\u003e多个 session 会可能会哈希到同一个 bucket（哈希槽），\n进而导致每个 session 的 quota 变小，达不到预期的整流带宽（或速度）\u003c/strong\u003e。为避免这个\n问题过于明显，\u003cstrong\u003eSFQ 会不断变换它使用的哈希算法\u003c/strong\u003e，最终任何两个会话冲突的持续时间\n都不会很长，只会有几秒钟。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eSFQ 只有在实际出向带宽已经非常饱和的情况下才有效\u003c/strong\u003e，这一点非常重要！否则，\nLinux 机器上就不存在 queue，因此也就没用效果。稍后会看到\u003cstrong\u003e如何将 SFQ 与其他\nqdisc 相结合来实现一般情况下的公平排队\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e说的更明确一点：\u003cstrong\u003e没用配套的整流配置的话，单纯在（连接 modem 的）以太网接口上配\n置SFQ 是毫无意义的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"9231-参数与用法\"\u003e9.2.3.1 参数与用法\u003c/h4\u003e\n\n\u003cp\u003eSFQ 大部分情况下默认参数就够了，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eperturb\u003c/p\u003e\n\n    \u003cp\u003e每隔多少\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e秒\u003c/code\u003e就重新配置哈希算法。如果这个参数没设，哈希算法就永远不会重新配置。\n  建议显式设置这个参数，不要为空。\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10s\u003c/code\u003e 可能是个不错的选择。\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003equantum\u003c/p\u003e\n\n    \u003cp\u003e在轮到下一个 queue 发送之前，当前 queue 允许出队（dequeue）的最大字节数。默认是\n  一个 MTU。不建议设置为小于 MTU 的值。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003elimit\u003c/p\u003e\n\n    \u003cp\u003eSFQ 能缓存的最大包数（超过这个阈值将导致丢包）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"9232-示例配置\"\u003e9.2.3.2 示例配置\u003c/h4\u003e\n\n\u003cp\u003e如果你有一个带宽已经饱和的网络设备，例如一个电话调制解调器（phone modem），那下\n面的配置有助于提高公平性：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev ppp0 root sfq perturb 10\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e qdisc \u003cspan class=\"nb\"\u003els\n\u003c/span\u003eqdisc sfq 800c: dev ppp0 quantum 1514b limit 128p flows 128/1024 perturb 10sec\n Sent 4812 bytes 62 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e解释：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e800c:\u003c/code\u003e：自动分配的 handle number（句柄编号）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elimit 128p\u003c/code\u003e：最大缓存 128 个包\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflows 128/1024\u003c/code\u003e：这个 sfq 有 1024 个哈希槽（hash buckets），其中 128 个当前有\n数据待发送。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperturb 10sec\u003c/code\u003e：每隔 10s 换一次哈希算法。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"924-fqfair-queue公平排队2013译注\"\u003e9.2.4 FQ（Fair Queue，公平排队，2013），译注\u003c/h2\u003e\n\n\u003cp\u003e详细介绍见 \u003ca href=\"https://github.com/torvalds/linux/commit/afe4fd062416b\"\u003eTODO\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"93-使用建议何时选择哪种队列\"\u003e9.3 使用建议：何时选择哪种队列？\u003c/h1\u003e\n\n\u003cp\u003e总结起来，上面几种都是简单的 qdisc，通过重排序（reordering）、降速（slowing）或\n丢包（dropping）来实现流量管理。\u003c/p\u003e\n\n\u003cp\u003e选择使用哪种 qdisc 时，下面几点可供参考。其中提到了几种在第 14\n章才会介绍到的 qdisc。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e单纯对出向流量限速\u003c/strong\u003e（slow down outgoing traffic），推荐\u003cstrong\u003e使用 TBF\u003c/strong\u003e。如果是\n针对大带宽进行限速，需要将 bucket 调大。\u003c/li\u003e\n  \u003cli\u003e如果带宽已经打满，想\u003cstrong\u003e确保带宽没有被任何单个 session 占据\u003c/strong\u003e，推荐\u003cstrong\u003e使用 SFQ\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eIf you have a big backbone and know what you are doing, consider Random Early Drop (see Advanced chapter).\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e对（不再转发的）入向流量整形，使用 Ingress Policer\u003c/strong\u003e。顺便说一句，入向整形称为 ‘policing’，而不是 ‘shaping’。\u003c/li\u003e\n  \u003cli\u003e对需要本机转发的流量整形，\n    \u003cul\u003e\n      \u003cli\u003e如果目的端是单个设备，那在目的端设备上使用 TBF。\u003c/li\u003e\n      \u003cli\u003e如果目的端是多个设备（同一个入向设备分流到多个目的设备），使用 Ingress\nPolicer。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e如果你不需要整形，只是想看看网络接口（interface）是否过载（so loaded that it has to queue），\n使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo\u003c/code\u003e queue（注意不是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e）。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo\u003c/code\u003e 内部没有 bands，但会记录\nbacklog 的大小。\u003c/li\u003e\n  \u003cli\u003e最后 —— 你还可以尝试“社会学整形”（”social shaping”）。有时候一些问题是无法单纯\n用技术解决的。用户会对技术限制充满敌意。和气地对别人说几句好话，也许你需要的\n带宽就解决了。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"94-术语\"\u003e9.4 术语\u003c/h1\u003e\n\n\u003cp\u003e为方便理解接下来更复杂的配置，我们需要先引入一些概念。由于这项技术本身比较复杂，\n发展也还处在较为早期的阶段，因此大家可能会用不同的术语描述同一样东西。\u003c/p\u003e\n\n\u003cp\u003e下列术语大体上来自 \u003ca href=\"http://www.ietf.org/internet-drafts/draft-ietf-diffserv-model-06.txt\"\u003edraft-ietf-diffserv-model-06.txt, An Informal Management Model for Diffserv Routers\u003c/a\u003e。想进一步了解一些术语的定义，可参考这份文档。\u003c/p\u003e\n\n\u003cp\u003e我们接下来会用到下列术语：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eQueueing Discipline (qdisc，排队规则)\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e管理设备队列（queues of devices）的算法\u003c/strong\u003e，可以是管理入向（incoing/ingress\n  ）队列，也可以是管理出向队列（outgoing/egress）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eroot qdisc（根排队规则）\u003c/p\u003e\n\n    \u003cp\u003eattach 到网络设备的那个 qdisc。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eClassless qdisc（无类别排队规则）\u003c/p\u003e\n\n    \u003cp\u003e对所有包一视同仁，同等对待。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eClassful qdisc（有类别排队规则）\u003c/p\u003e\n\n    \u003cp\u003e一个 classful qdisc 会包含多个类别（classes）。每个类别（class）可以进一步包\n  含其他 qdisc，可以是 classful qdisc，也可以是 classless qdisc。\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e严格按定义来说，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e 属于有类别排队规则（classful），因为它内部包\n  含了三个 band，而这些 band 实际上是 class\u003c/strong\u003e。但从用户配置的视角来说，它是\n  classless 的，因为这三个内部 class 用户是无法通过 tc 命令配置的。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eClasses（类别）\u003c/p\u003e\n\n    \u003cp\u003e每个 classful qdisc 可能会包含几个 class，这些都是 qdisc 内部可见的。对于每\n  个 class，也是可以再向其添加其他 class 的。因此，\u003cstrong\u003e一个 class 的 parent 可以\n  是一个 qdisc，也可以是另一个 class\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003eLeaf class 是没有 child class 的 class。\u003cstrong\u003e这种 class 中 attach 了一个 qdisc\n  ，负责该 class 的数据发送\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e创建一个 class 时会自动 attach 一个 fifo qdisc。而当向这个 class 添加 child\n  class 时，这个 fifo qdisc 会被自动删除。对于 leaf class，可以用一个更合适的\n  qdisc 来替换掉这个fifo qdisc。你甚至能用一个 classful qdisc 来替换这个 fifo\n  qdisc，这样就可以添加其他 class了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eClassifier（分类器）\u003c/p\u003e\n\n    \u003cp\u003e每个 classful qdisc 需要\u003cstrong\u003e判断每个包应该放到哪个 class\u003c/strong\u003e。这是通过分类器完成的。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eFilter（过滤器）\u003c/p\u003e\n\n    \u003cp\u003e分类过程（Classification）可以通过过滤器（filters）完成。过滤器包含许多的判\n  断条件，匹配到条件之后就算 filter 匹配成功了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eScheduling（调度）\u003c/p\u003e\n\n    \u003cp\u003e在分类器的协助下，一个 qdisc 可以\u003cstrong\u003e判断某些包是不是要先于其他包发送出去，这\n  个过程称为调度\u003c/strong\u003e，可以通过例如前面提到的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc 完成。\u003cstrong\u003e调度也被\n  称为重排序\u003c/strong\u003e（reordering），但后者容易引起混淆。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eShaping（整形）\u003c/p\u003e\n\n    \u003cp\u003e在包发送出去之前进行延迟处理，以达到预设的最大发送速率的过程。\u003cstrong\u003e整形是在\n  egress 做的\u003c/strong\u003e（前面提到了，ingress 方向的不叫 shaping，叫 policing，译者注）。\n  不严格地说，丢弃包来降低流量的过程有时也称为整形。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ePolicing（执行策略，决定是否丢弃包）\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e延迟或丢弃\u003c/strong\u003e（delaying or dropping）包来达到预设带宽的过程。 在 Linux 上，\n  policing \u003cstrong\u003e只能对包进行丢弃，不能延迟 —— 没有“入向队列”（”ingress queue”）\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eWork-Conserving qdisc（随到随发 qdisc）\u003c/p\u003e\n\n    \u003cp\u003ework-conserving qdisc \u003cstrong\u003e只要有包可发送就立即发送\u003c/strong\u003e。换句话说，只要网卡处于可\n  发送状态（对于 egress qdisc 来说），它\u003cstrong\u003e永远不会延迟包的发送\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003enon-Work-Conserving qdisc（非随到随发 qdisc）\u003c/p\u003e\n\n    \u003cp\u003e某些 qdisc，例如 TBF，可能会延迟一段时间再将一个包发送出去，以达到期望的带宽\n  。这意味着它们有时即使有能力发送，也不会发送。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e有了以上概念，我们来看它们都是在哪里用到的。\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e                Userspace programs\n                     ^\n                     |\n     +---------------+-----------------------------------------+\n     |               Y                                         |\n     |    -------\u0026gt; IP Stack                                    |\n     |   |              |                                      |\n     |   |              Y                                      |\n     |   |              Y                                      |\n     |   ^              |                                      |\n     |   |  / ----------\u0026gt; Forwarding -\u0026gt;                        |\n     |   ^ /                           |                       |\n     |   |/                            Y                       |\n     |   |                             |                       |\n     |   ^                             Y          /-qdisc1-\\   |\n     |   |                            Egress     /--qdisc2--\\  |\n  ---\u0026gt;-\u0026gt;Ingress                       Classifier ---qdisc3---- | -\u0026gt;\n     |   Qdisc                                   \\__qdisc4__/  |\n     |                                            \\-qdiscN_/   |\n     |                                                         |\n     +----------------------------------------------------------+\n\nThanks to Jamal Hadi Salim for this ASCII representation.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上图中的框代表 Linux 内核。最左侧的箭头表示流量从外部网络进入主机。然后进入\nIngress Qdisc，这里会对包进行过滤（apply Filters），根据结果\u003cstrong\u003e决定是否要丢弃这个\n包\u003c/strong\u003e。这个过程称为 “Policing”。\u003cstrong\u003e这个过程发生在内核处理的很早阶段\u003c/strong\u003e，在穿过大部\n分内核基础设施之前。\u003cstrong\u003e因此在这里丢弃包是很高效的\u003c/strong\u003e，不会消耗大量 CPU。\u003c/p\u003e\n\n\u003cp\u003e如果判断允许这个包通过，那它的目的端可能是本机上的应用（local application），这\n种情况下它会进入内核 IP 协议栈进行进一步处理，最后交给相应的用户态程序。另外，这\n个包的目的地也可能是其他主机上的应用，这种情况下就需要通过这台机器 Egress\nClassifier 再发送出去。主机程序也可能会发送数据，这种情况下也会通过 Egress\nClassifier 发送。\u003c/p\u003e\n\n\u003cp\u003eEgress Classifier 中会用到很多 qdisc。\u003cstrong\u003e默认情况下只有一个：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc\u003c/strong\u003e\n，它永远会接收包，这称为“入队”（”enqueueing”）。\u003c/p\u003e\n\n\u003cp\u003e此时包位于 qdisc 中了，等待内核召唤，然后通过网络接口（network interface）发送出去。\n这称为“出队”（”dequeueing”）。\u003c/p\u003e\n\n\u003cp\u003e以上画的是单网卡的情况。\u003cstrong\u003e在多网卡的情况下，每个网卡都有自己的 ingress 和 egress hooks\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"95-classful-qdisc分类别排队规则\"\u003e9.5 Classful qdisc（分类别排队规则）\u003c/h1\u003e\n\n\u003cp\u003e如果想\u003cstrong\u003e对不同类型的流量做不同处理\u003c/strong\u003e，那 classful qdisc 非常有用。其中一种是 CBQ（\nClass Based Queueing，基于类别的排队），由于这种类型的 qdisc 使用太广泛了，导致\n大家将广义上基于类别的排队等同于 CBQ（identify queueing with classes solely with\nCBQ），但实际并非如此。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCBQ 只是其中最古老 —— 也是最复杂 —— 的一种\u003c/strong\u003e。它的行为有时可能在你的意料之外。\n那些钟爱 “sendmail effect” 的人可能感到震惊。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003esendmail effect：\u003cstrong\u003e\u003cmark\u003e对于任何一项复杂技术，没有文档的实现一定是最好的实现\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n  \u003cp\u003eAny complex technology which doesn’t come with documentation must be the best available.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e接下来介绍更多关于 CBQ 及其类似 qdisc 的信息。\u003c/p\u003e\n\n\u003ch3 id=\"951-classful-qdisc--class-中的-flow\"\u003e9.5.1 Classful qdisc \u0026amp; class 中的 flow\u003c/h3\u003e\n\n\u003cp\u003e当流量进入一个 classful qdisc 时，该 qdisc 需要将其发送到内部的某个 class —— 即\n需要\u003cstrong\u003e对这个包进行“分类”\u003c/strong\u003e。而要这个判断过程，实际上是\u003cstrong\u003e查询所谓的“过滤器”\u003c/strong\u003e（\n‘filters’）。\u003cstrong\u003e过滤器是在 qdisc 中被调用的，而不是其他地方\u003c/strong\u003e，理解一点非常重要！\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e过滤器返回一个判决结果给 qdisc，qdisc 据此将包 enqueue 到合适的 class\u003c/strong\u003e。\n每个 subclass 可能会进一步执行其他 filters，以判断是否需要进一步处理。如果没有\n其他过滤器，这个 class 将把包 enqueue 到它自带的 qdisc。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e除了能包含其他 qdisc，大部分 classful qdisc 还会执行流量整形\u003c/strong\u003e。这对包调\n度（packet scheduling，例如，基于 SFQ）和速率控制（rate control）都非常有用。\n当高速设备（例如，以太网）连接到一个低速设备（例如一个调制解调器）时，会用到这个\n功能。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e如果只运行 SFQ，那接下来不会发生什么事情\u003c/strong\u003e，因为包会无延迟地进入和离开路由\n器：\u003cstrong\u003e网卡的发送速度要远大于真实的链路速度。瓶颈不在主机中，就无法用“队列”（queue\n）来调度这些流量\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"952-qdisc-大家庭roots-handles-siblings-and-parents\"\u003e9.5.2 qdisc 大家庭：roots, handles, siblings and parents\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e每个接口都有一个 egress \u0026#34;root qdisc\u0026#34;\u003c/mark\u003e。默认情况下，这个 root qdisc 就是前面提到的 classless \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc。\u003c/p\u003e\n\n    \u003cblockquote\u003e\n      \u003cp\u003e回忆前面实体邮箱的类比。理论上 egress 流量是本机可控的，所以需要配备一个 qdisc 来提供这种控制能力。译注。\u003c/p\u003e\n    \u003c/blockquote\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e每个 qdisc 和 class 都会分配一个相应的 handle（句柄）\u003c/mark\u003e，可以指定 handle 对 qdisc 进行配置。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e每个接口可能还会有一个 ingress qdisc\u003c/mark\u003e，用来对入向流量执行策略（which polices traffic coming in）。\u003c/p\u003e\n\n    \u003cblockquote\u003e\n      \u003cp\u003e理论上 ingress 基本是不受本机控制的，主动权在外部，所以不一定会有 qdisc。译注。\u003c/p\u003e\n    \u003c/blockquote\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e关于 handle：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cmark\u003e每个 handle 由两部分组成\u003c/mark\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;major\u0026gt;:\u0026lt;minor\u0026gt;\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e按照惯例，\u003cmark\u003eroot qdisc 的 handle 为\u003c/mark\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:\u003c/code\u003e，这是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e 的简写。\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e每个 qdisc 的 minor number 永远是\u003c/mark\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e关于 class：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e每个 class 的 major number 必须与其 parent 一致。\u003c/li\u003e\n  \u003cli\u003emajor number 在一个 egress 或 ingress 内必须唯一。\u003c/li\u003e\n  \u003cli\u003eminor number 在一个 qdisc 或 class 内必须唯一。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cmark\u003e上面的解释有点模糊\u003c/mark\u003e，可对照 \u003ca href=\"https://man7.org/linux/man-pages/man8/tc.8.html\"\u003etc(8) man page\u003c/a\u003e 的解释：\u003c/p\u003e\n\n  \u003cp\u003e所有 qdiscs、classes 和 filters 都有 ID，这些 ID 可以是指定的，也可以是自动分的。\u003c/p\u003e\n\n  \u003cp\u003eID 格式 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor:minor\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminor\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e都是 16 进制数字\u003c/mark\u003e\u003c/strong\u003e，不超过 2 字节。\n两个特殊值：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eroot\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminor\u003c/code\u003e 初始化全 1。\u003c/li\u003e\n    \u003cli\u003e省略未指定的部分将为全 0。\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e下面分别介绍以上三者的 ID 规范。\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cp\u003eqdisc：qdisc 可能会有 children。\u003c/p\u003e\n\n      \u003cul\u003e\n        \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e 部分：称为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle\u003c/code\u003e，表示的 qdisc 的唯一性。\u003c/li\u003e\n        \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminor\u003c/code\u003e 部分：留给 class 的 namespace。\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cp\u003eclass：class 依托在 qdisc 内，\u003c/p\u003e\n\n      \u003cul\u003e\n        \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e 部分：继承 class 所在的 qdisc 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e。\u003c/li\u003e\n        \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminor\u003c/code\u003e 部分：称为 classid，在所在的 qdisc 内唯一就行。\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cp\u003efilter：由三部分构成，只有在使用 hashed filter hierarchy 时才会用到。\u003c/p\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e译者注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch4 id=\"9521-如何用过滤器filters-对流量进行分类\"\u003e9.5.2.1 如何用过滤器（filters ）对流量进行分类\u003c/h4\u003e\n\n\u003cp\u003e综上，一个典型的 handle 层级如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e                     1:   root qdisc\n                      |\n                     1:1    child class\n                   /  |  \\\n                  /   |   \\\n                 /    |    \\\n                 /    |    \\\n              1:10  1:11  1:12   child classes\n               |      |     |\n               |     11:    |    leaf class\n               |            |\n               10:         12:   qdisc\n              /   \\       /   \\\n           10:1  10:2   12:1  12:2   leaf classes\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e但不要被这棵树迷惑！不要以为内核位于树的顶点，网络位于下面。\u003cstrong\u003e包只会通过 root\nqdisc 入队或出队\u003c/strong\u003e（get enqueued and dequeued），这也是内核唯一与之交互的部分（\nthe only thing the kernel talks to）。\u003c/p\u003e\n\n\u003cp\u003e一个包可能会被链式地分类如下（get classified in a chain）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1: -\u0026gt; 1:1 -\u0026gt; 1:12 -\u0026gt; 12: -\u0026gt; 12:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后到达 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclass 12:2\u003c/code\u003e 的 qdisc 的队列。在这个例子中，树的每个“节点”（\nnode）上都 attach 了一个 filter，每个 filter 都会给出一个判断结果，根据判断结果\n选择一个合适的分支将包发送过去。\u003cstrong\u003e这是常规的流程\u003c/strong\u003e。但下面这种流程也是有可能的：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1: -\u0026gt; 12:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在这种情况下，attach 到 root qdisc 的 filter 决定直接将包发给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:2\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch4 id=\"9522-包是如何从-qdisc-出队dequeue然后交给硬件的\"\u003e9.5.2.2 包是如何从 qdisc 出队（dequeue）然后交给硬件的\u003c/h4\u003e\n\n\u003cp\u003e当内核决定从 qdisc dequeue packet 交给接口（interface）发送时，它会\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e向 root qdisc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:\u003c/code\u003e 发送一个 dequeue request\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:\u003c/code\u003e 会将这个请求转发给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e，后者会进一步向下传递，转发给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e11:\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e每个 qdisc 会查询它们的 siblings，并尝试在上面执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edequeue()\u003c/code\u003e 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e在这个例子中，内核需要遍历整棵树，因为只有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:2\u003c/code\u003e 中有数据包\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e简单来说，\u003cstrong\u003e嵌套类（nested classes）只会和它们的 parent qdiscs 通信，而永远不会直\n接和接口交互\u003c/strong\u003e。\u003cmark\u003e内核只会调用 root qdisc 的\u003c/mark\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edequeue()\u003c/code\u003e 方法！\u003c/p\u003e\n\n\u003cp\u003e最终结果是，classes dequeue 的速度永远不会超过它们的 parents 允许的速度【译注】。而这正\n是我们所期望的：这样就能在内层使用一个 SFQ 做纯调度，它不用做任何整形的工作\n；然后在外层使用一个整形 qdisc 专门负责整形。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e【译注】有朋友验证，这里是可以超过的，\u003c/p\u003e\n\n  \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/nested-class-test.jpg\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n  \u003cp\u003e“nested classes rate（最低保障带宽）不受制于父类 class rate 和 ceil 的限制，但可借用带宽会受限”。\n感谢来信！\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"953-prio-qdisc优先级排队规则\"\u003e9.5.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc（优先级排队规则）\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc 实际上\u003cstrong\u003e不会整形行\u003c/strong\u003e，只会根据设置的过滤器\u003cstrong\u003e对流量分类\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/prio-qdisc-1.gif\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [2]\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e可以将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc 理解为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc 的升级版\u003c/strong\u003e，它也有多个 band，但\n每个 band 都是一个独立的 class，而不是简单的 FIFO。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/prio-qdisc-2.gif\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [2]\u003c/p\u003e\n\n\u003cp\u003e当一个包 enqueue 到 PRIO qdisc 之后，它会根据设置的 filters 选择一个 class\n，并将包送到这个 class。默认情况下会创建三个 class。每个 class 默认情况下都包含一\n个纯 FIFO qdisc，没有其他内部结构，但你可以用其他类型的 qdisc 替换掉 FIFO。\u003c/p\u003e\n\n\u003cp\u003e当从 PRIO qdisc 取出（dequeue）一个包时，会先尝试 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e:1\u003c/code\u003e。只有 lower bands/classes\n没有数据包可取时，才会尝试 higher classes。\u003c/p\u003e\n\n\u003cp\u003e如果想\u003cstrong\u003e基于 tc filters 而不仅仅是 TOS flags 做流量优先级分类\u003c/strong\u003e时，这个 qdisc 会非常\n有用。还可以向这三个预置的 classes 添加额外的 qdisc，毕竟 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e 只能提供简\n单的 FIFO qdisc。\u003c/p\u003e\n\n\u003cp\u003e由于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e \u003cmark\u003e没有流量整形功能\u003c/mark\u003e，因此针对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSFQ\u003c/code\u003e 的\u003cmark\u003e忠告也适用于这里\u003c/mark\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e如果你的物理链路已经打满了，可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc （对流量进行分类），或者\u003c/li\u003e\n  \u003cli\u003e在外层嵌套一个 classful qdisc，后者负责流量整形。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e用正式的术语来说，\u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc 是一个 work-conserving 调度器\u003c/strong\u003e（随到随发）。\u003c/p\u003e\n\n\u003ch4 id=\"9531-参数与用法\"\u003e9.5.3.1 参数与用法\u003c/h4\u003e\n\n\u003cp\u003e下面几个参数能被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 识别：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebands\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e需要创建的 band 数量。这个每个 band 实际上都是一个 class。如果改变这个配置，\n  还需要同时修改 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriomap\u003c/code\u003e 参数。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epriomap\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e如果没有提供 tc filters 来指导如何对流量分类，那 PRIO qdisc 将依据\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_PRIO\u003c/code\u003e 优先级来决定优先级。这里的工作方式与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e qdisc 是类似的，\n  更多细节可以参考前面的 \u003ca href=\"#pfifo_fast\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epfifo_fast\u003c/code\u003e 小节\u003c/a\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ePRIO qdisc 里面的 band 都是 class，默认情况下名字分别为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor:1\u003c/code\u003e、 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor:2\u003c/code\u003e、 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor:3\u003c/code\u003e，\n因此如果你的 PRIO qdisc 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:\u003c/code\u003e，那 tc filter 送到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:1\u003c/code\u003e 的流量就有更高的优先级。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e重复一遍：band 0 对应的 minor number 是 1！\u003c/strong\u003e band 1 对应的 minor number 是 2\n，以此类推。\u003c/p\u003e\n\n\u003ch4 id=\"9532-示例配置\"\u003e9.5.3.2 示例配置\u003c/h4\u003e\n\n\u003cp\u003e我们将创建一棵如下所示的树：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e          1:   root qdisc\n         / | \\\n        /  |  \\\n       /   |   \\\n     1:1  1:2  1:3    classes\n      |    |    |\n     10:  20:  30:    qdiscs    qdiscs\n     sfq  tbf  sfq\nband  0    1    2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e高吞吐流量（Bulk traffic）将送到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e30:\u003c/code\u003e，交互式流量（interactive traffic）将送到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e20:\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e命令行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 root handle 1: prio \u003cspan class=\"c\"\u003e# This *instantly* creates classes 1:1, 1:2, 1:3\u003c/span\u003e\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:1 handle 10: sfq\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:2 handle 20: tbf rate 20kbit buffer 1600 limit 3000\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:3 handle 30: sfq\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后查看创建出来的 qdisc：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e qdisc \u003cspan class=\"nb\"\u003els \u003c/span\u003edev eth0\nqdisc sfq 30: quantum 1514b\n Sent 0 bytes 0 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms\n Sent 0 bytes 0 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc sfq 10: quantum 1514b\n Sent 132 bytes 2 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 174 bytes 3 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，band 0 已经有了一些流量，而且在执行这条命令的过程中，刚好又发送了一个\n包！\u003c/p\u003e\n\n\u003cp\u003e现在我们来用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003escp\u003c/code\u003e 命令传输一些数据，它会自动设置 TOS flags：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ scp tc ahu@10.0.0.11:./\nahu@10.0.0.11\u0026#39;s password:\ntc                   100% |*****************************|   353 KB    00:00\n\n$ tc -s qdisc ls dev eth0\nqdisc sfq 30: quantum 1514b\n Sent 384228 bytes 274 pkts (dropped 0, overlimits 0)\n\n qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms\n Sent 2640 bytes 20 pkts (dropped 0, overlimits 0)\n\n qdisc sfq 10: quantum 1514b\n Sent 2230 bytes 31 pkts (dropped 0, overlimits 0)\n\n qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 389140 bytes 326 pkts (dropped 0, overlimits 0)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，所有的流量都进入了优先级最低的 handle \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e30:\u003c/code\u003e，这正是我们期望的。为了验\n证交互式流量会进入优先级更高的 bands，我们可以生成一些交互式流量。\n然后再来查看统计：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# tc -s qdisc ls dev eth0\u003c/span\u003e\nqdisc sfq 30: quantum 1514b\n Sent 384228 bytes 274 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc tbf 20: rate 20Kbit burst 1599b lat 667.6ms\n Sent 2640 bytes 20 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc sfq 10: quantum 1514b\n Sent 14926 bytes 193 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n qdisc prio 1: bands 3 priomap  1 2 2 2 1 2 0 0 1 1 1 1 1 1 1 1\n Sent 401836 bytes 488 pkts \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 0, overlimits 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e正如预期 —— 所有额外流量都进入了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e，这是我们优先级最高的 qdisc。handle \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e30:\u003c/code\u003e\n的流量这次没有增长，而刚才它吸收了所有的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003escp\u003c/code\u003e 流量。\u003c/p\u003e\n\n\u003ch3 id=\"954-著名的-cbqclass-based-queueingqdisc\"\u003e9.5.4 著名的 CBQ（Class Based Queueing）qdisc\u003c/h3\u003e\n\n\u003cp\u003e前面提到，\u003cstrong\u003eCBQ（Class Based Queueing，基于类的排队） 是最复杂、最花哨、最少被理\n解、也可能是最难用对的 qdisc\u003c/strong\u003e。这并非因为它的发明者都是魔鬼或者能力不够，而是\n因为 CBQ 算法经常不够精确，而这是由于\u003cstrong\u003e它与 Linux 的工作方式不是太匹配\u003c/strong\u003e造成的。\u003c/p\u003e\n\n\u003cp\u003e除了是 classful qdisc 之外，CBQ 还是一个整流器（shaper），作为一个整流器来说，\n其实它工作地并不是非常理想。理想的工作方式应该是这样的：如果想将一个 10Mbps 的连\n接整形为 1Mbps，那这条链路应该有 90% 的时间是空闲的。否则，我们就需要 throttle\n来确保链路 90% 的时间是空闲的。\u003c/p\u003e\n\n\u003cp\u003e但\u003cstrong\u003e空闲时间是很难测量的\u003c/strong\u003e，CBQ 的方式是：用硬件层连续两次请求数据的时间间隔（\n毫秒）来推算。这可以用来近似估计链路的空闲状态（how full or empty the link is）。\u003c/p\u003e\n\n\u003cp\u003e这种测量方式是非常间接的，因此结果并不总是很准确。例如，接口的物理带宽是 100Mbps\n，但它可能永远打不到 100Mbps，而原因可能是网卡驱动写的太烂。另一个例子，PCMCIA 网\n卡永远打不到 100Mbps，这是由于其总线设计导致的 —— 因此，又回到那个问题：\u003cstrong\u003e应该\n如何计算空闲时间\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e当考虑到非纯物理网络设备（not-quite-real network devices）时，例如\nPPP over Ethernet 或 PPTP over TCP/IP，情况会更加糟糕。在这些场景中，有效带\n宽可能是由到用户空间的管道（pipe）效率决定的 —— 这个值可能很高。\u003c/p\u003e\n\n\u003cp\u003e真正测量过的人会发现，CBQ 并不是永远很精确，有时甚至完全偏离了真实值。\u003c/p\u003e\n\n\u003cp\u003e但在某些场景下，CBQ 能很好地满足需求。基于本文的介绍，你应该能恰当地配置 CBQ，使\n其在大部分情况下都工作良好。\u003c/p\u003e\n\n\u003ch4 id=\"9541-cbq-shaping-详解\"\u003e9.5.4.1 CBQ shaping 详解\u003c/h4\u003e\n\n\u003cp\u003e如前所述，CBQ 的工作原理是：在发送包之前等待足够长的时间，以将带宽控制到期望\n的阈值。为实现这个目标，它需要计算包之间的等待间隔。\u003c/p\u003e\n\n\u003cp\u003e系统在运行过程中会计算一个\u003cstrong\u003e有效空闲时间\u003c/strong\u003e（effective idletime）：用\u003cstrong\u003e指数加权移动平均\u003c/strong\u003e（\nexponential weighted moving average，EWMA）来计算，这个算法假设包的优先级大小\n是指数变化的，越近的包（recent packets）优先级越高。UNIX 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eloadaverage\u003c/code\u003e 指标\n就是用的这个算法。\u003c/p\u003e\n\n\u003cp\u003e平均空闲时间（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle\u003c/code\u003e）的定义：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle = 有效空闲时间（EWMA）- 计算出的空闲时间\u003c/code\u003e，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e理想的未过载链路（loaded link）：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle = 0\u003c/code\u003e\u003c/strong\u003e，每经过精确地计算出的时间间隔，就有一个数据\n包到来（packets arrive exactly once every calculated interval）。\u003c/li\u003e\n  \u003cli\u003e过载链路（overloaded link）：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle \u0026lt; 0\u003c/code\u003e，如果这个负值变得太大，CBQ 会关闭一\n会，表示超出限制了（overlimit）。\u003c/li\u003e\n  \u003cli\u003e空闲链路（idle link）：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle \u0026lt; 0\u003c/code\u003e，而且这个值可能会非常大，这可能会导致\n累积几个小时之后，算法允许无限大的带宽（infinite bandwidths after a few hours of silence）。\n为防止这种情况发生，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle\u003c/code\u003e 会设置一个上限（maxidle）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果发生 overlimit，理论上 CBQ 会严格等待 calculated_idletime，然后才发生下一个\n包，然后再次 throttle 自己。但此时也要注意 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminburst\u003c/code\u003e 参数，见下面。\u003c/p\u003e\n\n\u003cp\u003e下面是整形（shaping）相关的配置参数：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eavpkt\u003c/p\u003e\n\n    \u003cp\u003e平均包长，单位是字节。计算 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaxidle\u003c/code\u003e 时会用到。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ebandwidth\u003c/p\u003e\n\n    \u003cp\u003e设备的物理带宽，计算 idle time 时会用到。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecell\u003c/p\u003e\n\n    \u003cp\u003e包长的增长步长。设备发送不同长度的包时，耗时可能是不一样的，与包长有关。\n  例如，一个 800Byte 和一个 806Byte 的包所花的发送时间可能是一样的。默认值通常是\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e8\u003c/code\u003e，必须是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2\u003c/code\u003e 的幂次。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaxburst\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e计算 maxidle 时用到，单位：包数（number of packets）。\u003c/p\u003e\n\n    \u003cp\u003e当 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle == maxidle\u003c/code\u003e 时，可以并发发送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaxburst\u003c/code\u003e 个包，直到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle == 0\u003c/code\u003e。\n  注意 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaxidle\u003c/code\u003e 是无法直接设置的，只能通过这个参数间接设置。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eminburst\u003c/p\u003e\n\n    \u003cp\u003e前面提到，overlimit 情况下 CBQ 要执行 throttle。理想情况下是精确 throttle\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecalculated idel time\u003c/code\u003e，然后发送一个包。但对 Unix 内核来说，通常很难调度\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10ms\u003c/code\u003e 以下精度的事件，因此最好的方式就是 throttle 更长一段时间，然后一次发\n  送 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminburst\u003c/code\u003e 个包，然后再睡眠 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminburst\u003c/code\u003e 倍的时间。\u003c/p\u003e\n\n    \u003cp\u003eThe time to wait is called the offtime。从较长时间跨度看，更大的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminburst\u003c/code\u003e\n  会使得整形更加精确，但会导致在毫秒级别有更大的波动性。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eminidle\u003c/p\u003e\n\n    \u003cp\u003e如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle \u0026lt; 0\u003c/code\u003e，那说明 overlimits，需要等到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavgidle\u003c/code\u003e 足够大才能发送下一个包。\n  为防止突然的 burst 打爆链路带宽，当 avgidle 降到一个非常小的值之后，会 reset 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminidle\u003c/code\u003e。\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminidle\u003c/code\u003e 的单位是负微秒（negative microseconds），因此 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10\u003c/code\u003e 就表示 idle\n  time 下限是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-10us\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003empu\u003c/p\u003e\n\n    \u003cp\u003e最小包长（Minimum packet size）—— 需要这个参数是因为，即使是零字节的包在以太\n  网上传输时也会被填充到 64 字节，因此总会有一个发送耗时。\n  CBQ 需要这个参数来精确计算 idle time。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003erate\u003c/p\u003e\n\n    \u003cp\u003e期望的离开这个 qdisc 的流量速率（rate of traffic）——  这就是“速度旋钮”（speed knob）！\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在内部，CBQ 有很多优化。例如，在 dequeue 包时，已经明确知道没有数据的 class 都会跳过。\nOverlimit 的 class 会通过降低其有效优先级（effective priority）的方式进行惩罚。\n所有这些都是很智能也很复杂的。\u003c/p\u003e\n\n\u003ch4 id=\"9542-cbq-classful-behaviour\"\u003e9.5.4.2 CBQ classful behaviour\u003c/h4\u003e\n\n\u003cp\u003e除了整形之外，基于前面提到的 idletime 近似，CBQ 也能完成类似 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e queue 的功能\n，因为 class 可以有不同优先级，优先级高的总是限于优先级低的被 poll。\u003c/p\u003e\n\n\u003cp\u003e每次硬件层请求一个数据包来发送时，都会开启一个 weighted round robin （WRR）过程，\n从优先级最高的 class 开始（注意，优先级越高对应的 priority number 越小）。\u003c/p\u003e\n\n\u003cp\u003e优先级相同的 class 会作为一组，依次判断它们是否有数据要发送。\u003c/p\u003e\n\n\u003cp\u003e下列参数控制 WRR 过程：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eallot\u003c/p\u003e\n\n    \u003cp\u003e当外层 CBQ 收到网卡要发送一个数据包的请求后，它会按照 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprio\u003c/code\u003e 参数指定的\n  优先级，尝试依次 classes 内 attach 的所有内部 qdiscs。 每个 class 被轮到时，\n  它只能发送有限的一些数据。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ealloct\u003c/code\u003e 就是这个数据量的一个基本单位。更多信息参见\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eweight\u003c/code\u003e 参数。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eprio\u003c/p\u003e\n\n    \u003cp\u003eCBQ 也能执行与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e 设备一样的行为。内部 classes 都有一个优先级 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprio\u003c/code\u003e，高\n  优先级的会先于低优先级的被 poll。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eweight\u003c/p\u003e\n\n    \u003cp\u003e这个参数用于 WRR 过程。每个 class 都有机会发送数据。如果要指定某个 class 使\n  用更大的带宽，就调大其 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eweight\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003eCBQ 会将一个 class 内的所有权重归一化，因此指定用整数还是小数都没关系：重要\n  的是比例。大家的经验值是 “rate/10”，这个值看上去工作良好。归一化后的\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eweight\u003c/code\u003e 乘以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eallot\u003c/code\u003e，决定了每次能发送的数据量。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e注意：CBQ 层级内的所有 class 要共享同一个 major number！\u003c/p\u003e\n\n\u003ch4 id=\"9543-决定-link-sharing--borrowing-的-cbq-参数\"\u003e9.5.4.3 决定 link sharing \u0026amp; borrowing 的 CBQ 参数\u003c/h4\u003e\n\n\u003cp\u003e除了限制特定类型的流量，还能指定哪些 class 能从另外哪些 class 借容量（borrow\ncapacity）或者说，借带宽（对前一种 class 来说是借入，对后一种 class 来说就是借出）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eisolated\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esharing\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e配置了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eisolated\u003c/code\u003e 的 class 不会向 sibling classes 借出带宽。如果多个应用\n  之间在链路利用上是竞争或互斥的，彼此不想给对方带宽，那可以用这个配置。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 工具还有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esharing\u003c/code\u003e 配置，作用于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eisolated\u003c/code\u003e 相反。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eborrow\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e也可以配置 class 为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e，这表示它不会向其他 siblings 借带宽。\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 工具还支持一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eborrow\u003c/code\u003e 选项，作用于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e 相反。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e一个典型场景可能是：同一个链路上有两个应用，二者都是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eisolated\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e\n，这表示二者都只会限制在它们各自分配的速率内，不会互相借带宽。\u003c/p\u003e\n\n\u003cp\u003e有了这样的 agency class（代理类），可能还会有其他允许交换带宽的 class。\u003c/p\u003e\n\n\u003cp\u003e\u003ca name=\"cbq_sample_config\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch4 id=\"9544-示例配置\"\u003e9.5.4.4 示例配置\u003c/h4\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e               1:           root qdisc\n               |\n              1:1           child class\n             /   \\\n            /     \\\n          1:3     1:4       leaf classes\n           |       |\n          30:     40:       qdiscs\n         (sfq)   (sfq)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个例子将\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ewebserver 限制为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5Mbps\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003eSMTP 流量限制到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3Mbps\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003ewebserver + SMTP 总共不超过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6Mbps\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e物理网卡是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100Mbps\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e每个 class 之间可以互借带宽。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 root handle 1:0 cbq bandwidth 100Mbit         \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000 cell 8\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:0 classid 1:1 cbq bandwidth 100Mbit  \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 6Mbit weight 0.6Mbit prio 8 allot 1514 cell 8 maxburst 20      \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000 bounded\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上面两条命令创建了 root qdisc 和相应的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e class。这个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e class 是\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e 类型，因此总带宽不会超过设置的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6Mbps\u003c/code\u003e 限制。如前所述，CBQ 需要很多\n速度选项（knobs，旋钮式开关）。但用到的参数前面都介绍过了。\u003cstrong\u003e如果 HTB 来实现这个\n功能，就会简单很多\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:1 classid 1:3 cbq bandwidth 100Mbit  \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 5Mbit weight 0.5Mbit prio 5 allot 1514 cell 8 maxburst 20      \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:1 classid 1:4 cbq bandwidth 100Mbit  \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 3Mbit weight 0.3Mbit prio 5 allot 1514 cell 8 maxburst 20      \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上面两个创建的是叶子节点（leaf classes）。注意其中是如何配置速率的。两个\nclass 都没有配置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebounded\u003c/code\u003e 参数，但它们都连着到了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e class，后者是有限速不超\n过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6Mbps\u003c/code\u003e 的。因此这两个 leaf class 的总带宽不会超过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6Mbps\u003c/code\u003e。另外需要注意，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclassid\u003c/code\u003e 中的 major number 必须要和 parent qdisc 中的 major number 一样！\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:3 handle 30: sfq\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:4 handle 40: sfq\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e每个 class 默认都有一个 FIFO qdisc。但我们将其替换成了 SFQ 这样每条 flow 都能被\n独立、平等对待了。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  sport 80 0xffff flowid 1:3\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 match ip \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  sport 25 0xffff flowid 1:4\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e这些过滤规则直接作用在 root qdisc 上\u003c/strong\u003e，作用是将流量分类到下面正确的 qdisc。\u003c/p\u003e\n\n\u003cp\u003e注意其中是\u003cstrong\u003e先用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc class add\u003c/code\u003e 命令往 qdisc 内添加 class，然后又用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc qdisc\nadd\u003c/code\u003e命令向 class 内添加 qdisc\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e你可能会好奇：\u003cstrong\u003e没有匹配到以上两条规则的流量怎么办？\u003c/strong\u003e在本例中，它们会进入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e\n接受处理，而这里是没有限速的。\u003c/p\u003e\n\n\u003cp\u003e如果 SMTP+web 的总带宽超过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6Mbps\u003c/code\u003e，那总带宽将根据给定的权重参数分为两部分，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5/8\u003c/code\u003e 给 webserver，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3/8\u003c/code\u003e 给邮件服务。也可以说，在这个配置下，\u003cstrong\u003ewebserver 流量在\n任何时候至少能获得 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5/8 * 6Mbps = 3.75Mbps\u003c/code\u003e 带宽\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"9545-cbq-其他参数split--defmap\"\u003e9.5.4.5 CBQ 其他参数：split \u0026amp; defmap\u003c/h3\u003e\n\n\u003cp\u003e如前所述，classful qdisc 需要调用过滤器（filters）来判断应该将包送到那个 class\n里面。\u003c/p\u003e\n\n\u003cp\u003e除了调用过滤器，CBQ 还提供了其他选项：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefmap\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esplit\u003c/code\u003e。这一块非常复杂，很难\n理解，而且并不是非常重要。但考虑到这是目前已知的关于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefmap \u0026amp; split\u003c/code\u003e 最完善的文\n档，我将尽我可能来介绍一下。\u003c/p\u003e\n\n\u003cp\u003eAs you will often want to filter on the Type of Service field only, a special\nsyntax is provided. Whenever the CBQ needs to figure out where a packet needs to\nbe enqueued, it checks if this node is a ‘split node’. If so, one of the\nsub-qdiscs has indicated that it wishes to receive all packets with a certain\nconfigured priority, as might be derived from the TOS field, or socket options\nset by applications.\u003c/p\u003e\n\n\u003cp\u003eThe packets’ priority bits are and-ed with the defmap field to see if a match\nexists. In other words, this is a short-hand way of creating a very fast filter,\nwhich only matches certain priorities. A defmap of ff (hex) will match\neverything, a map of 0 nothing. A sample configuration may help make things\nclearer:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth1 root handle 1: cbq bandwidth 10Mbit allot 1514 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  cell 8 avpkt 1000 mpu 64\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth1 parent 1:0 classid 1:1 cbq bandwidth 10Mbit    \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 10Mbit allot 1514 cell 8 weight 1Mbit prio 8 maxburst 20        \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eStandard CBQ preamble. I never get used to the sheer amount of numbers required!\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefmap\u003c/code\u003e 会用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_PRIO\u003c/code\u003e bits，后者定义如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eTC_PRIO..          Num  Corresponds to TOS\n-------------------------------------------------\nBESTEFFORT         0    Maximize Reliablity\nFILLER             1    Minimize Cost\nBULK               2    Maximize Throughput (0x8)\nINTERACTIVE_BULK   4\nINTERACTIVE        6    Minimize Delay (0x10)\nCONTROL            7\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e关于 TOS bits 如何映射到 priorities，参考 \u003ca href=\"#pfifo_fast\"\u003epfifo_fast\u003c/a\u003e 小结。\u003c/p\u003e\n\n\u003cp\u003e现在看交互式和批量 classes：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth1 parent 1:1 classid 1:2 cbq bandwidth 10Mbit     \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 1Mbit allot 1514 cell 8 weight 100Kbit prio 3 maxburst 20        \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000 \u003cspan class=\"nb\"\u003esplit \u003c/span\u003e1:0 defmap c0\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth1 parent 1:1 classid 1:3 cbq bandwidth 10Mbit     \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  rate 8Mbit allot 1514 cell 8 weight 800Kbit prio 7 maxburst 20        \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  avpkt 1000 \u003cspan class=\"nb\"\u003esplit \u003c/span\u003e1:0 defmap 3f\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e“split qdisc” 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e，表示在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e 进行判断。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eC0\u003c/code\u003e 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e11000000\u003c/code\u003e 的二进制表示，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3F\u003c/code\u003e 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e00111111\u003c/code\u003e，因此这二者足以匹配任何东西。第一个 class 匹配第 6 \u0026amp; 7 位，因\n此对应的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eINTERACTIVE\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONTROL\u003c/code\u003e 流量。第二个 class 匹配的是其他所有流量。\u003c/p\u003e\n\n\u003cp\u003e节点 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e 此时有一个如下的映射表：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epriority  send to\n0         1:3\n1         1:3\n2         1:3\n3         1:3\n4         1:3\n5         1:3\n6         1:2\n7         1:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果对此有进一步兴趣，还可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc class change\u003c/code\u003e 命令传递一个 “change mask” 参\n数，精确地指定你期望的优先级映射关系。例如，要将 best effort 流量转到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:2\u003c/code\u003e，执\n行命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ tc class change dev eth1 classid 1:2 cbq defmap 01/01\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e此时 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:0\u003c/code\u003e 处的 priority map 将变成下面这样：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epriority  send to\n0         1:2\n1         1:3\n2         1:3\n3         1:3\n4         1:3\n5         1:3\n6         1:2\n7         1:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eFIXME: did not test ‘tc class change’, only looked at the source.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"955-htbhierarchical-token-bucket层级令牌桶\"\u003e9.5.5 HTB（Hierarchical Token Bucket，层级令牌桶）\u003c/h3\u003e\n\n\u003cp\u003eMartin Devera (devik) 意识到 CBQ 太复杂了，并且没有针对很多典型的场景进\n行优化。因此他设计了 HTB，这种层级化的方式对下面这些场景很适用：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e有一个固定总带宽，想将其分割成几个部分，分别用作不同目的\u003c/li\u003e\n  \u003cli\u003e每个部分的带宽是有保证的（guaranteed bandwidth）\u003c/li\u003e\n  \u003cli\u003e还可以指定每个部分向其他部分借带宽\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/lartc-qdisc/htb-borrow.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e图片来自 [1]\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eHTB 的工作方式与 CBQ 类似，但不是借助于计算空闲时间（idle time）来实现整形\u003c/strong\u003e。\n在内部，它其实是一个 classful TBF（令牌桶过滤器）—— 这也是它叫层级令牌桶（HTB）\n的原因。HTB 的参数并不多，在它的\u003ca href=\"http://luxik.cdi.cz/~devik/qos/htb/\"\u003e网站\u003c/a\u003e文档\n里都已经写的很明确了。\u003c/p\u003e\n\n\u003cp\u003e即使发现你的 HTB 配置越来越复杂，这些配置还是能比较好地扩展（scales well）。而使\n用 CBQ 的话，即使在简单场景下配置就很复杂了！\nHTB3（HTB 的不同版本参见其\u003ca href=\"http://luxik.cdi.cz/~devik/qos/htb/\"\u003e官方文档\u003c/a\u003e）现在\n已经并入正式内核了（from 2.4.20-pre1 and 2.5.31 onwards）。但你可能还是要应用一\n个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e 的 patch：HTB 内核和用户空间模块的主版本号必须相同，否则 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e HTB 无法正\n常工作。\u003c/p\u003e\n\n\u003cp\u003e如果使用的内核版本已经支持 HTB，那非常建议用用看。\u003c/p\u003e\n\n\u003ch4 id=\"9551-示例配置\"\u003e9.5.5.1 示例配置\u003c/h4\u003e\n\n\u003cp\u003e功能几乎与 \u003ca href=\"#cbq_sample_config\"\u003e前面的 CBQ 示例配置\u003c/a\u003e 一样的 HTB 配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 root handle 1: htb default 30\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1: classid 1:1 htb rate 6mbit burst 15k\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:1 classid 1:10 htb rate 5mbit burst 15k\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:1 classid 1:20 htb rate 3mbit ceil 6mbit burst 15k\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev eth0 parent 1:1 classid 1:30 htb rate 1kbit ceil 6mbit burst 15k\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eHTB 作者推荐在这些 class 内部使用 SFQ：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:10 handle 10: sfq perturb 10\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:20 handle 20: sfq perturb 10\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 parent 1:30 handle 30: sfq perturb 10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后，将流量导向这些 class 的过滤器（filters）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ U32\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;tc filter add dev eth0 protocol ip parent 1:0 prio 1 u32\u0026#34;\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ $U32\u003c/span\u003e match ip dport 80 0xffff flowid 1:10\n\u003cspan class=\"nv\"\u003e$ $U32\u003c/span\u003e match ip sport 25 0xffff flowid 1:20\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这就是 HTB 的配置了 —— 没有看上去不知道是什么意思的数字（unsightly unexplained\nnumbers），没有查文档都查不到的参数。\nHTB 显然看上去非常棒 —— 如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e20:\u003c/code\u003e 都获得了保证的带宽（guaranteed\nbandwidth），并且总带宽中还有很多剩余，它们还可以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5:3\u003c/code\u003e 的比例借用额外带宽，正如\n我们所期望的。\u003c/p\u003e\n\n\u003cp\u003e未分类的流量（unclassified traffic）会进入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e30:\u003c/code\u003e，这个 band 只有很小的带宽，但能\n够从剩余的可用带宽中借带宽来用。由于我们用了的 SFQ（随机公平调度），我们还获得了\n公平调度而没有增加额外成本！\u003c/p\u003e\n\n\u003ch3 id=\"956-fq_codelfair-queuing-controlled-delay延迟受控的公平排队译注\"\u003e9.5.6 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efq_codel\u003c/code\u003e（Fair Queuing Controlled Delay，延迟受控的公平排队），译注\u003c/h3\u003e\n\n\u003cp\u003e这种 qdisc 组合了 FQ 和 ColDel AQM，使用一个随机模型（a stochastic model）\n将入向包分为不同 flow，确保使用这个队列的所有 flow 公平分享总带宽。\u003c/p\u003e\n\n\u003cp\u003e每个 flow 由 CoDel 排队规则来管理，每个 flow 内不能重排序，因为 CoDel 内部使用了一个 FIFO 队列。\u003c/p\u003e\n\n\u003cp\u003eUbuntu 20.04 默认使用的这种队列：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show \u003cspan class=\"c\"\u003e# 默认网卡 enp0s3\u003c/span\u003e\nqdisc fq_codel 0: dev enp0s3 root refcnt 2 limit 10240p flows 1024 quantum 1514 target 5.0ms interval 100.0ms memory_limit 32Mb ecn\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"957-mq-multi-queue2009译注\"\u003e9.5.7 MQ （Multi Queue，2009），译注\u003c/h3\u003e\n\n\u003cp\u003e详细介绍见 \u003ca href=\"https://github.com/torvalds/linux/commit/6ec1c69a8f649\"\u003eTODO\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"96-用过滤器对流量进行分类\"\u003e9.6 用过滤器对流量进行分类\u003c/h1\u003e\n\n\u003cp\u003e每次要判断将包送到哪个 class 进行处理时，都会调用所谓的“classifier chain”（分类\n器链）。这个 chain 由 attach 到 classful qdisc 的所有 filter 构成。\u003c/p\u003e\n\n\u003cp\u003e还是前面那个例子（包最终到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:2\u003c/code\u003e）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e                    root 1:\n                      |\n                    _1:1_\n                   /  |  \\\n                  /   |   \\\n                 /    |    \\\n               10:   11:   12:\n              /   \\       /   \\\n           10:1  10:2   12:1  12:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e当 enqueue 一个包时，在每一个分叉的地方都需要查询相关的过滤规则。\u003c/p\u003e\n\n\u003cp\u003e一种典型的配置是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e 配置一个 filter，将包送到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:\u003c/code\u003e 配置一个 filter，将包送到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e12:2\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e另外一种配置：将两个 filters 都配置在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1:1\u003c/code\u003e，但\u003cstrong\u003e将更精确的 filter 下放到更下面\n的位置有助于提升性能\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e需要注意的是，包是无法向上过滤的（filter a packet ‘upwards’）。\n另外，\u003cstrong\u003e使用 HTB 时，所有的 filters 必须 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eroot\u003c/code\u003e！\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e包只能向下 enqueue！当 dequeue 时，它们会重新上来，到达要发送它的网络接口。\n包并不是一路向下，最后从叶子节点到达网卡的！\u003c/p\u003e\n\n\u003ch3 id=\"961-一些简单的流量过滤filtering示例\"\u003e9.6.1 一些简单的流量过滤（filtering）示例\u003c/h3\u003e\n\n\u003cp\u003e正如在 Classifier 章节中介绍的，匹配语法非常复杂，但功能强大，可以对几乎任\n何东西进行匹配。\u003c/p\u003e\n\n\u003cp\u003e这里先从简单的开始。假设有一个名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePRIO\u003c/code\u003e qdisc，其中包含了三个\nclass，我们想将所有端口 22 的流量都导向优先级最高的 band，那 filters 将如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 protocol ip parent 10: prio 1 u32 match \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  ip dport 22 0xffff flowid 10:1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 protocol ip parent 10: prio 1 u32 match \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  ip sport 80 0xffff flowid 10:1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 protocol ip parent 10: prio 2 flowid 10:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这几行命令是什么意思？第一条命令：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc filter add dev eth0\u003c/code\u003e：attach 到 eth0 设备。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eparent 10:\u003c/code\u003e：父设备是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprio 1\u003c/code\u003e：优先级为 1（数字越小，优先级越高）。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu32 match ip dport 22 0xffff\u003c/code\u003e filter：精确匹配 dst port 22，并将匹配的包发送到 band \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:1\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e第二条命令与第一条类似，不过匹配的源端口 80。第三条命令表示所有未匹配到上面的包\n，都发送到优先级次高的 band \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10:2\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e上面的命令中需要指定网络接口（interface），因为每个接口都有自己独立的 handle 空间。\u003c/p\u003e\n\n\u003cp\u003e要\u003cstrong\u003e精确匹配单个 IP 地址\u003c/strong\u003e，使用下面的命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  match ip dst 4.3.2.1/32 flowid 10:1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  match ip src 1.2.3.4/32 flowid 10:1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 protocol ip parent 10: prio 2      \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  flowid 10:2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这会将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip=4.3.2.1\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_ip=1.2.3.4\u003c/code\u003e 的流量送到优先级最高的队列，其他流量\n送到优先级次高的队列。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e还可以将多个 match 级联起来，同时匹配源 IP 和 port\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 10:0 protocol ip prio 1 u32 match ip src 4.3.2.1/32 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  match ip sport 80 0xffff flowid 10:1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"962-常用-filtering-命令\"\u003e9.6.2 常用 filtering 命令\u003c/h3\u003e\n\n\u003cp\u003e大部分整形的命令都会以这样的命令开头：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth0 parent 1:0 protocol ip prio 1 u32 ..\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这种是所谓的 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu32\u003c/code\u003e 匹配\u003c/strong\u003e，特点是能匹配包的任何部分：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e匹配源/目的 IP 地址\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ematch ip src 1.2.3.0/24\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ematch ip dst 4.3.2.0/24\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e匹配单个 IP：指定掩码 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/32\u003c/code\u003e，或者直接省略掩码部分\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e匹配源/目的端口，任何 IP 协议\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ematch ip sport 80 0xffff\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ematch ip dport 80 0xffff\u003c/code\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e匹配 ip protocol（tcp, udp, icmp, gre, ipsec）\u003c/p\u003e\n\n    \u003cp\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/protocols\u003c/code\u003e 里面的协议号，例如，ICMP 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ematch ip protocol 1 0xff\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e匹配 fwmark\u003c/p\u003e\n\n    \u003cp\u003e可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipchains\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eiptables\u003c/code\u003e 等工具对包打标（mark），这些 mark 在不同接口\n  之间路由时是不会丢失的（survive routing across interfaces）。这非常有用，例\n  如，实现“只对从 eth0 进入 eth1 的流量进行整形”的功能。语法：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev eth1 protocol ip parent 1:0 prio 1 handle 6 fw flowid 1:1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e注意这里用的已经不是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu32\u003c/code\u003e 匹配了！\u003c/p\u003e\n\n    \u003cp\u003e对包打标（mark）：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eiptables \u003cspan class=\"nt\"\u003e-A\u003c/span\u003e PREROUTING \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e mangle \u003cspan class=\"nt\"\u003e-i\u003c/span\u003e eth0 \u003cspan class=\"nt\"\u003e-j\u003c/span\u003e MARK \u003cspan class=\"nt\"\u003e--set-mark\u003c/span\u003e 6\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e上面的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e6\u003c/code\u003e 只是本例随便设置的一个数字，可以是任意值。\u003c/p\u003e\n\n    \u003cp\u003e如果不想理解完整的 tc filter 语法，那可以选择用 iptables 来打标，根据fwmark 完成分类功能。\u003c/p\u003e\n\n    \u003cp\u003eiptables 还可以打印统计信息，有助于判断你设置的规则是否生效。下面的命令会打\n  印 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emangle\u003c/code\u003e 表内所有的 mark 规则，已经每个规则已经匹配到多少包和字节数：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eiptables \u003cspan class=\"nt\"\u003e-L\u003c/span\u003e \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e mangle \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e \u003cspan class=\"nt\"\u003e-v\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e匹配 TOS 字段\u003c/p\u003e\n\n    \u003cp\u003e选择交互式、最小延迟（interactive, minimum delay）流量：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev ppp0 parent 1:0 protocol ip prio 10 u32 \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n    match ip tos 0x10 0xff flowid 1:4\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e高吞吐流量（bulk traffic）对应的过滤条件是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x08 0xff\u003c/code\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e更多过滤相关的命令（filtering commands），见 Advanced Filters 章节。\u003c/p\u003e\n\n\u003ch1 id=\"97-imqintermediate-queueing-device中转排队设备\"\u003e9.7 IMQ（Intermediate queueing device，中转排队设备）\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003eIMQ 并不是一种 qdisc，但其使用是与 qdisc 紧密关联的\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e在 Linux 中，所有 qdisc都是 attach 到网络设备上的，\u003cstrong\u003e所有 enqueue 到设备的东西都\n是先 enqueue 到设备 qdisc 上\u003c/strong\u003e。从概念上来说，这会存在两个限制：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e只有出方向（egress）能做整形\u003c/strong\u003e：入方向的 qdisc 实际上也是有的，但与\nclassful qdiscs 相比，其发挥空间非常有限。\u003c/li\u003e\n  \u003cli\u003e任何一个 qdisc 只能看到一个接口（interface）的流量，\u003cstrong\u003e没有全局限流功能\u003c/strong\u003e（global\nlimitations can’t be placed）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003eIMQ 就是用来解决以上两点限制的\u003c/strong\u003e。简单来说，你可以将选中的任何东西放到 qdisc\n里面。打了标的包在经过 netfilter \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNF_IP_PRE_ROUTING\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNF_IP_POST_ROUTING\u003c/code\u003e\nhook 点时会被捕获，送到 IMQ 设备上 attach 的 qdisc。\u003c/p\u003e\n\n\u003cp\u003e因此对外部进来的包先打上标记（mark），就能实现\u003cstrong\u003e入向整型\u003c/strong\u003e（ingress shaping），\n；将接口们作为 classes（treat interfaces as classes），就能设置\u003cstrong\u003e全局限速\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e你还可以做很多其他事情，例如将 http 流量放到一个 qdisc，将新连接请求放到另一个\nqdisc，等等。\u003c/p\u003e\n\n\u003ch3 id=\"971-示例配置\"\u003e9.7.1 示例配置\u003c/h3\u003e\n\n\u003cp\u003e首先能想到的例子就是用入向整形（ingress shaping）给自己一个受保证的高带宽 ;)\u003c/p\u003e\n\n\u003cp\u003e配置如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev imq0 root handle 1: htb default 20\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev imq0 parent 1: classid 1:1 htb rate 2mbit burst 15k\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev imq0 parent 1:1 classid 1:10 htb rate 1mbit\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc class add dev imq0 parent 1:1 classid 1:20 htb rate 1mbit\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev imq0 parent 1:10 handle 10: pfifo\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev imq0 parent 1:20 handle 20: sfq\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev imq0 parent 10:0 protocol ip prio 1 u32 match \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n  ip dst 10.0.0.230/32 flowid 1:10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个例子用的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu32\u003c/code\u003e 做分类，用其他分类器也行。\u003c/p\u003e\n\n\u003cp\u003e接下来，需要选中流量，给它们打上标记，以便能被正确送到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimq0\u003c/code\u003e 设备：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ iptables -t mangle -A PREROUTING -i eth0 -j IMQ --todev 0\n\n$ ip link set imq0 up\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 mangle 表内的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePREROUTING\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOSTROUTING\u003c/code\u003e chain，IMQ 都是有效的 target。\n语法：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eIMQ [ --todev n ]\tn : number of imq device\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意，流量并不是在命中 target 的时候放入 imq 队列的，而是在更后面一点（not\nenqueued when the target is hit but afterwards）。流量进入 imq 设备的精确位置与\n流量方向（in/out）有关。下面这些是预定义的 netfilter hooks，iptables 会用到它们：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003enf_ip_hook_priorities\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_FIRST\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eINT_MIN\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_CONNTRACK\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e200\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_MANGLE\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e150\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_NAT_DST\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_FILTER\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_NAT_SRC\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e100\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eNF_IP_PRI_LAST\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eINT_MAX\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对于 ingress 流量，imq 会将自己注册为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNF_IP_PRI_MANGLE + 1\u003c/code\u003e 优先级，这意味包\n经过 PREROUTING chain 之后就会直接进入 imq 设备后。\u003c/li\u003e\n  \u003cli\u003e对于 egress 流量，imq 使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNF_IP_PRI_LAST\u003c/code\u003e，which honours the fact that packets dropped by the filter table won’t occupy bandwidth.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIMQ patch 及其更多信息见 \u003ca href=\"http://luxik.cdi.cz/~patrick/imq/\"\u003e\u003cdel\u003eIMQ 网站\u003c/del\u003e\u003c/a\u003e（原始\n链接已失效，可移步参考\u003ca href=\"https://github.com/imq/linuximq\"\u003e这篇\u003c/a\u003e，译者注）。\u003c/p\u003e\n\n\u003ch1 id=\"扩展阅读译注\"\u003e扩展阅读（译注）\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"http://linux-ip.net/articles/Traffic-Control-HOWTO/classless-qdiscs.html\"\u003eTraffic-Control-HOWTO, linux-ip.net\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://softwareopal.com/qos/default.php?p=ds-23\"\u003ePractical IP Network QoS\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/traffic-control-from-queue-to-edt-zh/\"\u003e(译) 流量控制（TC）五十年：从基于缓冲队列（Queue）到基于时间戳（EDT）的演进（Google, 2018）\u003c/a\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/cilium-life-of-a-packet-pod-to-service/\"\u003e\u003cspan\u003e« Life of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/trip-stepping-into-cloud-native-networking-era-zh/\"\u003e\u003cspan\u003e迈入 Cilium+BGP 的云原生网络时代 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-10-08T00:00:00Z",
  "Author": "Arthur Chiao"
}