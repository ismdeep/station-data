{
  "Source": "arthurchiao.art",
  "Title": "图解 JuiceFS CSI 工作流：K8s 创建带 PV 的 Pod 时，背后发生了什么（2024）",
  "Link": "https://arthurchiao.art/blog/k8s-juicefs-csi-workflow-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e图解 JuiceFS CSI 工作流：K8s 创建带 PV 的 Pod 时，背后发生了什么（2024）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2024-07-13 | Last Update 2024-07-13\u003c/p\u003e\n  \n  \u003cp\u003eJuiceFS 是一个架设在\u003cstrong\u003e\u003cmark\u003e对象存储\u003c/mark\u003e\u003c/strong\u003e（S3、Ceph、OSS 等）之上的分布式\u003cstrong\u003e\u003cmark\u003e文件系统\u003c/mark\u003e\u003c/strong\u003e，\n简单来说，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对象存储：只能通过 key/value 方式使用；\u003c/li\u003e\n  \u003cli\u003e文件系统：日常看到的文件目录，能执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003els/cat/find/truncate\u003c/code\u003e 等等之类的\u003cstrong\u003e\u003cmark\u003e文件读写\u003c/mark\u003e\u003c/strong\u003e操作。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e本文从 high-level 梳理了 JuiceFS CSI 方案中，当创建一个带 PV 的 pod 以及随后 pod 读写 PV 时，\nk8s/juicefs 组件在背后都做了什么，方便快速了解 K8s CSI 机制及 JuiceFS 的基本工作原理。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-setup-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e水平及维护精力所限，文中不免存在错误或过时之处，请酌情参考。\n\u003cstrong\u003e\u003cmark\u003e传播知识，尊重劳动，年满十八周岁，转载请注明\u003ca href=\"https://arthurchiao.art\"\u003e出处\u003c/a\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-背景知识\" id=\"markdown-toc-1-背景知识\"\u003e1 背景知识\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-k8s-csi-container-storage-interface-\" id=\"markdown-toc-11-k8s-csi-container-storage-interface-\"\u003e1.1 K8s CSI (Container Storage Interface )\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-fuse-filesystem-in-userspace\" id=\"markdown-toc-12-fuse-filesystem-in-userspace\"\u003e1.2 FUSE (Filesystem in Userspace)\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-juicefs-三种工作模式\" id=\"markdown-toc-13-juicefs-三种工作模式\"\u003e1.3 JuiceFS 三种工作模式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-小结\" id=\"markdown-toc-14-小结\"\u003e1.4 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-创建一个使用-pv-的-pod-时k8s-和-juicefs-组件都做了什么\" id=\"markdown-toc-2-创建一个使用-pv-的-pod-时k8s-和-juicefs-组件都做了什么\"\u003e2 创建一个使用 PV 的 pod 时，k8s 和 juicefs 组件都做了什么\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#step-1kubelet-启动监听集群的-pod-资源变化\" id=\"markdown-toc-step-1kubelet-启动监听集群的-pod-资源变化\"\u003eStep 1：kubelet 启动，监听集群的 pod 资源变化\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-2kubelet-收到业务-pod-创建事件开始创建-pod\" id=\"markdown-toc-step-2kubelet-收到业务-pod-创建事件开始创建-pod\"\u003eStep 2：kubelet 收到业务 pod 创建事件，\u003cstrong\u003e\u003cmark\u003e开始创建\u003c/mark\u003e\u003c/strong\u003e pod\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#step-21-创建业务-pod初始化部分\" id=\"markdown-toc-step-21-创建业务-pod初始化部分\"\u003eStep 2.1 创建业务 pod：初始化部分\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#step-22-处理-pod-依赖的-volumes\" id=\"markdown-toc-step-22-处理-pod-依赖的-volumes\"\u003eStep 2.2 处理 pod 依赖的 volumes\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-3kubelet----csi-pluginjuicefssetup-pv\" id=\"markdown-toc-step-3kubelet----csi-pluginjuicefssetup-pv\"\u003eStep 3：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubelet --\u0026gt; CSI plugin\u003c/code\u003e（juicefs）：setup PV\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-4juicefs-csi-plugin-具体工作\" id=\"markdown-toc-step-4juicefs-csi-plugin-具体工作\"\u003eStep 4：JuiceFS CSI plugin 具体工作\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#step-41-给-pod-pv-创建挂载路径初始化-volume\" id=\"markdown-toc-step-41-给-pod-pv-创建挂载路径初始化-volume\"\u003eStep 4.1 给 pod PV 创建挂载路径，初始化 volume\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#step-42-volume-挂载信息写入-metaserver\" id=\"markdown-toc-step-42-volume-挂载信息写入-metaserver\"\u003eStep 4.2 volume 挂载信息写入 MetaServer\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#step-43-juicefs-plugin如果-client-pod-不存在就创建一个\" id=\"markdown-toc-step-43-juicefs-plugin如果-client-pod-不存在就创建一个\"\u003eStep 4.3 JuiceFS plugin：如果 client pod 不存在，就创建一个\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-5kubelet-监听到-client-pod-创建事件\" id=\"markdown-toc-step-5kubelet-监听到-client-pod-创建事件\"\u003eStep 5：kubelet 监听到 client pod 创建事件\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-6kubelet-创建-client-pod\" id=\"markdown-toc-step-6kubelet-创建-client-pod\"\u003eStep 6：kubelet 创建 client pod\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-7client-pod-初始化fuse-挂载\" id=\"markdown-toc-step-7client-pod-初始化fuse-挂载\"\u003eStep 7：client pod 初始化、FUSE 挂载\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-8kubelet-创建业务-pod完成后续部分\" id=\"markdown-toc-step-8kubelet-创建业务-pod完成后续部分\"\u003eStep 8：kubelet 创建业务 pod：完成后续部分\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#小结\" id=\"markdown-toc-小结\"\u003e小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-业务-pod-读写-juicefs-volume-流程\" id=\"markdown-toc-3-业务-pod-读写-juicefs-volume-流程\"\u003e3 业务 pod 读写 juicefs volume 流程\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#step-1pod-读写文件rw-operations\" id=\"markdown-toc-step-1pod-读写文件rw-operations\"\u003eStep 1：pod 读写文件（R/W operations）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-2rw-请求被-fuse-模块-hook转给-juicefs-client-处理\" id=\"markdown-toc-step-2rw-请求被-fuse-模块-hook转给-juicefs-client-处理\"\u003eStep 2：R/W 请求被 FUSE 模块 hook，转给 juicefs client 处理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-3juicefs-client-pod-从-meta-server-读取文件或目录的元数据\" id=\"markdown-toc-step-3juicefs-client-pod-从-meta-server-读取文件或目录的元数据\"\u003eStep 3：juicefs client pod 从 meta server 读取（文件或目录的）元数据\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#step-4juicefs-client-pod-从-object-store-读写文件\" id=\"markdown-toc-step-4juicefs-client-pod-从-object-store-读写文件\"\u003eStep 4：juicefs client pod 从 object store 读写文件\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-总结\" id=\"markdown-toc-4-总结\"\u003e4 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-背景知识\"\u003e1 背景知识\u003c/h1\u003e\n\n\u003cp\u003e简单列几个基础知识，有背景的可直接跳过。\u003c/p\u003e\n\n\u003ch2 id=\"11-k8s-csi-container-storage-interface-\"\u003e1.1 K8s CSI (Container Storage Interface )\u003c/h2\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThe Container Storage Interface (CSI) is a standard for exposing arbitrary\nblock and file storage systems to containerized workloads on Container\nOrchestration Systems (COs) like Kubernetes.\u003c/p\u003e\n\n  \u003cp\u003ehttps://kubernetes-csi.github.io/docs/\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eCSI 是 K8s 支持的一种容器存储机制，扩展性非常好，\n各存储方案只要根据规范实现一些接口，就能集成到 k8s 中提供存储服务。\u003c/p\u003e\n\n\u003cp\u003e一般来说，存储方案需要在每个 node 上部署一个称为 “\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCSI plugin\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e” 的服务，\nkubelet 在创建带 PV 容器的过程中会调用这个 plugin。但要注意，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eK8s 的\u003cstrong\u003e\u003cmark\u003e网络插件\u003c/mark\u003e\u003c/strong\u003e CNI plugin 是一个\u003cstrong\u003e\u003cmark\u003e可执行文件\u003c/mark\u003e\u003c/strong\u003e，\n放在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/opt/cni/bin/\u003c/code\u003e 下面就行了，kubelet 在创建 pod 网络时\u003cstrong\u003e\u003cmark\u003e直接运行\n\u003c/mark\u003e\u003c/strong\u003e这个可执行文件；\u003c/li\u003e\n  \u003cli\u003eK8s 的\u003cstrong\u003e\u003cmark\u003e存储插件\u003c/mark\u003e\u003c/strong\u003e CSI plugin 是一个\u003cstrong\u003e\u003cmark\u003e服务\u003c/mark\u003e\u003c/strong\u003e（某种程度上，\n称为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eagent\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 更好理解），kubelet 在初始化\nPV 时通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003egRPC\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 调用这个 plugin；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"12-fuse-filesystem-in-userspace\"\u003e1.2 FUSE (Filesystem in Userspace)\u003c/h2\u003e\n\n\u003cp\u003eFUSE 是一种用户态文件系统，使得用户开发自己的文件系统非常方便。\u003c/p\u003e\n\n\u003cp\u003e懒得再重新画图，\n这里借 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elxcfs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（跟 juicefs 没关系，但也是一种 FUSE\n文件系统）展示一下 \u003cstrong\u003e\u003cmark\u003eFUSE 的基本工作原理\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"/blog/linux-container-and-runtime-zh/\"\u003eLinux 容器底层工作机制：从 500 行 C 代码到生产级容器运行时（2023）\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-container-and-runtime/lxcfs-fuse.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. lxcfs/fuse workflow: how a read operation is handled [2]\u003c/p\u003e\n\n\u003cp\u003eJuiceFS 基于 FUSE 实现了一个用户态文件系统。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e来自社区文档的一段内容，简单整理：\u003c/p\u003e\n\n  \u003cp\u003e传统上，实现一个 FUSE 文件系统，需要基于 Linux libfuse 库，它提供两种 API：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\n      \u003cp\u003ehigh-level API：\u003cstrong\u003e\u003cmark\u003e基于文件名和路径\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n      \u003cp\u003elibfuse 内部做了 VFS 树的模拟，对外暴露基于路径的 API。\u003c/p\u003e\n\n      \u003cp\u003e适合元数据本身是基于路径提供的 API 的系统，比如 HDFS 或者 S3 之类。\n如果元数据本身是基于 inode 的目录树，这种 inode → path →inode 的转换就会\n影响性能。\u003c/p\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\n      \u003cp\u003elow-level API：\u003cstrong\u003e\u003cmark\u003e基于 inode\u003c/mark\u003e\u003c/strong\u003e。内核的 VFS 跟 FUSE 库交互就使用 low-level API。\u003c/p\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003eJuiceFS 的\u003cstrong\u003e\u003cmark\u003e元数据基于 inode 组织\u003c/mark\u003e\u003c/strong\u003e，所以用 low-level API 实现（\n依赖 go-fuse 而非 libfuse），简单自然，性能好。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"13-juicefs-三种工作模式\"\u003e1.3 JuiceFS 三种工作模式\u003c/h2\u003e\n\n\u003cp\u003eJuiceFS 有几种工作或部署方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e进程挂载模式\u003c/p\u003e\n\n    \u003cp\u003eJuiceFS client 运行在 CSI Node plugin 容器中，所有需要挂载的 JuiceFS PV 都会在这个容器内以进程模式挂载。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eCSI 方式，又可分为两种：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\n        \u003cp\u003emountpod 方式：在每个 node 上，CSI plugin 动态为每个\u003cstrong\u003e\u003cmark\u003e被 local pod 使用的 PV\u003c/mark\u003e\u003c/strong\u003e 创建一个保姆 pod，\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e\n            \u003cp\u003e这个 mount pod 是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eper-PV\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 而非 per-business-pod 的，\n也就是说如果 node 上有\u003cstrong\u003e\u003cmark\u003e多个业务 pod 在使用同一 PV，那只会有一个 mount pod\u003c/mark\u003e\u003c/strong\u003e，\n下图可以看出来，\u003c/p\u003e\n\n            \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-setup-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n            \u003cp align=\"center\"\u003eFig. JuiceFS as K8s CSI solution: workflow when a business pod is created (JuiceFS mountpod mode).\u003c/p\u003e\n          \u003c/li\u003e\n          \u003cli\u003emount pod 里面装了 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ejuicefs client\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，替业务 pod 完成 juicefs 相关的读写操作；\n为了从字面上更容易理解，本文接下来把 mount pod 称为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003edynamic client pod\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 或 client pod。\u003c/li\u003e\n          \u003cli\u003e这是 JuiceFS CSI 的\u003cstrong\u003e\u003cmark\u003e默认工作方式\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n          \u003cli\u003eFUSE 需要 mount pod 具有 privilege 权限；\u003c/li\u003e\n          \u003cli\u003eclient pod 重启会导致业务 pod 一段时间读写不可用，但 client pod 好了之后业务 pod 就能继续读写了。\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003cp\u003e. CSI sidecar 方式：给每个使用 juicefs PV 的业务 pod 创建一个 sidecar 容器。\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eper-pod\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 级别的 sidecar；\u003c/li\u003e\n          \u003cli\u003e注意 sidecar 就不是 JuiceFS plugin 创建的了，CSI Controller 会注册一个 Webhook 来监听容器变动，在创建 pod 时，\nwebhook 给 pod yaml 自动注入一个 sidecar，跟 Istio 自动给 pod 注入 Envoy 容器类似；\u003c/li\u003e\n          \u003cli\u003eSidecar 重启需要重建业务 Pod 才能恢复。\u003c/li\u003e\n          \u003cli\u003e也依赖 FUSE，所以 sidecar 需要 privilege 权限。这会导致\u003cstrong\u003e\u003cmark\u003e每个 sidecar 都能看到 node 上所有设备\u003c/mark\u003e\u003c/strong\u003e，有风险，所以不建议；\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"14-小结\"\u003e1.4 小结\u003c/h2\u003e\n\n\u003cp\u003e有了以上基础，接下来看 k8s 中创建一个业务 pod 并且它要求挂载一个 PV 时，k8s 和 juicefs 组件都做了什么事情。\u003c/p\u003e\n\n\u003ch1 id=\"2-创建一个使用-pv-的-pod-时k8s-和-juicefs-组件都做了什么\"\u003e2 创建一个使用 PV 的 pod 时，k8s 和 juicefs 组件都做了什么\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-setup-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS as K8s CSI solution: workflow when a business pod is created (JuiceFS mountpod mode).\u003c/p\u003e\n\n\u003ch2 id=\"step-1kubelet-启动监听集群的-pod-资源变化\"\u003eStep 1：kubelet 启动，监听集群的 pod 资源变化\u003c/h2\u003e\n\n\u003cp\u003ekubelet 作为 k8s 在每个 node 上的 agent，在启动后会监听整个 k8s 集群中的 pod 资源变化。\n具体来说就是，kube-apiserver 中有 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epod create/update/delete events\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 发生时，kubelet 都会立即收到。\u003c/p\u003e\n\n\u003ch2 id=\"step-2kubelet-收到业务-pod-创建事件开始创建-pod\"\u003eStep 2：kubelet 收到业务 pod 创建事件，\u003cstrong\u003e\u003cmark\u003e开始创建\u003c/mark\u003e\u003c/strong\u003e pod\u003c/h2\u003e\n\n\u003cp\u003ekubelet 收到一条 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epod create\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 事件后，首先判断这个\npod 是否在自己的管辖范围内（spec 中的 \u003cstrong\u003e\u003cmark\u003enodeName 是否是这台 node\u003c/mark\u003e\u003c/strong\u003e），\n是的话就\u003cstrong\u003e\u003cmark\u003e开始创建这个 pod\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"step-21-创建业务-pod初始化部分\"\u003eStep 2.1 创建业务 pod：初始化部分\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ekubelet.INFO\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 中有比较详细的日志：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e10:05:57.410  Receiving a new pod \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n10:05:57.411  SyncLoop (ADD, \u0026#34;api\u0026#34;): \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n10:05:57.411  Needs to allocate 2 \u0026#34;nvidia.com/gpu\u0026#34; for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; container \u0026#34;container1\u0026#34;\n10:05:57.411  Needs to allocate 1 \u0026#34;our-corp.com/ip\u0026#34; for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; container \u0026#34;container1\u0026#34;\n10:05:57.413  Cgroup has some missing paths: [/sys/fs/cgroup/pids/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/systemd/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpuset/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/memory/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/hugetlb/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt;]\n10:05:57.413  Cgroup has some missing paths: [/sys/fs/cgroup/memory/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/systemd/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/hugetlb/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/pids/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpuset/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt;]\n10:05:57.413  Cgroup has some missing paths: [/sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/pids/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpuset/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/systemd/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/memory/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/cpu,cpuacct/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt; /sys/fs/cgroup/hugetlb/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt;]\n10:05:57.415  Using factory \u0026#34;raw\u0026#34; for container \u0026#34;/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt;\u0026#34;\n10:05:57.415  Added container: \u0026#34;/kubepods/burstable/pod\u0026lt;pod1-id\u0026gt;\u0026#34; (aliases: [], namespace: \u0026#34;\u0026#34;)\n10:05:57.419  Waiting for volumes to attach and mount for pod \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n\n10:05:57.432  SyncLoop (RECONCILE, \u0026#34;api\u0026#34;): \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n\n10:05:57.471  Added volume \u0026#34;meminfo\u0026#34; (volSpec=\u0026#34;meminfo\u0026#34;) for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; to desired state.\n10:05:57.471  Added volume \u0026#34;cpuinfo\u0026#34; (volSpec=\u0026#34;cpuinfo\u0026#34;) for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; to desired state.\n10:05:57.471  Added volume \u0026#34;stat\u0026#34; (volSpec=\u0026#34;stat\u0026#34;) for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; to desired state.\n10:05:57.480  Added volume \u0026#34;share-dir\u0026#34; (volSpec=\u0026#34;pvc-6ee43741-29b1-4aa0-98d3-5413764d36b1\u0026#34;) for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; to desired state.\n10:05:57.484  Added volume \u0026#34;data-dir\u0026#34; (volSpec=\u0026#34;juicefs-volume1-pv\u0026#34;) for pod \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34; to desired state.\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看出里面会依次处理 pod 所需的各种资源：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e设备：例如 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eGPU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003eIP 地址；\u003c/li\u003e\n  \u003cli\u003ecgroup 资源隔离配置；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003evolumes\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e本文主要关注 volume 资源。\u003c/p\u003e\n\n\u003ch3 id=\"step-22-处理-pod-依赖的-volumes\"\u003eStep 2.2 处理 pod 依赖的 volumes\u003c/h3\u003e\n\n\u003cp\u003e上面日志可以看到，业务 pod 里面声明了一些需要挂载的 volumes。\u003cstrong\u003e\u003cmark\u003e几种类型\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ehostpath 类型：直接把 node 路径挂载到容器内；\u003c/li\u003e\n  \u003cli\u003elxcfs 类型：为了解决资源视图问题 [2]；\u003c/li\u003e\n  \u003cli\u003e动态/静态 PV 类型\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e本文的 JuiceFS volume 就属于 PV 类型，继续看 kubelet 日志：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e# kubelet.INFO\n10:05:57.509  operationExecutor.VerifyControllerAttachedVolume started for volume \u0026#34;xxx\u0026#34;\n10:05:57.611  Starting operationExecutor.MountVolume for volume \u0026#34;xxx\u0026#34; (UniqueName: \u0026#34;kubernetes.io/host-path/\u0026lt;pod1-id\u0026gt;-xxx\u0026#34;) pod \u0026#34;pod1\u0026#34; (UID: \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34;) \n10:05:57.611  operationExecutor.MountVolume started for volume \u0026#34;juicefs-volume1-pv\u0026#34; (UniqueName: \u0026#34;kubernetes.io/csi/csi.juicefs.com^juicefs-volume1-pv\u0026#34;) pod \u0026#34;pod1\u0026#34; (UID: \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34;) \n10:05:57.611  kubernetes.io/csi: mounter.GetPath generated [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n10:05:57.611  kubernetes.io/csi: created path successfully [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv]\n10:05:57.611  kubernetes.io/csi: saving volume data file [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/vol_data.json]\n10:05:57.611  kubernetes.io/csi: volume data file saved successfully [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/vol_data.json]\n10:05:57.613  MountVolume.MountDevice succeeded for volume \u0026#34;juicefs-volume1-pv\u0026#34; (UniqueName: \u0026#34;kubernetes.io/csi/csi.juicefs.com^juicefs-volume1-pv\u0026#34;) pod \u0026#34;pod1\u0026#34; (UID: \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34;) device mount path \u0026#34;/var/lib/k8s/kubelet/plugins/kubernetes.io/csi/pv/juicefs-volume1-pv/globalmount\u0026#34;\n10:05:57.616  kubernetes.io/csi: mounter.GetPath generated [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n10:05:57.616  kubernetes.io/csi: Mounter.SetUpAt(/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount)\n10:05:57.616  kubernetes.io/csi: created target path successfully [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n10:05:57.618  kubernetes.io/csi: calling NodePublishVolume rpc [volid=juicefs-volume1-pv,target_path=/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n10:05:57.713  Starting operationExecutor.MountVolume for volume \u0026#34;juicefs-volume1-pv\u0026#34; (UniqueName: \u0026#34;kubernetes.io/csi/csi.juicefs.com^juicefs-volume1-pv\u0026#34;) pod \u0026#34;pod1\u0026#34; (UID: \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34;) \n...\n10:05:59.506  kubernetes.io/csi: mounter.SetUp successfully requested NodePublish [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n10:05:59.506  MountVolume.SetUp succeeded for volume \u0026#34;juicefs-volume1-pv\u0026#34; (UniqueName: \u0026#34;kubernetes.io/csi/csi.juicefs.com^juicefs-volume1-pv\u0026#34;) pod \u0026#34;pod1\u0026#34; (UID: \u0026#34;\u0026lt;pod1-id\u0026gt;\u0026#34;) \n10:05:59.506  kubernetes.io/csi: mounter.GetPath generated [/var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对于每个 volume，依次执行，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eoperationExecutor.\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eVerifyControllerAttachedVolume()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 方法，做一些检查；\u003c/li\u003e\n  \u003cli\u003eoperationExecutor.\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eMountVolume()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 方法，将指定的 volume 挂载到容器目录；\u003c/li\u003e\n  \u003cli\u003e对于 CSI 存储，还会调用到 CSI plugin 的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNodePublishVolume()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 方法，初始化对应的 PV，JuiceFS 就是这种模式。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e接下来 kubelet 会不断\u003cstrong\u003e\u003cmark\u003e检测所有 volumes 是否都挂载好\u003c/mark\u003e\u003c/strong\u003e，没好的话不会进入下一步（创建 sandbox 容器）。\u003c/p\u003e\n\n\u003ch2 id=\"step-3kubelet----csi-pluginjuicefssetup-pv\"\u003eStep 3：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubelet --\u0026gt; CSI plugin\u003c/code\u003e（juicefs）：setup PV\u003c/h2\u003e\n\n\u003cp\u003e下面进一步看一下 node CSI plugin 初始化 PV 挂载的逻辑。\u003cstrong\u003e\u003cmark\u003e调用栈\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e         gRPC NodePublishVolume()\nkubelet ---------------------------\u0026gt; juicefs node plugin (also called \u0026#34;driver\u0026#34;, etc)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"step-4juicefs-csi-plugin-具体工作\"\u003eStep 4：JuiceFS CSI plugin 具体工作\u003c/h2\u003e\n\n\u003cp\u003e看一下 JuiceFS CSI node plugin 的日志，这里直接在机器上看：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003edocker logs \u003cspan class=\"nt\"\u003e--timestamps\u003c/span\u003e k8s_juicefs-plugin_juicefs-csi-node-xxx | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ejuicefs-volume1\n10:05:57.619 NodePublishVolume: volume_id is juicefs-volume1-pv\n\n10:05:57.619 NodePublishVolume: creating \u003cspan class=\"nb\"\u003edir\u003c/span\u003e /var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount\n\n10:05:57.620 ceFormat cmd: \u003cspan class=\"o\"\u003e[\u003c/span\u003e/usr/local/bin/juicefs format \u003cspan class=\"nt\"\u003e--storage\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eOSS \u003cspan class=\"nt\"\u003e--bucket\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003exx \u003cspan class=\"nt\"\u003e--access-key\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003exx \u003cspan class=\"nt\"\u003e--secret-key\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003esecretkey\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e \u003cspan class=\"nt\"\u003e--token\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003etoken\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003emetaurl\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e juicefs-volume1]\n10:05:57.874 Format output is juicefs \u0026lt;INFO\u0026gt;: Meta address: tikv://node1:2379,node2:2379,node3:2379/juicefs-volume1\n10:05:57.874 cefs[1983] \u0026lt;INFO\u0026gt;: Data use oss://\u0026lt;bucket\u0026gt;/juicefs-volume1/\n\n10:05:57.875 Mount: mounting \u003cspan class=\"s2\"\u003e\u0026#34;tikv://node1:2379,node2:2379,node3:2379/juicefs-volume1\u0026#34;\u003c/span\u003e at \u003cspan class=\"s2\"\u003e\u0026#34;/jfs/juicefs-volume1-pv\u0026#34;\u003c/span\u003e with options \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u003cspan class=\"nv\"\u003etoken\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003exx]\n\n10:05:57.884 createOrAddRef: Need to create pod juicefs-node1-juicefs-volume1-pv.\n10:05:57.891 createOrAddRed: GetMountPodPVC juicefs-volume1-pv, err: %!s\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u0026lt;nil\u0026gt;\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n10:05:57.891 ceMount: mount tikv://node1:2379,node2:2379,node3:2379/juicefs-volume1 at /jfs/juicefs-volume1-pv\n10:05:57.978 createOrUpdateSecret: juicefs-node1-juicefs-volume1-pv-secret, juicefs-system\n10:05:59.500 waitUtilPodReady: Pod juicefs-node1-juicefs-volume1-pv is successful\n\n10:05:59.500 NodePublishVolume: binding /jfs/juicefs-volume1-pv at /var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount with options \u003cspan class=\"o\"\u003e[]\u003c/span\u003e\n10:05:59.505 NodePublishVolume: mounted juicefs-volume1-pv at /var/lib/k8s/kubelet/pods/\u0026lt;pod1-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount with options \u003cspan class=\"o\"\u003e[]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到确实执行了 \u003ca href=\"https://github.com/juicedata/juicefs-csi-driver/blob/v0.23.6/pkg/driver/node.go\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNodePublishVolume()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/a\u003e 方法，\n这个方法是\u003cstrong\u003e\u003cmark\u003e每个 CSI plugin 方案各自实现的\u003c/mark\u003e\u003c/strong\u003e，所以里面做什么事情就跟存储方案有很大关系。\n接下来具体看看 JuiceFS plugin 做的什么。\u003c/p\u003e\n\n\u003ch3 id=\"step-41-给-pod-pv-创建挂载路径初始化-volume\"\u003eStep 4.1 给 pod PV 创建挂载路径，初始化 volume\u003c/h3\u003e\n\n\u003cp\u003e默认配置下，每个 pod 会在 node 上对应一个存储路径，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ell /var/lib/k8s/kubelet/pods/\u0026lt;pod-id\u0026gt;\ncontainers/\netc-hosts\nplugins/\nvolumes/\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ejuicefs plugin 会在以上 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003evolumes/\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 目录内给 PV 创建一个对应的子目录和挂载点，\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003e/var/lib/k8s/kubelet/pods/{pod1-id}/\u003cmark\u003evolumes/kubernetes.io~csi/juicefs-volume1-pv\u003c/mark\u003e/mount\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e然后用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejuicefs\u003c/code\u003e 命令行工具\u003cstrong\u003e\u003cmark\u003e格式化\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e/usr/local/bin/juicefs format \u003cspan class=\"nt\"\u003e--storage\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eOSS \u003cspan class=\"nt\"\u003e--bucket\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003exx \u003cspan class=\"nt\"\u003e--access-key\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003exx \u003cspan class=\"nt\"\u003e--secret-key\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003esecretkey\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e \u003cspan class=\"nt\"\u003e--token\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003etoken\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003emetaurl\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e juicefs-volume1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e例如，如果 JuiceFS 对接的是\u003cstrong\u003e\u003cmark\u003e阿里云 OSS\u003c/mark\u003e\u003c/strong\u003e，上面就对应阿里云的 bucket 地址及访问秘钥。\u003c/p\u003e\n\n\u003ch3 id=\"step-42-volume-挂载信息写入-metaserver\"\u003eStep 4.2 volume 挂载信息写入 MetaServer\u003c/h3\u003e\n\n\u003cp\u003e此外，还会把这个挂载信息同步到 JuiceFS 的 MetaServer，这里用的是 TiKV，暂不展开：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-setup-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS as K8s CSI solution: workflow when a business pod is created (JuiceFS mountpod mode).\u003c/p\u003e\n\n\u003ch3 id=\"step-43-juicefs-plugin如果-client-pod-不存在就创建一个\"\u003eStep 4.3 JuiceFS plugin：如果 client pod 不存在，就创建一个\u003c/h3\u003e\n\n\u003cp\u003eJuiceFS CSI plugin 判断这个 PV 在 node 上是否已经存在 client pod，如果不存在，就创建一个；存在就不用再创建了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e当 node 上最后一个使用某 PV 的业务 pod 销毁后，对应的 client pod 也会被 juicefs CSI plugin 自动删掉。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e我们这个环境用的是 dynamic client pod 方式，因此会看到如下日志：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003edocker logs \u003cspan class=\"nt\"\u003e--timestamps\u003c/span\u003e \u0026lt;csi plugin container\u0026gt; | \u003cspan class=\"nb\"\u003egrep\u003c/span\u003e \n...\n10:05:57.884 createOrAddRef: Need to create pod juicefs-node1-juicefs-volume1-pv.\n10:05:57.891 createOrAddRed: GetMountPodPVC juicefs-volume1-pv, err: %!s\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u0026lt;nil\u0026gt;\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n10:05:57.891 ceMount: mount tikv://node1:2379,node2:2379,node3:2379/juicefs-volume1 at /jfs/juicefs-volume1-pv\n10:05:57.978 createOrUpdateSecret: juicefs-node1-juicefs-volume1-pv-secret, juicefs-system\n10:05:59.500 waitUtilPodReady:\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eJuiceFS node plugin 会去 k8s 里面创建一个名为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ejuicefs-{node}-{volume}-pv\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的 dynamic client pod。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-setup-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS as K8s CSI solution: workflow when a business pod is created (JuiceFS mountpod mode).\u003c/p\u003e\n\n\u003ch2 id=\"step-5kubelet-监听到-client-pod-创建事件\"\u003eStep 5：kubelet 监听到 client pod 创建事件\u003c/h2\u003e\n\n\u003cp\u003e这时候 kubelet 的\u003cstrong\u003e\u003cmark\u003e业务 pod\u003c/mark\u003e\u003c/strong\u003e 还没创建好，“伺候”它的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ejuicefs client pod\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n又来“请求创建”了：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003egrep \u003c/span\u003ejuicefs-\u0026lt;node\u0026gt;-\u0026lt;volume\u0026gt;-pv /var/log/kubernetes/kubelet.INFO | \u003cspan class=\"nb\"\u003egrep\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;received \u0026#34;\u003c/span\u003e\n10:05:58.288 SyncPod received new pod \u003cspan class=\"s2\"\u003e\u0026#34;juicefs-node1-volume1-pv_juicefs-system\u0026#34;\u003c/span\u003e, will create a sandbox \u003cspan class=\"k\"\u003efor \u003c/span\u003eit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e所以接下来进入创建 juicefs dynamic client pod 的流程。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e兵马未动，粮草先行。juicefs client pod 没有好，\u003cstrong\u003e\u003cmark\u003e业务 pod 即使起来了也不能读写 juicefs volume\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"step-6kubelet-创建-client-pod\"\u003eStep 6：kubelet 创建 client pod\u003c/h2\u003e\n\n\u003cp\u003e创建 client pod 的流程跟业务 pod 是类似的，但这个 pod 比较简单，我们省略细节，认为它直接就拉起来了。\u003c/p\u003e\n\n\u003cp\u003e查看这个 client pod 内\u003cstrong\u003e\u003cmark\u003e运行的进程\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003edk top k8s_jfs-mount_juicefs-node1-juicefs-volume1-pv-xx\n/bin/mount.juicefs \u003cspan class=\"k\"\u003e${\u003c/span\u003e\u003cspan class=\"nv\"\u003emetaurl\u003c/span\u003e\u003cspan class=\"k\"\u003e}\u003c/span\u003e /jfs/juicefs-volume1-pv \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e enable-xattr,no-bgjob,allow_other,token\u003cspan class=\"o\"\u003e=\u003c/span\u003exxx,metrics\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.0.0.0:9567\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/bin/mount.juicefs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 其实只是个 alias，指向的就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejuicefs\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e可执行文件\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e(pod) $ ls -ahl /bin/mount.juicefs\n/bin/mount.juicefs -\u0026gt; /usr/local/bin/juicefs\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"step-7client-pod-初始化fuse-挂载\"\u003eStep 7：client pod 初始化、FUSE 挂载\u003c/h2\u003e\n\n\u003cp\u003e查看这个 client pod 干了什么：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eroot@node:~  \u003cspan class=\"c\"\u003e# dk top k8s_jfs-mount_juicefs-node1-juicefs-volume1-pv-xx\u003c/span\u003e\n\u0026lt;INFO\u0026gt;: Meta address: tikv://node1:2379,node2:2379,node3:2379/juicefs-volume1\n\u0026lt;INFO\u0026gt;: Data use oss://\u0026lt;oss-bucket\u0026gt;/juicefs-volume1/\n\u0026lt;INFO\u0026gt;: Disk cache \u003cspan class=\"o\"\u003e(\u003c/span\u003e/var/jfsCache/\u0026lt;\u003cspan class=\"nb\"\u003eid\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e/\u003cspan class=\"o\"\u003e)\u003c/span\u003e: capacity \u003cspan class=\"o\"\u003e(\u003c/span\u003e10240 MB\u003cspan class=\"o\"\u003e)\u003c/span\u003e, free ratio \u003cspan class=\"o\"\u003e(\u003c/span\u003e10%\u003cspan class=\"o\"\u003e)\u003c/span\u003e, max pending pages \u003cspan class=\"o\"\u003e(\u003c/span\u003e15\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u0026lt;INFO\u0026gt;: Create session 667 OK with version: admin-1.2.1+2022-12-22.34c7e973\n\u0026lt;INFO\u0026gt;: listen on 0.0.0.0:9567\n\u0026lt;INFO\u0026gt;: Mounting volume juicefs-volume1 at /jfs/juicefs-volume1-pv ...\n\u0026lt;INFO\u0026gt;: OK, juicefs-volume1 is ready at /jfs/juicefs-volume1-pv\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003col\u003e\n  \u003cli\u003e初始化本地 volume 配置\u003c/li\u003e\n  \u003cli\u003e与 MetaServer 交互\u003c/li\u003e\n  \u003cli\u003e暴露 prometheus metrics\u003c/li\u003e\n  \u003cli\u003e以 juicefs 自己的 mount 实现（前面看到的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/bin/mount.juicefs\u003c/code\u003e），将 volume\n挂载到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/jfs/juicefs-volume1-pv\u003c/code\u003e，默认对应的是\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/var/lib/juicefs/volume/juicefs-volume1-pv\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e此时在 node 上就可以看到如下的\u003cstrong\u003e\u003cmark\u003e挂载信息\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/mounts | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eJuiceFS:juicefs-volume1\nJuiceFS:juicefs-volume1 /var/lib/juicefs/volume/juicefs-volume1-pv fuse.juicefs rw,relatime,user_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,group_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,default_permissions,allow_other 0 0\nJuiceFS:juicefs-volume1 /var/lib/k8s/kubelet/pods/\u0026lt;pod-id\u0026gt;/volumes/kubernetes.io~csi/juicefs-volume1-pv/mount fuse.juicefs rw,relatime,user_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,group_id\u003cspan class=\"o\"\u003e=\u003c/span\u003e0,default_permissions,allow_other 0 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003efuse.juicefs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 方式的挂载。\n忘了 FUSE 基本工作原理的，再来借 lxcfs 快速回忆一下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-container-and-runtime/lxcfs-fuse.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. lxcfs/fuse workflow: how a read operation is handled [2]\u003c/p\u003e\n\n\u003cp\u003e这个 dynamic client pod 创建好之后，\n\u003cstrong\u003e\u003cmark\u003e业务 pod（此时还不存在）的读写操作\u003c/mark\u003e\u003c/strong\u003e都会进入 FUSE 模块，\n然后转发给用户态的 juicefs client 处理。juicefs client 针对不同的 object store 实现了对应的读写方法。\u003c/p\u003e\n\n\u003ch2 id=\"step-8kubelet-创建业务-pod完成后续部分\"\u003eStep 8：kubelet 创建业务 pod：完成后续部分\u003c/h2\u003e\n\n\u003cp\u003e至此，Pod 所依赖的 volumes 都处理好了，kubelet 就会打印一条日志：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# kubelet.INFO\u003c/span\u003e\n10:06:06.119  All volumes are attached and mounted \u003cspan class=\"k\"\u003efor \u003c/span\u003epod \u003cspan class=\"s2\"\u003e\u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e接下来就可以\u003cstrong\u003e\u003cmark\u003e继续创建业务 pod\u003c/mark\u003e\u003c/strong\u003e 了：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e# kubelet.INFO\n10:06:06.119  No sandbox for pod \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34; can be found. Need to start a new one\n10:06:06.119  Creating PodSandbox for pod \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n10:06:06.849  Created PodSandbox \u0026#34;885c3a\u0026#34; for pod \u0026#34;pod1(\u0026lt;pod1-id\u0026gt;)\u0026#34;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"小结\"\u003e小结\u003c/h2\u003e\n\n\u003cp\u003e更详细的 pod 创建过程，可以参考 [1]。\u003c/p\u003e\n\n\u003ch1 id=\"3-业务-pod-读写-juicefs-volume-流程\"\u003e3 业务 pod 读写 juicefs volume 流程\u003c/h1\u003e\n\n\u003cp\u003ejuicefs dynamic client pod 先于业务 pod 创建，所以业务 pod 创建好之后，就可以直接读写 juicefs PV (volume) 了，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-pod-read-write-workflow.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS as K8s CSI solution: workflow when a business pod reads/writes (JuiceFS mountpod mode).\u003c/p\u003e\n\n\u003cp\u003e这个过程可以大致分为四步。\u003c/p\u003e\n\n\u003ch2 id=\"step-1pod-读写文件rw-operations\"\u003eStep 1：pod 读写文件（R/W operations）\u003c/h2\u003e\n\n\u003cp\u003e例如在 pod 内进入 volume 路径（e.g. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecd /data/juicefs-pv-dir/\u003c/code\u003e），执行 ls、find 等等之类的操作。\u003c/p\u003e\n\n\u003ch2 id=\"step-2rw-请求被-fuse-模块-hook转给-juicefs-client-处理\"\u003eStep 2：R/W 请求被 FUSE 模块 hook，转给 juicefs client 处理\u003c/h2\u003e\n\n\u003cp\u003e直接贴两张官方的图略作说明 [3]，这两张图也透露了随后的 step 3 \u0026amp; 4 的一些信息：\u003c/p\u003e\n\n\u003cp\u003e读操作：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-internals-read.png\" width=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS Internals: read operations.\u003c/p\u003e\n\n\u003cp\u003e写操作：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/k8s-juicefs-csi/juicefs-internals-write.png\" width=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. JuiceFS Internals: write operations.\u003c/p\u003e\n\n\u003ch2 id=\"step-3juicefs-client-pod-从-meta-server-读取文件或目录的元数据\"\u003eStep 3：juicefs client pod 从 meta server 读取（文件或目录的）元数据\u003c/h2\u003e\n\n\u003cp\u003e上面的图中已经透露了一些 JuiceFS 的元数据设计，例如 chunk、slice、block 等等。\n读写操作时，client 会与 MetaServer 有相关的元信息交互。\u003c/p\u003e\n\n\u003ch2 id=\"step-4juicefs-client-pod-从-object-store-读写文件\"\u003eStep 4：juicefs client pod 从 object store 读写文件\u003c/h2\u003e\n\n\u003cp\u003e这一步就是去 S3 之类的 object store 去读写文件了。\u003c/p\u003e\n\n\u003ch1 id=\"4-总结\"\u003e4 总结\u003c/h1\u003e\n\n\u003cp\u003e以上就是使用 JuiceFS 作为 k8s CSI plugin 时，创建一个带 PV 的 pod 以及这个 pod 读写 PV 的流程。\n限于篇幅，省略了很多细节，感兴趣的可移步参考资料。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/what-happens-when-k8s-creates-pods-1-zh/\"\u003e源码解析：K8s 创建 pod 时，背后发生了什么（系列）（2021）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-container-and-runtime-zh/\"\u003eLinux 容器底层工作机制：从 500 行 C 代码到生产级容器运行时（2023）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://juicefs.com/docs/zh/community/internals/io_processing/\"\u003e官方文档：读写请求处理流程\u003c/a\u003e, juicefs.com\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://kubernetes-csi.github.io/docs/\"\u003ekubernetes-csi.github.io/docs/\u003c/a\u003e, K8s CSI documentation\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e\u003ca href=\"https://notbyai.fyi\"\u003e\u003cimg src=\"/assets/img/Written-By-Human-Not-By-AI-Badge-white.svg\" alt=\"Written by Human, Not by AI\"/\u003e\u003c/a\u003e\n\u003ca href=\"https://notbyai.fyi\"\u003e\u003cimg src=\"/assets/img/Written-By-Human-Not-By-AI-Badge-black.svg\" alt=\"Written by Human, Not by AI\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/tcp-requests-stuck-after-connection-established/\"\u003e\u003cspan\u003e« TCP Requests Stuck After Connection Established（2024）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/linux-clock-source-tsc-zh/\"\u003e\u003cspan\u003eLinux 时钟源之 TSC：软硬件原理、使用场景、已知问题（2024） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2024-07-13T00:00:00Z",
  "Author": "Arthur Chiao"
}