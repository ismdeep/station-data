{
  "Source": "arthurchiao.art",
  "Title": "[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）",
  "Link": "https://arthurchiao.art/blog/linux-socket-filtering-aka-bpf-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-08-27 | Last Update 2023-02-11\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2021 年 Linux \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.10\u003c/code\u003e 内核文档：\n\u003ca href=\"https://www.kernel.org/doc/html/v5.10/networking/filter.html\"\u003eLinux Socket Filtering aka Berkeley Packet Filter (BPF)\u003c/a\u003e，\n文档源码见 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/Documentation/networking/filter.rst\"\u003eDocumentation/networking/filter.rst\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003eLinux Socket Filtering (LSF) 是最初将 BSD 系统上的\u003cstrong\u003e\u003cmark\u003e数据包过滤技术\u003c/mark\u003e\u003c/strong\u003e\nBPF（伯克利包过滤器）移植到 Linux 系统时使用的名称，但后来大家还是更多称呼其为\nBPF（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaka\u003c/code\u003e：as known as）。本文介绍了 Linux BPF 的一些\n\u003cstrong\u003e\u003cmark\u003e底层设计和实现\u003c/mark\u003e\u003c/strong\u003e（包括 cBPF 和 eBPF），可作为\n\u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-zh/\"\u003e\u003cmark\u003eCilium：BPF 和 XDP 参考指南（2021）\u003c/mark\u003e\u003c/a\u003e\n的很好补充，这两篇可能是目前除了内核源码之外，学习 BPF 的最全/最好参考。\n本文适合有一定 BPF 经验的开发者阅读，不适合初学者。\u003c/p\u003e\n\n\u003cp\u003e由于内核文档更新不是非常及时，文中部分内容已经与 5.10 代码对不上，因此（少量）\n过时内容在翻译时略去了。另外，为文中的大部分 BPF 汇编 / x86_64 汇编加了注释，\n并插入了一些 5.10 代码片段或链接，方便更深入理解。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#\" id=\"markdown-toc-\"\u003e————————————————————————\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#cbpf-相关内容\" id=\"markdown-toc-cbpf-相关内容\"\u003ecBPF 相关内容\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#-1\" id=\"markdown-toc--1\"\u003e————————————————————————\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-cbpf-引言\" id=\"markdown-toc-1-cbpf-引言\"\u003e1 cBPF 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-lsf-cbpf-与-bsd-bpf\" id=\"markdown-toc-11-lsf-cbpf-与-bsd-bpf\"\u003e1.1 LSF (cBPF) 与 BSD BPF\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-attachdetachlock-操作\" id=\"markdown-toc-12-attachdetachlock-操作\"\u003e1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eATTACH\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDETACH\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLOCK\u003c/code\u003e 操作\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-lsfbpf-使用场景\" id=\"markdown-toc-13-lsfbpf-使用场景\"\u003e1.3 LSF/BPF 使用场景\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-cbpf-经典论文\" id=\"markdown-toc-14-cbpf-经典论文\"\u003e1.4 cBPF 经典论文\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-cbpf-数据结构\" id=\"markdown-toc-2-cbpf-数据结构\"\u003e2 cBPF 数据结构\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-struct-sock_filter\" id=\"markdown-toc-21-struct-sock_filter\"\u003e2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_filter\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-struct-sock_fprog\" id=\"markdown-toc-22-struct-sock_fprog\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_fprog\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-cbpf-示例libpcap-过滤-socket-流量\" id=\"markdown-toc-3-cbpf-示例libpcap-过滤-socket-流量\"\u003e3 cBPF 示例：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibpcap\u003c/code\u003e 过滤 socket 流量\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-setsockopt-将字节码-attach-到-socket\" id=\"markdown-toc-31-setsockopt-将字节码-attach-到-socket\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt()\u003c/code\u003e 将字节码 attach 到 socket\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-setsockopt-attachdetachlock-时的参数\" id=\"markdown-toc-32-setsockopt-attachdetachlock-时的参数\"\u003e3.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt()\u003c/code\u003e attach/detach/lock 时的参数\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-libpcap-适用和不适用的场景\" id=\"markdown-toc-33-libpcap-适用和不适用的场景\"\u003e3.3 libpcap 适用和不适用的场景\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-cbpf-引擎和指令集\" id=\"markdown-toc-4-cbpf-引擎和指令集\"\u003e4 cBPF 引擎和指令集\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-bpf_asm最小-bpf-汇编器assembler\" id=\"markdown-toc-41-bpf_asm最小-bpf-汇编器assembler\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_asm\u003c/code\u003e：最小 BPF 汇编器（assembler）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-cbpf-架构\" id=\"markdown-toc-42-cbpf-架构\"\u003e4.2 cBPF 架构\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-bpf_asm-实现的指令集\" id=\"markdown-toc-43-bpf_asm-实现的指令集\"\u003e4.3 bpf_asm 实现的指令集\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-12-种指令寻址模式\" id=\"markdown-toc-44-12-种指令寻址模式\"\u003e4.4 12 种指令寻址模式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#45-linux-bpf-extensionslinux-bpf-扩展\" id=\"markdown-toc-45-linux-bpf-extensionslinux-bpf-扩展\"\u003e4.5 Linux BPF extensions（Linux BPF 扩展）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#46-cbpf-汇编示例若干附代码解读\" id=\"markdown-toc-46-cbpf-汇编示例若干附代码解读\"\u003e4.6 cBPF 汇编示例若干（附代码解读）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#47-用-bps_asm-编译成字节码\" id=\"markdown-toc-47-用-bps_asm-编译成字节码\"\u003e4.7 用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebps_asm\u003c/code\u003e 编译成字节码\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#48-调试\" id=\"markdown-toc-48-调试\"\u003e4.8 调试\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#load-命令\" id=\"markdown-toc-load-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#run-命令\" id=\"markdown-toc-run-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erun\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#disassemble-命令\" id=\"markdown-toc-disassemble-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edisassemble\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#dump-命令\" id=\"markdown-toc-dump-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edump\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#breakpoint-命令\" id=\"markdown-toc-breakpoint-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebreakpoint\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#run-命令-1\" id=\"markdown-toc-run-命令-1\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erun\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#step-命令\" id=\"markdown-toc-step-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estep\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#select-命令\" id=\"markdown-toc-select-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eselect\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#quit-命令\" id=\"markdown-toc-quit-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003equit\u003c/code\u003e 命令\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-cbpf-jit-编译器\" id=\"markdown-toc-5-cbpf-jit-编译器\"\u003e5 cBPF JIT 编译器\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-内核配置项bpf_jit_enable\" id=\"markdown-toc-51-内核配置项bpf_jit_enable\"\u003e5.1 内核配置项：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_enable\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-工具bpf_jit_disasm\" id=\"markdown-toc-52-工具bpf_jit_disasm\"\u003e5.2 工具：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_disasm\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-jit-开发者工具箱\" id=\"markdown-toc-53-jit-开发者工具箱\"\u003e5.3 JIT 开发者工具箱\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#-2\" id=\"markdown-toc--2\"\u003e————————————————————————\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#ebpf-相关内容\" id=\"markdown-toc-ebpf-相关内容\"\u003eeBPF 相关内容\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#-3\" id=\"markdown-toc--3\"\u003e————————————————————————\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-bpf-kernel-internalsebpf\" id=\"markdown-toc-6-bpf-kernel-internalsebpf\"\u003e6 BPF kernel internals（eBPF）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-ebpf-设计考虑\" id=\"markdown-toc-61-ebpf-设计考虑\"\u003e6.1 eBPF 设计考虑\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-cbpf-ebpf-自动转换\" id=\"markdown-toc-62-cbpf-ebpf-自动转换\"\u003e6.2 cBPF-\u0026gt;eBPF 自动转换\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-ebpf-相比-cbpf-的核心变化\" id=\"markdown-toc-63-ebpf-相比-cbpf-的核心变化\"\u003e6.3 eBPF 相比 cBPF 的核心变化\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#631-寄存器数量从-2-个增加到-10-个\" id=\"markdown-toc-631-寄存器数量从-2-个增加到-10-个\"\u003e6.3.1 寄存器数量从 2 个增加到 10 个\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#传参寄存器数量\" id=\"markdown-toc-传参寄存器数量\"\u003e传参寄存器数量\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#ebpf-调用约定\" id=\"markdown-toc-ebpf-调用约定\"\u003eeBPF 调用约定\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#632-寄存器位宽从-32bit-扩展到-64bit\" id=\"markdown-toc-632-寄存器位宽从-32bit-扩展到-64bit\"\u003e6.3.2 寄存器位宽从 32bit 扩展到 64bit\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#633-条件跳转jtfall-through-取代-jtjf\" id=\"markdown-toc-633-条件跳转jtfall-through-取代-jtjf\"\u003e6.3.3 条件跳转：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt/fall-through\u003c/code\u003e 取代 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt/jf\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#634-引入-bpf_call-指令和寄存器传参约定实现零额外开销内核函数调用\" id=\"markdown-toc-634-引入-bpf_call-指令和寄存器传参约定实现零额外开销内核函数调用\"\u003e6.3.4 引入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_call\u003c/code\u003e 指令和寄存器传参约定，实现零（额外）开销内核函数调用\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#原理jit-实现零额外开销内核函数调用\" id=\"markdown-toc-原理jit-实现零额外开销内核函数调用\"\u003e原理：JIT 实现零（额外）开销内核函数调用\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#示例解析一ebpfc-函数混合调用jit-生成的-x86_64-指令\" id=\"markdown-toc-示例解析一ebpfc-函数混合调用jit-生成的-x86_64-指令\"\u003e示例解析（一）：eBPF/C 函数混合调用，JIT 生成的 x86_64 指令\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#ebpf-寄存器到-x86_64-硬件寄存器一一映射关系\" id=\"markdown-toc-ebpf-寄存器到-x86_64-硬件寄存器一一映射关系\"\u003eeBPF 寄存器到 x86_64 硬件寄存器一一映射关系\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#示例解析二c-调-ebpf-代码编译成-x86_64-汇编后的样子\" id=\"markdown-toc-示例解析二c-调-ebpf-代码编译成-x86_64-汇编后的样子\"\u003e示例解析（二）：C 调 eBPF 代码编译成 x86_64 汇编后的样子\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-ebpf-程序最大指令数限制\" id=\"markdown-toc-64-ebpf-程序最大指令数限制\"\u003e6.4 eBPF 程序最大指令数限制\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#65-ebpf-程序上下文ctx参数\" id=\"markdown-toc-65-ebpf-程序上下文ctx参数\"\u003e6.5 eBPF 程序上下文（ctx）参数\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#66-cbpf---ebpf-转换若干问题\" id=\"markdown-toc-66-cbpf---ebpf-转换若干问题\"\u003e6.6 cBPF -\u0026gt; eBPF 转换若干问题\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#67-ebpf-的安全性\" id=\"markdown-toc-67-ebpf-的安全性\"\u003e6.7 eBPF 的安全性\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-ebpf-字节码编码opcode-encoding\" id=\"markdown-toc-7-ebpf-字节码编码opcode-encoding\"\u003e7 eBPF 字节码编码（opcode encoding）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-算术和跳转指令\" id=\"markdown-toc-71-算术和跳转指令\"\u003e7.1 算术和跳转指令\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#bpf_alu-和-bpf_jmp-的-operand\" id=\"markdown-toc-bpf_alu-和-bpf_jmp-的-operand\"\u003eBPF_ALU 和 BPF_JMP 的 operand\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf_alu-和-bpf_alu64-ebpf-的-opcode\" id=\"markdown-toc-bpf_alu-和-bpf_alu64-ebpf-的-opcode\"\u003eBPF_ALU 和 BPF_ALU64 (eBPF) 的 opcode\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf_jmp-和-bpf_jmp32-ebpf-的-opcode\" id=\"markdown-toc-bpf_jmp-和-bpf_jmp32-ebpf-的-opcode\"\u003eBPF_JMP 和 BPF_JMP32 (eBPF) 的 opcode\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf_misc-与-bpf_alu64ebpf-64bit-寄存器加法操作\" id=\"markdown-toc-bpf_misc-与-bpf_alu64ebpf-64bit-寄存器加法操作\"\u003eBPF_MISC 与 BPF_ALU64（eBPF 64bit 寄存器加法操作）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#cbpfebpf-bpf_ret-指令的不同\" id=\"markdown-toc-cbpfebpf-bpf_ret-指令的不同\"\u003ecBPF/eBPF BPF_RET 指令的不同\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf_jmp-与-ebpf-bpf_jmp32\" id=\"markdown-toc-bpf_jmp-与-ebpf-bpf_jmp32\"\u003eBPF_JMP 与 eBPF BPF_JMP32\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-加载指令loadstore\" id=\"markdown-toc-72-加载指令loadstore\"\u003e7.2 加载指令（load/store）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#两个-ebpf-non-generic-指令bpf_abs-和-bpf_ind用于访问-skb-data\" id=\"markdown-toc-两个-ebpf-non-generic-指令bpf_abs-和-bpf_ind用于访问-skb-data\"\u003e两个 eBPF non-generic 指令：BPF_ABS 和 BPF_IND，用于访问 skb data\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#通用-ebpf-loadstore-指令\" id=\"markdown-toc-通用-ebpf-loadstore-指令\"\u003e通用 eBPF load/store 指令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#加载-64bit-立即数的-ebpf-指令\" id=\"markdown-toc-加载-64bit-立即数的-ebpf-指令\"\u003e加载 64bit 立即数的 eBPF 指令\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-ebpf-校验器ebpf-verifier\" id=\"markdown-toc-8-ebpf-校验器ebpf-verifier\"\u003e8 eBPF 校验器（eBPF verifier）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#81-模拟执行\" id=\"markdown-toc-81-模拟执行\"\u003e8.1 模拟执行\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#82-loadstore-指令检查\" id=\"markdown-toc-82-loadstore-指令检查\"\u003e8.2 load/store 指令检查\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#83-定制化校验器限制程序只能访问-ctx-特定字段\" id=\"markdown-toc-83-定制化校验器限制程序只能访问-ctx-特定字段\"\u003e8.3 定制化校验器，限制程序只能访问 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e 特定字段\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#84-读取栈空间\" id=\"markdown-toc-84-读取栈空间\"\u003e8.4 读取栈空间\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#85-其他\" id=\"markdown-toc-85-其他\"\u003e8.5 其他\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-寄存器值跟踪register-value-tracking\" id=\"markdown-toc-9-寄存器值跟踪register-value-tracking\"\u003e9 寄存器值跟踪（register value tracking）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#91-9-种指针类型\" id=\"markdown-toc-91-9-种指针类型\"\u003e9.1 9 种指针类型\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#92-指针偏移offset触发寄存器状态更新\" id=\"markdown-toc-92-指针偏移offset触发寄存器状态更新\"\u003e9.2 指针偏移（offset）触发寄存器状态更新\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#93-条件分支触发寄存器状态更新\" id=\"markdown-toc-93-条件分支触发寄存器状态更新\"\u003e9.3 条件分支触发寄存器状态更新\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#94-有符号比较触发寄存器状态更新\" id=\"markdown-toc-94-有符号比较触发寄存器状态更新\"\u003e9.4 有符号比较触发寄存器状态更新\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#95-struct-bpf_reg_state-的-id-字段\" id=\"markdown-toc-95-struct-bpf_reg_state-的-id-字段\"\u003e9.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_reg_state\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 字段\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#ptr_to_packet\" id=\"markdown-toc-ptr_to_packet\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_PACKET\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ptr_to_map_value\" id=\"markdown-toc-ptr_to_map_value\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_MAP_VALUE\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ptr_to_socket\" id=\"markdown-toc-ptr_to_socket\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_SOCKET\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-直接数据包访问direct-packet-access\" id=\"markdown-toc-10-直接数据包访问direct-packet-access\"\u003e10 直接数据包访问（direct packet access）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#101-简单例子\" id=\"markdown-toc-101-简单例子\"\u003e10.1 简单例子\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#102-复杂例子\" id=\"markdown-toc-102-复杂例子\"\u003e10.2 复杂例子\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#校验器标记信息解读\" id=\"markdown-toc-校验器标记信息解读\"\u003e校验器标记信息解读\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#对应的-c-代码\" id=\"markdown-toc-对应的-c-代码\"\u003e对应的 C 代码\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#11-ebpf-maps\" id=\"markdown-toc-11-ebpf-maps\"\u003e11 eBPF maps\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#12-pruning剪枝\" id=\"markdown-toc-12-pruning剪枝\"\u003e12 Pruning（剪枝）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#13-理解-ebpf-校验器提示信息\" id=\"markdown-toc-13-理解-ebpf-校验器提示信息\"\u003e13 理解 eBPF 校验器提示信息\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#131-程序包含无法执行到的指令\" id=\"markdown-toc-131-程序包含无法执行到的指令\"\u003e13.1 程序包含无法执行到的指令\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#132-程序读取未初始化的寄存器\" id=\"markdown-toc-132-程序读取未初始化的寄存器\"\u003e13.2 程序读取未初始化的寄存器\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#133-程序退出前未设置-r0-寄存器\" id=\"markdown-toc-133-程序退出前未设置-r0-寄存器\"\u003e13.3 程序退出前未设置 R0 寄存器\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#134-程序访问超出栈空间\" id=\"markdown-toc-134-程序访问超出栈空间\"\u003e13.4 程序访问超出栈空间\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#135-未初始化栈内元素就传递该栈地址\" id=\"markdown-toc-135-未初始化栈内元素就传递该栈地址\"\u003e13.5 未初始化栈内元素，就传递该栈地址\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#136-程序执行-map_lookup_elem-传递了非法的-map_fd\" id=\"markdown-toc-136-程序执行-map_lookup_elem-传递了非法的-map_fd\"\u003e13.6 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 传递了非法的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_fd\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#137-程序未检查-map_lookup_elem-的返回值是否为空就开始使用\" id=\"markdown-toc-137-程序未检查-map_lookup_elem-的返回值是否为空就开始使用\"\u003e13.7 程序未检查 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 的返回值是否为空就开始使用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#138-程序访问-map-内容时使用了错误的字节对齐\" id=\"markdown-toc-138-程序访问-map-内容时使用了错误的字节对齐\"\u003e13.8 程序访问 map 内容时使用了错误的字节对齐\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#139-程序在-fallthrough-分支中使用了错误的字节对齐访问-map-数据\" id=\"markdown-toc-139-程序在-fallthrough-分支中使用了错误的字节对齐访问-map-数据\"\u003e13.9 程序在 fallthrough 分支中使用了错误的字节对齐访问 map 数据\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#1310-程序执行-sk_lookup_tcp未检查返回值就直接将其置-null\" id=\"markdown-toc-1310-程序执行-sk_lookup_tcp未检查返回值就直接将其置-null\"\u003e13.10 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e，未检查返回值就直接将其置 NULL\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#1311-程序执行-sk_lookup_tcp-但未检查返回值是否为空\" id=\"markdown-toc-1311-程序执行-sk_lookup_tcp-但未检查返回值是否为空\"\u003e13.11 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e 但未检查返回值是否为空\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#14-测试testing\" id=\"markdown-toc-14-测试testing\"\u003e14 测试（testing）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#15-其他misc\" id=\"markdown-toc-15-其他misc\"\u003e15 其他（misc）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#本文作者\" id=\"markdown-toc-本文作者\"\u003e本文作者\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eSPDX-License-Identifier: GPL-2.0\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1\u003e————————————————————————\u003c/h1\u003e\n\u003ch1 id=\"cbpf-相关内容\"\u003ecBPF 相关内容\u003c/h1\u003e\n\u003ch1 id=\"-1\"\u003e————————————————————————\u003c/h1\u003e\n\n\u003ch1 id=\"1-cbpf-引言\"\u003e1 cBPF 引言\u003c/h1\u003e\n\n\u003cp\u003eLinux Socket Filtering (LSF) 从 Berkeley Packet Filter（BPF）\u003cstrong\u003e\u003cmark\u003e衍生而来\u003c/mark\u003e\u003c/strong\u003e。\n虽然 BSD 和 Linux Kernel filtering 有一些重要不同，但\u003cstrong\u003e\u003cmark\u003e在 Linux 语境中提到 BPF 或 LSF 时\u003c/mark\u003e\u003c/strong\u003e，\n我们指的都是 Linux 内核中的同一套\u003cstrong\u003e\u003cmark\u003e过滤机制\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"11-lsf-cbpf-与-bsd-bpf\"\u003e1.1 LSF (cBPF) 与 BSD BPF\u003c/h2\u003e\n\n\u003cp\u003eBPF 允许用户空间程序\u003cstrong\u003e\u003cmark\u003e向任意 socket attach 过滤器（filter）\u003c/mark\u003e\u003c/strong\u003e，\n\u003cstrong\u003e\u003cmark\u003e对流经 socket 的数据进行控制\u003c/mark\u003e\u003c/strong\u003e（放行或拒绝）。\nLSF 完全遵循了 BSD BPF 的过滤器代码结构（filter code structure），因此实现过滤器时，\nBSD bpf.4 manpage 是很好的参考文档。\u003c/p\u003e\n\n\u003cp\u003e不过，\u003cstrong\u003e\u003cmark\u003eLinux BPF 要比 BSD BPF 简单很多\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e用户无需关心设备（devices）之类的东西；\u003c/li\u003e\n  \u003cli\u003e只需要创建自己的过滤器代码，通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eSO_ATTACH_FILTER\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 选项将其发送到内核；\u003c/li\u003e\n  \u003cli\u003e接下来只要这段代码能通过内核校验，用户就能立即在 socket 上开始过滤数据了。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"12-attachdetachlock-操作\"\u003e1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eATTACH\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDETACH\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLOCK\u003c/code\u003e 操作\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_ATTACH_FILTER\u003c/code\u003e 用于将 filter attach 到 socket。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_DETACH_FILTER\u003c/code\u003e 用于从 socket 中 detach 过滤器。\u003c/p\u003e\n\n    \u003cp\u003e但这种情况可能比较少，因为关闭一个 socket 时，attach 在上面的所有 filters 会被\n  \u003cstrong\u003e\u003cmark\u003e自动删除\u003c/mark\u003e\u003c/strong\u003e。\n  另一个不太常见的场景是：向一个已经有 filter 的 socket 再 attach 一个 filter：\n  内核负责将老的移除，替换成新的 —— 只要新的过滤器通过了校验，否则还是老的在工作。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_LOCK_FILTER\u003c/code\u003e 选项支持将 attach 到 socket 上的 \u003cstrong\u003e\u003cmark\u003efilter 锁定\u003c/mark\u003e\u003c/strong\u003e。\n一旦锁定之后，这个过滤器就\u003cstrong\u003e\u003cmark\u003e不能被删除或修改\u003c/mark\u003e\u003c/strong\u003e了。这样就能保证下列操作之后：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e进程创建 socket\u003c/li\u003e\n      \u003cli\u003eattach filter\u003c/li\u003e\n      \u003cli\u003e锁定 filter\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003edrop privileges\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n    \u003c/ol\u003e\n\n    \u003cp\u003e这个 filter 就会一直运行在该 socket 上，直到后者被关闭。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"13-lsfbpf-使用场景\"\u003e1.3 LSF/BPF 使用场景\u003c/h2\u003e\n\n\u003cp\u003eBPF 模块的\u003cstrong\u003e\u003cmark\u003e最大用户\u003c/mark\u003e\u003c/strong\u003e可能就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibpcap\u003c/code\u003e。例如，对于高层过滤命令 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump -i em1 port 22\u003c/code\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003elibpcap 编译器\u003c/mark\u003e\u003c/strong\u003e能将其编译生成一个 cBPF 程序，然后通过前面介绍的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_ATTACH_FILTER\u003c/code\u003e 加载到内核；\u003c/li\u003e\n  \u003cli\u003e加 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-ddd\u003c/code\u003e 参数，可以 \u003cstrong\u003e\u003cmark\u003edump 这条命令对应的字节码\u003c/mark\u003e\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump -i em1 port 22 -ddd\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e虽然我们这里讨论的都是 socket，但 \u003cstrong\u003e\u003cmark\u003eLinux 中 BPF 还可用于很多其他场景\u003c/mark\u003e\u003c/strong\u003e。例如\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003enetfilter 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ext_bpf\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e内核 qdisc 层的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003eseccomp-bpf (\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/Documentation/userspace-api/seccomp_filter.rst\"\u003eSECure COMPuting\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e其他很多地方，包括 team driver、PTP。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"14-cbpf-经典论文\"\u003e1.4 cBPF 经典论文\u003c/h2\u003e\n\n\u003cp\u003e最初的 BPF 论文：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eSteven McCanne and Van Jacobson. 1993. \u003cstrong\u003e\u003cmark\u003eThe BSD packet filter: a new\narchitecture for user-level packet capture\u003c/mark\u003e\u003c/strong\u003e. In Proceedings of the\nUSENIX Winter 1993 Conference Proceedings on USENIX Winter 1993\nConference Proceedings (USENIX’93). USENIX Association, Berkeley,\nCA, USA, 2-2. [http://www.tcpdump.org/papers/bpf-usenix93.pdf]\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"2-cbpf-数据结构\"\u003e2 cBPF 数据结构\u003c/h1\u003e\n\n\u003ch2 id=\"21-struct-sock_filter\"\u003e2.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_filter\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e要开发 cBPF 应用，用户空间程序需要 include \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e\u0026lt;linux/filter.h\u0026gt;\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，其中定义了下面的结构体：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_filter\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* Filter block */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u16\u003c/span\u003e    \u003cspan class=\"n\"\u003ecode\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e   \u003cspan class=\"cm\"\u003e/* Actual filter code */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e    \u003cspan class=\"n\"\u003ejt\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"cm\"\u003e/* Jump true */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e    \u003cspan class=\"n\"\u003ejf\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"cm\"\u003e/* Jump false */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u32\u003c/span\u003e    \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e      \u003cspan class=\"cm\"\u003e/* Generic multiuse field */\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个结构体包含 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecode\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejf\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek\u003c/code\u003e 四个字段。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejf\u003c/code\u003e 是 jump offset，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek\u003c/code\u003e 是一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecode\u003c/code\u003e 可以使用的通用字段。\u003c/p\u003e\n\n\u003ch2 id=\"22-struct-sock_fprog\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_fprog\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e要实现 socket filtering，需要通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003esetsockopt(2)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n将一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_fprog\u003c/code\u003e 指针传递给内核（后面有例子）。这个结构体的定义：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_fprog\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e                \u003cspan class=\"cm\"\u003e/* Required for SO_ATTACH_FILTER. */\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eshort\u003c/span\u003e           \u003cspan class=\"n\"\u003elen\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"cm\"\u003e/* Number of filter blocks */\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_filter\u003c/span\u003e \u003cspan class=\"n\"\u003e__user\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"3-cbpf-示例libpcap-过滤-socket-流量\"\u003e3 cBPF 示例：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibpcap\u003c/code\u003e 过滤 socket 流量\u003c/h1\u003e\n\n\u003ch2 id=\"31-setsockopt-将字节码-attach-到-socket\"\u003e3.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt()\u003c/code\u003e 将字节码 attach 到 socket\u003c/h2\u003e\n\n\u003cp\u003e两个结构体  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_filter\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_fprog\u003c/code\u003e 在前一节介绍过了：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;sys/socket.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;sys/types.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;arpa/inet.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;linux/if_ether.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003cspan class=\"cm\"\u003e/* ... */\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* From the example above: tcpdump -i em1 port 22 -dd */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_filter\u003c/span\u003e \u003cspan class=\"n\"\u003ecode\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x28\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x0000000c\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x000086dd\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x30\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000014\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000084\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000006\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e17\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000011\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x28\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000036\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e14\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000016\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x28\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000038\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e12\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e13\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000016\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e12\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000800\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x30\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000017\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000084\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000006\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000011\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x28\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000014\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x45\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00001fff\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xb1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x0000000e\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x48\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x0000000e\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000016\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x48\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000010\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000016\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x06\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x0000ffff\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x06\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e  \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mh\"\u003e0x00000000\u003c/span\u003e \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_fprog\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elen\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARRAY_SIZE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecode\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efilter\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecode\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003esock\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esocket\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePF_PACKET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSOCK_RAW\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ehtons\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eETH_P_ALL\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esock\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/* ... bail out ... */\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esetsockopt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esock\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSOL_SOCKET\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSO_ATTACH_FILTER\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eret\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/* ... bail out ... */\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* ... */\u003c/span\u003e\n\u003cspan class=\"n\"\u003eclose\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esock\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上代码将一个 filter attach 到了一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePF_PACKET\u003c/code\u003e 类型的 socket，功能是\n\u003cstrong\u003e\u003cmark\u003e放行所有 IPv4/IPv6 22 端口的包，其他包一律丢弃\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这里只展示了 attach 代码；detach 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt(2)\u003c/code\u003e 除了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_DETACH_FILTER\u003c/code\u003e 不需要其他参数；\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSO_LOCK_FILTER\u003c/code\u003e 可用于防止 filter 被 detach，需要带一个整形参数 0 或 1。\u003c/p\u003e\n\n\u003cp\u003e注意 socket filters 并不是只能用于 PF_PACKET 类型的 socket，也可以用于其他 socket 家族。\u003c/p\u003e\n\n\u003ch2 id=\"32-setsockopt-attachdetachlock-时的参数\"\u003e3.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt()\u003c/code\u003e attach/detach/lock 时的参数\u003c/h2\u003e\n\n\u003cp\u003e总结前面用到的几次系统调用：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003esetsockopt(sockfd, SOL_SOCKET, \u003cmark\u003eSO_ATTACH_FILTER\u003c/mark\u003e, \u0026amp;val, sizeof(val));\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003esetsockopt(sockfd, SOL_SOCKET, \u003cmark\u003eSO_DETACH_FILTER\u003c/mark\u003e, \u0026amp;val, sizeof(val));\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003esetsockopt(sockfd, SOL_SOCKET, \u003cmark\u003eSO_LOCK_FILTER\u003c/mark\u003e,   \u0026amp;val, sizeof(val));\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"33-libpcap-适用和不适用的场景\"\u003e3.3 libpcap 适用和不适用的场景\u003c/h2\u003e\n\n\u003cp\u003elipcap \u003cstrong\u003e\u003cmark\u003e高层语法\u003c/mark\u003e\u003c/strong\u003e封装了上面代码中看到的那些底层操作，\n功能已经\u003cstrong\u003e\u003cmark\u003e覆盖了大部分 socket filtering 的场景\u003c/mark\u003e\u003c/strong\u003e，\n因此如果想开发流量过滤应用，开发者应该首选基于 libpcap。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e除非遇到以下情况\u003c/mark\u003e\u003c/strong\u003e，否则不要纯手工编写过滤器：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e开发环境比较特殊，无法使用或链接 libpcap；\u003c/li\u003e\n  \u003cli\u003e使用的 filter 需要用到 libpcap 编译器还没有支持的 Linux extensions；\u003c/li\u003e\n  \u003cli\u003e开发的 filter 比较复杂，libpcap 编译器无法很好地支持该 filter；\u003c/li\u003e\n  \u003cli\u003e需要对特定的 filter 代码做优化，而不想使用 libpcap 编译器生成的代码；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003elibpcap 不适用的场景举例：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003ext_bpf 和 cls_bpf 用户\u003c/mark\u003e\u003c/strong\u003e可能需要更加复杂的 filter 代码，\n  libpcap 无法很好地表达。\u003c/li\u003e\n  \u003cli\u003eBPF JIT 开发者可能希望\u003cstrong\u003e\u003cmark\u003e手写测试用例\u003c/mark\u003e\u003c/strong\u003e，因此也需要直接编写或修改 BPF 代码。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"4-cbpf-引擎和指令集\"\u003e4 cBPF 引擎和指令集\u003c/h1\u003e\n\n\u003ch2 id=\"41-bpf_asm最小-bpf-汇编器assembler\"\u003e4.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_asm\u003c/code\u003e：最小 BPF 汇编器（assembler）\u003c/h2\u003e\n\n\u003cp\u003e内核 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/\u003c/code\u003e 目录下有个小工具 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_asm\u003c/code\u003e，能用它来\u003cstrong\u003e\u003cmark\u003e编写 low-level filters\u003c/mark\u003e\u003c/strong\u003e，\n例如前面提到的一些 libpcap 不适用的场景。\u003c/p\u003e\n\n\u003cp\u003eBPF 语法类似汇编，在 bpf_asm 已经中实现了，接下来还会用这种汇编解释其他一些程序\n（而不是直接使用难懂的 opcodes，二者的原理是一样的）。这种汇编语法非常接近\nSteven McCanne’s and Van Jacobson’s BPF paper 中的建模。\u003c/p\u003e\n\n\u003ch2 id=\"42-cbpf-架构\"\u003e4.2 cBPF 架构\u003c/h2\u003e\n\n\u003cp\u003ecBPF 架构由如下几个基本部分组成：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e=======          ====================================================\nElement          Description\n=======          ====================================================\nA                32 bit wide accumulator（32bit 位宽的累加器）\nX                32 bit wide X register （32bit 位宽 X 寄存器）\nM[]              16 x 32 bit wide misc registers aka \u0026#34;scratch memory store\u0026#34;, addressable from 0 to 15\n                 （16x32bit 数组，数组索引 0~15，可存放任意内容）\n=======          ====================================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBPF 程序经过 bpf_asm 处理之后\u003cstrong\u003e\u003cmark\u003e变成一个 \u003ccode\u003estruct sock_filter\u003c/code\u003e 类型的数组\u003c/mark\u003e\u003c/strong\u003e\n（这个结构体前面介绍过），因此数组中的每个元素都是\u003cstrong\u003e\u003cmark\u003e以如下格式编码\u003c/mark\u003e\u003c/strong\u003e的：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eop:16, jt:8, jf:8, k:32\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e：16bit opcode，其中包括了特定的指令；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt\u003c/code\u003e：jump if true\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejf\u003c/code\u003e：jump if false\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek\u003c/code\u003e：多功能字段，\u003cstrong\u003e\u003cmark\u003e存放的什么内容，根据 op 类型来解释\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"43-bpf_asm-实现的指令集\"\u003e4.3 bpf_asm 实现的指令集\u003c/h2\u003e\n\n\u003cp\u003e指令集包括 load、store、branch、alu、return 等指令，bpf_asm 语言中\u003cstrong\u003e\u003cmark\u003e实现了这些指令\u003c/mark\u003e\u003c/strong\u003e。\n下面的表格列出了 bpf_asm 中具体包括的指令，对应的 opcode 定义在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elinux/filter.h\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e===========      ===================  =====================\n指令             寻址模式              解释\n===========      ===================  =====================\nld               1, 2, 3, 4, 12       Load word into A\nldi              4                    Load word into A\nldh              1, 2                 Load half-word into A\nldb              1, 2                 Load byte into A\nldx              3, 4, 5, 12          Load word into X\nldxi             4                    Load word into X\nldxb             5                    Load byte into X\n\nst               3                    Store A into M[]\nstx              3                    Store X into M[]\n\njmp              6                    Jump to label\nja               6                    Jump to label\njeq              7, 8, 9, 10          Jump on A == \u0026lt;x\u0026gt;\njneq             9, 10                Jump on A != \u0026lt;x\u0026gt;\njne              9, 10                Jump on A != \u0026lt;x\u0026gt;\njlt              9, 10                Jump on A \u0026lt;  \u0026lt;x\u0026gt;\njle              9, 10                Jump on A \u0026lt;= \u0026lt;x\u0026gt;\njgt              7, 8, 9, 10          Jump on A \u0026gt;  \u0026lt;x\u0026gt;\njge              7, 8, 9, 10          Jump on A \u0026gt;= \u0026lt;x\u0026gt;\njset             7, 8, 9, 10          Jump on A \u0026amp;  \u0026lt;x\u0026gt;\n\nadd              0, 4                 A + \u0026lt;x\u0026gt;\nsub              0, 4                 A - \u0026lt;x\u0026gt;\nmul              0, 4                 A * \u0026lt;x\u0026gt;\ndiv              0, 4                 A / \u0026lt;x\u0026gt;\nmod              0, 4                 A % \u0026lt;x\u0026gt;\nneg                                   !A\nand              0, 4                 A \u0026amp; \u0026lt;x\u0026gt;\nor               0, 4                 A | \u0026lt;x\u0026gt;\nxor              0, 4                 A ^ \u0026lt;x\u0026gt;\nlsh              0, 4                 A \u0026lt;\u0026lt; \u0026lt;x\u0026gt;\nrsh              0, 4                 A \u0026gt;\u0026gt; \u0026lt;x\u0026gt;\n\ntax                                   Copy A into X\ntxa                                   Copy X into A\n\nret              4, 11                Return\n===========      ===================  =====================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中第二列是寻找模式，定义见下面。\u003c/p\u003e\n\n\u003ch2 id=\"44-12-种指令寻址模式\"\u003e4.4 12 种指令寻址模式\u003c/h2\u003e\n\n\u003cp\u003e寻址模式的定义如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e===============\u003c/span\u003e  \u003cspan class=\"o\"\u003e===================\u003c/span\u003e  \u003cspan class=\"o\"\u003e===============================================\u003c/span\u003e\n寻址模式         语法                 解释\n\u003cspan class=\"o\"\u003e===============\u003c/span\u003e  \u003cspan class=\"o\"\u003e===================\u003c/span\u003e  \u003cspan class=\"o\"\u003e===============================================\u003c/span\u003e\n 0               x/%x                 Register X\n 1               \u003cspan class=\"o\"\u003e[\u003c/span\u003ek]                  BHW at byte offset k \u003cspan class=\"k\"\u003ein \u003c/span\u003ethe packet\n 2               \u003cspan class=\"o\"\u003e[\u003c/span\u003ex + k]              BHW at the offset X + k \u003cspan class=\"k\"\u003ein \u003c/span\u003ethe packet\n 3               M[k]                 Word at offset k \u003cspan class=\"k\"\u003ein \u003c/span\u003eM[]\n 4               \u003cspan class=\"c\"\u003e#k                   Literal value stored in k\u003c/span\u003e\n 5               4\u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e([\u003c/span\u003ek]\u0026amp;0xf\u003cspan class=\"o\"\u003e)\u003c/span\u003e          Lower nibble \u003cspan class=\"k\"\u003e*\u003c/span\u003e 4 at byte offset k \u003cspan class=\"k\"\u003ein \u003c/span\u003ethe packet\n 6               L                    Jump label L\n 7               \u003cspan class=\"c\"\u003e#k,Lt,Lf             Jump to Lt if true, otherwise jump to Lf\u003c/span\u003e\n 8               x/%x,Lt,Lf           Jump to Lt \u003cspan class=\"k\"\u003eif \u003c/span\u003e\u003cspan class=\"nb\"\u003etrue\u003c/span\u003e, otherwise jump to Lf\n 9               \u003cspan class=\"c\"\u003e#k,Lt                Jump to Lt if predicate is true\u003c/span\u003e\n10               x/%x,Lt              Jump to Lt \u003cspan class=\"k\"\u003eif \u003c/span\u003epredicate is \u003cspan class=\"nb\"\u003etrue\n\u003c/span\u003e11               a/%a                 Accumulator A\n12               extension            BPF extension\n\u003cspan class=\"o\"\u003e===============\u003c/span\u003e  \u003cspan class=\"o\"\u003e===================\u003c/span\u003e  \u003cspan class=\"o\"\u003e===============================================\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意最后一种：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF extensions\u003c/code\u003e，这是 Linux 对 BPF 的扩展，下一节详细介绍。\u003c/p\u003e\n\n\u003ch2 id=\"45-linux-bpf-extensionslinux-bpf-扩展\"\u003e4.5 Linux BPF extensions（Linux BPF 扩展）\u003c/h2\u003e\n\n\u003cp\u003e除了常规的一些 load 指令，Linux 内核还有一些 BPF extensions，它们用一个\n\u003cstrong\u003e\u003cmark\u003e负 offset 加上一个特殊的 extension offset 来 “overloading” k 字段\u003c/mark\u003e\u003c/strong\u003e，\n然后将这个\u003cstrong\u003e\u003cmark\u003e结果加载到寄存器 A 中\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e===================================   =================================================\nExtension                             描述（实际对应的结构体字段或值）\n===================================   =================================================\nlen                                   skb-\u0026gt;len\nproto                                 skb-\u0026gt;protocol\ntype                                  skb-\u0026gt;pkt_type\npoff                                  Payload start offset\nifidx                                 skb-\u0026gt;dev-\u0026gt;ifindex\nnla                                   Netlink attribute of type X with offset A\nnlan                                  Nested Netlink attribute of type X with offset A\nmark                                  skb-\u0026gt;mark\nqueue                                 skb-\u0026gt;queue_mapping\nhatype                                skb-\u0026gt;dev-\u0026gt;type\nrxhash                                skb-\u0026gt;hash\ncpu                                   raw_smp_processor_id()\nvlan_tci                              skb_vlan_tag_get(skb)\nvlan_avail                            skb_vlan_tag_present(skb)\nvlan_tpid                             skb-\u0026gt;vlan_proto\nrand                                  prandom_u32()\n===================================   =================================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这些扩展也可以加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#\u003c/code\u003e 前缀。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以上提到的负 offset 和具体 extension 的 offset，定义见\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/uapi/linux/filter.h#L60\"\u003einclude/uapi/linux/filter.h\u003c/a\u003e：\u003c/p\u003e\n\n  \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* RATIONALE. Negative offsets are invalid in BPF.\n   We use them to reference ancillary data.\n   Unlike introduction new instructions, it does not break\n   existing compilers/optimizers.\n */\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define SKF_AD_OFF    (-0x1000)\n#define SKF_AD_PROTOCOL 0\n#define SKF_AD_PKTTYPE     4\n#define SKF_AD_IFINDEX     8\n#define SKF_AD_NLATTR    12\n#define SKF_AD_NLATTR_NEST    16\n#define SKF_AD_MARK     20\n#define SKF_AD_QUEUE    24\n#define SKF_AD_HATYPE    28\n#define SKF_AD_RXHASH    32\n#define SKF_AD_CPU    36\n#define SKF_AD_ALU_XOR_X    40\n#define SKF_AD_VLAN_TAG    44\n#define SKF_AD_VLAN_TAG_PRESENT 48\n#define SKF_AD_PAY_OFFSET    52\n#define SKF_AD_RANDOM    56\n#define SKF_AD_VLAN_TPID    60\n#define SKF_AD_MAX    64\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define SKF_NET_OFF    (-0x100000)\n#define SKF_LL_OFF    (-0x200000)\n\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#define BPF_NET_OFF    SKF_NET_OFF\n#define BPF_LL_OFF    SKF_LL_OFF\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e在 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/kernel/bpf/core.c\"\u003ekernel/bpf/core.c\u003c/a\u003e 等地方使用：\u003c/p\u003e\n\n  \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cm\"\u003e/* No hurry in this branch\n *\n * Exported for the bpf jit load helper.\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003ebpf_internal_load_pointer_neg_helper\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu8\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eSKF_NET_OFF\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eskb_network_header\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eSKF_NET_OFF\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eSKF_LL_OFF\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eptr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eskb_mac_header\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ek\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eSKF_LL_OFF\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eptr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ehead\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eptr\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eskb_tail_pointer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eptr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e\u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-zh/\"\u003e\u003cmark\u003eCilium：BPF 和 XDP 参考指南（2021）\u003c/mark\u003e\u003c/a\u003e\n中对此亦有提及。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"46-cbpf-汇编示例若干附代码解读\"\u003e4.6 cBPF 汇编示例若干（附代码解读）\u003c/h2\u003e\n\n\u003cp\u003e过滤 \u003cstrong\u003e\u003cmark\u003eARP 包\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-asm\"\u003eldh [12]          ; 将 skb 第 12,13 两个字节（h 表示 half word，两个字节，即 skb-\u0026gt;protocol 字段）加载到寄存器 A\njne #0x806, drop  ; 如果寄存器 A 中的值不等于 0x0806（ARP 协议），则跳转到 drop\nret #-1           ; （能执行到这一行，说明是 ARP 包），返回 -1\ndrop: ret #0      ; 返回 0\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003e过滤 \u003cstrong\u003e\u003cmark\u003eIPv4 TCP 包\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eldh [12]          ; 将 skb 第 12,13 两个字节（h 表示 half word，两个字节，即 skb-\u0026gt;protocol 字段）加载到寄存器 A\njne #0x800, drop  ; 如果寄存器 A 中的值不等于 0x0800（IPv4 协议），则跳转到 drop\nldb [23]          ; 将 skb 第 23 字节（b 表示 byte，一个字节，即 ipv4_hdr-\u0026gt;protocol 字段）加载到寄存器 A\njneq #6, drop     ; 如果寄存器 A 中的值不等于 6（TCP 协议），则跳转到 drop\nret #-1           ; （能执行到这一行，说明是 TCP 包），返回 -1\ndrop: ret #0      ; 返回 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e过滤 \u003cstrong\u003e\u003cmark\u003eVLAN ID 等于 10 的包\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eld vlan_tci       ; 根据前面介绍的 BPF extensions，这会转换成 skb_vlan_tag_get(skb)\njneq #10, drop    ; 如果寄存器 A 中的值不等于 10，则跳转到 drop\nret #-1           ; （能执行到这一行说明 VLAN ID 等于 10），返回 -1\ndrop: ret #0      ; 返回 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e对 ICMP 包随机采集，采样频率 1/4\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eldh [12]          ; 将 skb 第 12,13 两个字节（h 表示 half word，两个字节，即 skb-\u0026gt;protocol 字段）加载到寄存器 A\njne #0x800, drop  ; 如果寄存器 A 中的值不等于 0x0800（IPv4 协议），则跳转到 drop\nldb [23]          ; 将 skb 第 23 字节（b 表示 byte，一个字节，即 ipv4_hdr-\u0026gt;protocol 字段）加载到寄存器 A\njneq #1, drop     ; 如果寄存器 A 中的值不等于 1（ICMP 协议），则跳转到 drop\nld rand           ; 获取一个 u32 类型的随机数，存入寄存器 A\nmod #4            ; 将寄存器 A 中的值原地对 4 取模（结果仍然存入 A）\njneq #1, drop     ; 如果 A 中的值（即取模的结果）不等于 1，跳转到 drop\nret #-1           ; （能执行到这里说明对 4 取模等于 1），返回 -1\ndrop: ret #0      ; 返回 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eSECCOMP filter example\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eld [4]                  /* offsetof(struct seccomp_data, arch) */\njne #0xc000003e, bad    /* AUDIT_ARCH_X86_64 */\nld [0]                  /* offsetof(struct seccomp_data, nr) */\njeq #15, good           /* __NR_rt_sigreturn */\njeq #231, good          /* __NR_exit_group */\njeq #60, good           /* __NR_exit */\njeq #0, good            /* __NR_read */\njeq #1, good            /* __NR_write */\njeq #5, good            /* __NR_fstat */\njeq #9, good            /* __NR_mmap */\njeq #14, good           /* __NR_rt_sigprocmask */\njeq #13, good           /* __NR_rt_sigaction */\njeq #35, good           /* __NR_nanosleep */\nbad: ret #0             /* SECCOMP_RET_KILL_THREAD */\ngood: ret #0x7fff0000   /* SECCOMP_RET_ALLOW */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"47-用-bps_asm-编译成字节码\"\u003e4.7 用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebps_asm\u003c/code\u003e 编译成字节码\u003c/h2\u003e\n\n\u003cp\u003e以上代码片段都可以放到文件中（下面用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoo\u003c/code\u003e 表示），然后用 bpf_asm 来生成 opcodes，\n后者是可以被 xt_bpf 和 cls_bpf 理解的格式，能直接加载。以上面的 ARP 代码为例：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_asm foo\n4,40 0 0 12,21 0 1 2054,6 0 0 4294967295,6 0 0 0,\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e也可以输出成更容易复制粘贴的与 C 类似的格式：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_asm \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e foo\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x28,  0,  0, 0x0000000c \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x15,  0,  1, 0x00000806 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x06,  0,  0, 0xffffffff \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x06,  0,  0, 0000000000 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"48-调试\"\u003e4.8 调试\u003c/h2\u003e\n\n\u003cp\u003ext_bpf 和 cls_bpf 场景中可能会用到非常复杂的 BPF 过滤器，不像上面的代码一眼就能看懂。\n因此在将这些复杂程序（过滤器）直接 attach 到真实系统之前，最好先在线下测试一遍。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_dbg\u003c/code\u003e 就是用于这一目的的小工具，位于内核源码 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/\u003c/code\u003e 中。它可以测试\nBPF filters，输入是 pcap 文件，支持单步运行、打印 BPF 虚拟机的寄存器状态等等。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# 使用默认 stdin/stdout\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_dbg\n\n\u003cspan class=\"c\"\u003e# 指定输入输出\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_dbg test_in.txt test_out.txt\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e此外，还支持：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~/.bpf_dbg_init\u003c/code\u003e 配置 libreadline；\u003c/li\u003e\n  \u003cli\u003e命令历史保存到文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~/.bpf_dbg_history\u003c/code\u003e 中；\u003c/li\u003e\n  \u003cli\u003e命令行补全。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"load-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e加载 \u003cstrong\u003e\u003cmark\u003ebpf_asm 标准输出文件\u003c/mark\u003e\u003c/strong\u003e，或 \u003cstrong\u003e\u003cmark\u003etcpdump -ddd 输出文件\u003c/mark\u003e\u003c/strong\u003e\n（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump -iem1 -ddd port 22 | tr \u0026#39;\\n\u0026#39; \u0026#39;,\u0026#39;\u003c/code\u003e 的输出）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e load bpf 6,40 0 0 12,21 0 3 2048,48 0 0 23,21 0 1 1,6 0 0 65535,6 0 0 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意：对于 JIT debugging（后面介绍），以上命令会\u003cstrong\u003e\u003cmark\u003e创建一个临时 socket\u003c/mark\u003e\u003c/strong\u003e，\n然后将 BPF 代码加载到内核。因此这对 JIT 开发者也有帮助。\u003c/p\u003e\n\n\u003cp\u003e加载\u003cstrong\u003e\u003cmark\u003e标准 tcpdump pcap 文件\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u0026gt; load pcap foo.pcap\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"run-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erun\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e对 pcap 内的前 n 个包执行过滤器：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e run \u003cspan class=\"o\"\u003e[\u003c/span\u003e\u0026lt;n\u0026gt;]\nbpf passes:1 fails:9\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e打印的是命中和未命中过滤规则的包数。\u003c/p\u003e\n\n\u003ch3 id=\"disassemble-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edisassemble\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e反汇编：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e disassemble\nl0:    ldh \u003cspan class=\"o\"\u003e[\u003c/span\u003e12]\nl1:    jeq \u003cspan class=\"c\"\u003e#0x800, l2, l5\u003c/span\u003e\nl2:    ldb \u003cspan class=\"o\"\u003e[\u003c/span\u003e23]\nl3:    jeq \u003cspan class=\"c\"\u003e#0x1, l4, l5\u003c/span\u003e\nl4:    ret \u003cspan class=\"c\"\u003e#0xffff\u003c/span\u003e\nl5:    ret \u003cspan class=\"c\"\u003e#0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"dump-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edump\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e以 C 风格打印 BPF 代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edump\n/\u003cspan class=\"k\"\u003e*\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e op, jt, jf, k \u003cspan class=\"o\"\u003e}\u003c/span\u003e, \u003cspan class=\"k\"\u003e*\u003c/span\u003e/\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x28,  0,  0, 0x0000000c \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x15,  0,  3, 0x00000800 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x30,  0,  0, 0x00000017 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x15,  0,  1, 0x00000001 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x06,  0,  0, 0x0000ffff \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e 0x06,  0,  0, 0000000000 \u003cspan class=\"o\"\u003e}\u003c/span\u003e,\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"breakpoint-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebreakpoint\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e breakpoint 0\nbreakpoint at: l0:    ldh \u003cspan class=\"o\"\u003e[\u003c/span\u003e12]\n\n\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e breakpoint 1\nbreakpoint at: l1:    jeq \u003cspan class=\"c\"\u003e#0x800, l2, l5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"run-命令-1\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erun\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e在特定指令设置断点之后，执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erun\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e run\n\n\u003cspan class=\"nt\"\u003e--\u003c/span\u003e register dump \u003cspan class=\"nt\"\u003e--\u003c/span\u003e\npc:       \u003cspan class=\"o\"\u003e[\u003c/span\u003e0]                       \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e program counter\ncode:     \u003cspan class=\"o\"\u003e[\u003c/span\u003e40] jt[0] jf[0] k[12]    \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e plain BPF code of current instruction\ncurr:     l0:    ldh \u003cspan class=\"o\"\u003e[\u003c/span\u003e12]           \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e disassembly of current instruction\nA:        \u003cspan class=\"o\"\u003e[\u003c/span\u003e00000000][0]             \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e content of A \u003cspan class=\"o\"\u003e(\u003c/span\u003ehex, decimal\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nX:        \u003cspan class=\"o\"\u003e[\u003c/span\u003e00000000][0]             \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e content of X \u003cspan class=\"o\"\u003e(\u003c/span\u003ehex, decimal\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nM[0,15]:  \u003cspan class=\"o\"\u003e[\u003c/span\u003e00000000][0]             \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e folded content of M \u003cspan class=\"o\"\u003e(\u003c/span\u003ehex, decimal\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003cspan class=\"nt\"\u003e--\u003c/span\u003e packet dump \u003cspan class=\"nt\"\u003e--\u003c/span\u003e                   \u0026lt;\u003cspan class=\"nt\"\u003e--\u003c/span\u003e Current packet from pcap \u003cspan class=\"o\"\u003e(\u003c/span\u003ehex\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nlen: 42\n    0: 00 19 cb 55 55 a4 00 14 a4 43 78 69 08 06 00 01\n16: 08 00 06 04 00 01 00 14 a4 43 78 69 0a 3b 01 26\n32: 00 00 00 00 00 00 0a 3b 01 01\n\u003cspan class=\"o\"\u003e(\u003c/span\u003ebreakpoint\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e breakpoint \u003cspan class=\"c\"\u003e# 打印断点\u003c/span\u003e\nbreakpoints: 0 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"step-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estep\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e从当前 pc offset 开始，单步执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e step \u003cspan class=\"o\"\u003e[\u003c/span\u003e-\u0026lt;n\u0026gt;, +\u0026lt;n\u0026gt;]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e每执行一步，就会像 run 输出一样 dump 寄存器状态。\u003c/p\u003e\n\n\u003cp\u003e注意这里可以单步前进，也可以单步后退。\u003c/p\u003e\n\n\u003ch3 id=\"select-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eselect\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cp\u003e选择从第 n 个包开始执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eselect\u003c/span\u003e \u0026lt;n\u0026gt; \u003cspan class=\"c\"\u003e# 接下来执行 run 或 step 命令\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意与 Wireshark 一样，n 是从 1 开始的。\u003c/p\u003e\n\n\u003ch3 id=\"quit-命令\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003equit\u003c/code\u003e 命令\u003c/h3\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e quit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e退出 bpf_dbg。\u003c/p\u003e\n\n\u003ch1 id=\"5-cbpf-jit-编译器\"\u003e5 cBPF JIT 编译器\u003c/h1\u003e\n\n\u003cp\u003eLinux 内核内置了一个 BPF JIT 编译器，支持 x86_64、SPARC、PowerPC、ARM、ARM64、MIPS、\nRISC-V 和 s390，编译内核时需要打开 \u003cstrong\u003e\u003cmark\u003eCONFIG_BPF_JIT\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"51-内核配置项bpf_jit_enable\"\u003e5.1 内核配置项：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_enable\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e启用 JIT 编译器：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e1 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_enable\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果想每次编译过滤器时，都将生成的 opcode 镜像都\u003cstrong\u003e\u003cmark\u003e打印到内核日志中\u003c/mark\u003e\u003c/strong\u003e，可以配置：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e2 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e /proc/sys/net/core/bpf_jit_enable\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这对 JIT 开发者和审计来说比较有用。下面是 dmesg 的输出：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935842] \u003cspan class=\"nv\"\u003eflen\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e6 \u003cspan class=\"nv\"\u003eproglen\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e70 \u003cspan class=\"nv\"\u003epass\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e3 \u003cspan class=\"nv\"\u003eimage\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003effffffffa0069c8f\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果在编译时设置了 \u003cstrong\u003e\u003cmark\u003eCONFIG_BPF_JIT_ALWAYS_ON\u003c/mark\u003e\u003c/strong\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_enable\u003c/code\u003e 就会\n\u003cstrong\u003e\u003cmark\u003e永久性设为 1\u003c/mark\u003e\u003c/strong\u003e，再设置成其他值时会报错 —— 包括将其设为 2 时，因为\n\u003cstrong\u003e\u003cmark\u003e并不推荐将最终的 JIT 镜像打印到内核日志\u003c/mark\u003e\u003c/strong\u003e，通常推荐开发者通过 bpftool\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/bpftool/\u003c/code\u003e 来查看镜像内容。\u003c/p\u003e\n\n\u003ch2 id=\"52-工具bpf_jit_disasm\"\u003e5.2 工具：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_disasm\u003c/code\u003e\u003c/h2\u003e\n\n\u003cp\u003e在内核 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etools/bpf/\u003c/code\u003e 目录下还有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_jit_disasm\u003c/code\u003e 工具，用于生成\u003cstrong\u003e\u003cmark\u003e反汇编\u003c/mark\u003e\u003c/strong\u003e（disassembly），\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./bpf_jit_disasm\n70 bytes emitted from JIT compiler \u003cspan class=\"o\"\u003e(\u003c/span\u003epass:3, flen:6\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nffffffffa0069c8f + \u0026lt;x\u0026gt;:\n0:     push   %rbp                 \u003cspan class=\"p\"\u003e;\u003c/span\u003e 这些已经是 eBPF 指令而非 cBPF 指令，后面章节会详细介绍\n1:     mov    %rsp,%rbp\n4:     sub    \u003cspan class=\"nv\"\u003e$0x60\u003c/span\u003e,%rsp\n8:     mov    %rbx,-0x8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rbp\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nc:     mov    0x68\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n10:    sub    0x6c\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n14:    mov    0xd8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r8\n1b:    mov    \u003cspan class=\"nv\"\u003e$0xc\u003c/span\u003e,%esi\n20:    callq  0xffffffffe0ff9442\n25:    cmp    \u003cspan class=\"nv\"\u003e$0x800\u003c/span\u003e,%eax\n2a:    jne    0x0000000000000042\n2c:    mov    \u003cspan class=\"nv\"\u003e$0x17\u003c/span\u003e,%esi\n31:    callq  0xffffffffe0ff945e\n36:    cmp    \u003cspan class=\"nv\"\u003e$0x1\u003c/span\u003e,%eax\n39:    jne    0x0000000000000042\n3b:    mov    \u003cspan class=\"nv\"\u003e$0xffff\u003c/span\u003e,%eax\n40:    jmp    0x0000000000000044\n42:    xor    %eax,%eax\n44:    leaveq\n45:    retq\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-o\u003c/code\u003e 参数可以\u003cstrong\u003e\u003cmark\u003e对照打印字节码和相应的汇编指令\u003c/mark\u003e\u003c/strong\u003e，对 JIT 开发者非常有用：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# ./bpf_jit_disasm -o\u003c/span\u003e\n70 bytes emitted from JIT compiler \u003cspan class=\"o\"\u003e(\u003c/span\u003epass:3, flen:6\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nffffffffa0069c8f + \u0026lt;x\u0026gt;:\n0:    push   %rbp\n      55\n1:    mov    %rsp,%rbp\n      48 89 e5\n4:    sub    \u003cspan class=\"nv\"\u003e$0x60\u003c/span\u003e,%rsp\n      48 83 ec 60\n8:    mov    %rbx,-0x8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rbp\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n      48 89 5d f8\nc:    mov    0x68\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n      44 8b 4f 68\n10:   sub    0x6c\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r9d\n      44 2b 4f 6c\n14:   mov    0xd8\u003cspan class=\"o\"\u003e(\u003c/span\u003e%rdi\u003cspan class=\"o\"\u003e)\u003c/span\u003e,%r8\n      4c 8b 87 d8 00 00 00\n1b:   mov    \u003cspan class=\"nv\"\u003e$0xc\u003c/span\u003e,%esi\n      be 0c 00 00 00\n20:   callq  0xffffffffe0ff9442\n      e8 1d 94 ff e0\n25:   cmp    \u003cspan class=\"nv\"\u003e$0x800\u003c/span\u003e,%eax\n      3d 00 08 00 00\n2a:   jne    0x0000000000000042\n      75 16\n2c:   mov    \u003cspan class=\"nv\"\u003e$0x17\u003c/span\u003e,%esi\n      be 17 00 00 00\n31:   callq  0xffffffffe0ff945e\n      e8 28 94 ff e0\n36:   cmp    \u003cspan class=\"nv\"\u003e$0x1\u003c/span\u003e,%eax\n      83 f8 01\n39:   jne    0x0000000000000042\n      75 07\n3b:   mov    \u003cspan class=\"nv\"\u003e$0xffff\u003c/span\u003e,%eax\n      b8 ff ff 00 00\n40:   jmp    0x0000000000000044\n      eb 02\n42:   xor    %eax,%eax\n      31 c0\n44:   leaveq\n      c9\n45:   retq\n      c3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"53-jit-开发者工具箱\"\u003e5.3 JIT 开发者工具箱\u003c/h2\u003e\n\n\u003cp\u003e对 JIT 开发者来说，我们已经介绍的这几个工具：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ebpf_jit_disasm\u003c/li\u003e\n  \u003cli\u003ebpf_asm\u003c/li\u003e\n  \u003cli\u003ebpf_dbg\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e都是非常有用的。\u003c/p\u003e\n\n\u003ch1 id=\"-2\"\u003e————————————————————————\u003c/h1\u003e\n\u003ch1 id=\"ebpf-相关内容\"\u003eeBPF 相关内容\u003c/h1\u003e\n\u003ch1 id=\"-3\"\u003e————————————————————————\u003c/h1\u003e\n\n\u003ch1 id=\"6-bpf-kernel-internalsebpf\"\u003e6 BPF kernel internals（eBPF）\u003c/h1\u003e\n\n\u003cp\u003e在内核内部，解释器（the kernel interpreter）使用的是与 cBPF 类似、但属于\u003cstrong\u003e\u003cmark\u003e另一种指令集的格式\u003c/mark\u003e\u003c/strong\u003e。\n这种指令集格式参考了\u003cstrong\u003e\u003cmark\u003e处理器原生指令集建模\u003c/mark\u003e\u003c/strong\u003e，因此\u003cstrong\u003e\u003cmark\u003e更接近底层处理器架构\u003c/mark\u003e\u003c/strong\u003e，\n性能更好（后面会详细介绍）。\u003c/p\u003e\n\n\u003cp\u003e这种\u003cstrong\u003e\u003cmark\u003e新的指令集称为 “eBPF”\u003c/mark\u003e\u003c/strong\u003e，也叫 “internal BPF”。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：eBPF 这个名字源自 \u003cstrong\u003e\u003cmark\u003e[e]xtended BPF\u003c/mark\u003e\u003c/strong\u003e（直译为“扩展的 BPF”），\n它与 \u003cstrong\u003e\u003cmark\u003eBPF extensions\u003c/mark\u003e\u003c/strong\u003e（直译为 “BPF 扩展”，见前面章节）并不是一个概念！\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eeBPF 是一种\u003cstrong\u003e\u003cmark\u003e指令集架构（ISA）\u003c/mark\u003e\u003c/strong\u003e（在 ELF 规范中有正式的 ISA 编号 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0xF7\u003c/code\u003e，译注），\u003c/li\u003e\n    \u003cli\u003eBPF extensions 是早年 \u003cstrong\u003e\u003cmark\u003ecBPF\u003c/mark\u003e\u003c/strong\u003e 中对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD | BPF_{B,H,W} | BPF_ABS\u003c/code\u003e 几个指令\u003cstrong\u003e\u003cmark\u003e进行 overloading 的技术\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"61-ebpf-设计考虑\"\u003e6.1 eBPF 设计考虑\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e力求 \u003cstrong\u003e\u003cmark\u003eJIT 编译时，能将 eBPF 指令一一映射到原生指令\u003c/mark\u003e\u003c/strong\u003e，\n 这种设计也给 GCC/LLVM 等编译器打开了方便之门，因为它们可以通过各自的\n \u003cstrong\u003e\u003cmark\u003eeBPF 后端生成优化的、与原生编译之后的代码几乎一样快\u003c/mark\u003e\u003c/strong\u003e的 eBPF 代码。\u003c/li\u003e\n  \u003cli\u003e最初设计时，目标是能用 \u003cstrong\u003e\u003cmark\u003e“受限的 C 语言”\u003c/mark\u003e\u003c/strong\u003e 来编写程序，然后\n通过可选的 GCC/LLVM 后端编译成 eBPF，因此它能以两步最小的性能开销，即时映射成\n现代 64 位 CPU 指令，即 \u003cstrong\u003e\u003cmark\u003eC -\u0026gt; eBPF -\u0026gt; native code\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"62-cbpf-ebpf-自动转换\"\u003e6.2 cBPF-\u0026gt;eBPF 自动转换\u003c/h2\u003e\n\n\u003cp\u003e下列 cBPF 的经典使用场景中：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eseccomp BPF\u003c/li\u003e\n  \u003cli\u003eclassic socket filters\u003c/li\u003e\n  \u003cli\u003ecls_bpf traffic classifier\u003c/li\u003e\n  \u003cli\u003eteam driver’s classifier for its load-balancing mode\u003c/li\u003e\n  \u003cli\u003enetfilter’s xt_bpf extension\u003c/li\u003e\n  \u003cli\u003ePTP dissector/classifier\u003c/li\u003e\n  \u003cli\u003eand much more.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ecBPF 已经在内核中被\u003cstrong\u003e\u003cmark\u003e透明地转换成了 eBPF，然后在 eBPF 解释器中执行\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e在 in-kernel handlers 中，可以使用下面的函数：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_create()\u003c/code\u003e 创建过滤器；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_destroy()\u003c/code\u003e 销毁过滤器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_PROG_RUN(filter, ctx)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 执行过滤代码，它或者\n透明地\u003cstrong\u003e\u003cmark\u003e触发 eBPF 解释器执行\u003c/mark\u003e\u003c/strong\u003e，或者\u003cstrong\u003e\u003cmark\u003e执行 JIT 编译之后的代码\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efilter\u003c/code\u003e 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_create()\u003c/code\u003e 的返回值，类型是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_prog *\u003c/code\u003e 类型；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e 是程序上下文（例如 skb 指针）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在转换成新指令之前，会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_check_classic()\u003c/code\u003e 检查 cBPF 程序是否有问题。\u003c/p\u003e\n\n\u003cp\u003e当前，在大部分 32 位架构上，都是用 cBPF 格式做 JIT 编译；\n而在 x86-64, aarch64, s390x, powerpc64, sparc64, arm32, riscv64, riscv32 架构上，直接从 eBPF 指令集执行 JIT 编译。\u003c/p\u003e\n\n\u003ch2 id=\"63-ebpf-相比-cbpf-的核心变化\"\u003e6.3 eBPF 相比 cBPF 的核心变化\u003c/h2\u003e\n\n\u003ch3 id=\"631-寄存器数量从-2-个增加到-10-个\"\u003e6.3.1 寄存器数量从 2 个增加到 10 个\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e老格式（cBPF）只有两个寄存器 A 和 X，以及一个隐藏的栈指针（frame pointer）。\u003c/li\u003e\n  \u003cli\u003e新格式（eBPF）扩展到了 10 个内部寄存器，以及一个只读的栈指针。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"传参寄存器数量\"\u003e传参寄存器数量\u003c/h4\u003e\n\n\u003cp\u003e由于 64 位 CPU 都是\u003cstrong\u003e\u003cmark\u003e通过寄存器传递函数参数\u003c/mark\u003e\u003c/strong\u003e的，因此从 eBPF 程序\n传给内核函数（in-kernel function）的\u003cstrong\u003e\u003cmark\u003e参数数量限制到 5 个\u003c/mark\u003e\u003c/strong\u003e，另有\n一个寄存器用来接收内核函数的返回值，\u003c/p\u003e\n\n\u003cp\u003e考虑到\u003cstrong\u003e\u003cmark\u003e具体的处理器架构\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e 有 6 寄存器用于传参，6 个被调用方（callee）负责保存的寄存器；\u003c/li\u003e\n  \u003cli\u003eaarch64/sparcv9/mips64 有 7-8 个传参寄存器，11 个被调用方（callee）负责保存的寄存器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4 id=\"ebpf-调用约定\"\u003eeBPF 调用约定\u003c/h4\u003e\n\n\u003cp\u003e因此，\u003cstrong\u003e\u003cmark\u003eeBPF 调用约定\u003c/mark\u003e\u003c/strong\u003e（calling convention）定义如下：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eR0    - return value from in-kernel function, and exit value for eBPF program\u003c/li\u003e\n  \u003cli\u003eR1 - R5    - arguments from eBPF program to in-kernel function\u003c/li\u003e\n  \u003cli\u003eR6 - R9    - callee saved registers that in-kernel function will preserve\u003c/li\u003e\n  \u003cli\u003eR10    - read-only frame pointer to access stack\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这样的设计，使\u003cstrong\u003e\u003cmark\u003e所有的 eBPF 寄存器都能一一映射到\u003c/mark\u003e\u003c/strong\u003e x86_64、aarch64\n等架构上的\u003cstrong\u003e\u003cmark\u003e硬件寄存器\u003c/mark\u003e\u003c/strong\u003e，eBPF 调用约定也直接映射到 64 位的内核 ABI。\u003c/p\u003e\n\n\u003cp\u003e在 32 位架构上，JIT 只能编译那些只使用了 32bit 算术操作的程序，其他更复杂的程序，交给解释器来执行。\u003c/p\u003e\n\n\u003ch3 id=\"632-寄存器位宽从-32bit-扩展到-64bit\"\u003e6.3.2 寄存器位宽从 32bit 扩展到 64bit\u003c/h3\u003e\n\n\u003cp\u003e原来的 32bit ALU 操作仍然是支持的，通过 32bit 子寄存器执行。\n所有 eBPF 寄存器都是 64bit 的，如果对 32bit 子寄存器有写入操作，它会被 zero-extend 成 64bit。\n这种行为能直接映射到 x86_64 和 arm64 子寄存器的定义，但对其他处理器架构来说，JIT 会更加困难。\u003c/p\u003e\n\n\u003cp\u003e32-bit 的处理器架构上，通过解释器执行 64-bit 的 eBPF 程序。这种平台上的 JIT 编译器\n只能编译那些只使用了 32bit 子寄存器的程序，其他不能编译的程序，通过解释器执行。\u003c/p\u003e\n\n\u003cp\u003eeBPF 操作都是 64 位的，原因：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e64 位处理器架构上指针也是 64 位的，我们希望与内核函数交互时，输入输出的都是\n64 位值。如果使用 32 位 eBPF 寄存器，就需要定义 register-pair ABI，导致无法\n直接将 eBPF 寄存器映射到物理寄存器，JIT 就必须为与函数调用相关的每个寄存器承\n担 拼装/拆分/移动 等等操作，不仅复杂，而且很容易产生 bug，效率也很低。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e另一个原因是 eBPF 使用了 64 位的原子计数器（atomic 64-bit counters）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"633-条件跳转jtfall-through-取代-jtjf\"\u003e6.3.3 条件跳转：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt/fall-through\u003c/code\u003e 取代 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejt/jf\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003ecBPF 的设计中有条件判断：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ejump_true\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ejump_false\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在被下面的结构取代了：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ejump_true\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/* else fall-through */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"634-引入-bpf_call-指令和寄存器传参约定实现零额外开销内核函数调用\"\u003e6.3.4 引入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_call\u003c/code\u003e 指令和寄存器传参约定，实现零（额外）开销内核函数调用\u003c/h3\u003e\n\n\u003cp\u003e引入的寄存器传参约定，能实现\n零开销内核函数调用（zero overhead calls from/to other kernel functions）。\u003c/p\u003e\n\n\u003cp\u003e在调用内核函数之前，eBPF 程序需要按照调用约定，将参数依次放到 R1-R5 寄存器；\n然后解释器会从这些寄存器读取参数，传递给内核函数。\u003c/p\u003e\n\n\u003ch4 id=\"原理jit-实现零额外开销内核函数调用\"\u003e原理：JIT 实现零（额外）开销内核函数调用\u003c/h4\u003e\n\n\u003cp\u003e如果 R1-R5 能一一映射到处理器上的寄存器，JIT 编译器就\u003cstrong\u003e\u003cmark\u003e无需 emit 任何额外的指令\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e函数\u003cstrong\u003e\u003cmark\u003e参数已经在（硬件处理器）期望的位置\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e只需要将 eBPF \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CALL\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003eJIT 编译成一条处理器原生的 \u003ccode\u003ecall\u003c/code\u003e 指令\u003c/mark\u003e\u003c/strong\u003e就行了。\u003c/li\u003e\n  \u003cli\u003e这种\u003cstrong\u003e\u003cmark\u003e无性能损失的调用约定\u003c/mark\u003e\u003c/strong\u003e设计，足以覆盖大部分场景。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e函数调用结束后，R1-R5 会被重置为不可读状态（unreadable），函数返回值存放在 R0。\nR6-R9 是被调用方（callee）保存的，因此函数调用结束后里面的值是可读的。\u003c/p\u003e\n\n\u003ch4 id=\"示例解析一ebpfc-函数混合调用jit-生成的-x86_64-指令\"\u003e示例解析（一）：eBPF/C 函数混合调用，JIT 生成的 x86_64 指令\u003c/h4\u003e\n\n\u003cp\u003e考虑下面的三个 C 函数：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"nf\"\u003ef1\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003e_f2\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"nf\"\u003ef2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ef3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"nf\"\u003ef3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eGCC 能将 f1 和 f3 编译成 x86_64：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ef1:\nmovl $1, %edi         ; 将常量 1 加载到 edi 寄存器\nmovq _f2(%rip), %rax  ; 将 _f2 地址加载到 rax 寄存器\njmp  *%rax            ; 跳转到 rax 寄存器中指定的地址（即函数 _f2 的起始地址）\n\nf3:\nmovq %rdi, %rax       ; 将寄存器 rdi 中的值加载到寄存器 rax\nsubq %rsi, %rax       ; 将寄存器 rax 中的值减去寄存器 rsi 中的值（即 a-b）\nret                   ; 返回\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ef2 的 eBPF 代码可能如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ef2:\nbpf_mov R2, R1          ; 即 R2 = a\nbpf_add R1, 1           ; 即 R1 = a + 1\nbpf_call f3             ; 调用 f3，传递给 f3 的两个参数分别在 R1 和 R2 中\nbpf_exit                ; 退出\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果 \u003cstrong\u003e\u003cmark\u003ef2 是 JIT 编译的\u003c/mark\u003e\u003c/strong\u003e，函数地址保存为变量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_f2\u003c/code\u003e，那调用链 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef1 -\u0026gt; f2 -\u0026gt; f3\u003c/code\u003e 及返回就都是连续的。\u003c/li\u003e\n  \u003cli\u003e如果\u003cstrong\u003e\u003cmark\u003e没有 JIT\u003c/mark\u003e\u003c/strong\u003e，就需要\u003cstrong\u003e\u003cmark\u003e调用解释器 \u003ccode\u003e__bpf_prog_run()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 来调用执行 f2。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e出于一些实际考虑，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e所有 eBPF 程序都只有一个参数 \u003ccode\u003ectx\u003c/code\u003e，放在 R1 寄存器中\u003c/mark\u003e\u003c/strong\u003e，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__bpf_prog_run(ctx)\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e函数调用最多支持传递 5 个参数，但如果将来有需要，这个限制也可以进一步放宽。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"ebpf-寄存器到-x86_64-硬件寄存器一一映射关系\"\u003eeBPF 寄存器到 x86_64 硬件寄存器一一映射关系\u003c/h4\u003e\n\n\u003cp\u003e在 64 位架构上，所有寄存器都能一一映射到硬件寄存器。例如，由于 \u003cstrong\u003e\u003cmark\u003ex86_64 ABI 硬性规定\u003c/mark\u003e\u003c/strong\u003e了\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003erdi、rsi、rdx、rcx、r8\u003c/mark\u003e\u003c/strong\u003e、 r9 寄存器作为参数传递；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003erbx\u003c/mark\u003e\u003c/strong\u003e，以及 \u003cstrong\u003e\u003cmark\u003er12 - r15\u003c/mark\u003e\u003c/strong\u003e 由被调用方（callee）保存；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此 \u003cstrong\u003e\u003cmark\u003ex86_64 编译会做如下映射\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eR0 -\u0026gt; rax\n\nR1 -\u0026gt; rdi  ; 传参，调用方（caller）保存\nR2 -\u0026gt; rsi  ; 传参，调用方（caller）保存\nR3 -\u0026gt; rdx  ; 传参，调用方（caller）保存\nR4 -\u0026gt; rcx  ; 传参，调用方（caller）保存\nR5 -\u0026gt; r8   ; 传参，调用方（caller）保存\n\nR6 -\u0026gt; rbx  ; 被调用方（callee）保存\nR7 -\u0026gt; r13  ; 被调用方（callee）保存\nR8 -\u0026gt; r14  ; 被调用方（callee）保存\nR9 -\u0026gt; r15  ; 被调用方（callee）保存\nR10 -\u0026gt; rbp ; 被调用方（callee）保存\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"示例解析二c-调-ebpf-代码编译成-x86_64-汇编后的样子\"\u003e示例解析（二）：C 调 eBPF 代码编译成 x86_64 汇编后的样子\u003c/h4\u003e\n\n\u003cp\u003e根据上面的映射关系，下面的 BPF 程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e// BPF 指令格式：\n// \u0026lt;指令\u0026gt;  \u0026lt;目的寄存器\u0026gt;  \u0026lt;源寄存器/常量\u0026gt;\n\nbpf_mov  R6, R1 ; 将 ctx 保存到 R6\nbpf_mov  R2, 2  ; 将常量 2（即将调用的函数 foo() 的参数）加载到 R2 寄存器\nbpf_mov  R3, 3\nbpf_mov  R4, 4\nbpf_mov  R5, 5\nbpf_call foo    ; 调用 foo 函数\nbpf_mov  R7, R0 ; 将 foo() 的返回值（在 R0 中）保存到 R7 中\nbpf_mov  R1, R6 ; 从 R6 中恢复 ctx 状态，保存到 R1；这样下次执行调用函数调用时就可以继续使用了；\nbpf_mov  R2, 6  ; 将常量 2（即将调用的函数 bar() 的参数）加载到 R2 寄存器\nbpf_mov  R3, 7\nbpf_mov  R4, 8\nbpf_mov  R5, 9\nbpf_call bar    ; 调用 bar() 函数\nbpf_add  R0, R7 ; 将 bar() 的返回值（在 R0 中）与 foo() 的返回值（在 R7 中）相加\nbpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 JIT 成 x86_64 之后，可能长下面这样：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e将 “eBPF 寄存器 -\u0026gt; x86_64 硬件寄存器” 映射关系贴到这里方便下面程序对照\u003c/p\u003e\n\n  \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eR0\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erax\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erdi\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 传参，调用方（caller）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR2\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ersi\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 传参，调用方（caller）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR3\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erdx\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 传参，调用方（caller）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR4\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ercx\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 传参，调用方（caller）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR5\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003er8\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 传参，调用方（caller）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR6\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erbx\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 被调用方（callee）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR7\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003er13\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 被调用方（callee）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR8\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003er14\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 被调用方（callee）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR9\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003er15\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 被调用方（callee）保存\u003c/span\u003e\n\u003cspan class=\"n\"\u003eR10\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003erbp\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 被调用方（callee）保存\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\u003c/blockquote\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// x86_64 指令格式：注意源和目的寄存器的顺序与 BPF 指令是相反的\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// \u0026lt;指令\u0026gt;  \u0026lt;源寄存器/常量\u0026gt;  \u0026lt;目的寄存器\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 下面这几行是 x86_64 的初始化指令，与 eBPF 还没有直接对应关系\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// 解读参考：https://stackoverflow.com/questions/41912684/what-is-the-purpose-of-the-rbp-register-in-x86-64-assembler\u003c/span\u003e\n\u003cspan class=\"n\"\u003epush\u003c/span\u003e   \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e                \u003cspan class=\"c1\"\u003e// 将帧指针（frame pointer）在栈地址空间中前移，即栈空间增长一个单位（一个单位 64bit）\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// 将栈指针（stack pointer）保存到 %rbp 位置（即上一行刚在栈上分配的位置）\u003c/span\u003e\n\u003cspan class=\"n\"\u003esub\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x228\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003ersp\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 栈指针 rsp -= 0x228（栈向下增长，这一行表示再分配 0x228 个单位的栈空间）\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x228\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 将 %rbx（对应 eBPF R6）的值保存到新分配空间的起始处（占用 8 个字节），因为 eBPF 程序返回时会占用 rbx 寄存器\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er13\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x220\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 将 %r13 （对应 eBPF R7）的值保存到下一个位置（起始位置 = 0x228 - 0x8 = 0x220，也是占用 8 个字节），理由同上\u003c/span\u003e\n                           \u003cspan class=\"c1\"\u003e// 接下来还应该有三条指令，分别将 r14、15、rbp 依次保存到栈上，理由同上。\u003c/span\u003e\n                           \u003cspan class=\"c1\"\u003e// 这样，这 5 条指令占用 5*8 = 40byte = 0x28 字节。刚才总共申请了 0x228 字节，\u003c/span\u003e\n                           \u003cspan class=\"c1\"\u003e// 0x228 - 0x28 = 0x200 = 512 字节，也就是 eBPF 文档里常说的：eBPF 虚拟机最大支持 512 字节的栈空间。\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// 下面这段与上面的 eBPF 指令能一一对应上\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdi\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbx\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R6 = R1\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eesi\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R2 = 2\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R3 = 3\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eecx\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R4 = 4\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8d\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R5 = 5\u003c/span\u003e\n\u003cspan class=\"n\"\u003ecallq\u003c/span\u003e  \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er13\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R7 = R0\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erdi\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R1 = R6\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eesi\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R2 = 6\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x7\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eedx\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R3 = 7\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003eecx\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R4 = 8\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"err\"\u003e$\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x9\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er8d\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R5 = 9\u003c/span\u003e\n\u003cspan class=\"n\"\u003ecallq\u003c/span\u003e  \u003cspan class=\"n\"\u003ebar\u003c/span\u003e\n\u003cspan class=\"n\"\u003eadd\u003c/span\u003e    \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er13\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erax\u003c/span\u003e          \u003cspan class=\"c1\"\u003e// R7 += R0\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x228\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbx\u003c/span\u003e\n\u003cspan class=\"n\"\u003emov\u003c/span\u003e    \u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mh\"\u003e0x220\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003erbp\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e\u003cspan class=\"n\"\u003er13\u003c/span\u003e\n\u003cspan class=\"n\"\u003eleaveq\u003c/span\u003e\n\u003cspan class=\"n\"\u003eretq\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下面是对应的 C 代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"nf\"\u003ebpf_filter\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ebar\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e6\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e7\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e8\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e内核函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoo()\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebar()\u003c/code\u003e 原型：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu64 (*)(u64 arg1, u64 arg2, u64 arg3, u64 arg4, u64 arg5);\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e它们从规定好的寄存器中获取传入参数，并将函数返回值放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e%rax\u003c/code\u003e 寄存器，也就是 eBPF 中的 R0 寄存器。\n起始和结束的汇编片段\u003cstrong\u003e\u003cmark\u003e（prologue and epilogue）是由 JIT emit 出来的，是解释器内置的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e上面添加了对起始汇编片段的一些解读，尤其是：为什么\n\u003cstrong\u003e\u003cmark\u003e“eBPF 虚拟机的最大栈空间是 512 字节”\u003c/mark\u003e\u003c/strong\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eR0-R5 are scratch registers，因此 eBPF 程序需要在多次函数调用之间保存这些值。\n下面这个程序例子是不合法的：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebpf_mov   R1, 1\nbpf_call  foo\nbpf_mov   R0, R1\nbpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e 之后，寄存器 \u003cstrong\u003e\u003cmark\u003eR1-R5 包含垃圾值，不能读取\u003c/mark\u003e\u003c/strong\u003e。\n内核中的校验器（in-kernel eBPF verifier）负责验证 eBPF 程序的合法性。\u003c/p\u003e\n\n\u003ch2 id=\"64-ebpf-程序最大指令数限制\"\u003e6.4 eBPF 程序最大指令数限制\u003c/h2\u003e\n\n\u003cp\u003eeBPF 最初限制最大指令数 4096，现在已经将这个限制放大到了 \u003cstrong\u003e\u003cmark\u003e100 万条\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003ecBPF 和 eBPF 都是\u003cstrong\u003e\u003cmark\u003e两操作数指令\u003c/mark\u003e\u003c/strong\u003e（two operand instructions），有\n助于 JIT 编译时将 eBPF 指令一一映射成 x86 指令。\u003c/p\u003e\n\n\u003ch2 id=\"65-ebpf-程序上下文ctx参数\"\u003e6.5 eBPF 程序上下文（ctx）参数\u003c/h2\u003e\n\n\u003cp\u003e触发解释器执行时，传递给它的上下文指针（the input context pointer）是一个通用结构体，\n\u003cstrong\u003e\u003cmark\u003e结构体中的信息是由具体场景来解析的\u003c/mark\u003e\u003c/strong\u003e。例如\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对于 seccomp 来说，R1（也就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e）指向 seccomp_data，\u003c/li\u003e\n  \u003cli\u003e对于 eBPF filter（包括从 cBPF 转换过来的）来说，R1 \u003cstrong\u003e\u003cmark\u003e指向一个 skb\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"66-cbpf---ebpf-转换若干问题\"\u003e6.6 cBPF -\u0026gt; eBPF 转换若干问题\u003c/h2\u003e\n\n\u003cp\u003e内部的 cBPF -\u0026gt; eBPF 转换格式如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eop:16, jt:8, jf:8, k:32    ==\u0026gt;    op:8, dst_reg:4, src_reg:4, off:16, imm:32\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e目前已经实现了 87 条 eBPF 指令；\u003c/li\u003e\n  \u003cli\u003e8bit 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 字段最多支持 256 条，因此还有扩展空间，可用于增加新指令；\u003c/li\u003e\n  \u003cli\u003eSome of them may use 16/24/32 byte encoding；\u003c/li\u003e\n  \u003cli\u003eeBPF 指令必须是 8 字节对齐的，以保持后向兼容。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eeBPF 是一个\u003cstrong\u003e\u003cmark\u003e通用目的 RISC 指令集\u003c/mark\u003e\u003c/strong\u003e。在将 cBPF 转成 eBPF 的过程中\n，不是每个寄存器和每条指令都会用到。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003esocket filters 没有用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexclusive add\u003c/code\u003e 指令，而 tracing filters 可能会在维护\n事件计数器时用到这种 add；\u003c/li\u003e\n  \u003cli\u003esocket filters 也没有用到 R9 寄存器，但更加复杂的 filters 可能会用完所有的寄\n存器（还不够），因此还有用的 spill/fill to stack 之类的技术。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e某种意义上来说，eBPF 作为一个\u003cstrong\u003e\u003cmark\u003e通用汇编器\u003c/mark\u003e\u003c/strong\u003e（generic assembler），\n是性能优化的最后手段，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003esocket filters 和 seccomp 就是把它当做汇编器在用；\u003c/li\u003e\n  \u003cli\u003eTracing filters 可以用它作为汇编器，从内核生成代码。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"67-ebpf-的安全性\"\u003e6.7 eBPF 的安全性\u003c/h2\u003e\n\n\u003cp\u003e内核内使用（in kernel usage）可能没有安全顾虑，因为生成的 eBPF 代码只是用于优化\n内核内部代码路径，不会暴露给用户空间。eBPF 的安全问题可能会出自校验器本身（TBD\n）。因此在上述这些场景，可以把它作为一个安全的指令集来使用。\u003c/p\u003e\n\n\u003cp\u003e与 cBPF 类似，eBPF 运行在一个确定性的受控环境中，内核能依据下面两个步骤，轻松地对\n\u003cstrong\u003e\u003cmark\u003e程序的安全性\u003c/mark\u003e\u003c/strong\u003e作出判断：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e首先进行\u003cstrong\u003e\u003cmark\u003e深度优先搜索\u003c/mark\u003e\u003c/strong\u003e（depth-first-search），禁止循环；其他 CFG 验证。\u003c/li\u003e\n  \u003cli\u003e以上一步生成的指令作为输入，\u003cstrong\u003e\u003cmark\u003e遍历所有可能的执行路径\u003c/mark\u003e\u003c/strong\u003e。具体说\n就是模拟每条指令的执行，\u003cstrong\u003e\u003cmark\u003e观察寄存器和栈的状态变化\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"7-ebpf-字节码编码opcode-encoding\"\u003e7 eBPF 字节码编码（opcode encoding）\u003c/h1\u003e\n\n\u003cp\u003e为方便 cBPF 到 eBPF 的转换，eBPF 复用了 cBPF 的大部分 opcode encoding。\u003c/p\u003e\n\n\u003ch2 id=\"71-算术和跳转指令\"\u003e7.1 算术和跳转指令\u003c/h2\u003e\n\n\u003cp\u003e对于算术和跳转指令（arithmetic and jump instructions），eBPF 的 8bit \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eop\u003c/code\u003e 字段进一步分为三部分：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e+----------------+--------+--------------------+\n|   4 bits       |  1 bit |   3 bits           |\n| operation code | source | instruction class  |\n+----------------+--------+--------------------+\n(MSB)                                      (LSB)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后的 3bit 表示的是指令类型，包括：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e===================     ===============\nClassic BPF classes     eBPF classes\n===================     ===============\nBPF_LD    0x00          BPF_LD    0x00\nBPF_LDX   0x01          BPF_LDX   0x01\nBPF_ST    0x02          BPF_ST    0x02\nBPF_STX   0x03          BPF_STX   0x03\nBPF_ALU   0x04          BPF_ALU   0x04\nBPF_JMP   0x05          BPF_JMP   0x05\nBPF_RET   0x06          BPF_JMP32 0x06\nBPF_MISC  0x07          BPF_ALU64 0x07\n===================     ===============\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"bpf_alu-和-bpf_jmp-的-operand\"\u003eBPF_ALU 和 BPF_JMP 的 operand\u003c/h3\u003e\n\n\u003cp\u003e当 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CLASS(code) == BPF_ALU or BPF_JMP\u003c/code\u003e 时，第\n4 bit 表示的源操作数（source operand）可以是：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eBPF_K\u003c/span\u003e     \u003cspan class=\"mh\"\u003e0x00\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 32bit 立即数作为源操作数（use 32-bit immediate as source operand），对 cBPF/eBPF 一样\u003c/span\u003e\n\u003cspan class=\"n\"\u003eBPF_X\u003c/span\u003e     \u003cspan class=\"mh\"\u003e0x08\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 对 cBPF，表示用寄存器 X       作为源操作数\u003c/span\u003e\n               \u003cspan class=\"c1\"\u003e// 对 eBPF，表示用寄存器 src_reg 作为源操作数\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"bpf_alu-和-bpf_alu64-ebpf-的-opcode\"\u003eBPF_ALU 和 BPF_ALU64 (eBPF) 的 opcode\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CLASS(code) == BPF_ALU or BPF_ALU64 [ in eBPF ]\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_OP(code)\u003c/code\u003e 可以是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ADD   0x00\nBPF_SUB   0x10\nBPF_MUL   0x20\nBPF_DIV   0x30\nBPF_OR    0x40\nBPF_AND   0x50\nBPF_LSH   0x60\nBPF_RSH   0x70\nBPF_NEG   0x80\nBPF_MOD   0x90\nBPF_XOR   0xa0\nBPF_MOV   0xb0  /* eBPF only: mov reg to reg */\nBPF_ARSH  0xc0  /* eBPF only: sign extending shift right */\nBPF_END   0xd0  /* eBPF only: endianness conversion */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"bpf_jmp-和-bpf_jmp32-ebpf-的-opcode\"\u003eBPF_JMP 和 BPF_JMP32 (eBPF) 的 opcode\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_CLASS(code) == BPF_JMP or BPF_JMP32 [ in eBPF ]\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e BPF_OP(code)\u003c/code\u003e 可以是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_JA    0x00  /* BPF_JMP only */\nBPF_JEQ   0x10\nBPF_JGT   0x20\nBPF_JGE   0x30\nBPF_JSET  0x40\nBPF_JNE   0x50  /* eBPF only: jump != */\nBPF_JSGT  0x60  /* eBPF only: signed \u0026#39;\u0026gt;\u0026#39; */\nBPF_JSGE  0x70  /* eBPF only: signed \u0026#39;\u0026gt;=\u0026#39; */\nBPF_CALL  0x80  /* eBPF BPF_JMP only: function call */\nBPF_EXIT  0x90  /* eBPF BPF_JMP only: function return */\nBPF_JLT   0xa0  /* eBPF only: unsigned \u0026#39;\u0026lt;\u0026#39; */\nBPF_JLE   0xb0  /* eBPF only: unsigned \u0026#39;\u0026lt;=\u0026#39; */\nBPF_JSLT  0xc0  /* eBPF only: signed \u0026#39;\u0026lt;\u0026#39; */\nBPF_JSLE  0xd0  /* eBPF only: signed \u0026#39;\u0026lt;=\u0026#39; */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e指令 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_ADD | BPF_X | BPF_ALU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 在 cBPF 和 eBPF 中都表示 32bit 加法：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecBPF 中只有两个寄存器，因此它表示的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eA += X\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003eeBPF 中表示的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_reg = (u32) dst_reg + (u32) src_reg\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e类似的，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_XOR | BPF_K | BPF_ALU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 表示：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecBPF 中：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eA ^= imm32\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003eeBPF 中：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_reg = (u32) src_reg ^ (u32) imm32\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"bpf_misc-与-bpf_alu64ebpf-64bit-寄存器加法操作\"\u003eBPF_MISC 与 BPF_ALU64（eBPF 64bit 寄存器加法操作）\u003c/h3\u003e\n\n\u003cp\u003ecBPF 用 BPF_MISC 类型表示 A = X 和 X = A 操作。\u003c/p\u003e\n\n\u003cp\u003eeBPF 中与此对应的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_MOV | BPF_X | BPF_ALU\u003c/code\u003e。\n由于 eBPF 中没有 BPF_MISC 操作，因此 class 7 空出来了，用作了新指令类型 BPF_ALU64，表示 64bit BPF_ALU 操作。\n因此，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ADD | BPF_X | BPF_ALU64\u003c/code\u003e 表示 64bit 加法，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_reg = dst_reg + src_reg\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"cbpfebpf-bpf_ret-指令的不同\"\u003ecBPF/eBPF BPF_RET 指令的不同\u003c/h3\u003e\n\n\u003cp\u003ecBPF 用整个 BPF_RET class 仅仅表示一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eret\u003c/code\u003e 操作，非常浪费。\n其 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_RET | BPF_K\u003c/code\u003e 表示将立即数 imm32 拷贝到返回值寄存器，然后退出函数。\u003c/p\u003e\n\n\u003cp\u003eeBPF 是模拟 CPU 建模的，因此 eBPF 中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_JMP | BPF_EXIT\u003c/code\u003e 只表示退出函数操作。\neBPF 程序自己负责在执行 BPF_EXIT 之前，将返回值拷贝到 R0。\u003c/p\u003e\n\n\u003ch3 id=\"bpf_jmp-与-ebpf-bpf_jmp32\"\u003eBPF_JMP 与 eBPF BPF_JMP32\u003c/h3\u003e\n\n\u003cp\u003eClass 6 in eBPF 用作 BPF_JMP32，表示的意思与 BPF_JMP 一样，但操作数是 32bit 的。\u003c/p\u003e\n\n\u003ch2 id=\"72-加载指令loadstore\"\u003e7.2 加载指令（load/store）\u003c/h2\u003e\n\n\u003cp\u003eload and store 指令的 8bit code 进一步分为三部分：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e+--------+--------+-------------------+\n| 3 bits | 2 bits |   3 bits          |\n|  mode  |  size  | instruction class |\n+--------+--------+-------------------+\n(MSB)                             (LSB)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e2bit 的 size modifier 可以是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_W   0x00    /* word */\nBPF_H   0x08    /* half word */\nBPF_B   0x10    /* byte */\nBPF_DW  0x18    /* eBPF only, double word */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e表示的是 load/store 操作的字节数：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eB  - 1 byte\nH  - 2 byte\nW  - 4 byte\nDW - 8 byte (eBPF only)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eMode modifier 可以是：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_IMM  0x00  /* used for 32-bit mov in classic BPF and 64-bit in eBPF */\nBPF_ABS  0x20\nBPF_IND  0x40\nBPF_MEM  0x60\nBPF_LEN  0x80  /* classic BPF only, reserved in eBPF */\nBPF_MSH  0xa0  /* classic BPF only, reserved in eBPF */\nBPF_XADD 0xc0  /* eBPF only, exclusive add */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"两个-ebpf-non-generic-指令bpf_abs-和-bpf_ind用于访问-skb-data\"\u003e两个 eBPF non-generic 指令：BPF_ABS 和 BPF_IND，用于访问 skb data\u003c/h3\u003e\n\n\u003cp\u003eeBPF 有两个 non-generic 指令，用于兼容 cBPF：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ABS | \u0026lt;size\u0026gt; | BPF_LD\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_IND | \u0026lt;size\u0026gt; | BPF_LD\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e二者用来\u003cstrong\u003e\u003cmark\u003e访问数据包中的数据\u003c/mark\u003e\u003c/strong\u003e（packet data）。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e这两个指令 \u003cstrong\u003e\u003cmark\u003ecBPF 中就有了，必须 eBPF 也必须要支持\u003c/mark\u003e\u003c/strong\u003e，而且 eBPF\n  解释器还要\u003cstrong\u003e\u003cmark\u003e高效地执行\u003c/mark\u003e\u003c/strong\u003e这两条指令。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e执行这个两个指令时，\u003cstrong\u003e\u003cmark\u003e传递给解释器的上下文\u003c/mark\u003e\u003c/strong\u003e必须是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct *sk_buff\u003c/code\u003e，\n  并且\u003cstrong\u003e\u003cmark\u003e隐含了 7 个操作数\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eR6 作为\u003cstrong\u003e\u003cmark\u003e隐式输入\u003c/mark\u003e\u003c/strong\u003e，存放的必须是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct *sk_buff\u003c/code\u003e；\u003c/li\u003e\n      \u003cli\u003eR0 作为\u003cstrong\u003e\u003cmark\u003e隐式输出\u003c/mark\u003e\u003c/strong\u003e，存放的是从包中读取的数据；\u003c/li\u003e\n      \u003cli\u003eR1-R5 作为 scratch registers，不能在多次 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_ABS | BPF_LD\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_IND | BPF_LD\u003c/code\u003e 指令之间在这几个寄存器中保存数据（每次调用执行之后，都会将这些寄存器置空）；\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e这些指令还有隐含的程序退出条件。当 eBPF 程序试图访问数据包边界之外的数据时，解释器\n  会终止（abort）程序的执行。因此，eBPF JIT 编译器也必须实现这个特性。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_reg\u003c/code\u003e 和 imm32 字段是这些指令的显式输入。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e看个例子，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_IND | BPF_W | BPF_LD\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 翻译成 C 语言表示：\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eR0 = ntohl(*(u32 *) (((struct sk_buff *) R6)-\u0026gt;data + src_reg + imm32))\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\n过程中会用到 R1-R5（R1-R5 were scratched）。\u003c/p\u003e\n\n\u003ch3 id=\"通用-ebpf-loadstore-指令\"\u003e通用 eBPF load/store 指令\u003c/h3\u003e\n\n\u003cp\u003e与 cBPF 指令集不同，eBPF 有通用 load/store 操作：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MEM  | \u0026lt;size\u0026gt; | BPF_STX:  *(size *)(dst_reg + off) = src_reg\nBPF_MEM  | \u0026lt;size\u0026gt; | BPF_ST :  *(size *)(dst_reg + off) = imm32\nBPF_MEM  | \u0026lt;size\u0026gt; | BPF_LDX:  dst_reg = *(size *)(src_reg + off)\nBPF_XADD | BPF_W  | BPF_STX:  lock xadd *(u32 *)(dst_reg + off16) += src_reg\nBPF_XADD | BPF_DW | BPF_STX:  lock xadd *(u64 *)(dst_reg + off16) += src_reg\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中，size 是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_B\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_H\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_W\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_DW\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e注意：这里不支持 1 或 2 字节的原子递增操作。\u003c/p\u003e\n\n\u003ch3 id=\"加载-64bit-立即数的-ebpf-指令\"\u003e加载 64bit 立即数的 eBPF 指令\u003c/h3\u003e\n\n\u003cp\u003eeBPF 有一个 16-byte instruction: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD | BPF_DW | BPF_IMM\u003c/code\u003e，功能是将 64bit 立即数（imm64）加载到寄存器：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e这条指令由两个连续 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_insn\u003c/code\u003e 8-byte blocks 组成，会被解释器解释为单个指令，\u003c/li\u003e\n  \u003cli\u003e功能就是上面提到的，将一个 64bit 立即值 load 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_reg\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003ecBPF 中有一个类似指令 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD | BPF_W | BPF_IMM\u003c/code\u003e，功能是将一个 32bit 立即值（imm）加载到寄存器。\u003c/p\u003e\n\n\u003ch1 id=\"8-ebpf-校验器ebpf-verifier\"\u003e8 eBPF 校验器（eBPF verifier）\u003c/h1\u003e\n\n\u003cp\u003eeBPF 程序的安全是通过两个步骤来保证的：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先做一次 DAG 检查，确保没有循环，并执行其他 CFG validation。特别地，这会检查程序中是否有\n无法执行到的指令（unreachable instructions，虽然 cBPF checker 是允许的）。\u003c/li\u003e\n  \u003cli\u003e第二步是从程序的第一条指令开始，遍历所有的可能路径。这一步会模拟执行每一条指令，在过程中观察寄存器和栈的状态变化。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"81-模拟执行\"\u003e8.1 模拟执行\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e程序开始时，\u003cstrong\u003e\u003cmark\u003eR1 中存放的是上下文指针\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e），类型是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_CTX\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e接下来，如果校验器看到\u003cstrong\u003e\u003cmark\u003e R2=R1，那 R2 的类型也变成了 PTR_TO_CTX\u003c/mark\u003e\u003c/strong\u003e，并且接下来就能用在表达式的右侧。\u003c/li\u003e\n      \u003cli\u003e如果 R1=PTR_TO_CTX 接下来的指令是 \u003cstrong\u003e\u003cmark\u003eR2=R1+R1，那 R2=SCALAR_VALUE\u003c/mark\u003e\u003c/strong\u003e，\n因为\u003cstrong\u003e\u003cmark\u003e两个合法指针相加，得到的是一个非法指针\u003c/mark\u003e\u003c/strong\u003e。（在 “secure” 模式下，\n校验器会拒绝任何类型的指针运算，以确保内核地址不会泄露给 unprivileged users）。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e从来没有写入过数据的寄存器是不可读的\u003c/mark\u003e\u003c/strong\u003e，例如：\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  bpf_mov R0 = R2\n  bpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e将会被拒绝，因为程序开始之后，R2 还没有初始化过。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e内核函数\u003cstrong\u003e\u003cmark\u003e执行完成后，R1-R5 将被重置为不可读状态\u003c/mark\u003e\u003c/strong\u003e，R0 保存函数的返回值。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e由于 R6-R9 是被调用方（callee）保存的，因此它们的状态在函数调用结束之后还是有效的。\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  bpf_mov  R6 = 1\n  bpf_call foo\n  bpf_mov  R0 = R6\n  bpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e以上程序是合法的。如果换成了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR0 = R1\u003c/code\u003e，就会被拒绝。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"82-loadstore-指令检查\"\u003e8.2 load/store 指令检查\u003c/h2\u003e\n\n\u003cp\u003eload/store 指令只有当\u003cstrong\u003e\u003cmark\u003e寄存器类型合法时\u003c/mark\u003e\u003c/strong\u003e才能执行，这里的类型包括\n PTR_TO_CTX、PTR_TO_MAP、PTR_TO_STACK。会对它们做边界和对齐检查。例如：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebpf_mov R1 = 1\nbpf_mov R2 = 2\nbpf_xadd *(u32 *)(R1 + 3) += R2\nbpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e将会被拒，因为执行到第三行时，R1 并不是一个合法的指针类型。\u003c/p\u003e\n\n\u003ch2 id=\"83-定制化校验器限制程序只能访问-ctx-特定字段\"\u003e8.3 定制化校验器，限制程序只能访问 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e 特定字段\u003c/h2\u003e\n\n\u003cp\u003e程序开始时，R1 类型是 PTR_TO_CTX（指向通用类型 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_context\u003c/code\u003e 的指针）。\n可以\u003cstrong\u003e\u003cmark\u003e通过 callback 定制化校验器\u003c/mark\u003e\u003c/strong\u003e，指定 size 和对齐，来\n\u003cstrong\u003e\u003cmark\u003e限制 eBPF 程序只能访问 ctx 的特定字段\u003c/mark\u003e\u003c/strong\u003e。\n例如，下面的指令：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebpf_ld R0 = *(u32 *)(R6 + 8)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果 R6=PTR_TO_CTX，通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eis_valid_access()\u003c/code\u003e callback，校验器就能知道从\noffset 8 处读取 4 个字节的操作是合法的，否则，校验器就会拒绝这个程序。\u003c/li\u003e\n  \u003cli\u003e如果 R6=PTR_TO_STACK，那访问就应该是对齐的，而且在栈空间范围内，即\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[-MAX_BPF_STACK, 0)\u003c/code\u003e。在这里例子中 offset 是 8，因此校验会失败，因为超出\n栈空间边界。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"84-读取栈空间\"\u003e8.4 读取栈空间\u003c/h2\u003e\n\n\u003cp\u003e只有程序\u003cstrong\u003e\u003cmark\u003e向栈空间写入数据后，校验器才允许它从中读取数据\u003c/mark\u003e\u003c/strong\u003e。cBPF\n通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eM[0-15]\u003c/code\u003e memory slots 执行类似的检查，例如\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ebpf_ld R0 = *(u32 *)(R10 - 4)\nbpf_exit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e是非法程序。因为虽然 R10 是只读寄存器，类型 PTR_TO_STACK 也是合法的，并且\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR10 - 4\u003c/code\u003e 也在栈边界内，但在这次读取操作之前，并没有往这个位置写入数据。\u003c/p\u003e\n\n\u003ch2 id=\"85-其他\"\u003e8.5 其他\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e指针寄存器（pointer register）spill/fill 操作也会被跟踪，因为\n\u003cstrong\u003e\u003cmark\u003e对一些程序来说，四个 (R6-R9) callee saved registers 显然是不够的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e可通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_verifier_ops-\u0026gt;get_func_proto()\u003c/code\u003e 来\u003cstrong\u003e\u003cmark\u003e定制允许执行哪些函数\u003c/mark\u003e\u003c/strong\u003e。\neBPF 校验器会检查寄存器与参数限制是否匹配。调用结束之后，R0 用来存放函数返回值。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e函数调用\u003c/mark\u003e\u003c/strong\u003e是扩展 eBPF 程序功能的主要机制，但每种类型的 BPF 程\n序能用到的函数是不同的，例如 socket filters 和 tracing 程序。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果一个函数设计成对 eBPF 可见的，那必须从安全的角度对这个函数进行考量。校验\n器会保证调用该函数时，参数都是合法的。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecBPF 中， seccomp 的安全限制与 socket filter 是不同的，它依赖\u003cstrong\u003e\u003cmark\u003e两个级联的校验器\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e首先执行 cBPF verifier，\u003c/li\u003e\n      \u003cli\u003e然后再执行 seccomp verifier\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e而在 \u003cstrong\u003e\u003cmark\u003eeBPF 中，所有场景都共用一个（可配置的）校验器\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e更多关于 eBPF 校验器的信息，可参考 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/kernel/bpf/verifier.c\"\u003ekernel/bpf/verifier.c\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"9-寄存器值跟踪register-value-tracking\"\u003e9 寄存器值跟踪（register value tracking）\u003c/h1\u003e\n\n\u003cp\u003e为保证 eBPF 程序的安全，校验器必须跟踪每个\u003cstrong\u003e\u003cmark\u003e寄存器\u003c/mark\u003e\u003c/strong\u003e和\u003cstrong\u003e\u003cmark\u003e栈上每个槽位\u003c/mark\u003e\u003c/strong\u003e\n（stack slot）值的范围。这是通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct bpf_reg_state\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n实现的，定义在 \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/linux/bpf_verifier.h#L43\"\u003einclude/linux/bpf_verifier.h\u003c/a\u003e，\n它\u003cstrong\u003e\u003cmark\u003e统一了对标量和指针类型的跟踪\u003c/mark\u003e\u003c/strong\u003e（scalar and pointer values）。\u003c/p\u003e\n\n\u003cp\u003e每个\u003cstrong\u003e\u003cmark\u003e寄存器状态\u003c/mark\u003e\u003c/strong\u003e都有一个\u003cstrong\u003e\u003cmark\u003e类型\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNOT_INIT\u003c/code\u003e：该寄存器还未写入数据\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSCALAR_VALUE\u003c/code\u003e：标量值，不可作为指针\u003c/li\u003e\n  \u003cli\u003e指针类型\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"91-9-种指针类型\"\u003e9.1 9 种指针类型\u003c/h2\u003e\n\n\u003cp\u003e依据它们\u003cstrong\u003e\u003cmark\u003e指向的数据结构类型\u003c/mark\u003e\u003c/strong\u003e，又可以分为：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_CTX\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ebpf_context\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONST_PTR_TO_MAP\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct bpf_map\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针。\n是\u003cstrong\u003e\u003cmark\u003e常量\u003c/mark\u003e\u003c/strong\u003e（const），因为不允许对这种类型指针进行算术操作。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_MAP_VALUE\u003c/code\u003e：指向 bpf \u003cstrong\u003e\u003cmark\u003emap 元素\u003c/mark\u003e\u003c/strong\u003e的指针。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_MAP_VALUE_OR_NULL\u003c/code\u003e：指向 bpf map 元素的指针，可为 NULL。\n\u003cstrong\u003e\u003cmark\u003e访问 map 的操作\u003c/mark\u003e\u003c/strong\u003e会返回这种类型的指针。\u003cstrong\u003e\u003cmark\u003e禁止算术操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_STACK\u003c/code\u003e：帧指针（Frame pointer）。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_PACKET\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eskb-\u0026gt;data\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_PACKET_END\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eskb-\u0026gt;data + headlen\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针。禁止算术操作。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_SOCKET\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct bpf_sock_ops\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针，内部有引用计数。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_SOCKET_OR_NULL\u003c/code\u003e：指向 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct bpf_sock_ops\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的指针，或 NULL。\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003esocket lookup 操作\u003c/mark\u003e\u003c/strong\u003e会返回这种类型。\u003cstrong\u003e\u003cmark\u003e有引用计数\u003c/mark\u003e\u003c/strong\u003e，\n 因此程序在执行结束时，必须通过 socket release 函数释放引用。禁止算术操作。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这些指针都称为 base 指针。\u003c/p\u003e\n\n\u003ch2 id=\"92-指针偏移offset触发寄存器状态更新\"\u003e9.2 指针偏移（offset）触发寄存器状态更新\u003c/h2\u003e\n\n\u003cp\u003e实际上，很多有用的指针都是 base 指针加一个 offset（指针算术运算的结果），\n这是通过两方面来个跟踪的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e‘fixed offset’（\u003cstrong\u003e\u003cmark\u003e固定偏移\u003c/mark\u003e\u003c/strong\u003e）：offset 是个常量（例如，立即数）。\u003c/li\u003e\n  \u003cli\u003e‘variable offset’（\u003cstrong\u003e\u003cmark\u003e可变偏移\u003c/mark\u003e\u003c/strong\u003e）：offset 是个变量。这种类型还用在 SCALAR_VALUE 跟踪中，来跟踪寄存器值的可能范围。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e校验器对可变 offset 的知识包括：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e无符号类型：最小和最大值；\u003c/li\u003e\n  \u003cli\u003e有符号类型：最小和最大值；\u003c/li\u003e\n  \u003cli\u003e关于每个 bit 的知识，以 ‘tnum’ 的格式: 一个 u64 ‘mask’ 加一个 u64 ‘value’。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e1s in the mask represent bits whose value is unknown;\n  1s in the value represent bits known to be 1.  Bits known to be 0 have 0 in both\n  mask and value; no bit should ever be 1 in both。\n  例如，如果从内存加载一个字节到寄存器，那该寄存器的前 56bit 已知是全零，而后\n  8bit 是未知的 —— 表示为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etnum (0x0; 0xff)\u003c/code\u003e。如果我们将这个值与 0x40 进行 OR\n  操作，就得到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(0x40; 0xbf)\u003c/code\u003e；如果加 1 就得到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(0x0; 0x1ff)\u003c/code\u003e，因为可能的进位操\n  作。\u003c/p\u003e\n\n\u003ch2 id=\"93-条件分支触发寄存器状态更新\"\u003e9.3 条件分支触发寄存器状态更新\u003c/h2\u003e\n\n\u003cp\u003e除了算术运算之外，条件分支也能更新寄存器状态。例如，如果判断一个 SCALAR_VALUE 大于 8，那\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 true 分支，这个变量的最小值 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eumin_value\u003c/code\u003e（unsigned minimum value）就是 9；\u003c/li\u003e\n  \u003cli\u003e在 false 分支，它的最大值就是 umax_value of 8。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"94-有符号比较触发寄存器状态更新\"\u003e9.4 有符号比较触发寄存器状态更新\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e有符号比较\u003c/mark\u003e\u003c/strong\u003e（BPF_JSGT or BPF_JSGE）也会相应更新有符号变量\n的最大最小值。\u003c/p\u003e\n\n\u003cp\u003e有符合和无符号边界的信息可以结合起来；例如如果一个值先判断小于无\n符号 8，后判断大于有符合 4，校验器就会得出结论这个值大于无符号 4，小于有符号 8\n，因为这个边界不会跨正负边界。\u003c/p\u003e\n\n\u003ch2 id=\"95-struct-bpf_reg_state-的-id-字段\"\u003e9.5 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_reg_state\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 字段\u003c/h2\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_reg_state\u003c/code\u003e 结构体有一个\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/include/linux/bpf_verifier.h#L73\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e\u003c/a\u003e\n字段，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// include/linux/bpf_verifier.h\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/* For PTR_TO_PACKET, used to find other pointers with the same variable\n     * offset, so they can share range knowledge.\n     * For PTR_TO_MAP_VALUE_OR_NULL this is used to share which map value we\n     * came from, when one is tested for != NULL.\n     * For PTR_TO_MEM_OR_NULL this is used to identify memory allocation\n     * for the purpose of tracking that it\u0026#39;s freed.\n     * For PTR_TO_SOCKET this is used to share which pointers retain the\n     * same reference to the socket, to determine proper reference freeing.\n     */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003eid\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如注释所述，该字段针对不同指针类型有不同用途，下面分别解释。\u003c/p\u003e\n\n\u003ch3 id=\"ptr_to_packet\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_PACKET\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 字段对\u003cstrong\u003e\u003cmark\u003e共享同一 variable offset 的多个 PTR_TO_PACKET 指针\u003c/mark\u003e\u003c/strong\u003e\n都是可见的，这对\u003cstrong\u003e\u003cmark\u003eskb 数据的范围检查\u003c/mark\u003e\u003c/strong\u003e非常重要。举个例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1:  A = skb-\u0026gt;data // A 是指向包数据的指针\n2:  B = A + var2  // B 是从 A 开始往前移动 var2 得到的地址\n3:  A = A + 4     // A 往前移动 4 个字节\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在这个程序中，寄存器 \u003cstrong\u003e\u003cmark\u003eA 和 B 将将共享同一个 \u003ccode\u003eid\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eA 已经从最初地址向前移动了 4 字节（有一个固定偏移 +4），\u003c/li\u003e\n  \u003cli\u003e如果这个边界通过校验了，也就是确认小于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_PACKET_END\u003c/code\u003e，那现在\n\u003cstrong\u003e\u003cmark\u003e寄存器 B 将有一个范围至少为 4 字节的可安全访问范围\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e更多关于这种指针的信息，见下面的 ‘Direct packet access’ 章节。\u003c/p\u003e\n\n\u003ch3 id=\"ptr_to_map_value\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_MAP_VALUE\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e与上面的用途类型，具体来说：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e这一字段对共享同一基础指针的多个 PTR_TO_MAP_VALUE 指针可见；\u003c/li\u003e\n  \u003cli\u003e这些指针中，\u003cstrong\u003e\u003cmark\u003e只要一个指针经验证是非空的，就认为其他指针（副本）都是非空的\u003c/mark\u003e\u003c/strong\u003e（因此减少重复验证开销）；\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e另外，与 range-checking 类型，跟踪的信息（the tracked information）还用于\u003cstrong\u003e\u003cmark\u003e确保指针访问的正确对齐\u003c/mark\u003e\u003c/strong\u003e。\n例如，在大部分系统上，packet 指针都 4 字节对齐之后再加 2 字节。如果一个程序将这个指针加 14（跳过\nEthernet header）然后读取 IHL，并将指针再加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIHL * 4\u003c/code\u003e，最终的指针将有一个\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4n + 2\u003c/code\u003e 的 variable offset，因此，加 2 （\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNET_IP_ALIGN\u003c/code\u003e）\ngives a 4-byte alignment，因此通过这个指针进行 word-sized accesses 是安全的。\u003c/p\u003e\n\n\u003ch3 id=\"ptr_to_socket\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePTR_TO_SOCKET\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e与上面用途类似，只要一个指针验证是非空的，其他共享同一 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid\u003c/code\u003e 的 PTR_TO_SOCKET 指针就都是非空的；此外，\n还\u003cstrong\u003e\u003cmark\u003e负责跟踪指针的引用\u003c/mark\u003e\u003c/strong\u003e（reference tracking for the pointer）。\u003c/p\u003e\n\n\u003cp\u003ePTR_TO_SOCKET 隐式地表示对一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock\u003c/code\u003e 的引用。为确保引用没有泄露，需要强制对引用进行非空（检查），\n如果非空（non-NULL），将合法引用传给 socket release 函数。\u003c/p\u003e\n\n\u003ch1 id=\"10-直接数据包访问direct-packet-access\"\u003e10 直接数据包访问（direct packet access）\u003c/h1\u003e\n\n\u003cp\u003e对于 cls_bpf 和 act_bpf eBPF 程序，校验器允许\u003cstrong\u003e\u003cmark\u003e直接通过 \u003ccode\u003eskb-\u0026gt;data\u003c/code\u003e\n和 \u003ccode\u003eskb-\u0026gt;data_end\u003c/code\u003e 指针访问包数据\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"101-简单例子\"\u003e10.1 简单例子\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e1:  r4 = *(u32 *)(r1 +80)  /* load skb-\u0026gt;data_end */\n2:  r3 = *(u32 *)(r1 +76)  /* load skb-\u0026gt;data */\n3:  r5 = r3\n4:  r5 += 14\n5:  if r5 \u0026gt; r4 goto pc+16\nR1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp # 校验器标记\n6:  r0 = *(u16 *)(r3 +12) /* access 12 and 13 bytes of the packet */\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e上面从包数据中加载 2 字节的操作是安全的，因为\u003cstrong\u003e\u003cmark\u003e程序编写者在第五行主动检查了数据边界\u003c/mark\u003e\u003c/strong\u003e：\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif (skb-\u0026gt;data + 14 \u0026gt; skb-\u0026gt;data_end) goto err\u003c/code\u003e，这意味着能执行到第 6 行时（fall-through case），\nR3（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;data\u003c/code\u003e）至少有 14 字节的直接可访问数据，因此\n\u003cstrong\u003e\u003cmark\u003e校验器将其标记为 \u003ccode\u003eR3=pkt(id=0,off=0,r=14)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid=0\u003c/code\u003e 表示\u003cstrong\u003e\u003cmark\u003e没有额外的变量加到这个寄存器上\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eoff=0\u003c/code\u003e 表示\u003cstrong\u003e\u003cmark\u003e没有额外的常量 offset\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er=14\u003c/code\u003e 表示\u003cstrong\u003e\u003cmark\u003e安全访问的范围\u003c/mark\u003e\u003c/strong\u003e，即 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[R3, R3+14)\u003c/code\u003e 指向的字节范围都是 OK 的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这里注意 \u003cstrong\u003e\u003cmark\u003eR5 被标记为 \u003ccode\u003eR5=pkt(id=0,off=14,r=14)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e它也指向包数据，但\u003cstrong\u003e\u003cmark\u003e常量 14 加到了寄存器\u003c/mark\u003e\u003c/strong\u003e，因为它执行的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;data + 14\u003c/code\u003e，\u003c/li\u003e\n  \u003cli\u003e因此可访问的范围是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[R5, R5 + 14 - 14)\u003c/code\u003e，也就是 0 个字节。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"102-复杂例子\"\u003e10.2 复杂例子\u003c/h2\u003e\n\n\u003cp\u003e下面是个更复杂一些的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eR0=inv1 R1=ctx R3=pkt(id=0,off=0,r=14) R4=pkt_end R5=pkt(id=0,off=14,r=14) R10=fp\n6:   r0 = *(u8 *)(r3 +7) /* load 7th byte from the packet */\n7:   r4 = *(u8 *)(r3 +12)\n8:   r4 *= 14\n9:   r3 = *(u32 *)(r1 +76) /* load skb-\u0026gt;data */\n10:  r3 += r4\n11:  r2 = r1\n12:  r2 \u0026lt;\u0026lt;= 48\n13:  r2 \u0026gt;\u0026gt;= 48\n14:  r3 += r2\n15:  r2 = r3\n16:  r2 += 8\n17:  r1 = *(u32 *)(r1 +80) /* load skb-\u0026gt;data_end */\n18:  if r2 \u0026gt; r1 goto pc+2\nR0=inv(id=0,umax_value=255,var_off=(0x0; 0xff)) R1=pkt_end R2=pkt(id=2,off=8,r=8) R3=pkt(id=2,off=0,r=8) R4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe)) R5=pkt(id=0,off=14,r=14) R10=fp\n19:  r1 = *(u8 *)(r3 +4)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"校验器标记信息解读\"\u003e校验器标记信息解读\u003c/h3\u003e\n\n\u003cp\u003e第 18 行之后，寄存器 R3 的状态是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR3=pkt(id=2,off=0,r=8)\u003c/code\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eid=2\u003c/code\u003e 表示\u003cstrong\u003e\u003cmark\u003e之前已经跟踪到两个 \u003ccode\u003er3 += rX\u003c/code\u003e 指令\u003c/mark\u003e\u003c/strong\u003e，因此\n r3 指向某个包内的某个 offset，由于程序员在 18 行已经做了\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif (r3 + 8 \u0026gt; r1) goto err\u003c/code\u003e 检查，因此\u003cstrong\u003e\u003cmark\u003e安全范围\u003c/mark\u003e\u003c/strong\u003e是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[R3, R3 + 8)\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e校验器\u003cstrong\u003e\u003cmark\u003e只允许对 packet 寄存器执行 add/sub\u003c/mark\u003e\u003c/strong\u003e 操作。其他操作会将\n 寄存器状态设为 \u003cstrong\u003e\u003cmark\u003eSCALAR_VALUE，这个状态是不允许执行 direct packet access 的\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e操作 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er3 += rX\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e可能会溢出，变得比起始地址 skb-\u0026gt;data 还小\u003c/mark\u003e\u003c/strong\u003e，校验器必须要能检查出这种情况。\n因此当它看到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er3 += rX\u003c/code\u003e 指令并且 rX 比 16bit 值还大时，接下来的任何将 r3 与 \n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;data_end\u003c/code\u003e 对比的操作都\u003cstrong\u003e\u003cmark\u003e不会返回范围信息\u003c/mark\u003e\u003c/strong\u003e，因此尝试通过\n这个指针读取数据的操作都会收到 \u003cstrong\u003e\u003cmark\u003einvalid access to packet\u003c/mark\u003e\u003c/strong\u003e 错误。\n例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er4 = *(u8 *)(r3 +12)\u003c/code\u003e 之后，r4 的状态是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR4=inv(id=0,umax_value=255,var_off=(0x0; 0xff))\u003c/code\u003e，意思是\n寄存器的 upper 56 bits 肯定是 0，但对于低 8bit 信息一无所知。\n 在执行完 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er4 *= 14\u003c/code\u003e 之后，状态变成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR4=inv(id=0,umax_value=3570,var_off=(0x0; 0xfffe))\u003c/code\u003e，因为一个 8bit 值乘以 14 之后，\n 高 52bit 还是 0，此外最低 bit 位为 0，因为 14 是偶数。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e类似地，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003er2 \u0026gt;\u0026gt;= 48\u003c/code\u003e 使得 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR2=inv(id=0,umax_value=65535,var_off=(0x0; 0xffff))\u003c/code\u003e，因为移位是无符号扩展。\n这个逻辑在函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eadjust_reg_min_max_vals()\u003c/code\u003e 中实现，它又会调用\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eadjust_ptr_min_max_vals()\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eadjust_scalar_min_max_vals()\u003c/code\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"对应的-c-代码\"\u003e对应的 C 代码\u003c/h3\u003e\n\n\u003cp\u003e最终的结果是：eBPF 程序编写者可以像使用普通 C 语言一样访问包数据：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edata_end\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edata_end\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eeth_hdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eeth\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eiph\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eeth\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eudphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eudp\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eeth\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eiph\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eeth\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eiph\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eudp\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edata_end\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eeth\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eh_proto\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003ehtons\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eETH_P_IP\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eiph\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eprotocol\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003eIPPROTO_UDP\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003eiph\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eihl\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"mi\"\u003e5\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eudp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edest\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e53\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003eudp\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esource\u003c/span\u003e \u003cspan class=\"o\"\u003e==\u003c/span\u003e \u003cspan class=\"mi\"\u003e9\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e相比使用 LD_ABS 之类的指令，这种程序写起来方便多了。\u003c/p\u003e\n\n\u003ch1 id=\"11-ebpf-maps\"\u003e11 eBPF maps\u003c/h1\u003e\n\n\u003cp\u003e‘maps’ is a generic storage of different types for sharing data between kernel\nand userspace.\u003c/p\u003e\n\n\u003cp\u003eThe maps are accessed from user space via BPF syscall, which has commands:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003ecreate a map with given type and attributes\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_fd = bpf(BPF_MAP_CREATE, union bpf_attr *attr, u32 size)\u003c/code\u003e\nusing attr-\u0026gt;map_type, attr-\u0026gt;key_size, attr-\u0026gt;value_size, attr-\u0026gt;max_entries\nreturns process-local file descriptor or negative error\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003elookup key in a given map\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eerr = bpf(BPF_MAP_LOOKUP_ELEM, union bpf_attr *attr, u32 size)\u003c/code\u003e\nusing attr-\u0026gt;map_fd, attr-\u0026gt;key, attr-\u0026gt;value\nreturns zero and stores found elem into value or negative error\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecreate or update key/value pair in a given map\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eerr = bpf(BPF_MAP_UPDATE_ELEM, union bpf_attr *attr, u32 size)\u003c/code\u003e\nusing attr-\u0026gt;map_fd, attr-\u0026gt;key, attr-\u0026gt;value\nreturns zero or negative error\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003efind and delete element by key in a given map\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eerr = bpf(BPF_MAP_DELETE_ELEM, union bpf_attr *attr, u32 size)\u003c/code\u003e\nusing attr-\u0026gt;map_fd, attr-\u0026gt;key\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eto delete map: close(fd)\nExiting process will delete maps automatically\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003euserspace programs use this syscall to create/access maps that eBPF programs\nare concurrently updating.\u003c/p\u003e\n\n\u003cp\u003emaps can have different types: hash, array, bloom filter, radix-tree, etc.\u003c/p\u003e\n\n\u003cp\u003eThe map is defined by:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003etype\u003c/li\u003e\n  \u003cli\u003emax number of elements\u003c/li\u003e\n  \u003cli\u003ekey size in bytes\u003c/li\u003e\n  \u003cli\u003evalue size in bytes\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e以上介绍非常简单，更多信息可参考：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-2-zh/\"\u003e\u003cmark\u003eBPF 进阶笔记（二）：BPF Map 类型详解：使用场景、程序示例\u003c/mark\u003e\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/bpf-advanced-notes-3-zh/\"\u003e\u003cmark\u003eBPF 进阶笔记（三）：BPF Map 内核实现\u003c/mark\u003e\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"12-pruning剪枝\"\u003e12 Pruning（剪枝）\u003c/h1\u003e\n\n\u003cp\u003e校验器实际上\u003cstrong\u003e\u003cmark\u003e并不会模拟执行程序的每一条可能路径\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e对于每个新条件分支：校验器首先会查看它自己当前已经跟踪的所有状态。如果这些状态\n已经覆盖到这个新分支，该分支就会被剪掉（pruned）—— 也就是说之前的状态已经被接受\n（previous state was accepted）能证明当前状态也是合法的。\u003c/p\u003e\n\n\u003cp\u003e举个例子：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e当前的状态记录中，r1 是一个 packet-pointer\u003c/li\u003e\n  \u003cli\u003e下一条指令中，r1 仍然是 packet-pointer with a range as long or longer and at least as strict an alignment，那 r1 就是安全的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e类似的，如果 r2 之前是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNOT_INIT\u003c/code\u003e，那就说明之前任何代码路径都没有用到这个寄存器\n，因此 r2 中的任何值（包括另一个 NOT_INIT）都是安全的。\u003c/p\u003e\n\n\u003cp\u003e实现在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eregsafe()\u003c/code\u003e 函数。\u003c/p\u003e\n\n\u003cp\u003ePruning 过程不仅会看寄存器，还会看栈（及栈上的 spilled registers）。\n只有证明二者都安全时，这个分支才会被 prune。这个过程实现在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estates_equal()\u003c/code\u003e 函数。\u003c/p\u003e\n\n\u003ch1 id=\"13-理解-ebpf-校验器提示信息\"\u003e13 理解 eBPF 校验器提示信息\u003c/h1\u003e\n\n\u003cp\u003e提供几个不合法的 eBPF 程序及相应校验器报错的例子。\u003c/p\u003e\n\n\u003cp\u003eThe following are few examples of invalid eBPF programs and verifier error\nmessages as seen in the log:\u003c/p\u003e\n\n\u003ch2 id=\"131-程序包含无法执行到的指令\"\u003e13.1 程序包含无法执行到的指令\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003estatic struct bpf_insn prog[] = {\n  BPF_EXIT_INSN(),\n  BPF_EXIT_INSN(),\n};\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eunreachable insn 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"132-程序读取未初始化的寄存器\"\u003e13.2 程序读取未初始化的寄存器\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MOV64_REG(BPF_REG_0, BPF_REG_2),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (bf) r0 = r2\nR2 !read_ok\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"133-程序退出前未设置-r0-寄存器\"\u003e13.3 程序退出前未设置 R0 寄存器\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MOV64_REG(BPF_REG_2, BPF_REG_1),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (bf) r2 = r1\n1: (95) exit\nR0 !read_ok\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"134-程序访问超出栈空间\"\u003e13.4 程序访问超出栈空间\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ST_MEM(BPF_DW, BPF_REG_10, 8, 0),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError::\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (7a) *(u64 *)(r10 +8) = 0\ninvalid stack off=8 size=8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"135-未初始化栈内元素就传递该栈地址\"\u003e13.5 未初始化栈内元素，就传递该栈地址\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_LD_MAP_FD(BPF_REG_1, 0),\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError::\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (bf) r2 = r10\n1: (07) r2 += -8\n2: (b7) r1 = 0x0\n3: (85) call 1\ninvalid indirect read from stack off -8+0 size 8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"136-程序执行-map_lookup_elem-传递了非法的-map_fd\"\u003e13.6 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 传递了非法的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_fd\u003c/code\u003e\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_LD_MAP_FD(BPF_REG_1, 0),\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (7a) *(u64 *)(r10 -8) = 0\n1: (bf) r2 = r10\n2: (07) r2 += -8\n3: (b7) r1 = 0x0\n4: (85) call 1\nfd 0 is not pointing to valid bpf_map\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"137-程序未检查-map_lookup_elem-的返回值是否为空就开始使用\"\u003e13.7 程序未检查 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 的返回值是否为空就开始使用\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_LD_MAP_FD(BPF_REG_1, 0),\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\nBPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (7a) *(u64 *)(r10 -8) = 0\n1: (bf) r2 = r10\n2: (07) r2 += -8\n3: (b7) r1 = 0x0\n4: (85) call 1\n5: (7a) *(u64 *)(r0 +0) = 0\nR0 invalid mem access \u0026#39;map_value_or_null\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"138-程序访问-map-内容时使用了错误的字节对齐\"\u003e13.8 程序访问 map 内容时使用了错误的字节对齐\u003c/h2\u003e\n\n\u003cp\u003e程序虽然检查了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 返回值是否为 NULL，但接下来使用了错误的对齐：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_LD_MAP_FD(BPF_REG_1, 0),\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\nBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 1),\nBPF_ST_MEM(BPF_DW, BPF_REG_0, 4, 0),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (7a) *(u64 *)(r10 -8) = 0\n1: (bf) r2 = r10\n2: (07) r2 += -8\n3: (b7) r1 = 1\n4: (85) call 1\n5: (15) if r0 == 0x0 goto pc+1\n R0=map_ptr R10=fp\n6: (7a) *(u64 *)(r0 +4) = 0\nmisaligned access off 4 size 8\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"139-程序在-fallthrough-分支中使用了错误的字节对齐访问-map-数据\"\u003e13.9 程序在 fallthrough 分支中使用了错误的字节对齐访问 map 数据\u003c/h2\u003e\n\n\u003cp\u003e程序检查了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_lookup_elem()\u003c/code\u003e 返回值是否为 NULL，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eif\u003c/code\u003e 分支中使用了正确的字节对齐，\n但在 fallthrough 分支中使用了错误的对齐：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_ST_MEM(BPF_DW, BPF_REG_10, -8, 0),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_LD_MAP_FD(BPF_REG_1, 0),\nBPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_map_lookup_elem),\nBPF_JMP_IMM(BPF_JEQ, BPF_REG_0, 0, 2),\nBPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 0),\nBPF_EXIT_INSN(),\nBPF_ST_MEM(BPF_DW, BPF_REG_0, 0, 1),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (7a) *(u64 *)(r10 -8) = 0\n1: (bf) r2 = r10\n2: (07) r2 += -8\n3: (b7) r1 = 1\n4: (85) call 1\n5: (15) if r0 == 0x0 goto pc+2\n R0=map_ptr R10=fp\n6: (7a) *(u64 *)(r0 +0) = 0\n7: (95) exit\n\nfrom 5 to 8: R0=imm0 R10=fp\n8: (7a) *(u64 *)(r0 +0) = 1\nR0 invalid mem access \u0026#39;imm\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"1310-程序执行-sk_lookup_tcp未检查返回值就直接将其置-null\"\u003e13.10 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e，未检查返回值就直接将其置 NULL\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MOV64_IMM(BPF_REG_2, 0),\nBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_MOV64_IMM(BPF_REG_3, 4),\nBPF_MOV64_IMM(BPF_REG_4, 0),\nBPF_MOV64_IMM(BPF_REG_5, 0),\nBPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),\nBPF_MOV64_IMM(BPF_REG_0, 0),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (b7) r2 = 0\n1: (63) *(u32 *)(r10 -8) = r2\n2: (bf) r2 = r10\n3: (07) r2 += -8\n4: (b7) r3 = 4\n5: (b7) r4 = 0\n6: (b7) r5 = 0\n7: (85) call bpf_sk_lookup_tcp#65\n8: (b7) r0 = 0\n9: (95) exit\nUnreleased reference id=1, alloc_insn=7\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里的信息提示是 socket reference 未释放，说明 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e 返回的是一个非空指针，\n直接置空导致这个指针再也无法被解引用。\u003c/p\u003e\n\n\u003ch2 id=\"1311-程序执行-sk_lookup_tcp-但未检查返回值是否为空\"\u003e13.11 程序执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e 但未检查返回值是否为空\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_MOV64_IMM(BPF_REG_2, 0),\nBPF_STX_MEM(BPF_W, BPF_REG_10, BPF_REG_2, -8),\nBPF_MOV64_REG(BPF_REG_2, BPF_REG_10),\nBPF_ALU64_IMM(BPF_ADD, BPF_REG_2, -8),\nBPF_MOV64_IMM(BPF_REG_3, 4),\nBPF_MOV64_IMM(BPF_REG_4, 0),\nBPF_MOV64_IMM(BPF_REG_5, 0),\nBPF_EMIT_CALL(BPF_FUNC_sk_lookup_tcp),\nBPF_EXIT_INSN(),\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eError:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e0: (b7) r2 = 0\n1: (63) *(u32 *)(r10 -8) = r2\n2: (bf) r2 = r10\n3: (07) r2 += -8\n4: (b7) r3 = 4\n5: (b7) r4 = 0\n6: (b7) r5 = 0\n7: (85) call bpf_sk_lookup_tcp#65\n8: (95) exit\nUnreleased reference id=1, alloc_insn=7\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里的信息提示是 socket reference 未释放，说明 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esk_lookup_tcp()\u003c/code\u003e 返回的是一个非空指针，\n直接置空导致这个指针再也无法被解引用。\u003c/p\u003e\n\n\u003ch1 id=\"14-测试testing\"\u003e14 测试（testing）\u003c/h1\u003e\n\n\u003cp\u003e内核自带了一个 BPF 测试模块，覆盖了 cBPF 和 eBPF 的很多测试场景，能用来测试解释\n器和 JIT 编译器。源码见 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elib/test_bpf.c\u003c/code\u003e，编译是 Kconfig 启用：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003eCONFIG_TEST_BPF\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003em\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e编译之后用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einsmod\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emodprobe\u003c/code\u003e 加载 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest_bpf\u003c/code\u003e 模块。\n测试结果带有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens\u003c/code\u003e 精度的时间戳日志，打印到内核日志（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edmesg\u003c/code\u003e 查看）。\u003c/p\u003e\n\n\u003ch1 id=\"15-其他misc\"\u003e15 其他（misc）\u003c/h1\u003e\n\n\u003cp\u003eAlso trinity, the Linux syscall fuzzer, has built-in support for BPF and\nSECCOMP-BPF kernel fuzzing.\u003c/p\u003e\n\n\u003ch1 id=\"本文作者\"\u003e本文作者\u003c/h1\u003e\n\n\u003cp\u003eThe document was written in the hope that it is found useful and in order\nto give potential BPF hackers or security auditors a better overview of\nthe underlying architecture.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eJay Schulist \u003ca href=\"mailto:jschlst@samba.org\"\u003ejschlst@samba.org\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eDaniel Borkmann \u003ca href=\"mailto:daniel@iogearbox.net\"\u003edaniel@iogearbox.net\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eAlexei Starovoitov \u003ca href=\"mailto:ast@kernel.org\"\u003east@kernel.org\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/ebpf-assembly-with-llvm-zh/\"\u003e\u003cspan\u003e« [译] LLVM eBPF 汇编编程（2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/intro-to-io-uring-zh/\"\u003e\u003cspan\u003e[译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-08-27T00:00:00Z",
  "Author": "Arthur Chiao"
}