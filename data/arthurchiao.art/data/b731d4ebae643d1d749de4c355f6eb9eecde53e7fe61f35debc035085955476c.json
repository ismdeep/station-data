{
  "Source": "arthurchiao.art",
  "Title": "[译] Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）",
  "Link": "https://arthurchiao.art/blog/cgroupv2-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-09-10 | Last Update 2023-12-20\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2021 年 Linux \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.10\u003c/code\u003e 内核文档：\n\u003ca href=\"https://www.kernel.org/doc/html/v5.10/admin-guide/cgroup-v2.html\"\u003eControl Group v2\u003c/a\u003e，\n它是描述 cgroupv2 \u003cstrong\u003e\u003cmark\u003e用户空间侧\u003c/mark\u003e\u003c/strong\u003e的设计、接口和规范的\u003cstrong\u003e\u003cmark\u003e权威文档\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e原文非常全面详细，本文只翻译了目前感兴趣的部分，其他部分保留原文。\n另外，由于技术规范的描述比较抽象，因此翻译时加了一些系统测试输出、内核代码片段和\n链接，便于更好理解。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-引言\" id=\"markdown-toc-1-引言\"\u003e1 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-术语\" id=\"markdown-toc-11-术语\"\u003e1.1 术语\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-cgroup-是什么\" id=\"markdown-toc-12-cgroup-是什么\"\u003e1.2 cgroup 是什么？\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#121-cgroup-组成部分\" id=\"markdown-toc-121-cgroup-组成部分\"\u003e1.2.1 cgroup 组成部分\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#122-进程线程与-cgroup-关系\" id=\"markdown-toc-122-进程线程与-cgroup-关系\"\u003e1.2.2 进程/线程与 cgroup 关系\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#123-控制器\" id=\"markdown-toc-123-控制器\"\u003e1.2.3 控制器\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-基础操作\" id=\"markdown-toc-2-基础操作\"\u003e2 基础操作\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-挂载mounting\" id=\"markdown-toc-21-挂载mounting\"\u003e2.1 挂载（mounting）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#211-控制器与-v1v2-绑定关系\" id=\"markdown-toc-211-控制器与-v1v2-绑定关系\"\u003e2.1.1 控制器与 v1/v2 绑定关系\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#212-示例ubuntu-2004-同时挂载-cgroupv1cgroupv2译注\" id=\"markdown-toc-212-示例ubuntu-2004-同时挂载-cgroupv1cgroupv2译注\"\u003e2.1.2 示例：ubuntu 20.04 同时挂载 cgroupv1/cgroupv2（译注）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#213-控制器在-v1-和-v2-之间切换\" id=\"markdown-toc-213-控制器在-v1-和-v2-之间切换\"\u003e2.1.3 控制器在 v1 和 v2 之间切换\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#214-cgroupv2-mount-选项\" id=\"markdown-toc-214-cgroupv2-mount-选项\"\u003e2.1.4 cgroupv2 mount 选项\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-组织organizing进程和线程\" id=\"markdown-toc-22-组织organizing进程和线程\"\u003e2.2 组织（organizing）进程和线程\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-进程创建删除移动查看-cgroup\" id=\"markdown-toc-221-进程创建删除移动查看-cgroup\"\u003e2.2.1 进程：创建/删除/移动/查看 cgroup\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-线程\" id=\"markdown-toc-222-线程\"\u003e2.2.2 线程\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#将-cgroup-改成-threaded-模式单向不可逆操作\" id=\"markdown-toc-将-cgroup-改成-threaded-模式单向不可逆操作\"\u003e将 cgroup 改成 threaded 模式（单向/不可逆操作）\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-unpopulated-notification进程退出通知\" id=\"markdown-toc-23-unpopulated-notification进程退出通知\"\u003e2.3 [Un]populated Notification（进程退出通知）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-管理控制器controlling-controllers\" id=\"markdown-toc-23-管理控制器controlling-controllers\"\u003e2.3 管理控制器（controlling controllers）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-启用和禁用\" id=\"markdown-toc-231-启用和禁用\"\u003e2.3.1 启用和禁用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-自顶向下启用top-down-constraint\" id=\"markdown-toc-232-自顶向下启用top-down-constraint\"\u003e2.3.2 自顶向下启用（top-down constraint）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#233-将资源分给-children-时parent-cgroup-内不能有进程no-internal-process\" id=\"markdown-toc-233-将资源分给-children-时parent-cgroup-内不能有进程no-internal-process\"\u003e2.3.3 将资源分给 children 时，parent cgroup 内不能有进程（no internal process）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-delegation委派\" id=\"markdown-toc-24-delegation委派\"\u003e2.4 Delegation（委派）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#241-model-of-delegation\" id=\"markdown-toc-241-model-of-delegation\"\u003e2.4.1 Model of Delegation\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#242-delegation-containment\" id=\"markdown-toc-242-delegation-containment\"\u003e2.4.2 Delegation Containment\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-指导原则\" id=\"markdown-toc-25-指导原则\"\u003e2.5 指导原则\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#251-避免频繁在-cgroup-之间迁移进程organize-once-and-control\" id=\"markdown-toc-251-避免频繁在-cgroup-之间迁移进程organize-once-and-control\"\u003e2.5.1 避免频繁在 cgroup 之间迁移进程（Organize once and control）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#252-避免文件名冲突avoid-name-collisions\" id=\"markdown-toc-252-避免文件名冲突avoid-name-collisions\"\u003e2.5.2 避免文件名冲突（Avoid Name Collisions）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-资源分配模型resource-distribution-models\" id=\"markdown-toc-3-资源分配模型resource-distribution-models\"\u003e3 资源分配模型（Resource distribution models）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-weights资源量权重\" id=\"markdown-toc-31-weights资源量权重\"\u003e3.1 Weights（资源量权重）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-limits资源量上限可超分\" id=\"markdown-toc-32-limits资源量上限可超分\"\u003e3.2 Limits（资源量上限，可超分）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-protections资源量保护可超分\" id=\"markdown-toc-33-protections资源量保护可超分\"\u003e3.3 Protections（资源量保护，可超分）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-allocations独占资源量不可超分\" id=\"markdown-toc-34-allocations独占资源量不可超分\"\u003e3.4 Allocations（独占资源量，不可超分）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-接口文件interface-files\" id=\"markdown-toc-4-接口文件interface-files\"\u003e4 接口文件（Interface Files）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-文件格式\" id=\"markdown-toc-41-文件格式\"\u003e4.1 文件格式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-一些惯例conventions\" id=\"markdown-toc-42-一些惯例conventions\"\u003e4.2 一些惯例（conventions）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-核心接口文件core-interface-files\" id=\"markdown-toc-43-核心接口文件core-interface-files\"\u003e4.3 核心接口文件（core interface files）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-controllers控制器\" id=\"markdown-toc-5-controllers控制器\"\u003e5 Controllers（控制器）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-cpu\" id=\"markdown-toc-51-cpu\"\u003e5.1 CPU\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#cpu-interface-files\" id=\"markdown-toc-cpu-interface-files\"\u003eCPU Interface Files\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-memory\" id=\"markdown-toc-52-memory\"\u003e5.2 Memory\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#memory-interface-files\" id=\"markdown-toc-memory-interface-files\"\u003eMemory Interface Files\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#使用建议\" id=\"markdown-toc-使用建议\"\u003e使用建议\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#memory-ownership\" id=\"markdown-toc-memory-ownership\"\u003eMemory Ownership\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-io\" id=\"markdown-toc-53-io\"\u003e5.3 IO\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#io-interface-files\" id=\"markdown-toc-io-interface-files\"\u003eIO Interface Files\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#writeback\" id=\"markdown-toc-writeback\"\u003eWriteback\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#io-latency\" id=\"markdown-toc-io-latency\"\u003eIO Latency\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#how-io-latency-throttling-works\" id=\"markdown-toc-how-io-latency-throttling-works\"\u003eHow IO Latency Throttling Works\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#io-latency-interface-files\" id=\"markdown-toc-io-latency-interface-files\"\u003eIO Latency Interface Files\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#54-pid\" id=\"markdown-toc-54-pid\"\u003e5.4 PID\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#541-pid-接口文件pidscurrentpidsmax\" id=\"markdown-toc-541-pid-接口文件pidscurrentpidsmax\"\u003e5.4.1 PID 接口文件：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.current/pids.max\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#542-绕开-cgroup-pid-限制实现-pidscurrent--pidsmax\" id=\"markdown-toc-542-绕开-cgroup-pid-限制实现-pidscurrent--pidsmax\"\u003e5.4.2 绕开 cgroup PID 限制，实现 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.current \u0026gt; pids.max\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#55-cpuset\" id=\"markdown-toc-55-cpuset\"\u003e5.5 Cpuset\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#cpuset-接口文件\" id=\"markdown-toc-cpuset-接口文件\"\u003eCpuset 接口文件\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#56-device-controller\" id=\"markdown-toc-56-device-controller\"\u003e5.6 Device controller\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#561-控制方式基于-cgroup-bpf-而非接口文件\" id=\"markdown-toc-561-控制方式基于-cgroup-bpf-而非接口文件\"\u003e5.6.1 控制方式：基于 cgroup BPF 而非接口文件\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#562-cgroup-bpf-程序上下文和返回值\" id=\"markdown-toc-562-cgroup-bpf-程序上下文和返回值\"\u003e5.6.2 cgroup BPF 程序上下文和返回值\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#563-cgroup-bpf-程序示例\" id=\"markdown-toc-563-cgroup-bpf-程序示例\"\u003e5.6.3 cgroup BPF 程序示例\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#57-rdma\" id=\"markdown-toc-57-rdma\"\u003e5.7 RDMA\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#rdma-interface-files\" id=\"markdown-toc-rdma-interface-files\"\u003eRDMA Interface Files\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#58-hugetlb\" id=\"markdown-toc-58-hugetlb\"\u003e5.8 HugeTLB\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#hugetlb-interface-files\" id=\"markdown-toc-hugetlb-interface-files\"\u003eHugeTLB Interface Files\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#59-misc\" id=\"markdown-toc-59-misc\"\u003e5.9 Misc\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#perf_event\" id=\"markdown-toc-perf_event\"\u003eperf_event\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#510-规范外non-normative的一些信息\" id=\"markdown-toc-510-规范外non-normative的一些信息\"\u003e5.10 规范外（non-normative）的一些信息\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#cpu-controller-root-cgroup-处理行为\" id=\"markdown-toc-cpu-controller-root-cgroup-处理行为\"\u003eCPU controller root cgroup 处理行为\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#io-controller-root-cgroup-处理行为\" id=\"markdown-toc-io-controller-root-cgroup-处理行为\"\u003eIO controller root cgroup 处理行为\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-cgroup-命名空间cgroupns\" id=\"markdown-toc-6-cgroup-命名空间cgroupns\"\u003e6 cgroup 命名空间（cgroupns）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-基础\" id=\"markdown-toc-61-基础\"\u003e6.1 基础\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#611-功能对-procpidcgroup-和-cgroup-mount-进行虚拟化\" id=\"markdown-toc-611-功能对-procpidcgroup-和-cgroup-mount-进行虚拟化\"\u003e6.1.1 功能：对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/PID/cgroup\u003c/code\u003e 和 cgroup mount 进行虚拟化\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#612-新建-cgroup-namespace\" id=\"markdown-toc-612-新建-cgroup-namespace\"\u003e6.1.2 新建 cgroup namespace\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#613-多线程进程线程-unshare-后的行为\" id=\"markdown-toc-613-多线程进程线程-unshare-后的行为\"\u003e6.1.3 多线程进程：线程 unshare 后的行为\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#614-cgroupns-生命周期\" id=\"markdown-toc-614-cgroupns-生命周期\"\u003e6.1.4 cgroupns 生命周期\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-进一步解释-cgroupns-root-和视图\" id=\"markdown-toc-62-进一步解释-cgroupns-root-和视图\"\u003e6.2 进一步解释 cgroupns root 和视图\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-在-cgroupns-之间迁移进程\" id=\"markdown-toc-63-在-cgroupns-之间迁移进程\"\u003e6.3 在 cgroupns 之间迁移进程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-与其他-cgroupns-交互\" id=\"markdown-toc-64-与其他-cgroupns-交互\"\u003e6.4 与其他 cgroupns 交互\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-内核编程相关信息\" id=\"markdown-toc-7-内核编程相关信息\"\u003e7 内核编程相关信息\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#文件系统对-writeback-的支持\" id=\"markdown-toc-文件系统对-writeback-的支持\"\u003e文件系统对 writeback 的支持\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-v1-core-已弃用特性\" id=\"markdown-toc-8-v1-core-已弃用特性\"\u003e8 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1 core\u003c/code\u003e 已弃用特性\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-v1-存在的问题及-v2-的设计考虑rationales\" id=\"markdown-toc-9-v1-存在的问题及-v2-的设计考虑rationales\"\u003e9 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1\u003c/code\u003e 存在的问题及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev2\u003c/code\u003e 的设计考虑（rationales）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#91-v1-多-hierarchy-带来的问题\" id=\"markdown-toc-91-v1-多-hierarchy-带来的问题\"\u003e9.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1\u003c/code\u003e 多 hierarchy 带来的问题\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#92-线程粒度thread-granularity\" id=\"markdown-toc-92-线程粒度thread-granularity\"\u003e9.2 线程粒度（thread granularity）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#93-内部节点inner-nodes与线程之间竞争\" id=\"markdown-toc-93-内部节点inner-nodes与线程之间竞争\"\u003e9.3 内部节点（inner nodes）与线程之间竞争\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#94-其他-cgroup-接口相关的问题\" id=\"markdown-toc-94-其他-cgroup-接口相关的问题\"\u003e9.4 其他 cgroup 接口相关的问题\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#941-核心接口\" id=\"markdown-toc-941-核心接口\"\u003e9.4.1 核心接口\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#942-控制器接口\" id=\"markdown-toc-942-控制器接口\"\u003e9.4.2 控制器接口\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#943-控制器行为\" id=\"markdown-toc-943-控制器行为\"\u003e9.4.3 控制器行为\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#95-一些-controller-相关的问题及解决方式\" id=\"markdown-toc-95-一些-controller-相关的问题及解决方式\"\u003e9.5 一些 controller 相关的问题及解决方式\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#memory\" id=\"markdown-toc-memory\"\u003eMemory\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e本文（指\u003ca href=\"https://www.kernel.org/doc/html/v5.10/admin-guide/cgroup-v2.html\"\u003e\u003cmark\u003e英文原文\u003c/mark\u003e\u003c/a\u003e）\n是描述 cgroup v2 设计、接口和规范的\u003cstrong\u003e\u003cmark\u003e权威文档\u003c/mark\u003e\u003c/strong\u003e。\n未来所有改动/变化都需反应到本文档中。v1 的文档见\n\u003ca href=\"https://www.kernel.org/doc/html/v5.10/admin-guide/cgroup-v1/index.html\"\u003ecgroup-v1\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e本文描述 cgroup v2 所有\u003cstrong\u003e\u003cmark\u003e用户空间可见的部分\u003c/mark\u003e\u003c/strong\u003e，包括 cgroup\ncore 和各 controller。\u003c/p\u003e\n\n\u003ch1 id=\"1-引言\"\u003e1 引言\u003c/h1\u003e\n\n\u003ch2 id=\"11-术语\"\u003e1.1 术语\u003c/h2\u003e\n\n\u003cp\u003e“cgroup” 是 “control group” 的缩写，并且\u003cstrong\u003e\u003cmark\u003e首字母永远不大写\u003c/mark\u003e\u003c/strong\u003e（never capitalized）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e单数形式（cgroup）指这个特性，或用于 “cgroup controllers” 等术语中的修饰词。\u003c/li\u003e\n  \u003cli\u003e复数形式（cgroups）显式地指多个 cgroup。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"12-cgroup-是什么\"\u003e1.2 cgroup 是什么？\u003c/h2\u003e\n\n\u003cp\u003ecgroup 是一种\u003cstrong\u003e\u003cmark\u003e以 hierarchical（树形层级）方式组织进程的机制\u003c/mark\u003e\u003c/strong\u003e（a\nmechanism to organize processes hierarchically），以及在层级中\u003cstrong\u003e\u003cmark\u003e以受控和\n可配置的方式\u003c/mark\u003e\u003c/strong\u003e（controlled and configurable manner）\u003cstrong\u003e\u003cmark\u003e分发系统资源\n\u003c/mark\u003e\u003c/strong\u003e（distribute system resources）。\u003c/p\u003e\n\n\u003ch3 id=\"121-cgroup-组成部分\"\u003e1.2.1 cgroup 组成部分\u003c/h3\u003e\n\n\u003cp\u003ecgroup 主要由两部分组成：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e核心（core）\u003c/mark\u003e\u003c/strong\u003e：主要负责\u003cstrong\u003e\u003cmark\u003e层级化地组织进程\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e控制器（controllers）\u003c/mark\u003e\u003c/strong\u003e：大部分控制器负责 cgroup 层级中\n\u003cstrong\u003e\u003cmark\u003e特定类型的系统资源的分配\u003c/mark\u003e\u003c/strong\u003e，少部分 utility 控制器用于其他目的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"122-进程线程与-cgroup-关系\"\u003e1.2.2 进程/线程与 cgroup 关系\u003c/h3\u003e\n\n\u003cp\u003e所有 cgroup 组成一个\u003cstrong\u003e\u003cmark\u003e树形结构\u003c/mark\u003e\u003c/strong\u003e（tree structure），\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e系统中的\u003cstrong\u003e\u003cmark\u003e每个进程都属于且只属于\u003c/mark\u003e\u003c/strong\u003e某一个 cgroup；\u003c/li\u003e\n  \u003cli\u003e一个\u003cstrong\u003e\u003cmark\u003e进程的所有线程\u003c/mark\u003e\u003c/strong\u003e属于同一个 cgroup；\u003c/li\u003e\n  \u003cli\u003e创建子进程时，继承其父进程的 cgroup；\u003c/li\u003e\n  \u003cli\u003e一个进程可以被\u003cstrong\u003e\u003cmark\u003e迁移\u003c/mark\u003e\u003c/strong\u003e到其他 cgroup；\u003c/li\u003e\n  \u003cli\u003e迁移一个进程时，\u003cstrong\u003e\u003cmark\u003e子进程（后代进程）不会自动\u003c/mark\u003e\u003c/strong\u003e跟着一起迁移；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"123-控制器\"\u003e1.2.3 控制器\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e遵循特定的结构规范（structural constraints），可以选择性地\n\u003cstrong\u003e\u003cmark\u003e针对一个 cgroup 启用或禁用某些控制器\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e控制器的所有行为都是 hierarchical 的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e如果一个 cgroup 启用了某个控制器，那这个 cgroup 的 sub-hierarchy 中所有进程都会受控制。\u003c/li\u003e\n      \u003cli\u003e如果在更接近 root 的节点上设置了资源限制（restrictions set closer to the\nroot），那在下面的 sub-hierarchy 是无法覆盖的。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"2-基础操作\"\u003e2 基础操作\u003c/h1\u003e\n\n\u003ch2 id=\"21-挂载mounting\"\u003e2.1 挂载（mounting）\u003c/h2\u003e\n\n\u003cp\u003e与 v1 不同，cgroup \u003cstrong\u003e\u003cmark\u003ev2 只有单个层级树\u003c/mark\u003e\u003c/strong\u003e（single hierarchy）。\n用如下命令挂载 v2 hierarchy：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# mount -t \u0026lt;fstype\u0026gt; \u0026lt;device\u0026gt; \u0026lt;dir\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e cgroup2 none \u003cspan class=\"nv\"\u003e$MOUNT_POINT\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003ecgroupv2 文件系统\u003c/mark\u003e\u003c/strong\u003e 的 magic number 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x63677270\u003c/code\u003e (“cgrp”)。\u003c/p\u003e\n\n\u003ch3 id=\"211-控制器与-v1v2-绑定关系\"\u003e2.1.1 控制器与 v1/v2 绑定关系\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e所有\u003cstrong\u003e\u003cmark\u003e支持 v2 且未绑定到 v1 的控制器，会被自动绑定到 v2\u003c/mark\u003e\u003c/strong\u003e hierarchy，出现在 root 层级中。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003ev2 中未在使用的控制器\u003c/mark\u003e\u003c/strong\u003e（not in active use），可以绑定到其他 hierarchies。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这说明我们能以完全后向兼容的方式，\u003cstrong\u003e\u003cmark\u003e混用 v2 和 v1 hierarchy\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e下面通过实际例子理解以上是什么意思。\u003c/p\u003e\n\n\u003ch3 id=\"212-示例ubuntu-2004-同时挂载-cgroupv1cgroupv2译注\"\u003e2.1.2 示例：ubuntu 20.04 同时挂载 cgroupv1/cgroupv2（译注）\u003c/h3\u003e\n\n\u003cp\u003e查看 ubuntu 20.04 (5.11 内核）cgroup 相关的挂载点：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ecgroup\ntmpfs on /sys/fs/cgroup \u003cspan class=\"nb\"\u003etype \u003c/span\u003etmpfs \u003cspan class=\"o\"\u003e(\u003c/span\u003ero,nosuid,nodev,noexec,mode\u003cspan class=\"o\"\u003e=\u003c/span\u003e755,inode64\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup2 on /sys/fs/cgroup/unified \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup2 \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,nsdelegate\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/systemd \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,xattr,name\u003cspan class=\"o\"\u003e=\u003c/span\u003esystemd\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/cpuset \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,cpuset\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/cpu,cpuacct \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,cpu,cpuacct\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/hugetlb \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,hugetlb\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/blkio \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,blkio\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/pids \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,pids\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/rdma \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,rdma\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/net_cls,net_prio \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,net_cls,net_prio\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/freezer \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,freezer\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/devices \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,devices\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/memory \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,memory\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/perf_event \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,perf_event\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，系统\u003cstrong\u003e\u003cmark\u003e同时挂载了 cgroup 和 cgroup2\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ecgroup v2 是单一层级树，因此只有一个挂载点（第二行）\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/sys/fs/cgroup/unified\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，这就是上一小节所说的 \u003cstrong\u003e\u003cmark\u003eroot 层级\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003ecgroup v1 根据控制器类型（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuset/cpu,cpuacct/hugetlb/...\u003c/code\u003e），挂载到不同位置。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e接下来看\u003cstrong\u003e\u003cmark\u003e哪些控制绑定到了 cgroup v2\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e \u003cspan class=\"nt\"\u003e-ahlp\u003c/span\u003e /sys/fs/cgroup/unified/\ntotal 0\n\u003cspan class=\"nt\"\u003e-r--r--r--\u003c/span\u003e   1 root root   0 cgroup.controllers\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cgroup.max.depth\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cgroup.max.descendants\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cgroup.procs\n\u003cspan class=\"nt\"\u003e-r--r--r--\u003c/span\u003e   1 root root   0 cgroup.stat\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cgroup.subtree_control\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cgroup.threads\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 cpu.pressure\n\u003cspan class=\"nt\"\u003e-r--r--r--\u003c/span\u003e   1 root root   0 cpu.stat\ndrwxr-xr-x   2 root root   0 init.scope/\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 io.pressure\n\u003cspan class=\"nt\"\u003e-rw-r--r--\u003c/span\u003e   1 root root   0 memory.pressure\ndrwxr-xr-x 121 root root   0 system.slice/\ndrwxr-xr-x   3 root root   0 user.slice/\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e只有 cpu/io/memory 等\u003cstrong\u003e\u003cmark\u003e少量控制器\u003c/mark\u003e\u003c/strong\u003e（大部分还在 cgroup v1 中，系统默认使用 v1）。\u003c/p\u003e\n\n\u003cp\u003e最后看几个控制器文件的内容，加深一点直观印象，后面章节会详细解释这些分别表示什么意思：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /sys/fs/cgroup/unified\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecpu.pressure\nsome \u003cspan class=\"nv\"\u003eavg10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg60\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg300\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003etotal\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e2501067303\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecpu.stat\nusage_usec 44110960000\nuser_usec 29991256000\nsystem_usec 14119704000\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003eio.pressure\nsome \u003cspan class=\"nv\"\u003eavg10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg60\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg300\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003etotal\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e299044042\nfull \u003cspan class=\"nv\"\u003eavg10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg60\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg300\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003etotal\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e271257559\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ememory.pressure\nsome \u003cspan class=\"nv\"\u003eavg10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg60\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg300\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003etotal\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e298215\nfull \u003cspan class=\"nv\"\u003eavg10\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg60\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003eavg300\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e0.00 \u003cspan class=\"nv\"\u003etotal\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e229843\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"213-控制器在-v1-和-v2-之间切换\"\u003e2.1.3 控制器在 v1 和 v2 之间切换\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e控制器在当前 hierarchy 中已经\u003cstrong\u003e\u003cmark\u003e不再被引用\u003c/mark\u003e\u003c/strong\u003e（no longer referenced），\n  才能移动到其他 hierarchy。\u003c/li\u003e\n  \u003cli\u003e由于 \u003cstrong\u003e\u003cmark\u003eper-cgroup 控制器状态\u003c/mark\u003e\u003c/strong\u003e是异步销毁的，从 v1 umount 之后\n  可能会有 linger reference，因此可能不会立即出现在 v2 hierarchy 中。\u003c/li\u003e\n  \u003cli\u003e类似地，一个控制器只有被完全禁用之后，才能被移出 v2 hierarchy，且可能\n  过一段时间才能在 v1 hierarchy 中可用；\u003c/li\u003e\n  \u003cli\u003e此外，由于控制器间的依赖，其他控制器也可能需要被禁用。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在 v2 和 v1 之间动态移动控制器对开发和手动配置很有用，但\n\u003cstrong\u003e\u003cmark\u003e强烈建议不要在生产环境这么做\u003c/mark\u003e\u003c/strong\u003e。建议在系统启动、控制器开始使用之后，\n就不要再修改 hierarchy 和控制器的关联关系了。\u003c/p\u003e\n\n\u003cp\u003e另外，迁移到 v2 时，\u003cstrong\u003e\u003cmark\u003e系统管理软件可能仍然会自动 mount v1 cgroup 文件系统\u003c/mark\u003e\u003c/strong\u003e，\n因此需要在\u003cstrong\u003e\u003cmark\u003e系统启动过程中\u003c/mark\u003e\u003c/strong\u003e劫持所有的控制器，因为启动之后就晚了。\n为方便测试，内核提供了 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup_no_v1=allows\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 配置，\n可完全禁用 v1 控制器（强制使用 v2）。\u003c/p\u003e\n\n\u003ch3 id=\"214-cgroupv2-mount-选项\"\u003e2.1.4 cgroupv2 mount 选项\u003c/h3\u003e\n\n\u003cp\u003e前面 mount 命令没指定任何特殊参数。目前支持如下 mount 选项：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensdelegate\u003c/code\u003e：将 cgroup namespaces \u003cstrong\u003e\u003cmark\u003e（cgroupns）作为 delegation 边界\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e系统层选项，只能在 init namespace 通过 mount/unmount 来修改这个配置。在\n  non-init namespace 中，这个选项会被忽略。详见下面的 \u003ca href=\"#delegation\"\u003eDelegation 小结\u003c/a\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory_localevents\u003c/code\u003e：只为当前 cgroup populate \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory.events\u003c/code\u003e，\u003cstrong\u003e\u003cmark\u003e不统计任何 subtree\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e这是 legacy 行为，如果没配置这个参数，默认行为会统计所有的 subtree。\u003c/p\u003e\n\n    \u003cp\u003e系统层选项，只能在 init namespace 通过 mount/unmount 来修改这个配置。在\n  non-init namespace 中，这个选项会被忽略。详见下面的 \u003ca href=\"#delegation\"\u003eDelegation 小结\u003c/a\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory_recursiveprot\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003eRecursively apply memory.min and memory.low protection to\nentire subtrees, without requiring explicit downward\npropagation into leaf cgroups.  This allows protecting entire\nsubtrees from one another, while retaining free competition\nwithin those subtrees.  This should have been the default\nbehavior but is a mount-option to avoid regressing setups\nrelying on the original semantics (e.g. specifying bogusly\nhigh ‘bypass’ protection values at higher tree levels).\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"22-组织organizing进程和线程\"\u003e2.2 组织（organizing）进程和线程\u003c/h2\u003e\n\n\u003ch3 id=\"221-进程创建删除移动查看-cgroup\"\u003e2.2.1 进程：创建/删除/移动/查看 cgroup\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e初始状态下，只有 root cgroup\u003c/mark\u003e\u003c/strong\u003e，所有进程都属于这个 cgroup。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e创建 sub-cgroup\u003c/mark\u003e\u003c/strong\u003e：只需创建一个子目录，\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003emkdir\u003c/span\u003e \u003cspan class=\"nv\"\u003e$CGROUP_NAME\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e一个 cgroup 可以有多个子 cgroup，形成一个树形结构；\u003c/li\u003e\n      \u003cli\u003e\n        \u003cp\u003e每个 cgroup 都有一个\u003cstrong\u003e\u003cmark\u003e可读写的接口文件 \u003ccode\u003ecgroup.procs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e读该文件会列出这个 cgroup 内的所有 PID，每行一个；\u003c/li\u003e\n          \u003cli\u003ePID 并未排序；\u003c/li\u003e\n          \u003cli\u003e同一 PID 可能出现多次：进程先移出再移入该 cgroup，或读文件期间 PID 被重用了，都可能发生这种情况。\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e将进程移动到指定 cgroup\u003c/mark\u003e\u003c/strong\u003e：将 PID 写到相应 cgroup 的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.procs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 文件即可。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e每次 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewrite(2)\u003c/code\u003e 只能迁移\u003cstrong\u003e\u003cmark\u003e一个进程\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n      \u003cli\u003e如果进程有\u003cstrong\u003e\u003cmark\u003e多个线程\u003c/mark\u003e\u003c/strong\u003e，那将任意线程的 PID 写到文件，都会将该进程的所有线程迁移到相应 cgroup。\u003c/li\u003e\n      \u003cli\u003e如果进程 fork 出一个子进程，那子进程属于执行 fork 操作时父进程所属的 cgroup。\u003c/li\u003e\n      \u003cli\u003e进程退出（exit）后，\u003cstrong\u003e\u003cmark\u003e仍然留在退出时它所属的 cgroup\u003c/mark\u003e\u003c/strong\u003e，直到这个进程被收割（reap）；\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e僵尸进程不会出现在 cgroup.procs 中\u003c/mark\u003e\u003c/strong\u003e，因此\u003cstrong\u003e\u003cmark\u003e无法对僵尸进程执行 cgroup 迁移操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e删除 cgroup/sub-cgroup\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e如果一个 cgroup 已经没有任何 children 或活进程，那直接\n\u003cstrong\u003e\u003cmark\u003e删除对应的文件夹\u003c/mark\u003e\u003c/strong\u003e就删除该 cgroup 了。\u003c/li\u003e\n      \u003cli\u003e如果一个 cgroup 已经没有 children，虽然其中还有进程但\u003cstrong\u003e\u003cmark\u003e全是僵尸进程\u003c/mark\u003e\u003c/strong\u003e\n（zombie processes），那\u003cstrong\u003e\u003cmark\u003e认为这个 cgroup 是空的\u003c/mark\u003e\u003c/strong\u003e，也可以直接删除。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e查看进程的 cgroup 信息：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat /proc/$PID/cgroup\u003c/code\u003e 会列出该进程的 \u003cstrong\u003e\u003cmark\u003ecgroup membership\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e如果系统启用了 v1，这个文件可能会包含多行，\u003cstrong\u003e\u003cmark\u003e每个 hierarchy 一行\u003c/mark\u003e\u003c/strong\u003e。\n \u003cstrong\u003e\u003cmark\u003ev2 对应的行永远是 \u003ccode\u003e0::$PATH\u003c/code\u003e 格式\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/\u003cspan class=\"nv\"\u003e$$\u003c/span\u003e/cgroup \u003cspan class=\"c\"\u003e# ubuntu 20.04 上的输出，$$ 是当前 shell 的进程 ID\u003c/span\u003e\n 12:devices:/user.slice\n 11:freezer:/\n 10:memory:/user.slice/user-1000.slice/session-1.scope\n 9:hugetlb:/\n 8:cpuset:/\n 7:perf_event:/\n 6:rdma:/\n 5:pids:/user.slice/user-1000.slice/session-1.scope\n 4:cpu,cpuacct:/user.slice\n 3:blkio:/user.slice\n 2:net_cls,net_prio:/\n 1:name\u003cspan class=\"o\"\u003e=\u003c/span\u003esystemd:/user.slice/user-1000.slice/session-1.scope\n 0::/user.slice/user-1000.slice/session-1.scope\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e如果一个进程变成\u003cstrong\u003e\u003cmark\u003e僵尸进程\u003c/mark\u003e\u003c/strong\u003e（zombie），并且与它关联的\n \u003cstrong\u003e\u003cmark\u003ecgroup 随后被删掉了\u003c/mark\u003e\u003c/strong\u003e，那行尾会出现 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e(deleted)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 字样：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/842/cgroup\n ...\n 0::/test-cgroup/test-cgroup-nested \u003cspan class=\"o\"\u003e(\u003c/span\u003edeleted\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"222-线程\"\u003e2.2.2 线程\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003ecgroup v2 的\u003cstrong\u003e\u003cmark\u003e一部分控制器\u003c/mark\u003e\u003c/strong\u003e支持线程粒度的资源控制，\n 这种控制器称为 \u003cstrong\u003e\u003cmark\u003ethreaded controllers\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e默认情况下，一个进程的所有线程属于同一个 cgroup，\u003c/li\u003e\n      \u003cli\u003e线程模型使我们能将不同线程放到 subtree 的不同位置，而同时还能保持二者在同一\n资源域（resource domain）内。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e不支持线程模式的控制器称为 \u003cstrong\u003e\u003cmark\u003edomain controllers\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e将一个 cgroup 标记为 threaded，那它将作为 threaded cgroup 将加入 parent 的资源域\n。而 parent 可能也是一个 threaded cgroup，它所属的资源域在 hierarchy 层级中的更\n上面。一个 threaded subtree 的 root，即第一个不是 threaded 的祖先，称为 threaded\ndomain 或 threaded root，作为整个 subtree 的资源域。\u003c/p\u003e\n\n\u003cp\u003eInside a threaded subtree, threads of a process can be put in\ndifferent cgroups and are not subject to the no internal process\nconstraint - threaded controllers can be enabled on non-leaf cgroups\nwhether they have threads in them or not.\u003c/p\u003e\n\n\u003cp\u003eAs the threaded domain cgroup hosts all the domain resource\nconsumptions of the subtree, it is considered to have internal\nresource consumptions whether there are processes in it or not and\ncan’t have populated child cgroups which aren’t threaded.  Because the\nroot cgroup is not subject to no internal process constraint, it can\nserve both as a threaded domain and a parent to domain cgroups.\u003c/p\u003e\n\n\u003cp\u003eThe current operation mode or type of the cgroup is shown in the\n“cgroup.type” file which indicates whether the cgroup is a normal\ndomain, a domain which is serving as the domain of a threaded subtree,\nor a threaded cgroup.\u003c/p\u003e\n\n\u003ch4 id=\"将-cgroup-改成-threaded-模式单向不可逆操作\"\u003e将 cgroup 改成 threaded 模式（单向/不可逆操作）\u003c/h4\u003e\n\n\u003cp\u003ecgroup 创建之后都是 domain cgroup，可以通过下面的命令将其\u003cstrong\u003e\u003cmark\u003e改成 threaded 模式\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003ethreaded \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup.type\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e但注意：\u003cstrong\u003e\u003cmark\u003e这个操作是单向的\u003c/mark\u003e\u003c/strong\u003e，一旦设置成 threaded 模式之后，就无法再切回\ndomain 模式了。\u003c/p\u003e\n\n\u003cp\u003e开启 thread 模型必须先满足如下条件：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eAs the cgroup will join the parent’s resource domain.  The parent\n  must either be a valid (threaded) domain or a threaded cgroup.\u003c/li\u003e\n  \u003cli\u003eWhen the parent is an unthreaded domain, it must not have any domain\n  controllers enabled or populated domain children.  The root is\n  exempt from this requirement.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eTopology-wise, a cgroup can be in an invalid state.  Please consider\nthe following topology:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  A (threaded domain) - B (threaded) - C (domain, just created)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eC is created as a domain but isn’t connected to a parent which can\nhost child domains.  C can’t be used until it is turned into a\nthreaded cgroup.  “cgroup.type” file will report “domain (invalid)” in\nthese cases.  Operations which fail due to invalid topology use\nEOPNOTSUPP as the errno.\u003c/p\u003e\n\n\u003cp\u003eA domain cgroup is turned into a threaded domain when one of its child\ncgroup becomes threaded or threaded controllers are enabled in the\n“cgroup.subtree_control” file while there are processes in the cgroup.\nA threaded domain reverts to a normal domain when the conditions\nclear.\u003c/p\u003e\n\n\u003cp\u003eWhen read, “cgroup.threads” contains the list of the thread IDs of all\nthreads in the cgroup.  Except that the operations are per-thread\ninstead of per-process, “cgroup.threads” has the same format and\nbehaves the same way as “cgroup.procs”.  While “cgroup.threads” can be\nwritten to in any cgroup, as it can only move threads inside the same\nthreaded domain, its operations are confined inside each threaded\nsubtree.\u003c/p\u003e\n\n\u003cp\u003eThe threaded domain cgroup serves as the resource domain for the whole\nsubtree, and, while the threads can be scattered across the subtree,\nall the processes are considered to be in the threaded domain cgroup.\n“cgroup.procs” in a threaded domain cgroup contains the PIDs of all\nprocesses in the subtree and is not readable in the subtree proper.\nHowever, “cgroup.procs” can be written to from anywhere in the subtree\nto migrate all threads of the matching process to the cgroup.\u003c/p\u003e\n\n\u003cp\u003eOnly threaded controllers can be enabled in a threaded subtree.  When\na threaded controller is enabled inside a threaded subtree, it only\naccounts for and controls resource consumptions associated with the\nthreads in the cgroup and its descendants.  All consumptions which\naren’t tied to a specific thread belong to the threaded domain cgroup.\u003c/p\u003e\n\n\u003cp\u003eBecause a threaded subtree is exempt from no internal process\nconstraint, a threaded controller must be able to handle competition\nbetween threads in a non-leaf cgroup and its child cgroups.  Each\nthreaded controller defines how such competitions are handled.\u003c/p\u003e\n\n\u003ch2 id=\"23-unpopulated-notification进程退出通知\"\u003e2.3 [Un]populated Notification（进程退出通知）\u003c/h2\u003e\n\n\u003cp\u003e每个 non-root cgroup 都有一个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.events\u003c/code\u003e 文件\u003c/mark\u003e\u003c/strong\u003e，\n其中包含了 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epopulated\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 字段，描述这个 cgroup 的\nsub-hierarchy 中\u003cstrong\u003e\u003cmark\u003e是否存在活进程\u003c/mark\u003e\u003c/strong\u003e（live processes）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果值是 0，表示 cgroup 及其 sub-cgroup 中没有活进程；\u003c/li\u003e\n  \u003cli\u003e如果值是 1：那这个值变为 0 时，会触发 poll 和 [id]notify 事件。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这可以用来，例如，在一个 sub-hierarchy 内的\u003cstrong\u003e\u003cmark\u003e所有进程退出之后触发执行清理操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eThe populated 状态更新和通知是递归的。以下图为例，括号中的数字表示该 cgroup 中的进程数量：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  A(4) - B(0) - C(1)\n              \\ D(0)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003eA、B 和 C 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epopulated\u003c/code\u003e 字段都应该是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e，而 D 的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e当 C 中唯一的进程退出之后，B 和 C 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epopulated\u003c/code\u003e 字段将变成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e，将\n\u003cstrong\u003e\u003cmark\u003e在这两个 cgroup 内触发一次 cgroup.events 文件的文件修改事件\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"23-管理控制器controlling-controllers\"\u003e2.3 管理控制器（controlling controllers）\u003c/h2\u003e\n\n\u003ch3 id=\"231-启用和禁用\"\u003e2.3.1 启用和禁用\u003c/h3\u003e\n\n\u003cp\u003e每个 cgroup 都有一个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.controllers\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 文件，\n其中列出了这个 cgroup 可用的所有控制器：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecgroup.controllers\ncpu io memory\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e默认没有启用任何控制\u003c/mark\u003e\u003c/strong\u003e。启用或禁用是通过写\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.subtree_control\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 文件完成的：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;+cpu +memory -io\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup.subtree_control\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e只有\u003cstrong\u003e\u003cmark\u003e出现在 cgroup.controllers 中\u003c/mark\u003e\u003c/strong\u003e的控制器\u003cstrong\u003e\u003cmark\u003e才能被启用\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果像上面的命令一样，一次指定多个操作，那它们要么全部功能，要么全部失败；\u003c/li\u003e\n  \u003cli\u003e如果对同一个控制器指定了多个操作，最后一个是有效的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e启用 cgroup 的某个控制器，意味着控制它在子节点之间分配目标资源（target resource）的行为。\n考虑下面的 sub-hierarchy，括号中是已经启用的控制器：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  A(cpu,memory) - B(memory) - C()\n                            \\ D()\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003eA 启用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory\u003c/code\u003e，因此会控制它的 child（即 B）的 CPU 和 memory 使用；\u003c/li\u003e\n  \u003cli\u003eB 只启用了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory\u003c/code\u003e，因此 C 和 D 的 memory 使用量会受 B 控制，但\n\u003cstrong\u003e\u003cmark\u003eCPU 可以随意竞争\u003c/mark\u003e\u003c/strong\u003e（compete freely）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e控制器限制 children 的资源使用方式，是\u003cstrong\u003e\u003cmark\u003e创建或写入 children cgroup 的接口文件\u003c/mark\u003e\u003c/strong\u003e。\n还是以上面的拓扑为例：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 B 上启用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu\u003c/code\u003e 将会在 C 和 D 的 cgroup 目录中创建 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu.\u003c/code\u003e 开头的接口文件；\u003c/li\u003e\n  \u003cli\u003e同理，禁用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory\u003c/code\u003e 时会删除对应的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory.\u003c/code\u003e 开头的文件。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这也意味着\u003cstrong\u003e\u003cmark\u003ecgroup 目录中所有不以 \u003ccode\u003ecgroup.\u003c/code\u003e开头的\u003c/mark\u003e\u003c/strong\u003e\n控制器接口文件 —— 在管理上 \u003cstrong\u003e\u003cmark\u003e都属于 parent cgroup 而非当前 cgroup 自己\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"232-自顶向下启用top-down-constraint\"\u003e2.3.2 自顶向下启用（top-down constraint）\u003c/h3\u003e\n\n\u003cp\u003e资源是自顶向下（top-down）分配的，只有当一个 cgroup 从 parent 获得了某种资源，它\n才可以继续向下分发。这意味着\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e只有父节点启用了某个控制器，子节点才能启用；\u003c/li\u003e\n  \u003cli\u003e对应到实现上，\u003cstrong\u003e\u003cmark\u003e所有非根节点\u003c/mark\u003e\u003c/strong\u003e（non-root）的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.subtree_control\u003c/code\u003e 文件中，\n只能包含它的父节点的 \u003ccode\u003ecgroup.subtree_control\u003c/code\u003e 中有的控制器；\u003c/li\u003e\n  \u003cli\u003e另一方面，只要有子节点还在使用某个控制器，父节点就无法禁用之。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"233-将资源分给-children-时parent-cgroup-内不能有进程no-internal-process\"\u003e2.3.3 将资源分给 children 时，parent cgroup 内不能有进程（no internal process）\u003c/h3\u003e\n\n\u003cp\u003e只有当一个 non-root cgroup 中\u003cstrong\u003e\u003cmark\u003e没有任何进程时\u003c/mark\u003e\u003c/strong\u003e，才能将其 domain\nresource 分配给它的 children。换句话说，只有那些没有任何进程的 domain cgroup，\n才能\u003cstrong\u003e\u003cmark\u003e将它们的 domain controllers 写到其 children 的\n\u003ccode\u003ecgroup.subtree_control\u003c/code\u003e 文件中\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这种方式保证了在给定的 domain controller 范围内，\u003cstrong\u003e\u003cmark\u003e所有进程都位于叶子节点上\u003c/mark\u003e\u003c/strong\u003e，\n因而\u003cstrong\u003e\u003cmark\u003e避免了 child cgroup 内的进程与 parent 内的进程竞争\u003c/mark\u003e\u003c/strong\u003e的情况，便于\ndomain controller 扫描 hierarchy。\u003c/p\u003e\n\n\u003cp\u003e但 \u003cstrong\u003e\u003cmark\u003eroot cgroup 不受此限制\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对大部分类型的控制器来说，root 中包含了一些\u003cstrong\u003e\u003cmark\u003e没有与任何 cgroup 相关联的进程和匿名资源占用\u003c/mark\u003e\u003c/strong\u003e\n（anonymous resource consumption），需要特殊对待。\u003c/li\u003e\n  \u003cli\u003eroot cgroup 的资源占用是如何管理的，\u003cstrong\u003e\u003cmark\u003e因控制器而异\u003c/mark\u003e\u003c/strong\u003e（更多信息可参考\nControllers 小结）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e注意，在 parent 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.subtree_control\u003c/code\u003e 启用控制器之前，这些限制不会生效。\n这非常重要，因为它决定了创建 populated cgroup children 的方式。\n\u003cstrong\u003e\u003cmark\u003e要控制一个 cgroup 的资源分配\u003c/mark\u003e\u003c/strong\u003e，这个 cgroup 需要：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e创建 children cgroup，\u003c/li\u003e\n  \u003cli\u003e将自己所有的进程转移到 children cgroup 中，\u003c/li\u003e\n  \u003cli\u003e在它自己的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.subtree_control\u003c/code\u003e 中启用控制器。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003ca name=\"delegation\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2 id=\"24-delegation委派\"\u003e2.4 Delegation（委派）\u003c/h2\u003e\n\n\u003ch3 id=\"241-model-of-delegation\"\u003e2.4.1 Model of Delegation\u003c/h3\u003e\n\n\u003cp\u003ecgroup 能以两种方式 delegate。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e通过授予该目录以及目录中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.procs\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.threads\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.subtree_control\u003c/code\u003e 文件的写权限，\n  将 cgroup delegate 给一个 less privileged 用户；\u003c/li\u003e\n  \u003cli\u003e如果配置了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensdelegate\u003c/code\u003e 挂载选项，会在创建 cgroup 时自动 delegate。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e对于一个给定的目录，由于其中的 resource control 接口文件控制着 parent 的资源的分配，\n因此 delegatee 不应该被授予写权限。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eFor the first method, this is achieved by not granting access to these files.\u003c/li\u003e\n  \u003cli\u003e对第二种方式，内核会拒绝除了在该 namespace 内对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.procs\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.subtree_control\u003c/code\u003e 之外的对其他文件的写操作。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe end results are equivalent for both delegation types.  Once\ndelegated, the user can build sub-hierarchy under the directory,\norganize processes inside it as it sees fit and further distribute the\nresources it received from the parent.  The limits and other settings\nof all resource controllers are hierarchical and regardless of what\nhappens in the delegated sub-hierarchy, nothing can escape the\nresource restrictions imposed by the parent.\u003c/p\u003e\n\n\u003cp\u003e目前，cgroup 并未对 delegated sub-hierarchy 的 cgroup 数量或嵌套深度施加限制；但未来可能会施加显式限制。\u003c/p\u003e\n\n\u003ch3 id=\"242-delegation-containment\"\u003e2.4.2 Delegation Containment\u003c/h3\u003e\n\n\u003cp\u003eA delegated sub-hierarchy is contained in the sense that processes\ncan’t be moved into or out of the sub-hierarchy by the delegatee.\u003c/p\u003e\n\n\u003cp\u003eFor delegations to a less privileged user, this is achieved by\nrequiring the following conditions for a process with a non-root euid\nto migrate a target process into a cgroup by writing its PID to the\n“cgroup.procs” file.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThe writer must have write access to the “cgroup.procs” file.\u003c/li\u003e\n  \u003cli\u003eThe writer must have write access to the “cgroup.procs” file of the\ncommon ancestor of the source and destination cgroups.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe above two constraints ensure that while a delegatee may migrate\nprocesses around freely in the delegated sub-hierarchy it can’t pull\nin from or push out to outside the sub-hierarchy.\u003c/p\u003e\n\n\u003cp\u003eFor an example, let’s assume cgroups C0 and C1 have been delegated to\nuser U0 who created C00, C01 under C0 and C10 under C1 as follows and\nall processes under C0 and C1 belong to U0::\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e~~~~~~~~~~~~~ - C0 - C00\n~ cgroup    ~      \\ C01\n~ hierarchy ~\n~~~~~~~~~~~~~ - C1 - C10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eLet’s also say U0 wants to write the PID of a process which is\ncurrently in C10 into “C00/cgroup.procs”.  U0 has write access to the\nfile; however, the common ancestor of the source cgroup C10 and the\ndestination cgroup C00 is above the points of delegation and U0 would\nnot have write access to its “cgroup.procs” files and thus the write\nwill be denied with -EACCES.\u003c/p\u003e\n\n\u003cp\u003eFor delegations to namespaces, containment is achieved by requiring\nthat both the source and destination cgroups are reachable from the\nnamespace of the process which is attempting the migration.  If either\nis not reachable, the migration is rejected with -ENOENT.\u003c/p\u003e\n\n\u003ch2 id=\"25-指导原则\"\u003e2.5 指导原则\u003c/h2\u003e\n\n\u003ch3 id=\"251-避免频繁在-cgroup-之间迁移进程organize-once-and-control\"\u003e2.5.1 避免频繁在 cgroup 之间迁移进程（Organize once and control）\u003c/h3\u003e\n\n\u003cp\u003e原则：创建进程前，先想好应该放在哪个 cgroup；进程启动后，通过 controller 接口文件进行控制。\u003c/p\u003e\n\n\u003cp\u003e在 cgroup 之间迁移进程是一个\u003cstrong\u003e\u003cmark\u003e开销相对较高\u003c/mark\u003e\u003c/strong\u003e的操作，而且\n\u003cstrong\u003e\u003cmark\u003e有状态资源（例如 memory）\u003c/mark\u003e\u003c/strong\u003e是\u003cstrong\u003e\u003cmark\u003e不会随着进程一起迁移\u003c/mark\u003e\u003c/strong\u003e的。\n这种行为是有意设计的，因为 there often exist inherent trade-offs between\nmigration and various hot paths in terms of synchronization cost.\u003c/p\u003e\n\n\u003cp\u003e因此，\u003cstrong\u003e\u003cmark\u003e不建议为了达到某种资源限制目的而频繁地在 cgroup 之间迁移进程\u003c/mark\u003e\u003c/strong\u003e。\n一个进程启动时，就应该根据系统的逻辑和资源结构分配到合适的 cgroup。\n动态调整资源分配可以通过修改接口文件来调整 controller 配置。\u003c/p\u003e\n\n\u003ch3 id=\"252-避免文件名冲突avoid-name-collisions\"\u003e2.5.2 避免文件名冲突（Avoid Name Collisions）\u003c/h3\u003e\n\n\u003cp\u003ecgroup 自己的接口文件和它的 children cgroup 的接口文件\u003cstrong\u003e\u003cmark\u003e位于同一目录中\u003c/mark\u003e\u003c/strong\u003e，\n因此创建 children cgroup 时有可能与 cgroup 自己的接口文件冲突。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e所有 \u003cstrong\u003e\u003cmark\u003ecgroup 核心接口文件\u003c/mark\u003e\u003c/strong\u003e都是以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.\u003c/code\u003e 开头，并且不会以常用的 job/service/slice/unit/workload 等作为开头或结尾。\u003c/li\u003e\n  \u003cli\u003e每个控制器的接口文件都以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;controller name\u0026gt;.\u003c/code\u003e 开头，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;controller\u0026gt; name\u003c/code\u003e 由小写字母和下划线组成，但不会以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_\u003c/code\u003e 开头。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此为避免冲突，可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e_\u003c/code\u003e 作为前缀。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003ecgroup 没有任何文件名冲突检测机制\u003c/mark\u003e\u003c/strong\u003e，因此避免文件冲突是用户自己的责任。\u003c/p\u003e\n\n\u003ch1 id=\"3-资源分配模型resource-distribution-models\"\u003e3 资源分配模型（Resource distribution models）\u003c/h1\u003e\n\n\u003cp\u003e根据资源类型（resource type）与使用场景的不同，cgroup 控制器实现了机制不同的资源\n分发方式。本节介绍主要的几种机制及其行为。\u003c/p\u003e\n\n\u003ch2 id=\"31-weights资源量权重\"\u003e3.1 Weights（资源量权重）\u003c/h2\u003e\n\n\u003cp\u003e这种模型的一个\u003cstrong\u003e\u003cmark\u003e例子\u003c/mark\u003e\u003c/strong\u003e是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu.weight\u003c/code\u003e，负责在 active children 之间\n按比例分配 CPU cycle 资源。\u003c/p\u003e\n\n\u003cp\u003e这种模型中，parent 会\u003cstrong\u003e\u003cmark\u003e根据所有 active children 的权重来计算它们各自的占比\u003c/mark\u003e\u003c/strong\u003e\n（ratio）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e由于只有那些能使用这些资源的 children 会参与到资源分配，因此这种模型\n\u003cstrong\u003e\u003cmark\u003e能实现资源的充分利用\u003c/mark\u003e\u003c/strong\u003e（work-conserving）。\u003c/li\u003e\n  \u003cli\u003e这种分配模型\u003cstrong\u003e\u003cmark\u003e本质上是动态的\u003c/mark\u003e\u003c/strong\u003e（the dynamic nature）, 因此常用于\u003cstrong\u003e\u003cmark\u003e无状态资源\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e权重值范围是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e[1, 10000]\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，默认 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100\u003c/code\u003e。这使得能以\n足够细的粒度增大或缩小权重（以 100 为中心，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100/100 = 1\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100*100 = 10000\u003c/code\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"32-limits资源量上限可超分\"\u003e3.2 Limits（资源量上限，可超分）\u003c/h2\u003e\n\n\u003cp\u003e这种模型的一个\u003cstrong\u003e\u003cmark\u003e例子\u003c/mark\u003e\u003c/strong\u003e是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eio.max\u003c/code\u003e，负责在 IO device 上限制 cgroup 的最大 BPS 或 IOPS。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这种模型给 child 配置的资源使用量上限（limit）。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e资源是可以超分的\u003c/mark\u003e\u003c/strong\u003e（over-committed），即所有 children 的份额加起来可以大于 parent 的总可用量。\u003c/li\u003e\n  \u003cli\u003eLimits 值范围是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e[0, max]\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，默认 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax\u003c/code\u003e，也就是没做限制。\u003c/li\u003e\n  \u003cli\u003e由于 limits 是可以超分的，因此所有配置组合都是合法的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"33-protections资源量保护可超分\"\u003e3.3 Protections（资源量保护，可超分）\u003c/h2\u003e\n\n\u003cp\u003e这种模型的一个\u003cstrong\u003e\u003cmark\u003e例子\u003c/mark\u003e\u003c/strong\u003e是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory.low\u003c/code\u003e，实现了 \u003cstrong\u003e\u003cmark\u003ebest-effort 内存保护\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e在这种模型中，只要一个 cgroup 的所有祖先都处于各自的 protected level 以下，那\n这个 cgroup 拿到的资源量就能达到配置值（有保障）。这里的保障可以是\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003ehard guarantees\u003c/li\u003e\n      \u003cli\u003ebest effort soft boundaries\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eProtection 可以超分，在这种情况下，only upto the amount available to the parent is protected among children.\u003c/li\u003e\n  \u003cli\u003eProtection 值范围是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[0, max]\u003c/code\u003e，默认是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e，也就是没有特别限制。\u003c/li\u003e\n  \u003cli\u003e由于 protections 是可以超分的，因此所有配置组合都是合法的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"34-allocations独占资源量不可超分\"\u003e3.4 Allocations（独占资源量，不可超分）\u003c/h2\u003e\n\n\u003cp\u003e这种模型的一个\u003cstrong\u003e\u003cmark\u003e例子\u003c/mark\u003e\u003c/strong\u003e是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu.rt.max\u003c/code\u003e，它 hard-allocates realtime slices。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这种模型中，cgroup 会\u003cstrong\u003e\u003cmark\u003e排他性地分配\u003c/mark\u003e\u003c/strong\u003e（exclusively allocated）资源量。\u003c/li\u003e\n  \u003cli\u003eAllocation \u003cstrong\u003e\u003cmark\u003e不可超分\u003c/mark\u003e\u003c/strong\u003e，即所有 children 的 allocations 之和不能超过 parent 的可用资源量。\u003c/li\u003e\n  \u003cli\u003eAllocation 值范围是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[0, max]\u003c/code\u003e，默认是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e，也就是不会排他性地分配资源。\u003c/li\u003e\n  \u003cli\u003e由于 allocation 不可超分，因此某些配置可能不合法，会被拒绝；如果强制迁移进程，可能会因配置不合法（资源达到上限）而失败。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"4-接口文件interface-files\"\u003e4 接口文件（Interface Files）\u003c/h1\u003e\n\n\u003ch2 id=\"41-文件格式\"\u003e4.1 文件格式\u003c/h2\u003e\n\n\u003cp\u003e所有接口文件都应该属于以下某种类型：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e换行符分隔的值\u003c/mark\u003e\u003c/strong\u003e（每次 write 操作只允许写入一个值）\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e VAL0\\n\n VAL1\\n\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e空格分隔的值（只读场景，或一次可写入多个值的场景）\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e VAL0 VAL1 ...\\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e扁平 key 类型\u003c/mark\u003e\u003c/strong\u003e （flat keyed，每行一个 key value 对）\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e KEY0 VAL0\\n\n KEY1 VAL1\\n\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e嵌套 key 类型（nested keyed，每行一个 Key value 对，其中 value 中又包含\nsubkey/subvalue）\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e KEY0 SUB_KEY0=VAL00 SUB_KEY1=VAL01...\n KEY1 SUB_KEY0=VAL10 SUB_KEY1=VAL11...\n ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e对于可写文件（writable file），通常来说写的格式应与读的格式保持一致；\n但对于大部分常用场景，控制器可能会允许省略后面的字段（later fields），或实现了受\n限的快捷方式（restricted shortcuts）。\u003c/p\u003e\n\n\u003cp\u003e对于 flat 和 nested key 文件来说，每次只能写一个 key （及对于的 values）。\n对于 nested keyed files，sub key pairs 的顺序可以随意，也不必每次都指定所有\npairs。\u003c/p\u003e\n\n\u003ch2 id=\"42-一些惯例conventions\"\u003e4.2 一些惯例（conventions）\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个特性的配置应该放到单独文件。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eroot cgroup 不受资源控制的限制\u003c/mark\u003e\u003c/strong\u003e，因此不应该有资源控制\u003cstrong\u003e\u003cmark\u003e接口文件\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.*\u003c/code\u003e）。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e默认的时间单位是微秒 \u003ccode\u003eus\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（microseconds）。如果改\n用其他时间单位，必须显式加上一个单位后缀。\u003c/li\u003e\n  \u003cli\u003e表示各部分占比时，应该用十进制百分比表示，且小数点后保留至少两位，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e13.40\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e如果一个控制器实现了 weight 模型，那接口文件应命名为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eweight\u003c/code\u003e，值范围 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1, 10000]\u003c/code\u003e，默认 100。\u003c/li\u003e\n  \u003cli\u003e如果一个控制器实现了绝对 resource guarantee and/or limit，则接口文件应命名为\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emin\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax\u003c/code\u003e。如果实现了 best effort resource guarantee and/or limit，应命名为\n  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elow\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehigh\u003c/code\u003e。对于这四种控制文件，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;max\u0026#34;\u003c/code\u003e 是一个\u003cstrong\u003e\u003cmark\u003e特殊的合法值\u003c/mark\u003e\u003c/strong\u003e（special token），\n  表示\u003cstrong\u003e\u003cmark\u003e读和写无上限\u003c/mark\u003e\u003c/strong\u003e（upward infinity）。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果一个配置项的默认值可配置，且有 keyed specific overrides，那默认 default entry\n的 key 应该是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;default\u0026#34;\u003c/code\u003e，并出现在这个文件的第一行。\u003c/p\u003e\n\n    \u003cp\u003e更新/覆盖默认值：将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefault $VAL\u003c/code\u003e 或 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e$VAL\u003c/code\u003e 写入文件。单纯写入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefault\u003c/code\u003e 恢复默认配置。\u003c/p\u003e\n\n    \u003cp\u003e例如，下面的配置项以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor:minor\u003c/code\u003e 设备号为 key，整数为 value：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c\"\u003e# cat cgroup1.example-interface-file\u003c/span\u003e\n default 150\n 8:0 300\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e可用如下方式\u003cstrong\u003e\u003cmark\u003e更新默认值\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c\"\u003e# 方式一\u003c/span\u003e\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e125 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup-example-interface-file\n \u003cspan class=\"c\"\u003e# 方式二\u003c/span\u003e\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;default 125\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup-example-interface-file\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e用自定义值覆盖默认值：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;8:16 170\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup-example-interface-file\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e清除配置：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;8:0 default\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e cgroup-example-interface-file\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecgroup-example-interface-file\n default 125\n 8:16 170\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e对于不是太频繁的 events，应该创建一个接口文件 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;events\u0026#34;\u003c/code\u003e，读取这个文件能 list\nevent key value pairs。当发生任何 notifiable event 时，这个文件上都应该生成一个 file modified event。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"43-核心接口文件core-interface-files\"\u003e4.3 核心接口文件（core interface files）\u003c/h2\u003e\n\n\u003cp\u003e所有的 cgroup 核心文件都以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecgroup.\u003c/code\u003e 开头。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.type\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写文件，只能\u003cstrong\u003e\u003cmark\u003e位于 non-root cgroup 中\u003c/mark\u003e\u003c/strong\u003e。类型可以是：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e“domain”：正常的 domain cgroup。\u003c/li\u003e\n      \u003cli\u003e“domain threaded”：threaded domain cgroup，作为 threaded subtree 的 root。\u003c/li\u003e\n      \u003cli\u003e“domain invalid”：该 cgroup 当前处于 invalid 状态。这种状态下无法被 populate，或者启用控制器。可能能变成一个 threaded cgroup。\u003c/li\u003e\n      \u003cli\u003e“threaded” : 表示当前 cgroup 是某个 threaded subtree 的一个  member。\u003c/li\u003e\n    \u003c/ol\u003e\n\n    \u003cp\u003e可以将一个 cgroup 设置成 threaded group，只需将字符串 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;threaded\u0026#34;\u003c/code\u003e 写入这个文件。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.procs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写文件，每行一个 PID，可用于所有 cgroups。\u003c/p\u003e\n\n    \u003cp\u003e读时，返回这个 cgroup 内的所有进程 ID，每行一个。PID 列表没有排序，同一个\n PID 可能会出现多次 —— 如果该进程先移除再移入该 cgroup，或 PID 循环利用了，\n 都可以回出现这种情况。\u003c/p\u003e\n\n    \u003cp\u003e要将一个进程移动到该 cgroup，只需将 PID 写入这个文件。写入时必须满足：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e必须有对改 cgroup 的 cgroup.procs 文件写权限。\u003c/li\u003e\n      \u003cli\u003e必须对 source and destination cgroups 的\u003cstrong\u003e\u003cmark\u003e共同祖先\u003c/mark\u003e\u003c/strong\u003e的 cgroup.procs 文件有写权限。\u003c/li\u003e\n    \u003c/ol\u003e\n\n    \u003cp\u003eWhen delegating a sub-hierarchy, write access to this file\n should be granted along with the containing directory.\u003c/p\u003e\n\n    \u003cp\u003eIn a threaded cgroup, reading this file fails with EOPNOTSUPP\n as all the processes belong to the thread root.  Writing is\n supported and moves every thread of the process to the cgroup.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.threads\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-write new-line separated values file which exists on\n all cgroups.\u003c/p\u003e\n\n    \u003cp\u003eWhen read, it lists the TIDs of all threads which belong to\n the cgroup one-per-line.  The TIDs are not ordered and the\n same TID may show up more than once if the thread got moved to\n another cgroup and then back or the TID got recycled while\n reading.\u003c/p\u003e\n\n    \u003cp\u003eA TID can be written to migrate the thread associated with the\n TID to the cgroup.  The writer should match all of the\n following conditions.\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eIt must have write access to the “cgroup.threads” file.\u003c/li\u003e\n      \u003cli\u003eThe cgroup that the thread is currently in must be in the same resource domain as the destination cgroup.\u003c/li\u003e\n      \u003cli\u003eIt must have write access to the “cgroup.procs” file of the common ancestor of the source and destination cgroups.\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003eWhen delegating a sub-hierarchy, write access to this file\n should be granted along with the containing directory.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.controllers\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e只读\u003c/mark\u003e\u003c/strong\u003e（read-only）文件，内容是空格隔开的值，可用于所有 cgroups。\u003c/p\u003e\n\n    \u003cp\u003e读取这个文件，得到的是该 cgroup 的所有可用控制器，空格隔开。控制器列表未排序。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.subtree_control\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写，空格隔开的值，可用于所有控制器，初始时是空的。\u003c/p\u003e\n\n    \u003cp\u003e读取时，返回这个 cgroup 已经启用的控制器，对其 children 做资源控制。\u003c/p\u003e\n\n    \u003cp\u003e可通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e+\u0026lt;controller\u0026gt;\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-\u0026lt;controller\u0026gt;\u003c/code\u003e 来启用或禁用控制器。如果一个控制器在文件中出现多次，最后一次有效。\n 如果一次操作中指定了启用或禁用多个动作，那要么全部成功，要么全部失败。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.events\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e只读，flat-keyed file，只可用于 non-root cgroups。\u003c/p\u003e\n\n    \u003cp\u003e定义了下面两个配置项：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003epopulated：1 if the cgroup or its descendants contains any live processes; otherwise, 0.\u003c/li\u003e\n      \u003cli\u003efrozen：1 if the cgroup is frozen; otherwise, 0.\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e除非有特别设置，否则修改本文件会触发一次 file modified event.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.max.descendants\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写 single value files，默认值 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;max\u0026#34;\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e允许的最大 descent cgroups 数量。如果实际的 descendants 数量等于或大于该值，在 hierarchy 中再创建新 cgroup 时会失败。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.max.depth\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写 single value files，默认值 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026#34;max\u0026#34;\u003c/code\u003e。\u003c/p\u003e\n\n    \u003cp\u003e当前 cgroup 内允许的最大 descent depth。如果实际的 depth 数量等于或大于该值，再创建新 child cgroup 时会失败。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.stat\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e只读 flat-keyed file，定义了下列 entries:\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003cp\u003enr_descendants：可见的 descendant cgroups 总数。\u003c/p\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003cp\u003enr_dying_descendants\u003c/p\u003e\n\n        \u003cp\u003eTotal number of dying descendant cgroups. A cgroup becomes\n  dying after being deleted by a user. The cgroup will remain\n  in dying state for some time undefined time (which can depend\n  on system load) before being completely destroyed.\u003c/p\u003e\n\n        \u003cp\u003eA process can’t enter a dying cgroup under any circumstances,\n  a dying cgroup can’t revive.\u003c/p\u003e\n\n        \u003cp\u003eA dying cgroup can consume system resources not exceeding\n  limits, which were active at the moment of cgroup deletion.\u003c/p\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecgroup.freeze\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写 single value file，只能用于 non-root cgroups。\n Allowed values are “0” and “1”. The default is “0”.\u003c/p\u003e\n\n    \u003cp\u003eWriting “1” to the file causes freezing of the cgroup and all\n descendant cgroups. This means that all belonging processes will\n be stopped and will not run until the cgroup will be explicitly\n unfrozen. Freezing of the cgroup may take some time; when this action\n is completed, the “frozen” value in the cgroup.events control file\n will be updated to “1” and the corresponding notification will be\n issued.\u003c/p\u003e\n\n    \u003cp\u003eA cgroup can be frozen either by its own settings, or by settings\n of any ancestor cgroups. If any of ancestor cgroups is frozen, the\n cgroup will remain frozen.\u003c/p\u003e\n\n    \u003cp\u003eProcesses in the frozen cgroup can be killed by a fatal signal.\n They also can enter and leave a frozen cgroup: either by an explicit\n move by a user, or if freezing of the cgroup races with fork().\n If a process is moved to a frozen cgroup, it stops. If a process is\n moved out of a frozen cgroup, it becomes running.\u003c/p\u003e\n\n    \u003cp\u003eFrozen status of a cgroup doesn’t affect any cgroup tree operations:\n it’s possible to delete a frozen (and empty) cgroup, as well as\n create new sub-cgroups.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"5-controllers控制器\"\u003e5 Controllers（控制器）\u003c/h1\u003e\n\n\u003ch2 id=\"51-cpu\"\u003e5.1 CPU\u003c/h2\u003e\n\n\u003cp\u003eThe “cpu” controllers 控制着 CPU cycle 的分配。这个控制器实现了\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e常规调度\u003c/mark\u003e\u003c/strong\u003e策略：weight and absolute bandwidth limit 模型\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e实时调度\u003c/mark\u003e\u003c/strong\u003e策略：absolute bandwidth allocation 模型\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在所有以上模型中，cycles distribution 只定义在 temporal base 上，it does not account for the frequency at which tasks are executed.\nThe (optional) utilization clamping support allows to hint the schedutil\ncpufreq governor about the minimum desired frequency which should always be\nprovided by a CPU, as well as the maximum desired frequency, which should not\nbe exceeded by a CPU.\u003c/p\u003e\n\n\u003cp\u003e警告：cgroupv2 还\u003cstrong\u003e\u003cmark\u003e不支持对实时进程的控制\u003c/mark\u003e\u003c/strong\u003e，并且只有当所有实时进程\u003cstrong\u003e\u003cmark\u003e都位于 root cgroup 时\u003c/mark\u003e\u003c/strong\u003e，\ncpu 控制器才能启用。需要注意：一些系统管理软件可能已经在系统启动期间，将实时进程放到了 non-root cgroup 中，\n因此在启用 CPU 控制器之前，需要将这些进程移动到 root cgroup。\u003c/p\u003e\n\n\u003ch3 id=\"cpu-interface-files\"\u003eCPU Interface Files\u003c/h3\u003e\n\n\u003cp\u003e所有时间单位都是 microseconds。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.stat\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e只读文件。不管 CPU controller 有没有启用，这个文件都存在。\n 暴露下面三个字段：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eusage_usec\u003c/li\u003e\n      \u003cli\u003euser_usec\u003c/li\u003e\n      \u003cli\u003esystem_usec\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e如果启用了控制器，还会额外暴露三个字段：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003enr_periods\u003c/li\u003e\n      \u003cli\u003enr_throttled\u003c/li\u003e\n      \u003cli\u003ethrottled_usec\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.weight\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写文件，which exists on non-root cgroups.\n 默认值 “100”，合法范围 [1, 10000]。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.weight.nice\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写文件，which exists on non-root\n cgroups. 默认值 “0”，合法范围 [-20, 19].\u003c/p\u003e\n\n    \u003cp\u003eThis interface file is an alternative interface for\n “cpu.weight” and allows reading and setting weight using the\n same values used by nice(2).  Because the range is smaller and\n granularity is coarser for the nice values, the read value is\n the closest approximation of the current weight.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.max\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-write two value file which exists on non-root cgroups.\n The default is “max 100000”.\u003c/p\u003e\n\n    \u003cp\u003eThe maximum bandwidth limit.  It’s in the following format::\u003c/p\u003e\n\n    \u003cp\u003e$MAX $PERIOD\u003c/p\u003e\n\n    \u003cp\u003ewhich indicates that the group may consume upto $MAX in each\n $PERIOD duration.  “max” for $MAX indicates no limit.  If only\n one number is written, $MAX is updated.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.pressure\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-only nested-key file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eShows pressure stall information for CPU. See\n \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDocumentation/accounting/psi.rst \u0026lt;psi\u0026gt;\u003c/code\u003e for details.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.uclamp.min\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.\n The default is “0”, i.e. no utilization boosting.\u003c/p\u003e\n\n    \u003cp\u003eThe requested minimum utilization (protection) as a percentage\n rational number, e.g. 12.34 for 12.34%.\u003c/p\u003e\n\n    \u003cp\u003eThis interface allows reading and setting minimum utilization clamp\n values similar to the sched_setattr(2). This minimum utilization\n value is used to clamp the task specific minimum utilization clamp.\u003c/p\u003e\n\n    \u003cp\u003eThe requested minimum utilization (protection) is always capped by\n the current value for the maximum utilization (limit), i.e.\n \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu.uclamp.max\u003c/code\u003e.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpu.uclamp.max\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.\n  The default is “max”. i.e. no utilization capping\u003c/p\u003e\n\n    \u003cp\u003eThe requested maximum utilization (limit) as a percentage rational\n  number, e.g. 98.76 for 98.76%.\u003c/p\u003e\n\n    \u003cp\u003eThis interface allows reading and setting maximum utilization clamp\n  values similar to the sched_setattr(2). This maximum utilization\n  value is used to clamp the task specific maximum utilization clamp.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"52-memory\"\u003e5.2 Memory\u003c/h2\u003e\n\n\u003cp\u003eThe “memory” controller regulates distribution of memory. \n内存是\u003cstrong\u003e\u003cmark\u003e有状态的\u003c/mark\u003e\u003c/strong\u003e，实现了 limit 和 protection 两种模型。\nDue to the intertwining between memory usage and reclaim pressure and the\nstateful nature of memory, the distribution model is relatively\ncomplex.\u003c/p\u003e\n\n\u003cp\u003eWhile not completely water-tight, 给定 cgroup 的所有主要 memory usages\n都会跟踪，因此总内存占用可以控制在一个合理的范围内。目前\u003cstrong\u003e\u003cmark\u003e下列类型的内存\u003c/mark\u003e\u003c/strong\u003e使用会被跟踪：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eUserland memory\u003c/mark\u003e\u003c/strong\u003e - page cache and anonymous memory.\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eKernel data structures\u003c/mark\u003e\u003c/strong\u003e such as dentries and inodes.\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eTCP socket buffers\u003c/mark\u003e\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe above list may expand in the future for better coverage.\u003c/p\u003e\n\n\u003ch3 id=\"memory-interface-files\"\u003eMemory Interface Files\u003c/h3\u003e\n\n\u003cp\u003eAll memory amounts are in bytes.  If a value which is not aligned to\nPAGE_SIZE is written, the value may be rounded up to the closest\nPAGE_SIZE multiple when read back.\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.current\u003c/p\u003e\n\n    \u003cp\u003eA read-only single value file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eThe total amount of memory currently being used by the cgroup and its descendants.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.min\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “0”.\u003c/p\u003e\n\n    \u003cp\u003eHard memory protection.  If the memory usage of a cgroup\n is within its effective min boundary, the cgroup’s memory\n won’t be reclaimed under any conditions. If there is no\n unprotected reclaimable memory available, OOM killer\n is invoked. Above the effective min boundary (or\n effective low boundary if it is higher), pages are reclaimed\n proportionally to the overage, reducing reclaim pressure for\n smaller overages.\u003c/p\u003e\n\n    \u003cp\u003eEffective min boundary is limited by memory.min values of\n all ancestor cgroups. If there is memory.min overcommitment\n (child cgroup or cgroups are requiring more protected memory\n than parent will allow), then each child cgroup will get\n the part of parent’s protection proportional to its\n actual memory usage below memory.min.\u003c/p\u003e\n\n    \u003cp\u003ePutting more memory than generally available under this\n protection is discouraged and may lead to constant OOMs.\u003c/p\u003e\n\n    \u003cp\u003eIf a memory cgroup is not populated with processes, its memory.min is ignored.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.low\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “0”.\u003c/p\u003e\n\n    \u003cp\u003eBest-effort memory protection.  If the memory usage of a\n cgroup is within its effective low boundary, the cgroup’s\n memory won’t be reclaimed unless there is no reclaimable\n memory available in unprotected cgroups.\n Above the effective low    boundary (or\n effective min boundary if it is higher), pages are reclaimed\n proportionally to the overage, reducing reclaim pressure for\n smaller overages.\u003c/p\u003e\n\n    \u003cp\u003eEffective low boundary is limited by memory.low values of\n all ancestor cgroups. If there is memory.low overcommitment\n (child cgroup or cgroups are requiring more protected memory\n than parent will allow), then each child cgroup will get\n the part of parent’s protection proportional to its\n actual memory usage below memory.low.\u003c/p\u003e\n\n    \u003cp\u003ePutting more memory than generally available under this protection is discouraged.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.high\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “max”.\u003c/p\u003e\n\n    \u003cp\u003eMemory usage throttle limit.  This is the main mechanism to\n control memory usage of a cgroup.  If a cgroup’s usage goes\n over the high boundary, the processes of the cgroup are\n throttled and put under heavy reclaim pressure.\u003c/p\u003e\n\n    \u003cp\u003eGoing over the high limit never invokes the OOM killer and\n under extreme conditions the limit may be breached.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.max\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “max”.\u003c/p\u003e\n\n    \u003cp\u003eMemory usage hard limit.  This is the final protection\n mechanism.  If a cgroup’s memory usage reaches this limit and\n can’t be reduced, the OOM killer is invoked in the cgroup.\n Under certain circumstances, the usage may go over the limit\n temporarily.\u003c/p\u003e\n\n    \u003cp\u003eIn default configuration regular 0-order allocations always\n succeed unless OOM killer chooses current task as a victim.\u003c/p\u003e\n\n    \u003cp\u003eSome kinds of allocations don’t invoke the OOM killer.\n Caller could retry them differently, return into userspace\n as -ENOMEM or silently ignore in cases like disk readahead.\u003c/p\u003e\n\n    \u003cp\u003eThis is the ultimate protection mechanism.  As long as the\n high limit is used and monitored properly, this limit’s\n utility is limited to providing the final safety net.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.oom.group\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default value is “0”.\u003c/p\u003e\n\n    \u003cp\u003eDetermines whether the cgroup should be treated as\n an indivisible workload by the OOM killer. If set,\n all tasks belonging to the cgroup or to its descendants\n (if the memory cgroup is not a leaf cgroup) are killed\n together or not at all. This can be used to avoid\n partial kills to guarantee workload integrity.\u003c/p\u003e\n\n    \u003cp\u003eTasks with the OOM protection (oom_score_adj set to -1000)\n are treated as an exception and are never killed.\u003c/p\u003e\n\n    \u003cp\u003eIf the OOM killer is invoked in a cgroup, it’s not going\n to kill any tasks outside of this cgroup, regardless\n memory.oom.group values of ancestor cgroups.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.events\u003c/p\u003e\n\n    \u003cp\u003eA read-only flat-keyed file which exists on non-root cgroups.\n The following entries are defined.  Unless specified\n otherwise, a value change in this file generates a file\n modified event.\u003c/p\u003e\n\n    \u003cp\u003eNote that all fields in this file are hierarchical and the\n file modified event can be generated due to an event down the\n hierarchy. For for the local events at the cgroup level see\n memory.events.local.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   low\n     The number of times the cgroup is reclaimed due to\n     high memory pressure even though its usage is under\n     the low boundary.  This usually indicates that the low\n     boundary is over-committed.\n\n   high\n     The number of times processes of the cgroup are\n     throttled and routed to perform direct memory reclaim\n     because the high memory boundary was exceeded.  For a\n     cgroup whose memory usage is capped by the high limit\n     rather than global memory pressure, this event\u0026#39;s\n     occurrences are expected.\n\n   max\n     The number of times the cgroup\u0026#39;s memory usage was\n     about to go over the max boundary.  If direct reclaim\n     fails to bring it down, the cgroup goes to OOM state.\n\n   oom\n     The number of time the cgroup\u0026#39;s memory usage was\n     reached the limit and allocation was about to fail.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eThis event is not raised if the OOM killer is not considered as an\noption, e.g. for failed high-order allocations or if caller asked to not\nretry attempts.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   oom_kill\n     The number of processes belonging to this cgroup\n     killed by any kind of OOM killer.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.events.local\u003c/p\u003e\n\n    \u003cp\u003eSimilar to memory.events but the fields in the file are local\n to the cgroup i.e. not hierarchical. The file modified event\n generated on this file reflects only the local events.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.stat\u003c/p\u003e\n\n    \u003cp\u003eA read-only flat-keyed file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eThis breaks down the cgroup’s memory footprint into different\n types of memory, type-specific details, and other information\n on the state and past events of the memory management system.\u003c/p\u003e\n\n    \u003cp\u003eAll memory amounts are in bytes.\u003c/p\u003e\n\n    \u003cp\u003eThe entries are ordered to be human readable, and new entries\n can show up in the middle. Don’t rely on items remaining in a\n fixed position; use the keys to look up specific values!\u003c/p\u003e\n\n    \u003cp\u003eIf the entry has no per-node counter(or not show in the\n mempry.numa_stat). We use ‘npn’(non-per-node) as the tag\n to indicate that it will not show in the mempry.numa_stat.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   anon\n     Amount of memory used in anonymous mappings such as\n     brk(), sbrk(), and mmap(MAP_ANONYMOUS)\n\n   file\n     Amount of memory used to cache filesystem data,\n     including tmpfs and shared memory.\n\n   kernel_stack\n     Amount of memory allocated to kernel stacks.\n\n   percpu(npn)\n     Amount of memory used for storing per-cpu kernel\n     data structures.\n\n   sock(npn)\n     Amount of memory used in network transmission buffers\n\n   shmem\n     Amount of cached filesystem data that is swap-backed,\n     such as tmpfs, shm segments, shared anonymous mmap()s\n\n   file_mapped\n     Amount of cached filesystem data mapped with mmap()\n\n   file_dirty\n     Amount of cached filesystem data that was modified but\n     not yet written back to disk\n\n   file_writeback\n     Amount of cached filesystem data that was modified and\n     is currently being written back to disk\n\n   anon_thp\n     Amount of memory used in anonymous mappings backed by\n     transparent hugepages\n\n   inactive_anon, active_anon, inactive_file, active_file, unevictable\n     Amount of memory, swap-backed and filesystem-backed,\n     on the internal memory management lists used by the\n     page reclaim algorithm.\n\n     As these represent internal list state (eg. shmem pages are on anon\n     memory management lists), inactive_foo + active_foo may not be equal to\n     the value for the foo counter, since the foo counter is type-based, not\n     list-based.\n\n   slab_reclaimable\n     Part of \u0026#34;slab\u0026#34; that might be reclaimed, such as\n     dentries and inodes.\n\n   slab_unreclaimable\n     Part of \u0026#34;slab\u0026#34; that cannot be reclaimed on memory\n     pressure.\n\n   slab(npn)\n     Amount of memory used for storing in-kernel data\n     structures.\n\n   workingset_refault_anon\n     Number of refaults of previously evicted anonymous pages.\n\n   workingset_refault_file\n     Number of refaults of previously evicted file pages.\n\n   workingset_activate_anon\n     Number of refaulted anonymous pages that were immediately\n     activated.\n\n   workingset_activate_file\n     Number of refaulted file pages that were immediately activated.\n\n   workingset_restore_anon\n     Number of restored anonymous pages which have been detected as\n     an active workingset before they got reclaimed.\n\n   workingset_restore_file\n     Number of restored file pages which have been detected as an\n     active workingset before they got reclaimed.\n\n   workingset_nodereclaim\n     Number of times a shadow node has been reclaimed\n\n   pgfault(npn)\n     Total number of page faults incurred\n\n   pgmajfault(npn)\n     Number of major page faults incurred\n\n   pgrefill(npn)\n     Amount of scanned pages (in an active LRU list)\n\n   pgscan(npn)\n     Amount of scanned pages (in an inactive LRU list)\n\n   pgsteal(npn)\n     Amount of reclaimed pages\n\n   pgactivate(npn)\n     Amount of pages moved to the active LRU list\n\n   pgdeactivate(npn)\n     Amount of pages moved to the inactive LRU list\n\n   pglazyfree(npn)\n     Amount of pages postponed to be freed under memory pressure\n\n   pglazyfreed(npn)\n     Amount of reclaimed lazyfree pages\n\n   thp_fault_alloc(npn)\n     Number of transparent hugepages which were allocated to satisfy\n     a page fault. This counter is not present when CONFIG_TRANSPARENT_HUGEPAGE\n             is not set.\n\n   thp_collapse_alloc(npn)\n     Number of transparent hugepages which were allocated to allow\n     collapsing an existing range of pages. This counter is not\n     present when CONFIG_TRANSPARENT_HUGEPAGE is not set.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.numa_stat\u003c/p\u003e\n\n    \u003cp\u003eA read-only nested-keyed file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eThis breaks down the cgroup’s memory footprint into different\n types of memory, type-specific details, and other information\n per node on the state of the memory management system.\u003c/p\u003e\n\n    \u003cp\u003eThis is useful for providing visibility into the NUMA locality\n information within an memcg since the pages are allowed to be\n allocated from any physical node. One of the use case is evaluating\n application performance by combining this information with the\n application’s CPU allocation.\u003c/p\u003e\n\n    \u003cp\u003eAll memory amounts are in bytes.\u003c/p\u003e\n\n    \u003cp\u003eThe output format of memory.numa_stat is::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   type N0=\u0026lt;bytes in node 0\u0026gt; N1=\u0026lt;bytes in node 1\u0026gt; ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eThe entries are ordered to be human readable, and new entries\n can show up in the middle. Don’t rely on items remaining in a\n fixed position; use the keys to look up specific values!\u003c/p\u003e\n\n    \u003cp\u003eThe entries can refer to the memory.stat.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.swap.current\u003c/p\u003e\n\n    \u003cp\u003eA read-only single value file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eThe total amount of swap currently being used by the cgroup and its descendants.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.swap.high\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “max”.\u003c/p\u003e\n\n    \u003cp\u003eSwap usage throttle limit.  If a cgroup’s swap usage exceeds\n this limit, all its further allocations will be throttled to\n allow userspace to implement custom out-of-memory procedures.\u003c/p\u003e\n\n    \u003cp\u003eThis limit marks a point of no return for the cgroup. It is NOT\n designed to manage the amount of swapping a workload does\n during regular operation. Compare to memory.swap.max, which\n prohibits swapping past a set amount, but lets the cgroup\n continue unimpeded as long as other memory can be reclaimed.\u003c/p\u003e\n\n    \u003cp\u003eHealthy workloads are not expected to reach this limit.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.swap.max\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root cgroups.  The default is “max”.\u003c/p\u003e\n\n    \u003cp\u003eSwap usage hard limit.  If a cgroup’s swap usage reaches this\n limit, anonymous memory of the cgroup will not be swapped out.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.swap.events\u003c/p\u003e\n\n    \u003cp\u003eA read-only flat-keyed file which exists on non-root cgroups.\n The following entries are defined.  Unless specified\n otherwise, a value change in this file generates a file\n modified event.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   high\n     The number of times the cgroup\u0026#39;s swap usage was over\n     the high threshold.\n\n   max\n     The number of times the cgroup\u0026#39;s swap usage was about\n     to go over the max boundary and swap allocation\n     failed.\n\n   fail\n     The number of times swap allocation failed either\n     because of running out of swap system-wide or max\n     limit.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eWhen reduced under the current usage, the existing swap\n entries are reclaimed gradually and the swap usage may stay\n higher than the limit for an extended period of time.  This\n reduces the impact on the workload and memory management.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ememory.pressure\u003c/p\u003e\n\n    \u003cp\u003eA read-only nested-key file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eShows pressure stall information for memory. See\n :ref:\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDocumentation/accounting/psi.rst \u0026lt;psi\u0026gt;\u003c/code\u003e for details.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"使用建议\"\u003e使用建议\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ememory.high\u003c/code\u003e 是\u003cstrong\u003e\u003cmark\u003e控制内存使用量的主要机制\u003c/mark\u003e\u003c/strong\u003e。重要策略：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ehigh limit 超分（high limits 总和大于可用内存）\u003c/li\u003e\n  \u003cli\u003e让全局内存压力（global memory pressure）根据使用量分配内存\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e由于超过 high limit 之后\u003cstrong\u003e\u003cmark\u003e只会 throttle 该 cgroup 而不会触发 OOM killer\u003c/mark\u003e\u003c/strong\u003e，\n因此 management agent 有足够的机会来监控这种情况及采取合适措施，\n例如增加内存配额，或者干掉该 workload。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e判断一个 cgroup 内存是否够\u003c/mark\u003e\u003c/strong\u003e并不是一件简单的事情，因为内存使用量\n并不能反映出增加内存之后，workload 性能是否能有改善。例如，从网络接收数据然后写\n入本地文件的 workload，能充分利用所有可用内存；但另一方面，即使只给它很小一部分\n内存，这种 workload 的性能也同样是高效的。\n\u003cstrong\u003e\u003cmark\u003e内存压力（memory pressure）的测量\u003c/mark\u003e\u003c/strong\u003e —— 即由于内存不足导致\nworkload 受了多少影响 —— 对判断一个 workload 是否需要更多内存来说至关重要；但不\n幸的是，\u003cstrong\u003e\u003cmark\u003e内核还未实现内存压力监控机制\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"memory-ownership\"\u003eMemory Ownership\u003c/h3\u003e\n\n\u003cp\u003eA memory area is charged to the cgroup which instantiated it and stays\ncharged to the cgroup until the area is released.  Migrating a process\nto a different cgroup doesn’t move the memory usages that it\ninstantiated while in the previous cgroup to the new cgroup.\u003c/p\u003e\n\n\u003cp\u003eA memory area may be used by processes belonging to different cgroups.\nTo which cgroup the area will be charged is in-deterministic; however,\nover time, the memory area is likely to end up in a cgroup which has\nenough memory allowance to avoid high reclaim pressure.\u003c/p\u003e\n\n\u003cp\u003eIf a cgroup sweeps a considerable amount of memory which is expected\nto be accessed repeatedly by other cgroups, it may make sense to use\nPOSIX_FADV_DONTNEED to relinquish the ownership of memory areas\nbelonging to the affected files to ensure correct memory ownership.\u003c/p\u003e\n\n\u003ch2 id=\"53-io\"\u003e5.3 IO\u003c/h2\u003e\n\n\u003cp\u003eThe “io” controller regulates the distribution of IO resources.  This\ncontroller implements both weight based and absolute bandwidth or IOPS\nlimit distribution; however, weight based distribution is available\nonly if cfq-iosched is in use and neither scheme is available for\nblk-mq devices.\u003c/p\u003e\n\n\u003ch3 id=\"io-interface-files\"\u003eIO Interface Files\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.stat\n A read-only nested-keyed file.\u003c/p\u003e\n\n    \u003cp\u003eLines are keyed by $MAJ:$MIN device numbers and not ordered.\n The following nested keys are defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   ======    =====================\n   rbytes    Bytes read\n   wbytes    Bytes written\n   rios        Number of read IOs\n   wios        Number of write IOs\n   dbytes    Bytes discarded\n   dios        Number of discard IOs\n   ======    =====================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eAn example read output follows::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   8:16 rbytes=1459200 wbytes=314773504 rios=192 wios=353 dbytes=0 dios=0\n   8:0 rbytes=90430464 wbytes=299008000 rios=8950 wios=1252 dbytes=50331648 dios=3021\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.cost.qos\u003c/p\u003e\n\n    \u003cp\u003eA read-write nested-keyed file with exists only on the root\n cgroup.\u003c/p\u003e\n\n    \u003cp\u003eThis file configures the Quality of Service of the IO cost\n model based controller (CONFIG_BLK_CGROUP_IOCOST) which\n currently implements “io.weight” proportional control.  Lines\n are keyed by $MAJ:$MIN device numbers and not ordered.  The\n line for a given device is populated on the first write for\n the device on “io.cost.qos” or “io.cost.model”.  The following\n nested keys are defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e ======    =====================================\n enable    Weight-based control enable\n ctrl      \u0026#34;auto\u0026#34; or \u0026#34;user\u0026#34;\n rpct      Read latency percentile    [0, 100]\n rlat      Read latency threshold\n wpct      Write latency percentile   [0, 100]\n wlat      Write latency threshold\n min       Minimum scaling percentage [1, 10000]\n max       Maximum scaling percentage [1, 10000]\n ======    =====================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eThe controller is disabled by default and can be enabled by\n setting “enable” to 1.  “rpct” and “wpct” parameters default\n to zero and the controller uses internal device saturation\n state to adjust the overall IO rate between “min” and “max”.\u003c/p\u003e\n\n    \u003cp\u003eWhen a better control quality is needed, latency QoS parameters can be configured.  For example::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   8:16 enable=1 ctrl=auto rpct=95.00 rlat=75000 wpct=95.00 wlat=150000 min=50.00 max=150.0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eshows that on sdb, the controller is enabled, will consider\n the device saturated if the 95th percentile of read completion\n latencies is above 75ms or write 150ms, and adjust the overall\n IO issue rate between 50% and 150% accordingly.\u003c/p\u003e\n\n    \u003cp\u003eThe lower the saturation point, the better the latency QoS at\n the cost of aggregate bandwidth.  The narrower the allowed\n adjustment range between “min” and “max”, the more conformant\n to the cost model the IO behavior.  Note that the IO issue\n base rate may be far off from 100% and setting “min” and “max”\n blindly can lead to a significant loss of device capacity or\n control quality.  “min” and “max” are useful for regulating\n devices which show wide temporary behavior changes - e.g. a\n ssd which accepts writes at the line speed for a while and\n then completely stalls for multiple seconds.\u003c/p\u003e\n\n    \u003cp\u003eWhen “ctrl” is “auto”, the parameters are controlled by the\n kernel and may change automatically.  Setting “ctrl” to “user”\n or setting any of the percentile and latency parameters puts\n it into “user” mode and disables the automatic changes.  The\n automatic mode can be restored by setting “ctrl” to “auto”.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.cost.model\u003c/p\u003e\n\n    \u003cp\u003eA read-write nested-keyed file with exists only on the root\n cgroup.\u003c/p\u003e\n\n    \u003cp\u003eThis file configures the cost model of the IO cost model based\n controller (CONFIG_BLK_CGROUP_IOCOST) which currently\n implements “io.weight” proportional control.  Lines are keyed\n by $MAJ:$MIN device numbers and not ordered.  The line for a\n given device is populated on the first write for the device on\n “io.cost.qos” or “io.cost.model”.  The following nested keys\n are defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   =====        ================================\n   ctrl        \u0026#34;auto\u0026#34; or \u0026#34;user\u0026#34;\n   model        The cost model in use - \u0026#34;linear\u0026#34;\n   =====        ================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eWhen “ctrl” is “auto”, the kernel may change all parameters\n dynamically.  When “ctrl” is set to “user” or any other\n parameters are written to, “ctrl” become “user” and the\n automatic changes are disabled.\u003c/p\u003e\n\n    \u003cp\u003eWhen “model” is “linear”, the following model parameters are\n defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   =============    ========================================\n   [r|w]bps    The maximum sequential IO throughput\n   [r|w]seqiops    The maximum 4k sequential IOs per second\n   [r|w]randiops    The maximum 4k random IOs per second\n   =============    ========================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eFrom the above, the builtin linear model determines the base\n costs of a sequential and random IO and the cost coefficient\n for the IO size.  While simple, this model can cover most\n common device classes acceptably.\u003c/p\u003e\n\n    \u003cp\u003eThe IO cost model isn’t expected to be accurate in absolute\n sense and is scaled to the device behavior dynamically.\u003c/p\u003e\n\n    \u003cp\u003eIf needed, tools/cgroup/iocost_coef_gen.py can be used to\n generate device-specific coefficients.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.weight\u003c/p\u003e\n\n    \u003cp\u003eA read-write flat-keyed file which exists on non-root cgroups.\n The default is “default 100”.\u003c/p\u003e\n\n    \u003cp\u003eThe first line is the default weight applied to devices\n without specific override.  The rest are overrides keyed by\n $MAJ:$MIN device numbers and not ordered.  The weights are in\n the range [1, 10000] and specifies the relative amount IO time\n the cgroup can use in relation to its siblings.\u003c/p\u003e\n\n    \u003cp\u003eThe default weight can be updated by writing either “default\n $WEIGHT” or simply “$WEIGHT”.  Overrides can be set by writing\n “$MAJ:$MIN $WEIGHT” and unset by writing “$MAJ:$MIN default”.\u003c/p\u003e\n\n    \u003cp\u003eAn example read output follows::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   default 100\n   8:16 200\n   8:0 50\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.max\n A read-write nested-keyed file which exists on non-root\n cgroups.\u003c/p\u003e\n\n    \u003cp\u003eBPS and IOPS based IO limit.  Lines are keyed by $MAJ:$MIN\n device numbers and not ordered.  The following nested keys are\n defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   =====        ==================================\n   rbps        Max read bytes per second\n   wbps        Max write bytes per second\n   riops        Max read IO operations per second\n   wiops        Max write IO operations per second\n   =====        ==================================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eWhen writing, any number of nested key-value pairs can be\n specified in any order.  “max” can be specified as the value\n to remove a specific limit.  If the same key is specified\n multiple times, the outcome is undefined.\u003c/p\u003e\n\n    \u003cp\u003eBPS and IOPS are measured in each IO direction and IOs are\n delayed if limit is reached.  Temporary bursts are allowed.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e Setting read limit at 2M BPS and write at 120 IOPS for 8:16::\n\n   echo \u0026#34;8:16 rbps=2097152 wiops=120\u0026#34; \u0026gt; io.max\n\n Reading returns the following::\n\n   8:16 rbps=2097152 wbps=max riops=max wiops=120\n\n Write IOPS limit can be removed by writing the following::\n\n   echo \u0026#34;8:16 wiops=max\u0026#34; \u0026gt; io.max\n\n Reading now returns the following::\n\n   8:16 rbps=2097152 wbps=max riops=max wiops=max\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.pressure\n A read-only nested-key file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cp\u003eShows pressure stall information for IO. See\n :ref:\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDocumentation/accounting/psi.rst \u0026lt;psi\u0026gt;\u003c/code\u003e for details.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"writeback\"\u003eWriteback\u003c/h3\u003e\n\n\u003cp\u003ePage cache is dirtied through buffered writes and shared mmaps and\nwritten asynchronously to the backing filesystem by the writeback\nmechanism.  Writeback sits between the memory and IO domains and\nregulates the proportion of dirty memory by balancing dirtying and\nwrite IOs.\u003c/p\u003e\n\n\u003cp\u003eThe io controller, in conjunction with the memory controller,\nimplements control of page cache writeback IOs.  The memory controller\ndefines the memory domain that dirty memory ratio is calculated and\nmaintained for and the io controller defines the io domain which\nwrites out dirty pages for the memory domain.  Both system-wide and\nper-cgroup dirty memory states are examined and the more restrictive\nof the two is enforced.\u003c/p\u003e\n\n\u003cp\u003ecgroup writeback requires explicit support from the underlying\nfilesystem.  Currently, cgroup writeback is implemented on ext2, ext4,\nbtrfs, f2fs, and xfs.  On other filesystems, all writeback IOs are\nattributed to the root cgroup.\u003c/p\u003e\n\n\u003cp\u003eThere are inherent differences in memory and writeback management\nwhich affects how cgroup ownership is tracked.  Memory is tracked per\npage while writeback per inode.  For the purpose of writeback, an\ninode is assigned to a cgroup and all IO requests to write dirty pages\nfrom the inode are attributed to that cgroup.\u003c/p\u003e\n\n\u003cp\u003eAs cgroup ownership for memory is tracked per page, there can be pages\nwhich are associated with different cgroups than the one the inode is\nassociated with.  These are called foreign pages.  The writeback\nconstantly keeps track of foreign pages and, if a particular foreign\ncgroup becomes the majority over a certain period of time, switches\nthe ownership of the inode to that cgroup.\u003c/p\u003e\n\n\u003cp\u003eWhile this model is enough for most use cases where a given inode is\nmostly dirtied by a single cgroup even when the main writing cgroup\nchanges over time, use cases where multiple cgroups write to a single\ninode simultaneously are not supported well.  In such circumstances, a\nsignificant portion of IOs are likely to be attributed incorrectly.\nAs memory controller assigns page ownership on the first use and\ndoesn’t update it until the page is released, even if writeback\nstrictly follows page ownership, multiple cgroups dirtying overlapping\nareas wouldn’t work as expected.  It’s recommended to avoid such usage\npatterns.\u003c/p\u003e\n\n\u003cp\u003eThe sysctl knobs which affect writeback behavior are applied to cgroup\nwriteback as follows.\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  vm.dirty_background_ratio, vm.dirty_ratio\n    These ratios apply the same to cgroup writeback with the\n    amount of available memory capped by limits imposed by the\n    memory controller and system-wide clean memory.\n\n  vm.dirty_background_bytes, vm.dirty_bytes\n    For cgroup writeback, this is calculated into ratio against\n    total available memory and applied the same way as\n    vm.dirty[_background]_ratio.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"io-latency\"\u003eIO Latency\u003c/h3\u003e\n\n\u003cp\u003eThis is a cgroup v2 controller for IO workload protection.  You provide a group\nwith a latency target, and if the average latency exceeds that target the\ncontroller will throttle any peers that have a lower latency target than the\nprotected workload.\u003c/p\u003e\n\n\u003cp\u003eThe limits are only applied at the peer level in the hierarchy.  This means that\nin the diagram below, only groups A, B, and C will influence each other, and\ngroups D and F will influence each other.  Group G will influence nobody::\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e            [root]\n      /       |       \\\n      A       B        C\n     /  \\     |\n    D    F    G\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eSo the ideal way to configure this is to set io.latency in groups A, B, and C.\nGenerally you do not want to set a value lower than the latency your device\nsupports.  Experiment to find the value that works best for your workload.\nStart at higher than the expected latency for your device and watch the\navg_lat value in io.stat for your workload group to get an idea of the\nlatency you see during normal operation.  Use the avg_lat value as a basis for\nyour real setting, setting at 10-15% higher than the value in io.stat.\u003c/p\u003e\n\n\u003ch3 id=\"how-io-latency-throttling-works\"\u003eHow IO Latency Throttling Works\u003c/h3\u003e\n\n\u003cp\u003eio.latency is work conserving; so as long as everybody is meeting their latency\ntarget the controller doesn’t do anything.  Once a group starts missing its\ntarget it begins throttling any peer group that has a higher target than itself.\nThis throttling takes 2 forms:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eQueue depth throttling.  This is the number of outstanding IO’s a group is\nallowed to have.  We will clamp down relatively quickly, starting at no limit\nand going all the way down to 1 IO at a time.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eArtificial delay induction.  There are certain types of IO that cannot be\nthrottled without possibly adversely affecting higher priority groups.  This\nincludes swapping and metadata IO.  These types of IO are allowed to occur\nnormally, however they are “charged” to the originating group.  If the\noriginating group is being throttled you will see the use_delay and delay\nfields in io.stat increase.  The delay value is how many microseconds that are\nbeing added to any process that runs in this group.  Because this number can\ngrow quite large if there is a lot of swapping or metadata IO occurring we\nlimit the individual delay events to 1 second at a time.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eOnce the victimized group starts meeting its latency target again it will start\nunthrottling any peer groups that were throttled previously.  If the victimized\ngroup simply stops doing IO the global counter will unthrottle appropriately.\u003c/p\u003e\n\n\u003ch3 id=\"io-latency-interface-files\"\u003eIO Latency Interface Files\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.latency\u003c/p\u003e\n\n    \u003cp\u003eThis takes a similar format as the other controllers.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u0026#34;MAJOR:MINOR target=\u0026lt;target time in microseconds\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eio.stat\u003c/p\u003e\n\n    \u003cp\u003eIf the controller is enabled you will see extra stats in io.stat in addition to the normal ones.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e depth\n   This is the current queue depth for the group.\n\n avg_lat\n   This is an exponential moving average with a decay rate of 1/exp\n   bound by the sampling interval.  The decay rate interval can be\n   calculated by multiplying the win value in io.stat by the\n   corresponding number of samples based on the win value.\n\n win\n   The sampling window size in milliseconds.  This is the minimum\n   duration of time between evaluation events.  Windows only elapse\n   with IO activity.  Idle periods extend the most recent window.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"54-pid\"\u003e5.4 PID\u003c/h2\u003e\n\n\u003cp\u003ePID 控制器用于在\u003cstrong\u003e\u003cmark\u003e进程数量超过设置的 limit 之后，禁止通过 fork()\n或 clone() 创建新进程\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e依靠其他控制器是无法避免 cgroup 中的进程暴增问题的，例如，fork 炸弹能在触发内存\n限制之前耗尽 PID 空间，因此引入了 PID 控制器。\u003c/li\u003e\n  \u003cli\u003e注意，这里所说的 PID 指的是内核在使用的 TID 和进程 ID。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"541-pid-接口文件pidscurrentpidsmax\"\u003e5.4.1 PID 接口文件：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.current/pids.max\u003c/code\u003e\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epids.max\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root\n cgroups.  The default is “max”.\u003c/p\u003e\n\n    \u003cp\u003eHard limit of number of processes.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003epids.current\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-only single value file which exists on all cgroups.\u003c/p\u003e\n\n    \u003cp\u003ecgroup 及其 descendants 中的\u003cstrong\u003e\u003cmark\u003e当前进程数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"542-绕开-cgroup-pid-限制实现-pidscurrent--pidsmax\"\u003e5.4.2 绕开 cgroup PID 限制，实现 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.current \u0026gt; pids.max\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e上面提到，PID 控制器是\u003cstrong\u003e\u003cmark\u003e限制通过 \u003ccode\u003efork/clone\u003c/code\u003e 来创建新进程\u003c/mark\u003e\u003c/strong\u003e（超过限制之后返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-EAGAIN\u003c/code\u003e）。\n因此\u003cstrong\u003e\u003cmark\u003e只要不用这两个系统调用\u003c/mark\u003e\u003c/strong\u003e，我们还是能将 cgroup 内的进程数量搞成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecurrent \u0026gt; max\u003c/code\u003e 的。例如：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e设置 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.max\u003c/code\u003e 小于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epids.current\u003c/code\u003e（即先有足够多的进程，再降低 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax\u003c/code\u003e 配置），或者\u003c/li\u003e\n  \u003cli\u003e将足够多的进程从其他 cgroup 移动到当前 cgroup（迁移现有进程不需要 fork/clone）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"55-cpuset\"\u003e5.5 Cpuset\u003c/h2\u003e\n\n\u003cp\u003e“cpuset” controller 提供了一种对 CPU 和内存物理位置（CPU and memory placement）的控制方式，\n在 \u003cstrong\u003e\u003cmark\u003eNUMA 系统中非常有用\u003c/mark\u003e\u003c/strong\u003e，能将 job 放到期望的 NUMA node 上，\n从而减少跨 NUMA node 的内存访问和竞争，提升性能。\u003c/p\u003e\n\n\u003cp\u003e“cpuset” controller is hierarchical. 这意味着 controller\n只能使用它的 parent 允许范围内的 CPU 或内存。\u003c/p\u003e\n\n\u003ch3 id=\"cpuset-接口文件\"\u003eCpuset 接口文件\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpuset.cpus\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e可读写文件，只存在于 non-root cpuset-enabled cgroups.\u003c/p\u003e\n\n    \u003cp\u003e描述了\u003cstrong\u003e\u003cmark\u003e这个 cgroup 进程申请的 CPU 列表\u003c/mark\u003e\u003c/strong\u003e，逗号隔开：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecpuset.cpus\n 0-4,6,8-10\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e但是，\u003cstrong\u003e\u003cmark\u003e最终真正分配给这个 cgroup 的 CPU 列表，可能不同于申请的列表\u003c/mark\u003e\u003c/strong\u003e，\n 因为还要受 parent 的限制（比如申请了 CPU 4 但是 parent 列表里没有 4）。\u003c/p\u003e\n\n    \u003cp\u003e这个文件为空时，表示这个 cgroup 使用离它最近的、非空的祖先 cgroup 的配置；\n 如果所有的祖先都为空，那就意味着使用所有可用的 CPU。\u003c/p\u003e\n\n    \u003cp\u003eThe value of “cpuset.cpus” stays constant until the next update\n and won’t be affected by any CPU hotplug events.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpuset.cpus.effective\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e只读文件， which exists on all cpuset-enabled cgroups.\u003c/p\u003e\n\n    \u003cp\u003e描述的是 parent \u003cstrong\u003e\u003cmark\u003e真正分给这个 cgroup 的 CPU 列表\u003c/mark\u003e\u003c/strong\u003e。\n 这个 cgroup 内的所有进程都可以使用这些 CPU。\u003c/p\u003e\n\n    \u003cp\u003eIf “cpuset.cpus” is empty, the “cpuset.cpus.effective” file shows\n all the CPUs from the parent cgroup that can be available to\n be used by this cgroup.  Otherwise, it should be a subset of\n “cpuset.cpus” unless none of the CPUs listed in “cpuset.cpus”\n can be granted.  In this case, it will be treated just like an\n empty “cpuset.cpus”.\u003c/p\u003e\n\n    \u003cp\u003eIts value will be affected by CPU hotplug events.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecpuset.mems\u003c/p\u003e\n\n    \u003cp\u003eA read-write multiple values file which exists on non-root cpuset-enabled cgroups.\u003c/p\u003e\n\n    \u003cp\u003eIt lists the requested memory nodes to be used by tasks within\n this cgroup.  The actual list of memory nodes granted, however,\n is subjected to constraints imposed by its parent and can differ\n from the requested memory nodes.\u003c/p\u003e\n\n    \u003cp\u003eThe memory node numbers are comma-separated numbers or ranges.\n For example::\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ecpuset.mems\n 0-1,3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eAn empty value indicates that the cgroup is using the same\n setting as the nearest cgroup ancestor with a non-empty\n “cpuset.mems” or all the available memory nodes if none\n is found.\u003c/p\u003e\n\n    \u003cp\u003eThe value of “cpuset.mems” stays constant until the next update\n and won’t be affected by any memory nodes hotplug events.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecpuset.mems.effective\u003c/p\u003e\n\n    \u003cp\u003eA read-only multiple values file which exists on all cpuset-enabled cgroups.\u003c/p\u003e\n\n    \u003cp\u003eIt lists the onlined memory nodes that are actually granted to\n this cgroup by its parent. These memory nodes are allowed to\n be used by tasks within the current cgroup.\u003c/p\u003e\n\n    \u003cp\u003eIf “cpuset.mems” is empty, it shows all the memory nodes from the\n parent cgroup that will be available to be used by this cgroup.\n Otherwise, it should be a subset of “cpuset.mems” unless none of\n the memory nodes listed in “cpuset.mems” can be granted.  In this\n case, it will be treated just like an empty “cpuset.mems”.\u003c/p\u003e\n\n    \u003cp\u003eIts value will be affected by memory nodes hotplug events.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ecpuset.cpus.partition\u003c/p\u003e\n\n    \u003cp\u003eA read-write single value file which exists on non-root\n cpuset-enabled cgroups.  This flag is owned by the parent cgroup\n and is not delegatable.\u003c/p\u003e\n\n    \u003cp\u003eIt accepts only the following input values when written to.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e     \u0026#34;root\u0026#34;   - a partition root\n     \u0026#34;member\u0026#34; - a non-root member of a partition\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eWhen set to be a partition root, the current cgroup is the\n root of a new partition or scheduling domain that comprises\n itself and all its descendants except those that are separate\n partition roots themselves and their descendants.  The root\n cgroup is always a partition root.\u003c/p\u003e\n\n    \u003cp\u003eThere are constraints on where a partition root can be set.\n It can only be set in a cgroup if all the following conditions\n are true.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e 1) The \u0026#34;cpuset.cpus\u0026#34; is not empty and the list of CPUs are\n    exclusive, i.e. they are not shared by any of its siblings.\n 2) The parent cgroup is a partition root.\n 3) The \u0026#34;cpuset.cpus\u0026#34; is also a proper subset of the parent\u0026#39;s\n    \u0026#34;cpuset.cpus.effective\u0026#34;.\n 4) There is no child cgroups with cpuset enabled.  This is for\n    eliminating corner cases that have to be handled if such a\n    condition is allowed.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eSetting it to partition root will take the CPUs away from the\n effective CPUs of the parent cgroup.  Once it is set, this\n file cannot be reverted back to “member” if there are any child\n cgroups with cpuset enabled.\u003c/p\u003e\n\n    \u003cp\u003eA parent partition cannot distribute all its CPUs to its\n child partitions.  There must be at least one cpu left in the\n parent partition.\u003c/p\u003e\n\n    \u003cp\u003eOnce becoming a partition root, changes to “cpuset.cpus” is\n generally allowed as long as the first condition above is true,\n the change will not take away all the CPUs from the parent\n partition and the new “cpuset.cpus” value is a superset of its\n children’s “cpuset.cpus” values.\u003c/p\u003e\n\n    \u003cp\u003eSometimes, external factors like changes to ancestors’\n “cpuset.cpus” or cpu hotplug can cause the state of the partition\n root to change.  On read, the “cpuset.sched.partition” file\n can show the following values.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u0026#34;member\u0026#34;       Non-root member of a partition\n \u0026#34;root\u0026#34;         Partition root\n \u0026#34;root invalid\u0026#34; Invalid partition root\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eIt is a partition root if the first 2 partition root conditions\n above are true and at least one CPU from “cpuset.cpus” is\n granted by the parent cgroup.\u003c/p\u003e\n\n    \u003cp\u003eA partition root can become invalid if none of CPUs requested\n in “cpuset.cpus” can be granted by the parent cgroup or the\n parent cgroup is no longer a partition root itself.  In this\n case, it is not a real partition even though the restriction\n of the first partition root condition above will still apply.\n The cpu affinity of all the tasks in the cgroup will then be\n associated with CPUs in the nearest ancestor partition.\u003c/p\u003e\n\n    \u003cp\u003eAn invalid partition root can be transitioned back to a\n real partition root if at least one of the requested CPUs\n can now be granted by its parent.  In this case, the cpu\n affinity of all the tasks in the formerly invalid partition\n will be associated to the CPUs of the newly formed partition.\n Changing the partition state of an invalid partition root to\n “member” is always allowed even if child cpusets are present.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"56-device-controller\"\u003e5.6 Device controller\u003c/h2\u003e\n\n\u003cp\u003eDevice controller 管理对设备文件（device files）的访问，包括创建新文件（使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emknod\u003c/code\u003e）和访问已有文件。\u003c/p\u003e\n\n\u003ch3 id=\"561-控制方式基于-cgroup-bpf-而非接口文件\"\u003e5.6.1 控制方式：基于 cgroup BPF 而非接口文件\u003c/h3\u003e\n\n\u003cp\u003ecgroupv2 设备控制器\u003cstrong\u003e\u003cmark\u003e没有接口文件，而是实现在 cgroup BPF 之上\u003c/mark\u003e\u003c/strong\u003e。\n要控制对设备文件的访问时，用户需要：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e编写的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_PROG_TYPE_CGROUP_DEVICE\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 类型的 BPF 程序；\u003c/li\u003e\n  \u003cli\u003e将 BPF 程序 attach 到指定的 cgroup，其中指定 \u003cstrong\u003e\u003cmark\u003eattach 类型为 \u003ccode\u003eBPF_CGROUP_DEVICE\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在访问设备文件时，会\u003cstrong\u003e\u003cmark\u003e触发相应 BPF 程序的执行\u003c/mark\u003e\u003c/strong\u003e，后者的返回值决定了\n是否允许访问。\u003c/p\u003e\n\n\u003ch3 id=\"562-cgroup-bpf-程序上下文和返回值\"\u003e5.6.2 cgroup BPF 程序上下文和返回值\u003c/h3\u003e\n\n\u003cp\u003e这种 BPF 程序接受一个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct bpf_cgroup_dev_ctx *\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 指针，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/include/uapi/linux/bpf.h#L4833\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_cgroup_dev_ctx\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u32\u003c/span\u003e \u003cspan class=\"n\"\u003eaccess_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"cm\"\u003e/* encoded as (BPF_DEVCG_ACC_* \u0026lt;\u0026lt; 16) | BPF_DEVCG_DEV_* */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u32\u003c/span\u003e \u003cspan class=\"n\"\u003emajor\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__u32\u003c/span\u003e \u003cspan class=\"n\"\u003eminor\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e字段含义：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccess_type\u003c/code\u003e：访问操作的类型，例如 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003emknod/read/write\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emajor\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eminor\u003c/code\u003e：主次设备号；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eBPF 程序返回值：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0\u003c/code\u003e：访问失败（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-EPERM\u003c/code\u003e）\u003c/li\u003e\n  \u003cli\u003e其他值：访问成功。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"563-cgroup-bpf-程序示例\"\u003e5.6.3 cgroup BPF 程序示例\u003c/h3\u003e\n\n\u003cp\u003e内核测试用例：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/tools/testing/selftests/bpf/progs/dev_cgroup.c\"\u003etools/testing/selftests/bpf/progs/dev_cgroup.c\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/tools/testing/selftests/bpf/test_dev_cgroup.c\"\u003etools/testing/selftests/bpf/test_dev_cgroup.c\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"57-rdma\"\u003e5.7 RDMA\u003c/h2\u003e\n\n\u003cp\u003eThe “rdma” controller regulates the distribution and accounting of\nRDMA resources.\u003c/p\u003e\n\n\u003ch3 id=\"rdma-interface-files\"\u003eRDMA Interface Files\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003erdma.max\u003c/p\u003e\n\n    \u003cp\u003eA readwrite nested-keyed file that exists for all the cgroups\n except root that describes current configured resource limit\n for a RDMA/IB device.\u003c/p\u003e\n\n    \u003cp\u003eLines are keyed by device name and are not ordered.\n Each line contains space separated resource name and its configured\n limit that can be distributed.\u003c/p\u003e\n\n    \u003cp\u003eThe following nested keys are defined.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   ==========    =============================\n   hca_handle    Maximum number of HCA Handles\n   hca_object     Maximum number of HCA Objects\n   ==========    =============================\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eAn example for mlx4 and ocrdma device follows::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   mlx4_0 hca_handle=2 hca_object=2000\n   ocrdma1 hca_handle=3 hca_object=max\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003erdma.current\u003c/p\u003e\n\n    \u003cp\u003eA read-only file that describes current resource usage.\n It exists for all the cgroup except root.\u003c/p\u003e\n\n    \u003cp\u003eAn example for mlx4 and ocrdma device follows::\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   mlx4_0 hca_handle=1 hca_object=20\n   ocrdma1 hca_handle=1 hca_object=23\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"58-hugetlb\"\u003e5.8 HugeTLB\u003c/h2\u003e\n\n\u003cp\u003eThe HugeTLB controller allows to limit the HugeTLB usage per control group and\nenforces the controller limit during page fault.\u003c/p\u003e\n\n\u003ch3 id=\"hugetlb-interface-files\"\u003eHugeTLB Interface Files\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003ehugetlb.\u003chugepagesize\u003e.current\u003c/hugepagesize\u003e\u003c/p\u003e\n\n    \u003cp\u003eShow current usage for “hugepagesize” hugetlb.  It exists for all\n the cgroup except root.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ehugetlb.\u003chugepagesize\u003e.max\u003c/hugepagesize\u003e\u003c/p\u003e\n\n    \u003cp\u003eSet/show the hard limit of “hugepagesize” hugetlb usage.\n The default value is “max”.  It exists for all the cgroup except root.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ehugetlb.\u003chugepagesize\u003e.events\u003c/hugepagesize\u003e\u003c/p\u003e\n\n    \u003cp\u003eA read-only flat-keyed file which exists on non-root cgroups.\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e   max\n     The number of allocation failure due to HugeTLB limit\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ehugetlb.\u003chugepagesize\u003e.events.local\u003c/hugepagesize\u003e\u003c/p\u003e\n\n    \u003cp\u003eSimilar to hugetlb.\u003chugepagesize\u003e.events but the fields in the file\n are local to the cgroup i.e. not hierarchical. The file modified event\n generated on this file reflects only the local events.\u003c/hugepagesize\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"59-misc\"\u003e5.9 Misc\u003c/h2\u003e\n\n\u003ch3 id=\"perf_event\"\u003eperf_event\u003c/h3\u003e\n\n\u003cp\u003eperf_event controller, if not mounted on a legacy hierarchy, is\nautomatically enabled on the v2 hierarchy so that perf events can\nalways be filtered by cgroup v2 path.  The controller can still be\nmoved to a legacy hierarchy after v2 hierarchy is populated.\u003c/p\u003e\n\n\u003ch2 id=\"510-规范外non-normative的一些信息\"\u003e5.10 规范外（non-normative）的一些信息\u003c/h2\u003e\n\n\u003cp\u003e本节内容\u003cstrong\u003e\u003cmark\u003e不属于 stable kernel API\u003c/mark\u003e\u003c/strong\u003e，随时可能变化。\u003c/p\u003e\n\n\u003ch3 id=\"cpu-controller-root-cgroup-处理行为\"\u003eCPU controller root cgroup 处理行为\u003c/h3\u003e\n\n\u003cp\u003eWhen distributing CPU cycles in the root cgroup each thread in this\ncgroup is treated as if it was hosted in a separate child cgroup of the\nroot cgroup. This child cgroup weight is dependent on its thread nice\nlevel.\u003c/p\u003e\n\n\u003cp\u003eFor details of this mapping see sched_prio_to_weight array in\nkernel/sched/core.c file (values from this array should be scaled\nappropriately so the neutral - nice 0 - value is 100 instead of 1024).\u003c/p\u003e\n\n\u003ch3 id=\"io-controller-root-cgroup-处理行为\"\u003eIO controller root cgroup 处理行为\u003c/h3\u003e\n\n\u003cp\u003eRoot cgroup processes are hosted in an implicit leaf child node.\nWhen distributing IO resources this implicit child node is taken into\naccount as if it was a normal child cgroup of the root cgroup with a\nweight value of 200.\u003c/p\u003e\n\n\u003ch1 id=\"6-cgroup-命名空间cgroupns\"\u003e6 cgroup 命名空间（cgroupns）\u003c/h1\u003e\n\n\u003cp\u003e容器环境中用 cgroup 和其他一些 namespace 来隔离进程，但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/$PID/cgroup\u003c/code\u003e 文件\n\u003cstrong\u003e\u003cmark\u003e可能会泄露潜在的系统层信息\u003c/mark\u003e\u003c/strong\u003e。例如：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/self/cgroup\n0::/batchjobs/container_id1 \u003cspan class=\"c\"\u003e# \u0026lt;-- cgroup 的绝对路径，属于系统层信息，不希望暴露给隔离的进程\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e因此\u003cstrong\u003e\u003cmark\u003e引入了 cgroup namespace\u003c/mark\u003e\u003c/strong\u003e，以下简写为 \u003cstrong\u003e\u003cmark\u003ecgroupns\u003c/mark\u003e\u003c/strong\u003e\n（类似于 network namespace 简写为 netns）。\u003c/p\u003e\n\n\u003ch2 id=\"61-基础\"\u003e6.1 基础\u003c/h2\u003e\n\n\u003ch3 id=\"611-功能对-procpidcgroup-和-cgroup-mount-进行虚拟化\"\u003e6.1.1 功能：对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/PID/cgroup\u003c/code\u003e 和 cgroup mount 进行虚拟化\u003c/h3\u003e\n\n\u003cp\u003ecgroupns 对\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/proc/$PID/cgroup\u003c/code\u003e 文件和 cgroup 挂载视角\u003c/mark\u003e\u003c/strong\u003e进行了虚拟化。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e如果没有 cgroupns\u003c/mark\u003e\u003c/strong\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat /proc/$PID/cgroup\u003c/code\u003e 看到的是\u003cstrong\u003e\u003cmark\u003e进程所属 cgroup 的绝对路径\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e有了 cgroupns 之后，看到的将是 cgroupns root 范围内的路径。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面具体来看。\u003c/p\u003e\n\n\u003ch3 id=\"612-新建-cgroup-namespace\"\u003e6.1.2 新建 cgroup namespace\u003c/h3\u003e\n\n\u003cp\u003e可以用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eclone(2)/unshare(2)\u003c/code\u003e 指定 \u003ccode\u003eCLONE_NEWCGROUP\u003c/code\u003e flag\u003c/mark\u003e\u003c/strong\u003e\n来创建一个新的 cgroupns。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e创建该 cgroupns 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunshare/clone\u003c/code\u003e 所在的 cgroup namespace 称为 \u003cstrong\u003e\u003cmark\u003ecgroupns root\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e该 cgroupns 内的进程查看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/$PID/cgroup\u003c/code\u003e 时，只能看到其 cgroupns root 范围内的 cgroup 文件路径。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e也就是说，cgroupns 限制了 cgroup 文件路径的可见性。例如，没有创建 cgroup\nnamespace 时的视图：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e /proc/self/ns/cgroup\nlrwxrwxrwx 1 root root 0 2014-07-15 10:37 /proc/self/ns/cgroup -\u0026gt; cgroup:[4026531835]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/self/cgroup\n0::/batchjobs/container_id1  \u003cspan class=\"c\"\u003e# \u0026lt;-- 绝对路径\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunshare\u003c/code\u003e 创建一个新 cgroupns 之后的视图：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e /proc/self/ns/cgroup\nlrwxrwxrwx 1 root root 0 2014-07-15 10:35 /proc/self/ns/cgroup -\u0026gt; cgroup:[4026532183]\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/self/cgroup\n0::/                         \u003cspan class=\"c\"\u003e# \u0026lt;-- cgroupns root 限制范围内的路径\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"613-多线程进程线程-unshare-后的行为\"\u003e6.1.3 多线程进程：线程 unshare 后的行为\u003c/h3\u003e\n\n\u003cp\u003e对于多线程的进程，任何一个线程通过 unshare 创建新 cgroupns 时，整个进程（所有线程）\n都会进入到新的 cgroupns。这对 v2 hierarchy 是很自然的事情，但对 v1 来说，可能是\n不期望的行为。\u003c/p\u003e\n\n\u003ch3 id=\"614-cgroupns-生命周期\"\u003e6.1.4 cgroupns 生命周期\u003c/h3\u003e\n\n\u003cp\u003e只要以下条件之一满足，cgroupns 就会活着：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e该 \u003cstrong\u003e\u003cmark\u003ecgroup 中还有活着的进程\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e挂载的文件系统中，还有对象 \u003cstrong\u003e\u003cmark\u003epin 在这个 cgroupns 上\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e当最后一个还在使用 cgroupns 的进程退出或文件系统 unmount 之后，这个 cgroupns 就销毁了。\n但 cgroupns root 和真正的 cgroups 还是继续存在的。\u003c/p\u003e\n\n\u003ch2 id=\"62-进一步解释-cgroupns-root-和视图\"\u003e6.2 进一步解释 cgroupns root 和视图\u003c/h2\u003e\n\n\u003cp\u003e前面提到，cgroupns root 是指 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunshare(2)\u003c/code\u003e 创建 cgroupns 时所在的 cgroup。\n例如，如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/batchjobs/container_id1\u003c/code\u003e cgroup 中的一个进程调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunshare\u003c/code\u003e，那\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/batchjobs/container_id1\u003c/code\u003e 就成了 cgroupns root。For the init_cgroup_ns, this is\nthe real root (‘/’) cgroup.\u003c/p\u003e\n\n\u003cp\u003e即便创建这个 cgroupns 的进程后面移动到其他 cgroup，这个 \u003cstrong\u003e\u003cmark\u003ecgroupns root 也是不会变的\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e~/unshare \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e \u003cspan class=\"c\"\u003e# 在当前 cgroup 中通过 unshare 命令创建一个 cgroupns\u003c/span\u003e\n\n\u003cspan class=\"c\"\u003e# 以下命令都在刚创建的 cgroupns 中执行的\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/self/cgroup\n0::/\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003emkdir \u003c/span\u003esub_cgrp_1                  \u003cspan class=\"c\"\u003e# 创建一个 sub-cgroup\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e0 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e sub_cgrp_1/cgroup.procs  \u003cspan class=\"c\"\u003e# 将当前 shell 进程迁移到新创建的 cgroup sub_cgrp_1\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/self/cgroup             \u003cspan class=\"c\"\u003e# 查看当前 shell 进程的 cgroup 信息\u003c/span\u003e\n0::/sub_cgrp_1                      \u003cspan class=\"c\"\u003e# 可以看到是相对路径\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e每个进程获得了它自己的 namespace-specific \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/$PID/cgroup\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e运行在 cgroupns 中的进程，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/self/cgroup\u003c/code\u003e 中只能看到它们的 root cgroup 内的 cgroup 路径。\n例如，还是在刚才 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunshare\u003c/code\u003e 创建的 cgroupns 中：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# 接着上面的窗口，现在还是在创建出的 cgroupns 中执行命令\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esleep \u003c/span\u003e100000 \u0026amp;                      \u003cspan class=\"c\"\u003e# 创建一个进程，放在后台执行\u003c/span\u003e\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e1] 7353\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e7353 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e sub_cgrp_1/cgroup.procs \u003cspan class=\"c\"\u003e# 将进程迁移到前面创建的 sub-cgroup 中\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/7353/cgroup               \u003cspan class=\"c\"\u003e# 查看这个进程的 cgroup 信息，会看到是相对路径\u003c/span\u003e\n0::/sub_cgrp_1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在默认 cgroupns 中，真实 cgroup path 还是可见的：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/7353/cgroup\n0::/batchjobs/container_id1/sub_cgrp_1 \u003cspan class=\"c\"\u003e# 绝对路径，说明没有在新建的 cgroupns 中\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e在 sibling（兄弟）cgroupns (a namespace rooted at a different cgroup) 中，会显示\n\u003cstrong\u003e\u003cmark\u003e相对 cgroup path\u003c/mark\u003e\u003c/strong\u003e（相对于它自己的cgroupns root）。例如，如果\nPID 7353 的 cgroupns root 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/batchjobs/container_id2\u003c/code\u003e，那它将看到：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/7353/cgroup\n0::/../container_id2/sub_cgrp_1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意：相对路径永远以 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/\u003c/code\u003e 开头，以提醒用户这是相对于调用者的 cgroupns root 的路径。\u003c/p\u003e\n\n\u003ch2 id=\"63-在-cgroupns-之间迁移进程\"\u003e6.3 在 cgroupns 之间迁移进程\u003c/h2\u003e\n\n\u003cp\u003ecgroupns 内的进程，可以移出或移入 ns root，只要有\u003cstrong\u003e\u003cmark\u003e对外部 cgroup 的访问权限\u003c/mark\u003e\u003c/strong\u003e\n（proper access to external cgroups）。例如，在 cgroupns root 是\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/batchjobs/container_id1\u003c/code\u003e 的某 cgroupns 内，假设能访问全局 hierarchy，那可以通\n过如下命令迁移进程：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/7353/cgroup\n0::/sub_cgrp_1\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eecho \u003c/span\u003e7353 \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e batchjobs/container_id2/cgroup.procs\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/7353/cgroup\n0::/../container_id2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意，这种迁移方式\u003cstrong\u003e\u003cmark\u003e并不推荐\u003c/mark\u003e\u003c/strong\u003e。cgroupns 内的进程只应当被暴露到它\n自己的 cgroupns hierarchy 内。\u003c/p\u003e\n\n\u003cp\u003e还可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetns(2)\u003c/code\u003e 将进程移动到其他 cgroupns，前提条件：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e有 CAP_SYS_ADMIN against its current user namespace\u003c/li\u003e\n  \u003cli\u003e有 CAP_SYS_ADMIN against the target cgroupns’s userns\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e当 attach 到其他 cgroupns 时，不会有隐式的 cgroup changes。\nIt is expected that the someone moves the attaching process under the target cgroupns root.\u003c/p\u003e\n\n\u003ch2 id=\"64-与其他-cgroupns-交互\"\u003e6.4 与其他 cgroupns 交互\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eNamespace 相关的 cgroup hierarchy\u003c/mark\u003e\u003c/strong\u003e 可以在 non-init cgroupns 内以如下方式挂载：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# mount -t \u0026lt;fstype\u0026gt; \u0026lt;device\u0026gt; \u0026lt;dir\u0026gt;\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e cgroup2 none \u003cspan class=\"nv\"\u003e$MOUNT_POINT\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这会\u003cstrong\u003e\u003cmark\u003e挂载默认的 unified cgroup hierarchy\u003c/mark\u003e\u003c/strong\u003e，并\u003cstrong\u003e\u003cmark\u003e将 cgroupns root 作为 filesystem root\u003c/mark\u003e\u003c/strong\u003e。\n这个操作需要 CAP_SYS_ADMIN 权限。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/self/cgroup\u003c/code\u003e 的虚拟化，以及通过 namespace-private cgroupfs mount 来限制\n进程能看到的 cgroup hierarchy，提供了容器的隔离的 cgroup 视角。\u003c/p\u003e\n\n\u003ch1 id=\"7-内核编程相关信息\"\u003e7 内核编程相关信息\u003c/h1\u003e\n\n\u003cp\u003e一些与 cgroup 交互相关的内核编程信息。\u003c/p\u003e\n\n\u003ch2 id=\"文件系统对-writeback-的支持\"\u003e文件系统对 writeback 的支持\u003c/h2\u003e\n\n\u003cp\u003eA filesystem can support cgroup writeback by updating\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaddress_space_operations-\u0026gt;writepage[s]()\u003c/code\u003e to annotate bio’s using the\nfollowing two functions.\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  wbc_init_bio(@wbc, @bio)\n    Should be called for each bio carrying writeback data and\n    associates the bio with the inode\u0026#39;s owner cgroup and the\n    corresponding request queue.  This must be called after\n    a queue (device) has been associated with the bio and\n    before submission.\n\n  wbc_account_cgroup_owner(@wbc, @page, @bytes)\n    Should be called for each data segment being written out.\n    While this function doesn\u0026#39;t care exactly when it\u0026#39;s called\n    during the writeback session, it\u0026#39;s the easiest and most\n    natural to call it as data segments are added to a bio.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWith writeback bio’s annotated, cgroup support can be enabled per\nsuper_block by setting SB_I_CGROUPWB in -\u0026gt;s_iflags.  This allows for\nselective disabling of cgroup writeback support which is helpful when\ncertain filesystem features, e.g. journaled data mode, are\nincompatible.\u003c/p\u003e\n\n\u003cp\u003ewbc_init_bio() binds the specified bio to its cgroup.  Depending on\nthe configuration, the bio may be executed at a lower priority and if\nthe writeback session is holding shared resources, e.g. a journal\nentry, may lead to priority inversion.  There is no one easy solution\nfor the problem.  Filesystems can try to work around specific problem\ncases by skipping wbc_init_bio() and using bio_associate_blkg()\ndirectly.\u003c/p\u003e\n\n\u003ch1 id=\"8-v1-core-已弃用特性\"\u003e8 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1 core\u003c/code\u003e 已弃用特性\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eMultiple hierarchies including named ones are not supported.\u003c/li\u003e\n  \u003cli\u003eAll v1 mount options are not supported.\u003c/li\u003e\n  \u003cli\u003eThe “tasks” file is removed and “cgroup.procs” is not sorted.\u003c/li\u003e\n  \u003cli\u003e“cgroup.clone_children” is removed.\u003c/li\u003e\n  \u003cli\u003e/proc/cgroups is meaningless for v2.  Use “cgroup.controllers” file at the root instead.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"9-v1-存在的问题及-v2-的设计考虑rationales\"\u003e9 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1\u003c/code\u003e 存在的问题及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev2\u003c/code\u003e 的设计考虑（rationales）\u003c/h1\u003e\n\n\u003ch2 id=\"91-v1-多-hierarchy-带来的问题\"\u003e9.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ev1\u003c/code\u003e 多 hierarchy 带来的问题\u003c/h2\u003e\n\n\u003cp\u003ev1 允许任意数量的 hierarchy，每个 hierarchy 可以启用任意数量的 controller。\n这种方式看上去高度灵活，但\u003cstrong\u003e\u003cmark\u003e在实际中并不是很有用\u003c/mark\u003e\u003c/strong\u003e。例如，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eutility 类型的 controller（例如 freezer）本可用于多个 hierarchy，而\n由于 v1 中每个 controller 只有一个实例，utility controller 的作用就大打折扣；\n而 hierarchy 一旦被 populated 之后，控制器就不能移动到其他 hierarchy 的事实，\n更是加剧了这个问题。\u003c/li\u003e\n  \u003cli\u003e另一个问题是，关联到某个 hierarchy 的所有控制器，只能拥有相同的 hierarchy 视图。\n\u003cstrong\u003e\u003cmark\u003e无法在 controller 粒度改变这种视图\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在实际中，这些问题严重制约着每个 hierarchy 能启用哪些控制器，导致的结果就是：\n\u003cstrong\u003e\u003cmark\u003e大部分 hierarchy 都启用了所有控制器\u003c/mark\u003e\u003c/strong\u003e。而实际上只有联系非常紧密的\n控制器 —— 例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpu\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecpuacct\u003c/code\u003e —— 放到同一个 hierarchy 中才有意义。\n因此最终的结果就是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e用户空间最后\u003cstrong\u003e\u003cmark\u003e管理着多个非常类似的 hierarchy\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e在执行 hierarchy 管理操作时，\u003cstrong\u003e\u003cmark\u003e每个 hierarchy 上都重复着相同的操作\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e此外，支持多个 hierarchy 代价也非常高。它使得 cgroup core 的实现更加复杂，更重要的是，\n限制了 cgroup 如何使用以及每个控制器能做什么。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e由于未限制 hierarchy 数量，因此一个线程的 cgroup membership 无法用有限长度来描述。\u003c/p\u003e\n\n    \u003cp\u003ecgroup 文件可能包含任意数量（行数）的 entry，长度是没有限制的，使得管理非常棘手，\n 最终不得\u003cstrong\u003e\u003cmark\u003e不加一些特殊的控制器\u003c/mark\u003e\u003c/strong\u003e，而这些控制器的唯一目的就是识\n 别 membership，这反过来又加剧了最初的问题：hierarchy 数量不断增加。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e由于 controller 无法对其他 controller 所在的 hierarchy 拓扑做出预测，每个\ncontroller 只能假设所有控制器都 attach 到了完全正交的 hierarchies。\n这使得无法 —— 或至少非常困难 —— \u003cstrong\u003e\u003cmark\u003e实现控制器之间的协作\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e在大部分场景下，将控制器放到多个完全正交的 hierarchy 都是没必要的。大家更\n 希望的是不同控制器能有不同层级的控制粒度。换句话说，从某个具体的 controller 角\n 度来看时，hierarchy 能够自底向上（from leaf towards root）collapse。例如\n ，某个配置能不关心内存是否已经超过限制，而只关心 CPU cycle 的分配是否符合设置。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"92-线程粒度thread-granularity\"\u003e9.2 线程粒度（thread granularity）\u003c/h2\u003e\n\n\u003cp\u003ecgroup v1 allowed threads of a process to belong to different cgroups.\nThis didn’t make sense for some controllers and those controllers\nended up implementing different ways to ignore such situations but\nmuch more importantly it blurred the line between API exposed to\nindividual applications and system management interface.\u003c/p\u003e\n\n\u003cp\u003eGenerally, in-process knowledge is available only to the process\nitself; thus, unlike service-level organization of processes,\ncategorizing threads of a process requires active participation from\nthe application which owns the target process.\u003c/p\u003e\n\n\u003cp\u003ecgroup v1 had an ambiguously defined delegation model which got abused\nin combination with thread granularity.  cgroups were delegated to\nindividual applications so that they can create and manage their own\nsub-hierarchies and control resource distributions along them.  This\neffectively raised cgroup to the status of a syscall-like API exposed\nto lay programs.\u003c/p\u003e\n\n\u003cp\u003eFirst of all, cgroup has a fundamentally inadequate interface to be\nexposed this way.  For a process to access its own knobs, it has to\nextract the path on the target hierarchy from /proc/self/cgroup,\nconstruct the path by appending the name of the knob to the path, open\nand then read and/or write to it.  This is not only extremely clunky\nand unusual but also inherently racy.  There is no conventional way to\ndefine transaction across the required steps and nothing can guarantee\nthat the process would actually be operating on its own sub-hierarchy.\u003c/p\u003e\n\n\u003cp\u003ecgroup controllers implemented a number of knobs which would never be\naccepted as public APIs because they were just adding control knobs to\nsystem-management pseudo filesystem.  cgroup ended up with interface\nknobs which were not properly abstracted or refined and directly\nrevealed kernel internal details.  These knobs got exposed to\nindividual applications through the ill-defined delegation mechanism\neffectively abusing cgroup as a shortcut to implementing public APIs\nwithout going through the required scrutiny.\u003c/p\u003e\n\n\u003cp\u003eThis was painful for both userland and kernel.  Userland ended up with\nmisbehaving and poorly abstracted interfaces and kernel exposing and\nlocked into constructs inadvertently.\u003c/p\u003e\n\n\u003ch2 id=\"93-内部节点inner-nodes与线程之间竞争\"\u003e9.3 内部节点（inner nodes）与线程之间竞争\u003c/h2\u003e\n\n\u003cp\u003ecgroup v1 允许线程在任意 cgroup，这导致了一个很有趣的问题：\nthreads belonging to a parent cgroup and its\nchildren cgroups competed for resources.  This was nasty as two\ndifferent types of entities competed and there was no obvious way to\nsettle it.  Different controllers did different things.\u003c/p\u003e\n\n\u003cp\u003eThe cpu controller considered threads and cgroups as equivalents and\nmapped nice levels to cgroup weights.  This worked for some cases but\nfell flat when children wanted to be allocated specific ratios of CPU\ncycles and the number of internal threads fluctuated - the ratios\nconstantly changed as the number of competing entities fluctuated.\nThere also were other issues.  The mapping from nice level to weight\nwasn’t obvious or universal, and there were various other knobs which\nsimply weren’t available for threads.\u003c/p\u003e\n\n\u003cp\u003eThe io controller implicitly created a hidden leaf node for each\ncgroup to host the threads.  The hidden leaf had its own copies of all\nthe knobs with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eleaf_\u003c/code\u003e prefixed.  While this allowed equivalent\ncontrol over internal threads, it was with serious drawbacks.  It\nalways added an extra layer of nesting which wouldn’t be necessary\notherwise, made the interface messy and significantly complicated the\nimplementation.\u003c/p\u003e\n\n\u003cp\u003eThe memory controller didn’t have a way to control what happened\nbetween internal tasks and child cgroups and the behavior was not\nclearly defined.  There were attempts to add ad-hoc behaviors and\nknobs to tailor the behavior to specific workloads which would have\nled to problems extremely difficult to resolve in the long term.\u003c/p\u003e\n\n\u003cp\u003eMultiple controllers struggled with internal tasks and came up with\ndifferent ways to deal with it; unfortunately, all the approaches were\nseverely flawed and, furthermore, the widely different behaviors\nmade cgroup as a whole highly inconsistent.\u003c/p\u003e\n\n\u003cp\u003eThis clearly is a problem which needs to be addressed from cgroup core\nin a uniform way.\u003c/p\u003e\n\n\u003ch2 id=\"94-其他-cgroup-接口相关的问题\"\u003e9.4 其他 cgroup 接口相关的问题\u003c/h2\u003e\n\n\u003cp\u003ev1 的设计并\u003cstrong\u003e\u003cmark\u003e没有前瞻性\u003c/mark\u003e\u003c/strong\u003e，因此后面引入了\u003cstrong\u003e\u003cmark\u003e大量的怪异特性和不一致性\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"941-核心接口\"\u003e9.4.1 核心接口\u003c/h3\u003e\n\n\u003cp\u003ecgroup core 中的问题，例如：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如何通知一个 empty cgroup。v1 的实现非常粗暴：\n对于每个事件都 fork 执行一个用户空间 helper binary。\u003c/li\u003e\n  \u003cli\u003eevent delivery 也是不可递归或 delegatable 的。这也使内核中的事件 delivery 过滤机制让 cgroup 接口变得更复杂。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"942-控制器接口\"\u003e9.4.2 控制器接口\u003c/h3\u003e\n\n\u003cp\u003e控制器接口也有问题。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个极端的例子：控制器完全不管 hierarchical organization，认为所有 cgroup 都直接位于 root cgroup 下面。\u003c/li\u003e\n  \u003cli\u003e一些控制器暴露了大量的、不一致的实现细节给用户空间。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"943-控制器行为\"\u003e9.4.3 控制器行为\u003c/h3\u003e\n\n\u003cp\u003e控制器行为也有不一致。\u003c/p\u003e\n\n\u003cp\u003e创建一个新 cgroup 之后，某些控制器默认不会施加限制，而另一些控制器则会直接禁用\n资源，需要用户显式配置来解除禁用。\nConfiguration knobs for the same type of\ncontrol used widely differing naming schemes and formats.  Statistics\nand information knobs were named arbitrarily and used different\nformats and units even in the same controller.\u003c/p\u003e\n\n\u003cp\u003ev2 建立了\u003cstrong\u003e\u003cmark\u003e通用约定\u003c/mark\u003e\u003c/strong\u003e，并更新了控制器设计，以使得它们只需\u003cstrong\u003e\u003cmark\u003e暴露最少且一致的接口\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"95-一些-controller-相关的问题及解决方式\"\u003e9.5 一些 controller 相关的问题及解决方式\u003c/h2\u003e\n\n\u003ch3 id=\"memory\"\u003eMemory\u003c/h3\u003e\n\n\u003cp\u003eThe original lower boundary, the soft limit, is defined as a limit\nthat is per default unset.  As a result, the set of cgroups that\nglobal reclaim prefers is opt-in, rather than opt-out.  The costs for\noptimizing these mostly negative lookups are so high that the\nimplementation, despite its enormous size, does not even provide the\nbasic desirable behavior.  First off, the soft limit has no\nhierarchical meaning.  All configured groups are organized in a global\nrbtree and treated like equal peers, regardless where they are located\nin the hierarchy.  This makes subtree delegation impossible.  Second,\nthe soft limit reclaim pass is so aggressive that it not just\nintroduces high allocation latencies into the system, but also impacts\nsystem performance due to overreclaim, to the point where the feature\nbecomes self-defeating.\u003c/p\u003e\n\n\u003cp\u003eThe memory.low boundary on the other hand is a top-down allocated\nreserve.  A cgroup enjoys reclaim protection when it’s within its\neffective low, which makes delegation of subtrees possible. It also\nenjoys having reclaim pressure proportional to its overage when\nabove its effective low.\u003c/p\u003e\n\n\u003cp\u003eThe original high boundary, the hard limit, is defined as a strict\nlimit that can not budge, even if the OOM killer has to be called.\nBut this generally goes against the goal of making the most out of the\navailable memory.  The memory consumption of workloads varies during\nruntime, and that requires users to overcommit.  But doing that with a\nstrict upper limit requires either a fairly accurate prediction of the\nworking set size or adding slack to the limit.  Since working set size\nestimation is hard and error prone, and getting it wrong results in\nOOM kills, most users tend to err on the side of a looser limit and\nend up wasting precious resources.\u003c/p\u003e\n\n\u003cp\u003eThe memory.high boundary on the other hand can be set much more\nconservatively.  When hit, it throttles allocations by forcing them\ninto direct reclaim to work off the excess, but it never invokes the\nOOM killer.  As a result, a high boundary that is chosen too\naggressively will not terminate the processes, but instead it will\nlead to gradual performance degradation.  The user can monitor this\nand make corrections until the minimal memory footprint that still\ngives acceptable performance is found.\u003c/p\u003e\n\n\u003cp\u003eIn extreme cases, with many concurrent allocations and a complete\nbreakdown of reclaim progress within the group, the high boundary can\nbe exceeded.  But even then it’s mostly better to satisfy the\nallocation from the slack available in other groups or the rest of the\nsystem than killing the group.  Otherwise, memory.max is there to\nlimit this type of spillover and ultimately contain buggy or even\nmalicious applications.\u003c/p\u003e\n\n\u003cp\u003eSetting the original memory.limit_in_bytes below the current usage was\nsubject to a race condition, where concurrent charges could cause the\nlimit setting to fail. memory.max on the other hand will first set the\nlimit to prevent new charges, and then reclaim and OOM kill until the\nnew limit is met - or the task writing to memory.max is killed.\u003c/p\u003e\n\n\u003cp\u003eThe combined memory+swap accounting and limiting is replaced by real\ncontrol over swap space.\u003c/p\u003e\n\n\u003cp\u003eThe main argument for a combined memory+swap facility in the original\ncgroup design was that global or parental pressure would always be\nable to swap all anonymous memory of a child group, regardless of the\nchild’s own (possibly untrusted) configuration.  However, untrusted\ngroups can sabotage swapping by other means - such as referencing its\nanonymous memory in a tight loop - and an admin can not assume full\nswappability when overcommitting untrusted jobs.\u003c/p\u003e\n\n\u003cp\u003eFor trusted jobs, on the other hand, a combined counter is not an\nintuitive userspace interface, and it flies in the face of the idea\nthat cgroup controllers should account and limit specific physical\nresources.  Swap space is a resource like all others in the system,\nand that’s why unified hierarchy allows distributing it separately.\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/intro-to-io-uring-zh/\"\u003e\u003cspan\u003e« [译] Linux 异步 I/O 框架 io_uring：基本原理、程序示例与性能压测（2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/rbac-as-it-meant-to-be-zh/\"\u003e\u003cspan\u003e[译] 基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现（Tailscale, 2021） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-09-10T00:00:00Z",
  "Author": "Arthur Chiao"
}