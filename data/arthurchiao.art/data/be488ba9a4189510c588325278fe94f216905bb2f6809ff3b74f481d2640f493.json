{
  "Source": "arthurchiao.art",
  "Title": "[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）",
  "Link": "https://arthurchiao.art/blog/everything-about-pki-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 写给工程师：关于证书（certificate）和公钥基础设施（PKI）的一切（SmallStep, 2018）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-10-07 | Last Update 2023-05-02\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2018 年的一篇英文博客：\n\u003ca href=\"https://smallstep.com/blog/everything-pki/\"\u003eEverything you should know about certificates and PKI but are too afraid to ask\u003c/a\u003e，\n作者 MIKE MALONE。\u003c/p\u003e\n\n\u003cp\u003e这篇长文并不是枯燥、零碎地介绍 PKI、X.509、OID 等概念，而是从前因后果、历史沿革\n的角度把这些东西串联起来，逻辑非常清晰，让读者知其然，更知其所以然。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e证书和 PKI 的目标其实很简单：\u003cstrong\u003e\u003cmark\u003e将名字关联到公钥\u003c/mark\u003e\u003c/strong\u003e（bind names to public keys）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e加密方式的演进\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e MAC         最早的验证消息是否被篡改的方式，发送消息时附带一段验证码\n  |          双方共享同一密码，做哈希；最常用的哈希算法：HMAC\n  |\n  \\/\n Signature   解决 MAC 存在的一些问题；双方不再共享同一密码，而是使用密钥对\n  |\n  |\n  \\/\n PKC         公钥加密，或称非对称加密，最常用的一种 Signature 方式\n  |          公钥给别人，私钥自己留着；\n  |          发送给我的消息：别人用 *我的公钥* 加密；我用我的私钥解密\n  \\/\n Certificate   公钥加密的基础，概念：CA/issuer/subject/relying-party/...\n    |          按功能来说，分为两种\n    |\n    |---用于 *签名*（签发其他证书） 的证书\n    |---用于 *加解密* 的证书\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e证书（certificate）相关格式及其关系\u003c/mark\u003e\u003c/strong\u003e（沉重的历史负担）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  最常用的格式   |      信息比 X.509 更丰富的格式       |       其他格式\n\n  mTLS 等常用        Java 常用            微软常用\n                     .p7b .p7c          .pfx .p12\n\n  X.509 v3            PKCS#7               PKCS#12        SSH 证书    PGP 证书     =====\u0026gt;  证书格式\n      \\                 |                    /                                           （封装格式，证书结构体）\n       \\                |                   /\n        \\               |                  /\n         \\              |                 /\n          \\-------------+----------------/\n                        |\n                       ASN.1 （类似于 JSON、ProtoBuf 等）                          =====\u0026gt;  描述格式\n                        |\n          /-------------+----------------\\\n         /              |                 \\\n        /               |                  \\\n       /                |                   \\\n      /                 |                    \\\n   DER                 PEM                                                         =====\u0026gt;  编码格式\n二进制格式           文本格式                                                             （序列化）\n  .der            .pem .crt .cer\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e一些解释：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003eX.509 \u003cstrong\u003e\u003cmark\u003e从结构上定义证书中应该包含的信息\u003c/mark\u003e\u003c/strong\u003e，例如签发者、秘钥等等；\n  但使用哪个格式（例如 JSON 还是 YAML 还是 ASN.1）来描述，并不属于 X.509 的内容；\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eASN.1 是 X.509 的\u003cstrong\u003e\u003cmark\u003e描述格式\u003c/mark\u003e\u003c/strong\u003e（或者说用 ASN.1 格式来定义 X.509），类似于现在的 protobuf；\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eASN 中有很多数据类型，除了常见的整形、字符串等类型，还有一个称为 OID 的特殊类型，用点分整数表示，例如\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.5.4.3\u003c/code\u003e，有点像 URI 或 IP 地址，在设计上是全球唯一标识符，\u003c/li\u003e\n      \u003cli\u003eASN.1 只是一种描述格式，并未定义如何序列化为比特流，因此又引出了 \u003cstrong\u003e\u003cmark\u003eASN.1 的编码格式\u003c/mark\u003e\u003c/strong\u003e；\nASN.1 与其编码格式的关系，类似 \u003cstrong\u003e\u003cmark\u003eunicode 与 utf8 的关系\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eASN.1 的常见\u003cstrong\u003e\u003cmark\u003e编码格式\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eDER：一种二进制编码格式\u003c/li\u003e\n      \u003cli\u003ePEM：一种文本编码格式，通常以 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e.pem\u003c/code\u003e、\u003ccode\u003e.crt\u003c/code\u003e 或 \u003ccode\u003e.cer\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 为后缀。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e某些场景下，X.509 信息不够丰富，因此又设计了一些信息更丰富（例如可以包含证书\n链、秘钥）的证书封装格式，包括 PKCS #7 和 #12。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e仍然用 ASN.1 格式描述\u003c/li\u003e\n      \u003cli\u003e基本都是用 DER 编码\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e以上提到的东西，再加上 CA、信任仓库、信任链、certificate path validation、CSR、证书生命周期管理、\nSPIFFE 等还没有提到但也与加密相关的东西，统称为\u003cstrong\u003e\u003cmark\u003e公钥基础设施（PKI）\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e翻译时调整了一些配图，也加了几张新图，以方便展示和理解。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-前言\" id=\"markdown-toc-1-前言\"\u003e1 前言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-为什么要学习-pki\" id=\"markdown-toc-11-为什么要学习-pki\"\u003e1.1 为什么要学习 PKI\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-本文目的\" id=\"markdown-toc-12-本文目的\"\u003e1.2 本文目的\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-极简-tl-dr太长不读\" id=\"markdown-toc-13-极简-tl-dr太长不读\"\u003e1.3 极简 TL; DR（太长不读）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-术语\" id=\"markdown-toc-2-术语\"\u003e2 术语\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-entity实体\" id=\"markdown-toc-21-entity实体\"\u003e2.1 Entity（实体）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-identity身份\" id=\"markdown-toc-22-identity身份\"\u003e2.2 Identity（身份）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-identifier身份标识符\" id=\"markdown-toc-23-identifier身份标识符\"\u003e2.3 Identifier（身份标识符）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-claim声明--authentication认证\" id=\"markdown-toc-24-claim声明--authentication认证\"\u003e2.4 Claim（声明） \u0026amp; Authentication（认证）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-subscriber--ca--relying-party-rp\" id=\"markdown-toc-25-subscriber--ca--relying-party-rp\"\u003e2.5 Subscriber \u0026amp; CA \u0026amp; relying party (RP)\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#26-小结\" id=\"markdown-toc-26-小结\"\u003e2.6 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-mac消息认证码和-signature签名\" id=\"markdown-toc-3-mac消息认证码和-signature签名\"\u003e3 MAC（消息认证码）和 signature（签名）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-macmessage-authentication-code和-hmachash-based-mac\" id=\"markdown-toc-31-macmessage-authentication-code和-hmachash-based-mac\"\u003e3.1 MAC（message authentication code）和 HMAC（hash-based MAC）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-signature签名与不可否认性\" id=\"markdown-toc-32-signature签名与不可否认性\"\u003e3.2 Signature（签名）与不可否认性\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-小结\" id=\"markdown-toc-33-小结\"\u003e3.3 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-public-key-cryptography公钥加密或称非对称加密\" id=\"markdown-toc-4-public-key-cryptography公钥加密或称非对称加密\"\u003e4 Public key cryptography（公钥加密，或称非对称加密）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-秘钥对\" id=\"markdown-toc-41-秘钥对\"\u003e4.1 秘钥对\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-公钥加密系统使计算机能看到对方\" id=\"markdown-toc-42-公钥加密系统使计算机能看到对方\"\u003e4.2 公钥加密系统使计算机能“看到”对方\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-证书certificate计算机和代码的驾驶证\" id=\"markdown-toc-5-证书certificate计算机和代码的驾驶证\"\u003e5 证书（certificate）：计算机和代码的驾驶证\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-证书的内容subscriber-的公钥名字\" id=\"markdown-toc-51-证书的内容subscriber-的公钥名字\"\u003e5.1 证书的内容：（subscriber 的）公钥+名字\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-证书的本质基于对-issuer-公钥的信任来学习其他公钥\" id=\"markdown-toc-52-证书的本质基于对-issuer-公钥的信任来学习其他公钥\"\u003e5.2 证书的本质：基于对 issuer 公钥的信任来学习其他公钥\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-与驾照的类比\" id=\"markdown-toc-53-与驾照的类比\"\u003e5.3 与驾照的类比\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#54-证书内容解析举例\" id=\"markdown-toc-54-证书内容解析举例\"\u003e5.4 证书内容解析举例\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-证书编码格式及历史演进\" id=\"markdown-toc-6-证书编码格式及历史演进\"\u003e6 证书编码格式及历史演进\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-x509-证书\" id=\"markdown-toc-61-x509-证书\"\u003e6.1 X.509 证书\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#x509-起源电信领域\" id=\"markdown-toc-x509-起源电信领域\"\u003eX.509 起源：电信领域\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-asn1数据抽象格式\" id=\"markdown-toc-62-asn1数据抽象格式\"\u003e6.2 ASN.1：数据抽象格式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-oid-object-identitfier\" id=\"markdown-toc-63-oid-object-identitfier\"\u003e6.3 OID (object identitfier)\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-asn1-编码格式\" id=\"markdown-toc-64-asn1-编码格式\"\u003e6.4 ASN.1 编码格式\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#der-distinguished-encoding-rules二进制格式\" id=\"markdown-toc-der-distinguished-encoding-rules二进制格式\"\u003eDER (distinguished encoding rules)：二进制格式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#pem-privacy-enhanced-email文本格式\" id=\"markdown-toc-pem-privacy-enhanced-email文本格式\"\u003ePEM (privacy enhanced email)：文本格式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#65-比-x509-信息更丰富的证书打包封装格式\" id=\"markdown-toc-65-比-x509-信息更丰富的证书打包封装格式\"\u003e6.5 比 X.509 信息更丰富的证书打包（封装）格式\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#pkcs-7java-中常用\" id=\"markdown-toc-pkcs-7java-中常用\"\u003ePKCS #7：Java 中常用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#pkcs-12微软常用\" id=\"markdown-toc-pkcs-12微软常用\"\u003ePKCS #12：微软常用\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#66-秘钥编解码\" id=\"markdown-toc-66-秘钥编解码\"\u003e6.6 秘钥编解码\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#pem-编码的-pkcs8-格式私钥\" id=\"markdown-toc-pem-编码的-pkcs8-格式私钥\"\u003ePEM 编码的 PKCS#8 格式私钥\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#密码加密的私钥\" id=\"markdown-toc-密码加密的私钥\"\u003e密码加密的私钥\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#公钥私钥常见扩展名\" id=\"markdown-toc-公钥私钥常见扩展名\"\u003e公钥、私钥常见扩展名\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#67-小结\" id=\"markdown-toc-67-小结\"\u003e6.7 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#7-pki-public-key-infrastructure\" id=\"markdown-toc-7-pki-public-key-infrastructure\"\u003e7 PKI (Public Key Infrastructure)\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-web-pki-vs-internal-pki\" id=\"markdown-toc-71-web-pki-vs-internal-pki\"\u003e7.1 Web PKI vs Internal PKI\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-有了-web-pki为什么还要使用自己的-internal-pki\" id=\"markdown-toc-72-有了-web-pki为什么还要使用自己的-internal-pki\"\u003e7.2 有了 Web PKI，为什么还要使用自己的 internal PKI？\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#8-trust--trustworthiness\" id=\"markdown-toc-8-trust--trustworthiness\"\u003e8 Trust \u0026amp; Trustworthiness\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#81-trust-stores信任仓库\" id=\"markdown-toc-81-trust-stores信任仓库\"\u003e8.1 Trust Stores（信任仓库）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#预配置信任的根证书\" id=\"markdown-toc-预配置信任的根证书\"\u003e预配置信任的根证书\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#信任链\" id=\"markdown-toc-信任链\"\u003e信任链\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#根证书自签名\" id=\"markdown-toc-根证书自签名\"\u003e根证书自签名\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#信任仓库的来源\" id=\"markdown-toc-信任仓库的来源\"\u003e信任仓库的来源\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#操作系统的信任仓库\" id=\"markdown-toc-操作系统的信任仓库\"\u003e操作系统的信任仓库\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#82-trustworthiness可靠性\" id=\"markdown-toc-82-trustworthiness可靠性\"\u003e8.2 Trustworthiness（可靠性）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#83-federation\" id=\"markdown-toc-83-federation\"\u003e8.3 Federation\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#证书欺骗的风险\" id=\"markdown-toc-证书欺骗的风险\"\u003e证书欺骗的风险\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#改进措施\" id=\"markdown-toc-改进措施\"\u003e改进措施\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#internal-pki-使用单独的信任仓库\" id=\"markdown-toc-internal-pki-使用单独的信任仓库\"\u003eInternal PKI 使用单独的信任仓库\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#internal-pki-细粒度控制caa--spiffe\" id=\"markdown-toc-internal-pki-细粒度控制caa--spiffe\"\u003eInternal PKI 细粒度控制：CAA \u0026amp; SPIFFE\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#9-什么是证书权威certificate-authority\" id=\"markdown-toc-9-什么是证书权威certificate-authority\"\u003e9 什么是证书权威（Certificate Authority）？\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#91-web-pki-不能自动化签发证书\" id=\"markdown-toc-91-web-pki-不能自动化签发证书\"\u003e9.1 Web PKI 不能自动化签发证书\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#92-intermediates-chains-and-bundling\" id=\"markdown-toc-92-intermediates-chains-and-bundling\"\u003e9.2 Intermediates, Chains, and Bundling\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#93-rpcertificate-path-validation\" id=\"markdown-toc-93-rpcertificate-path-validation\"\u003e9.3 RP：Certificate path validation\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#10-秘钥和证书的生命周期\" id=\"markdown-toc-10-秘钥和证书的生命周期\"\u003e10 秘钥和证书的生命周期\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#101-naming-things命名相关\" id=\"markdown-toc-101-naming-things命名相关\"\u003e10.1 Naming things（命名相关）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#dn-distinguished-names\" id=\"markdown-toc-dn-distinguished-names\"\u003eDN (distinguished names)\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#san-subject-alternative-name\" id=\"markdown-toc-san-subject-alternative-name\"\u003eSAN (subject alternative name)\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#102-生成-key-pairs\" id=\"markdown-toc-102-生成-key-pairs\"\u003e10.2 生成 key pairs\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#103-issuance确保证书中的信息都是对的\" id=\"markdown-toc-103-issuance确保证书中的信息都是对的\"\u003e10.3 Issuance（确保证书中的信息都是对的）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#1031-certificate-signing-requests证书签名请求pkcs10\" id=\"markdown-toc-1031-certificate-signing-requests证书签名请求pkcs10\"\u003e10.3.1 Certificate signing requests（证书签名请求，PKCS#10）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1032-identity-proofing身份证明过程\" id=\"markdown-toc-1032-identity-proofing身份证明过程\"\u003e10.3.2 Identity proofing（身份证明过程）\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#web-pki-证明身份过程\" id=\"markdown-toc-web-pki-证明身份过程\"\u003eWeb PKI 证明身份过程\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#internal-pki-证明身份过程\" id=\"markdown-toc-internal-pki-证明身份过程\"\u003eInternal PKI 证明身份过程\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#104-expiration过期\" id=\"markdown-toc-104-expiration过期\"\u003e10.4 Expiration（过期）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#105-renewal续期\" id=\"markdown-toc-105-renewal续期\"\u003e10.5 Renewal（续期）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#1051-web-pki-证书续期\" id=\"markdown-toc-1051-web-pki-证书续期\"\u003e10.5.1 Web PKI 证书续期\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1052-internal-pki-证书续期\" id=\"markdown-toc-1052-internal-pki-证书续期\"\u003e10.5.2 Internal PKI 证书续期\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1053-小结\" id=\"markdown-toc-1053-小结\"\u003e10.5.3 小结\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#106-revocation撤销\" id=\"markdown-toc-106-revocation撤销\"\u003e10.6 Revocation（撤销）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#1061--主动撤销的困难\" id=\"markdown-toc-1061--主动撤销的困难\"\u003e10.6.1  主动撤销的困难\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1062-internal-pki被动撤销机制\" id=\"markdown-toc-1062-internal-pki被动撤销机制\"\u003e10.6.2 Internal PKI：被动撤销机制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1063-主动检查机制crlcertificate-revocation-lists\" id=\"markdown-toc-1063-主动检查机制crlcertificate-revocation-lists\"\u003e10.6.3 主动检查机制：CRL（Certificate Revocation Lists）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1064-主动检查机制ocsponline-certificate-signing-protocol\" id=\"markdown-toc-1064-主动检查机制ocsponline-certificate-signing-protocol\"\u003e10.6.4 主动检查机制：OCSP（Online Certificate Signing Protocol）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#1065-主动检查机制ocsp-stapling合订绑定\" id=\"markdown-toc-1065-主动检查机制ocsp-stapling合订绑定\"\u003e10.6.5 主动检查机制：OCSP stapling（合订，绑定）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#11-使用证书\" id=\"markdown-toc-11-使用证书\"\u003e11 使用证书\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#12-结束语\" id=\"markdown-toc-12-结束语\"\u003e12 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#13-延伸阅读译注\" id=\"markdown-toc-13-延伸阅读译注\"\u003e13 延伸阅读（译注）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-前言\"\u003e1 前言\u003c/h1\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e证书\u003c/mark\u003e\u003c/strong\u003e（certificates）与 \u003cstrong\u003e\u003cmark\u003ePKI\u003c/mark\u003e\u003c/strong\u003e（public key\ninfrastructure，公钥基础设施）很难。我认识的很多非常聪明的人也会绕过这一主题。\n我个人也很长时间没去碰这些内容，但说起来很讽刺，我没去碰的原因是不懂：\n因为不懂，所以不好意思问 —— 然后更不懂，自然更不好意思问 —— 如此形成恶性循环。\u003c/p\u003e\n\n\u003cp\u003e但最终，我还是硬着头皮学习了这些东西。\u003c/p\u003e\n\n\u003ch2 id=\"11-为什么要学习-pki\"\u003e1.1 为什么要学习 PKI\u003c/h2\u003e\n\n\u003cp\u003e我觉得\n\u003cstrong\u003e\u003cmark\u003ePKI 能使一个人在加解密层面（乃至更大的安全层面）去思考如何定义一个系统\u003c/mark\u003e\u003c/strong\u003e。\n具体来说，PKI 技术，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e都是\u003cstrong\u003e\u003cmark\u003e通用的、厂商无关的\u003c/mark\u003e\u003c/strong\u003e（universal and vendor neutral）；\u003c/li\u003e\n  \u003cli\u003e适用于任何地方，因此即使系统可分布在世界各地，彼此之间也能安全地通信；\u003c/li\u003e\n  \u003cli\u003e在概念上很简单，并且非常灵活；如果使用我们的 \u003ca href=\"https://smallstep.com/blog/use-tls.html\"\u003eTLS everywhere\u003c/a\u003e 模型，\n那甚至连 VPN 都不需要了。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e总之一句话：\u003cstrong\u003e\u003cmark\u003e非常强大！\u003c/mark\u003e\u003c/strong\u003e\u003c/p\u003e\n\n\u003ch2 id=\"12-本文目的\"\u003e1.2 本文目的\u003c/h2\u003e\n\n\u003cp\u003e在深入理解了 PKI 之后，我很\u003cstrong\u003e\u003cmark\u003e后悔没有早点学这些东西\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ePKI 非常强大且有趣，虽然它背后的数学原理很复杂，\u003cstrong\u003e\u003cmark\u003e一些相关标准也设计地非常愚蠢\u003c/mark\u003e\u003c/strong\u003e\n  （巴洛克式的复杂），但其 \u003cstrong\u003e\u003cmark\u003e核心概念其实非常简单\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e证书是识别（identify）代码和设备的最佳方式\u003c/mark\u003e\u003c/strong\u003e，\n  而 identity（身份）对安全、监控、指标等很多东西都非常有用；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e使用证书并不是太难\u003c/mark\u003e\u003c/strong\u003e，不会难于学习一门新语言或一种新数据库。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e那为什么大家对这些内容望而却步呢？我认为主要是\u003cstrong\u003e\u003cmark\u003e缺少很好的文档\u003c/mark\u003e\u003c/strong\u003e，所以经常看地云里雾里，半途而弃。\u003c/p\u003e\n\n\u003cp\u003e本文试图弥补这一缺失。我认为大部分工程师花一个小时读完本文后，都将了解到\n\u003cstrong\u003e\u003cmark\u003e关于加解密的那些最重要概念和使用场景\u003c/mark\u003e\u003c/strong\u003e —— 这正是本文的目的 ——\n一小时只是很小的一个投资，而且这些内容是无法通过其他途径学到的。\u003c/p\u003e\n\n\u003cp\u003e本文将用到以下两个开源工具：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://smallstep.com/cli\"\u003estep CLI\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://smallstep.com/certificates\"\u003estep certificates\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"13-极简-tl-dr太长不读\"\u003e1.3 极简 TL; DR（太长不读）\u003c/h2\u003e\n\n\u003cp\u003e证书和 PKI 的目的：\u003cstrong\u003e\u003cmark\u003e将名字关联到公钥（bind names to public keys）\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这是\u003cstrong\u003e\u003cmark\u003e关于证书和 PKI 的最高抽象\u003c/mark\u003e\u003c/strong\u003e，其他都属于实现细节。\u003c/p\u003e\n\n\u003ch1 id=\"2-术语\"\u003e2 术语\u003c/h1\u003e\n\n\u003cp\u003e本文将用到以下术语。\u003c/p\u003e\n\n\u003ch2 id=\"21-entity实体\"\u003e2.1 Entity（实体）\u003c/h2\u003e\n\n\u003cp\u003eEntity 是\u003cstrong\u003e\u003cmark\u003e任何存在的东西\u003c/mark\u003e\u003c/strong\u003e（anything that exists） —— 即使\n\u003cstrong\u003e\u003cmark\u003e只在逻辑或概念上存在\u003c/mark\u003e\u003c/strong\u003e（even if only exists logically or conceptually）。\n例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e你用的计算机是一个 entity，\u003c/li\u003e\n  \u003cli\u003e你写的代码也是一个 entity，\u003c/li\u003e\n  \u003cli\u003e你自己也是一个 entity，\u003c/li\u003e\n  \u003cli\u003e你早餐吃的杂粮饼也是一个 entity，\u003c/li\u003e\n  \u003cli\u003e你六岁时见过的\u003cstrong\u003e\u003cmark\u003e鬼\u003c/mark\u003e\u003c/strong\u003e也是一个 entity —— 即使你妈妈告诉你世界上并没有鬼，这只是你的臆想。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"22-identity身份\"\u003e2.2 Identity（身份）\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e每个 entity（实体）都有一个 identity（身份）\u003c/mark\u003e\u003c/strong\u003e。\n要精确定义这个概念比较困难，这么来说吧：identity 是\u003cstrong\u003e\u003cmark\u003e使你之所以为你\u003c/mark\u003e\u003c/strong\u003e\n（what makes you you）的东西，懂吗？\u003c/p\u003e\n\n\u003cp\u003e具体到计算机领域，identity 通常\u003cstrong\u003e\u003cmark\u003e用一系列属性来表示，描述某个具体的 entity\u003c/mark\u003e\u003c/strong\u003e，\n这里的属性包括 group、age、location、favorite color、shoe size 等等。\u003c/p\u003e\n\n\u003ch2 id=\"23-identifier身份标识符\"\u003e2.3 Identifier（身份标识符）\u003c/h2\u003e\n\n\u003cp\u003eIdentifier 跟 identity 还不是一个东西：每个 identifier 都是一个\u003cstrong\u003e\u003cmark\u003e唯一标识符\u003c/mark\u003e\u003c/strong\u003e，\n也\u003cstrong\u003e\u003cmark\u003e唯一地关联到某个有 identity 的 entity\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e例如，我是 Mike，但 Mike 并不是我的 identity，而只是个 name —— 虽然二者在我们\n小范围的讨论中是同义的。\u003c/p\u003e\n\n\u003ch2 id=\"24-claim声明--authentication认证\"\u003e2.4 Claim（声明） \u0026amp; Authentication（认证）\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个 entity 能 \u003cstrong\u003e\u003cmark\u003eclaim\u003c/mark\u003e\u003c/strong\u003e（声明）说，它\u003cstrong\u003e\u003cmark\u003e拥有某个或某些 name\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e其他 entity 能够对这个 claim 进行\u003cstrong\u003e\u003cmark\u003e认证\u003c/mark\u003e\u003c/strong\u003e（authenticate），以确认这份声明的真假。\u003c/p\u003e\n\n    \u003cp\u003e一般来说，\u003cstrong\u003e\u003cmark\u003e认证的目的是确认某些 claim 的合法性\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003eClaim 不是只能关联到 name，还可以关联到别的东西。例如，我能 claim 任何东西：\nmy age, your age, access rights, the meaning of life 等等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"25-subscriber--ca--relying-party-rp\"\u003e2.5 Subscriber \u0026amp; CA \u0026amp; relying party (RP)\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e能作为一个证书的 subject 的 entity\u003c/mark\u003e\u003c/strong\u003e，称为 \u003cstrong\u003e\u003cmark\u003esubscriber\u003c/mark\u003e\u003c/strong\u003e（证书 owner）或 \u003cstrong\u003e\u003cmark\u003eend entity\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e对应地，subscriber 的证书有时也称为 end entity certificates 或 leaf certificates，\n  原因在后面讨论 certificate chains 时会介绍。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eCA（certificate authority，证书权威）是\u003cstrong\u003e\u003cmark\u003e给 subscriber 颁发证书的 entity\u003c/mark\u003e\u003c/strong\u003e，是一种 certificate issuer（证书颁发者）。\u003c/p\u003e\n\n    \u003cp\u003eCA 的证书，通常称为 \u003cstrong\u003e\u003cmark\u003eroot certificate\u003c/mark\u003e\u003c/strong\u003e 或 intermediate certificate，具体取决于 CA 类型。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eRelying party 是 \u003cstrong\u003e\u003cmark\u003e使用证书的用户\u003c/mark\u003e\u003c/strong\u003e（certificate user），它验证由 CA 颁发（给 subscriber）的证书是否合法。\u003c/p\u003e\n\n    \u003cp\u003e一个 entity 可以同时是一个 subscriber 和一个 relying party。\n  也就是说，单个 entity 既有自己的证书，又使用其他证书来认证 remote peers，\n  例如双向 TLS（mutual TLS，\u003cstrong\u003e\u003cmark\u003emTLS\u003c/mark\u003e\u003c/strong\u003e）场景。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"26-小结\"\u003e2.6 小结\u003c/h2\u003e\n\n\u003cp\u003e对于我们接下来的讨论，这些术语就够了。下面将进入正题，看如何在实际中实现\n\u003cstrong\u003e\u003cmark\u003e证书的声明和认证\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e想了解更多相关术语，可参考 \u003ca href=\"https://tools.ietf.org/html/rfc4949\"\u003eRFC 4949\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"3-mac消息认证码和-signature签名\"\u003e3 MAC（消息认证码）和 signature（签名）\u003c/h1\u003e\n\n\u003ch2 id=\"31-macmessage-authentication-code和-hmachash-based-mac\"\u003e3.1 MAC（message authentication code）和 HMAC（hash-based MAC）\u003c/h2\u003e\n\n\u003cp\u003eMAC（消息认证码）是一\u003cstrong\u003e\u003cmark\u003e小段数据\u003c/mark\u003e\u003c/strong\u003e，用于验证某个 entity 发送的消息\u003cstrong\u003e\u003cmark\u003e未被篡改\u003c/mark\u003e\u003c/strong\u003e。\n其基本原理如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/HMAC.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eMAC/HMAC 原理。图片来自：\u003ca href=\"https://www.okta.com/identity-101/hmac/\"\u003eokta.com\u003c/a\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e对\u003cstrong\u003e\u003cmark\u003e消息\u003c/mark\u003e\u003c/strong\u003e（message）和双方都知道的一个\u003cstrong\u003e\u003cmark\u003e密码\u003c/mark\u003e\u003c/strong\u003e\n（shared secret，a password）做哈希，\u003cstrong\u003e\u003cmark\u003e得到的哈希值\u003c/mark\u003e\u003c/strong\u003e就是 MAC；\u003c/li\u003e\n  \u003cli\u003e发送方将消息连带 MAC 一起发给接收方；\u003c/li\u003e\n  \u003cli\u003e接收方收到消息之后，用同一个密码来计算 MAC，然后跟消息中提供的 MAC 对比。如果相同，就证明未被篡改。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e关于哈希：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e哈希是单向的，因此无法从输出反推输入；这一点至关重要，否则截获消息的人就可以根据 MAC 和哈希函数反推 secrets。\u003c/li\u003e\n  \u003cli\u003e生成 MAC 的\u003cstrong\u003e\u003cmark\u003e哈希算法选择也至关重要\u003c/mark\u003e\u003c/strong\u003e，本文不会展开，但提醒一点：不要试图用自己设计的 MAC 算法。\u003c/li\u003e\n  \u003cli\u003e最常用的 MAC 算法是 \u003ca href=\"https://en.wikipedia.org/wiki/HMAC\"\u003eHMAC\u003c/a\u003e（\u003cstrong\u003e\u003cmark\u003ehash-based message authentication code\u003c/mark\u003e\u003c/strong\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"32-signature签名与不可否认性\"\u003e3.2 Signature（签名）与不可否认性\u003c/h2\u003e\n\n\u003cp\u003e讨论 MAC 其实是为了\u003cstrong\u003e\u003cmark\u003e引出 signature（签名）\u003c/mark\u003e\u003c/strong\u003e这一主题。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e签名在概念上与 MAC 类似\u003c/mark\u003e\u003c/strong\u003e，但\u003cstrong\u003e\u003cmark\u003e不是用共享 secret 的方式\u003c/mark\u003e\u003c/strong\u003e，\n而是使用一对秘钥（key pair）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eMAC 方式中，至少有两个 entity 需要知道共享的 secret，也就是消息的发送方和接\n收方。\u003cstrong\u003e\u003cmark\u003e双方都可以生成 MAC\u003c/mark\u003e\u003c/strong\u003e，因此给定一个合法的 MAC，我们是\n\u003cstrong\u003e\u003cmark\u003e无法知道是谁生成的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e签名就不同了：签名能用\u003cstrong\u003e\u003cmark\u003e公钥（public key）验证\u003c/mark\u003e\u003c/strong\u003e，但只能用相应的\n\u003cstrong\u003e\u003cmark\u003e私钥（private key）生成\u003c/mark\u003e\u003c/strong\u003e。\n因此对于接收方来说，它只能验证签名是否合法，而无法生成同样的签名。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果只有一个 entity 知道秘钥，那这种特性称为 \u003cstrong\u003e\u003cmark\u003enon-repudiation\u003c/mark\u003e\u003c/strong\u003e\n（不可否认性）：持有私钥的人无法否认（repudiate）数据是由他签名的这一事实。\u003c/p\u003e\n\n\u003ch2 id=\"33-小结\"\u003e3.3 小结\u003c/h2\u003e\n\n\u003cp\u003eMAC 与 signature 都叫做签名，是因为它们和现实世界中的签名是很像的。例如，如果想\n让某人同意某事，并且事后还能证明他们当时的确同意了，就把问题写下来，然后让他们\n手写签字（签名）。\u003c/p\u003e\n\n\u003ch1 id=\"4-public-key-cryptography公钥加密或称非对称加密\"\u003e4 Public key cryptography（公钥加密，或称非对称加密）\u003c/h1\u003e\n\n\u003cp\u003e证书和 PKI 的基础是\u003cstrong\u003e\u003cmark\u003e公钥加密\u003c/mark\u003e\u003c/strong\u003e（public key cryptography），\n也叫\u003cstrong\u003e\u003cmark\u003e非对称加密\u003c/mark\u003e\u003c/strong\u003e（asymmetric cryptography）。\u003c/p\u003e\n\n\u003ch2 id=\"41-秘钥对\"\u003e4.1 秘钥对\u003c/h2\u003e\n\n\u003cp\u003e公钥加密系统使用秘钥对（key pair）加解密。一个秘钥对包含：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e一个私钥（private key）：owner 持有，\u003cstrong\u003e\u003cmark\u003e解密用，不要分享给任何人\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n    \u003cp\u003e这一点非常重要，值得重复一遍：\u003cstrong\u003e\u003cmark\u003e公钥加密系统的安全性取决于私钥（private key）的机密性\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e一个公钥（public key）：\u003cstrong\u003e\u003cmark\u003e加密用\u003c/mark\u003e\u003c/strong\u003e，可分发和共享给别人；\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e秘钥可以做的事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e加解密：公钥（public key）加密，私钥（private key）解密。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e签名\u003c/mark\u003e\u003c/strong\u003e：\u003cstrong\u003e\u003cmark\u003e私钥（private key）对数据进行签名\u003c/mark\u003e\u003c/strong\u003e（sign some data）；\n任何有公钥的人都可以\u003cstrong\u003e\u003cmark\u003e对签名进行验证\u003c/mark\u003e\u003c/strong\u003e，证明这个签名确实是私钥生成的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"42-公钥加密系统使计算机能看到对方\"\u003e4.2 公钥加密系统使计算机能“看到”对方\u003c/h2\u003e\n\n\u003cp\u003e公钥加密是数学给计算机科学的神秘礼物，\n\u003ca href=\"https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html\"\u003e其数学基础\u003c/a\u003e\n显然很复杂，但如果只是使用，那并不需要理解它的每一步数学原理。\n公钥加密使计算机能做一些之前无法做的事情：它们\u003cstrong\u003e\u003cmark\u003e现在能看到对方是谁了\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这句话的意思是说，公钥加密使一台计算（或代码）能向其他计算机或程序证明\n\u003cstrong\u003e\u003cmark\u003e不用直接分享某些信息，它也能知道该信息\u003c/mark\u003e\u003c/strong\u003e。更具体来说，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e以前要证明你有密码，就必须向别人展示这个密码。但展示之后，任何有这个密码的人就都能使用它了。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e私钥却与此不同。你能通过公钥对我的身份进行认证（authenticate my identity），但却无法假冒我。\u003c/p\u003e\n\n    \u003cp\u003e例如，你发给我一个大随机数，我对这个随机数进行签名，然后将再发送给你。\n  你能用公钥对这个签名进行认证，确认这个签名（消息）确实来自我。\n  这就是一种证明你在和我（而不是别的其他的人）通信的很好证据。这使得网络上的\n  计算机能有效地知道它们在和谁通信。\u003c/p\u003e\n\n    \u003cp\u003e这听起来是一件如此理所当然的事情，但仔细地想一下，网络上只有流动的 0 和 1，\n  你怎么知道消息来自谁，在和谁通信？因此公钥加密系统是一个非常伟大的发明。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"5-证书certificate计算机和代码的驾驶证\"\u003e5 证书（certificate）：计算机和代码的驾驶证\u003c/h1\u003e\n\n\u003cp\u003e前面说道，公钥加密系统使我们能知道和谁在通信，但这个的前提是：\n\u003cstrong\u003e\u003cmark\u003e要知道（有）对方的公钥\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e那么，如果\u003cstrong\u003e\u003cmark\u003e对方不知道我的公钥怎么办\u003c/mark\u003e\u003c/strong\u003e？\n这就轮到证书出场了。\u003c/p\u003e\n\n\u003cp\u003e想一下，我们需求其实非常简单：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先要将\u003cstrong\u003e\u003cmark\u003e公钥和它的 owner\u003c/mark\u003e\u003c/strong\u003e 信息发给对方；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e但光有这个信息还不行，\u003cstrong\u003e\u003cmark\u003e还要让对方相信这些信息\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n    \u003cp\u003e证书就是用来解决这个问题的，解决方式是\u003cstrong\u003e\u003cmark\u003e请一个双方都信任的权威机构\u003c/mark\u003e\u003c/strong\u003e\n  对以上信息作出证明（签名）。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"51-证书的内容subscriber-的公钥名字\"\u003e5.1 证书的内容：（subscriber 的）公钥+名字\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e证书是一个数据结构，其中包含一个 public key 和一个 name；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e权威机构\u003c/mark\u003e\u003c/strong\u003e对证书进行\u003cstrong\u003e\u003cmark\u003e签名\u003c/mark\u003e\u003c/strong\u003e，签名的大概意思是：public key xxx 关联到了 name xx；\u003c/p\u003e\n\n    \u003cp\u003e对证书进行签名的 entity 称为 \u003cstrong\u003e\u003cmark\u003eissuer\u003c/mark\u003e\u003c/strong\u003e（或 certificate authority, CA），\n 证书中的 entity 称为 \u003cstrong\u003e\u003cmark\u003esubject\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e举个例子，如果某个 Issuer 为 Bob 签发了一张证书，其中的内容就可以解读如下：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cem\u003eSome Issuer\u003c/em\u003e says \u003cem\u003eBob\u003c/em\u003e’s public key is 01:23:42…\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/drivers-license-cert.jpg\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003e证书是权威机构颁发的身份证明，\u003cmark\u003e并没有什么神奇之处\u003c/mark\u003e\u003c/p\u003e\n\n\u003cp\u003e其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSome Issuer\u003c/code\u003e 是证书的签发者（证书权威），证书是为了证明这是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBob\u003c/code\u003e 的公钥，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSome Issuer\u003c/code\u003e 也是这个声明的签字方。\u003c/p\u003e\n\n\u003ch2 id=\"52-证书的本质基于对-issuer-公钥的信任来学习其他公钥\"\u003e5.2 证书的本质：基于对 issuer 公钥的信任来学习其他公钥\u003c/h2\u003e\n\n\u003cp\u003e由上可知，如果知道 \u003cem\u003eSome Issuer\u003c/em\u003e 的公钥，就可以通过\u003cstrong\u003e\u003cmark\u003e验证签名\u003c/mark\u003e\u003c/strong\u003e的方式来\n\u003cstrong\u003e\u003cmark\u003e对它（用私钥）签发的证书\u003c/mark\u003e\u003c/strong\u003e进行认证（authenticate）。\n如果如果你信任 \u003cem\u003eSome Issuer\u003c/em\u003e，那你就可以信任这个声明。\u003c/p\u003e\n\n\u003cp\u003e因此，证书使大家能\u003cstrong\u003e\u003cmark\u003e基于对 issuer 公钥的信任和知识，来学习到其他 entity 的公钥\u003c/mark\u003e\u003c/strong\u003e\n（上面的例子中就是 Bob）。这就是证书的本质。\u003c/p\u003e\n\n\u003ch2 id=\"53-与驾照的类比\"\u003e5.3 与驾照的类比\u003c/h2\u003e\n\n\u003cp\u003e证书就像是计算机/代码的驾照或护照。如果你之前从未见过我，但信任车管局，那你可以\n用我的驾照做认证：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先验证驾照是真的（检查 hologram 等），\u003c/li\u003e\n  \u003cli\u003e然后人脸和照片上对的上，\u003c/li\u003e\n  \u003cli\u003e然后看名字是我，等等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/license-vs-cert.jpg\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e计算机用\u003cstrong\u003e\u003cmark\u003e证书做类似的事情\u003c/mark\u003e\u003c/strong\u003e：如果之前从未和其他电脑通信，但信任\n一些证书权威，那可以用证书来认证：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先验证证书是合法的（用证书签发者的公钥检查签名等），\u003c/li\u003e\n  \u003cli\u003e然后提取证书中的（subscriber 的）公钥和名字，\u003c/li\u003e\n  \u003cli\u003e然后用 subscriber 的公钥，通过网络验证该 subscriber 的签名；\u003c/li\u003e\n  \u003cli\u003e查看名字是否正确等等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"54-证书内容解析举例\"\u003e5.4 证书内容解析举例\u003c/h2\u003e\n\n\u003cp\u003e下面是个真实的证书：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/step-certificate-inspect.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e还是与驾照类比：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e驾照：描述了你是否有资格开车；\u003c/li\u003e\n  \u003cli\u003e证书：描述你是否是一个 CA，你的公钥能否用来签名或加密。\u003c/li\u003e\n  \u003cli\u003e二者都有有效期。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e上图中有大量的细节，很多东西将在下面讨论到。但归根结底还是本文最开始总结的那句话\n：\u003cstrong\u003e\u003cmark\u003e证书不过是一个将名字关联到公钥（bind names to public keys）的东西\u003c/mark\u003e\u003c/strong\u003e。\n其他都是实现细节。\u003c/p\u003e\n\n\u003ch1 id=\"6-证书编码格式及历史演进\"\u003e6 证书编码格式及历史演进\u003c/h1\u003e\n\n\u003cp\u003e接下来看一看证书在底层的表示（represented as bits and bytes）。\u003c/p\u003e\n\n\u003cp\u003e这部分内容\u003cstrong\u003e\u003cmark\u003e复杂且相当令人沮丧\u003c/mark\u003e\u003c/strong\u003e。事实上，我怀疑\u003cstrong\u003e\u003cmark\u003e证书和秘钥诡异的编码方式\u003c/mark\u003e\u003c/strong\u003e\n是导致 PKI 如此混乱和令人沮丧的根源。\u003c/p\u003e\n\n\u003ch2 id=\"61-x509-证书\"\u003e6.1 X.509 证书\u003c/h2\u003e\n\n\u003cp\u003e一般来说，人们\u003cstrong\u003e\u003cmark\u003e提到“证书”而没有加额外限定词时\u003c/mark\u003e\u003c/strong\u003e，指的都是 X.509 v3\n证书。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e更准确地说，他们指的是\n\u003ca href=\"https://tools.ietf.org/html/rfc5280\"\u003eRFC 5280\u003c/a\u003e 中描述、\nCA/Browser Forum \u003ca href=\"https://cabforum.org/baseline-requirements-documents/\"\u003eBaseline Requirements\u003c/a\u003e中进一步完善的\nPKIX 变种。\u003c/li\u003e\n  \u003cli\u003e换句话说，指的是\u003cstrong\u003e\u003cmark\u003e浏览器理解并用来做 HTTPS（HTTP over TLS）的那些证书\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e也有其他的证书格式，例如著名的 \u003cstrong\u003e\u003cmark\u003eSSH 和 PGP 都有它们各自的格式\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e本文主要关注 X.509，理解了 X.509，其他格式都是类似的。\n由于这些证书使用广泛，因此有很好的函数库，而且也用在浏览器之外的场景。毫无疑问，它们是\ninternal PKI 颁发的最常见证书格式。重要的是，这些证书在很多 TLS/HTTPS 客户端/服\n务端程序中都是开箱即用的。\u003c/p\u003e\n\n\u003ch3 id=\"x509-起源电信领域\"\u003eX.509 起源：电信领域\u003c/h3\u003e\n\n\u003cp\u003e了解一点 X.509 的历史对理解它会有很大帮助。\u003c/p\u003e\n\n\u003cp\u003eX.509 在 \u003cstrong\u003e\u003cmark\u003e1988\u003c/mark\u003e\u003c/strong\u003e 年作为国际电信联盟（ITU）X.500 项目的一部分首次标准化。\n这是通信（telecom）领域的标准，想通过它构建一个\u003cstrong\u003e\u003cmark\u003e全球电话簿\u003c/mark\u003e\u003c/strong\u003e（global telephone book）。\n虽然这个项目没有成功，但却留下了一些遗产，X.509 就是其中之一。\u003c/p\u003e\n\n\u003cp\u003e如果查看 X.509 的证书，会看到其中包含了 locality、state、country 等信息，\n之前可能会有疑问为什么为 web 设计的证书会有这些东西，现在应该明白了，因为\n\u003cstrong\u003e\u003cmark\u003eX.509 并不是为 web 设计的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/cert-dn.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"62-asn1数据抽象格式\"\u003e6.2 ASN.1：数据抽象格式\u003c/h2\u003e\n\n\u003cp\u003eX.509 构建在 ASN.1 （Abstract Syntax Notation，抽象语法标注）之上，后者是另一个\nITU-T 标准 (X.208 and X.680)。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eASN.1 定义数据类型\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e可以将 ASN.1 理解成 \u003cstrong\u003e\u003cmark\u003eX.509 的 JSON\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e但实际上\u003cstrong\u003e\u003cmark\u003e更像 protobuf\u003c/mark\u003e\u003c/strong\u003e、thrift 或 SQL DDL。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eRFC 5280 \u003cstrong\u003e\u003cmark\u003e用 ASN.1 来定义 X.509 证书\u003c/mark\u003e\u003c/strong\u003e，其中包括名字、秘钥、签名等信息。\u003c/p\u003e\n\n\u003ch2 id=\"63-oid-object-identitfier\"\u003e6.3 OID (object identitfier)\u003c/h2\u003e\n\n\u003cp\u003eASN.1 除了有常见的数据类型，如整形、字符串、集合、列表等，\n还有一个\u003cstrong\u003e\u003cmark\u003e不常见但很重要的类型：OID\u003c/mark\u003e\u003c/strong\u003e（object identifier，\u003cstrong\u003e\u003cmark\u003e对象标识符\u003c/mark\u003e\u003c/strong\u003e）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eOID \u003cstrong\u003e\u003cmark\u003e与 URI 有些像\u003c/mark\u003e\u003c/strong\u003e，但比 URI 要怪。\u003c/li\u003e\n  \u003cli\u003eOID （在设计上）是\u003cstrong\u003e\u003cmark\u003e全球唯一标识符\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e在结构上，OID 是在一个 hierarchical namespace 中的一个整数序列（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.5.4.3\u003c/code\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可以用 OID 来 tag 一段数据的类型。例如，一个 string 本来只是一个 string，但可\n以 tag 一个 OID \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.5.4.3\u003c/code\u003e，然后就\u003cstrong\u003e\u003cmark\u003e变成了一个特殊 string\u003c/mark\u003e\u003c/strong\u003e：这是\n\u003cstrong\u003e\u003cmark\u003eX.509 的通用名字（common name）\u003c/mark\u003e\u003c/strong\u003e 字段。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/oids.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"64-asn1-编码格式\"\u003e6.4 ASN.1 编码格式\u003c/h2\u003e\n\n\u003cp\u003eASN.1 只是\u003cstrong\u003e\u003cmark\u003e抽象\u003c/mark\u003e\u003c/strong\u003e（abstract），因为这个标准并未定义在数据层应该如何表示（represented as bits and bytes）。\nASN.1 与其编码格式的关系，就像 \u003cstrong\u003e\u003cmark\u003eunicode 与 utf8 的区别\u003c/mark\u003e\u003c/strong\u003e。\n因此，有很多种\u003cstrong\u003e\u003cmark\u003e编码规则\u003c/mark\u003e\u003c/strong\u003e（encoding rules），描述具体如何表示 ASN.1 数据。\n原以为增加这层额外的抽象会有所帮助，但实际证明大部分情况下反而\u003cstrong\u003e\u003cmark\u003e徒增烦恼\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"der-distinguished-encoding-rules二进制格式\"\u003eDER (distinguished encoding rules)：二进制格式\u003c/h3\u003e\n\n\u003cp\u003eASN.1 有\u003ca href=\"https://en.wikipedia.org/wiki/Abstract_Syntax_Notation_One#Encodings\"\u003e很多种编码规则\u003c/a\u003e，\n但用于 X.509 和其他加密相关的，\u003cstrong\u003e\u003cmark\u003e只有一种\u003c/mark\u003e\u003c/strong\u003e常见格式：DER —— 虽然有时也会用到 non-canonical\n的 basic encoding rules (BER，基础编码规则) 。\u003c/p\u003e\n\n\u003cp\u003eDER 是\u003cstrong\u003e\u003cmark\u003e非常简单的 TLV\u003c/mark\u003e\u003c/strong\u003e（type-length-value）编码，但实际上用户无需\n关心这些，因为函数库封装好了。但不要高兴得太早 —— 虽然我们不必关心 DER 的编解码，\n但要能判断给定的某个 X.509 证书是 DER 还是其他类型编码的。这里的其他类型包括：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e一些比 DER 更友好的格式，\u003c/li\u003e\n  \u003cli\u003e封装了证书及其他额外信息的格式（something more than just a certificate）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eDER 编码的证书通常以 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e.der\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 为后缀。\u003c/p\u003e\n\n\u003ch3 id=\"pem-privacy-enhanced-email文本格式\"\u003ePEM (privacy enhanced email)：文本格式\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eDER 是二进制格式，不便复制粘贴\u003c/mark\u003e\u003c/strong\u003e。因此\u003cstrong\u003e\u003cmark\u003e大部分证书都是以\u003c/mark\u003e\u003c/strong\u003e\n\u003ca href=\"https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail\"\u003ePEM\u003c/a\u003e 格式打包的，这是\n\u003cstrong\u003e\u003cmark\u003e另一个历史怪胎\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果你熟悉 \u003ca href=\"https://en.wikipedia.org/wiki/MIME\"\u003eMIME\u003c/a\u003e 的话，二者是比较类似的：\n由 header、base64 编码的 payload、footer 三部分组成。\nheader 中有标签（label）来描述 payload。例如下面是一个 \u003cstrong\u003e\u003cmark\u003ePEM 编码的 X.509 证书\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e-----BEGIN CERTIFICATE-----\nMIIBwzCCAWqgAwIBAgIRAIi5QRl9kz1wb+SUP20gB1kwCgYIKoZIzj0EAwIwGzEZ\nMBcGA1UEAxMQTDVkIFRlc3QgUm9vdCBDQTAeFw0xODExMDYyMjA0MDNaFw0yODEx\nBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRc+LHppFk8sflIpm/XKpbNMwx3\nSDAfBgNVHSMEGDAWgBTirEpzC7/gexnnz7ozjWKd71lz5DAKBggqhkjOPQQDAgNH\nADBEAiAejDEfua7dud78lxWe9eYxYcM93mlUMFIzbWlOJzg+rgIgcdtU9wIKmn5q\nFU3iOiRP5VyLNmrsQD3/ItjUN1f1ouY=\n-----END CERTIFICATE-----\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e但令人震惊的时，即便如此简单的功能，在实现上也已经出现混乱：PEM labels 在不同工具之间是不一致的。\n\u003ca href=\"https://tools.ietf.org/html/rfc7468\"\u003eRFC 7468\u003c/a\u003e 试图标准化 PEM 的使用规范，\n但也并不完整，不是所有工具都遵循这个规范。\u003c/p\u003e\n\n\u003cp\u003ePEM 编码的证书通常以 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e.pem\u003c/code\u003e、\u003ccode\u003e.crt\u003c/code\u003e 或 \u003ccode\u003e.cer\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 为后缀。\n再次提醒，这只是“通常”情况，实际上某些工具可能并不遵循这些惯例。\u003c/p\u003e\n\n\u003cp\u003e下面介绍几个前面提到的“其他类型的打包格式”。\u003c/p\u003e\n\n\u003ch2 id=\"65-比-x509-信息更丰富的证书打包封装格式\"\u003e6.5 比 X.509 信息更丰富的证书打包（封装）格式\u003c/h2\u003e\n\n\u003cp\u003eX.509 只是一种常用的证书格式，但有人觉得这种格式能装的信息不够多，因此\n又定义了一些比 X.509 \u003cstrong\u003e\u003cmark\u003e更大的数据结构\u003c/mark\u003e\u003c/strong\u003e（但\u003cstrong\u003e\u003cmark\u003e仍然用 ASN.1\u003c/mark\u003e\u003c/strong\u003e），\n能将证书、秘钥以及其他东西封装（打包）到一起。因此，有时说我需要“一个证书”时，其\n实真正说的是包（package）中包含的那个“证书”（a certificate in one of these\nenvelopes），而不是这个包本身。\u003c/p\u003e\n\n\u003ch3 id=\"pkcs-7java-中常用\"\u003ePKCS #7：Java 中常用\u003c/h3\u003e\n\n\u003cp\u003e你可能会遇到的是一个称为 PKCS（Public Key Cryptography Standards，\u003cstrong\u003e\u003cmark\u003e公钥加密标准\u003c/mark\u003e\u003c/strong\u003e）的标准的一部分，\n它由 RSA labs 发布（真实历史要 \u003ca href=\"https://security.stackexchange.com/questions/73156/whats-the-difference-between-x-509-and-pkcs7-certificate\"\u003e更加复杂一些\u003c/a\u003e，本文不展开）。\u003c/p\u003e\n\n\u003cp\u003e其中的第一个标准是 \u003ca href=\"https://tools.ietf.org/html/rfc2315\"\u003ePKCS#7\u003c/a\u003e，后面被\nIETF 重新冠名为 \u003ca href=\"https://tools.ietf.org/html/rfc5652\"\u003eCryptographic Message Syntax\u003c/a\u003e (CMS)\n，其中可以包含多个证书（以 full certificate chain 方式编码，后面会看到）。\u003c/p\u003e\n\n\u003cp\u003ePKCS#7 \u003cstrong\u003e\u003cmark\u003e在 Java 中使用广泛\u003c/mark\u003e\u003c/strong\u003e。常见扩展名是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.p7b\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.p7c\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"pkcs-12微软常用\"\u003ePKCS #12：微软常用\u003c/h3\u003e\n\n\u003cp\u003e另一个常见的打包格式 \u0026lt;a href=https://tools.ietf.org/html/rfc7292\u0026gt;PKCS#12\u0026lt;/a\u0026gt;，\n它能将一个\u003cstrong\u003e\u003cmark\u003e证书链\u003c/mark\u003e\u003c/strong\u003e（这一点与 PKCS#7 类似）连同一个（加密之后的）\u003cstrong\u003e\u003cmark\u003e私钥\u003c/mark\u003e\u003c/strong\u003e打包到一起。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e微软的产品多用这种格式\u003c/mark\u003e\u003c/strong\u003e，常见后缀\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.pfx\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.p12\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e再次说明，PKCS#7 和 PKCS#12 envelopes \u003cstrong\u003e\u003cmark\u003e仍然使用 ASN.1\u003c/mark\u003e\u003c/strong\u003e，这意味着\n它们都能以原始 DER、BER 或 PEM 的格式编码。\n从我个人的经验来看，二者\u003cstrong\u003e\u003cmark\u003e几乎都是 DER 编码的\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"66-秘钥编解码\"\u003e6.6 秘钥编解码\u003c/h2\u003e\n\n\u003cp\u003e秘钥编码（Key encoding）的过程与以上描述的类似（复杂）：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e用某种 ASN.1 数据结构描述秘钥（key）；\u003c/li\u003e\n  \u003cli\u003e用 DER 做二进制编码，或用 PEM (hopefully with a useful header) 做一些稍微友好一些的表示。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e秘钥的解密过程（deciphering），一半是是科学，一半是艺术\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果足够幸运，根据 \u003ca href=\"https://tools.ietf.org/html/rfc7468\"\u003eRFC 7468\u003c/a\u003e 就能找到其中的 PEM payload；\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e椭圆曲线秘钥通常符合 RFC 7468 规范，虽然\n  \u003ca href=\"https://tools.ietf.org/html/rfc5915#section-4\"\u003e这里看起来似乎也并没有什么标准\u003c/a\u003e。\u003c/p\u003e\n\n    \u003cp\u003e下面是一个 \u003cstrong\u003e\u003cmark\u003ePEM 编码的椭圆曲线秘钥\u003c/mark\u003e\u003c/strong\u003e（PEM-encoded elliptic curve key）：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003estep crypto keypair \u003cspan class=\"nt\"\u003e--kty\u003c/span\u003e EC \u003cspan class=\"nt\"\u003e--no-password\u003c/span\u003e \u003cspan class=\"nt\"\u003e--insecure\u003c/span\u003e ec.pub ec.prv\n\n \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003eec.pub ec.prv\n \u003cspan class=\"nt\"\u003e-----BEGIN\u003c/span\u003e PUBLIC KEY-----\n MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEc73/+JOESKlqWlhf0UzcRjEe7inF\n uu2z1DWxr+2YRLfTaJOm9huerJCh71z5lugg+QVLZBedKGEff5jgTssXHg\u003cspan class=\"o\"\u003e==\u003c/span\u003e\n \u003cspan class=\"nt\"\u003e-----END\u003c/span\u003e PUBLIC KEY-----\n \u003cspan class=\"nt\"\u003e-----BEGIN\u003c/span\u003e EC PRIVATE KEY-----\n MHcCAQEEICjpa3i7ICHSIqZPZfkJpcRim/EAmUtMFGJg6QjkMqDMoAoGCCqGSM49\n AwEHoUQDQgAEc73/+JOESKlqWlhf0UzcRjEe7inFuu2z1DWxr+2YRLfTaJOm9hue\n rJCh71z5lugg+QVLZBedKGEff5jgTssXHg\u003cspan class=\"o\"\u003e==\u003c/span\u003e\n \u003cspan class=\"nt\"\u003e-----END\u003c/span\u003e EC PRIVATE KEY-----\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e其他秘钥，通常用 PEM label “PRIVATE KEY” 描述\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"pem-编码的-pkcs8-格式私钥\"\u003ePEM 编码的 PKCS#8 格式私钥\u003c/h3\u003e\n\n\u003cp\u003ePEM label “PRIVATE KEY” 描述的秘钥，通常暗示这是一个\n\u003ca href=\"https://tools.ietf.org/html/rfc5208\"\u003ePKCS#8\u003c/a\u003e payload，\n这是一种私钥（private key）封装格式，其中包含秘钥类型和其他 metadata。\u003c/p\u003e\n\n\u003ch3 id=\"密码加密的私钥\"\u003e密码加密的私钥\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e用密码来加密私钥\u003c/mark\u003e\u003c/strong\u003e也很常见（private keys encrypted using a\npassword），这里的密码可以是 a shared secret or symmetric key。\n看起来大致如下（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eProc-Type\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDEK-Info\u003c/code\u003e 是 PEM 的一部分，表示这个 PEM 的 payload 是用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAES-256-CBC\u003c/code\u003e 加密的）：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e-----BEGIN EC PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-256-CBC,b3fd6578bf18d12a76c98bda947c4ac9\n\nqdV5u+wrywkbO0Ai8VUuwZO1cqhwsNaDQwTiYUwohvot7Vw851rW/43poPhH07So\nsdLFVCKPd9v6F9n2dkdWCeeFlI4hfx+EwzXLuaRWg6aoYOj7ucJdkofyRyd4pEt+\nMj60xqLkaRtphh9HWKgaHsdBki68LQbObLOz4c6SyxI=\n-----END EC PRIVATE KEY-----\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ePKCS#8 对象也能被加密，这种情况下 header label 应该是 \u003cstrong\u003e\u003cmark\u003e\u0026#34;ENCRYPTED PRIVATE KEY\u0026#34;\u003c/mark\u003e\u003c/strong\u003e per RFC 7468。\n这种情况下不会看到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eProc-Type\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDek-Info\u003c/code\u003e headers，因为这些信息此时编码到了 payload 中。\u003c/p\u003e\n\n\u003ch3 id=\"公钥私钥常见扩展名\"\u003e公钥、私钥常见扩展名\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e公钥：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.pub\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.pem\u003c/code\u003e，\u003c/li\u003e\n  \u003cli\u003e私钥：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.prv,\u003c/code\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.key\u003c/code\u003e, or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.pem\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但再次说明，有些工具或组织可能并不遵循业界惯例。\u003c/p\u003e\n\n\u003ch2 id=\"67-小结\"\u003e6.7 小结\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eASN.1 用于定义数据类型\u003c/mark\u003e\u003c/strong\u003e，例如证书（certificate）和秘钥（key）——\n就像用 JSON 定义一个 request body —— X.509 用 ASN.1  定义。\u003c/li\u003e\n  \u003cli\u003eDER 是一组将 ASN.1 编码成二进制（比特和字节）的编码规则（encoding rules）。\u003c/li\u003e\n  \u003cli\u003ePKCS#7 and PKCS#12 是比 X.509 更大的数据结构（封装格式），也用 ASN.1 定义，其\n中能包含除了证书之外的其他东西。二者分别在 Java 和 Microsoft 产品中使用较多。\u003c/li\u003e\n  \u003cli\u003eDER 编码之后是二进制数据，不方便复制粘贴，因此大部分证书都是用 PEM 编码的，它\n用 base64 对 DER 进行编码，然后再加上自己的 label。\u003c/li\u003e\n  \u003cli\u003e私钥通常用是 PEM 编码的 PKCS#8 对象，但有时也会用密码来加密。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果觉得以上内容理解起来很杂乱，那并不是你的问题，而是加密领域的现状就是如此。我已经尽力了。\u003c/p\u003e\n\n\u003ch1 id=\"7-pki-public-key-infrastructure\"\u003e7 PKI (Public Key Infrastructure)\u003c/h1\u003e\n\n\u003cp\u003e至此我们已经知道了证书的来历和样子，但这仅仅是本文的一半。\n下面看\u003cstrong\u003e\u003cmark\u003e证书是如何创建和使用\u003c/mark\u003e\u003c/strong\u003e的。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003ePublic key infrastructure\u003c/mark\u003e (PKI) 是一个统称，包括了我们在\n如下与证书和秘钥管理及交互操作时需要用到的所有东西：签发、分发、存放、使用、验证、撤回等等。\n就像“数据库基础设施” 一样，这个名词是有意取的这样模糊的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e证书是大部分 PKI 的构建模块\u003c/mark\u003e\u003c/strong\u003e，而证书权威是其基础。\u003c/li\u003e\n  \u003cli\u003ePKI 包括了 libraries, cron jobs, protocols, conventions, clients, servers,\npeople, processes, names, discovery mechanisms, and all the other stuff\nyou’ll need to use public key cryptography effectively。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e自己从头开始构建一个 PKI 是一件极其庞大的工作，\n但实际上 \u003cstrong\u003e\u003cmark\u003e一些简单的 PKI 甚至并不使用证书\u003c/mark\u003e\u003c/strong\u003e。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e编辑 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~/.ssh/authorized_keys\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 文件时，就是在配置\n一个简单的无证书形式的（certificate-less）PKI，SSH 通过这种方式在扁平文件内\n\u003cstrong\u003e\u003cmark\u003e实现 public key 和 name 的绑定\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003ePGP 用证书，但不用 CA，而是用一个 \u003ca href=\"https://en.wikipedia.org/wiki/Web_of_trust\"\u003eweb-of-trust\u003c/a\u003e model；\u003c/li\u003e\n  \u003cli\u003e甚至可以 \u003ca href=\"http://www.aaronsw.com/weblog/squarezooko\"\u003e用区块链\u003c/a\u003e 来 assign name 并将它们 bind 到 public key。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果从头开始构建一个 PKI，\u003cstrong\u003e\u003cmark\u003e唯一确定的事情是：你需要用到公钥\u003c/mark\u003e\u003c/strong\u003e（public keys），\n其他东西都随设计而异。\u003c/p\u003e\n\n\u003cp\u003e下文将\u003cstrong\u003e\u003cmark\u003e主要关注 web 领域使用的 PKI\u003c/mark\u003e\u003c/strong\u003e，以及基于 Web PKI 技术、遵循现有标准的 internal PKI。\u003c/p\u003e\n\n\u003cp\u003e证书和 PKI 的目标其实很简单：\u003cstrong\u003e\u003cmark\u003e将名字关联到公钥\u003c/mark\u003e\u003c/strong\u003e（bind names to public keys）。\n在下面的内容中，不要忘了这一点。\u003c/p\u003e\n\n\u003ch2 id=\"71-web-pki-vs-internal-pki\"\u003e7.1 Web PKI vs Internal PKI\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e浏览器访问 HTTPS 链接时\u003c/mark\u003e\u003c/strong\u003e会用到 Web PKI。虽然也有一些问题，但它大大提升了 web\n的安全性，而且基本上对用户透明。在访问互联网 web 服务时，应该在所有可能的情\n况下都启用它。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eWeb PKI 由 \u003ca href=\"https://tools.ietf.org/html/rfc5280\"\u003eRFC 5280\u003c/a\u003e 定义，\n\u003ca href=\"https://cabforum.org/\"\u003eCA/Browser Forum\u003c/a\u003e (a.k.a., CA/B or CAB Forum) 对其进行了进一步完善。\u003c/li\u003e\n  \u003cli\u003e有时也称为 “Internet PKI” 或 \u003cstrong\u003e\u003cmark\u003ePKIX\u003c/mark\u003e\u003c/strong\u003e (after the working group that created it).\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ePKIX 和 CAB Forum 文档涵盖了很大内容。\n它们定义了前面讨论的各种证书、还定义什么是 “name” 以及位于证书中什么位置、能使用什么签名算法、\nRP 如何判断 issuer 的证书、如何指定证书的 validity period (issue and expiry dates)、\n撤回、certificate path validation、CA 判断某人是否拥有一个域名等等。\u003c/p\u003e\n\n\u003cp\u003eWeb PKI 很重要，是因为浏览器默认使用 Web PKI 证书。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003eInternal PKI\u003c/mark\u003e 是\u003cstrong\u003e\u003cmark\u003e用户为自己的产品基础设施使用的 PKI\u003c/mark\u003e\u003c/strong\u003e，这些产品包括\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e服务、容器、虚拟机等；\u003c/li\u003e\n  \u003cli\u003e企业 IT 应用；\u003c/li\u003e\n  \u003cli\u003e公司终端设备，例如笔记本电脑、手机等；\u003c/li\u003e\n  \u003cli\u003e其他需要识别的代码或设备。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eInternal PKI 使你能认证和建立加密通道，这样你的服务就可以安全地在公网上的任意位置互相通信了。\u003c/p\u003e\n\n\u003ch2 id=\"72-有了-web-pki为什么还要使用自己的-internal-pki\"\u003e7.2 有了 Web PKI，为什么还要使用自己的 internal PKI？\u003c/h2\u003e\n\n\u003cp\u003e首先，简单来说：\u003cstrong\u003e\u003cmark\u003eWeb PKI 设计中并没有考虑内部使用场景\u003c/mark\u003e\u003c/strong\u003e。\n即使有了 \u003ca href=\"https://letsencrypt.org/\"\u003eLet’s Encrypt\u003c/a\u003e 这样的提供免费证书和自动化交付的 CA，\n用户还是需要自己处理 \u003ca href=\"https://letsencrypt.org/docs/rate-limits/\"\u003erate limits\u003c/a\u003e 和\n\u003ca href=\"https://statusgator.com/services/lets-encrypt\"\u003eavailability\u003c/a\u003e 之类的事情。\n如果有很多 service，部署很频繁，就非常不方便。\u003c/p\u003e\n\n\u003cp\u003e另外，Web PKI 中，用户对证书生命周期、撤回机制、续约过程、秘钥类型、算法等等很\n多重要的细节都没有控制权，或只有很少控制权。而下文将会看到，这些都是非常重要的东西。\u003c/p\u003e\n\n\u003cp\u003e最后，CA/Browser Forum Baseline Requirements\n实际上\u003cstrong\u003e\u003cmark\u003e禁止将 Web PKI CA 关联到 internal IPs\u003c/mark\u003e\u003c/strong\u003e (e.g., \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.0.0.0/8\u003c/code\u003e)\n及 \u003cstrong\u003e\u003cmark\u003einternal DNS names\u003c/mark\u003e\u003c/strong\u003e that aren’t fully-qualified and\nresolvable in public global DNS (e.g., you can’t bind a kubernetes cluster DNS\nname like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efoo.ns.svc.cluster.local\u003c/code\u003e)。\n如果需要在证书中绑定到这些 name，或者签发大量证书，或者控制证书细节，就需要自己的 internal PKI.\u003c/p\u003e\n\n\u003cp\u003e下面一节将看到，信任（或缺乏信任）是避免将 Web PKI 用于内部场景的另一个原因。\u003c/p\u003e\n\n\u003cp\u003e总结起来，建议：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e面向公网的服务或 API\u003c/mark\u003e\u003c/strong\u003e，使用 Web PKI；\u003c/li\u003e\n  \u003cli\u003e其他所有场景，都使用 internal PKI。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"8-trust--trustworthiness\"\u003e8 Trust \u0026amp; Trustworthiness\u003c/h1\u003e\n\n\u003ch2 id=\"81-trust-stores信任仓库\"\u003e8.1 Trust Stores（信任仓库）\u003c/h2\u003e\n\n\u003cp\u003e前面介绍到，证书可解读为一个 statement 或 claim，例如：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eIssuer（签发者）说，该 subject 的公钥是 xxx。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eIssuer 会对这份声明进行签名，relying party 能（通过 issuer 的公钥）验证（authenticate）签名是否合法。\n但这里其实跳过了一个重要问题：\u003cstrong\u003e\u003cmark\u003erelying party 是如何知道 issuer 的公钥的\u003c/mark\u003e\u003c/strong\u003e？\u003c/p\u003e\n\n\u003ch3 id=\"预配置信任的根证书\"\u003e预配置信任的根证书\u003c/h3\u003e\n\n\u003cp\u003e答案其实很简单：relying parties 在自己的 trust store（信任库）预先配置了一个它\n\u003cstrong\u003e\u003cmark\u003e信任的根证书\u003c/mark\u003e\u003c/strong\u003e（trusted root certificates，也称为 trust anchors）列表，\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e预配置的具体方式\u003c/mark\u003e\u003c/strong\u003e（the manner in which this pre-configuration occurs），\n是 PKI 非常重要的一面：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一种方式是从另一个 PKI 来 bootstrap：可以用一些自动化工具，通过 SSH 将 root 证\n书拷贝到 relying party。这里用到里前面提到的 SSH PKI。\u003c/li\u003e\n  \u003cli\u003e如果是在 cloud 上，那 PKI 依赖层次（信任链）又深了一步：SSH PKI 是由 Web PKI 加上认证方式\n来 bootstrap 的，这里的认证是你创建 cloud 账户时选择的认证方式。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"信任链\"\u003e信任链\u003c/h3\u003e\n\n\u003cp\u003e如果沿着这个信任链（chain of trust）回溯足够远，最后总能找到人（people）：每个\n信任链都终结在现实世界（meatspace）。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/chain-of-trust.jpg\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e下面这个图画地更清楚一些，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/trust-chain.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eImage credit: \u003ca href=\"https://brainbit.io/posts/cilium-tls-inspection/\"\u003eCilium TLS inspection\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"根证书自签名\"\u003e根证书自签名\u003c/h3\u003e\n\n\u003cp\u003e信任仓库中的\u003cstrong\u003e\u003cmark\u003e根证书是自签名的（self-signed）\u003c/mark\u003e\u003c/strong\u003e：issuer 和 subject\n相同。逻辑上，这种 statement 表示的是：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eMike 说：Mike 的公钥是 xxx。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e自签名的证书保证了该证书的 subject/issuer 知道对应的私钥，\n但任何人都可以生成一个自签名的证书，这个证书中可以写任何他们想写的名字（name）。\u003c/p\u003e\n\n\u003cp\u003e因此\u003cstrong\u003e\u003cmark\u003e证书的起源（provenance）就非常关键\u003c/mark\u003e\u003c/strong\u003e：一个自签名的证书，只有\n当它\u003cstrong\u003e\u003cmark\u003e进入信任仓库的过程是可信任时\u003c/mark\u003e\u003c/strong\u003e，才应该信任这个根证书。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 macOS 上，信任仓库是由 Keychain 管理的。\u003c/li\u003e\n  \u003cli\u003e在一些 Linux 发行版上，可能只是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc\u003c/code\u003e 或其他路径下面的一些文件。\u003c/li\u003e\n  \u003cli\u003e如果你的用户能修改这些文件，那最好先确认是你信任这些用户的。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"信任仓库的来源\"\u003e信任仓库的来源\u003c/h3\u003e\n\n\u003cp\u003e所以，信任仓库又从哪里来？对于 Web PKI 来说，最重要的\nrelying parties 就是浏览器。\u003cstrong\u003e\u003cmark\u003e主流浏览器默认使用的信任仓库\u003c/mark\u003e\u003c/strong\u003e ——\n及其他任何使用 TLS 的东西 —— 都是\u003cstrong\u003e\u003cmark\u003e由四个组织维护\u003c/mark\u003e\u003c/strong\u003e的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"http://www.apple.com/certificateauthority/ca_program.html\"\u003eApple’s root certificate\u003c/a\u003e：iOS/macOS 程序\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://social.technet.microsoft.com/wiki/contents/articles/31633.microsoft-trusted-root-program-requirements.aspx\"\u003eMicrosoft’s root certificate program\u003c/a\u003e：Windows 使用\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.mozilla.org/en-US/about/governance/policies/security-group/certs/\"\u003eMozilla’s root certificate program\u003c/a\u003e：\n  Mozilla 产品使用，由于其开放和透明，也作为其他一些信任仓库从基础 (e.g., for many Linux distributions)\u003c/li\u003e\n  \u003cli\u003eGoogle \u003ca href=\"https://www.chromium.org/Home/chromium-security/root-ca-policy\"\u003e未维护 root certificate program\u003c/a\u003e\n  （Chrome 通常使用所在计算的操作系统的信任仓库），但\n\u003ca href=\"https://chromium.googlesource.com/chromium/src/+/master/net/data/ssl/blacklist/README.md\"\u003e维护了自己的黑名单\u003c/a\u003e，\n列出了自己不信任的根证书或特定证书。\n(\u003ca href=\"https://chromium.googlesource.com/chromiumos/docs/+/master/ca_certs.md\"\u003eChromeOS builds off of Mozilla’s certificate program\u003c/a\u003e)\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"操作系统的信任仓库\"\u003e操作系统的信任仓库\u003c/h3\u003e\n\n\u003cp\u003e操作系统中的信任仓库通常都是\u003cstrong\u003e\u003cmark\u003e系统自带\u003c/mark\u003e\u003c/strong\u003e的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eFirefox 自带了自己的信任仓库（通过 TLS 从 mozilla.org 分发 ——\nbootstrapping off of Web PKI using some other trust store）。\u003c/li\u003e\n  \u003cli\u003e编程语言和其他非浏览器的东西例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecurl\u003c/code\u003e，通过默认用操作系统的信任仓库。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，这个信任仓库通常情况下，会被该系统上预装的很多东西默认使用；通过软件更新（\n通常使用另一个 PKI 来签名）而更新。\u003c/p\u003e\n\n\u003cp\u003e信任仓库中通常包含了超过 100 个由这些程序维护的\u003cstrong\u003e\u003cmark\u003e常见证书权威\u003c/mark\u003e\u003c/strong\u003e（certificate authorities）。\n其中一些著名的：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eLet’s Encrypt\u003c/li\u003e\n  \u003cli\u003eSymantec\u003c/li\u003e\n  \u003cli\u003eDigiCert\u003c/li\u003e\n  \u003cli\u003eEntrust\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果想编程控制：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eCloudflare’s\n\u003ca href=\"https://github.com/cloudflare/cfssl\"\u003ecfssl\u003c/a\u003e project maintains a\n\u003ca href=\"https://github.com/cloudflare/cfssl_trust\"\u003egithub repository\u003c/a\u003e that\nincludes the trusted certificates from various trust stores to assist with\ncertificate bundling (which we’ll discuss momentarily).\u003c/li\u003e\n  \u003cli\u003eFor a more human-friendly experience you can query \u003ca href=\"https://censys.io/\"\u003eCensys\u003c/a\u003e\nto see which certificates are trusted by \u003ca href=\"https://censys.io/certificates?q=validation.nss.valid%3A+true+AND+parsed.extensions.basic_constraints.is_ca%3A+true\"\u003eMozilla\u003c/a\u003e,\n\u003ca href=\"https://censys.io/certificates?q=validation.apple.valid%3A+true+AND+parsed.extensions.basic_constraints.is_ca%3A+true\"\u003eApple\u003c/a\u003e,\nand \u003ca href=\"https://censys.io/certificates?q=validation.microsoft.valid%3A+true+AND+parsed.extensions.basic_constraints.is_ca%3A+true\"\u003eMicrosoft\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"82-trustworthiness可靠性\"\u003e8.2 Trustworthiness（可靠性）\u003c/h2\u003e\n\n\u003cp\u003e这 100 多个证书权威在理论上是\u003cstrong\u003e\u003cmark\u003e可信的\u003c/mark\u003e\u003c/strong\u003e（trusted） —— 浏览器和其他\n一些软件默认情况下信任由这些权威颁发的证书。\u003c/p\u003e\n\n\u003cp\u003e但是，这并不意味着它们是\u003cstrong\u003e\u003cmark\u003e可靠的\u003c/mark\u003e\u003c/strong\u003e（trustworthy）。\n已经出现过 Web PKI 证书权威向政府机构\u003cstrong\u003e\u003cmark\u003e提供假证书\u003c/mark\u003e\u003c/strong\u003e的事故，以便\n窥探流量（snoop on traffic）或仿冒某些网站。\n这类“受信任的” CA 中，其中在司法管辖权之外的地方运营 —— 包括民主国家和专制国家。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eNSA 利用每个可能的机会来削弱 Web PKI。2011 年，两个“受信任的”证书权威\nDigiNotar and Comodo  \u003ca href=\"https://en.wikipedia.org/wiki/DigiNotar\"\u003e都\u003c/a\u003e\n\u003ca href=\"https://en.wikipedia.org/wiki/Comodo_Group#Certificate_hacking\"\u003e被攻陷了\u003c/a\u003e。\nDigiNotar 证书泄露可能与 NSA 相关。\u003c/li\u003e\n  \u003cli\u003e此外，还有大量 CA 签发格式不对或不兼容的证书。因此，虽然按业界规范来说\n这些 CA 是受信的，但\u003cstrong\u003e\u003cmark\u003e按照经验来说它们是不可靠（不靠谱）的\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e我们很快就会看到，\u003cstrong\u003e\u003cmark\u003eWeb PKI 的安全性取决于安全性最弱的权威\u003c/mark\u003e\u003c/strong\u003e（the least secure CA）的安全性。\n这显然不是我们希望的。\u003c/p\u003e\n\n\u003cp\u003e浏览器社区已经在采取行动来解决这些问题。\nCA/Browser Forum Baseline Requirements 规定了这些受信的证书权威在签发证书时应该遵守的规则。\n作为 WebTrust audit 项目的一部分，在将 CA 加入到某些信任仓库（例如 Mozilla 的）之前，会对 CA 合规性进行审计。\u003c/p\u003e\n\n\u003cp\u003e如果\u003cstrong\u003e\u003cmark\u003e内部场景\u003c/mark\u003e\u003c/strong\u003e（internal stuff）已经在使用 TLS，你可能大部分情况下\n\u003cstrong\u003e\u003cmark\u003e并不需要信任这些 public CA\u003c/mark\u003e\u003c/strong\u003e。\n如果信任了，就为 NSA 和其他组织打开了一扇地狱之门：你的系统安全性将取决于 100 多\n个组织中安全性最弱的那一个。\u003c/p\u003e\n\n\u003ch2 id=\"83-federation\"\u003e8.3 Federation\u003c/h2\u003e\n\n\u003ch3 id=\"证书欺骗的风险\"\u003e证书欺骗的风险\u003c/h3\u003e\n\n\u003cp\u003e令事情更糟糕的是，Web PKI relying parties (RPs) 信任它们的信任仓库中任何 CA\n签发给任何 subscriber 的证书。结果是 Web PKI 整体的安全性取决于所有 Web PKI CA 中最弱的那个。\n\u003cstrong\u003e\u003cmark\u003e2011 DigiNotar 攻击\u003c/mark\u003e\u003c/strong\u003e就说明了这个问题：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e作为攻击的一部分，\u003cstrong\u003e\u003cmark\u003e给 google.com 签发了一个假证书\u003c/mark\u003e\u003c/strong\u003e，\n这个证书\u003cstrong\u003e\u003cmark\u003e被大部分浏览器和操作系统信任\u003c/mark\u003e\u003c/strong\u003e，而它们不管 google 和\nDigiNotar 没有任何关系这一事实。\u003c/li\u003e\n  \u003cli\u003e还有类似的欺骗证书颁发给了 Yahoo!, Mozilla, The Tor Project。\u003c/li\u003e\n  \u003cli\u003e最终的解决方式是将 DigiNotar 的根证书从主流信任仓库中移除，但显然在此期间已经造成了大量破坏。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e最近，\u003cstrong\u003e\u003cmark\u003e森海塞尔\u003c/mark\u003e\u003c/strong\u003e（Sennheiser）因为在它们的 HeadSetup APP 信任仓库中\n\u003ca href=\"https://medium.com/asecuritysite-when-bob-met-alice/your-headphones-might-break-the-security-of-your-computer-4f304ed86611\"\u003e安装了一个自签名的根证书\u003c/a\u003e\n引起了一次重大安全事故，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e他们将相应的私钥（private key）嵌入在了 app 的配置中，\u003c/li\u003e\n  \u003cli\u003e任何人都能从中提取这个私钥，然后颁发证书给任何 domain，\u003c/li\u003e\n  \u003cli\u003e因此，任何在自己的信任仓库中添加了 Sennheiser 证书的，都将会信任这些欺骗证书。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这完全摧毁了 TLS 带来的好处，太糟糕了！\u003c/p\u003e\n\n\u003ch3 id=\"改进措施\"\u003e改进措施\u003c/h3\u003e\n\n\u003cp\u003e已经有一些机制来减少此类风险：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://tools.ietf.org/html/rfc6844\"\u003eCertificate Authority Authorization\u003c/a\u003e (CAA) allows you to restrict which CAs can issue certificates\nfor your domain using a special DNS record.\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.certificate-transparency.org/\"\u003eCertificate Transparency\u003c/a\u003e\n (CT) (\u003ca href=\"https://tools.ietf.org/html/rfc6962\"\u003eRFC 6962\u003c/a\u003e) mandates\n that CAs submit every certificate they issue to an impartial observer that\n maintains a \u003ca href=\"https://crt.sh/?Identity=smallstep.com\"\u003epublic\n certificate log\u003c/a\u003e to detect fraudulently issued certificates.\n Cryptographic proof of CT submission is included in issued certificate\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://tools.ietf.org/html/rfc7469\"\u003eHTTP Public Key Pinning\u003c/a\u003e (HPKP\n or just “pinning”) lets a subscriber (a website) tell an RP (a browser) to\n only accept certain public keys in certificates for a particular domain.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这里存在的问题是：\u003cstrong\u003e\u003cmark\u003e缺少 RP 端的支持\u003c/mark\u003e\u003c/strong\u003e。CAB Forum now mandates CAA\nchecks in browsers. Some browsers also have some support for CT and HPKP. 但对于\n其他 RPs (e.g., most TLS standard library implementations) \u003cstrong\u003e\u003cmark\u003e这些东西几乎都是没有\n贯彻执行的\u003c/mark\u003e\u003c/strong\u003e。This issue will come up repeatedly: a lot of certificate policy must\nbe enforced by RPs, and RPs can rarely be bothered. If RPs don’t check CAA\nrecords and don’t require proof of CT submission this stuff doesn’t do much\ngood.\u003c/p\u003e\n\n\u003ch3 id=\"internal-pki-使用单独的信任仓库\"\u003eInternal PKI 使用单独的信任仓库\u003c/h3\u003e\n\n\u003cp\u003e在任何情况下，如果使用自己的 internal PKI，都应该为 internal 服务\u003cstrong\u003e\u003cmark\u003e维护一个单独的信任仓库\u003c/mark\u003e\u003c/strong\u003e。\n即，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e不要将你的根证书直接加到系统已有的信任仓库，\u003c/li\u003e\n  \u003cli\u003e而应该配置 internal TLS 只使用你自己的根证书。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"internal-pki-细粒度控制caa--spiffe\"\u003eInternal PKI 细粒度控制：CAA \u0026amp; SPIFFE\u003c/h3\u003e\n\n\u003cp\u003e如果想在内部实现更好的联邦（federation） —— 例如限制 internal CA 能签发哪些证书，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e可以试试 CAA records 然后对 RPs 进行恰当配置。\u003c/li\u003e\n  \u003cli\u003e还可以看看 \u003ca href=\"https://spiffe.io/\"\u003e\u003cmark\u003eSPIFFE\u003c/mark\u003e\u003c/a\u003e，这是一个还在不断发展的项目，\n目标是对一些 internal PKI 相关的问题进行标准化。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"9-什么是证书权威certificate-authority\"\u003e9 什么是证书权威（Certificate Authority）？\u003c/h1\u003e\n\n\u003cp\u003e前面已经讨论了很多 CA 相关的东西，但我们还没定义什么是 CA。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个证书权威（CA）就是一个\u003cstrong\u003e\u003cmark\u003e受信任的证书颁发者\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eCA 通过对一个证书进行签名，对一个\u003cstrong\u003e\u003cmark\u003e公钥和名字之间的绑定关系（binding）做担保\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e本质上来说，一个 CA 只不过是另一个证书加上用来签其他证书的相应私钥。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e显然需要一些逻辑和过程来将这些东西串联起来。CA 需要将它的证书分发到信任仓库，接受和处理\n证书请求，颁发证书给 subscriber。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个暴露此类 API 给外部调用、自动化这些过程的 CA 称为\u003cstrong\u003e\u003cmark\u003e在线证书权威\u003c/mark\u003e\u003c/strong\u003e（\u003cstrong\u003e\u003cmark\u003eonline CA\u003c/mark\u003e\u003c/strong\u003e）。\u003c/li\u003e\n  \u003cli\u003e在信任仓库中那些自签名的根证书 称为根证书权威（\u003cstrong\u003e\u003cmark\u003eroot CA\u003c/mark\u003e\u003c/strong\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"91-web-pki-不能自动化签发证书\"\u003e9.1 Web PKI 不能自动化签发证书\u003c/h2\u003e\n\n\u003cp\u003eCAB Forum Baseline Requirements 4.3.1 明确规定：一个 Web PKI CA 的 root private key\n只能通过 issue a direct command 来签发证书。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e换句话说，\u003cstrong\u003e\u003cmark\u003eWeb PKI root CA 不能自动化证书签名（certificate signing）过程\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e对于任何大的 CA operation 来说，无法在线完成都是一个问题。\n不可能每次签发一个证书时，都人工敲一个命令。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这样规定是出于\u003cstrong\u003e\u003cmark\u003e安全考虑\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eWeb PKI root certificates 广泛存在于信任仓库中，很难被撤回。截获一个\nroot CA private key 理论上将影响几十亿的人和设备。\u003c/li\u003e\n  \u003cli\u003e因此，最佳实践就是，确保 root private keys 是离线的（offline），理想情况下在一些\n\u003ca href=\"https://en.wikipedia.org/wiki/Hardware_security_module\"\u003e专用硬件\u003c/a\u003e\n上，连接到某些物理空间隔离的设备上，有很好的物理安全性，有严格的使用流程。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e一些 internal PKI 也遵循类似的实践，但实际上并没有这个必要\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果能自动化 root certificate rotation （例如，通过配置管理或编排工具，更新信任仓库），\n你就能轻松地 rotate 一个 compromised root key。\u003c/li\u003e\n  \u003cli\u003e由于人们如此沉迷于 internal PKI 的根秘钥管理，导致 internal PKI 的部署效率大大\n降低。你的 AWS root account credentials 至少也是机密信息，你又是如何管理它的呢？\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"92-intermediates-chains-and-bundling\"\u003e9.2 Intermediates, Chains, and Bundling\u003c/h2\u003e\n\n\u003cp\u003e在 root CA offline 的前提下，为使证书 issuance 可扩展（例如，使自动化成为可能），\nroot private key 只在很少情况下使用，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e用来签发几个\u003cem\u003eintermediate certificates\u003c/em\u003e。\u003c/li\u003e\n  \u003cli\u003e然后 intermediate CA（也称为 subordinate CAs）用相应的 intermediate private keys 来签发 leaf certificates to subscribers。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/cert-path.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eImage credit: \u003ca href=\"https://brainbit.io/posts/cilium-tls-inspection/\"\u003eCilium TLS inspection\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e下面这张图把签发关系展示地更清楚，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/trust-chain.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eImage credit: \u003ca href=\"https://brainbit.io/posts/cilium-tls-inspection/\"\u003eCilium TLS inspection\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003eIntermediates 通常并不包含在信任仓库中，所以撤回或 roate 比较容易\u003c/mark\u003e\u003c/strong\u003e，\n因此通过 intermediate CA，就实现了 certificate issuance 的在线和自动化（online and automated）。\u003c/p\u003e\n\n\u003cp\u003e这种 leaf、intermediate、root 组成的证书捆绑（bundle）机制，\n形成了一个\u003cstrong\u003e\u003cmark\u003e证书链\u003c/mark\u003e\u003c/strong\u003e（certificate chain）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eleaf 由 intermediate 签发，\u003c/li\u003e\n  \u003cli\u003eintermediate 又由 root 签发，\u003c/li\u003e\n  \u003cli\u003eroot 自签名（signs itself）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e技术上来说，上面都是简化的例子，你可以创建更长的 chain 和更复杂的图（例如，\n\u003ca href=\"https://docs.microsoft.com/en-us/windows/desktop/seccertenroll/about-cross-certification\"\u003ecross-certification\u003c/a\u003e）。\n但不推荐这么做，因为复杂性很快会失控。在任何情况下，\nend entity certificates 都是叶子节点，这也是称为叶子证书（leaf certificate）的原因。\u003c/p\u003e\n\n\u003cp\u003e当配置一个 \u003cstrong\u003e\u003cmark\u003esubscriber\u003c/mark\u003e\u003c/strong\u003e 时（例如，Apache、Nginx、Linkderd、\u003cstrong\u003e\u003cmark\u003eEnvoy\u003c/mark\u003e\u003c/strong\u003e），\n通常不仅需要叶子证书，还需要一个\u003cstrong\u003e\u003cmark\u003e包含了 intermediates 的 certificate bundle\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e有时会用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePKCS#7\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePKCS#12\u003c/code\u003e，因为它们能包含一个完整的证书链（certificate chain）。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e更多情况下，证书链编码成一个简单的空行隔开的 PEM 对象（sequence of line-separated PEM objects）。\u003c/p\u003e\n\n    \u003cp\u003eSome stuff expects the certs to be ordered from leaf to root, other stuff expects root to leaf, and some stuff doesn’t care.\n  More annoying inconsistency. Google and Stack Overflow help here. Or trial and error.\u003c/p\u003e\n\n    \u003cp\u003e下面是一个例子：\u003c/p\u003e\n\n    \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003eserver.crt\n  \u003cspan class=\"nt\"\u003e-----BEGIN\u003c/span\u003e CERTIFICATE-----\n  MIICFDCCAbmgAwIBAgIRANE187UXf5fn5TgXSq65CMQwCgYIKoZIzj0EAwIwHzEd\n  ...\n  MBsGA1UEAxMUVGVzdCBJbnRlcm1lZGlhdGUgQ0EwHhcNMTgxMjA1MTc0OTQ0WhcN\n  HO3iTsozZsCuqA34HMaqXveiEie4AiEAhUjjb7vCGuPpTmn8HenA5hJplr+Ql8s1\n  d+SmYsT0jDU\u003cspan class=\"o\"\u003e=\u003c/span\u003e\n  \u003cspan class=\"nt\"\u003e-----END\u003c/span\u003e CERTIFICATE-----\n  \u003cspan class=\"nt\"\u003e-----BEGIN\u003c/span\u003e CERTIFICATE-----\n  MIIBuzCCAWKgAwIBAgIRAKBv/7Xs6GPAK4Y8z4udSbswCgYIKoZIzj0EAwIwFzEV\n  ...\n  BRvPAJZb+soYP0tnObqWdplmO+krWmHqCWtK8hcCIHS/es7GBEj3bmGMus+8n4Q1\n  x8YmK7ASLmSCffCTct9Y\n  \u003cspan class=\"nt\"\u003e-----END\u003c/span\u003e CERTIFICATE-----\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003eAgain, annoying and baroque, but not rocket science.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"93-rpcertificate-path-validation\"\u003e9.3 RP：Certificate path validation\u003c/h2\u003e\n\n\u003cp\u003e由于 \u003cstrong\u003e\u003cmark\u003eintermediate certificates 并未包含在信任仓库中，因此需要与\nleaf certificates 一样分发和验证\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e前面已经介绍，配置 subscriber 时需要提供这些 intermediates，\u003cstrong\u003e\u003cmark\u003esubscribers 随后再将它们传给 RP\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e如果使用 TLS，那这个过程发生在 \u003cstrong\u003e\u003cmark\u003eTLS 握手时\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e当一个 subscriber 将它的证书发给 relying party 时，其中会包含所有能证明来自信任的根证书的 intermediates。\u003c/li\u003e\n  \u003cli\u003erelying party 通过一个称为 \u003cstrong\u003e\u003cmark\u003ecertificate path validation\u003c/mark\u003e\u003c/strong\u003e 的过程来验证 leaf 和 intermediate certificates 。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/cert-path-validation.jpg\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e完整的 \u003ca href=\"https://tools.ietf.org/html/rfc5280#section-6\"\u003ecertificate path validation\u003c/a\u003e\n算法比较复杂。包括了\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003echecking certificate expirations\u003c/li\u003e\n  \u003cli\u003erevocation status\u003c/li\u003e\n  \u003cli\u003evarious certificate policies\u003c/li\u003e\n  \u003cli\u003ekey use restrictions\u003c/li\u003e\n  \u003cli\u003ea bunch of other stuff\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e显然，PKI RP 准确实现这个算法是非常关键的。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果\u003cstrong\u003e\u003cmark\u003e关闭 certificate path validation\u003c/mark\u003e\u003c/strong\u003e\n(例如，\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecurl -k\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e)，用户将面临重大风险，所以不要关闭。\u003c/li\u003e\n  \u003cli\u003e完成正确的 TLS 并没有那么难，certificate path validation 是\n\u003cstrong\u003e\u003cmark\u003eTLS 中完成认证（authentication）的部分\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e可能有人会说，channel 已经是加密的了，因此关闭没关系 —— 错，有关系。\n\u003cstrong\u003e\u003cmark\u003e没有认证（authentication）的加密是毫无价值的\u003c/mark\u003e\u003c/strong\u003e —— 这就像在教堂忏悔：\n你说的话都是私密的，但却并不知道帘幕后面的人是谁 —— 只不过这里不是教堂，而是互联网。\u003c/p\u003e\n\n\u003ch1 id=\"10-秘钥和证书的生命周期\"\u003e10 秘钥和证书的生命周期\u003c/h1\u003e\n\n\u003cp\u003e在能通过 TLS 等协议使用证书之前，要先\u003cstrong\u003e\u003cmark\u003e配置如何从 CA 获取一个证书\u003c/mark\u003e\u003c/strong\u003e。\n逻辑上来说这是一个相当简单的过程：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e需要证书的 subscriber 自己先生成一个 key pair，然后通过请求发送给 CA，\u003c/li\u003e\n  \u003cli\u003eCA 检查其中关联的 name 是否正确，如果正确就签名并返回一个证书。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e证书会过期，过期的证书就不会被 RP 信任了。如果证书快过期了而还想继续用它，就需要\n续期（renew ）并轮转（rotate）它。如果想在一个证书过期之前就让 RP 停止信任它，就需要执行撤销（revoke）。\u003c/p\u003e\n\n\u003cp\u003e与 PKI 相关的大部分东西一样，\u003cstrong\u003e\u003cmark\u003e这些看似简单的过程实际上都充满坑\u003c/mark\u003e\u003c/strong\u003e。\n其中也隐藏了计算机科学中最难的两个问题：缓存一致性和命名（naming）。\n但另一方面，一旦理解了背后的原理，再反过来看实际在用的一些东西就简单多了。\u003c/p\u003e\n\n\u003ch2 id=\"101-naming-things命名相关\"\u003e10.1 Naming things（命名相关）\u003c/h2\u003e\n\n\u003ch3 id=\"dn-distinguished-names\"\u003eDN (distinguished names)\u003c/h3\u003e\n\n\u003cp\u003e历史上，X.509 使用 X.500 distinguished names (DN) 来命名证书的使用者（name the subject of a certificate），即 subscriber。\n一个 DN 包含了一个 common name （对作者我来说，就是 “Mike Malone”），此外还可以包含\nlocality、country、organization、organizational unit 及其他一些东西（数字电话簿相关）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e没人理解 DN，它在互联网上也没什么意义\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e应该避免使用 DN。如果真的要用，也要尽量保持简单。\u003c/li\u003e\n  \u003cli\u003e无需使用全部字段，实际上，也不应该使用全部字段。\u003c/li\u003e\n  \u003cli\u003ecommon name 可能就是\u003cstrong\u003e\u003cmark\u003e需要用到的全部字段\u003c/mark\u003e\u003c/strong\u003e了，如果你是一个 thrill seeker ，可以在用上一个 organization name。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003ePKIX 规定一个网站的 DNS hostname 应该关联到 DN \u003cem\u003ecommon name\u003c/em\u003e。最近，CAB Forum 已\n经废弃了这个规定，使整个 DN 字段变成可选的（Baseline Requirements, sections\n7.1.4.2）。\u003c/p\u003e\n\n\u003ch3 id=\"san-subject-alternative-name\"\u003eSAN (subject alternative name)\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e现代最佳实践\u003c/mark\u003e\u003c/strong\u003e使用\n\u003ca href=\"https://tools.ietf.org/html/rfc5280#section-4.2.1.6\"\u003esubject alternative name (SAN) X.509 extension\u003c/a\u003e\n来 \u003cstrong\u003e\u003cmark\u003ebind 证书中的 name\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e常用的 SAN 有四种类型，绑定的都是广泛使用的名字：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003edomain names (DNS)\u003c/li\u003e\n  \u003cli\u003eemail addresse\u003c/li\u003e\n  \u003cli\u003eIP addresse\u003c/li\u003e\n  \u003cli\u003eURI\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在我们讨论的上下文中，这些\u003cstrong\u003e\u003cmark\u003e都是唯一的\u003c/mark\u003e\u003c/strong\u003e，而且它们\u003cstrong\u003e\u003cmark\u003e能很好地映射到我们想识别的东西\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eemail addresses for people\u003c/li\u003e\n  \u003cli\u003edomain names and IP addresses for machines and code,\u003c/li\u003e\n  \u003cli\u003eURIs if you want to get fancy\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e应该使用 SAN。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/inspect-san-dns.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e注意，Web PKI 允许在一个证书内 bind 多个 name，name 也也允许通配符。也就是说，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一个证书可以有多个 SAN，也可以有类似 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e*.smallstep.com\u003c/code\u003e 这样的 SAN。\u003c/li\u003e\n  \u003cli\u003e这对有多个域名的的网站来说很有用。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"102-生成-key-pairs\"\u003e10.2 生成 key pairs\u003c/h2\u003e\n\n\u003cp\u003e有了 name 之后，需要先生成一个密钥对，然后才能创建证书。前面提到：PKI 的安全性\n在根本上取决于一个简单的事实：\u003cstrong\u003e\u003cmark\u003e只有与证书中的 subscriber name 对应的 entity，才应该拥有与该证书对应的私钥\u003c/mark\u003e\u003c/strong\u003e。\n为确保这个条件成立，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e最佳实践是\u003cstrong\u003e\u003cmark\u003e让 subscriber 生成它自己的密钥对，这样就只有它自己知道私钥\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e绝对应该避免通过网络发送私钥。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e生成证书时\u003cstrong\u003e\u003cmark\u003e使用什么类型的秘钥\u003c/mark\u003e\u003c/strong\u003e？这一主题值得单独写一篇文章，这里\n只提供一点快速指导（截止 2018.12）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如今有一个缓慢但清晰的\u003cstrong\u003e\u003cmark\u003e从 RSA 转向椭圆曲线秘钥的趋势\u003c/mark\u003e\u003c/strong\u003e（\n\u003ca href=\"https://blog.cloudflare.com/ecdsa-the-digital-signature-algorithm-of-a-better-internet\"\u003eECDSA\u003c/a\u003e\n或 \u003ca href=\"https://tools.ietf.org/html/rfc8032\"\u003eEdDSA\u003c/a\u003e）。\u003c/li\u003e\n  \u003cli\u003e如果决定使用 RSA 秘钥，确保它们至少是 2048 比特长，但也不要超过 4096 比特。\u003c/li\u003e\n  \u003cli\u003e如果使用 ECDSA，那 P-256 曲线可能是最好选择（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esecp256k1\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprime256v1\u003c/code\u003e in openssl），\n除非你担心 NSA，这种情况下你可以选择更 fancier 一些的东西，例如 EdDSA with Curve25519（但对这些秘钥的支持还不是太好）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e下面是用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eopenssl\u003c/code\u003e 生成一个椭圆曲线 P-256 key pair 的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eopenssl ecparam \u003cspan class=\"nt\"\u003e-name\u003c/span\u003e prime256v1 \u003cspan class=\"nt\"\u003e-genkey\u003c/span\u003e \u003cspan class=\"nt\"\u003e-out\u003c/span\u003e k.prv\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eopenssl ec \u003cspan class=\"nt\"\u003e-in\u003c/span\u003e k.prv \u003cspan class=\"nt\"\u003e-pubout\u003c/span\u003e \u003cspan class=\"nt\"\u003e-out\u003c/span\u003e k.pub\n\n\u003cspan class=\"c\"\u003e# 也可以用 step 生成\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003estep crypto keypair \u003cspan class=\"nt\"\u003e--kty\u003c/span\u003e EC \u003cspan class=\"nt\"\u003e--curve\u003c/span\u003e P-256 k.pub k.prv\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e还可以通过编程来生成这些证书，这样能做到证书不落磁盘。\u003c/p\u003e\n\n\u003ch2 id=\"103-issuance确保证书中的信息都是对的\"\u003e10.3 Issuance（确保证书中的信息都是对的）\u003c/h2\u003e\n\n\u003cp\u003esubscriber 有了一个 name 和一对 key 之后，下一步就是\u003cstrong\u003e\u003cmark\u003e从 CA 获取一个 leaf certificate\u003c/mark\u003e\u003c/strong\u003e。\n对 CA 来说，它需要认证（证明）两件事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003esubscriber 证书中的公钥，确实是该 subscriber 的公钥（例如，验证该 subscriber 知道对应的私钥）；\u003c/p\u003e\n\n    \u003cp\u003e这一步通常通过一个简单的技术机制实现：\u003cstrong\u003e\u003cmark\u003e证书签名请求\u003c/mark\u003e\u003c/strong\u003e（certificate signing request, CSR）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e证书中将要绑定的 name，确实是该 subscriber 的 name。\u003c/p\u003e\n\n    \u003cp\u003e这一步要难很多。抽象来说，这个过程称为 \u003cstrong\u003e\u003cmark\u003eidentity proofing（身份证明）或 registration（注册）\u003c/mark\u003e\u003c/strong\u003e.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"1031-certificate-signing-requests证书签名请求pkcs10\"\u003e10.3.1 Certificate signing requests（证书签名请求，PKCS#10）\u003c/h3\u003e\n\n\u003cp\u003eSubscriber 请求一个证书时，会向 CA 会提交一个 certificate signing request (CSR)。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eCSR 也是一个 ASN.1 结构\u003c/mark\u003e\u003c/strong\u003e，定义在 \u003ca href=\"https://tools.ietf.org/html/rfc2986\"\u003ePKCS#10\u003c/a\u003e。\u003c/li\u003e\n  \u003cli\u003e与证书类似，CSR 数据结构包括一个公钥、一个名字和一个签名。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eCSR 是\u003cstrong\u003e\u003cmark\u003e自签名的\u003c/mark\u003e\u003c/strong\u003e，用与 CRS 中公钥对应的私钥自签名。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e这个签名用于证明该 subscriber 有对应的私钥，能对任何用其公钥加密的东西进行解密。\u003c/li\u003e\n      \u003cli\u003e还使即使 CSR 被复制或转发，都没有能篡改其中的内容（篡改无效）。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eCSR 中包括了很多证书细节配置项。但在实际中，大部分配置项都会被 CA 忽略。大部分 CA 都使用自己的固定模板，\n或提供一个 administrative 接口来收集这些信息。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estep\u003c/code\u003e 命令创建一个密钥对和 CSR 的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003estep certificate create \u003cspan class=\"nt\"\u003e-csr\u003c/span\u003e test.smallstep.com test.csr test.key\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eOpenSSL 功能也非常强大，但 \u003ca href=\"https://www.openssl.org/docs/manmaster/man1/openssl-req.html\"\u003e用起来不够方便\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"1032-identity-proofing身份证明过程\"\u003e10.3.2 Identity proofing（身份证明过程）\u003c/h3\u003e\n\n\u003cp\u003eCA 收到一个 CSR 并验证签名之后，接下来需要确认证书中绑定的 name 是否真的\n是这个 subscriber 的 name。这项工作很棘手。\n证书的核心功能是\u003cstrong\u003e\u003cmark\u003e能让 RP 对 subscriber 进行认证\u003c/mark\u003e\u003c/strong\u003e。因此，\n如果一个\u003cstrong\u003e\u003cmark\u003e证书都还没有颁发，CA 如何对这个 subscriber 进行认证呢\u003c/mark\u003e\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e答案是：分情况。\u003c/p\u003e\n\n\u003ch4 id=\"web-pki-证明身份过程\"\u003eWeb PKI 证明身份过程\u003c/h4\u003e\n\n\u003cp\u003eWeb PKI 有三种类型的证书，它们\u003cstrong\u003e\u003cmark\u003e最大的区别就是如何识别 subscriber\u003c/mark\u003e\u003c/strong\u003e，\n以及它们所用到的 \u003cstrong\u003e\u003cmark\u003eidentity proofing 机制\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这三种证书是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003edomain validation (DV，域验证)\u003c/p\u003e\n\n    \u003cp\u003eDV 证书绑定的是 \u003cstrong\u003e\u003cmark\u003eDNS name\u003c/mark\u003e\u003c/strong\u003e，CA 在颁发时需要验证的这个 domain name 确实是由该 subscriber 控制的。\u003c/p\u003e\n\n    \u003cp\u003e证明过程通常是通过一个简单的流程，例如\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e给 WHOIS 记录中该 domain name 的管理员发送一封确认邮件。\u003c/li\u003e\n      \u003cli\u003e\n        \u003cp\u003e\u003ca href=\"https://ietf-wg-acme.github.io/acme/draft-ietf-acme-acme.html\"\u003eACME protocol\u003c/a\u003e\n   （最初由 Let’s Encrypt 开发和使用）改进了这种方式，更加自动化：不再用邮件验证\n   ，而是由 ACME CA 提出一个 challenge，该 subscriber 通过完成这个问题来证明它拥有\n   这个域名。challenge 部分属于 ACME 规范的扩展部门，常见的包括：\u003c/p\u003e\n\n        \u003cul\u003e\n          \u003cli\u003e在指定的 URL 上提供一个随机数（HTTP challenge）\u003c/li\u003e\n          \u003cli\u003e在 DNS TXT 记录中放置一个随机数（DNS challenge）\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eorganization validation (OV，组织验证)\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eOV 和下面将介绍的 EV 证书构建在 DV 证书之上，它们包括了 name 和域名\n\u003cstrong\u003e\u003cmark\u003e所属组织的位置信息（location）\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n      \u003cli\u003eOV 和 EV 证书不仅仅将证书关联到域名，还关联到控制这个域名的法律实体（legal entity）。\u003c/li\u003e\n      \u003cli\u003eOV 证书的验证过程，不同的 CA 并不统一。为解决这个问题，CAB Forum 引入了 EV 证书。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003eextended validation\u003c/mark\u003e\u003c/strong\u003e (EV，扩展验证)\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eEV 证书包含的基本信息与 OV 是一样的，但强制要求严格验证（identity proofing）。\u003c/li\u003e\n      \u003cli\u003eEV 过程需要几天或几个星期，其中可能包括公网记录搜索（public records searches）和公司人员（用笔）签署的（纸质）证词。\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e这些完成之后，当相应网站时，\u003cstrong\u003e\u003cmark\u003e某些浏览器会在 URL 栏中显示该组织的名称\u003c/mark\u003e\u003c/strong\u003e。例如：\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/github-ev.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n    \u003cp\u003e但除了这个场景之外，EV certificates 并未得到广泛使用，Web PKI RP 也未强依赖它。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e本质上来说，每个 Web PKI RP 只需要 DV 级别的 assurance\u003c/mark\u003e\u003c/strong\u003e 就行了，\n也就是确保域名是被该 subscriber 控制的。重要的是能理解一个 DV 证书在设计上的意思和在实际上做了什么：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在设计上，希望通过它证明：请求这个证书的 entity 拥有对应的域名；\u003c/li\u003e\n  \u003cli\u003e在实际上，真正完成的操作是：在某个时间，请求这个证书的 entity 能读一封邮件，或配置一条 DNS 记录，或能通过 HTTP serve 一个指定随机数等等。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但话说回来，DNS、电子邮件和 BGP 这些底层基础设施本身的安全性也并没有做到足够好，\n针对这些基础设施的攻击还是\n\u003ca href=\"https://doublepulsar.com/hijack-of-amazons-internet-domain-service-used-to-reroute-web-traffic-for-two-hours-unnoticed-3a6f0dda6a6f\"\u003e时有发生\u003c/a\u003e，\n目的之一就是获取证书。\u003c/p\u003e\n\n\u003ch4 id=\"internal-pki-证明身份过程\"\u003eInternal PKI 证明身份过程\u003c/h4\u003e\n\n\u003cp\u003e上面是 Web PKI 的身份证明过程，再来看 internal PKI 的身份证明过程。\u003c/p\u003e\n\n\u003cp\u003e实际上，用户可以使用\u003cstrong\u003e\u003cmark\u003e任何方式\u003c/mark\u003e\u003c/strong\u003e来做 internal PKI 的 identity proofing，\n并且效果可能比 Web PKI 依赖 DNS 或邮件方式的效果更好。\u003c/p\u003e\n\n\u003cp\u003e乍听起来好像很难，但其实不难，因为可以\u003cstrong\u003e\u003cmark\u003e利用已有的受信基础设施\u003c/mark\u003e\u003c/strong\u003e：\n用来搭建基础设施的工具，也能用来为这些基础设施之上的服务创建和证明安全身份。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果用户已经信任 Chef/Puppet/Ansible/Kubernetes，允许它们将代码放到服务器上，\n那也应该信任它们能完成 identity attestations\u003c/li\u003e\n  \u003cli\u003e如果在 AWS 上，可以用 \u003ca href=\"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html\"\u003einstance\nidentity documents\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e如果在 GCP：\u003ca href=\"https://cloud.google.com/compute/docs/instances/verifying-instance-identity\"\u003eGCP\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/how-to-use-vm-token\"\u003eAzure\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eprovisioning infrastructure 必须理解 identity 的概念，这样才能将正确的代码放到正确的位置。\n此外，用户必须信任这套机制。基于这些知识和信任，才能配置 RP 信任仓库、将 subscribers 纳入你的 internal PKI 管理范围。\n而完成这些功能全部所需做的就是：设计和实现某种方式，能让\nprovisioning infrastructure 在每个服务启动时，能将它们的 identity 告诉你的 CA。\n顺便说一句，这正是\n\u003ca href=\"https://smallstep.com/certificates/\"\u003estep certificates\u003c/a\u003e 解决的事情。\u003c/p\u003e\n\n\u003ch2 id=\"104-expiration过期\"\u003e10.4 Expiration（过期）\u003c/h2\u003e\n\n\u003cp\u003e证书通常都会过期。虽然这不是强制规定，但一般都这么做。设置一个过期时间非常重要，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e证书都是分散在各处的\u003c/mark\u003e\u003c/strong\u003e：通常 RP 在验证一个证书时，并没有某个中心式权威能感知到（这个操作）。\u003c/li\u003e\n  \u003cli\u003e如果没有过期时间，证书将永久有效。\u003c/li\u003e\n  \u003cli\u003e安全领域的一条经验就是：\u003cstrong\u003e\u003cmark\u003e时间过的越久，凭证被泄露的概率就越接近 100%\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e因此，设置过期时间非常重要。具体来说，X.509 证书中包含一个有效时间范围：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cem\u003eissued at\u003c/em\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cem\u003enot before\u003c/em\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cem\u003enot after\u003c/em\u003e：过了这个时间，证书就过期了。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这个机制看起来设计良好，但实际上也是有一些不足的：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e首先，\u003cstrong\u003e\u003cmark\u003e没有什么能阻止 RP\u003c/mark\u003e\u003c/strong\u003e 错误地（或因为糟糕的设计）\u003cstrong\u003e\u003cmark\u003e接受一个过期证书\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e其次，证书是分散的。验证证书是否过期是每个 RP 的责任，而有时它们会出乱子。例如，\u003cstrong\u003e\u003cmark\u003eRP 依赖的系统时钟不对\u003c/mark\u003e\u003c/strong\u003e时。\n\u003cstrong\u003e\u003cmark\u003e最坏的情况就是系统时钟被重置为了 unix epoch\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1970.1.1\u003c/code\u003e），此时它无法信任任何证书。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在 subscriber 侧，证书过期后，私钥要处理得当：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果一个密钥对之前是\u003cstrong\u003e\u003cmark\u003e用来签名/认证\u003c/mark\u003e\u003c/strong\u003e的（例如，基于 TLS），\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e应该在不需要这个密钥对之后，\u003cstrong\u003e\u003cmark\u003e立即删除私钥\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n      \u003cli\u003e保留已经失效的签名秘钥（signing key）会导致不必要的风险：对谁都已经没有用处，反而会被拿去仿冒签名。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e如果密钥对是\u003cstrong\u003e\u003cmark\u003e用来加密的\u003c/mark\u003e\u003c/strong\u003e，情况就不同了。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e只要还有数据是用这个加密过的，就需要\u003cstrong\u003e\u003cmark\u003e留着这个私钥\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这就是为什么很多人会说，\u003cstrong\u003e\u003cmark\u003e不要用同一组秘钥来同时做签名和加密\u003c/mark\u003e\u003c/strong\u003e（signing and encryption）。\n因为当一个用于签名的私钥过期时，\u003cstrong\u003e\u003cmark\u003e无法实现秘钥生命周期的最佳管理\u003c/mark\u003e\u003c/strong\u003e：\n最终不得不保留着这个私钥，因为解密还要用它。\u003c/p\u003e\n\n\u003ch2 id=\"105-renewal续期\"\u003e10.5 Renewal（续期）\u003c/h2\u003e\n\n\u003cp\u003e证书快过期时，如果还想继续使用，就需要续期。\u003c/p\u003e\n\n\u003ch3 id=\"1051-web-pki-证书续期\"\u003e10.5.1 Web PKI 证书续期\u003c/h3\u003e\n\n\u003cp\u003eWeb PKI 实际上并\u003cstrong\u003e\u003cmark\u003e没有标准的续期过期\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e没有一个标准方式来延长证书的合法时间，\u003c/li\u003e\n  \u003cli\u003e一般是\u003cstrong\u003e\u003cmark\u003e直接用一个新证书替换过期的\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e因此续期过程和 issuance 过程是一样的：\u003cstrong\u003e\u003cmark\u003e生成并提交一个 CSR\u003c/mark\u003e\u003c/strong\u003e，然后完成 identity proofing。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"1052-internal-pki-证书续期\"\u003e10.5.2 Internal PKI 证书续期\u003c/h3\u003e\n\n\u003cp\u003e对于 internal PKI 我们能做的更好。\u003c/p\u003e\n\n\u003cp\u003e最简单的方式是：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e用 mTLS 之类的协议对老证书续期\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003eCA 能对 subscriber 提供的客户端证书进行认证（authenticate），\u003cstrong\u003e\u003cmark\u003e重签一个更长的时间\u003c/mark\u003e\u003c/strong\u003e，然后返回这个证书。\u003c/li\u003e\n  \u003cli\u003e这使得续期过程\u003cstrong\u003e\u003cmark\u003e很容易自动化\u003c/mark\u003e\u003c/strong\u003e，而且强制 subscriber 定期与中心权威保持沟通。\u003c/li\u003e\n  \u003cli\u003e基于这种机制能轻松\u003cstrong\u003e\u003cmark\u003e构建一个证书的监控和撤销基础设施\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"1053-小结\"\u003e10.5.3 小结\u003c/h3\u003e\n\n\u003cp\u003e证书的续期过程其实并不是太难，\u003cstrong\u003e\u003cmark\u003e最难的是记得续期这件事\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e几乎每个管理过公网证书的人，都经历过证书过期导致的生产事故，\u003ca href=\"https://expired.badssl.com/\"\u003e例如这个\u003c/a\u003e。\n我的建议是：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e发现问题之后，一定要全面排查，解决能发现的所有此类问题。\u003c/li\u003e\n  \u003cli\u003e另外，使用生命周期比较短的证书。这会反过来逼迫你们优化和自动化整个流程。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eLet’s Encrypt 使自动化非常容易，它签发 90 天有效期的证书，因此对 Web PKI 来说非常合适。\n对于 internal PKI，建议有效期签的更短：24 小时或更短。有一些实现上的挑战 ——\n\u003ca href=\"https://diogomonica.com/2017/01/11/hitless-tls-certificate-rotation-in-go/\"\u003ehitless certificate rotation\u003c/a\u003e\n可能比较棘手 —— 但这些工作是值得的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estep\u003c/code\u003e 检查证书过期时间：\u003c/p\u003e\n\n  \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003estep certificate inspect cert.pem \u003cspan class=\"nt\"\u003e--format\u003c/span\u003e json | jq .validity.end\nstep certificate inspect https://smallstep.com \u003cspan class=\"nt\"\u003e--format\u003c/span\u003e json | jq .validity.end\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e将这种命令行封装到监控采集脚本，就可以实现某种程度的监控和自动化。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"106-revocation撤销\"\u003e10.6 Revocation（撤销）\u003c/h2\u003e\n\n\u003cp\u003e如果一个私钥泄露了，或者一个证书已经不再用了，就需要撤销它。即希望：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e明确地将其标记为非法的，\u003c/li\u003e\n  \u003cli\u003e所有 RP 都不再信任这个证书了，即使它还未过期。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e但实际上，\u003cstrong\u003e\u003cmark\u003e撤销证书过程也是一团糟\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"1061--主动撤销的困难\"\u003e10.6.1  主动撤销的困难\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e与过期类似，\u003cstrong\u003e\u003cmark\u003e执行撤回的职责在 RP\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e与过期不同的是，\u003cstrong\u003e\u003cmark\u003e撤销状态无法编码在证书中\u003c/mark\u003e\u003c/strong\u003e。RP 只能依靠某些带外过程（out-of-band process）\n来判断证书的撤销状态。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e除非显式配置，否则大部分 Web PKI TLS RP 并不关注撤销状态。换句话说，默认情况下，\n大部分 TLS 实现都乐于接受已经撤销的证书。\u003c/p\u003e\n\n\u003ch3 id=\"1062-internal-pki被动撤销机制\"\u003e10.6.2 Internal PKI：被动撤销机制\u003c/h3\u003e\n\n\u003cp\u003eInternal PKI 的趋势是接受这个现实，然后试图通过\u003cstrong\u003e\u003cmark\u003e被动撤销\u003c/mark\u003e\u003c/strong\u003e（passive revocation）机制来弥补，\n具体来说就是\u003cstrong\u003e\u003cmark\u003e签发生命周期很短的证书\u003c/mark\u003e\u003c/strong\u003e，这样就使撤销过程变得不再那么重要了。\n想撤销一个证书时，直接不给它续期就行了，过一段时间就会自动过期。\u003c/p\u003e\n\n\u003cp\u003e可以看到，\u003cstrong\u003e\u003cmark\u003e这个机制有效的前提\u003c/mark\u003e\u003c/strong\u003e就是使用生命周期很短的证书。具体有多短？\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e取决于你的威胁模型（安全专家说了算）。\u003c/li\u003e\n  \u003cli\u003e24 小时是很常见的，但也有短到 5 分钟的。\u003c/li\u003e\n  \u003cli\u003e如果生命周期太短，显然也会给可扩展性和可用性带来挑战：\u003cstrong\u003e\u003cmark\u003e每次续期都需要与 online CA 交互\u003c/mark\u003e\u003c/strong\u003e，\n  因此 CA 有性能压力。\u003c/li\u003e\n  \u003cli\u003e如果缩短了证书的生命周期，记得\u003cstrong\u003e\u003cmark\u003e确保你的时钟是同步的\u003c/mark\u003e\u003c/strong\u003e，否则就有罪受了。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e对于 web 和其他的被动撤销不适合的场景，如果认真思考之后发现\u003cstrong\u003e\u003cmark\u003e真的\u003c/mark\u003e\u003c/strong\u003e\n需要撤销功能，那有两个选择：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCRL（，\u003cstrong\u003e\u003cmark\u003e证书撤销列表\u003c/mark\u003e\u003c/strong\u003e，RFC 5280）\u003c/li\u003e\n  \u003cli\u003eOCSP（Online Certificate Signing Protocol，\u003cstrong\u003e\u003cmark\u003e在线证书签名协议\u003c/mark\u003e\u003c/strong\u003e，RFC 2560）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"1063-主动检查机制crlcertificate-revocation-lists\"\u003e10.6.3 主动检查机制：CRL（Certificate Revocation Lists）\u003c/h3\u003e\n\n\u003cp\u003eCRL 定义在 RFC 5280 中，这是一个相当庞杂的 RFC，还定义了很多其他东西。\n简单来是，CRL 是一个\u003cstrong\u003e\u003cmark\u003e有符号整数序列，用来识别已撤销的证书\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这个维护在一个 \u003cstrong\u003e\u003cmark\u003eCRL distribution point\u003c/mark\u003e\u003c/strong\u003e 服务中，每个证书中都包含指向这个服务的 URL。\n工作流程：每个 RP 下载这个列表并缓存到本地，在对证书进行验证时，从本地缓存查询撤销状态。\n但这里也有一些明显的问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eCRL 可能很大\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003edistribution point 也可能失效。\u003c/li\u003e\n  \u003cli\u003eRP 的 CRL 缓存同步经常是天级的，因此如果一个证书撤销了，可能要几天之后才能同步到这个状态。\u003c/li\u003e\n  \u003cli\u003e此外，RP \u003cem\u003efail open\u003c/em\u003e 也很常见 —— CRL distribution point 挂了之后，就接受这个证书。\n  这显然是一个安全问题：只要对 CRL distribution point 发起 DDoS 攻击，就能让 RP 接受一个已经撤销的证书。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此，即使已经在用 CRL，也应该考虑使用短时证书来保持 CRL size 比较小。\nCRL 只需要包含\u003cstrong\u003e\u003cmark\u003e已撤销但还未过期的证书\u003c/mark\u003e\u003c/strong\u003e的 serial numbers，因此\n证书生命周期越短，CRL 越短。\u003c/p\u003e\n\n\u003ch3 id=\"1064-主动检查机制ocsponline-certificate-signing-protocol\"\u003e10.6.4 主动检查机制：OCSP（Online Certificate Signing Protocol）\u003c/h3\u003e\n\n\u003cp\u003e主动检查机制除了 CRL 之外，另一个选择是 OCSP，它允许 RP 实时查询一个 \u003cem\u003eOCSP responder\u003c/em\u003e：\n指定证书的 serial number 来获取这个证书的撤销状态。\u003c/p\u003e\n\n\u003cp\u003e与 CRL distribution point 类似，OCSP responder URL 也包含在证书中。\n这样看，OCSP 似乎更加友好，但实际上它也有自己的问题。对于 Web PKI，它引入了验证的隐私问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每次查询 OCSP responder，使得它能看到我正在访问哪个网站。\u003c/li\u003e\n  \u003cli\u003e此外，它还增加了每个 TLS 连接的开销：需要一个额外请求来检查证实的撤销状态。\u003c/li\u003e\n  \u003cli\u003e与 CRL 一样，很多 RPs (including browsers) 会在 OCSP responder 失效时直接认为证书有效（未撤销）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"1065-主动检查机制ocsp-stapling合订绑定\"\u003e10.6.5 主动检查机制：OCSP stapling（合订，绑定）\u003c/h3\u003e\n\n\u003cp\u003eOCSP stapling 是 OCSP 的一个变种，目的是解决以上提到的那些问题。\u003c/p\u003e\n\n\u003cp\u003e相比于让 RP 每次都去查询 OCSP responder，OCSP stapling 中让证书的 subscriber 来做这件事情。\nOCSP response 是一个经过签名的、时间较短的证词（signed attestation），证明这个证书未被撤销。\u003c/p\u003e\n\n\u003cp\u003eattestation 包含在 subscriber 和 RP 的 TLS handshake (“stapled to” the certificate) 中。\n这给 RP 提供了相对比较及时的撤销状态，而不用每次都去查询 OCSP responder。\nsubscriber 可以在 signed OCSP response 过期之前多次使用它。这减少了 OCSP 的负担，也解决了 OCSP 的隐私问题。\u003c/p\u003e\n\n\u003cp\u003e但是，所有这些东西其实最终都像是一个 \u003cstrong\u003e\u003cmark\u003e鲁布·戈德堡装置（Rube Goldberg Device） \u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e鲁布·戈德堡机械（Rube Goldberg machine）是一种被设计得过度复杂的机械组合，以\n迂回曲折的方法去完成一些其实是非常简单的工作，例如倒一杯茶，或打一只蛋等等。\n设计者必须计算精确，令机械的每个部件都能够准确发挥功用，因为任何一个环节出错\n，都极有可能令原定的任务不能达成。\u003c/p\u003e\n\n  \u003cp\u003e解释来自 \u003ca href=\"https://www.zhihu.com/topic/20017497/intro\"\u003e知乎\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e如果让 subscribers 去 CA 获取一些生命周期很短的证词（signed attestation）来证明对应的证书并没有过期，\n为什么不直接干掉中间环节，直接使用生命周期很短的证书呢？\u003c/p\u003e\n\n\u003ch1 id=\"11-使用证书\"\u003e11 使用证书\u003c/h1\u003e\n\n\u003cp\u003e虽然理解 PKI 需要以上长篇大论，但在实际中用证书其实是非常简单的。\u003c/p\u003e\n\n\u003cp\u003e下面以 TLS 为例，其他方式也是类似的：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e配置 PKI relying party 使用哪个根证书；\u003c/p\u003e\n\n    \u003cp\u003e对于 Web PKI，通常已经默认配置了正确的根证书，这一步可以跳过。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e配置 PKI subscriber 使用哪个证书和私钥（或如何生成自己的密钥对、如何提交 CSR）；\u003c/p\u003e\n\n    \u003cp\u003e某个 entity (code, device, server, etc) 既是 RP 又是 subscriber 是很常见的。\n 这样的 entities 需要同时配置根证书、证书和私钥。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e下面是个完整例子，展示 certificate issuance, root certificate\ndistribution, and TLS client (RP) and server (subscriber) configuration:\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/everything-about-pki/step-ca-certificate-flow.jpg\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e希望这展示了\u003cstrong\u003e\u003cmark\u003e使用 internal PKI 和 TLS 是如何简单直接\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e有了这样的基础，就无需使用自签名的证书或做一些危险的事情，例如禁用 certificate path validation（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecurl -k\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）。\u003c/li\u003e\n  \u003cli\u003e几乎每个 TLS client/server 都支持这些参数；但是，它们又几乎都不关注秘钥和证书\n的声明周期：都假设证书会出现在磁盘上的恰当位置，有人或服务会帮它们完成 rotate\n等工作。这项生命周期相关的工作才是难点。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"12-结束语\"\u003e12 结束语\u003c/h1\u003e\n\n\u003cp\u003e公钥加密系统使计算机能在网络上看到对方（”see” across networks）。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果我有公钥，就能“看到”你有对应的私钥，但我自己是无法使用这个私钥的。\u003c/li\u003e\n  \u003cli\u003e如果还没有对方的公钥，就需要证书来帮忙。证书将公钥和私钥拥有者的名字（name）相关联，\n它们就像是计算机和代码的驾照。\u003c/li\u003e\n  \u003cli\u003e证书权威（CA）用它们的私钥对证书进行签名，对这些绑定关系作出担保，它们就像是车管局（DMV），\u003c/li\u003e\n  \u003cli\u003e如果你出示一张车管局颁发的驾照，脸长得也和驾照上的照片一样，那别人就可以认为你就是驾照上这个人（名字）。\n同理，如果你是唯一知道某个秘钥的 entity，你给我的证书也是从我信任的某个 CA 来的，那我就认为证书中的 name 就是你。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e现实中，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e大部分证书都是 X.509 v3 证书，用 ASN.1 格式定义，通常序列化为 PEM-encoded DER。\u003c/li\u003e\n  \u003cli\u003e相应的私钥通常表示为 PKCS#8 objects，也序列化为 PEM-encoded DER。\u003c/li\u003e\n  \u003cli\u003e如果你用 Java 或微软的产品，可能会遇到 PKCS#7 and PKCS#12 封装格式。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e加密领域有\u003cstrong\u003e\u003cmark\u003e沉重的历史包袱\u003c/mark\u003e\u003c/strong\u003e，使当前的这些东西学起来、用起来非常让人沮丧，这比一项技术因为太难而不想学更加令人沮丧。\u003c/p\u003e\n\n\u003cp\u003ePKI 是使用公钥基础设施时涉及到的所有东西的统称：names, key types,\ncertificates, CAs, cron jobs, libraries 等。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eWeb PKI 是浏览器默认使用的 PKI。Web PKI CA 是\u003cstrong\u003e\u003cmark\u003e受信但不可靠\u003c/mark\u003e\u003c/strong\u003e的（trusted but not trustworthy）。\u003c/li\u003e\n  \u003cli\u003eInternal PKI 是用户自己构建和维护的 PKI。需要它是因为 Web PKI 并不是针对 internal 使用场景设计的，\nInternal PKI 更易于自动化和扩展，并且能让用户控制很多细节，例如 naming and certificate lifetime。\u003c/li\u003e\n  \u003cli\u003e建议公网上使用 Web PKI，内网使用自己的 internal PKI\n（例如，\u003ca href=\"https://smallstep.com/blog/use-tls.html\"\u003euse TLS\u003c/a\u003e 来替代 VPN）。\u003c/li\u003e\n  \u003cli\u003eSmallstep Certificate Manager 使构建 internal PKI 非常简单。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e要获得一个证书，需要命令和生成证书。建议 name 用 SAN：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eDNS SANs for code and machines\u003c/li\u003e\n  \u003cli\u003eEMAIL SANs for people\u003c/li\u003e\n  \u003cli\u003e如果这些都不能用，就用 URI SAN\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e秘钥类型（key type）\u003c/mark\u003e\u003c/strong\u003e是很大一个主题，但几乎不重要：你可以随便修改秘钥类型，\n而且实际上加密本身（crypto）并不是 PKI 中最弱的一环。\u003c/p\u003e\n\n\u003cp\u003e要从 CA 获取一个证书，需要提交一个 CSR 并证明申请者的身份（identity）。\n使用生命周期较短的证书和 passive revocation。\n自动化证书续期过程。不要禁用 certificate path validation。\u003c/p\u003e\n\n\u003cp\u003e最后还是那句话：\u003cstrong\u003e\u003cmark\u003e证书和 PKI 将名字关联到公钥\u003c/mark\u003e\u003c/strong\u003e（bind names to public keys）。\n其他都是细节。\u003c/p\u003e\n\n\u003ch1 id=\"13-延伸阅读译注\"\u003e13 延伸阅读（译注）\u003c/h1\u003e\n\n\u003cp\u003e更多相关内容或实践，推荐：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://darutk.medium.com/illustrated-x-509-certificate-84aece2c5c2e\"\u003eIllustrated X.509 Certificate\u003c/a\u003e，2020\u003c/p\u003e\n\n    \u003cp\u003e超详细\u003cstrong\u003e\u003cmark\u003e图解 X.509 证书\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://brainbit.io/posts/cilium-tls-inspection/\"\u003eCilium TLS inspection\u003c/a\u003e，2021\u003c/p\u003e\n\n    \u003cp\u003e图解 X.509 证书、信任链，及 \u003cstrong\u003e\u003cmark\u003eCilium/hubble L7 实战\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/rbac-as-it-meant-to-be-zh/\"\u003e\u003cspan\u003e« [译] 基于角色的访问控制（RBAC）：演进历史、设计理念及简洁实现（Tailscale, 2021）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/how-nat-traversal-works-zh/\"\u003e\u003cspan\u003e[译] NAT 穿透是如何工作的：技术原理及企业级实践（Tailscale, 2020） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-10-07T00:00:00Z",
  "Author": "Arthur Chiao"
}