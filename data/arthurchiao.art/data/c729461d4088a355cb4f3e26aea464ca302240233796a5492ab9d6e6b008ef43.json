{
  "Source": "arthurchiao.art",
  "Title": "[译] [论文] 迈向完全可编程 tc 分类器（cls_bpf）（NetdevConf，2016）",
  "Link": "https://arthurchiao.art/blog/on-getting-tc-classifier-fully-programmable-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] [论文] 迈向完全可编程 tc 分类器（cls_bpf）（NetdevConf，2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-03-05 | Last Update 2021-03-05\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2016 年 Daniel Borkman 在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNetdevConf\u003c/code\u003e 大会上的一篇文章：\n\u003ca href=\"https://www.netdevconf.org/1.1/proceedings/papers/On-getting-tc-classifier-fully-programmable-with-cls-bpf.pdf\"\u003eOn getting tc classifier fully programmable with cls_bpf\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003eDaniel 是 eBPF 的核心开发之一，\n文章从技术层面介绍了 eBPF 的发展历史、核心设计，以及更重要的 —— 在 eBPF 基础之上\n，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 如何使 tc 分类器变得完全可编程。\u003c/p\u003e\n\n\u003cp\u003e由于 eBPF 发展很快，文中有些描述今天已经过时（例如单个 eBPF 程序允许的最大指令数量），\n因此翻译时以译注的形式做了适当更新。插入的一些内核代码基于 4.19。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#摘要\" id=\"markdown-toc-摘要\"\u003e摘要\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-引言\" id=\"markdown-toc-1-引言\"\u003e1 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-cbpf-架构\" id=\"markdown-toc-11-cbpf-架构\"\u003e1.1 cBPF 架构\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-cbpf-使用场景\" id=\"markdown-toc-12-cbpf-使用场景\"\u003e1.2 cBPF 使用场景\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-ebpf-架构\" id=\"markdown-toc-2-ebpf-架构\"\u003e2 eBPF 架构\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#20-指令集架构\" id=\"markdown-toc-20-指令集架构\"\u003e2.0 指令集架构\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#寄存器设计\" id=\"markdown-toc-寄存器设计\"\u003e寄存器设计\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#解释器-和-jit-编译器\" id=\"markdown-toc-解释器-和-jit-编译器\"\u003e解释器 和 JIT 编译器\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#指令编码格式\" id=\"markdown-toc-指令编码格式\"\u003e指令编码格式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#新指令\" id=\"markdown-toc-新指令\"\u003e新指令\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#单个程序的指令数限制\" id=\"markdown-toc-单个程序的指令数限制\"\u003e单个程序的指令数限制\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#21-辅助函数helper-functions\" id=\"markdown-toc-21-辅助函数helper-functions\"\u003e2.1 辅助函数（Helper Functions）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#函数签名\" id=\"markdown-toc-函数签名\"\u003e函数签名\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#调用约定\" id=\"markdown-toc-调用约定\"\u003e调用约定\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#带来的好处\" id=\"markdown-toc-带来的好处\"\u003e带来的好处\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-maps\" id=\"markdown-toc-22-maps\"\u003e2.2 Maps\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#map-类型\" id=\"markdown-toc-map-类型\"\u003emap 类型\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#创建和访问-map\" id=\"markdown-toc-创建和访问-map\"\u003e创建和访问 map\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#map-相关辅助函数调用\" id=\"markdown-toc-map-相关辅助函数调用\"\u003emap 相关辅助函数调用\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-object-pinning目标文件锚定\" id=\"markdown-toc-23-object-pinning目标文件锚定\"\u003e2.3 Object Pinning（目标文件锚定）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#文件描述符方式的限制\" id=\"markdown-toc-文件描述符方式的限制\"\u003e文件描述符方式的限制\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#bpf-文件系统bpffs\" id=\"markdown-toc-bpf-文件系统bpffs\"\u003eBPF 文件系统（bpffs）\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-尾调用tail-calls\" id=\"markdown-toc-24-尾调用tail-calls\"\u003e2.4 尾调用（Tail Calls）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#程序之间传递状态\" id=\"markdown-toc-程序之间传递状态\"\u003e程序之间传递状态\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#底层实现\" id=\"markdown-toc-底层实现\"\u003e底层实现\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-安全锁定镜像为只读模式地址随机化\" id=\"markdown-toc-25-安全锁定镜像为只读模式地址随机化\"\u003e2.5 安全：锁定镜像为只读模式、地址随机化\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#26-llvm\" id=\"markdown-toc-26-llvm\"\u003e2.6 LLVM\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-tc-cls_bpf-和-ebpf\" id=\"markdown-toc-3-tc-cls_bpf-和-ebpf\"\u003e3 tc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 eBPF\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#30-cls_bpf-和-act_bpf\" id=\"markdown-toc-30-cls_bpf-和-act_bpf\"\u003e3.0 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#可编程-tc-分类器-cls_bpf\" id=\"markdown-toc-可编程-tc-分类器-cls_bpf\"\u003e可编程 tc 分类器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#可编程-tc-动作actionact_bpf\" id=\"markdown-toc-可编程-tc-动作actionact_bpf\"\u003e可编程 tc 动作（action）\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-对-cls_bpf-的支持\" id=\"markdown-toc-ebpf-对-cls_bpf-的支持\"\u003eeBPF 对 cls_bpf 的支持\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#ebpf-cls_bpf-带来的好处\" id=\"markdown-toc-ebpf-cls_bpf-带来的好处\"\u003eeBPF cls_bpf 带来的好处\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#31-工作模式传统模式和-direct-action-模式\" id=\"markdown-toc-31-工作模式传统模式和-direct-action-模式\"\u003e3.1 工作模式：传统模式和 direct-action 模式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-特性\" id=\"markdown-toc-32-特性\"\u003e3.2 特性\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#skb-可读写字段\" id=\"markdown-toc-skb-可读写字段\"\u003eskb 可读/写字段\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#辅助函数\" id=\"markdown-toc-辅助函数\"\u003e辅助函数\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#重定向redirection\" id=\"markdown-toc-重定向redirection\"\u003e重定向（redirection）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#调试debug\" id=\"markdown-toc-调试debug\"\u003e调试（Debug）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#可以-attach-到的-tc-hooks\" id=\"markdown-toc-可以-attach-到的-tc-hooks\"\u003e可以 attach 到的 tc hooks\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-前端front-end\" id=\"markdown-toc-33-前端front-end\"\u003e3.3 前端（Front End）\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#处理-object-pinning\" id=\"markdown-toc-处理-object-pinning\"\u003e处理 Object pinning\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#处理尾调用\" id=\"markdown-toc-处理尾调用\"\u003e处理尾调用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tc-exec-bpf-graft\" id=\"markdown-toc-tc-exec-bpf-graft\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf graft\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#tc-exec-bpf-dbg\" id=\"markdown-toc-tc-exec-bpf-dbg\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf dbg\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-工作流workflow\" id=\"markdown-toc-34-工作流workflow\"\u003e3.4 工作流（Workflow）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-编程\" id=\"markdown-toc-35-编程\"\u003e3.5 编程\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#代码共享内联函数或尾调用\" id=\"markdown-toc-代码共享内联函数或尾调用\"\u003e代码共享：内联函数或尾调用\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#有限栈空间和全局变量\" id=\"markdown-toc-有限栈空间和全局变量\"\u003e有限栈空间和全局变量\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#动态循环\" id=\"markdown-toc-动态循环\"\u003e动态循环\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-总结及未来展望\" id=\"markdown-toc-4-总结及未来展望\"\u003e4 总结及未来展望\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"摘要\"\u003e摘要\u003c/h1\u003e\n\n\u003cp\u003eBerkely Packet Filter（BPF）是 1993 年设计的一种\u003cstrong\u003e指令集架构\u003c/strong\u003e（instruction set architecture）[18] [1] ——\n作为一种\u003cmark\u003e通用数据包过滤方案\u003c/mark\u003e（generic packet filtering solution），\n提供给 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elibpcap\u003c/code\u003e/\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e 等上层应用使用。\nBPF 很早就已经出现在 \u003cstrong\u003eLinux 内核\u003c/strong\u003e中，并且使用场景也\u003cstrong\u003e不再仅限于网络方面\u003c/strong\u003e，\n例如有\u003cstrong\u003e对系统调用进行过滤\u003c/strong\u003e（system call filtering）的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eseccomp\u003c/code\u003e BPF [15]。\u003c/p\u003e\n\n\u003cp\u003e近几年，Linux 社区将这种经典 BPF（classic BPF, cBPF）做了升级，形成一个新的指令集架构，\n称为 “extended BPF” (eBPF) [21] [23] [22] [24]。与 cBPF 相比，eBPF 带了\n\u003cstrong\u003e更大的灵活性和可编程性\u003c/strong\u003e，也带来了一些\u003cstrong\u003e新的使用场景\u003c/strong\u003e，例如跟踪（tracing）[27]、\nKCM（Kernel Connection Multiplexor）[17] 等。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eKernel Connection Multiplexor (KCM) is a facility that provides a\nmessage based interface over TCP for generic application protocols.\nWith KCM an application can efficiently send and receive application\nprotocol messages over TCP using datagram sockets.\u003c/p\u003e\n\n  \u003cp\u003eFor more information see the included Documentation/networking/kcm.txt\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e除了\u003cmark\u003e替换掉解释器\u003c/mark\u003e之外，\u003cmark\u003eJIT 编译器也进行了升级\u003c/mark\u003e，使\neBPF [25] 程序能达到\u003cstrong\u003e平台原生的执行性能\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e内核流量控制层的 \u003cstrong\u003e\u003cmark\u003ecls_bpf 分类器添加了对 eBPF 的支持之后\u003c/mark\u003e\u003c/strong\u003e [8]，\n\u003cmark\u003etc 对 Linux 数据平面进行编程的能力更加强大\u003c/mark\u003e，并且该过程与\n内核网络栈、相关工具及底层编程范式的联系也更紧密。\u003c/p\u003e\n\n\u003cp\u003e本文将介绍 \u003cstrong\u003eeBPF、eBPF 与 tc 的交互\u003c/strong\u003e及内核网络社区在 eBPF 领域的一些最新工作。\u003c/p\u003e\n\n\u003cp\u003e本文内容不求大而全，而是希望作为一份入门材料，供那些对 \u003cstrong\u003eeBPF 架构及其与 tc 关系\u003c/strong\u003e感兴趣的人参考。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e关键字\u003c/mark\u003e\u003c/strong\u003e：eBPF, cls_bpf, tc, programmable datapath, Linux kernel\u003c/p\u003e\n\n\u003ch1 id=\"1-引言\"\u003e1 引言\u003c/h1\u003e\n\n\u003cp\u003e经典 BPF（cBPF）多年前就已经在 Linux 内核中实现了，\u003cmark\u003e主要用户是 PF_PACKET sockets\u003c/mark\u003e。\n在该场景中，cBPF 作为一种\u003cstrong\u003e通用、快速且安全\u003c/strong\u003e的方案，在 PF_PACKET\n\u003cmark\u003e收包路径的早期位置（early point）解析数据包\u003c/mark\u003e（packet parsing）。\n其中，与安全执行（safe execution）相关的一个目标是：\u003cstrong\u003e从用户程序向内核注入\n非受信代码，但不能因此破坏内核的稳定性\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"11-cbpf-架构\"\u003e1.1 cBPF 架构\u003c/h2\u003e\n\n\u003cp\u003ecBPF 是 \u003cstrong\u003e\u003cmark\u003e32bit 架构\u003c/mark\u003e\u003c/strong\u003e [18]，\u003cmark\u003e主要针对包解析（packet parsing）场景设计\u003c/mark\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e两个主寄存器 A 和 X\n    \u003cul\u003e\n      \u003cli\u003eA 是主寄存器（main register），也称作累加器（accumulator）。这里执行大部分操作，例如 alu、load、store、comparison-for-jump 等。\u003c/li\u003e\n      \u003cli\u003eX 主要用作临时寄存器，也用于加载包内容（relative loads of packet contents）。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e一个 16word scratch space（存放临时数据），通常称为 M\u003c/li\u003e\n  \u003cli\u003e一个隐藏的程序计数器（PC）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e使用 cBPF 时，包的内容只能读取，不能修改\u003c/mark\u003e。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003ecBPF 有 8 种的指令类型：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eld\u003c/li\u003e\n  \u003cli\u003eldx\u003c/li\u003e\n  \u003cli\u003est\u003c/li\u003e\n  \u003cli\u003estx\u003c/li\u003e\n  \u003cli\u003ealu\u003c/li\u003e\n  \u003cli\u003ejmp\u003c/li\u003e\n  \u003cli\u003eret\u003c/li\u003e\n  \u003cli\u003e其他一些指令：用于传递 A 和 X 中的内容。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e几点解释：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e前四个是加载相关的指令，\u003cstrong\u003eload 和 store 类型分别会用到寄存器 A 和 X\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejump\u003c/code\u003e 只支持前向跳转（forward jump）。\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eret\u003c/code\u003e 结束 cBPF 程序执行，从程序返回。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cmark\u003e每个 cBPF 程序最多只能包含 4096 条指令\u003c/mark\u003e（max instructions/programm），\n代码在加载到内核执行之前，校验器会对其进行静态验证（statically verify）。\u003c/p\u003e\n\n\u003cp\u003e具体到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_asm\u003c/code\u003e 工具 [5]，它包含 33 条指令、11 种寻址模式和 16 个 Linux 相关的 cBPF 扩展（extensions）。\u003c/p\u003e\n\n\u003ch2 id=\"12-cbpf-使用场景\"\u003e1.2 cBPF 使用场景\u003c/h2\u003e\n\n\u003cp\u003ecBPF 程序的语义是由使用它的子系统定义的。由于其通用、最小化和快速执行的特点，如\n今 cBPF 已经在 PF_PACKET socket \u003cstrong\u003e\u003cmark\u003e之外的一些场景找到了用武之地\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eseccomp\u003c/code\u003e BPF [15] 于 2012 年添加到内核，目的是提供一种\u003cstrong\u003e安全和快速的过滤系统调\u003c/strong\u003e的方式。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e网络领域，cBPF 已经能\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e用作大部分协议（TCP、UDP、netlink 等）的 socket filter；\u003c/li\u003e\n      \u003cli\u003e用作 PF_PACKET socket 的 fanout demuxing facility [14] [13]\u003c/li\u003e\n      \u003cli\u003e用于 socket demuxing with SO REUSEPORT [16]\u003c/li\u003e\n      \u003cli\u003e用于 load balancing in team driver [19]\u003c/li\u003e\n      \u003cli\u003e用于本文将介绍的 tc 子系统中，作为 classifier [6] and action [20]\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e其他一些场景\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eeBPF 作为对 cBPF 的扩展，\u003cstrong\u003e\u003cmark\u003e第一个 commit 于 2014 年合并到内核\u003c/mark\u003e\u003c/strong\u003e。从那之后，\nBPF 的可编程特性已经发生了巨大变化。\u003c/p\u003e\n\n\u003ch1 id=\"2-ebpf-架构\"\u003e2 eBPF 架构\u003c/h1\u003e\n\n\u003cp\u003e与 cBPF 类似，eBPF 也可以被视为一个最小“虚拟”机（minimalistic ”virtual” machine construct）[21]。\neBPF 抽象的机器只有少量寄存器、很小的栈空间、一个隐藏的程序计数器以及一个所谓的辅助函数\n（helper function）的概念。\u003c/p\u003e\n\n\u003cp\u003e在内核其他基础设施的配合下，\u003cstrong\u003eeBPF 能做一些有副作用（side effects）的事情\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里的副作用是指：eBPF 程序能够对拦截到的东西做（安全的）修改，而 cBPF 对拦截到的东西都是只能读、不能改的。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eeBPF 程序是事件驱动的，触发执行时，系统会传给它一些参数，\u003cmark\u003e这些输入（inputs）称为“上下文”（context）\u003c/mark\u003e。\n对于 \u003cstrong\u003etc eBPF 程序来说，传递的上下文是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb\u003c/code\u003e\u003c/strong\u003e，即网络设备 tc 层的 ingress 或 egress 路径上正在经过的数据包。\u003c/p\u003e\n\n\u003ch2 id=\"20-指令集架构\"\u003e2.0 指令集架构\u003c/h2\u003e\n\n\u003ch3 id=\"寄存器设计\"\u003e寄存器设计\u003c/h3\u003e\n\n\u003cp\u003eeBPF 有\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e11 个寄存器 (R0 ~ R10)\u003c/li\u003e\n  \u003cli\u003e每个寄存器都是 64bit，有相应的 32bit 子寄存器\u003c/li\u003e\n  \u003cli\u003e指令集是固定的 64bit 位宽，\u003cstrong\u003e\u003cmark\u003e参考了 cBPF、x86_64、arm64 和 risc 指令集的设计\u003c/mark\u003e\u003c/strong\u003e，\n目的是\u003cstrong\u003e方便 JIT 编译\u003c/strong\u003e（将 eBPF 指令编译成平台原生指令）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003eeBPF 兼容 cBPF\u003c/strong\u003e，并且与后者一样，给用户空间程序提供稳定的 ABI。\u003c/p\u003e\n\n\u003ch3 id=\"解释器-和-jit-编译器\"\u003e解释器 和 JIT 编译器\u003c/h3\u003e\n\n\u003cp\u003e目前，x86_64、s390 和 arm64 平台的 Linux 内核都自带了 eBPF 解释器和 JIT 编译器\n。还没有将 cBPF JIT 转换成 eBPF JIT 的平台，只能通过解释器执行。\u003c/p\u003e\n\n\u003cp\u003e此外，原来某些不支持 JIT 编译的 cBPF 代码，现在也能够在加载时自动转换成 eBPF 指\n令，接下来或者通过解释器执行，或者通过 eBPF JIT 执行。一个例子就是 seccom BPF：\n引入了 eBPF 指令之后，原来的 cBPF seccom 指令就自动被转换成 eBPF 指令了。\u003c/p\u003e\n\n\u003ch3 id=\"指令编码格式\"\u003e指令编码格式\u003c/h3\u003e\n\n\u003cp\u003eeBPF \u003cmark\u003e指令编码格式\u003c/mark\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e8 bit code：存放真正的指令码（instruction code）\u003c/li\u003e\n  \u003cli\u003e8 bit dst reg：存放指令用到的寄存器号（R0~R10）\u003c/li\u003e\n  \u003cli\u003e8 bit src reg：同上，存放指令用到的寄存器号（R0~R10）\u003c/li\u003e\n  \u003cli\u003e16 bit signed offset：取决于指令类型，可能是\n    \u003cul\u003e\n      \u003cli\u003ea jump offset：in case the related condition is evaluated as true\u003c/li\u003e\n      \u003cli\u003ea relative stack buffer offset for load/stores of registers into the stack\u003c/li\u003e\n      \u003cli\u003ea increment offset：in case of an xadd alu instruction, it can be an\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e32 bit signed imm：存放立即值（carries the immediate value）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"新指令\"\u003e新指令\u003c/h3\u003e\n\n\u003cp\u003eeBPF 带来了几个新指令，例如\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e工作在 64 位模式的 alu 操作\u003c/li\u003e\n  \u003cli\u003e有符号移位（signed shift）操作\u003c/li\u003e\n  \u003cli\u003eload/store of double words\u003c/li\u003e\n  \u003cli\u003ea generic move operation for registers and immediate values\u003c/li\u003e\n  \u003cli\u003eoperators for endianness conversion,\u003c/li\u003e\n  \u003cli\u003ea call operation for invoking helper functions\u003c/li\u003e\n  \u003cli\u003ean atomic add (xadd) instruction.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"单个程序的指令数限制\"\u003e单个程序的指令数限制\u003c/h3\u003e\n\n\u003cp\u003e与 cBPF 类似，eBPF 中单个程序的最大指令数（instructions/programm）是 4096。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e译注：\u003cmark\u003e现在已经放大到了 100 万条\u003c/mark\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这些指令序列（instruction sequence）在加载到内核之前会进行静态校验（statically verified），\n以确保它们不会包含破坏内核稳定性的代码，例如无限循环、指针或数据泄露、非法内存访问等等。\ncBPF 只支持前向跳转，而 eBPF \u003cmark\u003e额外支持了受限的后向跳转\u003c/mark\u003e ——\n只要后向跳转不会产生循环，即保证程序能在有限步骤内结束。\u003c/p\u003e\n\n\u003cp\u003e除此之外，eBPF 还引入了一些新的概念，例如 helper functions、maps、tail calls、object pinning。\n接下来分别详细讨论。\u003c/p\u003e\n\n\u003ch2 id=\"21-辅助函数helper-functions\"\u003e2.1 辅助函数（Helper Functions）\u003c/h2\u003e\n\n\u003cp\u003e辅助函数是一组\u003cmark\u003e内核定义的函数集\u003c/mark\u003e，\u003cstrong\u003e使 eBPF 程序能从内核读取数据，\n或者向内核写入数据\u003c/strong\u003e（retrieve/push data from/to the kernel）。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003e不同类型的 eBPF 程序能用到的 helper function 集合是不同的\u003c/mark\u003e，例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003esocket 层 eBPF 能使用的辅助函数，只是 tc 层 eBPF 能使用的辅助函数的一个子集。\u003c/li\u003e\n  \u003cli\u003eflow-based tunneling 场景中，封装/解封装用的辅助函数只能用在比较低层的 tc ingress/egress 层。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"函数签名\"\u003e函数签名\u003c/h3\u003e\n\n\u003cp\u003e与系统调用类似，\u003cstrong\u003e\u003cmark\u003e所有辅助函数的签名是一样的\u003c/mark\u003e\u003c/strong\u003e，格式为：\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eu64 foo(u64 r1, u64 r2, u64 r3, u64 r4, u64 r5)\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"调用约定\"\u003e调用约定\u003c/h3\u003e\n\n\u003cp\u003e辅助函数的\u003cmark\u003e调用约定\u003c/mark\u003e（calling convention）也是固定的：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eR0：存放程序返回值\u003c/li\u003e\n  \u003cli\u003eR1 ~ R5：存放函数参数（function arguments）\u003c/li\u003e\n  \u003cli\u003eR6 ~ R9：\u003cstrong\u003e被调用方\u003c/strong\u003e（callee）负责保存的寄存器\u003c/li\u003e\n  \u003cli\u003eR10：栈空间 load/store 操作用的只读 frame pointer\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"带来的好处\"\u003e带来的好处\u003c/h3\u003e\n\n\u003cp\u003e这样的设计有几方面好处：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003eJIT 更加简单、高效\u003c/mark\u003e。\u003c/p\u003e\n\n    \u003cp\u003ecBPF 中，为了调用某些特殊功能的辅助函数（auxiliary helper functions），对 load 指令进行了重载（overload），\n  在数据包的某个看似不可能的位置（impossible packet offset）加载数据，以这种方式调用到辅助函数；每个 cBPF\n  JIT 都需要实现对这样的 cBPF 扩展的支持。\u003c/p\u003e\n\n    \u003cp\u003e而在 eBPF 中，每个辅助函数都是以透明和高效地方式进行 JIT 编译的，这意味着\n  JIT 编译器只需要 emit 一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e 指令 —— 因为寄存器映射（register mapping）\n  的设计中，eBPF 已经和底层架构的调用约定是匹配的了。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e函数签名使校验器能执行类型检查\u003c/mark\u003e（type checks）。\u003c/p\u003e\n\n    \u003cp\u003e每个辅助函数都有一个配套的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_func_proto\u003c/code\u003e 类型变量，\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"cm\"\u003e/* eBPF function prototype used by verifier to allow BPF_CALLs from eBPF programs\n   * to in-kernel helper functions and for adjusting imm32 field in BPF_CALL instructions after verifying */\u003c/span\u003e\n  \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_func_proto\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \t\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003efunc\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er4\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003er5\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n  \t\u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003egpl_only\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"n\"\u003epkt_access\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_return_type\u003c/span\u003e \u003cspan class=\"n\"\u003eret_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_arg_type\u003c/span\u003e \u003cspan class=\"n\"\u003earg1_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_arg_type\u003c/span\u003e \u003cspan class=\"n\"\u003earg2_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_arg_type\u003c/span\u003e \u003cspan class=\"n\"\u003earg3_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_arg_type\u003c/span\u003e \u003cspan class=\"n\"\u003earg4_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eenum\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_arg_type\u003c/span\u003e \u003cspan class=\"n\"\u003earg5_type\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e一个例子：\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"c1\"\u003e// net/core/filter.c\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003eBPF_CALL_2\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_redirect\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eifindex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu64\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_redirect_info\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eri\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ethis_cpu_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_redirect_info\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eunlikely\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"o\"\u003e~\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eBPF_F_INGRESS\u003c/span\u003e\u003cspan class=\"p\"\u003e)))\u003c/span\u003e\n  \t\t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eTC_ACT_SHOT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n  \t\u003cspan class=\"n\"\u003eri\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eifindex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eifindex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"n\"\u003eri\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eflags\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \t\u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eTC_ACT_REDIRECT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_func_proto\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_redirect_proto\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \t\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efunc\u003c/span\u003e           \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_redirect\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \t\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003egpl_only\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003efalse\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \t\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eret_type\u003c/span\u003e       \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eRET_INTEGER\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \t\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg1_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_ANYTHING\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \t\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003earg2_type\u003c/span\u003e      \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eARG_ANYTHING\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e\u003cmark\u003e校验器据此就能知道该 helper 函数的详细信息，\n  进而确保该 helper 的类型与当前 eBPF 程序用到的寄存器内的内容是匹配的\u003c/mark\u003e。\u003c/p\u003e\n\n    \u003cp\u003ehelper 函数的参数类型有很多种，如果是指针类型（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eARG_PTR_TO_MEM\u003c/code\u003e），\n  校验器还可以执行进一步的检查，例如判断这个缓冲区之前是否已经初始化了。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"22-maps\"\u003e2.2 Maps\u003c/h2\u003e\n\n\u003cp\u003eMap 是 eBPF 的另一个重要组成部分。\n它是一种\u003cmark\u003e高效的 key/value 存储\u003c/mark\u003e，map 的\u003cmark\u003e内容驻留在内核空间\u003c/mark\u003e，\n但可以\u003cstrong\u003e\u003cmark\u003e在用户空间通过文件描述符访问\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003eMap 可以在多个 eBPF 程序之间共享，而且没有什么限制，例如，可以在一个 tc eBPF\n程序和一个 tracing eBPF 程序之间共享。\u003c/p\u003e\n\n\u003ch3 id=\"map-类型\"\u003emap 类型\u003c/h3\u003e\n\n\u003cp\u003eMap 后端是由\u003cmark\u003e核心内核（the core kernel）提供\u003c/mark\u003e的，可能是通用类型\n（generic），也可能是专用类型（specialized type）；\n\u003cstrong\u003e某些专业类型的 map 只能用于特定的子系统\u003c/strong\u003e，例如 [28]。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003e通用类型 map 当前是数组或哈希表结构\u003c/mark\u003e（array or hash table），\n可以是 per-CPU 的类型，也可以是 non-per-CPU 类型。\u003c/p\u003e\n\n\u003ch3 id=\"创建和访问-map\"\u003e创建和访问 map\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cmark\u003e创建 map：只能从用户空间操作\u003c/mark\u003e，通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ebpf(2)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 系统调用完成。\u003c/li\u003e\n  \u003cli\u003e从 \u003cstrong\u003eeBPF 程序中\u003c/strong\u003e访问 map：\u003cmark\u003e通过辅助函数\u003c/mark\u003e。\u003c/li\u003e\n  \u003cli\u003e从\u003cstrong\u003e用户空间\u003c/strong\u003e访问 map：通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"map-相关辅助函数调用\"\u003emap 相关辅助函数调用\u003c/h3\u003e\n\n\u003cp\u003e以上设计意味着，如果 eBPF 程序想调用某个 map 相关的辅助函数，\n它需要将文件描述符编码到指令中 —— 文件描述符会进一步对应到 map 引用，\n并放到正确的寄存器 —— \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_LD_MAP_FD(BPF_REG_1, fd)\u003c/code\u003e 就是一个例子。\n内核能识别出这种特殊 src 寄存器的情况，然后从文件描述符表中查找该 fd，进而找到真\n正的 eBPF map，然后在内部对指令进行重写（rewrite the instruction）。\u003c/p\u003e\n\n\u003ch2 id=\"23-object-pinning目标文件锚定\"\u003e2.3 Object Pinning（目标文件锚定）\u003c/h2\u003e\n\n\u003cp\u003eeBPF map 和 eBPF program 都是\u003cmark\u003e内核资源\u003c/mark\u003e（kernel resource），\n\u003cstrong\u003e只能通过文件描述符（file descriptor）访问\u003c/strong\u003e；而\u003cmark\u003e文件描述符背后是内核中的匿名 inode\u003c/mark\u003e\n（backed by anonymous inodes in the kernel）。\u003c/p\u003e\n\n\u003ch3 id=\"文件描述符方式的限制\"\u003e文件描述符方式的限制\u003c/h3\u003e\n\n\u003cp\u003e以上这种方式有优点，例如：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e用户空间程序\u003c/strong\u003e能使用\u003cstrong\u003e大部分文件描述符相关的 API\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e在 Unix domain socket 传递文件描述符是\u003cstrong\u003e透明\u003c/strong\u003e的\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但也有缺点：\u003cmark\u003e文件描述符的生命周期在进程生命周期之内\u003c/mark\u003e，因此不同进程之间\u003cstrong\u003e共享 map 之类的东西就比较困难\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这给 tc 等应用带来了很多不便。因为 tc 的工作方式是：\u003cstrong\u003e将程序加载到内核之后就退出\u003c/strong\u003e（而不是持续运行的进程）。\u003c/li\u003e\n  \u003cli\u003e此外，从用户空间也无法\u003cstrong\u003e直接访问\u003c/strong\u003e map（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用不算），否则这会很有用。\n例如，第三方应用可能希望在 eBPF 程序运行时（runtime）监控或更新 map 的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e针对这些问题，提出了几种\u003cstrong\u003e保持文件描述符 alive 的设想\u003c/strong\u003e，其中之一是重用 fuse，作为 tc 的 proxy。\n这种情况下，文件描述符被 fuse implementation 所拥有，tc 之类的工具可以通过\nunix domain sockets 来获取这些文件描述符。但又也带来了很大的新问题：\n增加了新的依赖 fuse，而且需要作为额外的守护进程安装和启动。\n大型部署中，都希望保持用户空间最小化（maintain a minimalistic user space）以节省资源。\n因此这样的额外依赖难以让用户接受。\u003c/p\u003e\n\n\u003ch3 id=\"bpf-文件系统bpffs\"\u003eBPF 文件系统（bpffs）\u003c/h3\u003e\n\n\u003cp\u003e为了更好的解决以上问题，我们\u003cstrong\u003e在内核中实现了一个最小文件系统\u003c/strong\u003e（a minimal kernel space file system）[4]。\u003c/p\u003e\n\n\u003cp\u003eeBPF map 和 eBPF program 可以 pin（固定）到这个文件系统，这个过程称为 object pinning。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf(2)\u003c/code\u003e 系统调用也新加了两个命令用来 pin 或获取一个已经 pinned 的 object。\n例如，\u003cmark\u003etc 之类的工具利用这个新功能 [9] 就能在 ingress 或 egress 上共享 map\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003eeBPF 文件系统在每个 mount 命名空间创建一个挂载实例（keep an instance per mount namespace），\n并支持 bind mounts、hard links 等功能，并与网络命令空间无缝集成。\u003c/p\u003e\n\n\u003ch2 id=\"24-尾调用tail-calls\"\u003e2.4 尾调用（Tail Calls）\u003c/h2\u003e\n\n\u003cp\u003eeBPF 的另一个概念是尾调用 [26]：从一个程序调用到另一个程序，且后者执行完之后不再\n返回到前者。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e不同于普通的函数调用，尾调用的开销最小；\u003c/li\u003e\n  \u003cli\u003e底层\u003cmark\u003e通过 long jump 实现\u003c/mark\u003e，复用原来是栈帧（reusing the same stack frame）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"程序之间传递状态\"\u003e程序之间传递状态\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e尾调用的程序是独立验证的\u003c/mark\u003e\u003c/strong\u003e（verified independently），\n因此\u003cmark\u003e要在两个程序之间传递状态\u003c/mark\u003e，就需要用到：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eper-CPU maps，作为自定义数据的存储区（as scratch buffers），或者\u003c/li\u003e\n  \u003cli\u003eskb 的某些可以存储自定义数据的字段，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecb\u003c/code\u003e（control buffer）字段\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cmark\u003e只有同类型的程序之间才可以尾调用\u003c/mark\u003e，而且它们\u003cstrong\u003e要么都是通过解释器执行，\n要么都是通过 JIT 编译之后执行\u003c/strong\u003e，不支持混合两种模式。\u003c/p\u003e\n\n\u003ch3 id=\"底层实现\"\u003e底层实现\u003c/h3\u003e\n\n\u003cp\u003e尾调用涉及两个步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e首先设置一个特殊的、称为\u003cmark\u003e程序数组\u003c/mark\u003e（program array）的 map。\u003c/p\u003e\n\n    \u003cp\u003e这个 map 可以从用户空间通过 key/value 操作，其中 \u003cstrong\u003evalue 是各个 eBPF 程序的文件描述符\u003c/strong\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e第二步是执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_tail_call(void *ctx, struct bpf_map *prog_array_map, u32 index)\u003c/code\u003e 辅助函数，其中\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog_array_map\u003c/code\u003e 就是前面提到的程序数组，\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eindex\u003c/code\u003e 是程序数组的索引，表示希望跳转到这个位置的文件描述符所指向的程序。\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cp\u003e下面是这个辅助函数的进一步说明：\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c1\"\u003e// include/uapi/linux/bpf.h\u003c/span\u003e\n\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_tail_call\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ebpf_map\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eprog_array_map\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\u003cspan class=\"n\"\u003eDescription\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eThis\u003c/span\u003e \u003cspan class=\"n\"\u003especial\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003eused\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003etrigger\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;tail call\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eother\u003c/span\u003e \u003cspan class=\"n\"\u003ewords\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ejump\u003c/span\u003e \u003cspan class=\"n\"\u003einto\u003c/span\u003e \u003cspan class=\"n\"\u003eanother\u003c/span\u003e \u003cspan class=\"n\"\u003eeBPF\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eThe\u003c/span\u003e \u003cspan class=\"n\"\u003esame\u003c/span\u003e \u003cspan class=\"n\"\u003estack\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eframe\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003eused\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ebut\u003c/span\u003e \u003cspan class=\"n\"\u003evalues\u003c/span\u003e \u003cspan class=\"n\"\u003eon\u003c/span\u003e \u003cspan class=\"n\"\u003estack\u003c/span\u003e \u003cspan class=\"n\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eregisters\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003ecaller\u003c/span\u003e \u003cspan class=\"n\"\u003eare\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003eaccessible\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ecallee\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e \u003cspan class=\"n\"\u003eThis\u003c/span\u003e \u003cspan class=\"n\"\u003emechanism\u003c/span\u003e \u003cspan class=\"n\"\u003eallows\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e \u003cspan class=\"n\"\u003echaining\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eeither\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003eraising\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003emaximum\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eavailable\u003c/span\u003e \u003cspan class=\"n\"\u003eeBPF\u003c/span\u003e \u003cspan class=\"n\"\u003einstructions\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003eexecute\u003c/span\u003e \u003cspan class=\"n\"\u003egiven\u003c/span\u003e \u003cspan class=\"n\"\u003eprograms\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003econditional\u003c/span\u003e \u003cspan class=\"n\"\u003eblocks\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eFor\u003c/span\u003e \u003cspan class=\"n\"\u003esecurity\u003c/span\u003e \u003cspan class=\"n\"\u003ereasons\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethere\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003ean\u003c/span\u003e \u003cspan class=\"n\"\u003eupper\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003elimit\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003esuccessive\u003c/span\u003e \u003cspan class=\"n\"\u003etail\u003c/span\u003e \u003cspan class=\"n\"\u003ecalls\u003c/span\u003e \u003cspan class=\"n\"\u003ethat\u003c/span\u003e \u003cspan class=\"n\"\u003ecan\u003c/span\u003e \u003cspan class=\"n\"\u003ebe\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eperformed\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eUpon\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003ethis\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e \u003cspan class=\"n\"\u003eattempts\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ejump\u003c/span\u003e \u003cspan class=\"n\"\u003einto\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eprogram\u003c/span\u003e \u003cspan class=\"n\"\u003ereferenced\u003c/span\u003e \u003cspan class=\"n\"\u003eat\u003c/span\u003e \u003cspan class=\"n\"\u003eindex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eprog_array_map\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003especial\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003etype\u003c/span\u003e \u003cspan class=\"o\"\u003e**\u003c/span\u003e\u003cspan class=\"n\"\u003eBPF_MAP_TYPE_PROG_ARRAY\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003epasses\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003epointer\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003econtext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eIf\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003esucceeds\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ekernel\u003c/span\u003e \u003cspan class=\"n\"\u003eimmediately\u003c/span\u003e \u003cspan class=\"n\"\u003eruns\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003efirst\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003einstruction\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eThis\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003efunction\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003eit\u003c/span\u003e \u003cspan class=\"n\"\u003enever\u003c/span\u003e \u003cspan class=\"n\"\u003ereturns\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003eprevious\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eIf\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003efails\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethen\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ehelper\u003c/span\u003e \u003cspan class=\"n\"\u003ehas\u003c/span\u003e \u003cspan class=\"n\"\u003eno\u003c/span\u003e \u003cspan class=\"n\"\u003eeffect\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eand\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ecaller\u003c/span\u003e \u003cspan class=\"n\"\u003econtinues\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003erun\u003c/span\u003e \u003cspan class=\"n\"\u003eits\u003c/span\u003e \u003cspan class=\"n\"\u003esubsequent\u003c/span\u003e \u003cspan class=\"n\"\u003einstructions\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eA\u003c/span\u003e \u003cspan class=\"n\"\u003ecall\u003c/span\u003e \u003cspan class=\"n\"\u003ecan\u003c/span\u003e \u003cspan class=\"n\"\u003efail\u003c/span\u003e \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003edestination\u003c/span\u003e \u003cspan class=\"n\"\u003eprogram\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ejump\u003c/span\u003e \u003cspan class=\"n\"\u003edoes\u003c/span\u003e \u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003eexist\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eindex\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003esuperior\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003eentries\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eprog_array_map\u003c/span\u003e\u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003eor\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003emaximum\u003c/span\u003e \u003cspan class=\"n\"\u003enumber\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003etail\u003c/span\u003e \u003cspan class=\"n\"\u003ecalls\u003c/span\u003e \u003cspan class=\"n\"\u003ehas\u003c/span\u003e \u003cspan class=\"n\"\u003ebeen\u003c/span\u003e \u003cspan class=\"n\"\u003ereached\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ethis\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003echain\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003eprograms\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e \u003cspan class=\"n\"\u003eThis\u003c/span\u003e \u003cspan class=\"n\"\u003elimit\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003edefined\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e \u003cspan class=\"n\"\u003ekernel\u003c/span\u003e \u003cspan class=\"n\"\u003eby\u003c/span\u003e \u003cspan class=\"n\"\u003ethe\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003emacro\u003c/span\u003e \u003cspan class=\"o\"\u003e**\u003c/span\u003e\u003cspan class=\"n\"\u003eMAX_TAIL_CALL_CNT\u003c/span\u003e\u003cspan class=\"o\"\u003e**\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enot\u003c/span\u003e \u003cspan class=\"n\"\u003eaccessible\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"n\"\u003euser\u003c/span\u003e \u003cspan class=\"n\"\u003espace\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"n\"\u003ewhich\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003ecurrently\u003c/span\u003e \u003cspan class=\"n\"\u003eset\u003c/span\u003e \u003cspan class=\"n\"\u003eto\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\u003cspan class=\"n\"\u003eReturn\u003c/span\u003e\n  \u003cspan class=\"o\"\u003e*\u003c/span\u003e \t\t\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"n\"\u003eon\u003c/span\u003e \u003cspan class=\"n\"\u003esuccess\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eor\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e \u003cspan class=\"n\"\u003enegative\u003c/span\u003e \u003cspan class=\"n\"\u003eerror\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"k\"\u003ecase\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003efailure\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e内核会将这个辅助函数调用转换成一个特殊的 eBPF 指令\u003c/mark\u003e\u003c/strong\u003e。另外，这个\nprogram array 对于用户空间是只读的。\u003c/p\u003e\n\n\u003cp\u003e内核根据文件描述符（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efd = prog_array_map[index]\u003c/code\u003e）查找相关的 eBPF 程序，然后自动将相应 map slot 程序指针\n进行替换。如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprog_array_map[index]\u003c/code\u003e 为空，内核就继续在原来的 eBPF 程序中继续执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_tail_call()\u003c/code\u003e 之后的指令。\u003c/p\u003e\n\n\u003cp\u003e尾调用是一个非常强大的功能，例如，解析网络头（network headers）可以通过 尾调用实现（\n因为每解析一层就可以丢弃一层，没有再返回来的需求）。\n另外，尾调用还能够在运行时（runtime）原子地添加或替换功能，改变执行行为。\u003c/p\u003e\n\n\u003ch2 id=\"25-安全锁定镜像为只读模式地址随机化\"\u003e2.5 安全：锁定镜像为只读模式、地址随机化\u003c/h2\u003e\n\n\u003cp\u003eeBPF 有几种\u003cstrong\u003e防止有意或无意的内核 bug 导致程序镜像（program images）损坏\u003c/strong\u003e的技术 —— 即便这些 bug 跟 BPF 无关。\u003c/p\u003e\n\n\u003cp\u003e支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCONFG_DEBUG_SET_MODULE_RONX\u003c/code\u003e 配置选项的平台，\u003cstrong\u003e\u003cmark\u003e启用这个配置后，\n内核会将 eBPF 解释器的镜像设置为只读的\u003c/mark\u003e\u003c/strong\u003e [2]。\u003c/p\u003e\n\n\u003cp\u003e当启用 JIT 编译之后，内核还会将生成的\u003cstrong\u003e可执行镜像\u003c/strong\u003e（generated executable images）\n锁定为只读的，并且\u003cstrong\u003e对其地址进行随机化\u003c/strong\u003e，以使猜测更加困难。\n镜像中的缝隙（gaps in the images）会填充 trap 指令（例如，x86_64 平台上填充的是 int3 opcode）\n，用来捕获跳转探测（catching such jump probes）。\u003c/p\u003e\n\n\u003cp\u003e对于非特权程序（unprivileged programs），校验器还会对能使用的 helper 函数、指针\n等施加额外的限制，以确保不会发生数据泄露。\u003c/p\u003e\n\n\u003ch2 id=\"26-llvm\"\u003e2.6 LLVM\u003c/h2\u003e\n\n\u003cp\u003e至此，还有一个重要方面一直没有讨论：\u003cmark\u003e如何编写 eBPF 程序\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003ecBPF 提供的选择很少：libpcap 里面的 cBPF compiler，bpf_asm，或者手写 cBPF 程序；\n相比之下，eBPF 支持使用更更高层的语言（例如 C 和 P4）来编写，大大方便了 eBPF 程序的开发。\u003c/p\u003e\n\n\u003cp\u003eLLVM 有一个 \u003cstrong\u003eeBPF 后端\u003c/strong\u003e（back end），能生成（emit）包含 eBPF 指令的 ELF 文件。\nClang 这样的前端（front ends）能用来编译 eBPF 程序。\u003c/p\u003e\n\n\u003cp\u003e用 clang 来编译 eBPF 程序非常简单：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang -O2 -target bpf -o bpf prog.o -c bpf prog.c\u003c/code\u003e。\n一个很有用的选项是指定输出汇编代码：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang -O2 -target bpf -o - -S -c bpf prog.c\u003c/code\u003e or\n，或者用 readelf 之类的工具 dump 和 分析 ELF sections 和 relocations。\u003c/p\u003e\n\n\u003cp\u003e典型的工作流：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e用 C 编写 eBPF 代码\u003c/li\u003e\n  \u003cli\u003e用 clang/llvm 编译成目标文件\u003c/li\u003e\n  \u003cli\u003e用 tc 之类的加载器（能与 cls_bpf 分类器交互）将目标文件加载到内核\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"3-tc-cls_bpf-和-ebpf\"\u003e3 tc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 eBPF\u003c/h1\u003e\n\n\u003ch2 id=\"30-cls_bpf-和-act_bpf\"\u003e3.0 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e\u003c/h2\u003e\n\n\u003ch3 id=\"可编程-tc-分类器-cls_bpf\"\u003e可编程 tc 分类器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 作为一种分类器（classifier，也叫 filter），\u003cmark\u003e2013 年就出现在了 cBPF 中\u003c/mark\u003e [6]。\n通过 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_asm\u003c/code\u003e、libpcap/tcpdump\u003c/strong\u003e 或其他一些 cBPF 字节码生成器能对它进行编程。\n步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e使用工具生成字节码（byte code）\u003c/li\u003e\n  \u003cli\u003e将字节码传递给 tc 前端\u003c/li\u003e\n  \u003cli\u003etc 前端\u003cstrong\u003e\u003cmark\u003e通过 netlink 消息将字节码下发到 tc cls_bpf 分类器\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"可编程-tc-动作actionact_bpf\"\u003e可编程 tc 动作（action）\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e后来又出现 act_bpf [20]，这是一种 tc action，因此与其他 tc action 一样，act_bpf\n能被 \u003cstrong\u003eattach 到 tc 分类器\u003c/strong\u003e，作为分类器执行完之后对包要执行的动作（即，\n分类器执行完之后返回一个 action code，act_bpf 能根据这个 code 执行相应的行为，\n例如丢弃包）。\u003c/p\u003e\n\n\u003cp\u003e\u003cmark\u003eact_bpf 功能与 cls_bpf 几乎相同，区别在于二者的返回码类型\u003c/mark\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecls_bpf 返回的是 tc classid (major/minor)\u003c/li\u003e\n  \u003cli\u003eact bpf 返回的是 tc action opcode\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里对 cls_bpf/act_bpf 的解释太简单。想进一步了解，可参考：\n\u003ca href=\"/blog/understanding-tc-da-mode-zh/\"\u003e(译) 深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/a\u003e 译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003eact_bpf 的缺点是\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e只适用用于 cBPF\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e无法对包进行修改（mangle）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此通常需要用 action pipeline 做进一步处理，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_pedit\u003c/code\u003e，代价是\n\u003cstrong\u003e额外的包级别（packet-level）的性能开销\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"ebpf-对-cls_bpf-的支持\"\u003eeBPF 对 cls_bpf 的支持\u003c/h3\u003e\n\n\u003cp\u003eeBPF 引入 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_SCHED_CLS\u003c/code\u003e [8] 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_PROG_TYPE_SCHED_ACT\u003c/code\u003e [7] 之后也\n\u003cstrong\u003e支持了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact_bpf\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这两种类型的 fast path 都在 RCU 内运行（run under RCU）\u003c/li\u003e\n  \u003cli\u003e二者做的主要事情也就是调用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eBPF_PROG_RUN()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，后者会解析到\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(*filter-\u0026gt;bpf_func)(ctx, filter-\u0026gt;insnsi)\u003c/code\u003e，其中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ectx\u003c/code\u003e 参数包含了 skb 信息\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_func()\u003c/code\u003e 里对 skb 进行处理，\u003cmark\u003e接下来可能会执行\u003c/mark\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eeBPF 解释器（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_prog_run()\u003c/code\u003e）\u003c/li\u003e\n      \u003cli\u003eJIT 编译器生成的 JIT image\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"ebpf-cls_bpf-带来的好处\"\u003eeBPF cls_bpf 带来的好处\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf_classify()\u003c/code\u003e 之类的函数感知不到底层 BPF 类型（eBPF 还是 cBPF），\n因此对于 cBPF 和 eBPF，skb 的穿梭路径是一样的。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 相比于其他类型 tc 分类器的一个优势：\u003cmark\u003e能实现高效、非线性分类功能\u003c/mark\u003e（以及\ndirect actions，后面会介绍），这意味着 \u003cstrong\u003eBPF 程序可以得到简化，只解析一遍就能处理不同类型的 skb\u003c/strong\u003e\n（a single parsing pass is enough to process skbs of different types）。\u003c/p\u003e\n\n\u003cp\u003e历史上，tc 支持 attach 多个分类器 —— 前面的没有匹配成功时，接着匹配下一个。\n因此，如果一个包要经过多个分类器，那它的某些字段就会在每个分类器中都要解析一遍，这显然是非常低效的。\u003c/p\u003e\n\n\u003cp\u003e有了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e，使用单个 eBPF 程序（用作分类器）就可以轻松地避免这个问题，\n或者是使用 eBPF 尾调用结构，后者支持 packet parser 的某些部分进行原子替换。\n此时，eBPF 程序就能根据分类或动作结果（classification or action outcome），\n来返回不同的 classid 或 opcodes 了，下面进一步介绍。\u003c/p\u003e\n\n\u003ch2 id=\"31-工作模式传统模式和-direct-action-模式\"\u003e3.1 工作模式：传统模式和 direct-action 模式\u003c/h2\u003e\n\n\u003cp\u003ecls_bpf 在处理 action 方面有两种工作模式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e传统模式：分类之后执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcf_exts_exec()\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003edirect-action 模式\u003c/p\u003e\n\n    \u003cp\u003e随着 eBPF 功能越来越强大，它能做的事情不止是分类，例如，分类器自己就\n  能够（无需 action 参与）修改包的内容（mangle packet contents）、更新校验和\n  （update checksums）等。\u003c/p\u003e\n\n    \u003cp\u003e因此，社区决定引入一个 direct action (da) mode [3]。使用 cls_bpf 时，这是推荐的模式。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在 da 模式中，cls_bpf 对 skb 执行 action，返回的是 tc opcode，\n最终形成一个紧凑、轻量级的镜像（compact, lightweight image）。\n而在此之前，需要使用 tc action 引擎，必须穿越多层 indirection 和 list handling。\n对于 eBPF 来说，classid 可以存储在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tc_classid\u003c/code\u003e，然后返回 action opcode。\n这个 opcode 对于 cBPF drop action 这样的简单场景也是适用的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这里对 da 的解释过于简单，很难理解。可参考\n下面这篇文章，其对 da 模式的来龙去脉、工作原理和内核实现有更深入介绍：\n\u003ca href=\"/blog/understanding-tc-da-mode-zh/\"\u003e(译) 深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/a\u003e 译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e此外，cls_bpf 也支持多个分类器，每个分类器可以工作在不同模式（da 和 non-da） —— 只要你有这个需要。\n但建议 fast path 越紧凑越好，\u003cmark\u003e对应高性能应用，推荐使用单个 cls_bpf 分类器\n并且工作在 da 模式\u003c/mark\u003e，这足以满足大部分需求了。\u003c/p\u003e\n\n\u003ch2 id=\"32-特性\"\u003e3.2 特性\u003c/h2\u003e\n\n\u003cp\u003eeBPF cls_bpf 带来了很多新特性，例如可以读写包的很多字段、一些新的辅助函数。\n这些特性或功能可以组合使用，产生强大的效果。\u003c/p\u003e\n\n\u003ch3 id=\"skb-可读写字段\"\u003eskb 可读/写字段\u003c/h3\u003e\n\n\u003cp\u003eFor the context (skb here is of type \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sk_buff\u003c/code\u003e), cls_bpf 允许\u003cmark\u003e读写\u003c/mark\u003e下列字段：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eskb-\u0026gt;mark\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;priority\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;tc_index\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;cb[5]\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;tc_classid members\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e允许\u003cmark\u003e读\u003c/mark\u003e下列字段：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eskb-\u0026gt;len\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;pkt type\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;queue mapping\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;protocol\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;vlan tci\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;vlan proto\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;vlan present\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;ifindex (translates to netdev’s ifindex)\u003c/li\u003e\n  \u003cli\u003eskb-\u0026gt;hash\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"辅助函数\"\u003e辅助函数\u003c/h3\u003e\n\n\u003cp\u003ecls_bpf 程序类型中有很多的 helper 函数可供使用。包括\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对 map 进行操作（get/update/delete）的辅助函数\u003c/li\u003e\n  \u003cli\u003e尾调用辅助函数\u003c/li\u003e\n  \u003cli\u003e对 skb 进行 mangle 的辅助函数（storing and loading bytes into the skb for parsing and packet mangling）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e重新计算 L3/L4 checksum\u003c/mark\u003e\u003c/strong\u003e 的辅助函数\u003c/li\u003e\n  \u003cli\u003e封装/解封装（VLAN、VxLAn 等隧道）相关辅助函数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"重定向redirection\"\u003e重定向（redirection）\u003c/h3\u003e\n\n\u003cp\u003ecls_bpf 还能对 skb 进行重定向，包括，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev_queue_xmit()\u003c/code\u003e 在 egress 路径中重定向，或者\u003c/li\u003e\n  \u003cli\u003e在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev_forward_skb()\u003c/code\u003e 中重定向回 ingress path。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e重定向有两种可能的方式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e方式一：在 eBPF 程序运行时（runtime）复制一份数据包（clone skb）\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e方式二：\u003cmark\u003e无需复制数据包\u003c/mark\u003e，性能更好\u003c/p\u003e\n\n    \u003cp\u003e需要 cls_bpf 运行在 da 模式，并且\u003cstrong\u003e返回值为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACT_REDIRECT\u003c/code\u003e\u003c/strong\u003e。\n  \u003cmark\u003esch_clsact 等 qdisc 在 ingress/egress path 上支持这种这种 action\u003c/mark\u003e。\u003c/p\u003e\n\n    \u003cp\u003eeBPF 程序在 runtime 将必要的重定向信息放到一个 per-CPU scratch buffer，\n  然后返回相关的 opcode，接下来内核会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb_do_redirect()\u003c/code\u003e 来完成重定向。\n  这种是一种性能优化方式，能显著提升转发性能。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"调试debug\"\u003e调试（Debug）\u003c/h3\u003e\n\n\u003cp\u003e可以使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e 辅助函数，它能将消息打印到 trace pipe，格式与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintk()\u003c/code\u003e 类似，\n然后可以通过 \u003cmark\u003etc exec bpf dbg\u003c/mark\u003e 等命令读取。\u003c/p\u003e\n\n\u003cp\u003e虽然它作为 helper 函数有一些限制，\n能传递五个参数，其中前两个是格式字符串，但这个功能还是给编写和调试 eBPF 程序带来了很大便利。\u003c/p\u003e\n\n\u003cp\u003e还有其他一些 helper 函数，例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e读取 skb 的 cgroup classid（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_cls\u003c/code\u003e cgroup），\u003c/li\u003e\n  \u003cli\u003e读取 dst 的 routing realm (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst-\u0026gt;tclassid\u003c/code\u003e)\u003c/li\u003e\n  \u003cli\u003e获取一个随机数（例如用于采样）\u003c/li\u003e\n  \u003cli\u003e获取当前包正在被哪个 CPU 处理\u003c/li\u003e\n  \u003cli\u003e获取纳秒为单位的当前时间（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ektime_t\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"可以-attach-到的-tc-hooks\"\u003e可以 attach 到的 tc hooks\u003c/h3\u003e\n\n\u003cp\u003ecls_bpf 能 attach 到许多与 tc 相关的 hook 点。这些 \u003cmark\u003ehook 点可分为三类\u003c/mark\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eingress hook\u003c/li\u003e\n  \u003cli\u003eegress hook，这是最近才引入的\u003c/li\u003e\n  \u003cli\u003eclassification hook inside classful qdiscs on egress.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e前两种可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_clsact\u003c/code\u003e qdisc (或 sch_ingress\nfor the ingress-only part) 配置，而且是在 RCU 上下文中无锁运行的 [12]。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e可进一步参考：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"/blog/understanding-tc-da-mode-zh/\"\u003e(译) 深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"/blog/advanced-bpf-kernel-features-for-container-age-zh/\"\u003e(译) 为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eegress hook 在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edev_queue_xmit()\u003c/code\u003e 中执行（before fetching the transmit queue\nfrom the device）。\u003c/p\u003e\n\n\u003ch2 id=\"33-前端front-end\"\u003e3.3 前端（Front End）\u003c/h2\u003e\n\n\u003cp\u003etc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 的 iproute2 前端 [10] [11] [9]\n在将 cls_bpf 数据通过 netlink 发送到内核之前，在背后做了很多工作。\niproute2 包含了一个通用 ELF 加载器后端，适用于下面几个部分，实现了通用代码的共享：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ef_bpf (classifier)\u003c/li\u003e\n  \u003cli\u003em_bpf (action)\u003c/li\u003e\n  \u003cli\u003ee_bpf (exec)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e编译和加载所涉及到的 iproute2/tc 内部工作：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e当用 clang 编译 eBPF 代码时，它会生成一个 ELF 格式的目标文件，\n接下来通过 tc 加载到内核。这个\u003cmark\u003e目标文件就是一个容器（container）\u003c/mark\u003e，\n其中包含了 tc 所需的所有数据：它会\u003cmark\u003e从中提取数据、重定位（relocate）并加载到 cls_bpf hook 点\u003c/mark\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e在启动时，\u003cmark\u003etc 会检查（如果有必要还会 mount）bpf 文件系统\u003c/mark\u003e，用于 object pinning。\n默认目录是  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf\u003c/code\u003e。然后会加载和生成一个 pinning 配置用的哈希表，给 map\n共享用。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e之后，tc 会\u003cmark\u003e扫描目标文件中的 ELF sections\u003c/mark\u003e。一些预留的 section 名，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emaps\u003c/code\u003e：for eBPF map specifications (e.g. map type, key and value size, maximum elements, pinning, etc)\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elicense\u003c/code\u003e：for the licence string, specified similarly as in Linux kernel modules.\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclassifier\u003c/code\u003e：默认情况下，\u003cmark\u003ecls_bpf 分类器所在的 section\u003c/mark\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eact\u003c/code\u003e：默认情况下，\u003cmark\u003eact_bpf 所在的 section\u003c/mark\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003etc 首先读取辅助功能区（ancillary sections），这包括 \u003cstrong\u003eELF 的符号表 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.symtab\u003c/code\u003e 和字符串表 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.strtab\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003cp\u003e由于 eBPF 中的所有东西都是通过文件描述符来从用户空间访问的，\n因此 \u003cmark\u003etc 前端首先需要基于 ELF 的 relocation entries 生成 maps\u003c/mark\u003e，\n它将文件描述符作为立即值（immediate value）插入相应的指令。\u003c/p\u003e\n\n    \u003cp\u003e取决于 map 是否是 pinned，tc 或者\u003cmark\u003e从 bpffs 的指定位置加载一个 map 文件描述符\u003c/mark\u003e，\n或者\u003cmark\u003e生成一个新的\u003c/mark\u003e，并且如果有需要，将它 pin 到 bpffs。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"处理-object-pinning\"\u003e处理 Object pinning\u003c/h3\u003e\n\n\u003cp\u003esharing maps 有\u003cmark\u003e三种不同的 scope\u003c/mark\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/tc/globals\u003c/code\u003e：全局命名空间\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/bpf/tc/\u0026lt;obj-sha\u0026gt;\u003c/code\u003e：对象命名空间（object namespace）\u003c/li\u003e\n  \u003cli\u003e自定义位置\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eeBPF maps 可以在不同的 cls_bpf 实例之间共享。\n不止通用类型 map（例如 array、hash table）可以共享，专业类型的 map，例如 tracing\neBPF 程序（kprobes）使用的 eBPF maps 也与 cls_bpf/act_bpf 使用的 eBPF maps 实现共享。\u003c/p\u003e\n\n\u003cp\u003eObject pinning 时，tc 会在 ELF 的符号表和字符串表中寻找 map name。\nmap 创建完成后，tc 会找到程序代码所在的 section，然后带着 map 的文件描述符信\n息\u003cmark\u003e执行重定位\u003c/mark\u003e，并将程序代码加载到内核。\u003c/p\u003e\n\n\u003ch3 id=\"处理尾调用\"\u003e处理尾调用\u003c/h3\u003e\n\n\u003cp\u003e当用到了尾调用且尾调用 subsection 也在 ELF 文件中时，tc 也会将它们加载到内核。\n从 tc 加载器的角度看，尾调用可以任意嵌套，但内核运行时对嵌套是有限制的。\n另外，\u003cstrong\u003e尾调用用到的程序数组（program array）也能被 pin\u003c/strong\u003e，\n这样能在用户空间根据程序的运行时行为来修改这个数组（决定尾调用到哪个程序）。\u003c/p\u003e\n\n\u003ch3 id=\"tc-exec-bpf-graft\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf graft\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003etc 有个 graft（嫁接） 选项，\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf [ graft MAP_FILE ] [ key KEY ]\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e它能\u003cstrong\u003e在运行时替换 section\u003c/strong\u003e（replacing such sections during runtime）。\nGrafting 实际上\u003cstrong\u003e所做的事情和加载一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 分类器差不多\u003c/strong\u003e，区别在于\n产生的\u003cmark\u003e文件描述符并不是通过 netlink —— 而是通过相应的 map —— push 到内核\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003etc cls_bpf 前端还允许通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexecvpe()\u003c/code\u003e 将新生成的 map 的文件描述符传递给新创建的 shell，\n这样程序就能像 stdin、stdout、stderr 一样全局地使用它；或者，文件描述符集合还能通过 Unix domain socket 传递给其他进程。\n在这两种情况下，cloned 文件描述符的生命周期仍然与进程的生命周期紧密相连。\n\u003cmark\u003e通过 bpf fs 获取文件描述符\u003c/mark\u003e是最灵活也是最推荐的方式，[9]\n也适用于第三方用户空间程序管理 eBPF map 的内容。\u003c/p\u003e\n\n\u003ch3 id=\"tc-exec-bpf-dbg\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf dbg\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003etc 前端提供了打印 trace pipe 的命令行工具：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc exec bpf dbg\u003c/code\u003e。这个命令\n\u003cstrong\u003e会用到 trace fs\u003c/strong\u003e，它会自动定位 trace fs 的挂载点。\u003c/p\u003e\n\n\u003ch2 id=\"34-工作流workflow\"\u003e3.4 工作流（Workflow）\u003c/h2\u003e\n\n\u003cp\u003e一个典型的工作流是：\u003cstrong\u003e将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecls_bpf\u003c/code\u003e 分类器以 da 模式加载到内核\u003c/strong\u003e，整个过程简单直接。\u003c/p\u003e\n\n\u003cp\u003e来看下面的例子：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e用 clang 编译源文件 foo.c，生成的目标文件 foo.o；foo.o 中包含两个 section \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ep1\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ep2\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e启用内核的 JIT 编译功能\u003c/li\u003e\n  \u003cli\u003e给网络设备 em1 添加一个 clsact qdisc\u003c/li\u003e\n  \u003cli\u003e将目标文件分别加载到 em1 的 ingress 和 egress 路径上\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e foo.o \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e foo.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esysctl \u003cspan class=\"nt\"\u003e-w\u003c/span\u003e net.core.bpf_jit_enable\u003cspan class=\"o\"\u003e=\u003c/span\u003e1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev em1 clsact\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc show dev em1\n\u003cspan class=\"o\"\u003e[\u003c/span\u003e...]\nqdisc clsact ffff: parent ffff:fff1\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 ingress bpf da obj foo.o sec p1\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter add dev em1 egress bpf da obj foo.o sec p2\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 ingress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle\n0x1 foo.o:[p1] direct-action\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev em1 egress\nfilter protocol all pref 49152 bpf\nfilter protocol all pref 49152 bpf handle\n0x1 foo.o:[p2] direct-action\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后将它们删除：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter del dev em1 ingress pref 49152\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter del dev em1 egress pref 49152\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"35-编程\"\u003e3.5 编程\u003c/h2\u003e\n\n\u003cp\u003eiproute2 源码中 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexamples/bpf/\u003c/code\u003e 目录下包含很多入门示例，是用 restricted C 编写的 eBPF 代码。\n实现这样的分类器还是比较简单的。\u003c/p\u003e\n\n\u003cp\u003e与传统用户空间 C 程序相比，eBPF 程序在某些地方是受限的。\n每个这样的分类器都必须放到 ELF sections。因此，\u003cmark\u003e一个目标文件会包含一个或多个 eBPF 分类器\u003c/mark\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"代码共享内联函数或尾调用\"\u003e代码共享：内联函数或尾调用\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e分类器之间共享代码\u003c/strong\u003e有两种方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__always_inline\u003c/code\u003e 声明的内联函数\u003c/p\u003e\n\n    \u003cp\u003eclang 需要将整个扁平程序（the whole, flat program）编程成 eBPF 指令流，\n 分别放到各自的 ELF section。\u003c/p\u003e\n\n    \u003cp\u003eeBPF 不支持共享库（shared libraries）或\u003cstrong\u003e可重入 eBPF 函数\u003c/strong\u003e（eBPF functions as relocation entries）。\n 像 tc 这样的 eBPF \u003cstrong\u003e加载器\u003c/strong\u003e，是无法将多个库拼装成单个扁平 eBPF 指令流数组的\n （a single flat array of eBPF instructions） —— 除非它实现\u003cstrong\u003e编译器\u003c/strong\u003e的大部分功能。\u003c/p\u003e\n\n    \u003cp\u003e因此，加载器和 clang 之间有一份“契约”（contract），其中明确规定了生成的 ELF 文件中，\n 特定 section 中必须包含什么样的 eBPF 指令。\u003c/p\u003e\n\n    \u003cp\u003e唯一允许的重定位项（relocation entries）是与 map 相关的，这种情况下需要先确定文件描述符。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e尾调用\u003c/p\u003e\n\n    \u003cp\u003e前面已经介绍过了。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"有限栈空间和全局变量\"\u003e有限栈空间和全局变量\u003c/h3\u003e\n\n\u003cp\u003eeBPF 程序的栈空间非常有限，只有 512KB，因此用 C 实现 eBPF 程序时需要特别注意这一点。\n常规 C 程序中常见的\u003cmark\u003e全局变量在这里不支持的\u003c/mark\u003e（译注：较新的内核已经支持了）。\u003c/p\u003e\n\n\u003cp\u003eeBPF maps（在 tc 中对应的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct bpf_elf_map\u003c/code\u003e）定义在各自的 ELF sections\n中，但可以在程序 sections 中访问到。\n因此，如果真的需要全局“变量”，可以这样实现：创建一个 per-CPU 或 non-per-CPU array map，\n但其中只存储有一个值，这样这个变量就能被多个 section 中的程序访问，例如\nentry point sections、tail called sections 等。\u003c/p\u003e\n\n\u003ch3 id=\"动态循环\"\u003e动态循环\u003c/h3\u003e\n\n\u003cp\u003e另一个限制是：eBPF 程序不支持动态循环（dynamic looping），只支持编译时已知的常量循环\n（compile-time known constant bounds），后者能被 clang 展开。\u003c/p\u003e\n\n\u003cp\u003e编译时不能确定是否为常量次数的循环会被校验器拒绝，因为这样的程序无法静态验证\n（statically verify）它们是否确定会终止。\u003c/p\u003e\n\n\u003ch1 id=\"4-总结及未来展望\"\u003e4 总结及未来展望\u003c/h1\u003e\n\n\u003cp\u003e\u003cmark\u003ecls_bpf 是 tc 家族中的一个灵活高效的分类器（及 action）\u003c/mark\u003e，\n它提供了强大的\u003cstrong\u003e数据平面可编程能力\u003c/strong\u003e，适用于大量不同场景，例如解析、查找或更新\n（例如 map state），以及对网络包进行修改（mangling）等。\n当使用底层平台的 eBPF JIT 后端进行编译之后，这些 eBPF 程序能以\u003cmark\u003e平台原生性能执行\u003c/mark\u003e。\neBPF 是为\u003cstrong\u003e既要求高性能又要求高灵活性\u003c/strong\u003e的场景设计的。\u003c/p\u003e\n\n\u003cp\u003e虽然一些内部细节看上去有点复杂，让人望而生畏，但了解了 eBPF 的限制条件之后，\n编写 cls_bpf eBPF 程序其实与编写普通用户空间程序并不会复杂多少。\n另外，tc 命令行在设计时也考虑到了易用性，例如用 tc 处理 cls_bpf 前端只需要几条命令。\u003c/p\u003e\n\n\u003cp\u003ecls_bpf 代码 及其 tc 前端、eBPF 内部实现及其 clang 编译器后端全部都是开源的，\n由社区开发和维护。\u003c/p\u003e\n\n\u003cp\u003e目前还有很多的增强特性和想法正在讨论和评估之中，例如将 cls_bpf offload 到可编程网卡上。\n\u003ca href=\"https://criu.org/Main_Page\"\u003eCRIU\u003c/a\u003e（checkpoint restore in user space）\n目前还只支持 cBPF，如果实现了对 eBPF 的支持，对容器迁移将非常有用。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003eBegel, A.; Mccanne, S.; and Graham, S. L. 1999. Bpf+: Exploiting global data-flow optimization in a generalized packet filter architecture. In In SIGCOMM, 123–134.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D., and Sowa, H. F. 2014. net: bpf: make ebpf interpreter images read-only. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/60a3b2253c41\"\u003e60a3b2253c41\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D., and Starovoitov, A. 2015. cls_bpf: introduce integrated actions. Linux kernel, commit 045efa82ff56.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D.; Starovoitov, A.; and Sowa, H. F. 2015.  bpf: add support for persistent maps/progs. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/b2197755b263\"\u003eb2197755b263\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2013a. filter: bpf_asm: add minimal bpf asm tool. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/3f356385e8a4\"\u003e3f356385e8a4\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2013b. net: sched: cls_bpf: add bpf-based classifier. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/7d1d65cb84e1\"\u003e7d1d65cb84e1\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2015a. act bpf: add initial ebpf support for actions. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/a8cb5f556b56\"\u003ea8cb5f556b56\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2015b. cls bpf: add initial ebpf support for programmable classifiers. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/e2e9b6541dd4\"\u003ee2e9b6541dd4\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2015c. ff,mg bpf: allow for sharing maps.  iproute2, commit 32e93fb7f66d.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2015d. tc: add ebpf support to f_bpf.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2015e. tc, bpf: finalize ebpf support for cls and act front-end. iproute2, commit 6256f8c9e45f.\u003c/li\u003e\n  \u003cli\u003eBorkmann, D. 2016. net, sched: add clsact qdisc. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/1f211a1b929c\"\u003e1f211a1b929c\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003ede Bruijn, W. 2015a. packet: add classic bpf fanout mode. Linux kernel, commit 47dceb8ecdc1.\u003c/li\u003e\n  \u003cli\u003ede Bruijn, W. 2015b. packet: add extended bpf fanout mode. Linux kernel, commit f2e520956a1a.\u003c/li\u003e\n  \u003cli\u003eDrewry, W. 2012. seccomp: add system call filtering using bpf. Linux kernel, commit e2cfabdfd075.\u003c/li\u003e\n  \u003cli\u003eGallek, C. 2016. soreuseport: setsockopt so attach reuseport [ce]bpf. Linux kernel, commit 538950a1b752.\u003c/li\u003e\n  \u003cli\u003eHerbert, T. 2016. kcm: Kernel connection multiplexor module. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/ab7ac4eb9832\"\u003eab7ac4eb9832\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eMccanne, S., and Jacobson, V. 1992. The bsd packet filter: A new architecture for user-level packet capture. 259–269.\u003c/li\u003e\n  \u003cli\u003ePirko, J. 2012. team: add loadbalance mode. Linux kernel, commit 01d7f30a9f96.\u003c/li\u003e\n  \u003cli\u003ePirko, J. 2015. tc: add bpf based action. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/d23b8ad8ab23\"\u003ed23b8ad8ab23\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A., and Borkmann, D. 2014. net: filter: rework/optimize internal bpf interpreter’s instruction set.  Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/bd4cf0ed331a\"\u003ebd4cf0ed331a\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2014a. bpf: expand bpf syscall with program load/unload. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/09756af46893\"\u003e09756af46893\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2014b. bpf: introduce bpf syscall and maps. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/99c55f7d47c0\"\u003e99c55f7d47c0\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2014c. bpf: verifier (add verifier core).  Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/17a5267067f3\"\u003e17a5267067f3\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2014d. net: filter: x86: internal bpf jit.  Linux kernel, commit 622582786c9e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2015a. bpf: allow bpf programs to tail-call other bpf programs. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/04fd61ab36ec\"\u003e04fd61ab36ec\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2015b. tracing, perf: Implement bpf programs attached to kprobes. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/2541517c32be\"\u003e2541517c32be\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eStarovoitov, A. 2016. bpf: introduce bpf map type stack trace. Linux kernel, commit \u003ca href=\"https://github.com/torvalds/linux/commit/d5a3b1f69186\"\u003ed5a3b1f69186\u003c/a\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/understanding-tc-da-mode-zh/\"\u003e\u003cspan\u003e« [译] 深入理解 tc ebpf 的 direct-action (da) 模式（2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/bpf-portability-and-co-re-zh/\"\u003e\u003cspan\u003e[译] BPF 可移植性和 CO-RE（一次编译，到处运行）（Facebook，2020） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-03-05T00:00:00Z",
  "Author": "Arthur Chiao"
}