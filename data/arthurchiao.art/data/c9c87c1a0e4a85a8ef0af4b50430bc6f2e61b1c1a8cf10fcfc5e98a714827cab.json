{
  "Source": "arthurchiao.art",
  "Title": "[译] LLVM eBPF 汇编编程（2020）",
  "Link": "https://arthurchiao.art/blog/ebpf-assembly-with-llvm-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] LLVM eBPF 汇编编程（2020）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-08-15 | Last Update 2021-08-17\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2020 年 Quentin Monnet 的一篇英文博客：\n\u003ca href=\"https://qmonnet.github.io/whirl-offload/2020/04/12/llvm-ebpf-asm/\"\u003eeBPF assembly with LLVM\u003c/a\u003e。\nQuentin Monnet 是 Cilium 开发者之一，此前也在从事网络、eBPF 相关的开发。\u003c/p\u003e\n\n\u003cp\u003e翻译已获得 Quentin Monnet 授权。\u003c/p\u003e\n\n\u003cp\u003e文章介绍了如何直接\u003cstrong\u003e\u003cmark\u003e基于 LLVM eBPF 汇编开发 BPF 程序\u003c/mark\u003e\u003c/strong\u003e，虽然给出的\n两个例子极其简单，但其流程对于开发更大的程序也是适用的。\u003cstrong\u003e\u003cmark\u003e为什么不用 C，而用汇编\u003c/mark\u003e\u003c/strong\u003e\n这么不友好的编程方式呢？至少有两个特殊场景：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e测试特定的 eBPF 指令流\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e对程序的某个特定部分进行\u003cstrong\u003e\u003cmark\u003e深度调优\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e原文历时（开头之后拖延）了好几年，\u003cdel\u003e因此文中存在一些（文件名等）前后不一致之处，翻译时已经改正\u003c/del\u003e\n（交流之后，作者已经修正）；另外，译文基于 clang/llvm 10.0 验证了其中的每个步骤，因此代码、输出等与原文不完全一致。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-引言\" id=\"markdown-toc-1-引言\"\u003e1 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-主流开发方式从-c-代码直接生成-ebpf-字节码\" id=\"markdown-toc-11-主流开发方式从-c-代码直接生成-ebpf-字节码\"\u003e1.1 主流开发方式：从 C 代码直接生成 eBPF 字节码\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-特殊场景需求ebpf-汇编编程更合适\" id=\"markdown-toc-12-特殊场景需求ebpf-汇编编程更合适\"\u003e1.2 特殊场景需求：eBPF 汇编编程更合适\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-几种-ebpf-汇编编程方式\" id=\"markdown-toc-13-几种-ebpf-汇编编程方式\"\u003e1.3 几种 eBPF 汇编编程方式\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-clangllvm-编译-ebpf-基础\" id=\"markdown-toc-2-clangllvm-编译-ebpf-基础\"\u003e2 Clang/LLVM 编译 eBPF 基础\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-将-c-程序编译成-bpf-目标文件\" id=\"markdown-toc-21-将-c-程序编译成-bpf-目标文件\"\u003e2.1 将 C 程序编译成 BPF 目标文件\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-查看-elf-文件中的-ebpf-字节码\" id=\"markdown-toc-12-查看-elf-文件中的-ebpf-字节码\"\u003e1.2 查看 ELF 文件中的 eBPF 字节码\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-方式一c-生成-ebpf-汇编--手工修改汇编\" id=\"markdown-toc-3-方式一c-生成-ebpf-汇编--手工修改汇编\"\u003e3 方式一：C 生成 eBPF 汇编 + 手工修改汇编\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-将-c-编译成-ebpf-汇编clang\" id=\"markdown-toc-31-将-c-编译成-ebpf-汇编clang\"\u003e3.1 将 C 编译成 eBPF 汇编（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-手工修改汇编程序\" id=\"markdown-toc-32-手工修改汇编程序\"\u003e3.2 手工修改汇编程序\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-将汇编程序-assemble-成-elf-对象文件llvm-mc\" id=\"markdown-toc-33-将汇编程序-assemble-成-elf-对象文件llvm-mc\"\u003e3.3 将汇编程序 assemble 成 ELF 对象文件（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-mc\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-查看对象文件中的-ebpf-字节码readelf\" id=\"markdown-toc-34-查看对象文件中的-ebpf-字节码readelf\"\u003e3.4 查看对象文件中的 eBPF 字节码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-以更加人类可读的方式查看-ebpf-字节码llvm-objdump--d\" id=\"markdown-toc-35-以更加人类可读的方式查看-ebpf-字节码llvm-objdump--d\"\u003e3.5 以更加人类可读的方式查看 eBPF 字节码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump -d\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#36-编译时嵌入调试符号或-c-源码clang--g--llvm-objdump--s\" id=\"markdown-toc-36-编译时嵌入调试符号或-c-源码clang--g--llvm-objdump--s\"\u003e3.6 编译时嵌入调试符号或 C 源码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang -g\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump -S\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-方式二内联汇编inline-assembly\" id=\"markdown-toc-4-方式二内联汇编inline-assembly\"\u003e4 方式二：内联汇编（inline assembly）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-c-内联汇编示例\" id=\"markdown-toc-41-c-内联汇编示例\"\u003e4.1 C 内联汇编示例\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-编译及查看生成的字节码\" id=\"markdown-toc-42-编译及查看生成的字节码\"\u003e4.2 编译及查看生成的字节码\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-小结\" id=\"markdown-toc-43-小结\"\u003e4.3 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-结束语\" id=\"markdown-toc-5-结束语\"\u003e5 结束语\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-引言\"\u003e1 引言\u003c/h1\u003e\n\n\u003ch2 id=\"11-主流开发方式从-c-代码直接生成-ebpf-字节码\"\u003e1.1 主流开发方式：从 C 代码直接生成 eBPF 字节码\u003c/h2\u003e\n\n\u003cp\u003eeBPF 相比于 cBPF（经典 BPF）的优势之一是：Clang/LLVM 为它提供了一个\u003cstrong\u003e\u003cmark\u003e编译后端\u003c/mark\u003e\u003c/strong\u003e，\n能从 C 源码直接生成 eBPF 字节码（bytecode）。（写作本文时，GCC 也提供了一个类似\n的后端，但各方面都没有 Clang/LLVM 完善，因此后者仍然是\u003cstrong\u003e\u003cmark\u003e生成 eBPF 字节码\n的最佳参考工具\u003c/mark\u003e\u003c/strong\u003e）。\u003c/p\u003e\n\n\u003cp\u003e将 C 代码编译成 eBPF 目标文件非常有用，因为\n\u003cstrong\u003e\u003cmark\u003e直接用字节码编写高级程序\u003c/mark\u003e\u003c/strong\u003e是非常耗时的。此外，截至本文写作时，\n还无法直接编写字节码程序来使用 \u003ca href=\"https://facebookmicrosites.github.io/bpf/blog/2020/02/19/bpf-portability-and-co-re.html\"\u003eCO-RE\u003c/a\u003e \n等复杂特性。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"/blog/bpf-portability-and-co-re-zh/\"\u003e\u003cmark\u003e(译) BPF 可移植性和 CO-RE（一次编译，到处运行）\u003c/mark\u003e（Facebook，2020）\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e因此，Clang 和 LLVM 仍然是 eBPF 工作流不可或缺的部分。\u003c/p\u003e\n\n\u003ch2 id=\"12-特殊场景需求ebpf-汇编编程更合适\"\u003e1.2 特殊场景需求：eBPF 汇编编程更合适\u003c/h2\u003e\n\n\u003cp\u003e但是，C 方式不适用于某些特殊的场景，例如：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e只是想\u003cstrong\u003e\u003cmark\u003e测试特定的 eBPF 指令流\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e对程序的某个特定部分进行\u003cstrong\u003e\u003cmark\u003e深度调优\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在这些情况下，就需要直接编写或修改 eBFP 汇编程序。\u003c/p\u003e\n\n\u003ch2 id=\"13-几种-ebpf-汇编编程方式\"\u003e1.3 几种 eBPF 汇编编程方式\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e直接编写 eBPF 字节码程序\u003c/mark\u003e\u003c/strong\u003e。也就是编写\u003cstrong\u003e\u003cmark\u003e可直接加载运行\u003c/mark\u003e\u003c/strong\u003e的\n二进制 eBPF 程序，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e这肯定是可行的，但过程非常冗长无聊，对开发者极其不友好。\u003c/li\u003e\n      \u003cli\u003e此外，为\u003cstrong\u003e\u003cmark\u003e保证与 tc 等工具的兼容\u003c/mark\u003e\u003c/strong\u003e，还要将写好的程序转换成目标文件（object file），因此工作量又多了一些。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e直接用 eBPF 汇编语言编写\u003c/mark\u003e\u003c/strong\u003e，然后用\u003cstrong\u003e\u003cmark\u003e专门的汇编器\u003c/mark\u003e\u003c/strong\u003e\n  （例如 \u003ca href=\"https://github.com/solarflarecom/ebpf_asm\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eebpf_asm\u003c/code\u003e\u003c/a\u003e）将其汇编（assemble）成字节码。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e相比字节码（二进制），汇编语言（文本）至少可读性还是好很多的。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e用 LLVM 将 C 编译成 eBPF 汇编，然后\u003cstrong\u003e\u003cmark\u003e手动修改生成的汇编程序\u003c/mark\u003e\u003c/strong\u003e，\n最后再将其汇编（assemble）成字节码放到对象文件。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e在 C 中插入内联汇编，然后统一用 clang/llvm 编译。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e以上几种方式 \u003cstrong\u003e\u003cmark\u003eClang/LLVM 都支持\u003c/mark\u003e\u003c/strong\u003e！先用可读性比较好的方式写，\n然后再将其汇编（assembling）成另字节码程序。此外，甚至能 dump 对象文件中包含的程序。\u003c/p\u003e\n\n\u003cp\u003e本文将会展示第三种和第四种方式，第二种可以认为是第三种的更加彻底版，开发的流程\n、步骤等已经包括在第三种了。\u003c/p\u003e\n\n\u003ch1 id=\"2-clangllvm-编译-ebpf-基础\"\u003e2 Clang/LLVM 编译 eBPF 基础\u003c/h1\u003e\n\n\u003cp\u003e在开始汇编编程之前，先来熟悉一下 clang/llvm 将 C 程序编译成 eBPF 程序的过程。\u003c/p\u003e\n\n\u003ch2 id=\"21-将-c-程序编译成-bpf-目标文件\"\u003e2.1 将 C 程序编译成 BPF 目标文件\u003c/h2\u003e\n\n\u003cp\u003e下面是个 \u003cstrong\u003e\u003cmark\u003eeBPF 程序\u003c/mark\u003e\u003c/strong\u003e：没做任何事情，直接返回零，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ebpf.c\nint func\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn \u003c/span\u003e0\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如下命令可以将其编译成\u003cstrong\u003e\u003cmark\u003e对象文件（目标文件）\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# 注意 target 类型指定为 `bpf`\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-Wall\u003c/span\u003e \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e bpf.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e某些\u003cstrong\u003e\u003cmark\u003e复杂的程序\u003c/mark\u003e\u003c/strong\u003e可能需要用下面的命令来编译：\u003c/p\u003e\n\n  \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-O2\u003c/span\u003e \u003cspan class=\"nt\"\u003e-emit-llvm\u003c/span\u003e \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e bpf.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e - | \u003cspan class=\"se\"\u003e\\\u003c/span\u003e\n\tllc \u003cspan class=\"nt\"\u003e-march\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ebpf \u003cspan class=\"nt\"\u003e-mcpu\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eprobe \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e以上命令会将 C 源码\u003cstrong\u003e\u003cmark\u003e编译成字节码\u003c/mark\u003e\u003c/strong\u003e，然后生成一个 \u003cstrong\u003e\u003cmark\u003eELF 格式\u003c/mark\u003e\u003c/strong\u003e的目标文件。\u003c/p\u003e\n\n\u003ch2 id=\"12-查看-elf-文件中的-ebpf-字节码\"\u003e1.2 查看 ELF 文件中的 eBPF 字节码\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e默认情况下，代码位于 ELF 的 \u003ccode\u003e.text\u003c/code\u003e 区域\u003c/mark\u003e\u003c/strong\u003e（section）：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ereadelf \u003cspan class=\"nt\"\u003e-x\u003c/span\u003e .text bpf.o\nHex dump of section \u003cspan class=\"s1\"\u003e\u0026#39;.text\u0026#39;\u003c/span\u003e:\n  0x00000000 b7000000 00000000 95000000 00000000 ................\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这就是\u003cstrong\u003e\u003cmark\u003e编译生成的字节码\u003c/mark\u003e\u003c/strong\u003e！\u003c/p\u003e\n\n\u003cp\u003e以上字节码包含了\u003cstrong\u003e\u003cmark\u003e两条 eBPF 指令\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eb7 0 0 0000 00000000    # r0 = 0\n95 0 0 0000 00000000    # exit and return r0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果对 \u003cstrong\u003e\u003cmark\u003eeBPF 汇编语法\u003c/mark\u003e\u003c/strong\u003e不熟悉，可参考：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eiovisor/bpf-docs 中的\u003ca href=\"https://github.com/iovisor/bpf-docs/blob/master/eBPF.md\"\u003e简洁文档\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e更详细的内核文档 \u003ca href=\"https://www.kernel.org/doc/Documentation/networking/filter.txt\"\u003e\u003cmark\u003enetworking/filter.txt\u003c/mark\u003e\u003c/a\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e有了以上基础，接下来看如何开发 eBPF 汇编程序。\u003c/p\u003e\n\n\u003ch1 id=\"3-方式一c-生成-ebpf-汇编--手工修改汇编\"\u003e3 方式一：C 生成 eBPF 汇编 + 手工修改汇编\u003c/h1\u003e\n\n\u003cp\u003e本节需要 Clang/LLVM 6.0+ 版本（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang -v\u003c/code\u003e）。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e译文基于 10.0，结果与原文略有差异。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eC 源码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ebpf.c\nint func\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n\t\u003cspan class=\"k\"\u003ereturn \u003c/span\u003e0\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"31-将-c-编译成-ebpf-汇编clang\"\u003e3.1 将 C 编译成 eBPF 汇编（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e其实前面已经看到了，与将普通 C 程序编译成汇编类似，只是这里指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etarget\u003c/code\u003e 类型是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e\n（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf\u003c/code\u003e target 与默认 target 的不同，见 Cilium 文档 \u003ca href=\"http://docs.cilium.io/en/latest/bpf/#llvm\"\u003eBPF and XDP Reference Guide\u003c/a\u003e ）：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-zh/\"\u003e\u003cmark\u003e(译） Cilium：BPF 和 XDP 参考指南（2021）\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.s bpf.c\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e查看生成的汇编代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ebpf.s\n        .text\n        .file   \u003cspan class=\"s2\"\u003e\u0026#34;bpf.c\u0026#34;\u003c/span\u003e\n        .globl  func                    \u003cspan class=\"c\"\u003e# -- Begin function func\u003c/span\u003e\n        .p2align        3\n        .type   func,@function\nfunc:                                   \u003cspan class=\"c\"\u003e# @func\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# %bb.0:\u003c/span\u003e\n        r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n        \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n.Lfunc_end0:\n        .size   func, .Lfunc_end0-func\n                                        \u003cspan class=\"c\"\u003e# -- End function\u003c/span\u003e\n        .addrsig\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e接下来就可以修改这段汇编代码了。\u003c/p\u003e\n\n\u003ch2 id=\"32-手工修改汇编程序\"\u003e3.2 手工修改汇编程序\u003c/h2\u003e\n\n\u003cp\u003e因为汇编程序是\u003cstrong\u003e\u003cmark\u003e文本文件\u003c/mark\u003e\u003c/strong\u003e，因此编辑起来很容易。\n作为练手，我们在程序最后加上一行汇编指令 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0 = 3\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003ebpf.s\n        .text\n        .file   \u003cspan class=\"s2\"\u003e\u0026#34;bpf.c\u0026#34;\u003c/span\u003e\n        .globl  func                    \u003cspan class=\"c\"\u003e# -- Begin function func\u003c/span\u003e\n        .p2align        3\n        .type   func,@function\nfunc:                                   \u003cspan class=\"c\"\u003e# @func\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# %bb.0:\u003c/span\u003e\n        r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n        \u003cspan class=\"nb\"\u003eexit\n        \u003c/span\u003er0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3                          \u003cspan class=\"c\"\u003e# -- 这行是我们手动加的\u003c/span\u003e\n.Lfunc_end0:\n        .size   func, .Lfunc_end0-func\n                                        \u003cspan class=\"c\"\u003e# -- End function\u003c/span\u003e\n        .addrsig\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这行放在了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eexit\u003c/code\u003e 之后，因此实际上没任何作用。\u003c/p\u003e\n\n\u003ch2 id=\"33-将汇编程序-assemble-成-elf-对象文件llvm-mc\"\u003e3.3 将汇编程序 assemble 成 ELF 对象文件（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-mc\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e接下来将 bpf.s 汇编（assemble）成包含\u003cstrong\u003e\u003cmark\u003e字节码\u003c/mark\u003e\u003c/strong\u003e的 ELF 对象文件。这\n里需要用到 LLVM 自带的与\u003cstrong\u003e\u003cmark\u003e机器码\u003c/mark\u003e\u003c/strong\u003e（machine code，mc）打交道的工具\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-mc\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-mc \u003cspan class=\"nt\"\u003e-triple\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.o bpf.s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ebpf.o 就是生成的 ELF 文件！\u003c/p\u003e\n\n\u003ch2 id=\"34-查看对象文件中的-ebpf-字节码readelf\"\u003e3.4 查看对象文件中的 eBPF 字节码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereadelf\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e查看 bpf.o 中的\u003cstrong\u003e\u003cmark\u003e字节码\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ereadelf \u003cspan class=\"nt\"\u003e-x\u003c/span\u003e .text bpf.o\n\nHex dump of section \u003cspan class=\"s1\"\u003e\u0026#39;.text\u0026#39;\u003c/span\u003e:\n  0x00000000 b7000000 00000000 95000000 00000000 ................\n  0x00000010 b7000000 03000000                   ........\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e看到和之前相比，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e第一行（包含前两条指令）一样，\u003c/li\u003e\n  \u003cli\u003e第二行是新多出来的（对应的正是我们新加的一行汇编指令），作用：将常量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3\u003c/code\u003e load 到寄存器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er0\u003c/code\u003e 中。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e至此，我们已经\u003cstrong\u003e\u003cmark\u003e成功地修改了指令流\u003c/mark\u003e\u003c/strong\u003e。接下来就可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpftool\u003c/code\u003e 之\n类的工具将这个程序加载到内核，任务完成！\u003c/p\u003e\n\n\u003ch2 id=\"35-以更加人类可读的方式查看-ebpf-字节码llvm-objdump--d\"\u003e3.5 以更加人类可读的方式查看 eBPF 字节码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump -d\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003eLLVM 还能以人类可读的方式 dump eBPF 对象文件中的指令，这里就要用到\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# -d           : alias for --disassemble\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# --disassemble: display assembler mnemonics for the machine instructions\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e bpf.o\nbpf.o:  file format ELF64-BPF\n\nDisassembly of section .text:\n\n0000000000000000 func:\n       0:       b7 00 00 00 00 00 00 00 r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n       1:       95 00 00 00 00 00 00 00 \u003cspan class=\"nb\"\u003eexit\n       \u003c/span\u003e2:       b7 00 00 00 03 00 00 00 r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e最后一列显示了\u003cstrong\u003e\u003cmark\u003e对应的 LLVM 使用的汇编指令\u003c/mark\u003e\u003c/strong\u003e（也是前面我们手工编辑时使用的 eBPF 指令）。\u003c/p\u003e\n\n\u003ch2 id=\"36-编译时嵌入调试符号或-c-源码clang--g--llvm-objdump--s\"\u003e3.6 编译时嵌入调试符号或 C 源码（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclang -g\u003c/code\u003e + \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ellvm-objdump -S\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e除了字节码和汇编指令，LLVM 还能将\u003cstrong\u003e\u003cmark\u003e调试信息\u003c/mark\u003e\u003c/strong\u003e（debug symbols）嵌入到对象文件，\n更具体说就是能\u003cstrong\u003e\u003cmark\u003e在字节码旁边同时显示对应的 C 源码\u003c/mark\u003e\u003c/strong\u003e，对调试非常有用，也是\n\u003cstrong\u003e\u003cmark\u003e观察 C 指令如何映射到 eBPF 指令\u003c/mark\u003e\u003c/strong\u003e的好机会。\u003c/p\u003e\n\n\u003cp\u003e在 clang 编译时加上 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-g\u003c/code\u003e 参数：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# -g: generate debug information.\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eclang \u003cspan class=\"nt\"\u003e-target\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-g\u003c/span\u003e \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.s bpf.c\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-mc \u003cspan class=\"nt\"\u003e-triple\u003c/span\u003e bpf \u003cspan class=\"nt\"\u003e-filetype\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eobj \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e bpf.o bpf.s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# -S      : alias for --source\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# --source: display source inlined with disassembly. Implies disassemble object\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e bpf.o\nDisassembly of section .text:\n\n0000000000000000 func:\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e int func\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n       0:       b7 00 00 00 00 00 00 00 r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 0\n\u003cspan class=\"p\"\u003e;\u003c/span\u003e     \u003cspan class=\"k\"\u003ereturn \u003c/span\u003e0\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n       1:       95 00 00 00 00 00 00 00 \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e注意这里\u003cstrong\u003e\u003cmark\u003e用的是 -S（显示源码），不是 -d（反汇编）\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"4-方式二内联汇编inline-assembly\"\u003e4 方式二：内联汇编（inline assembly）\u003c/h1\u003e\n\n\u003cp\u003e接下来看另一种生成和编译 eBPF 汇编的方式：\u003cstrong\u003e\u003cmark\u003e直接在 C 程序中嵌入 eBPF 汇编\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"41-c-内联汇编示例\"\u003e4.1 C 内联汇编示例\u003c/h2\u003e\n\n\u003cp\u003e下面是个非常简单的例子，受 Cilium 文档 \u003ca href=\"http://docs.cilium.io/en/latest/bpf/#llvm\"\u003eBPF and XDP Reference Guide\u003c/a\u003e 的启发：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"/blog/cilium-bpf-xdp-reference-guide-zh/\"\u003e\u003cmark\u003e(译） Cilium：BPF 和 XDP 参考指南（2021）\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003einline_asm.c\nint func\u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    unsigned long long foobar \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2, r3 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3, \u003cspan class=\"k\"\u003e*\u003c/span\u003efoobar_addr \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u0026amp;foobar\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    asm volatile\u003cspan class=\"o\"\u003e(\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;lock *(u64 *)(%0+0) += %1\u0026#34;\u003c/span\u003e : // 等价于：foobar +\u003cspan class=\"o\"\u003e=\u003c/span\u003e r3\n         \u003cspan class=\"s2\"\u003e\u0026#34;=r\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003efoobar_addr\u003cspan class=\"o\"\u003e)\u003c/span\u003e :\n         \u003cspan class=\"s2\"\u003e\u0026#34;r\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003er3\u003cspan class=\"o\"\u003e)\u003c/span\u003e, \u003cspan class=\"s2\"\u003e\u0026#34;0\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003efoobar_addr\u003cspan class=\"o\"\u003e))\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn \u003c/span\u003efoobar\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e关键字\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003easm\u003c/code\u003e 用于插入汇编代码。\u003c/p\u003e\n\n\u003ch2 id=\"42-编译及查看生成的字节码\"\u003e4.2 编译及查看生成的字节码\u003c/h2\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ clang -target bpf -Wall -O2 -c inline_asm.c -o inline_asm.o\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e反汇编：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ellvm-objdump \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e inline_asm.o\nDisassembly of section .text:\n\n0000000000000000 func:\n       0:       b7 01 00 00 02 00 00 00 r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 2\n       1:       7b 1a f8 ff 00 00 00 00 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 - 8\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n       2:       b7 01 00 00 03 00 00 00 r1 \u003cspan class=\"o\"\u003e=\u003c/span\u003e 3\n       3:       bf a2 00 00 00 00 00 00 r2 \u003cspan class=\"o\"\u003e=\u003c/span\u003e r10\n       4:       07 02 00 00 f8 ff ff ff r2 +\u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nt\"\u003e-8\u003c/span\u003e\n       5:       db 12 00 00 00 00 00 00 lock \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er2 + 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e +\u003cspan class=\"o\"\u003e=\u003c/span\u003e r1\n       6:       79 a0 f8 ff 00 00 00 00 r0 \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eu64 \u003cspan class=\"k\"\u003e*\u003c/span\u003e\u003cspan class=\"o\"\u003e)(\u003c/span\u003er10 - 8\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n       7:       95 00 00 00 00 00 00 00 \u003cspan class=\"nb\"\u003eexit\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对应到最后一列的汇编，大家应该大致能看懂。\u003c/p\u003e\n\n\u003ch2 id=\"43-小结\"\u003e4.3 小结\u003c/h2\u003e\n\n\u003cp\u003e这种方式的好处是：源码仍然是 C，因此\u003cstrong\u003e\u003cmark\u003e无需像前一种方式那样必须手动执行编译（\ncompile）和汇编（assemble）两个分开的过程\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"5-结束语\"\u003e5 结束语\u003c/h1\u003e\n\n\u003cp\u003e本文通过两个极简的例子展示了两种 eBPF 汇编编程方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e手动生成并修改一段特定的指令流\u003c/li\u003e\n  \u003cli\u003e在 C 中插入内联汇编\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这两种方式我认为都是有用的，比如在 Netronome，我们经常用前一种方式做单元测试，\n检查 nfp 驱动中的 eBPF hw offload 特性。\u003c/p\u003e\n\n\u003cp\u003eLLVM 支持编写任意的 eBPF 汇编程序（但提醒一下：编译能通过是一回事，能不能通过校验器是另一回事）。\n有兴趣自己试试吧！\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/xdp-paper-acm-2018-zh/\"\u003e\u003cspan\u003e« [译] [论文] XDP (eXpress Data Path)：在操作系统内核中实现快速、可编程包处理（ACM，2018）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/linux-socket-filtering-aka-bpf-zh/\"\u003e\u003cspan\u003e[译] Linux Socket Filtering (LSF, aka BPF)（KernelDoc，2021） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-08-15T00:00:00Z",
  "Author": "Arthur Chiao"
}