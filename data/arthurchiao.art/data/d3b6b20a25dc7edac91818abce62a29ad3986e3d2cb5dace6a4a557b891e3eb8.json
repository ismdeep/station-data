{
  "Source": "arthurchiao.art",
  "Title": "[译] 为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）",
  "Link": "https://arthurchiao.art/blog/advanced-bpf-kernel-features-for-container-age-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-02-13 | Last Update 2021-02-13\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2021 年 Daniel Borkmann 在 FOSDEM 的一篇分享：\n\u003ca href=\"https://fosdem.org/2021/schedule/event/containers_ebpf_kernel/\"\u003eAdvanced eBPF kernel features for the container age\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e内容是 2019 和 2020 两次 LPC 大会分享的延续，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-scale-k8s-service-with-bpf-zh/\"\u003e利用 eBPF 支撑大规模 K8s Service (LPC, 2019)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-k8s-service-lb-zh/\"\u003e基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e翻译已获得 Daniel 授权。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-纠正一些关于-ebpf-的错误理解\" id=\"markdown-toc-1-纠正一些关于-ebpf-的错误理解\"\u003e1 纠正一些关于 eBPF 的错误理解\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-ebpf-是什么通用目的引擎最小指令集架构\" id=\"markdown-toc-11-ebpf-是什么通用目的引擎最小指令集架构\"\u003e1.1 eBPF 是什么？通用目的引擎、最小指令集架构\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-ebpf-不是什么通用目的虚拟机全功能通用指令集\" id=\"markdown-toc-12-ebpf-不是什么通用目的虚拟机全功能通用指令集\"\u003e1.2 eBPF 不是什么？通用目的虚拟机、全功能通用指令集\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-ebpf-与-c\" id=\"markdown-toc-13-ebpf-与-c\"\u003e1.3 eBPF 与 C\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-基于-ebpf-的云原生项目cilium-简介\" id=\"markdown-toc-2-基于-ebpf-的云原生项目cilium-简介\"\u003e2 基于 eBPF 的云原生项目：Cilium 简介\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-网络功能\" id=\"markdown-toc-21-网络功能\"\u003e2.1 网络功能\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-负载均衡\" id=\"markdown-toc-22-负载均衡\"\u003e2.2 负载均衡\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-网络安全\" id=\"markdown-toc-23-网络安全\"\u003e2.3 网络安全\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-可观测性\" id=\"markdown-toc-24-可观测性\"\u003e2.4 可观测性\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#25-servicemesh\" id=\"markdown-toc-25-servicemesh\"\u003e2.5 Servicemesh\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#26-小结\" id=\"markdown-toc-26-小结\"\u003e2.6 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-深入剖析一基于-bpfxdpmaglev-实现-k8s-service-负载均衡\" id=\"markdown-toc-3-深入剖析一基于-bpfxdpmaglev-实现-k8s-service-负载均衡\"\u003e3 深入剖析（一）：基于 BPF/XDP/Maglev 实现 K8s Service 负载均衡\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-原理\" id=\"markdown-toc-31-原理\"\u003e3.1 原理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-转发性能对比xdp-vs-dpdk\" id=\"markdown-toc-32-转发性能对比xdp-vs-dpdk\"\u003e3.2 转发性能对比（XDP vs DPDK）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-source-ip-处理snatdsr\" id=\"markdown-toc-32-source-ip-处理snatdsr\"\u003e3.2 Source IP 处理：SNAT/DSR\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#snat\" id=\"markdown-toc-snat\"\u003eSNAT\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#dsr\" id=\"markdown-toc-dsr\"\u003eDSR\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-destination-ip-处理--maglev-负载均衡\" id=\"markdown-toc-33-destination-ip-处理--maglev-负载均衡\"\u003e3.3 Destination IP 处理 —— Maglev 负载均衡\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-内核-ebpf-改动\" id=\"markdown-toc-34-内核-ebpf-改动\"\u003e3.4 内核 eBPF 改动\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-深入剖析二基于-bpf-的低延迟转发路径fast-path\" id=\"markdown-toc-4-深入剖析二基于-bpf-的低延迟转发路径fast-path\"\u003e4 深入剖析（二）：基于 BPF 的低延迟转发路径（fast-path）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-进出宿主机的容器流量host---pod\" id=\"markdown-toc-41-进出宿主机的容器流量host---pod\"\u003e4.1 进出宿主机的容器流量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost \u0026lt;-\u0026gt; pod\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-同宿主机的容器流量pod---pod\" id=\"markdown-toc-42-同宿主机的容器流量pod---pod\"\u003e4.2 同宿主机的容器流量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epod \u0026lt;-\u0026gt; pod\u003c/code\u003e）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-内核-ebpf-改动\" id=\"markdown-toc-43-内核-ebpf-改动\"\u003e4.3 内核 eBPF 改动\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-性能对比\" id=\"markdown-toc-44-性能对比\"\u003e4.4 性能对比\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-深入剖析三基于-bpf-实现-pod-限速rate-limiting\" id=\"markdown-toc-5-深入剖析三基于-bpf-实现-pod-限速rate-limiting\"\u003e5 深入剖析（三）：基于 BPF 实现 pod 限速（rate-limiting）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-传统方式\" id=\"markdown-toc-51-传统方式\"\u003e5.1 传统方式\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-cilium-方式bpf-edt\" id=\"markdown-toc-52-cilium-方式bpf-edt\"\u003e5.2 Cilium 方式：BPF EDT\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-性能对比\" id=\"markdown-toc-53-性能对比\"\u003e5.3 性能对比\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-总结\" id=\"markdown-toc-6-总结\"\u003e6 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#译文参考链接扩展阅读\" id=\"markdown-toc-译文参考链接扩展阅读\"\u003e译文参考链接（扩展阅读）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e我来自 Isovalent（Cilium 背后的公司），是内核 \u003cstrong\u003eeBPF 的维护者之一\u003c/strong\u003e（co-maintainer）。\n今天给大家分享一些 Cilium（1.9）和 eBPF 的最新进展。\u003c/p\u003e\n\n\u003ch1 id=\"1-纠正一些关于-ebpf-的错误理解\"\u003e1 纠正一些关于 eBPF 的错误理解\u003c/h1\u003e\n\n\u003cp\u003e首先我想纠正一些关于 eBPF 的错误理解与不实描述。\u003c/p\u003e\n\n\u003ch2 id=\"11-ebpf-是什么通用目的引擎最小指令集架构\"\u003e1.1 eBPF 是什么？通用目的引擎、最小指令集架构\u003c/h2\u003e\n\n\u003cp\u003e之前我们讨论 eBPF 时大都集中在\u003cstrong\u003e网络\u003c/strong\u003e（networking）和\u003cstrong\u003e跟踪\u003c/strong\u003e（tracing）领域，\n最近可能将范围扩大到了\u003cstrong\u003e安全\u003c/strong\u003e（security）领域 —— 但我想说的是：eBPF 是一个\n\u003cstrong\u003e通用目的执行引擎\u003c/strong\u003e（general purpose execution engine）。\u003c/p\u003e\n\n\u003cp\u003e换句话说，eBPF 是一个\u003cstrong\u003e最小指令集架构\u003c/strong\u003e（a minimal instruction set\narchitecture），在设计时\u003cstrong\u003e两个主要考虑\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e将 eBPF 指令映射到平台原生指令时开销尽可能小\u003c/mark\u003e —— 尤其是 x86-64 和\narm64 平台，因此我们针对这两种架构进行了很多优化，使程序运行地尽可能快。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cmark\u003e内核在加载 eBPF 代码时要能验证代码的安全性\u003c/mark\u003e —— 这也是为什么我们一\n直将其限制为一个最小指令集，因为这样才能确保它是可验证的（进而是安全的）。\u003c/p\u003e\n\n    \u003cp\u003e很多人像我一样，在过去很长时间都在开发\u003cstrong\u003e内核模块\u003c/strong\u003e（kernel module）。\n 但\u003cstrong\u003e内核模块中引入 bug 是一件极度危险的事情 —— 它会导致内核 crash\u003c/strong\u003e。\n 此时 \u003cstrong\u003eBPF 的优势\u003c/strong\u003e就体现出来了：校验器（verifier）会检查是否有越界内存访问\n 、无限循环等问题，一旦发现就会拒绝加载，而非将这些问题留到运行时（导致\n 内核 crash 等破坏系统稳定性的行为）。\u003c/p\u003e\n\n    \u003cp\u003e所以出于安全方面的原因，很多内核开发者开始用 eBPF 编写程序，而不再使用传统的内核模块方式。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eeBPF 提供的是基本功能模块（building blocks）和程序附着点（attachment points）。\n我们可以编写 eBPF 程序来 attach 到这些 hook 点完成某些高级功能。\u003c/p\u003e\n\n\u003ch2 id=\"12-ebpf-不是什么通用目的虚拟机全功能通用指令集\"\u003e1.2 eBPF 不是什么？通用目的虚拟机、全功能通用指令集\u003c/h2\u003e\n\n\u003cp\u003eBPF 是一个\u003cstrong\u003e通用目的虚拟机\u003c/strong\u003e（general purpose virtual machine）吗？\n这是人们经常问的一个问题。不是 —— \u003cmark\u003eBPF 并不打算模拟完整的计算机\u003c/mark\u003e，它只是一个最小指令集和通用目的执行引擎。\u003c/p\u003e\n\n\u003cp\u003eBPF 是一个\u003cstrong\u003e全功能通用指令集\u003c/strong\u003e吗？也不是。它必须保持最小，这样才能保证可验证和安全。\u003c/p\u003e\n\n\u003ch2 id=\"13-ebpf-与-c\"\u003e1.3 eBPF 与 C\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eBPF 在设计上\u003cmark\u003e有意采用了 C 调用约定\u003c/mark\u003e（calling convention）。\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e由于内核是用 C 写的\u003c/strong\u003e，BPF 要与内核\u003cstrong\u003e\u003cmark\u003e高效\u003c/mark\u003e\u003c/strong\u003e地交互，因此也采用了 C。\n  当需要从 BPF 程序中调用所谓的 BPF helper 甚至是真正的内核函数时，这会非常方\n  便；另外，用户态和内核态之间共享数据（BPF maps）必须越快越好。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e目前 ~150 BPF helpers，~30 BPF maps。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eBPF C 与普通 C 差异有多大？\u003c/p\u003e\n\n    \u003cp\u003eBPF 校验器可能最清楚地见证了近几年 BPF C 的发展历史。\n  现在我们有了 BPF-to-BPF 函数调用、有限循环（bounded loops）、全局变量、静态\n  链接（static linking）、\u003cmark\u003eBTF\u003c/mark\u003e（BPF Type Format，在 \u003cstrong\u003etracing 场景\u003c/strong\u003e尤其有用；其\n  他方面也有用到，\u003cmark\u003e使内核成为可自描述的\u003c/mark\u003e self-descriptive）、\n  \u003cmark\u003e单个 BPF 程序的最大指令数\u003c/mark\u003e（instructions/program）从原来的 4096\n  条放大到了 \u003cmark\u003e100 万条\u003c/mark\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上可以看到，BPF 已经具备了很多的基础模块和功能。基于这项功能，我们能解决许多更\n加有趣的生产问题。其中之一 —— 也是我接下来想讨论的 —— 就是 Cilium。\n我们来看它是如何使用 eBPF 以及用来解决什么问题的。\u003c/p\u003e\n\n\u003ch1 id=\"2-基于-ebpf-的云原生项目cilium-简介\"\u003e2 基于 eBPF 的云原生项目：Cilium 简介\u003c/h1\u003e\n\n\u003cp\u003eCilium 是一个基于 eBPF 技术的云原生网络、安全和可观测项目。下面简单列举一些特性。\u003c/p\u003e\n\n\u003ch2 id=\"21-网络功能\"\u003e2.1 网络功能\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e通过 CNI 集成到 Kubernetes。\u003c/li\u003e\n  \u003cli\u003e基于 BPF 实现了 Pod-to-Pod \u003cstrong\u003e数据转发路径\u003c/strong\u003e（datapath）。\u003c/li\u003e\n  \u003cli\u003e支持\u003cstrong\u003e直接路由\u003c/strong\u003e（direct routing）、overlay、\u003cstrong\u003ecloud-provider native\u003c/strong\u003e（例如 AWS）等网\n络模式。\u003c/li\u003e\n  \u003cli\u003e支持 IPv4、IPv6、NAT46。\u003c/li\u003e\n  \u003cli\u003e支持\u003cstrong\u003e多集群路由\u003c/strong\u003e（multi-cluster routing）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多信息，可参考 [3,4,5,6]。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"22-负载均衡\"\u003e2.2 负载均衡\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e实现了\u003cstrong\u003e高度可扩展的 L3-L4（XDP）负载均衡\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e能完全替代 kube-proxy，提供 K8s Service 功能。\u003c/li\u003e\n  \u003cli\u003e支持\u003cstrong\u003e多集群\u003c/strong\u003e（multi-cluster）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e详见 [1,2]，译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"23-网络安全\"\u003e2.3 网络安全\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e支持\u003cstrong\u003e基于身份的（identity-based）L3-L7 网络安全\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003eAPI-aware 安全（HTTP、gRPC 等）\u003c/li\u003e\n  \u003cli\u003eDNS-aware\u003c/li\u003e\n  \u003cli\u003e透明加密\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"24-可观测性\"\u003e2.4 可观测性\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003eMetrics：通过 BPF 收集观测数据和 tracing 数据并导出；包含网络、DNS、安全、延迟、HTTP 等方面的数据。\u003c/li\u003e\n  \u003cli\u003e提供 flow 级别的日志（flow log），并支持设置聚合粒度（datapath aggregation）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"25-servicemesh\"\u003e2.5 Servicemesh\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e注入 sidecar 时开销最小（minimized overhead）。\u003c/li\u003e\n  \u003cli\u003e与 Istio 集成。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e用到了sockmap/redirection 做 socket 重定向，可参考 [7]，译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"26-小结\"\u003e2.6 小结\u003c/h2\u003e\n\n\u003cp\u003e接下来介绍几个最近的新特性（我们在 Cilium 1.9 及内核方面的最新工作）。\u003c/p\u003e\n\n\u003ch1 id=\"3-深入剖析一基于-bpfxdpmaglev-实现-k8s-service-负载均衡\"\u003e3 深入剖析（一）：基于 BPF/XDP/Maglev 实现 K8s Service 负载均衡\u003c/h1\u003e\n\n\u003cp\u003e首先看基于 XDP/BPF 和 Maglev 算法实现的 K8s Service 负载均衡。\u003c/p\u003e\n\n\u003ch2 id=\"31-原理\"\u003e3.1 原理\u003c/h2\u003e\n\n\u003cp\u003eK8s Service 模型中，入口和后端实例位于同一组节点，即\u003cstrong\u003e每个节点既用于部署容器，\n又负责 Service 负载均衡的实现\u003c/strong\u003e（\u003cmark\u003eco-location of service\nload balancer with regular user workloads on every node\u003c/mark\u003e）的。换句话说，每个\nnode 上都实现了 Service 负载均衡的功能。在原生 K8s 中，实现这个功能的组件是 kube-proxy。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eService 是对\u003cstrong\u003e服务\u003c/strong\u003e的抽象，服务包含一个入口和多个后端实例，因此涉及到负载均衡\n，即如何将请求分发到不同后端。但在模型及实现上，入口（负载均衡器）和后端实例\n可以是分开部署的（例如负载均衡器部署在独立设备上），也可以部署在一起（负载均\n衡器直接部署在运行实例的宿主机上）。\n更多关于 kube-proxy 的设计及实现，可参考 [8]。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e但 kube-proxy 的问题之一是性能很差。Cilium 所做的一项工作就是\u003cstrong\u003e基于 BPF/XDP 实现了\nkube-proxy 的功能\u003c/strong\u003e（针对南北向流量），显著减少了 CPU 使用量，并达到（某些场景甚至\n超过了）DPDK 的性能。\u003c/p\u003e\n\n\u003cp\u003eXDP 运行在网络驱动层，因此能\u003cstrong\u003e直接在驱动层将收到的包再发出去\u003c/strong\u003e，\n这是软件栈中\u003cmark\u003e最早能够处理数据包的位置\u003c/mark\u003e（此时 skb 都还没有创建），因此性能非常高。\u003c/p\u003e\n\n\u003ch2 id=\"32-转发性能对比xdp-vs-dpdk\"\u003e3.2 转发性能对比（XDP vs DPDK）\u003c/h2\u003e\n\n\u003cp\u003e以下测试结果基于 Cilium 1.9 及原生 Linux 内核中的 XDP 驱动。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/xdp-vs-dpdk.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e这里测试的是后端 pod 在另一台 node 的场景。三条线分别表示：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eDPDK (different NIC): DPDK 从一个网卡收包，然后将包从\u003cstrong\u003e另一个网卡\u003c/strong\u003e发出去。\u003c/li\u003e\n  \u003cli\u003eXDP (different NIC): Cilium/XDP 从一个网卡收包，然后将包从\u003cstrong\u003e另一个网卡\u003c/strong\u003e发出去。\u003c/li\u003e\n  \u003cli\u003eXDP (same NIC): Cilium/XDP 从一个网卡收包，然后直接将包从\u003cstrong\u003e当前网卡\u003c/strong\u003e发出去。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e可以看出，XDP (different NIC) 的性能已经接近 DPDK；但 \u003cstrong\u003esame NIC 组，四核\n及以上的性能已经远超过 DPDK\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e再看 CPU 消耗：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/xdp-vs-dpdk-2.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eDPDK 是 busy-poll 模型，因此 CPU 一直是 100%，即需要独占一个或多个 CPU。\u003c/li\u003e\n  \u003cli\u003e相比之下，XDP 的 CPU 消耗基本上是线性的，远小于 DPDK 的消耗。\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e图中还给出了 Linux kernel 收发包的 CPU 消耗作为 benchmark\u003c/mark\u003e。可以\n看到在 5Mpps 时它就已经饱和了，转发性能无法进一步提高。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-source-ip-处理snatdsr\"\u003e3.2 Source IP 处理：SNAT/DSR\u003c/h2\u003e\n\n\u003cp\u003e简要重温 Service LB 的 NAT/DSR 模式。\u003c/p\u003e\n\n\u003cp\u003e假设 Service 请求到达了 node1，而这个 Service 的 backend pod 在 node2。\u003c/p\u003e\n\n\u003ch3 id=\"snat\"\u003eSNAT\u003c/h3\u003e\n\n\u003cp\u003e这种模式下，node1 \u003cstrong\u003e对源 IP 地址（Source IP）的处理\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e请求：做源地址转换（SNAT）\u003c/li\u003e\n  \u003cli\u003e响应：对源地址做反向转换（rev-SNAT）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/nat.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e响应包需要先回到 node1，再回到客户端。来回路径是相同的。\u003c/p\u003e\n\n\u003ch3 id=\"dsr\"\u003eDSR\u003c/h3\u003e\n\n\u003cp\u003e这种模式下，node1 不需要做 SNAT：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/dsr.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e响应包也无需回到 node1，而是直接从 node2 回到客户端\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e详见 [2,10]，译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"33-destination-ip-处理--maglev-负载均衡\"\u003e3.3 Destination IP 处理 —— Maglev 负载均衡\u003c/h2\u003e\n\n\u003cp\u003e上面小节讨论的是对源 IP 地址的处理，接下来看对目的 IP 地址的处理，即，如何选择后\n端 pod。\u003c/p\u003e\n\n\u003cp\u003ekube-proxy \u003cmark\u003e选择后端 pod 时都是随机的\u003c/mark\u003e（select a random backend）。\n\u003cstrong\u003eCilium 1.9 之前也是这个行为\u003c/strong\u003e，并将这个状态存储到本节点的 BPF conntrack table。\u003c/p\u003e\n\u003cblockquote\u003e\n  \u003cp\u003econntrack，连接跟踪，可参考 [9]，译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e但这里存在一个问题是，如下图所示，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/lb-2.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e当负责处理某个 Service 的 node 挂掉时，这个连接\u003cmark\u003e接下来的包会被转发到另一个 node\u003c/mark\u003e\n （例如通过 ECMP）—— \u003cstrong\u003e此时还没有问题\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e但\u003cmark\u003e新 node 没有之前的 service -\u0026gt; backend1 上下文信息\u003c/mark\u003e（因为这些信息\n  只存在于 node1 的 conntrack table），因此\u003cmark\u003e会随机再选择一个 backend\u003c/mark\u003e，\n  假设这里选择了 backend2，然后\u003cmark\u003e建立新的映射 service -\u0026gt; backdend2\u003c/mark\u003e，并将包转\n  发过去 —— \u003cstrong\u003e这里也没问题，能发送过去\u003c/strong\u003e，但接下来 ——\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003e包到达 backend2 时会被拒绝\u003c/mark\u003e，因为 backend2 上并不存在这条连接。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e总结起来就是：\u003cmark\u003e一旦 node 挂掉，所有经过这台 node 的 Service 连接会全部中断\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cp\u003e为了解决这个问题，我们在 1.9 中引入了一致性哈希：在 Cilium 中实现了 \u003cstrong\u003eGoogle\nMaglev 一致性哈希算法\u003c/strong\u003e，用于 BPF/XDP Service 负载均衡。简单来说，\n\u003cmark\u003e对于同一条 Service 连接，该算法能保证哈希到相同的后端\u003c/mark\u003e。因此一台 node 挂掉后\n，只要接下来的包能到达其他 node，该 node 就能保证将包转发到原\n来的 backend pod，因此\u003cstrong\u003e连接不会中断\u003c/strong\u003e，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/lb-3.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在实现上，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e相比随机方式，这种算法\u003cmark\u003e需要使用更多的内存\u003c/mark\u003e；为了提高内存使用效率，\n使用了\u003cmark\u003e动态大小的 map-in-map 数据结构\u003c/mark\u003e：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003e外层\u003c/strong\u003e：service map\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e内层\u003c/strong\u003e：per-service maglev map\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e根据 tuple 信息做两级查找：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e第一次查全局的 service map\u003c/li\u003e\n      \u003cli\u003e然后再查找 per-service 的 Maglev map，这个表是\u003cstrong\u003e由用户态的 cilium-agent 来操作和更新\u003c/strong\u003e的。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"34-内核-ebpf-改动\"\u003e3.4 内核 eBPF 改动\u003c/h2\u003e\n\n\u003cp\u003e为实现以上功能，我们\u003cmark\u003e对内核 eBPF 的 map-in-map 做了增强，允许内层 map 的大小是动态的\u003c/mark\u003e，\n见 \u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4a8f87e60f6d\"\u003ebpf: Allow for map-in-map with dynamic inner array map entries\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e如果没有这个扩展，那内层 map 只能是固定大小，而很多 Service 可能只有少量后端，\n导致 map 的大部分空间都是用不到的，非常浪费内存。\u003c/p\u003e\n\n\u003ch1 id=\"4-深入剖析二基于-bpf-的低延迟转发路径fast-path\"\u003e4 深入剖析（二）：基于 BPF 的低延迟转发路径（fast-path）\u003c/h1\u003e\n\n\u003cp\u003e这里主要是介绍绕过宿主机内核协议栈，直接将包从网卡或容器 redirect 到另一个端（容器或网卡）。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这些内容在去年的分享中有更详细介绍，见\n\u003ca href=\"/blog/cilium-k8s-service-lb-zh/\"\u003e基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"41-进出宿主机的容器流量host---pod\"\u003e4.1 进出宿主机的容器流量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehost \u0026lt;-\u0026gt; pod\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e原来需要穿越宿主机的内核协议栈：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-1.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e现在绕过了宿主机内核协议栈，直接将包从网卡重定向到容器网络设备：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-2.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"42-同宿主机的容器流量pod---pod\"\u003e4.2 同宿主机的容器流量（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epod \u0026lt;-\u0026gt; pod\u003c/code\u003e）\u003c/h2\u003e\n\n\u003cp\u003e与前面类似，绕过宿主机内核协议栈，直接重定向：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-3.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"43-内核-ebpf-改动\"\u003e4.3 内核 eBPF 改动\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/torvalds/c/9aa1206e8f48\"\u003ebpf: Add redirect_peer helper\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/torvalds/c/b4ab31414970\"\u003ebpf: Add redirect_neigh helper as redirect drop-in\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"44-性能对比\"\u003e4.4 性能对比\u003c/h2\u003e\n\n\u003cp\u003e用 netperf 做了一些性能测试。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-performance-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTCP_SENDFILE 性能，三组测试：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003enode-to-node 转发性能：作为 benchmark 参考。\u003c/li\u003e\n  \u003cli\u003epod-to-remote-pod，没有使用 fast-path：传统的经过宿主机内核协议栈方式。\u003c/li\u003e\n  \u003cli\u003epod-to-remote-pod，使用 fast-path：可以看到\u003cstrong\u003e\u003cmark\u003e几乎达到了 node-to-node 性能 —— 理论上的最高性能\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTCP_RR 测试（ping-pong）也是类似的结果：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/fast-path-performance-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"5-深入剖析三基于-bpf-实现-pod-限速rate-limiting\"\u003e5 深入剖析（三）：基于 BPF 实现 pod 限速（rate-limiting）\u003c/h1\u003e\n\n\u003cp\u003e这个功能也是在最新的 Cilium 1.9 中实现的。\u003c/p\u003e\n\n\u003ch2 id=\"51-传统方式\"\u003e5.1 传统方式\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e传统的 pod 限速方式\u003c/strong\u003e：加一个 CNI 插件，\u003cmark\u003e通过 CNI chaining 给容器设置 TBF qdisc\u003c/mark\u003e。\n甚至还会为了 ingress shaping 设置所谓的 ifb（Intermediate Functional Block）设备。可扩展性差。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eTBF、HTB、MQ、FQ 等 tc qdisc 信息，可参考 [11]。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种方式存在很多问题：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e效率不高，因为通常情况下这都会涉及到多队列设备（multi-queue devices），\n\u003cstrong\u003e需要竞争 qdisc 锁\u003c/strong\u003e，不是一种无锁方式。\u003c/li\u003e\n  \u003cli\u003e通过 ifb 设备来做整形（shaping）也不是合适，因为它占用了很多的资源来做 ingress\n整形，效果却不怎么样。整形都应该是在出向做的。\u003c/li\u003e\n  \u003cli\u003e整体上这种方式并不是可扩展的。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"52-cilium-方式bpf-edt\"\u003e5.2 Cilium 方式：BPF EDT\u003c/h2\u003e\n\n\u003cp\u003e在 Cilium 中，我们基于 multi-queue 和 BPF，实现了一种称为 \u003cmark\u003eEarlist Departure Time\u003c/mark\u003e（EDT，最早离开时间）\n的\u003cmark\u003e无锁（lockless）方式来对 pod 进行限速\u003c/mark\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e关于 lockless，可参考下面的 patch。译注。\u003c/p\u003e\n\n  \u003cp\u003eauthor  Daniel Borkmann 2016-01-07 22:29:47 +0100\u003c/p\u003e\n\n  \u003cp\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=1f211a1b929c804100e138c5d3d656992cfd5622\"\u003enet, sched: add clsact qdisc\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003eThis work adds a generalization of the ingress qdisc as a qdisc holding\nonly classifiers. The clsact qdisc works on ingress, but also on egress.\nIn both cases, it’s execution happens without taking the qdisc lock, …\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e工作原理如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/rate-limit.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 K8s 里\u003cstrong\u003e为 pod 设置限速带宽\u003c/strong\u003e：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubernetes.io/egress-bandwidth: \u0026#34;50M\u0026#34;\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003eCilium agent 生成 BPF 程序。\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003eBPF 对流量进行分类\u003c/mark\u003e，根据用户定义的限速带宽，\u003cmark\u003e为每个包设置一个离开时间\u003c/mark\u003e（\ndeparture time），其实就是一个时间戳 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e。\u003c/li\u003e\n  \u003cli\u003e在物理设备上设置 FQ qdisc，\u003cstrong\u003e\u003cmark\u003eFQ qdisc 会根据这个时间戳对包进行调度\u003c/mark\u003e\u003c/strong\u003e。保证不会早于这个时间戳将包发送出去。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"53-性能对比\"\u003e5.3 性能对比\u003c/h2\u003e\n\n\u003cp\u003e下面是基于一些生产流量所做的测试，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/advanced-bpf-kernel-features-for-container-age/rate-limit-performance.png\" width=\"65%\" height=\"65%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e左边是传统方式 HTB，右边是 Cilium 方式 BPF+FQ，Y 轴是取了对数（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elog\u003c/code\u003e）的。总结：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cmark\u003ep99：延迟降低了 10x\u003c/mark\u003e\u003c/li\u003e\n  \u003cli\u003e\u003cmark\u003ep95：延迟降低了 20x\u003c/mark\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"6-总结\"\u003e6 总结\u003c/h1\u003e\n\n\u003cp\u003e与其他内核子系统不同，BPF 在内核中的位置非常特殊，因此能极其高效地解决一些复杂的生产问题。\n而\u003cstrong\u003e其他任何内核子系统，都无法只依靠自身解决这些问题\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e这次分享的主要是网络方面，但其实 BPF 也已经在跟踪、安全等领域大展拳脚，而且\n还有更多更多的可能性正在被发掘。此外，我仍然觉得 \u003cmark\u003eBPF 才刚刚开始\u003c/mark\u003e（\nfeels it’s at the very beginning）。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCilium 以 BPF 为核心，将这项技术带入了主流的 Kubernetes 社区\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e推荐阅读：\u003ca href=\"/blog/ebpf-and-k8s-zh/\"\u003e大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）\u003c/a\u003e。译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e另外一件可喜的事情是，GKE（Google Kubernets Engine）已经宣布将 Cilium 作为其下一\n代 dataplane。因此，如果是在 GKE 上创建 K8s 集群，那你已经能原生地使用了 Cilium 了。\u003c/p\u003e\n\n\u003cp\u003e最后，几个链接：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium\"\u003egithub.com/cilium/cilium\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://cilium.io\"\u003ecilium.io\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://ebpf.io\"\u003eebpf.io\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"译文参考链接扩展阅读\"\u003e译文参考链接（扩展阅读）\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-scale-k8s-service-with-bpf-zh/\"\u003e（译）利用 eBPF 支撑大规模 K8s Service (LPC, 2019)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-k8s-service-lb-zh/\"\u003e（译）基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-life-of-a-packet-pod-to-service-zh/\"\u003eLife of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/trip-stepping-into-cloud-native-networking-era-zh/\"\u003e迈入 Cilium+BGP 的云原生网络时代\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-network-topology-on-aws/\"\u003eCilium Network Topology and Traffic Path on AWS\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-clustermesh/\"\u003eCilium ClusterMesh: A Hands-on Guide\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/socket-acceleration-with-ebpf-zh/\"\u003e（译）利用 ebpf sockmap/redirection 提升 socket 性能（2020）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cracking-k8s-node-proxy/\"\u003eCracking kubernetes node proxy (aka kube-proxy)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/conntrack-design-and-implementation-zh/\"\u003e连接跟踪（conntrack）：原理、应用及 Linux 内核实现\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/k8s-l4lb/\"\u003eL4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/lartc-qdisc-zh/\"\u003e（译）《Linux 高级路由与流量控制手册（2012）》第九章：用 tc qdisc 管理 Linux 网络带宽\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/ebpf-and-k8s-zh/\"\u003e（译）大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/socket-acceleration-with-ebpf-zh/\"\u003e\u003cspan\u003e« [译] 利用 ebpf sockmap/redirection 提升 socket 性能（2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/understanding-tc-da-mode-zh/\"\u003e\u003cspan\u003e[译] 深入理解 tc ebpf 的 direct-action (da) 模式（2020） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-02-13T00:00:00Z",
  "Author": "Arthur Chiao"
}