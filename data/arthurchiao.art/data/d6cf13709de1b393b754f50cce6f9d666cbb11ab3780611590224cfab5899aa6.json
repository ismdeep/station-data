{
  "Source": "arthurchiao.art",
  "Title": "Linux Load Average：算法、实现与实用指南（2023）",
  "Link": "https://arthurchiao.art/blog/linux-loadavg-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux Load Average：算法、实现与实用指南（2023）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2023-10-03 | Last Update 2023-10-14\u003c/p\u003e\n  \n  \u003cp\u003e借着遇到的一个问题，研究下 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eloadavg\u003c/code\u003e 的算法和实现。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-一次-load-spike-问题排查\" id=\"markdown-toc-1-一次-load-spike-问题排查\"\u003e1 一次 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload\u003c/code\u003e spike 问题排查\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-现象\" id=\"markdown-toc-11-现象\"\u003e1.1 现象\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-排查\" id=\"markdown-toc-12-排查\"\u003e1.2 排查\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#121-宿主机监控load-和-running-线程数量趋势一致\" id=\"markdown-toc-121-宿主机监控load-和-running-线程数量趋势一致\"\u003e1.2.1 宿主机监控：load 和 running 线程数量趋势一致\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#122-定位到进程pod\" id=\"markdown-toc-122-定位到进程pod\"\u003e1.2.2 定位到进程（Pod）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#123-pod-监控大量线程周期性状态切换\" id=\"markdown-toc-123-pod-监控大量线程周期性状态切换\"\u003e1.2.3 Pod 监控：大量线程周期性状态切换\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#124-交叉验证\" id=\"markdown-toc-124-交叉验证\"\u003e1.2.4 交叉验证\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-进一步排查方向\" id=\"markdown-toc-13-进一步排查方向\"\u003e1.3 进一步排查方向\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-疑问\" id=\"markdown-toc-14-疑问\"\u003e1.4 疑问\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-loadavg算法与内核实现\" id=\"markdown-toc-2-loadavg算法与内核实现\"\u003e2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eloadavg\u003c/code\u003e：算法与内核实现\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-原理与算法\" id=\"markdown-toc-21-原理与算法\"\u003e2.1 原理与算法\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#211-有活跃线程load-指数增长\" id=\"markdown-toc-211-有活跃线程load-指数增长\"\u003e2.1.1 有活跃线程：load 指数增长\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#212-无活跃线程load-指数衰减\" id=\"markdown-toc-212-无活跃线程load-指数衰减\"\u003e2.1.2 无活跃线程：load 指数衰减\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#213-load-测试与小结\" id=\"markdown-toc-213-load-测试与小结\"\u003e2.1.3 Load 测试与小结\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-内核基础\" id=\"markdown-toc-22-内核基础\"\u003e2.2 内核基础\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-运行调度队列-struct-rq\" id=\"markdown-toc-221-运行调度队列-struct-rq\"\u003e2.2.1 运行/调度队列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct rq\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-load-计算相关的全局变量\" id=\"markdown-toc-222-load-计算相关的全局变量\"\u003e2.2.2 Load 计算相关的全局变量\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#223-内核时间基础hztickjiffiesuptime\" id=\"markdown-toc-223-内核时间基础hztickjiffiesuptime\"\u003e2.2.3 内核时间基础：HZ/tick/jiffies/uptime\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-算法实现\" id=\"markdown-toc-23-算法实现\"\u003e2.3 算法实现\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-调用栈\" id=\"markdown-toc-231-调用栈\"\u003e2.3.1 调用栈\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-一些实现细节\" id=\"markdown-toc-232-一些实现细节\"\u003e2.3.2 一些实现细节\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#runqueue-load-字段初始化\" id=\"markdown-toc-runqueue-load-字段初始化\"\u003erunqueue load 字段初始化\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#判断是否由当前-cpu-执行-load-计算\" id=\"markdown-toc-判断是否由当前-cpu-执行-load-计算\"\u003e判断是否由当前 CPU 执行 load 计算\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#do_timer\" id=\"markdown-toc-do_timer\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edo_timer()\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#calc_global_load---calc_load\" id=\"markdown-toc-calc_global_load---calc_load\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecalc_global_load() -\u0026gt; calc_load()\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-考古\" id=\"markdown-toc-24-考古\"\u003e2.4 考古\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#241-计入不可中断-sleep\" id=\"markdown-toc-241-计入不可中断-sleep\"\u003e2.4.1 计入不可中断 sleep\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#242-linux-vs-其他-osloadavg-区别\" id=\"markdown-toc-242-linux-vs-其他-osloadavg-区别\"\u003e2.4.2 Linux vs. 其他 OS：loadavg 区别\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-讨论\" id=\"markdown-toc-3-讨论\"\u003e3 讨论\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-load-很高所有进程都会受影响吗\" id=\"markdown-toc-31-load-很高所有进程都会受影响吗\"\u003e3.1 Load 很高，所有进程都会受影响吗？\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#311-模拟单个-cpu-把系统-load-打高上百倍\" id=\"markdown-toc-311-模拟单个-cpu-把系统-load-打高上百倍\"\u003e3.1.1 模拟：单个 CPU 把系统 load 打高上百倍\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#312-cpuset-vs-cpu-quota\" id=\"markdown-toc-312-cpuset-vs-cpu-quota\"\u003e3.1.2 cpuset vs. cpu quota\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-僵尸进程\" id=\"markdown-toc-32-僵尸进程\"\u003e3.2 僵尸进程\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-load--cpu-利用率\" id=\"markdown-toc-33-load--cpu-利用率\"\u003e3.3 Load \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!=\u003c/code\u003e CPU 利用率\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-load-是否是一个很好的告警指标\" id=\"markdown-toc-34-load-是否是一个很好的告警指标\"\u003e3.4 Load 是否是一个很好的告警指标？\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-实用指南\" id=\"markdown-toc-4-实用指南\"\u003e4 实用指南\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-use-used-frequency-saturation-errors-方法论\" id=\"markdown-toc-41-use-used-frequency-saturation-errors-方法论\"\u003e4.1 USE (Used-frequency, Saturation, Errors) 方法论\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-指标\" id=\"markdown-toc-42-指标\"\u003e4.2 指标\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#421-used-frequency-指标\" id=\"markdown-toc-421-used-frequency-指标\"\u003e4.2.1 Used-frequency 指标\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#422-saturation-指标\" id=\"markdown-toc-422-saturation-指标\"\u003e4.2.2 Saturation 指标\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-结束语\" id=\"markdown-toc-5-结束语\"\u003e5 结束语\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#references\" id=\"markdown-toc-references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e查看一台 Linux 机器在过去一段时间的\u003cstrong\u003e\u003cmark\u003e负载\u003c/mark\u003e\u003c/strong\u003e\n（准确来说是“负载平均”，load average）有很多命令，比如\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etop\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003euptime\u003c/code\u003e、\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eprocinfo\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e、\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ew\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 等等，\n它们底层都是从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprocfs\u003c/code\u003e 读取的数据：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/loadavg\n0.25 0.23 0.14 1/239 1116826\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这是排查 Linux 性能问题时的重要参考指标之一。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eproc\u003c/code\u003e man page 中有关于它的\u003cstrong\u003e\u003cmark\u003e定义\u003c/mark\u003e\u003c/strong\u003e和每一列表示什么的解释：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eman 5 proc\n...\n/proc/loadavg\n    The first three fields \u003cspan class=\"k\"\u003ein \u003c/span\u003ethis file are load average figures giving the number of \u003cspan class=\"nb\"\u003ejobs \u003c/span\u003e\u003cspan class=\"k\"\u003ein \u003c/span\u003ethe run queue \u003cspan class=\"o\"\u003e(\u003c/span\u003estate R\u003cspan class=\"o\"\u003e)\u003c/span\u003e or waiting \u003cspan class=\"k\"\u003efor \u003c/span\u003edisk I/O \u003cspan class=\"o\"\u003e(\u003c/span\u003estate D\u003cspan class=\"o\"\u003e)\u003c/span\u003e averaged over 1, 5, and 15 minutes.  They are the same as the load average numbers given by \u003cspan class=\"nb\"\u003euptime\u003c/span\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003e1\u003cspan class=\"o\"\u003e)\u003c/span\u003e and other programs.\n    The fourth field consists of two numbers separated by a slash \u003cspan class=\"o\"\u003e(\u003c/span\u003e/\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"nb\"\u003e.\u003c/span\u003e  The first of these is the number of currently runnable kernel scheduling entities \u003cspan class=\"o\"\u003e(\u003c/span\u003eprocesses, threads\u003cspan class=\"o\"\u003e)\u003c/span\u003e\u003cspan class=\"nb\"\u003e.\u003c/span\u003e  The value after the slash is the number of kernel scheduling entities that currently exist on the system.\n    The fifth field is the PID of the process that was most recently created on the system.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e前 3 列分别表示这台机器在过去 1、5、15 分内的负载平均，为方便起见，下文分别用\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eload1/load5/load15\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 表示。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload1\u003c/code\u003e 的精度是这三个里面最高的，\n因此本文接下来将主要关注 load1（后面将看到，load5/load15 算法 load1 一样，只是时间尺寸不同）。\u003c/p\u003e\n\n\u003cp\u003e需要注意的是，loadavg 是\u003cstrong\u003e\u003cmark\u003e机器的所有 CPU 上所有任务\u003c/mark\u003e\u003c/strong\u003e的总负载，因此跟机器的 CPU 数量有直接关系。\nCPU 数量不一样的机器，直接比较 loadavg 是没有意义的。为了不同机器之间能够直接对比，\n可以将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload1\u003c/code\u003e \u003cstrong\u003e\u003cmark\u003e除以机器的 CPU 数量\u003c/mark\u003e\u003c/strong\u003e，得到的指标用 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eload1_per_core\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 表示。\u003c/p\u003e\n\n\u003cp\u003e有了 load/loadavg 和 load1_per_core 的概念，接下来看一个具体问题。\u003c/p\u003e\n\n\u003ch1 id=\"1-一次-load-spike-问题排查\"\u003e1 一次 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload\u003c/code\u003e spike 问题排查\u003c/h1\u003e\n\n\u003cp\u003e我们的监控程序会采集每台机器的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload1_per_core\u003c/code\u003e 指标。\n平时排查问题时经常用这个指标作为性能参考。\u003c/p\u003e\n\n\u003ch2 id=\"11-现象\"\u003e1.1 现象\u003c/h2\u003e\n\n\u003cp\u003e为了定位某个问题，我们对部分 k8s node 加了个 load 告警，比如 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eload1_per_core \u0026gt; 1.0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n就告警出来。加上后前几天平安无事，但某天突然收到了一台机器的告警，它的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eload1_per_core\u003c/code\u003e 曲线如下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-loadavg/load-spikes.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Load (loadavg1-per-core) spikes of a k8s node\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对于这些 node，我们预期 load1_per_core 正常不会超过 1，超过 3 就更夸张了；\u003c/li\u003e\n  \u003cli\u003e另外，多个业务的 pod 混部在这台机器，根据之前的经验，load 这么高肯定有业务报障，\n但这次却没有；\u003c/li\u003e\n  \u003cli\u003eLoad spike 非常有规律，预示着比较容易定位直接原因。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e基于以上信息，接下来排查一下。\u003c/p\u003e\n\n\u003ch2 id=\"12-排查\"\u003e1.2 排查\u003c/h2\u003e\n\n\u003ch3 id=\"121-宿主机监控load-和-running-线程数量趋势一致\"\u003e1.2.1 宿主机监控：load 和 running 线程数量趋势一致\u003c/h3\u003e\n\n\u003cp\u003e宿主机基础监控除了 load、cpu、io 等等指标外，我们还采集了系统上的进程/线程、上下文、中断等统计信息。\n快速过了一遍这些看板之后发现，load 变化和 \u003cstrong\u003e\u003cmark\u003enode 上总的 running 状态进程数量\u003c/mark\u003e\u003c/strong\u003e趋势和时间段都一致：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-loadavg/node-load-and-threads.png\" width=\"75%\" height=\"75%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Node load (load1_per_core) and threads on the node\u003c/p\u003e\n\n\u003cp\u003e可以看到 running 进程数量在几十到几百之间剧烈波动。这里的 running 和 blocked 数量采集自：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/stat\n...\nprocs_running 8\nprocs_blocked 1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eLoad 高低和\u003cstrong\u003e\u003cmark\u003e活跃进程数量\u003c/mark\u003e\u003c/strong\u003e及 IO 等因素正相关，\n因此看到这个监控时，我们首先猜测可能是某些主机进程或 pod 进程在周期性\u003cstrong\u003e\u003cmark\u003e创建和销毁大量进程（线程），或者切换进程（线程）状态\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eLinux 调度模块里，实际上是以线程为调度单位（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct se\u003c/code\u003e，schedule entity），并没有进程的概念。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e接下来就是找到这个进程或 pod。\u003c/p\u003e\n\n\u003ch3 id=\"122-定位到进程pod\"\u003e1.2.2 定位到进程（Pod）\u003c/h3\u003e\n\n\u003cp\u003e非常规律的飙升意味着很容易抓现场。登录到 node 先用 top 看了几分钟，\n确认系统 loadavg 会周期性从几十飙升到几百，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etop\n\u003cspan class=\"c\"\u003e#                                                   最近    1      5      15  分钟内的平均总负载\u003c/span\u003e\n\u003cspan class=\"c\"\u003e#                                                           |     |      |\u003c/span\u003e\ntop - 16:03:08 up 114 days, 18:03,  1 user,  load average: 17.01, 79.96, 90.27\nTasks: 1137 total,   1 running, 844 sleeping,   0 stopped,   0 zombie\n%Cpu\u003cspan class=\"o\"\u003e(\u003c/span\u003es\u003cspan class=\"o\"\u003e)\u003c/span\u003e: 23.3 us,  3.5 sy,  0.0 ni, 72.8 \u003cspan class=\"nb\"\u003eid\u003c/span\u003e,  0.0 wa,  0.0 hi,  0.4 si,  0.0 st\n...\n   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND \u003cspan class=\"c\"\u003e# \u0026lt;-- 进程详情列表\u003c/span\u003e\n719488 1004      20   0   36.8g   8.5g  35896 S 786.6  3.4  19332:17 java\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e再结合进程详情列表和 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e%CPU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 这一列，很容易确定是哪个进程（PID）引起的，\n进而可以根据 PID 找到 Pod。\u003c/p\u003e\n\n\u003ch3 id=\"123-pod-监控大量线程周期性状态切换\"\u003e1.2.3 Pod 监控：大量线程周期性状态切换\u003c/h3\u003e\n\n\u003cp\u003e找到是哪个 Pod 之后，再跳转到 Pod 监控页面。\n我们的监控项中，有一项是 pod 内的任务（线程）数量：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-loadavg/pod-tasks-by-state-1.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Task states of the specific Pod\u003c/p\u003e\n\n\u003cp\u003e这是在容器内收集的各种状态的线程数量。\u003cstrong\u003e\u003cmark\u003e时间及趋势都和 node 对得上\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e再把时间范围拉短了看一下，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-loadavg/pod-tasks-by-state-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Task states of the specific Pod\u003c/p\u003e\n\n\u003cp\u003erunning 线程增多时 sleeping 减少，running 减少时 sleeping 增多，数量对得上。\n所以像是 \u003cstrong\u003e\u003cmark\u003e600 来个线程不断在 sleeping/running 状态切换\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"124-交叉验证\"\u003e1.2.4 交叉验证\u003c/h3\u003e\n\n\u003cp\u003e计算 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eloadavg\u003c/code\u003e 会用到 Running 和 Uninterrupptable 状态的线程数量， 在 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etop -H\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（display individual threads）\n里面是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eR\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eD\u003c/code\u003e 状态，每 5s 统计一次这种线程的数量：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003enode\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"k\"\u003efor \u003c/span\u003en \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"nb\"\u003eseq \u003c/span\u003e1 30\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003edo \u003c/span\u003etop \u003cspan class=\"nt\"\u003e-b\u003c/span\u003e \u003cspan class=\"nt\"\u003e-H\u003c/span\u003e \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e 1 | egrep \u003cspan class=\"s2\"\u003e\u0026#34;(\u003c/span\u003e\u003cspan class=\"se\"\u003e\\s\u003c/span\u003e\u003cspan class=\"s2\"\u003eD\u003c/span\u003e\u003cspan class=\"se\"\u003e\\s\u003c/span\u003e\u003cspan class=\"s2\"\u003e|\u003c/span\u003e\u003cspan class=\"se\"\u003e\\s\u003c/span\u003e\u003cspan class=\"s2\"\u003eR\u003c/span\u003e\u003cspan class=\"se\"\u003e\\s\u003c/span\u003e\u003cspan class=\"s2\"\u003e)\u0026#34;\u003c/span\u003e | \u003cspan class=\"nb\"\u003ewc\u003c/span\u003e \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003esleep \u003c/span\u003e5\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003edone\n\u003c/span\u003e672\n349\n106\n467\n128\n378\n138\n50\n453\n152\n254\n701\n527\n660\n695\n677\n185\n32\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e线程数量周期性在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e30~700\u003c/code\u003e 之间变化，跟监控看到的 load 趋势一致。\u003c/p\u003e\n\n\u003cp\u003e其他现象：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003empstat -P ALL 1\u003c/code\u003e 看了一会，在 load 飙升时\u003cstrong\u003e\u003cmark\u003e只有几个核的 CPU 利用率飙升\u003c/mark\u003e\u003c/strong\u003e，\n单核最高到 100%；其他 CPU 的利用率都在正常水平；\u003c/li\u003e\n  \u003cli\u003e每次 load 飙升时，\u003cstrong\u003e\u003cmark\u003e哪些 CPU\u003c/mark\u003e\u003c/strong\u003e 的利用率会飙升起来\u003cstrong\u003e\u003cmark\u003e不固定\u003c/mark\u003e\u003c/strong\u003e；\n这是因为该 Pod 并不是 cpuset 类型，内核会根据 CPU 空闲情况迁移线程；\u003c/li\u003e\n  \u003cli\u003eIO 没什么变化；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e也可以用下面的命令\u003cstrong\u003e\u003cmark\u003e过滤掉那些不会用来计算 load 的线程\u003c/mark\u003e\u003c/strong\u003e  (S,T,t,Z,I etc)：\u003c/p\u003e\n\n  \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eps \u003cspan class=\"nt\"\u003e-e\u003c/span\u003e \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e s,user,cmd | \u003cspan class=\"nb\"\u003egrep\u003c/span\u003e ^[RD]\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"13-进一步排查方向\"\u003e1.3 进一步排查方向\u003c/h2\u003e\n\n\u003cp\u003e根据以上排查，初步总结如下：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e宿主机 Load 升高是由于 Pod 大量线程进入 running 状态导致的；\u003c/li\u003e\n  \u003cli\u003e整体 CPU/IO 等利用率都不高，因此其他业务实际上受影响不大；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e进一步排查就要联系业务看看他们的 pod 在干什么了，这个不展开。\u003c/p\u003e\n\n\u003ch2 id=\"14-疑问\"\u003e1.4 疑问\u003c/h2\u003e\n\n\u003cp\u003e作为基础设施研发，这个 case 留给我们几个疑问：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eload 到底是怎么计算的？\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eload 是否适合作为告警指标？\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e弄懂了第一个问题，第二个问题也就有答案了。\n因此接下来我们研究下第一个问题。\u003c/p\u003e\n\n\u003ch1 id=\"2-loadavg算法与内核实现\"\u003e2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eloadavg\u003c/code\u003e：算法与内核实现\u003c/h1\u003e\n\n\u003cp\u003e接下来的代码基于内核 5.10。\u003c/p\u003e\n\n\u003ch2 id=\"21-原理与算法\"\u003e2.1 原理与算法\u003c/h2\u003e\n\n\u003cp\u003eloadavg 算法本质上\u003cstrong\u003e\u003cmark\u003e很简单\u003c/mark\u003e\u003c/strong\u003e，但 Linux 内核为了减少计算开销、适配不同处理器平台等等，做了很多工程优化，\n所以现在很难快速看懂了。算法实现主要在\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/kernel/sched/loadavg.c\"\u003e\u003cmark\u003ekernel/sched/loadavg.c\u003c/mark\u003e\u003c/a\u003e [4]，\n上来就是官方吐槽：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eThis file contains the magic bits required to compute the global loadavg figure.\n\u003cstrong\u003e\u003cmark\u003eIts a silly number but people think its important\u003c/mark\u003e\u003c/strong\u003e. We go through\ngreat pains to make it work on big machines and tickless kernels.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e吐槽结束之后是算法描述：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eThe\u003c/span\u003e \u003cspan class=\"n\"\u003eglobal\u003c/span\u003e \u003cspan class=\"n\"\u003eload\u003c/span\u003e \u003cspan class=\"n\"\u003eaverage\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003ean\u003c/span\u003e \u003cspan class=\"n\"\u003eexponentially\u003c/span\u003e \u003cspan class=\"n\"\u003edecaying\u003c/span\u003e \u003cspan class=\"n\"\u003eaverage\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003enr_running\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003enr_uninterruptible\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eOnce\u003c/span\u003e \u003cspan class=\"n\"\u003eevery\u003c/span\u003e \u003cspan class=\"n\"\u003eLOAD_FREQ\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"n\"\u003efor_each_possible_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu_of\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enr_running\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu_of\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enr_uninterruptible\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eexp_n\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eexp_n\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e其中的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eavenrun[]\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 就是 loadavg。这段话说，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eloadavg 是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003enr_running + nr_uninterruptible\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 状态线程数量的一个\u003cstrong\u003e\u003cmark\u003e指数衰减平均\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e算法每隔 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e5s\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eLOAD_FREQ\u003c/code\u003e）根据公式计算一次\u003cstrong\u003e\u003cmark\u003e过去 n 分钟内\u003c/mark\u003e\u003c/strong\u003e的 loadavg，其中 n 有三个取值：1/5/15；\u003c/li\u003e\n  \u003cli\u003e对于 1 分钟粒度的 loadavg，公式简化为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eavenrun[n] = avenrun[0] * exp_1 + nr_active * (1 - exp_1)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e根据 [3]，最近 1 分钟的 load 计算公式可以进一步精确为：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cmark\u003e\u003ccode\u003eload(t) = load(t-1)e\u003csup\u003e-5/60\u003c/sup\u003e + nr_active * (1-e\u003csup\u003e-5/60\u003c/sup\u003e)\u003c/code\u003e\u003c/mark\u003e 公式 (1)\u003c/p\u003e\n\n\u003cp\u003e其中的参数：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003et\u003c/code\u003e：时刻；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enr_active\u003c/code\u003e：所有 CPU 上 nr_running + nr_uninterruptible 的 task 数量；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e根据 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enr_active\u003c/code\u003e 的取值，又分为两种情况，下面分别来看。\u003c/p\u003e\n\n\u003ch3 id=\"211-有活跃线程load-指数增长\"\u003e2.1.1 有活跃线程：load 指数增长\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enr_active \u0026gt; 0\u003c/code\u003e 表示此时（至少一个 CPU 上）有活跃线程。此时（尤其是活跃线程比较多时），\n公式 1 的后面一部分占主，前面的衰减部分可以忽略，公式简化为：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cmark\u003e\u003ccode\u003eload(t\u003csub\u003eT\u003c/sub\u003e) = nr_active * load(t\u003csub\u003e0\u003c/sub\u003e)(1-e\u003csup\u003e-5t/60\u003c/sup\u003e)\u003c/code\u003e\u003c/mark\u003e 公式 (2)\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003et\u003csub\u003e0\u003c/sub\u003e\u003c/code\u003e 是初始时刻，\u003ccode\u003et\u003csub\u003eT\u003c/sub\u003e\u003c/code\u003e 是 \u003ccode\u003eT\u003c/code\u003e 时刻。\n可以看出，这是一个与 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enr_active\u003c/code\u003e 呈近似线性的\u003cstrong\u003e\u003cmark\u003e单调递增\u003c/mark\u003e\u003c/strong\u003e曲线。\u003c/p\u003e\n\n\u003ch3 id=\"212-无活跃线程load-指数衰减\"\u003e2.1.2 无活跃线程：load 指数衰减\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enr_active = 0\u003c/code\u003e 表示所有 CPU 上都没有活跃线性，即\u003cstrong\u003e\u003cmark\u003e整个系统处于空闲状态\u003c/mark\u003e\u003c/strong\u003e。\n此时，公式简化为：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cmark\u003e\u003ccode\u003eload(t\u003csub\u003eT\u003c/sub\u003e) = load(t\u003csub\u003e0\u003c/sub\u003e)e\u003csup\u003e-5t/60\u003c/sup\u003e\u003c/code\u003e\u003c/mark\u003e 公式 (3)\u003c/p\u003e\n\n\u003cp\u003e是一个\u003cstrong\u003e\u003cmark\u003e标准的指数衰减\u003c/mark\u003e\u003c/strong\u003e。也就是说如果从此刻开始，\n后面都没有任务运行了，那系统 load 将指数衰减下去。\u003c/p\u003e\n\n\u003ch3 id=\"213-load-测试与小结\"\u003e2.1.3 Load 测试与小结\u003c/h3\u003e\n\n\u003cp\u003e我们来快速验证下。\u003c/p\u003e\n\n\u003cp\u003e在一台 48 核机器上，创建 44 个线程（留下 4 个核跑系统任务，比如监控采集程序）压测 10 分钟：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# spawn 44 workers spinning on malloc()/free(), run for 10 minutes\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003estress \u003cspan class=\"nt\"\u003e-m\u003c/span\u003e 44 \u003cspan class=\"nt\"\u003e--timeout\u003c/span\u003e 600s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下面是 load1_per_core 的监控：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-loadavg/load-curve-with-stress.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. \u003cmark\u003eLoad test on a 48-Core physical server\u003c/mark\u003e. \u003ccode\u003estress -m 44 --timeout 600s\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eLoad 曲线明显分为两个阶段：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e15:50~16:00\u003c/code\u003e，一直有 44 个活跃线性，因此 load 一个\u003cstrong\u003e\u003cmark\u003e单调递增\u003c/mark\u003e\u003c/strong\u003e曲线，前半部分近似线性（后面为什么越来越平了？）；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e16:00~16:10\u003c/code\u003e，没有活跃线性（除了一些开销很小的系统线程），因此 load 是一个比较标准的\u003cstrong\u003e\u003cmark\u003e指数衰减\u003c/mark\u003e\u003c/strong\u003e曲线；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e注意：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e图中纵轴的单位是 load1_per_core，乘以这台机器的核数 48 才是 loadavg，也就是公式 1-3 中的 load。\n  不过由于二者就差一个固定倍数，因此曲线走势是一模一样的。\u003c/li\u003e\n  \u003cli\u003e后面会看到，内核每 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e5s\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 计算一次 load，而这里的监控是每 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e60s\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n  采集一个点，所以曲线略显粗糙；如果有精度更高的采集（例如，也是 5s 采集一次），会看到一条更漂亮的曲线。\u003c/li\u003e\n  \u003cli\u003e另外注意注意到 load1_per_core 最大值已经超过 1 了，因此它\u003cstrong\u003e\u003cmark\u003e并不是\u003c/mark\u003e\u003c/strong\u003e一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;= 1.0 (100%)\u003c/code\u003e 的指标，\n  活跃线程数量越多，load 就越大。如果压测时创建更多的活跃线性，就会看到 load 达到一个更大的平稳值。\n  它\u003cstrong\u003e\u003cmark\u003e跟 CPU 利用率\u003c/mark\u003e\u003c/strong\u003e（最大 100%）\u003cstrong\u003e\u003cmark\u003e并不是一个概念\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e有了这样初步的感性认识之后，接下来看看内核实现。\u003c/p\u003e\n\n\u003ch2 id=\"22-内核基础\"\u003e2.2 内核基础\u003c/h2\u003e\n\n\u003cp\u003e要大致看懂代码，需要一些内核基础。\u003c/p\u003e\n\n\u003ch3 id=\"221-运行调度队列-struct-rq\"\u003e2.2.1 运行/调度队列 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct rq\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e内核在每个 CPU 上都有一个\u003cstrong\u003e\u003cmark\u003e调度队列\u003c/mark\u003e\u003c/strong\u003e，叫 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003erunqueue\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（运行队列），\n对应的结构体是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct rq\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\n这是一个通用调度队列，里面包含了大量与调度相关的字段，比如\n\u003ca href=\"/blog/linux-cfs-design-and-implementation-zh/\"\u003e完全公平调度器\u003c/a\u003e\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003estruct cfs_rq cfs\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e本文主要关注的是与计算 load 有关的几个字段，\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/sched/sched.h\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// This is the main, per-CPU runqueue data structure.\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003erq\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e         \u003cspan class=\"n\"\u003enr_running\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// running task 数量\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e   \u003cspan class=\"n\"\u003ecfs_rq\u003c/span\u003e      \u003cspan class=\"n\"\u003ecfs\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e               \u003cspan class=\"c1\"\u003e// 完全公平调度器 CFS\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e        \u003cspan class=\"n\"\u003enr_uninterruptible\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"c1\"\u003e// 不可中断状态的 task 数量\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// 与 load 计算相关的字段\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e        \u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 上次计算 load 的时刻\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003elong\u003c/span\u003e                 \u003cspan class=\"n\"\u003ecalc_load_active\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 上次计算 load 时的 nr_active (running+uninterruptible)\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如上，有两个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecalc_load_\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 前缀的变量，表明这是\u003cstrong\u003e\u003cmark\u003e计算 load 用的\u003c/mark\u003e\u003c/strong\u003e，\n后缀表示变量的用途，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode\u003ecalc_load_\u003cmark\u003eupdate\u003c/mark\u003e\u003c/code\u003e：上次计算 load 的时刻；\u003c/li\u003e\n  \u003cli\u003e\u003ccode\u003ecalc_load_\u003cmark\u003etasks\u003c/mark\u003e\u003c/code\u003e：上次计算 load 时的 running+uninterruptible 状态的 task 数量（内核代码中 task 表示的是一个进程或一个线程）；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e代码中看到这俩变量时，可能觉得更像是函数名而不是变量。如果更倾向于可读性，这俩变量可以改为：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eprev_load_calc_time\u003c/li\u003e\n    \u003cli\u003eprev_load_calc_active_tasks 或 prev_load_calc_nr_active\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"222-load-计算相关的全局变量\"\u003e2.2.2 Load 计算相关的全局变量\u003c/h3\u003e\n\n\u003cp\u003e计算 load 用的几个全局变量：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/sched/loadavg.c\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eatomic_long_t\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load_tasks\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// CPU 上 threads 数量\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 时间戳\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e前两个跟 runqueue 里面的字段对应，但计算的是所有 CPU 上所有 runqueue 对应字段的总和，\n因为 load 表示是系统负载，不是单个 CPU 的负载。\u003c/li\u003e\n  \u003cli\u003e第三个变量 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eavenrun[3]\u003c/code\u003e 前面也看到了，表示的是过去 1、5、15 分钟内的 loadavg。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"223-内核时间基础hztickjiffiesuptime\"\u003e2.2.3 内核时间基础：HZ/tick/jiffies/uptime\u003c/h3\u003e\n\n\u003cp\u003eLinux 内核的\u003cstrong\u003e\u003cmark\u003e周期性事件\u003c/mark\u003e\u003c/strong\u003e基于 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etimer interrupt\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n触发，计时基于 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eHZ\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，这是一个\u003cstrong\u003e\u003cmark\u003e编译常量\u003c/mark\u003e\u003c/strong\u003e，通常与 CPU 架构相关。\n例如，对于最常见的 X86 架构，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e默认 HZ 是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e1000\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，也就是 1s 内触发 1000 次 timer interrupt，interrupt 间隔是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e1s/HZ = 1ms\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\n  这和\u003cstrong\u003e\u003cmark\u003e处理器的晶振频率\u003c/mark\u003e\u003c/strong\u003e（例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.1G HZ\u003c/code\u003e）并不是一个概念，别搞混了；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e在计时上，一次 timer interrupt 也称为一次 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etick\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003etick 的间隔称为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etick period\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，因此有 tick period = \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e1s/HZ\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n      \u003cli\u003e在内核中有两个相关变量\u003c/li\u003e\n    \u003c/ul\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c1\"\u003e// kernel/time/tick-common.c\u003c/span\u003e\n    \n \u003cspan class=\"c1\"\u003e// Tick next event: keeps track of the tick time\u003c/span\u003e\n \u003cspan class=\"n\"\u003ektime_t\u003c/span\u003e \u003cspan class=\"n\"\u003etick_next_period\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n \u003cspan class=\"n\"\u003ektime_t\u003c/span\u003e \u003cspan class=\"n\"\u003etick_period\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \n \u003cspan class=\"c1\"\u003e// Setup the tick device\u003c/span\u003e\n \u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003etick_setup_device\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etick_device\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003etd\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eclock_event_device\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enewdev\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecpumask\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecpumask\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n     \u003cspan class=\"n\"\u003etick_next_period\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ektime_get\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n     \u003cspan class=\"n\"\u003etick_period\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eNSEC_PER_SEC\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003eHZ\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 内部用 ns 表示\u003c/span\u003e\n \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e系统启动以来的 tick 次数\u003c/mark\u003e\u003c/strong\u003e记录在全局变量 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ejiffies\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 里面，\u003c/p\u003e\n\n    \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e \u003cspan class=\"c1\"\u003e// linux/jiffies.h\u003c/span\u003e\n    \n \u003cspan class=\"k\"\u003eextern\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e \u003cspan class=\"n\"\u003ejiffies\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n\n    \u003cp\u003e系统启动时初始化为 0，每次 timer interrupt 加 1。由于 timer interrupt 是 1ms，\n 因此 jiffies 就是以 \u003cstrong\u003e\u003cmark\u003e1ms 为单位的系统启动以来的时间\u003c/mark\u003e\u003c/strong\u003e。\n jiffies_64 是 64bit 版本的 jiffies。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ejiffies 和 uptime 的关系：\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cmark\u003e\u003ccode\u003euptime_in_seconds = jiffies / HZ\u003c/code\u003e\u003c/mark\u003e\u003c/p\u003e\n\n    \u003cp\u003e以及\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cmark\u003e\u003ccode\u003ejiffies = uptime_in_seconds * HZ\u003c/code\u003e\u003c/mark\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e有了以上基础，接下来可以看算法实现了。\u003c/p\u003e\n\n\u003ch2 id=\"23-算法实现\"\u003e2.3 算法实现\u003c/h2\u003e\n\n\u003ch3 id=\"231-调用栈\"\u003e2.3.1 调用栈\u003c/h3\u003e\n\n\u003cp\u003e每次 timer interrupt 之后，会执行到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etick_handle_periodic()\u003c/code\u003e，接下来的调用栈：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003etick_handle_periodic // kernel/time/tick-common.c\n  |-cpu = smp_processor_id();\n  |-tick_periodic(cpu)\n      |-if (tick_do_timer_cpu == cpu) { // 只有一个 CPU 负责计算 load，不然就乱套了\n      |   tick_next_period = ktime_add(tick_next_period, tick_period); // 更新全局变量\n      |   do_timer(ticks=1)\n      |   | |-jiffies_64 += ticks; // 都是 ns 表示的\n      |   | |-calc_global_load();\n      |   |     | // update the avenrun load estimates 10 ticks after the CPUs have updated calc_load_tasks.\n      |   |     |-if jiffies \u0026lt; calc_load_update + 10\n      |   |     |   return;\n      |   |     |\n      |   |     |-active = atomic_long_read(\u0026amp;calc_load_tasks);\n      |   |     |-active = active \u0026gt; 0 ? active * FIXED_1 : 0;\n      |   |     |-avenrun[0] = calc_load(load=avenrun[0], exp=EXP_1, active);\n      |   |     |                |-newload = avenrun[0] * EXP_1 + active * (FIXED_1 - EXP_1)\n      |   |     |                |-if (active \u0026gt;= avenrun[0])\n      |   |     |                |     newload += FIXED_1-1;\n      |   |     |                | \n      |   |     |                |-return newload / FIXED_1;\n      |   |     |\n      |   |     |-avenrun[1] = calc_load(avenrun[1], EXP_5, active);\n      |   |     |-avenrun[2] = calc_load(avenrun[2], EXP_15, active);\n      |   |     |-WRITE_ONCE(calc_load_update, sample_window + LOAD_FREQ); // 下一次计算 loadavg 的时间：5s 后\n      |   |     |\n      |   |     |-calc_global_nohz(); // In case we went to NO_HZ for multiple LOAD_FREQ intervals catch up in bulk.\n      |   |         |-calc_load_n\n      |   |             |-calc_load\n      |   |\n      |   update_wall_time()\n      |-}\n      |-update_process_times(user_mode(get_irq_regs()));\n      |-profile_tick(CPU_PROFILING);\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003etimer 中断之后，执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etick_handle_periodic()\u003c/code\u003e，它首先\n获取程序当前所在的 CPU ID，然后执行 tick_periodic(cpu)。\u003c/p\u003e\n\n\u003cp\u003e接下来的大致步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e判断是不是当前 CPU 负责计算 load，是的话才继续；否则只更新一些进程 timer 信息就返回了；\u003c/li\u003e\n  \u003cli\u003e如果是当前 CPU 负责计算，则更新下次 tick 时间戳 tick_next_period，也就是在当前时间基础上加上 tick_period （1/HZ 秒，x86 默认是 1ms）；\u003c/li\u003e\n  \u003cli\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edo_timer(ticks=1)\u003c/code\u003e 尝试计算一次 load；这里说尝试是因为不一定真的会计算，可能会提前返回；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e更新 jiffies_64；然后计算 load，\u003c/p\u003e\n\n    \u003cp\u003e如果 jiffies 比上次计算 load 的时间戳 + 10 要小，就不计算；\n 否则，调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecalc_load()\u003c/code\u003e 开始计算 loadavg。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e计算 load 的算法就是我们上一节介绍过的了：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eThe\u003c/span\u003e \u003cspan class=\"n\"\u003eglobal\u003c/span\u003e \u003cspan class=\"n\"\u003eload\u003c/span\u003e \u003cspan class=\"n\"\u003eaverage\u003c/span\u003e \u003cspan class=\"n\"\u003eis\u003c/span\u003e \u003cspan class=\"n\"\u003ean\u003c/span\u003e \u003cspan class=\"n\"\u003eexponentially\u003c/span\u003e \u003cspan class=\"n\"\u003edecaying\u003c/span\u003e \u003cspan class=\"n\"\u003eaverage\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"n\"\u003enr_running\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003enr_uninterruptible\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003eOnce\u003c/span\u003e \u003cspan class=\"n\"\u003eevery\u003c/span\u003e \u003cspan class=\"n\"\u003eLOAD_FREQ\u003c/span\u003e\u003cspan class=\"err\"\u003e（\u003c/span\u003e\u003cspan class=\"mi\"\u003e5\u003c/span\u003e \u003cspan class=\"err\"\u003e秒）\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e \u003cspan class=\"n\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003ecpus\u003c/span\u003e\u003cspan class=\"o\"\u003e:\u003c/span\u003e\n      \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enr_running\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enr_uninterruptible\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eexp_n\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003enr_active\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eexp_n\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"232-一些实现细节\"\u003e2.3.2 一些实现细节\u003c/h3\u003e\n\n\u003ch4 id=\"runqueue-load-字段初始化\"\u003erunqueue load 字段初始化\u003c/h4\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003esched_rq_cpu_starting\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003erq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erq\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu_rq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eupdate_max_interval\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003e__init\u003c/span\u003e \u003cspan class=\"nf\"\u003esched_init\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003efor_each_possible_cpu\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003erq\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"n\"\u003erq\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecpu_rq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eraw_spin_lock_init\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003elock\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enr_running\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_active\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"n\"\u003erq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ejiffies\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eLOAD_FREQ\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"判断是否由当前-cpu-执行-load-计算\"\u003e判断是否由当前 CPU 执行 load 计算\u003c/h4\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/time/tick-common.c\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/*\n * tick_do_timer_cpu is a timer core internal variable which holds the CPU NR\n * which is responsible for calling do_timer(), i.e. the timekeeping stuff. This\n * variable has two functions:\n *\n * 1) Prevent a thundering herd issue of a gazillion of CPUs trying to grab the\n *    timekeeping lock all at once. Only the CPU which is assigned to do the\n *    update is handling it.\n *\n * 2) Hand off the duty in the NOHZ idle case by setting the value to\n *    TICK_DO_TIMER_NONE, i.e. a non existing CPU. So the next cpu which looks\n *    at it will take over and keep the time keeping alive.  The handover\n *    procedure also covers cpu hotplug.\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003etick_do_timer_cpu\u003c/span\u003e \u003cspan class=\"n\"\u003e__read_mostly\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eTICK_DO_TIMER_BOOT\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"do_timer\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edo_timer()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/time/tick-common.c\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// kernel/time/timekeeping.c\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003edo_timer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eticks\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ejiffies_64\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eticks\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ecalc_global_load\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4 id=\"calc_global_load---calc_load\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecalc_global_load() -\u0026gt; calc_load()\u003c/code\u003e\u003c/h4\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// kernel/time/tick-common.c\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/*\n * calc_load - update the avenrun load estimates 10 ticks after the\n * CPUs have updated calc_load_tasks.\n *\n * Called from the global timer code.\n */\u003c/span\u003e\n\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e \u003cspan class=\"nf\"\u003ecalc_global_load\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003esample_window\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edelta\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003esample_window\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eREAD_ONCE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etime_before\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ejiffies\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esample_window\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e10\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/*\n     * Fold the \u0026#39;old\u0026#39; NO_HZ-delta to include all NO_HZ CPUs.\n     */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003edelta\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load_nohz_read\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelta\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eatomic_long_add\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelta\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_tasks\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eatomic_long_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_tasks\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e?\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eFIXED_1\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003eEXP_1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003eEXP_5\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ecalc_load\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eavenrun\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"n\"\u003eEXP_15\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eWRITE_ONCE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecalc_load_update\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esample_window\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eLOAD_FREQ\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"cm\"\u003e/*\n     * In case we went to NO_HZ for multiple LOAD_FREQ intervals\n     * catch up in bulk.\n     */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ecalc_global_nohz\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"cm\"\u003e/*\n * a1 = a0 * e + a * (1 - e)\n */\u003c/span\u003e\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\n\u003cspan class=\"nf\"\u003ecalc_load\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eload\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eexp\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003enewload\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eload\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003eexp\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eFIXED_1\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003eexp\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eactive\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;=\u003c/span\u003e \u003cspan class=\"n\"\u003eload\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n        \u003cspan class=\"n\"\u003enewload\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"n\"\u003eFIXED_1\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003enewload\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003eFIXED_1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"24-考古\"\u003e2.4 考古\u003c/h2\u003e\n\n\u003cp\u003e[2] 中对 Linux loadavg 算法演变做了一些考古。\n主要是关于 Linux 为什么计算 loadavg 时需要考虑到 uninterruptible sleep 线程数量，\n以及 Linux 的 loadavg 和其他操作系统的 loadavg 有什么区别。\u003c/p\u003e\n\n\u003ch3 id=\"241-计入不可中断-sleep\"\u003e2.4.1 计入不可中断 sleep\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eUninterruptible Sleep\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e (\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eD\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e) 状态通常是同步 disk IO 导致的 sleeping；\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e这种状态的 task 不受中断信号影响，例如阻塞在 disk IO 和某些 lock 上的 task；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e将这种状态的线性引入 loadavg 计算的 \u003ca href=\"http://oldlinux.org/Linux.old/mail-archive/alan-old-funet-lists/kernel.1993.gz\"\u003epatch\u003c/a\u003e；\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  From: Matthias Urlichs \u0026lt;urlichs@smurf.sub.org\u0026gt;\n  Subject: Load average broken ?\n  Date: Fri, 29 Oct 1993 11:37:23 +0200\n    \n  The kernel only counts \u0026#34;runnable\u0026#34; processes when computing the load average. \n  I don\u0026#39;t like that; the problem is that processes which are swapping or \n  waiting on \u0026#34;fast\u0026#34;, i.e. noninterruptible, I/O, also consume resources.\n    \n  It seems somewhat nonintuitive that the load average goes down when you \n  replace your fast swap disk with a slow swap disk...\n    \n  Anyway, the following patch seems to make the load average much more \n  consistent WRT the subjective speed of the system. And, most important, the \n  load is still zero when nobody is doing anything. ;-)\n    \n  --- kernel/sched.c.orig\tFri Oct 29 10:31:11 1993\n  +++ kernel/sched.c\tFri Oct 29 10:32:51 1993\n  @@ -414,7 +414,9 @@\n   \tunsigned long nr = 0;\n    \n   \tfor(p = \u0026amp;LAST_TASK; p \u0026gt; \u0026amp;FIRST_TASK; --p)\n  -\t\tif (*p \u0026amp;\u0026amp; (*p)-\u0026gt;state == TASK_RUNNING)\n  +\t\tif (*p \u0026amp;\u0026amp; ((*p)-\u0026gt;state == TASK_RUNNING) ||\n  +\t\t           (*p)-\u0026gt;state == TASK_UNINTERRUPTIBLE) ||\n  +\t\t           (*p)-\u0026gt;state == TASK_SWAPPING))\n   \t\t\tnr += FIXED_1;\n   \treturn nr;\n   }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e使得 Linux 系统 loadavg 表示的不再是 “CPU load averages”，而是 “system load averages”。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"242-linux-vs-其他-osloadavg-区别\"\u003e2.4.2 Linux vs. 其他 OS：loadavg 区别\u003c/h3\u003e\n\n\u003cp\u003eLinux load 与其他操作系统 load 的区别：\n几点重要信息：\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth style=\"text-align: left\"\u003e操作系统\u003c/th\u003e\n      \u003cth style=\"text-align: left\"\u003eload average 概念和内涵\u003c/th\u003e\n      \u003cth style=\"text-align: left\"\u003e优点\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003eLinux\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e准确说是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003esystem load average\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，衡量的是系统整体资源，而非 CPU 这一种资源。包括了正在运行和等待（CPU, disk, uninterruptible locks 等资源）运行的所有线程数量，换句话说，统计\u003cstrong\u003e\u003cmark\u003e所有非完全空闲的线程\u003c/mark\u003e\u003c/strong\u003e（threads that aren’t completely idle）数量\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e考虑到了 CPU 之外的其他资源\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e其他操作系统\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e指的就是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCPU load average\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，衡量所有 CPU 上 running+runnable 线程的数量\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e理解简单，也更容易推测 CPU 资源的使用情况\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch1 id=\"3-讨论\"\u003e3 讨论\u003c/h1\u003e\n\n\u003ch2 id=\"31-load-很高所有进程都会受影响吗\"\u003e3.1 Load 很高，所有进程都会受影响吗？\u003c/h2\u003e\n\n\u003cp\u003e不一定。\u003c/p\u003e\n\n\u003cp\u003eLoad 是根据\u003cstrong\u003e\u003cmark\u003e所有 CPU\u003c/mark\u003e\u003c/strong\u003e 的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003erunqueue\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n状态综合算出的一个数字，load 很高\u003cstrong\u003e\u003cmark\u003e并不能代表每个 CPU 都过载了\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e例如，少数几个 CPU 上有大量或持续活跃线程，就足以把系统 load 打到很高，\n但这种情况下，其他 CPU 上的任务并不受影响。下面来模拟一下。\u003c/p\u003e\n\n\u003ch3 id=\"311-模拟单个-cpu-把系统-load-打高上百倍\"\u003e3.1.1 模拟：单个 CPU 把系统 load 打高上百倍\u003c/h3\u003e\n\n\u003cp\u003e下面是一台 4C 空闲机器上，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/cpuinfo | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003eprocessor\nprocessor       : 0\nprocessor       : 1\nprocessor       : 2\nprocessor       : 3\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003euptime\n \u003c/span\u003e16:52:13 up  3:15,  7 \u003cspan class=\"nb\"\u003eusers\u003c/span\u003e,  load average: 0.22, 0.18, 0.18\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e系统 loadavg1 只有 0.22。接下来创建 30 个 stress 任务并\u003cstrong\u003e\u003cmark\u003e固定到 CPU 3\u003c/mark\u003e\u003c/strong\u003e 上执行，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# spawn 30 workers spinning on sqrt()\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etaskset \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e 3 stress \u003cspan class=\"nt\"\u003e-c\u003c/span\u003e 30 \u003cspan class=\"nt\"\u003e--timeout\u003c/span\u003e 120s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后通过 top 命令 5s 查看一次 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eloadavg1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"k\"\u003efor \u003c/span\u003en \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"nb\"\u003eseq \u003c/span\u003e1 120\u003cspan class=\"sb\"\u003e`\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003edo \u003c/span\u003etop \u003cspan class=\"nt\"\u003e-b\u003c/span\u003e \u003cspan class=\"nt\"\u003e-n1\u003c/span\u003e | \u003cspan class=\"nb\"\u003ehead\u003c/span\u003e \u003cspan class=\"nt\"\u003e-n1\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;{print $(NF-2)}\u0026#39;\u003c/span\u003e | \u003cspan class=\"nb\"\u003esed\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;s/,//\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nb\"\u003esleep \u003c/span\u003e5\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"k\"\u003edone\n\u003c/span\u003e0.24\n0.22\n0.26\n2.64\n4.84\n6.85\n8.70\n10.41\n11.98\n13.42\n14.75\n15.97\n17.09\n18.13\n19.08\n19.95\n20.76\n21.50\n22.18\n22.81\n23.38\n23.91\n24.40\n24.85\n25.26\n25.64\n25.99\n23.91\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，loadavg 最高到了 25 以上，比我们压测之前高了 \u003cstrong\u003e\u003cmark\u003e100 多倍\u003c/mark\u003e\u003c/strong\u003e。\n看一下压测期间的 \u003cstrong\u003e\u003cmark\u003eCPU 利用率\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003empstat \u003cspan class=\"nt\"\u003e-p\u003c/span\u003e ALL 1\nAverage:  CPU    %usr  %nice   %sys %iowait   %irq  %soft  %steal  %guest  %gnice   %idle\nAverage:  all   25.02   0.00   0.17    0.00   0.00   0.00    0.00    0.00    0.00   74.81\nAverage:    0    0.00   0.00   0.33    0.00   0.00   0.00    0.00    0.00    0.00   99.67 \u003cspan class=\"c\"\u003e# -+\u003c/span\u003e\nAverage:    1    0.00   0.00   0.33    0.00   0.00   0.00    0.00    0.00    0.00   99.67 \u003cspan class=\"c\"\u003e#  | CPU 0-2 are idle\u003c/span\u003e\nAverage:    2    0.00   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00  100.00 \u003cspan class=\"c\"\u003e# -+\u003c/span\u003e\nAverage:    3  100.00   0.00   0.00    0.00   0.00   0.00    0.00    0.00    0.00    0.00\n           \u003cspan class=\"c\"\u003e#      |\u003c/span\u003e\n           \u003cspan class=\"c\"\u003e# CPU 3 is 100% busy\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到\u003cstrong\u003e\u003cmark\u003e只有 CPU 3 维持在 100%\u003c/mark\u003e\u003c/strong\u003e，其他几个 CPU 都是绝对空闲的。\u003c/p\u003e\n\n\u003ch3 id=\"312-cpuset-vs-cpu-quota\"\u003e3.1.2 cpuset vs. cpu quota\u003c/h3\u003e\n\n\u003cp\u003e假如我们的压测程序是跑在一个 pod 里，这种情况对应的就是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecpuset\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n模式 —— 独占几个固定的 CPU。这种情况下除了占用这些 CPU 的 Pod 自身，其他 Pod 是不受影响的\n（单就 CPU 这一种资源来说。实际上 pod 还共享其他资源，例如宿主机的总网络带宽、IO 等）。\u003c/p\u003e\n\n\u003cp\u003e非 cpuset 的 pod 没有独占 CPU，系统通过 cgroup/cfs 来分配给它们 CPU 份额，\n线程也会在 CPU 之间迁移，因此影响其他 pod 的可能性大一些。一些相关内容：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cfs-design-and-implementation-zh/\"\u003eLinux CFS 调度器：原理、设计与内核实现（2023）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/k8s-cgroup-zh/\"\u003ek8s 基于 cgroup 的资源限额（capacity enforcement）：模型设计与代码实现（2023）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"32-僵尸进程\"\u003e3.2 僵尸进程\u003c/h2\u003e\n\n\u003cp\u003eloadavg 也会计入僵尸进程（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eZ\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 状态），因此如果有大量僵尸进程，也会看到系统的 load 很高。\u003c/p\u003e\n\n\u003ch2 id=\"33-load--cpu-利用率\"\u003e3.3 Load \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e!=\u003c/code\u003e CPU 利用率\u003c/h2\u003e\n\n\u003cp\u003eloadavg 衡量系统整体在过去一段时间内的负载状态，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e每 5s 对\u003cstrong\u003e\u003cmark\u003e所有 CPU 上所有 runqueue\u003c/mark\u003e\u003c/strong\u003e 采样一次，本质上表示的是 runqueue length，并不是 CPU 利用率；\u003c/li\u003e\n  \u003cli\u003e是一种 \u003cstrong\u003e\u003cmark\u003e指数衰减移动平均\u003c/mark\u003e\u003c/strong\u003e（exponentially-damped moving average）；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eCPU 利用率统计的是 CPU 繁忙的时间占比，比如对于单个 CPU，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 1s 的周期内有 0.5s 在执行任务，剩下的时间是空闲的，那 CPU 利用率就是 50%；\u003c/li\u003e\n  \u003cli\u003e利用率上限是 100%；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"34-load-是否是一个很好的告警指标\"\u003e3.4 Load 是否是一个很好的告警指标？\u003c/h2\u003e\n\n\u003cp\u003e根据以上讨论，load 高并不一定表示每个 CPU 都繁忙。极端情况下，单核或单个应用的线程太多就能导致 load 飙升成百上千倍，\n但这时可能除了少数几个核，其他核上的应用都不受影响，所以\u003cstrong\u003e用 load 来告警并不合适\u003c/strong\u003e；\n更准确的是\u003cstrong\u003e\u003cmark\u003e每个 CPU 独立计算 load\u003c/mark\u003e\u003c/strong\u003e，即 \u003cstrong\u003eper-core-loadavg\u003c/strong\u003e，但目前并没有这个指标。\u003c/p\u003e\n\n\u003cp\u003e但另一方面，load 趋势变化在实际排障中还是很有参加价值的，\n比如之前 loadavg 是 0.5，现在突然变成 0.8，那说明系统任务数量或状态还是有较大变化的，\n为进一步排查指明了一个方向。\u003c/p\u003e\n\n\u003ch1 id=\"4-实用指南\"\u003e4 实用指南\u003c/h1\u003e\n\n\u003cp\u003e既然 load 只能用来看趋势和相对大小，判断是否可能有问题，而无法及衡量问题的严重程度及进一步定位问题根源，\n那怎么进一步排查和定位问题呢？下面是一些参考。\u003c/p\u003e\n\n\u003ch2 id=\"41-use-used-frequency-saturation-errors-方法论\"\u003e4.1 USE (Used-frequency, Saturation, Errors) 方法论\u003c/h2\u003e\n\n\u003cp\u003e《Systems Performance: Enterprise and the Cloud》（中文版名为《性能之巅》）一书提出了\n衡量一种资源使用状况的 3 个维度的指标 [5]：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e利用率（Utilization）: 例如，CPU 利用率 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e90%\u003c/code\u003e（有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e90%\u003c/code\u003e 的时间内，这个 CPU 有被使用到）；\u003c/li\u003e\n  \u003cli\u003e饱和度（Saturation）: 用 \u003cstrong\u003ewait-queue length\u003c/strong\u003e 衡量，例如，CPU 的平均 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunqueue length\u003c/code\u003e 是 4；\u003c/li\u003e\n  \u003cli\u003e错误数（Errors）: 例如网卡有 50 个丢包\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e但 [7] 中已经分析过，USE 术语给 “Utilization” 这个词带来了相当大的歧义，因为大家说到 “utilization”（“利用率”）\n时，普遍指的是一种资源总共被使用了多少 —— 比如我有 4 个 CPU，其中 3 个 100% 在运行，那 “utilization”\n就是 75% —— 这对应的其实是 USE 里面的 “saturation”（“饱和度”）概念。作者重新将\n“Utilization” 定义为“使用频率” —— \u003cstrong\u003e\u003cmark\u003e在采样周期内，有多长时间这种资源有被使用到\u003c/mark\u003e\u003c/strong\u003e（不管使用了多少） ——\n给一个已经普遍接受的术语重新定义概念，造成很大的理解和交流障碍。\n为此，本文把 USE 中的 “U” 解释成 “Used-frequency”。方法论没有任何变化，只是改个术语来减少混淆。\u003c/p\u003e\n\n\u003cp\u003e举例，对于一片 100 核的 GPU，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eUsed-frequency：在采样周期内，这种资源被使用到的时间比例；例如采样周期是 1s，\n其中 0.8s 的时间内有\u003cstrong\u003e\u003cmark\u003e至少有一个核\u003c/mark\u003e\u003c/strong\u003e在执行计算，那 U 就是 80%；\n\u003cstrong\u003e\u003cmark\u003e实际用了几个核，从这个指标推测不出来\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003eSaturation：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100% * used_cores / total_cores\u003c/code\u003e；这个指标\u003cstrong\u003e\u003cmark\u003e可以推测平均用了几个核\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003eErrors：（一般是 Saturation 超过一定阈值之后，）这个 GPU 的报错数量。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"42-指标\"\u003e4.2 指标\u003c/h2\u003e\n\n\u003cp\u003e进一步排查，可以参考下列 U 和 S 指标。\u003c/p\u003e\n\n\u003ch3 id=\"421-used-frequency-指标\"\u003e4.2.1 Used-frequency 指标\u003c/h3\u003e\n\n\u003cp\u003e在\u003cstrong\u003e\u003cmark\u003e定义 workload 行为特征\u003c/mark\u003e\u003c/strong\u003e方面比较有用，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eper-CPU\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e used-frequency：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003empstat -P ALL 1\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eper-process\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e CPU used-frequency: eg, top, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epidstat 1\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"422-saturation-指标\"\u003e4.2.2 Saturation 指标\u003c/h3\u003e\n\n\u003cp\u003e在\u003cstrong\u003e\u003cmark\u003e瓶颈分析\u003c/mark\u003e\u003c/strong\u003e方面比较有用：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003ePer-CPU 调度延迟\u003c/mark\u003e\u003c/strong\u003e（CPU run queue \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elatency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/schedstat\u003c/code\u003e\u003c/p\u003e\n\n        \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/schedstat\n  version 15\n  timestamp 4300445966\n  cpu0 0 0 0 0 0 0 1251984973307 142560271674 30375313\n  cpu1 0 0 0 0 0 0 1423130608498 155128353435 40480095\n  cpu2 0 0 0 0 0 0 1612417112675 603370909483 43658159\n  cpu3 0 0 0 0 0 0 1763144199179 4220860238053 31154491\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e        \u003c/div\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf sched\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003ebcc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunqlat\u003c/code\u003e 脚本\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e全局调度队列长度\u003c/mark\u003e\u003c/strong\u003e（CPU run queue \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003elength\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）：\n  这个指标能看出\u003cstrong\u003e\u003cmark\u003e有没有问题\u003c/mark\u003e\u003c/strong\u003e，但是很难估计问题的严重程度。\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\n        \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003evmstat 1\u003c/code\u003e，看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003er\u003c/code\u003e 列的数据；\u003c/p\u003e\n\n        \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e  \u003cspan class=\"nv\"\u003e$ \u003c/span\u003evmstat 1\n  procs \u003cspan class=\"nt\"\u003e-----------memory----------\u003c/span\u003e \u003cspan class=\"nt\"\u003e---swap--\u003c/span\u003e \u003cspan class=\"nt\"\u003e-----io----\u003c/span\u003e \u003cspan class=\"nt\"\u003e-system--\u003c/span\u003e \u003cspan class=\"nt\"\u003e------cpu-----\u003c/span\u003e\n   r  b   swpd   free   buff  cache   si   so    bi    bo   \u003cspan class=\"k\"\u003ein   \u003c/span\u003ecs us sy \u003cspan class=\"nb\"\u003eid \u003c/span\u003ewa st\n   2  0 220532  69004  56416 1305500    1   10   387   370  900 1411  9  2 89  0  0\n   0  0 220532  69004  56416 1305700    0    0     0     0  774 1289  0  1 99  0  0\n  ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e        \u003c/div\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\n        \u003cp\u003ebcc \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erunqlen\u003c/code\u003e 脚本\u003c/p\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ePer-thread run queue (scheduler) latency\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e：\n  这是最好的 CPU 饱和度指标，它表示 task/thread 已经 runnable 了，但是还没有等到它的时间片；\n  可以计算出一个线程花在 scheduler latency 上的时间百分比。这个比例很容易量化，看出问题的严重程度。\n  具体指标：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/PID/schedstats\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edelaystats\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eperf sched\u003c/code\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"5-结束语\"\u003e5 结束语\u003c/h1\u003e\n\n\u003cp\u003e本文从遇到的具体问题出发，研究了一些 Linux load 相关的内容。\n一些内容和理解都还比较粗糙，后面有机会再完善。\u003c/p\u003e\n\n\u003ch1 id=\"references\"\u003eReferences\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://tanelpoder.com/posts/high-system-load-low-cpu-utilization-on-linux/\"\u003eHigh System Load with Low CPU Utilization on Linux?\u003c/a\u003e, tanelpoder.com, 2020\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.brendangregg.com/blog/2017-08-08/linux-load-averages.html\"\u003eLinux Load Averages: Solving the Mystery\u003c/a\u003e, brendangregg.com, 2017\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.fortra.com/resources/guides/unix-load-average-part-1-how-it-works\"\u003eUNIX Load Average Part 1: How It Works\u003c/a\u003e, fortra.com\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/kernel/sched/loadavg.c\"\u003ekernel/sched/loadavg.c\u003c/a\u003e, 2021\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/systems-performance-notes-zh/\"\u003e(笔记)《Systems Performance: Enterprise and the Cloud》(Prentice Hall, 2013)\u003c/a\u003e, 2020\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-trouble-shooting-cheat-sheet/\"\u003eLinux Trouble Shooting Cheat Sheet\u003c/a\u003e, 2020\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/understanding-gpu-performance/\"\u003eUnderstanding NVIDIA GPU Performance: Utilization vs. Saturation (2023)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/gpu-advanced-notes-1-zh/\"\u003e\u003cspan\u003e« GPU 进阶笔记（一）：高性能 GPU 服务器硬件拓扑与集群组网（2023）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/k8s-is-about-apis-2-zh/\"\u003e\u003cspan\u003eK8s 的核心是 API 而非容器（二）：从开源项目看 k8s 的几种 API 扩展机制（2023） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2023-10-03T00:00:00Z",
  "Author": "Arthur Chiao"
}