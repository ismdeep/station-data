{
  "Source": "arthurchiao.art",
  "Title": "[译] 为 K8s workload 引入的一些 BPF datapath 扩展（LPC, 2021）",
  "Link": "https://arthurchiao.art/blog/bpf-datapath-extensions-for-k8s-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 为 K8s workload 引入的一些 BPF datapath 扩展（LPC, 2021）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2021-11-24 | Last Update 2022-10-17\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 LPC 2021 的一篇分享：\n\u003ca href=\"https://linuxplumbersconf.org/event/11/contributions/953/\"\u003eBPF datapath extensions for K8s workloads\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e作者 Daniel Borkmann 和 Martynas Pumputis 都是 Cilium 的核心开发。\n翻译时补充了一些背景知识、代码片段和链接，以方便理解。\u003c/p\u003e\n\n\u003cp\u003e翻译已获得作者授权。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#0-引言\" id=\"markdown-toc-0-引言\"\u003e0 引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#01-cilium-datapath-基础\" id=\"markdown-toc-01-cilium-datapath-基础\"\u003e0.1 Cilium datapath 基础\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#02-cilium-datapath-几个新变化\" id=\"markdown-toc-02-cilium-datapath-几个新变化\"\u003e0.2 Cilium datapath 几个新变化\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#03-本文提纲\" id=\"markdown-toc-03-本文提纲\"\u003e0.3 本文提纲\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-cgroup-v1v2-干扰问题\" id=\"markdown-toc-1-cgroup-v1v2-干扰问题\"\u003e1 cgroup v1/v2 干扰问题\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-普通节点v1v2-同时挂载没问题\" id=\"markdown-toc-11-普通节点v1v2-同时挂载没问题\"\u003e1.1 普通节点：v1/v2 同时挂载没问题\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-嵌套虚拟化节点\" id=\"markdown-toc-12-嵌套虚拟化节点\"\u003e1.2 嵌套虚拟化节点\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#121-kind-k8s-in-docker\" id=\"markdown-toc-121-kind-k8s-in-docker\"\u003e1.2.1 KIND (K8s-In-Docker)\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#122-kind-worker-node-cgroup-layout\" id=\"markdown-toc-122-kind-worker-node-cgroup-layout\"\u003e1.2.2 KIND-worker-node cgroup layout\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#123-带来的问题\" id=\"markdown-toc-123-带来的问题\"\u003e1.2.3 带来的问题\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-问题分析历史代码假设-v1v2-不会同时启用\" id=\"markdown-toc-13-问题分析历史代码假设-v1v2-不会同时启用\"\u003e1.3 问题分析：历史代码假设 v1/v2 不会同时启用\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-解决方案v1v2-字段拆开\" id=\"markdown-toc-14-解决方案v1v2-字段拆开\"\u003e1.4 解决方案：v1/v2 字段拆开\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-tcp-pacing\" id=\"markdown-toc-2-tcp-pacing\"\u003e2 TCP Pacing\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#20-基础\" id=\"markdown-toc-20-基础\"\u003e2.0 基础\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#201-tcp-pacing在每个-rtt-窗口内均匀发送数据\" id=\"markdown-toc-201-tcp-pacing在每个-rtt-窗口内均匀发送数据\"\u003e2.0.1 TCP Pacing（在每个 RTT 窗口内均匀发送数据）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#202-tcp-bbr-算法\" id=\"markdown-toc-202-tcp-bbr-算法\"\u003e2.0.2 TCP BBR 算法\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#203-tc-fq-fair-queue\" id=\"markdown-toc-203-tc-fq-fair-queue\"\u003e2.0.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e FQ (Fair Queue)\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#21-k8s-pod-限速\" id=\"markdown-toc-21-k8s-pod-限速\"\u003e2.1 K8s pod 限速\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-cilium-中-pod-egress-限速的实现\" id=\"markdown-toc-22-cilium-中-pod-egress-限速的实现\"\u003e2.2 Cilium 中 pod egress 限速的实现\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#设计原理\" id=\"markdown-toc-设计原理\"\u003e设计原理\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#工作流程\" id=\"markdown-toc-工作流程\"\u003e工作流程\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#23-下一步计划支持-tcp-pacing--bbr\" id=\"markdown-toc-23-下一步计划支持-tcp-pacing--bbr\"\u003e2.3 下一步计划：支持 TCP Pacing \u0026amp; BBR\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#231-目前无法支持的原因跨-netns-导致-skb-时间戳被重置\" id=\"markdown-toc-231-目前无法支持的原因跨-netns-导致-skb-时间戳被重置\"\u003e2.3.1 目前无法支持的原因：跨 netns 导致 skb 时间戳被重置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#232-为什么跨-netns-时skb-tstamp-要被重置\" id=\"markdown-toc-232-为什么跨-netns-时skb-tstamp-要被重置\"\u003e2.3.2 为什么跨 netns 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 要被重置\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#233-能将-skb-tstamp-统一到同一种时钟吗\" id=\"markdown-toc-233-能将-skb-tstamp-统一到同一种时钟吗\"\u003e2.3.3 能将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 统一到同一种时钟吗？\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#24-中场-qa-环节\" id=\"markdown-toc-24-中场-qa-环节\"\u003e2.4 中场 Q\u0026amp;A 环节\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#问题-1net_timestamp_check-功能是什么检查硬件是否设置了时间戳如果没有就加上\" id=\"markdown-toc-问题-1net_timestamp_check-功能是什么检查硬件是否设置了时间戳如果没有就加上\"\u003e问题 1：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_timestamp_check()\u003c/code\u003e 功能是什么？检查硬件是否设置了时间戳，如果没有就加上？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#问题-2这个时间戳相比于包从容器发出的时刻是有偏差的\" id=\"markdown-toc-问题-2这个时间戳相比于包从容器发出的时刻是有偏差的\"\u003e问题 2：这个时间戳相比于包从容器发出的时刻是有偏差的？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#问题-3用一个-bit-表示时间戳类型是否够\" id=\"markdown-toc-问题-3用一个-bit-表示时间戳类型是否够\"\u003e问题 3：用一个 bit 表示时间戳类型是否够？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#问题-4能否让-bpf-程序处理推迟-reset-timestamp-的操作\" id=\"markdown-toc-问题-4能否让-bpf-程序处理推迟-reset-timestamp-的操作\"\u003e问题 4：能否让 BPF 程序处理推迟 reset timestamp 的操作？\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#问题-5能否在-veth-加一个比特让我们能知道自己在处理-ingress-还是-egress-路径\" id=\"markdown-toc-问题-5能否在-veth-加一个比特让我们能知道自己在处理-ingress-还是-egress-路径\"\u003e问题 5：能否在 veth 加一个比特，让我们能知道自己在处理 ingress 还是 egress 路径？\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-自维护邻居managed-neighbor与-fib-扩展\" id=\"markdown-toc-3-自维护邻居managed-neighbor与-fib-扩展\"\u003e3 自维护邻居（managed neighbor）与 FIB 扩展\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-cilium-l4lb-处理逻辑\" id=\"markdown-toc-31-cilium-l4lb-处理逻辑\"\u003e3.1 Cilium L4LB 处理逻辑\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-邻居表的管理\" id=\"markdown-toc-32-邻居表的管理\"\u003e3.2 邻居表的管理\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#321-xdp-场景下的邻居解析\" id=\"markdown-toc-321-xdp-场景下的邻居解析\"\u003e3.2.1 XDP 场景下的邻居解析\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#322-当前的解析和管理方式\" id=\"markdown-toc-322-当前的解析和管理方式\"\u003e3.2.2 当前的解析和管理方式\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#323-当前管理方式存在的问题\" id=\"markdown-toc-323-当前管理方式存在的问题\"\u003e3.2.3 当前管理方式存在的问题\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#324-解决方案设想\" id=\"markdown-toc-324-解决方案设想\"\u003e3.2.4 解决方案：设想\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#325-解决方案调研\" id=\"markdown-toc-325-解决方案调研\"\u003e3.2.5 解决方案：调研\u003c/a\u003e            \u003cul\u003e\n              \u003cli\u003e\u003ca href=\"#ntf_use\" id=\"markdown-toc-ntf_use\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNTF_USE\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n              \u003cli\u003e\u003ca href=\"#ntf_ext_learned\" id=\"markdown-toc-ntf_ext_learned\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNTF_EXT_LEARNED\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n            \u003c/ul\u003e\n          \u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#326-解决方案引入一个新-flag-nud_managed\" id=\"markdown-toc-326-解决方案引入一个新-flag-nud_managed\"\u003e3.2.6 解决方案：引入一个新 flag \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNUD_MANAGED\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-fib-extensions-snat-时的-src_ip-选择\" id=\"markdown-toc-33-fib-extensions-snat-时的-src_ip-选择\"\u003e3.3 FIB extensions: SNAT 时的 SRC_IP 选择\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#331-node-有多个-ipsnatmasquerade-时的源地址选择问题\" id=\"markdown-toc-331-node-有多个-ipsnatmasquerade-时的源地址选择问题\"\u003e3.3.1 Node 有多个 IP：SNAT/Masquerade 时的源地址选择问题\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#332-解决方式\" id=\"markdown-toc-332-解决方式\"\u003e3.3.2 解决方式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-l4lb-节点多网卡service-转发时-egress-网卡的选择问题\" id=\"markdown-toc-34-l4lb-节点多网卡service-转发时-egress-网卡的选择问题\"\u003e3.4 L4LB 节点多网卡：Service 转发时 egress 网卡的选择问题\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#341-问题描述\" id=\"markdown-toc-341-问题描述\"\u003e3.4.1 问题描述\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#342-解决方案\" id=\"markdown-toc-342-解决方案\"\u003e3.4.2 解决方案\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-查询-bpf-map-时的通配符匹配问题\" id=\"markdown-toc-4-查询-bpf-map-时的通配符匹配问题\"\u003e4 查询 BPF map 时的通配符匹配问题\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-pcap-recorder-当前使用场景cilium-xdp-l4lb\" id=\"markdown-toc-41-pcap-recorder-当前使用场景cilium-xdp-l4lb\"\u003e4.1 PCAP recorder 当前使用场景：Cilium XDP L4LB\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-pcap-recorder-原理\" id=\"markdown-toc-42-pcap-recorder-原理\"\u003e4.2 PCAP recorder 原理\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-pcap-recorder-匹配规则\" id=\"markdown-toc-43-pcap-recorder-匹配规则\"\u003e4.3 PCAP recorder 匹配规则\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#431-recorder-组成\" id=\"markdown-toc-431-recorder-组成\"\u003e4.3.1 Recorder 组成\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#432-agent-职责\" id=\"markdown-toc-432-agent-职责\"\u003e4.3.2 Agent 职责\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-匹配规则当前的代码实现\" id=\"markdown-toc-44-匹配规则当前的代码实现\"\u003e4.4 匹配规则：当前的代码实现\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#45-当前实现的问题mask-集合不能太大否则开销太大\" id=\"markdown-toc-45-当前实现的问题mask-集合不能太大否则开销太大\"\u003e4.5 当前实现的问题：Mask 集合不能太大，否则开销太大\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#46-原生支持通配符匹配的-bpf-map\" id=\"markdown-toc-46-原生支持通配符匹配的-bpf-map\"\u003e4.6 原生支持通配符匹配的 BPF map\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-完场-qa-环节\" id=\"markdown-toc-5-完场-qa-环节\"\u003e5 完场 Q\u0026amp;A 环节\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#问题-6关于-wildcard-匹配算法\" id=\"markdown-toc-问题-6关于-wildcard-匹配算法\"\u003e问题 6：关于 wildcard 匹配算法\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#问题-7其中一些算法是不是有专利\" id=\"markdown-toc-问题-7其中一些算法是不是有专利\"\u003e问题 7：其中一些算法是不是有专利？\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#问题-8cilium-是否已经不需要-direct-interface-概念\" id=\"markdown-toc-问题-8cilium-是否已经不需要-direct-interface-概念\"\u003e问题 8：Cilium 是否已经不需要 direct interface 概念？\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#问题-9用-libpcap-将-cbpf-编译成-ebpf-是否可以解决你们不支持-port-range-的问题\" id=\"markdown-toc-问题-9用-libpcap-将-cbpf-编译成-ebpf-是否可以解决你们不支持-port-range-的问题\"\u003e问题 9：用 libpcap 将 cbpf 编译成 ebpf 是否可以解决你们不支持 port-range 的问题？\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-本文翻译时原作者特别更新\" id=\"markdown-toc-6-本文翻译时原作者特别更新\"\u003e6 本文翻译时，原作者特别更新\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-merged-cgroup-v1v2-patches\" id=\"markdown-toc-61-merged-cgroup-v1v2-patches\"\u003e6.1 Merged cgroup v1/v2 patches\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-merged-managed-neighbor-entries--fixes\" id=\"markdown-toc-62-merged-managed-neighbor-entries--fixes\"\u003e6.2 Merged managed neighbor entries \u0026amp; fixes\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#63-iproute2\" id=\"markdown-toc-63-iproute2\"\u003e6.3 iproute2\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#64-go-netlink-lib\" id=\"markdown-toc-64-go-netlink-lib\"\u003e6.4 go netlink lib\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#65-cilium-111-neighbor-rework-using-managed-neighbors-on-newer-kernels\" id=\"markdown-toc-65-cilium-111-neighbor-rework-using-managed-neighbors-on-newer-kernels\"\u003e6.5 Cilium 1.11 neighbor rework (using managed neighbors on newer kernels)\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e今天分享一些我们在开发 Cilium datapath 过程中遇到的有趣问题。\u003c/p\u003e\n\n\u003ch1 id=\"0-引言\"\u003e0 引言\u003c/h1\u003e\n\n\u003ch2 id=\"01-cilium-datapath-基础\"\u003e0.1 Cilium datapath 基础\u003c/h2\u003e\n\n\u003cp\u003eCilium BPF datapath 的设计与实现我们在过去几年已分享过多次，这里不再赘述。\n有需要请参考：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-scale-k8s-service-with-bpf-zh/\"\u003e利用 eBPF 支撑大规模 K8s Service (LPC, 2019)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-k8s-service-lb-zh/\"\u003e基于 BPF/XDP 实现 K8s Service 负载均衡 (LPC, 2020)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/advanced-bpf-kernel-features-for-container-age-zh/\"\u003e为容器时代设计的高级 eBPF 内核特性（FOSDEM, 2021）\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e接下来重点看下过去一年的几个新变化。\u003c/p\u003e\n\n\u003ch2 id=\"02-cilium-datapath-几个新变化\"\u003e0.2 Cilium datapath 几个新变化\u003c/h2\u003e\n\n\u003cp\u003e如下图所示，最近一年 Cilium 有一些新的变化：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cilium-service-lb.png\" width=\"95%\" height=\"95%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eCilium Service LB\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eCilium 不再只能作为普通 k8s 节点上的网络 agent，而可以作为\u003cstrong\u003e\u003cmark\u003e独立的四层负载均（L4LB）\u003c/mark\u003e\u003c/strong\u003e 节点运行了；\u003c/li\u003e\n  \u003cli\u003eService 负载均衡支持了\u003cstrong\u003e\u003cmark\u003e一致性哈希（Maglev 算法）\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e新引入了一个 \u003cstrong\u003e\u003cmark\u003epcap recorder\u003c/mark\u003e\u003c/strong\u003e，增强 LB 流量的可观测性；\u003c/li\u003e\n  \u003cli\u003e为 health probe 引入了一个新的 datapath extension；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e支持通过 \u003cstrong\u003e\u003cmark\u003eIPIP 封装\u003c/mark\u003e\u003c/strong\u003e转发 DSR 流量。\u003c/p\u003e\n\n    \u003cblockquote\u003e\n      \u003cp\u003e这是 1.10 的新特性，但这个“新特性”反而是回归到了传统 DSR（为了兼容客户的\n基础设施）。\u003cstrong\u003e\u003cmark\u003e在此之前，例如 1.9，Cilium 的 DSR 设计是非常巧妙的\u003c/mark\u003e\u003c/strong\u003e，\n无需隧道封装，也不要求 LB 节点和 backend 节点在同一个二层网络。有兴趣可参考：\n\u003ca href=\"/blog/k8s-l4lb/\"\u003eL4LB for Kubernetes: Theory and Practice with Cilium+BGP+ECMP\u003c/a\u003e。\n译注。\u003c/p\u003e\n    \u003c/blockquote\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e总体来说，Cilium BPF datapath 的\u003cstrong\u003e\u003cmark\u003e核心设计理念\u003c/mark\u003e\u003c/strong\u003e是：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e对于东西向流量，尽量靠近 socket 层处理；\u003c/li\u003e\n  \u003cli\u003e对于南北向流量，尽量靠近网卡驱动处理。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"03-本文提纲\"\u003e0.3 本文提纲\u003c/h2\u003e\n\n\u003cp\u003e本文接下来将介绍以下内容：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ecgroup v1/v2 干扰问题\u003c/li\u003e\n  \u003cli\u003eTCP pacing for Pods from initns\u003c/li\u003e\n  \u003cli\u003e自维护的邻居表项（neighbor entries）和 FIB 扩展\u003c/li\u003e\n  \u003cli\u003eBPF map 通配符查找\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"1-cgroup-v1v2-干扰问题\"\u003e1 cgroup v1/v2 干扰问题\u003c/h1\u003e\n\n\u003cp\u003e很多 Linux 发行版上\u003cstrong\u003e\u003cmark\u003e默认同时启用了 cgroup v1/v2\u003c/mark\u003e\u003c/strong\u003e，导致一些干扰问题。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e例如，\u003cstrong\u003e\u003cmark\u003e在 Ubuntu 20.04 上查看\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n  \u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003emount | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ecgroup\ncgroup2 on /sys/fs/cgroup/unified \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup2 \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,nsdelegate\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/systemd \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,xattr,name\u003cspan class=\"o\"\u003e=\u003c/span\u003esystemd\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ncgroup on /sys/fs/cgroup/blkio \u003cspan class=\"nb\"\u003etype \u003c/span\u003ecgroup \u003cspan class=\"o\"\u003e(\u003c/span\u003erw,nosuid,nodev,noexec,relatime,blkio\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e第一行表示挂载了 cgroupv2，后面几行表示挂载了（某些）cgroupv1。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"11-普通节点v1v2-同时挂载没问题\"\u003e1.1 普通节点：v1/v2 同时挂载没问题\u003c/h2\u003e\n\n\u003cp\u003e对于一台普通节点，同时挂载 cgroup v1/v2 后，它们在系统中的\u003cstrong\u003e\u003cmark\u003e典型布局\u003c/mark\u003e\u003c/strong\u003e（layout）将如下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e图中标出了哪些是 v1 挂载点，哪些是 v2 挂载点。简单来说：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ev1 是以 controller 维度挂载的，因此看到大部分文件（目录）都属于 cgroup v1；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ev2 是以进程维度挂载的单一层级树（unified hierarchy），因此顶层\u003cstrong\u003e\u003cmark\u003e只有一个挂载点\u003c/mark\u003e\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/unified\u003c/code\u003e）。\u003c/p\u003e\n\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e只有 v2 支持 attach bpf 程序\u003c/mark\u003e\u003c/strong\u003e，例如 hook \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econnect\u003c/code\u003e、\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebind\u003c/code\u003e 等系统调用；因此\n socket-level service LB 之类的代码，只能 attach 到 cgroup v2。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"/blog/bpf-advanced-notes-1-zh/\"\u003eBPF 进阶笔记（一）：BPF 程序（BPF Prog）类型详解：使用场景、函数签名、执行位置及程序示例\u003c/a\u003e\n在\u003cmark\u003e内核代码层面介绍了为什么 cgroup v2 支持 socket-level BPF\u003c/mark\u003e。\u003c/p\u003e\n\n  \u003cp\u003e另外，想深入了解 cgroup v1/v2 的区别，可参考\n\u003ca href=\"/blog/cgroupv2-zh/\"\u003e\u003cmark\u003e(译) Control Group v2（cgroupv2 权威指南）（KernelDoc, 2021）\u003c/mark\u003e\u003c/a\u003e。\n译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种\u003cstrong\u003e\u003cmark\u003e普通节点\u003c/mark\u003e\u003c/strong\u003e上，v1/v2 同时挂载是没问题的。下面再看一种\u003cstrong\u003e\u003cmark\u003e特殊节点\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"12-嵌套虚拟化节点\"\u003e1.2 嵌套虚拟化节点\u003c/h2\u003e\n\n\u003ch3 id=\"121-kind-k8s-in-docker\"\u003e1.2.1 KIND (K8s-In-Docker)\u003c/h3\u003e\n\n\u003cp\u003eKIND 是一个将 k8s 完全跑在容器里的项目 —— 包括 worker node —— 也就是说：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e先起一个或多个容器作为 k8s node，里面装上 kubelet、cilium-agent 等组件，然后\u003c/li\u003e\n  \u003cli\u003ekubelet 在这些 worker node\u003cstrong\u003e\u003cmark\u003e（容器）里再创创建容器\u003c/mark\u003e\u003c/strong\u003e（pod）。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e显然，这个项目的好处是\u003cstrong\u003e\u003cmark\u003e只需要一台真实 node\u003c/mark\u003e\u003c/strong\u003e（物理机或虚拟机），\n就能\u003cstrong\u003e\u003cmark\u003e搭建一个多 node k8s 集群\u003c/mark\u003e\u003c/strong\u003e，方便测试和开发。\u003c/p\u003e\n\n\u003ch3 id=\"122-kind-worker-node-cgroup-layout\"\u003e1.2.2 KIND-worker-node cgroup layout\u003c/h3\u003e\n\n\u003cp\u003e为方便讨论，先对两种 node 做一下名字上的区分，简单起见：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e将部署 KIND 的这台机器称为 \u003cstrong\u003e\u003cmark\u003ebm-node\u003c/mark\u003e\u003c/strong\u003e，虽然它可能是一台物理服务器，也可能是一台虚拟机；\u003c/li\u003e\n  \u003cli\u003e将 bm-node 内虚拟化出来的 worker node 称为 \u003cstrong\u003e\u003cmark\u003ek8s-node\u003c/mark\u003e\u003c/strong\u003e，这种 node 都是容器。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e有了以上区分，我们再来看 cgroup 的挂载情况：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e每个 k8s-node 内，看到的都是自己独立的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/\u003c/code\u003e 挂载点；而同时，\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e由于 \u003cstrong\u003e\u003cmark\u003ek8s-node 都是容器\u003c/mark\u003e\u003c/strong\u003e，因此它们的\u003cstrong\u003e\u003cmark\u003e文件路径又都会映射到 bm-node 上\u003c/mark\u003e\u003c/strong\u003e；\u003c/p\u003e\n\n    \u003cp\u003e具体来说，图中两个 k8s-node 的挂载点 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/\u003c/code\u003e，将分别\u003cstrong\u003e\u003cmark\u003e映射到 bm-node 的以下路径\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-a/\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-b/\u003c/code\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这种会导致什么问题呢？\u003c/p\u003e\n\n\u003ch3 id=\"123-带来的问题\"\u003e1.2.3 带来的问题\u003c/h3\u003e\n\n\u003cp\u003e考虑到：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ecilium-agent 运行在 k8s-node 内\u003c/li\u003e\n  \u003cli\u003ecilium-agent 会将 BPF 程序加载到\u003cstrong\u003e\u003cmark\u003e它的视角看到的 cgroup root 挂载点\u003c/mark\u003e\u003c/strong\u003e（即 k8s-node 中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/\u003c/code\u003e）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e那么，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ecilium-agent 在 \u003cstrong\u003e\u003cmark\u003ek8s-node 中 attach 的 BPF 程序\u003c/mark\u003e\u003c/strong\u003e，其实最终是 \u003cstrong\u003e\u003cmark\u003eattach 到了 bm-node\u003c/mark\u003e\u003c/strong\u003e\n  的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-a/\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-b/\u003c/code\u003e 路径下；\u003c/li\u003e\n  \u003cli\u003e而 \u003cstrong\u003e\u003cmark\u003eBPF 程序要能工作，必须 attach 到 bm-node 的 cgroup root 挂载点\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e因此，在这种嵌套虚拟化的场景下，我们的 BPF datapath 就失效了，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker-problem.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"13-问题分析历史代码假设-v1v2-不会同时启用\"\u003e1.3 问题分析：历史代码假设 v1/v2 不会同时启用\u003c/h2\u003e\n\n\u003cp\u003e先给一下背景介绍。\u003c/p\u003e\n\n\u003cp\u003ecgroup \u003cstrong\u003e\u003cmark\u003ev1 中某些控制器有 tagging 功能\u003c/mark\u003e\u003c/strong\u003e。例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003enet_prio 控制器会直接在 sock 上设置 一些属性，这样后面在\n\u003cstrong\u003e\u003cmark\u003etc qdisc 上就能根据这些 tags 过滤\u003c/mark\u003e\u003c/strong\u003e socket 和对流量进行分类。\u003c/li\u003e\n  \u003cli\u003enet_prio 控制器也是类似的，它的功能是给包设置优先级（priority），后面也是被 tc 使用。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e而在 v2 中，每个 \u003cstrong\u003e\u003cmark\u003esock 是关联到\u003c/mark\u003e\u003c/strong\u003e创建这个 sock 时\u003cstrong\u003e\u003cmark\u003e所在的 cgroup\u003c/mark\u003e\u003c/strong\u003e，\n在\u003cstrong\u003e\u003cmark\u003e网络层直接 match cgroup\u003c/mark\u003e\u003c/strong\u003e（而不是 socket 本身）。\u003c/p\u003e\n\n\u003cp\u003e引入 v2 之后，\u003cstrong\u003e\u003cmark\u003esocket cgroup 结构体\u003c/mark\u003e\u003c/strong\u003e \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_cgroup_data\u003c/code\u003e\n增加了另一个指针，指向 v2 object 对象。\n为避免结构体膨胀以及出于性能考虑，当时将这个结构体\u003cstrong\u003e\u003cmark\u003e改造成了 union，节省了 8 个字节\u003c/mark\u003e\u003c/strong\u003e，\n代码 diff 如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"gi\"\u003e+/*\n+ * sock_cgroup_data is embedded at sock-\u0026gt;sk_cgrp_data and contains\n+ * per-socket cgroup information except for memcg association.\n+ ...\n+\n\u003c/span\u003e struct sock_cgroup_data {\n\u003cspan class=\"gd\"\u003e-\tu16\tprioidx;\n-\tu32\tclassid;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\tunion {\n+#ifdef __LITTLE_ENDIAN\n+\t\tstruct {\n+\t\t\tu8\tis_data;\n+\t\t\tu8\tpadding;\n+\t\t\tu16\tprioidx;\n+\t\t\tu32\tclassid;\n+\t\t} __packed;\n+#else\n+\t\tstruct {\n+\t\t\tu32\tclassid;\n+\t\t\tu16\tprioidx;\n+\t\t\tu8\tpadding;\n+\t\t\tu8\tis_data;\n+\t\t} __packed;\n+#endif\n+\t\tu64\t\tval;\n+\t};\n\u003c/span\u003e };\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e改动之后的逻辑（来自源码注释）：\u003c/p\u003e\n\n  \u003cp\u003e启动时，sock_cgroup_data 会记录这个 sock 创建时它所在的 cgroup，因此后面可以直接匹配 v2；\n但如果 net_prio or net_cls 开始使用之后，这个字段就会被 v1 的 prioidx and/or\nclassid 所覆盖。区分这里存储的是 v1 还是 v2 数据的方式：根据 lowest bit\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e如果为 1：存储的就是 v1 的 prioidx 和 classid\u003c/li\u003e\n    \u003cli\u003e如果为 0：存储的就是 v2 cgroup 对象的指针\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e以上改动的假设是\u003c/mark\u003e\u003c/strong\u003e：\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=bd1060a1d67128bb8fbe2e1384c518912cbe54e7\"\u003ev1 和 v2 不会同时使用\u003c/a\u003e。\n一台机器要么使用 v1，要么使用 v2。但今天的实际情况是：v1 和 v2 同时挂载了。\n那么，在 fast path 上看起来是什么样的逻辑呢？\u003c/p\u003e\n\n\u003cp\u003e当执行 bpf 程序时，例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econnect\u003c/code\u003e 系统调用，socket bpf helper 会获取相应的 cgroup v2 对象，\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e例如，下面这两个系统调用：\u003c/p\u003e\n\n  \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBPF_CALL_1(bpf_skb_cgroup_id, skb)\n           |-__bpf_sk_cgroup_id(skb-\u0026gt;sk)\n              |-cgrp = sock_cgroup_ptr(\u0026amp;sk-\u0026gt;sk_cgrp_data)\n              |-return cgroup_id(cgrp)\n\nBPF_CALL_2(bpf_skb_ancestor_cgroup_id, skb, ancestor_level)\n           |-__bpf_sk_ancestor_cgroup_id(skb-\u0026gt;sk, ancestor_level)\n              |-cgrp = sock_cgroup_ptr(\u0026amp;sk-\u0026gt;sk_cgrp_data)\n              |-ancestor = cgroup_ancestor(cgrp, ancestor_level)\n              |-return cgroup_id(ancestor)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003ehelper 最终会调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esock_cgroup_ptr()\u003c/code\u003e，注意这个函数只会被 cgroup v2 调用：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/include/linux/cgroup.h#L828\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kr\"\u003einline\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecgroup\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"nf\"\u003esock_cgroup_ptr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock_cgroup_data\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskcd\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID) // 说明使用了 v1\n\u003c/span\u003e    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e                                                      \u003cspan class=\"c1\"\u003e// 而这个函数只会被 v2 使用\u003c/span\u003e\n                                                                          \u003cspan class=\"c1\"\u003e// 因此接下来要获取 v2 的 root 地址\u003c/span\u003e\n    \u003cspan class=\"cm\"\u003e/*\n     * @skcd-\u0026gt;val is 64bit but the following is safe on 32bit too as we\n     * just need the lower ulong to be written and read atomically.\n     */\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eREAD_ONCE\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskcd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e                      \u003cspan class=\"c1\"\u003e// 如果这个 socket 上使用了 cgroup v1 tagging，则\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecgrp_dfl_root\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecgrp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// fallback 到 cgroup v2 default root\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecgroup\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"o\"\u003e?:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecgrp_dfl_root\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecgrp\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#else\n\u003c/span\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecgroup\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eskcd\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003eval\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"cp\"\u003e#endif\n\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果有 cgroup v1 tag，就会 fallback 到 cgroup v2 default root。\n如果 v1/v2 不同时使用，那没问题，但同时使用了之后，会怎么样了呢？\u003c/p\u003e\n\n\u003cp\u003e因为必须 fallback 到 v2。在 bm-node 上，对应的就是\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-a/\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/docker-node-b/\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e等目录。而 bm-node 上的 cgroup v2 hook 是监听在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/fs/cgroup/\u003c/code\u003e 下面的。这意味着\nk8s-node 内的路径会被 bypass。或者说，像 cilium agent 这样 attach 到 root 的行\n为，在 k8s-node 内做不了任何事情的。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cgroupv2-layout-k8s-in-docker-problem.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到，管理 v2 是非常复杂和脆弱的，例如，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e对 cgroup namespaces 或 non-root cgroup paths 的不兼容\u003c/p\u003e\n\n    \u003cp\u003eattach 到 root 就会遇到这个问题。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e在 socket 层做 v2-\u0026gt;v1 的转换，会泄露 v2 对象的引用\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e\u003cmark\u003ev2 不可靠的唤醒机制\u003c/mark\u003e\u003c/strong\u003e（unreliable v2 invocation）使 bpf 程序的普及遇到问题\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e第三方 agents 都在加载 bpf 程序，\u003c/li\u003e\n      \u003cli\u003e发行版为了最大兼容性，会把能打开的功能全打开。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"14-解决方案v1v2-字段拆开\"\u003e1.4 解决方案：v1/v2 字段拆开\u003c/h2\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e struct sock_cgroup_data {\n\u003cspan class=\"gd\"\u003e-\tunion {\n-#ifdef __LITTLE_ENDIAN\n-\t\tstruct {\n-\t\t\tu8\tis_data : 1;\n-\t\t\tu8\tno_refcnt : 1;\n-\t\t\tu8\tunused : 6;\n-\t\t\tu8\tpadding;\n-\t\t\tu16\tprioidx;\n-\t\t\tu32\tclassid;\n-\t\t} __packed;\n-#else\n-\t\tstruct {\n-\t\t\tu32\tclassid;\n-\t\t\tu16\tprioidx;\n-\t\t\tu8\tpadding;\n-\t\t\tu8\tunused : 6;\n-\t\t\tu8\tno_refcnt : 1;\n-\t\t\tu8\tis_data : 1;\n-\t\t} __packed;\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\tstruct cgroup\t*cgroup; /* v2 */\n+#ifdef CONFIG_CGROUP_NET_CLASSID\n+\tu32\t\tclassid; /* v1 */\n+#endif\n+#ifdef CONFIG_CGROUP_NET_PRIO\n+\tu16\t\tprioidx; /* v1 */\n\u003c/span\u003e #endif\n\u003cspan class=\"gd\"\u003e-\t\tu64\t\tval;\n-\t};\n\u003c/span\u003e };\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-diff highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e static inline struct cgroup *sock_cgroup_ptr(struct sock_cgroup_data *skcd)\n {\n\u003cspan class=\"gd\"\u003e-#if defined(CONFIG_CGROUP_NET_PRIO) || defined(CONFIG_CGROUP_NET_CLASSID)\n-\tunsigned long v;\n-\n-\t/*\n-\t * @skcd-\u0026gt;val is 64bit but the following is safe on 32bit too as we\n-\t * just need the lower ulong to be written and read atomically.\n-\t */\n-\tv = READ_ONCE(skcd-\u0026gt;val);\n-\n-\tif (v \u0026amp; 3)\n-\t\treturn \u0026amp;cgrp_dfl_root.cgrp;\n-\n-\treturn (struct cgroup *)(unsigned long)v ?: \u0026amp;cgrp_dfl_root.cgrp;\n-#else\n-\treturn (struct cgroup *)(unsigned long)skcd-\u0026gt;val;\n-#endif\n\u003c/span\u003e\u003cspan class=\"gi\"\u003e+\treturn skcd-\u0026gt;cgroup;\n\u003c/span\u003e }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e永远返回可靠的 cgroup 指针： \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estruct sock_cgroup_data\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e还顺便解决了 v2 引用的泄露问题\u003c/li\u003e\n  \u003cli\u003e已经\u003ca href=\"https://lore.kernel.org/bpf/20210913230759.2313-1-daniel@iogearbox.net/\"\u003e提交\u003c/a\u003e到社区\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1 id=\"2-tcp-pacing\"\u003e2 TCP Pacing\u003c/h1\u003e\n\n\u003ch2 id=\"20-基础\"\u003e2.0 基础\u003c/h2\u003e\n\n\u003cp\u003e本小节为译注，方便大家理解后面的内容。有基础的可以跳过。\u003c/p\u003e\n\n\u003ch3 id=\"201-tcp-pacing在每个-rtt-窗口内均匀发送数据\"\u003e2.0.1 TCP Pacing（在每个 RTT 窗口内均匀发送数据）\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ca href=\"https://homes.cs.washington.edu/~tom/pubs/pacing.pdf\"\u003eUnderstanding the Performance of TCP Pacing\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003eTCP’s congestion control  mechanisms  can lead  to  bursty  traffic  flows\non  modern  high-speednetworks,  with  a negative  impact  on  overall\nnetwork  efficiency.   A  pro-posed solution to this problem is to\n\u003cstrong\u003e\u003cmark\u003eevenly space, or “pace”, data sent intothe network  over  an entire round-trip  time\u003c/mark\u003e\u003c/strong\u003e,\nso that  data is  not  sent  in  aburst.  In this paper, we quantitatively evaluate this approach.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"202-tcp-bbr-算法\"\u003e2.0.2 TCP BBR 算法\u003c/h3\u003e\n\n\u003cp\u003eGoogle 提出的一种 TCP 流控算法。Linux 内核已经支持。\u003c/p\u003e\n\n\u003ch3 id=\"203-tc-fq-fair-queue\"\u003e2.0.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etc\u003c/code\u003e FQ (Fair Queue)\u003c/h3\u003e\n\n\u003cp\u003e内容来自 \u003ca href=\"https://man7.org/linux/man-pages/man8/tc-fq.8.html\"\u003etc-fq(8)\u003c/a\u003e manpage。\u003c/p\u003e\n\n\u003cp\u003eFQ (Fair Queue) 是一个 \u003cstrong\u003e\u003cmark\u003eclassless packet scheduler\u003c/mark\u003e\u003c/strong\u003e，设计主要用于\u003cstrong\u003e\u003cmark\u003e本地生成的流量\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e设计中，能获得 per-flow pacing。\u003c/li\u003e\n  \u003cli\u003eFQ 会对 flow 进行 separation，支持 TCP 协议栈设置的 pacing 要求。\u003c/li\u003e\n  \u003cli\u003e所有属于某个 socket 的包，认为是一条 flow。\u003c/li\u003e\n  \u003cli\u003e对于非本地流量（router workload），会使用 packet hash 作为 fallback 方式。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e使用方式：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e应用可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetsockopt(SO_MAX_PACING_RATE)\u003c/code\u003e 来指定最大 pacing 速率。\u003c/li\u003e\n  \u003cli\u003eFQ 会\u003cstrong\u003e\u003cmark\u003e在包之间加入延迟\u003c/mark\u003e\u003c/strong\u003e来达到这个 socket 设置的 rate limitation。\u003c/li\u003e\n  \u003cli\u003e在 Linux 4.20 之后，内核\u003cstrong\u003e\u003cmark\u003e采用了 EDT\u003c/mark\u003e\u003c/strong\u003e (Earliest Departure Time) 算法，\n  TCP 也能直接为每个 skb 设置合适的 Departure Time。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e内部设计：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e以 round-robin 方式从 queue dequeue 待发送的数据包；\u003c/li\u003e\n  \u003cli\u003e对于高优先级（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_PRIO_CONTROL\u003c/code\u003e priority）包，预留了一个特殊的 FIFO queue，确保包永远会先被 dequeue。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eFQ is 不是 \u003cstrong\u003e\u003cmark\u003ework-conserving\u003c/mark\u003e\u003c/strong\u003e 类型的。更多信息可参考\n\u003ca href=\"/blog/traffic-control-from-queue-to-edt-zh/\"\u003e(译) 流量控制（TC）五十年：从基于缓冲队列（Queue）到基于时间戳（EDT）的演进（Google, 2018）\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003eTCP pacing 对于有 idle time 的 flow 来说比较有用，因为拥塞窗口允许\nTCP stack 将可能非常多的包一次性插入队列。\nThis removes the ‘slow start after idle’ choice, badly\nhitting large BDP (Bandwidth-delay product) flows and applications delivering chunks of\ndata such as video streams.\u003c/p\u003e\n\n\u003cp\u003e例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc qdisc add dev eth0 root fq ce_threshold 4ms\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc \u003cspan class=\"nt\"\u003e-s\u003c/span\u003e \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e qdisc show dev eth0\nqdisc fq 8001: dev eth0 root refcnt 2 limit 10000p flow_limit 100p buckets 1024 orphan_mask 1023 quantum 3028b initial_quantum 15140b low_rate_threshold 550Kbit refill_delay 40.0ms ce_threshold 4.0ms\nSent 72149092 bytes 48062 pkt \u003cspan class=\"o\"\u003e(\u003c/span\u003edropped 2176, overlimits 0 requeues 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nbacklog 1937920b 1280p requeues 0\n  flows 34 \u003cspan class=\"o\"\u003e(\u003c/span\u003einactive 17 throttled 0\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n  gc 0 highprio 0 throttled 0 ce_mark 47622 flows_plimit 2176\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下面回到原作者分享内容。\u003c/p\u003e\n\n\u003ch2 id=\"21-k8s-pod-限速\"\u003e2.1 K8s pod 限速\u003c/h2\u003e\n\n\u003cp\u003eK8s 模型中可以通过给 pod 打上 ingress/egress bandwidth annotation 对容器进行限速，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e具体实现交给 k8s CNI plugin（例如，\u003ca href=\"https://cilium.io/blog/2020/11/10/cilium-19#bwmanager\"\u003eCilium\u003c/a\u003e\n或 \u003ca href=\"https://www.cni.dev/plugins/current/meta/bandwidth/\"\u003ebandwidth plugin\u003c/a\u003e）\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e怎么实现由插件自己决定，例如：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eK8s bandwidth plugin 组合了 ifb \u0026amp; tbf qdisc\u003c/li\u003e\n      \u003cli\u003eCilium 通过 \u003cstrong\u003e\u003cmark\u003eBPF \u0026amp; FQ qdisc\u003c/mark\u003e\u003c/strong\u003e，原生实现了 egress 限速\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"22-cilium-中-pod-egress-限速的实现\"\u003e2.2 Cilium 中 pod egress 限速的实现\u003c/h2\u003e\n\n\u003ch3 id=\"设计原理\"\u003e设计原理\u003c/h3\u003e\n\n\u003cp\u003eCilium attach 到宿主机的物理网卡（或 bond 设备），在 BPF 程序中为每个包设置 timestamp，\n然后通过 earliest departure time 在 fq 中实现限速，下图：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e注意：容器限速是在\u003cstrong\u003e\u003cmark\u003e物理网卡\u003c/mark\u003e\u003c/strong\u003e上做的，而不是在每个 pod 的 veth 设备上。这跟之前基于 ifb 的限速方案有很大不同。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/pod-egress-rate-limit.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Cilium 基于 BPF+EDT 的容器限速方案（逻辑架构）\u003c/p\u003e\n\n\u003cp\u003e从上到下三个步骤：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eBPF 程序\u003c/mark\u003e\u003c/strong\u003e：管理（计算和设置） skb 的 departure timestamp；\u003c/li\u003e\n  \u003cli\u003eTC \u003cstrong\u003e\u003cmark\u003eqdisc (multi-queue) 发包调度\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e物理网卡的队列\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e如果宿主机使用了 bond，那么\u003cstrong\u003e\u003cmark\u003e根据 bond 实现方式的不同，FQ 的数量会不一样\u003c/mark\u003e\u003c/strong\u003e，\n可通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003etc -s -d qdisc show dev {bond}\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 查看实际状态。具体来说，\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eLinux bond \u003ca href=\"https://www.kernel.org/doc/Documentation/networking/bonding.txt\"\u003e默认支持多队列（multi-queue），会默认创建 16 个 queue\u003c/a\u003e，\n每个 queue 对应一个 FQ，挂在一个 MQ 下面，也就是上面图中画的；\u003c/li\u003e\n    \u003cli\u003eOVS bond 不支持 MQ，因此只有一个 FQ（v2.3 等老版本行为，新版本不清楚）。\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003ebond 设备的 TXQ 数量，可以通过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003els /sys/class/net/{dev}/queues/\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 查看。\n物理网卡的 TXQ 数量也可以通过以上命令看，但 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eethtool -l {dev}\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\n看到的信息更多，包括了最大支持的数量和实际启用的数量。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"工作流程\"\u003e工作流程\u003c/h3\u003e\n\n\u003cp\u003e先复习下 Cilium datapath，细节见去年的分享：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-forwarding.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eegress 限速工作流程：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-works-today.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ePod egress 流量从容器进入宿主机，此时会发生 \u003cstrong\u003e\u003cmark\u003enetns 切换\u003c/mark\u003e\u003c/strong\u003e，但 socket 信息 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;sk\u003c/code\u003e 不会丢失；\u003c/li\u003e\n  \u003cli\u003eHost veth 上的 BPF 标记（marking）包的 aggregate（queue_mapping），见 \u003ca href=\"https://github.com/cilium/cilium/blob/v1.10/bpf/lib/edt.h\"\u003eCilium 代码\u003c/a\u003e；\u003c/li\u003e\n  \u003cli\u003e物理网卡上的 BPF 程序根据 aggregate 设置的限速参数，设置每个包的时间戳 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003eFQ+MQ 根据 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 调度发包。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e过程中用\u003cstrong\u003e\u003cmark\u003e到了 bpf map 存储 aggregate 信息\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"23-下一步计划支持-tcp-pacing--bbr\"\u003e2.3 下一步计划：支持 TCP Pacing \u0026amp; BBR\u003c/h2\u003e\n\n\u003cp\u003e以上流程是没问题的。接下来我们想做的是，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e允许 pod 内的 socket 定义自己的 max pacing rate\u003c/mark\u003e\u003c/strong\u003e，或\u003c/li\u003e\n  \u003cli\u003e允许\u003cstrong\u003e\u003cmark\u003e使用 BBR TCP 流控算法\u003c/mark\u003e\u003c/strong\u003e —— 该算法内部也会用到 pacing。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e想在物理网卡上默认 netns 实现这个功能。\n但这个功能目前还是做不到的。\u003c/p\u003e\n\n\u003ch3 id=\"231-目前无法支持的原因跨-netns-导致-skb-时间戳被重置\"\u003e2.3.1 目前无法支持的原因：跨 netns 导致 skb 时间戳被重置\u003c/h3\u003e\n\n\u003cp\u003e如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e在\u003cstrong\u003e\u003cmark\u003e切换 netns 时，skb-\u0026gt;tstamp 会被重置\u003c/mark\u003e\u003c/strong\u003e，因此物理网卡上的\n\u003cstrong\u003e\u003cmark\u003eFQ 看不到时间戳，无法做限速\u003c/mark\u003e\u003c/strong\u003e（无法计算状态）。\n下面是设置 4Gbps 限速所做的测试，会发现完全不稳定：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps-2.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e我们做了个 POC 来保持 egress timestamp ，在切 netns 时不要重置它，\n然后就非常稳定了：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/datapath-next-steps-3.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"232-为什么跨-netns-时skb-tstamp-要被重置\"\u003e2.3.2 为什么跨 netns 时，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 要被重置\u003c/h3\u003e\n\n\u003cp\u003e下面介绍一些背景，为什么这个 ts 会被重置。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e几种时间规范：https://www.cl.cam.ac.uk/~mgk25/posix-clocks.html\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e对于包的时间戳 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e，内核\u003cstrong\u003e\u003cmark\u003e根据包的方向（RX/TX）不同而使用的两种时钟源\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eIngress 使用 CLOCK_TAI\u003c/mark\u003e\u003c/strong\u003e (TAI: international atomic time)\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eEgress 使用 CLOCK_MONOTONIC\u003c/mark\u003e\u003c/strong\u003e（也是 \u003cstrong\u003e\u003cmark\u003eFQ 使用的时钟类型\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e如果不重置，将包\u003cstrong\u003e\u003cmark\u003e从 RX 转发到 TX 会导致包在 FQ 中被丢弃\u003c/mark\u003e\u003c/strong\u003e，因为\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L463\"\u003e超过 FQ 的 drop horizon\u003c/a\u003e。\nFQ \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehorizon\u003c/code\u003e \u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L950\"\u003e默认是 10s\u003c/a\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehorizon\u003c/code\u003e 是 FQ 的一个配置项，表示一个时间长度，\n在 \u003ca href=\"https://github.com/torvalds/linux/commit/39d010504e6b\"\u003enet_sched: sch_fq: add horizon attribute\u003c/a\u003e 引入，\u003c/p\u003e\n\n  \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eQUIC servers would like to use SO_TXTIME, without having CAP_NET_ADMIN,\nto efficiently pace UDP packets.\n\nAs far as sch_fq is concerned, we need to add safety checks, so\nthat a buggy application does not fill the qdisc with packets\nhaving delivery time far in the future.\n\nThis patch adds a configurable horizon (default: 10 seconds),\nand a configurable policy when a packet is beyond the horizon\nat enqueue() time:\n- either drop the packet (default policy)\n- or cap its delivery time to the horizon.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e简单来说，如果一个\u003cstrong\u003e\u003cmark\u003e包的时间戳离现在太远，就直接将这个包\n丢弃，或者将其改为一个上限值\u003c/mark\u003e\u003c/strong\u003e（cap），以便节省队列空间；否则，这种\n包太多的话，队列可能会被塞满，导致时间戳比较近的包都无法正常处理。\n\u003ca href=\"https://github.com/torvalds/linux/blob/v5.10/net/sched/sch_fq.c#L436\"\u003e内核代码\u003c/a\u003e如下：\u003c/p\u003e\n\n  \u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003ebool\u003c/span\u003e \u003cspan class=\"nf\"\u003efq_packet_beyond_horizon\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003efq_sched_data\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eunlikely\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"n\"\u003es64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003etstamp\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003es64\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ektime_cache\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ehorizon\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e  \u003c/div\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e另外，现在给定一个包，我们\u003cstrong\u003e\u003cmark\u003e无法判断它用的是哪种 timestamp\u003c/mark\u003e\u003c/strong\u003e，因此只能用这种 reset 方式。\u003c/p\u003e\n\n\u003ch3 id=\"233-能将-skb-tstamp-统一到同一种时钟吗\"\u003e2.3.3 能将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e 统一到同一种时钟吗？\u003c/h3\u003e\n\n\u003cp\u003e其实最开始，TCP \u003cstrong\u003e\u003cmark\u003eEDT 用的也是 CLOCK_TAI 时钟\u003c/mark\u003e\u003c/strong\u003e。\n但有人在\u003ca href=\"https://lore.kernel.org/netdev/2185d09d-90e1-81ef-7c7f-346eeb951bf4@gmail.com/\"\u003e邮件列表\u003c/a\u003e\n里反馈说，某些特殊的嵌入式设备上重启会导致时钟漂移 50 多年。所以后来\n\u003cstrong\u003e\u003cmark\u003eEDT 又回到了 monotonic 时钟\u003c/mark\u003e\u003c/strong\u003e，而我们必须跨 netns 时 reset。\u003c/p\u003e\n\n\u003cp\u003e我们做了个原型验证，新加一个 bit \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp_base\u003c/code\u003e 来解决这个问题，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e0 表示使用的 TAI，\u003c/li\u003e\n  \u003cli\u003e1 表示使用的 MONO，\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e然后，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eTX/RX 通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb_set_tstamp_{mono,tai}(skb, ktime)\u003c/code\u003e helper 来获取这个值，\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003efq_enqueue()\u003c/code\u003e 先检查 timestamp 类型，如果不是 MONO，就 reset \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e此外，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e转发逻辑中所有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eskb-\u0026gt;tstamp = 0\u003c/code\u003e 都可以删掉了\u003c/li\u003e\n  \u003cli\u003eskb_mstamp_ns union 也可能删掉了\u003c/li\u003e\n  \u003cli\u003e在 RX 方向，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_timestamp_check()\u003c/code\u003e 必须推迟到 tc ingress 之后执行\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"24-中场-qa-环节\"\u003e2.4 中场 Q\u0026amp;A 环节\u003c/h2\u003e\n\n\u003ch3 id=\"问题-1net_timestamp_check-功能是什么检查硬件是否设置了时间戳如果没有就加上\"\u003e问题 1：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet_timestamp_check()\u003c/code\u003e 功能是什么？检查硬件是否设置了时间戳，如果没有就加上？\u003c/h3\u003e\n\n\u003cp\u003e是的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e那为什么它必须要推迟到 tc ingress 之后执行？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e流量跨 netns 从 pod 出去后，就\u003cstrong\u003e\u003cmark\u003e重新进入了 RX 路径\u003c/mark\u003e\u003c/strong\u003e，其中会执行主\nreceive 方法，后者也会调用这个函数，就会将时间戳覆盖掉。\u003c/p\u003e\n\n\u003cp\u003e为了保留 skb 上的 monotonic clock，以便将它\u003cstrong\u003e\u003cmark\u003e从 tc ingress 一路带给给物理网卡\u003c/mark\u003e\u003c/strong\u003e（FQ 依据这个做限速），\n我们就必须在 tc ingress 之后的位置调用这个函数。\u003c/p\u003e\n\n\u003ch3 id=\"问题-2这个时间戳相比于包从容器发出的时刻是有偏差的\"\u003e问题 2：这个时间戳相比于包从容器发出的时刻是有偏差的？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e这么说来，这个时间戳相比于包从容器发出的时刻，其实是有一点偏差的？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e理论上是的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e不知道这个延迟是否很明显？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e（Daniel 好像走神了，没回答。）\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e不过我觉得你们实现这套新机制已经很不错了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"问题-3用一个-bit-表示时间戳类型是否够\"\u003e问题 3：用一个 bit 表示时间戳类型是否够？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e我在考虑只用一个 bit 是否够，例如，现在已经有新的 time namespace。\n不确定当前容器能否有自己独立的 time namespace，如果有的话，即使是\nmonotonic time 这个 namespace 内也将是独立的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e理解。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e但我不确定现在的是否有合适的 helpers 来，例如，在包从一个 namespace 进入另一\n个 namespace 时，我们是否有方式来对这个时间戳做转换，变成当前 namespace 内的视角。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这一点很好，我之前没想到过，后面我会关注一下，也许会放到 issues 列表。\n但据我所知目前没有这样的转换方式，也没有办法将一个 monotonic clock 转换 TAI。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e我记得是 intel 还是哪个公司将 timstamp 加到 skb 时，他们曾提议在 skb 包含这样的\n能区分出时钟源的 bits；而我们现在再次为了这一目的而努力。我相信只要我们有充分的使\n用场景，就能将这个改动合并到社区。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e是的。\u003c/p\u003e\n\n\u003ch3 id=\"问题-4能否让-bpf-程序处理推迟-reset-timestamp-的操作\"\u003e问题 4：能否让 BPF 程序处理推迟 reset timestamp 的操作？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e前面的 POC 改动了内核代码来推迟 reset timestamp。我的问题是，\n能否将这个逻辑放到 BPF 程序里去做？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个问题也很好，我最开始也是这么做（hack）的。不过我觉得这个改动无法合并到内核，因为太丑陋了，\n你仍然需要一些方式来避免在 scrub skb 时清掉 timestamp，例如在切换 netns 时就会遇到这种情况。\n因此彻底解决这个问题就需要一种不是那么 hacky 但又有效的方式。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e能否在容器内 attach 一段 BPF 程序，在里面实现 disable scrubing，或者将信息\ncopy 到 cb (control buffer) 之类的地方（然后在宿主机端再取出来）？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e从我个人来说，我避免在 pod namespace 内管理任何事情，因此我不希望在容器内 attach bpf 程序。\n我希望无需两个 netns 的任何协作这件事情就能完成，或者说宿主机侧自己就能完成这件事情。\u003c/p\u003e\n\n\u003ch3 id=\"问题-5能否在-veth-加一个比特让我们能知道自己在处理-ingress-还是-egress-路径\"\u003e问题 5：能否在 veth 加一个比特，让我们能知道自己在处理 ingress 还是 egress 路径？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e流量永远会经过 veth 设备对吗？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e对的。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e那能否在 veth 设备设置一个 bit，在包出来时，使我们能分辨出自己在 ingress 路径上处理这个包？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这也是一种方式。\u003c/p\u003e\n\n\u003cp\u003e但我认为这种方式太丑陋了，因为你要如何配置这个东西呢？而且这里涉及了太多实现细节，\n我们真的要将如此细节的东西（要不要清除一个 bit）暴露出来吗？我认为这种方式不够简洁。\u003c/p\u003e\n\n\u003cp\u003e时间有限，我们先继续下面的内容，其他问题可以会后再继续讨论。\u003c/p\u003e\n\n\u003ch1 id=\"3-自维护邻居managed-neighbor与-fib-扩展\"\u003e3 自维护邻居（managed neighbor）与 FIB 扩展\u003c/h1\u003e\n\n\u003ch2 id=\"31-cilium-l4lb-处理逻辑\"\u003e3.1 Cilium L4LB 处理逻辑\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/cilium-xdp-lb.png\" width=\"90%\" height=\"90%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eCilium L4LB 或其他基于 XDP 的负载均衡器，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e都位于流量中间路径上，交换机通过 ECMP 算法将流量转发给 LB 节点，LB 节点再转发给后端；\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eLB 收到的流量通常目的地址都是 ServiceIP，\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003eBPF 处理逻辑：通过 \u003cstrong\u003e\u003cmark\u003eDNAT+SNAT\u003c/mark\u003e\u003c/strong\u003e 或 \u003cstrong\u003e\u003cmark\u003eDSR+IPIP/IP6IP6\u003c/mark\u003e\u003c/strong\u003e 将流量转发到后端 pod\u003c/li\u003e\n      \u003cli\u003e两种处理方式中，外层 IP 头的 dst_ip 都是 backendIP（pod ip）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e两种情况下，都是\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e利用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_fib_lookup()\u003c/code\u003e helper 函数顺便解析 neighbor 地址\u003c/li\u003e\n  \u003cli\u003ePushed back out via XDP_TX (对 phys/bond 设备来说是透明的)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以上转发，需要用到\u003cstrong\u003e\u003cmark\u003e后端的 IP 和 MAC 地址信息\u003c/mark\u003e\u003c/strong\u003e，因此涉及到 neighbor/fib 管理。\u003c/p\u003e\n\n\u003ch2 id=\"32-邻居表的管理\"\u003e3.2 邻居表的管理\u003c/h2\u003e\n\n\u003ch3 id=\"321-xdp-场景下的邻居解析\"\u003e3.2.1 XDP 场景下的邻居解析\u003c/h3\u003e\n\n\u003cp\u003e首先需要知道，\u003cstrong\u003e\u003cmark\u003eXDP 中是无法做邻居解析的\u003c/mark\u003e\u003c/strong\u003e，因此\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003eneighbor entry 必须由更上层来解析，然后插入到邻居表\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e具体实现就是发送 ARP 请求，获取 MAC 地址。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"322-当前的解析和管理方式\"\u003e3.2.2 当前的解析和管理方式\u003c/h3\u003e\n\n\u003cp\u003e当前的邻居解析是由 cilium-agent 来做的。但这里是我们的一个痛点，如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/neighbor-mgnt-1.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e所有 agent 监听 kube-apiserver node create 事件，\u003c/li\u003e\n  \u003cli\u003e对于新 node，agent 发送 ARP 请求解析 MAC 地址，\u003c/li\u003e\n  \u003cli\u003e把解析到的地址作为一条永久记录（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNUD_PERMANENT\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）插入到邻居表。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e需要定期解析，以便即使删除不可用的表项：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/neighbor-mgnt-2.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003ch3 id=\"323-当前管理方式存在的问题\"\u003e3.2.3 当前管理方式存在的问题\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e需要定期解析，目前我们是 5 分钟一次。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e逻辑上存在 bug：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e考虑 kube-apiserver node，它们也各自对应一条 NUD_PERMANENT 记录；如果在\n\u003cstrong\u003e\u003cmark\u003eagent 重启时，kube-apiserver 地址变了\u003c/mark\u003e\u003c/strong\u003e（小概率但可能发生），那所有 node\n就都访问不到这台 kube-apiserver 了。\u003c/li\u003e\n      \u003cli\u003e本机\u003cstrong\u003e\u003cmark\u003e协议栈不会根据收发的流量自动更新这些 entry\u003c/mark\u003e\u003c/strong\u003e，因为这条 entry 是永久的，由外部管理的。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003eagent 是在重复内核 net/ipv4/arp.c 的逻辑；\u003c/li\u003e\n  \u003cli\u003e需要为 IPv6 ND 实现一套类似机制。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e早期一些的版本，例如 1.9.5 之前，邻居的定期解析比较激进，可能导致意想不到的问题。\n从 1.8.4 (customized) 升级到 1.9.5 (customized) 之后，我们曾收到一些偶发到网关超时的报障。\u003c/p\u003e\n\n  \u003cp\u003e基本背景：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e某个老数据中心，基于接入-汇聚-核心网络架构\u003c/li\u003e\n    \u003cli\u003e同时支撑两种虚拟网络：Cilium+BGP 三层网络和 VLAN 二层网络；对于后者，实例（VM/Container）的网关全在核心交换机\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e故障现象：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e报障的全是二层网络的实例，现象是到网关偶发不通，严重时持续时长在一分钟以上\u003c/li\u003e\n    \u003cli\u003e情况有越来越严重的趋势\u003c/li\u003e\n    \u003cli\u003e与 Cilium 升级时间吻合\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003e排查后发现确实是升级 Cilium 导致的：一台 cilium node 给核心交换机大致增加了 15pps 的入向 ARP 流量。\n随着升级的 node 不断增加，当入向 ARP 从 1kpps 上升到 6kpps 时，\u003cstrong\u003e\u003cmark\u003e交换机 ARP 响应时间从 10ms 急\n剧上升到 500ms\u003c/mark\u003e\u003c/strong\u003e —— 这种情况下，基于 Cilium+BGP 的网络没有问题，但\n二层网络的那些应用（例如 OpenStack 实例）就可能遇到网关超时。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"324-解决方案设想\"\u003e3.2.4 解决方案：设想\u003c/h3\u003e\n\n\u003cp\u003e设想还是让\u003cstrong\u003e\u003cmark\u003e控制平面\u003c/mark\u003e\u003c/strong\u003e（这里就是 cilium agent）做这个事情，要求：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e基于 netlink 查找路由\u003c/mark\u003e\u003c/strong\u003e：这个 backendIP 是在同一个 L2 网络，还是要通过 GW IP？\u003c/li\u003e\n  \u003cli\u003e将 \u003cstrong\u003e\u003cmark\u003eL3 地址（不带 L2 地址）写到邻居表\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e然后，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e内核邻居子系统将自动解析邻居地址\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003e邻居子系统也会将这个地址一直保持在 reachable 状态，\u003c/li\u003e\n  \u003cli\u003e我们也有方式\u003cstrong\u003e\u003cmark\u003e配置不要对这种地址进行 GC\u003c/mark\u003e\u003c/strong\u003e，\u003c/li\u003e\n  \u003cli\u003eAgent 重启后，会自动 resync/clean 过期的 L3 记录。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"325-解决方案调研\"\u003e3.2.5 解决方案：调研\u003c/h3\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNTF_USE | NTF_EXT_LEARNED\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 这两个 neigh flag\n大体上能帮我们实现以上设想。我之前其实并不知道这些 flag，也是看代码才发现。\u003c/p\u003e\n\n\u003ch4 id=\"ntf_use\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNTF_USE\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e先来看第一个 flag \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNTF_USE\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/torvalds/linux/blob/v5.10/net/core/neighbour.c#L1973\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003eneigh_add\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esk_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enlmsghdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003enlh\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003enetlink_ext_ack\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eextack\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003endm\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003endm_flags\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003eNTF_USE\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eneigh_event_send\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eneigh\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e\n        \u003cspan class=\"n\"\u003e__neigh_update\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eneigh\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elladdr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003endm\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003endm_state\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eflags\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eNETLINK_CB\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eskb\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eportid\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eextack\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，指定这个 flag 之后，将一条邻居表项加到内核时，将触发\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eneigh_event_send()\u003c/code\u003e 执行，后者会\u003cstrong\u003e\u003cmark\u003e做一次邻居解析\u003c/mark\u003e\u003c/strong\u003e。\n如果你一条 entry 加入到内核，它会在内核做 neighbor 解析，\u003c/p\u003e\n\n\u003cp\u003e后面这条表项过期时，\u003cstrong\u003e\u003cmark\u003e如果有 inbount 流量进来，或者有 outbound 流量需要这个表项\u003c/mark\u003e\u003c/strong\u003e\n（从而再触发一次解析），它会重新更新到 reachable 状态。\u003c/p\u003e\n\n\u003ch4 id=\"ntf_ext_learned\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNTF_EXT_LEARNED\u003c/code\u003e\u003c/h4\u003e\n\n\u003cp\u003e带这个 flag 表示这是一条\u003cstrong\u003e\u003cmark\u003e外部学习（externally learned）到并插入内核\u003c/mark\u003e\u003c/strong\u003e\n（而非内核自己维护）的表项，从而\n\u003cstrong\u003e\u003cmark\u003e确保了这个 entry 不会进入 GC 列表\u003c/mark\u003e\u003c/strong\u003e；这已经使我们非常接近最终想实现的效果了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNTF_EXT_LEARNED\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 与 Ethernet VPN (EVPN)\u003c/p\u003e\n\n  \u003cp\u003eCumulusNetworks 的工程师在 2018 年将\n\u003ca href=\"https://patchwork.ozlabs.org/project/netdev/patch/1524602974-11476-1-git-send-email-roopa@cumulusnetworks.com/\"\u003e这个 flag\u003c/a\u003e\n加到了内核，使 Linux 能支持 \u003cstrong\u003e\u003cmark\u003eBGP-EVPN\u003c/mark\u003e\u003c/strong\u003e：允许用户将某种\n\u003cstrong\u003e\u003cmark\u003e控制平面\u003c/mark\u003e\u003c/strong\u003e（例如基于 FRR 的 SDN 控制器）学习到的邻居信息直接添加到内核邻居表。\n这种外部 neigh entry 的管理方式，在之前的 bridge 和 vxlan fdb 中已经在用了。\u003c/p\u003e\n\n  \u003cp\u003eBGP-EVPN 用于\u003cstrong\u003e\u003cmark\u003e多租户大二层\u003c/mark\u003e\u003c/strong\u003e组网，典型的如 OpenStack SDN 网络，使用案例可参考\n\u003ca href=\"/blog/ctrip-network-arch-evolution-zh/\"\u003e\u003cmark\u003e云计算时代携程的网络架构变迁（2019）\u003c/mark\u003e\u003c/a\u003e。\u003c/p\u003e\n\n  \u003cp\u003e译注。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e但 NTF_EXT_LEARNED 的不足是：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e没有 auto-refresh 机制来从 STALE 重新回到 REACHABLE 状态，\u003c/li\u003e\n  \u003cli\u003eflags 并没有回传给用户空间，导致 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip neighbor xxx\u003c/code\u003e 命令之后看不到相应字段的状态（Daniel 的 \u003ca href=\"https://lore.kernel.org/all/20211115165320.907759698@linuxfoundation.org/\"\u003epatch\u003c/a\u003e），\u003c/li\u003e\n  \u003cli\u003e在发生 \u003cstrong\u003e\u003cmark\u003ecarrier-down\u003c/mark\u003e\u003c/strong\u003e 事件（例如网线接触不良）时会丢失，而 permanent flag 就不会。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"326-解决方案引入一个新-flag-nud_managed\"\u003e3.2.6 解决方案：引入一个新 flag \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNUD_MANAGED\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e因此，我们决定添加一个创建 neighbor entry 时用的\u003cstrong\u003e\u003cmark\u003e新 flag NUD_MANAGED\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e使用这个 flag 创建的邻居表项，\u003cstrong\u003e\u003cmark\u003e状态是可变的\u003c/mark\u003e\u003c/strong\u003e（volatile states，例如会进入 reachable state），而不像 NUD_PERMANENT 表项那样是一个永久状态；\n    \u003cul\u003e\n      \u003cli\u003e意味着内部使用了 NTF_USE\u003c/li\u003e\n      \u003cli\u003e表项是加到一个 per-neigh table list\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e使用 delayed system worker queue (wq) 来\u003cstrong\u003e\u003cmark\u003e定期\u003c/mark\u003e\u003c/strong\u003e为这些表项触发 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eneigh_event_send()\u003c/code\u003e，即\u003cstrong\u003e\u003cmark\u003e触发邻居解析\u003c/mark\u003e\u003c/strong\u003e；触发频率 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBASE_REACHABLE_TIME/2\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e这个 flag 还可以\u003cstrong\u003e\u003cmark\u003e与 NTF_EXT_LEARNED 一起用\u003c/mark\u003e\u003c/strong\u003e（表示这是外部控制平面学习到的），\u003cstrong\u003e\u003cmark\u003e从而避免被 GC\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e在发生 carrier-down 事件状态不会丢失，carrier-up 之后会自动刷新状态。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e基于 iproute2 的例子：指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enud managed\u003c/code\u003e 创建一条邻居表项：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip neigh replace 192.168.1.99 dev enp5s0 extern_learn nud managed\n192.168.1.99 dev enp5s0 lladdr 98:9b:cb:05:2e:ae use extern_learn REACHABLE\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"33-fib-extensions-snat-时的-src_ip-选择\"\u003e3.3 FIB extensions: SNAT 时的 SRC_IP 选择\u003c/h2\u003e\n\n\u003cp\u003e关于邻居表项的管理告一段落，接下来往上走一层，来看某些情况下 cilium datapath 中的 fib 查找问题。\u003c/p\u003e\n\n\u003ch3 id=\"331-node-有多个-ipsnatmasquerade-时的源地址选择问题\"\u003e3.3.1 Node 有多个 IP：SNAT/Masquerade 时的源地址选择问题\u003c/h3\u003e\n\n\u003cp\u003e来看下面这个例子。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/snat-1.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ePod 所在的网络是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e172.16.0.1/24\u003c/code\u003e，无法被外部网络主动访问\u003c/li\u003e\n  \u003cli\u003eNode 网卡上有两个 IP 地址，分别属于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e192.168.0.1/24\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.0.0.0/24\u003c/code\u003e 网段\u003c/li\u003e\n  \u003cli\u003ePod 想访问宿主机外面的某个 IP \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.0.0.100/32\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e由于 Pod IP 对外不可直接访问，因此 Pod \u003cstrong\u003e\u003cmark\u003e出向流量\u003c/mark\u003e\u003c/strong\u003e需要做\u003cstrong\u003e\u003cmark\u003e源地址转换\u003c/mark\u003e\u003c/strong\u003e（入向做相反转换）。\n我们在 tc ingress 上 attach 了一段 bpf 程序来做这件事情（masquerade，动态版 SNAT）。\u003c/p\u003e\n\n\u003cp\u003eNode IP 有多个，那执行地址转换时\u003cstrong\u003e\u003cmark\u003e选哪个呢\u003c/mark\u003e\u003c/strong\u003e？\n目前的做法是在 BPF 中根据某些逻辑来选一个地址，然后将其 \u003cstrong\u003e\u003cmark\u003ehardcode 到代码中\u003c/mark\u003e\u003c/strong\u003e，如上图所示。\u003c/p\u003e\n\n\u003cp\u003e但这里有个问题：还是以上图为例，虽然宿主机有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e192.168.0.1/24\u003c/code\u003e\n和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.0.0.0/24\u003c/code\u003e 两个网段的 IP 地址，但实际上连接到的只有 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.0.0.0/24\u003c/code\u003e 网络。这种情况下，\n如果我们用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e192.168.0.1/24\u003c/code\u003e 做 SNAT，应答流量就回不来了。\u003c/p\u003e\n\n\u003cp\u003e也就是说，这里涉及到如何选择真实可用的 Node IP 做 masquerade。\u003c/p\u003e\n\n\u003ch3 id=\"332-解决方式\"\u003e3.3.2 解决方式\u003c/h3\u003e\n\n\u003cp\u003e这个\u003cstrong\u003e\u003cmark\u003e信息其实已经在 FIB 表中了\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e因此，我们首先要做的是使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_{xdp,skb}_fib_lookup()\u003c/code\u003e 来动态选择源 IP。\n这需要对 BPF helper 函数做一些\u003ca href=\"https://github.com/brb/linux/commit/044d54d95456163a8fc5f776000e08e13d34039e\"\u003e修改\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e其次，给内核 \u003ca href=\"https://github.com/brb/linux/commit/d3b42b8fe46b252a8dad27623926f52086105399\"\u003e引入\u003c/a\u003e \n一个新 flag \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBPF_FIB_LOOKUP_SET_SRC\u003c/code\u003e，在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_ipv{4,6}_fib_lookup()\u003c/code\u003e\n\u003cstrong\u003e\u003cmark\u003e查询邻居表项时，自动将正确的源 IP 一起带出来\u003c/mark\u003e\u003c/strong\u003e，这个 patch 很快将合并到上游。\u003c/p\u003e\n\n\u003cp\u003e此外，有了这种方式，我们也不需要在 BPF 程序中 hardcode IP 了。\u003c/p\u003e\n\n\u003cp\u003e效果如下图所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/snat-2.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"34-l4lb-节点多网卡service-转发时-egress-网卡的选择问题\"\u003e3.4 L4LB 节点多网卡：Service 转发时 egress 网卡的选择问题\u003c/h2\u003e\n\n\u003ch3 id=\"341-问题描述\"\u003e3.4.1 问题描述\u003c/h3\u003e\n\n\u003cp\u003eFIB lookup 相关的另一个问题是 multi-home 网络。\n如下图所示，一个有三张网卡的 Cilium L4LB 节点在处理 Service 转换，将请求 DNAT 到特定的 backend。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/multi-home.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e那么，这里就会涉及到\u003cstrong\u003e\u003cmark\u003e选择哪张网卡将流量转发出去\u003c/mark\u003e\u003c/strong\u003e的问题。\n目前的做法是，在多个网卡的 datapath 中都重复了一些 fib lookup 逻辑。\u003c/p\u003e\n\n\u003ch3 id=\"342-解决方案\"\u003e3.4.2 解决方案\u003c/h3\u003e\n\n\u003cp\u003e这个信息（转发表项对应的是哪个 ifindex，即网卡）其实\u003cstrong\u003e\u003cmark\u003e也已经在 FIB 表中了\u003c/mark\u003e\u003c/strong\u003e。\n因此我们希望再次通过动态 fib lookup 解决这个问题，即（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_{xdp,skb}_fib_lookup()\u003c/code\u003e）把这个信息顺便带出来。\u003c/p\u003e\n\n\u003cp\u003e深入查看了相关代码之后，我们发现这个逻辑已经在了，只是 BPF helper 实现上有点问题，\n因此这里我们做了一点 \u003ca href=\"https://github.com/brb/linux/commit/3387287212490d30bc1a4266ae472eab9a988962\"\u003e改动\u003c/a\u003e，也会合并到上游内核。\u003c/p\u003e\n\n\u003cp\u003e最终效果如下：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/snat-3.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\n\u003ch1 id=\"4-查询-bpf-map-时的通配符匹配问题\"\u003e4 查询 BPF map 时的通配符匹配问题\u003c/h1\u003e\n\n\u003ch2 id=\"41-pcap-recorder-当前使用场景cilium-xdp-l4lb\"\u003e4.1 PCAP recorder 当前使用场景：Cilium XDP L4LB\u003c/h2\u003e\n\n\u003cp\u003eCilium LB 节点上提供了一个灵活的 traffic recorder，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e它会关联入向和出向 flow（后面会看到原理），因此用它可以查看 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efabric -\u0026gt; L4LB -\u0026gt; L7 proxy/backend\u003c/code\u003e 的整条流量路径。\u003c/li\u003e\n  \u003cli\u003e提供了更高层的 API ，能在带外（out-of-band）对 L4LB agent 进行编程。agent 将把指定的 filter 加载到内核 bpf datapath，创建一个 wildcard mask。\u003c/li\u003e\n  \u003cli\u003e还有一个叫 \u003ca href=\"https://github.com/cilium/hubble\"\u003eHubble\u003c/a\u003e 的组件，能抓包并保存成 pcap 供 offline 排障。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e遗憾的是今天这里不能播放 gif，只能提供两条命令供大家参考：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ehubble record \u003cspan class=\"s2\"\u003e\u0026#34;0.0.0.0/0 192.168.33.11/32 80 TCP\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecilium recorder list\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e下面介绍一下它的内部实现。\u003c/p\u003e\n\n\u003ch2 id=\"42-pcap-recorder-原理\"\u003e4.2 PCAP recorder 原理\u003c/h2\u003e\n\n\u003cp\u003e下图从 flow 的角度展示它是如何工作的：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e判断入向流量。如果是需要抓取的流量，就提取基本信息存储到一个 per-cpu cache。\n将原始包放到 perf ring buffer。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e判断出向流量：如果 ring buffer 中记录了对应的 ingress flow，就抓取该 egress flow。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e以上二者都会调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_capture()\u003c/code\u003e，它会\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e记录一些 metadata，例如 recorder id\u003c/li\u003e\n      \u003cli\u003epcap header with MONO。\u003c/li\u003e\n      \u003cli\u003efull or partial payload capture。\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这些抓取到流量经过隧道封装之后发往 backend。\u003c/p\u003e\n\n\u003ch2 id=\"43-pcap-recorder-匹配规则\"\u003e4.3 PCAP recorder 匹配规则\u003c/h2\u003e\n\n\u003ch3 id=\"431-recorder-组成\"\u003e4.3.1 Recorder 组成\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder-classifier-rules-1.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e一个 Recorder 由下面几部分组成：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eSource CIDR, destination CIDR\u003c/li\u003e\n  \u003cli\u003eSource Port, destination Port，其中\n    \u003cul\u003e\n      \u003cli\u003e0 表示 any\u003c/li\u003e\n      \u003cli\u003en：表示精确匹配 port == n，其中 n != 0\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eCurrently unsupported: n-m range\u003c/li\u003e\n  \u003cli\u003eProtocol\n    \u003cul\u003e\n      \u003cli\u003e0 表示 any\u003c/li\u003e\n      \u003cli\u003en：表示精确匹配 proto == n，其中 n != 0\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"432-agent-职责\"\u003e4.3.2 Agent 职责\u003c/h3\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/pcap-recorder-classifier-rules-2.png\" width=\"85%\" height=\"85%\"/\u003e\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e使用 API 来对 recorder 进行编程\u003c/li\u003e\n  \u003cli\u003eTracking different masks from rules\u003c/li\u003e\n  \u003cli\u003e在 mask set 发生变化时，Regens datapath\u003c/li\u003e\n  \u003cli\u003ev4/v6 hashtable each for rule lookup\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"44-匹配规则当前的代码实现\"\u003e4.4 匹配规则：当前的代码实现\u003c/h2\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/cilium/cilium/blob/v1.10/bpf/lib/pcap.h#L216\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003e__always_inline\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecapture_rule\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\n\u003cspan class=\"nf\"\u003ecilium_capture4_classify_wcard\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__ctx_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"c1\"\u003e// 有序 mask 集合（列表），PREFIX_MASKS4 是一个编译时常量，由 agent 动态生成\u003c/span\u003e\n    \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecapture4_wcard\u003c/span\u003e \u003cspan class=\"n\"\u003eprefix_masks\u003c/span\u003e\u003cspan class=\"p\"\u003e[]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003ePREFIX_MASKS4\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\n\u003cspan class=\"n\"\u003e_Pragma\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;unroll\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// 根据元组信息 okey 和当前 mask 生成 masked key (lkey)，这个函数的实现下面也给出了\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ecilium_capture4_masked_key\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eokey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eprefix_masks\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e],\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003elkey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n        \u003cspan class=\"c1\"\u003e// 用掩码之后的 key（即 lkey）去哈希表查找 \u003c/span\u003e\n        \u003cspan class=\"n\"\u003ematch\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emap_lookup_elem\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ecilium_capture4_rules\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003elkey\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n            \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003ematch\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"c1\"\u003e// match 中包含了 Recorder ID 和 capture length 信息\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e根据 tuple 信息和 mask 信息计算掩码之后的 key：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// https://github.com/cilium/cilium/blob/v1.10/bpf/lib/pcap.h#L156\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003e__always_inline\u003c/span\u003e \u003cspan class=\"kt\"\u003evoid\u003c/span\u003e\n\u003cspan class=\"nf\"\u003ecilium_capture4_masked_key\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecapture4_wcard\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n               \u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecapture4_wcard\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003ecapture4_wcard\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esaddr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esaddr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edport\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edport\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edport\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esport\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esport\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esport\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enexthdr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eorig\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enexthdr\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003enexthdr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edmask\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003edmask\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eout\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esmask\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emask\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esmask\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"45-当前实现的问题mask-集合不能太大否则开销太大\"\u003e4.5 当前实现的问题：Mask 集合不能太大，否则开销太大\u003c/h2\u003e\n\n\u003cp\u003e总体上来说，这是一种穷人的 wildcard match 方式。\u003c/p\u003e\n\n\u003cp\u003e这里的一个基本前提是 \u003cstrong\u003e\u003cmark\u003emask 集合不会很大\u003c/mark\u003e\u003c/strong\u003e，这个假设对我们当前来说是可接受的。\n但有一些缺点：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003emask 集合发生变化时，需要动态重新编译，开销非常大；\u003c/li\u003e\n  \u003cli\u003e对 mask 的处理是一个线性过程，复杂的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eO(n)\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e虽然在老版本内核上也能工作，但 loop unrolling 可能导致生成的代码太复杂，verifier 通过不了。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"46-原生支持通配符匹配的-bpf-map\"\u003e4.6 原生支持通配符匹配的 BPF map\u003c/h2\u003e\n\n\u003cp\u003e理想情况下，有内核原生的 BPF map 来避免开销非常高的 code regeneration：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e非常快速的查询：Millions/Sec\u003c/li\u003e\n  \u003cli\u003e合理速度的更新：Thousands/Sec\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这种设想最早在 2018 年\n\u003ca href=\"https://lore.kernel.org/netdev/CALDO+SYzDDpTmJttghfjUYKbo3AHDaT4L154Acwn5BGqkytkHQ@mail.gmail.com/\"\u003eBPF + OVS\u003c/a\u003e\n中出现过，他们想基于这种方式在 BPF 中实现 Megaflow 的匹配，但后来没进展了。\u003c/p\u003e\n\n\u003cp\u003e另外，我们最近也在看当前主流的包分类算法有哪些，例如 \u003ca href=\"https://nonsns.github.io/paper/rossi19ton.pdf\"\u003eTupleMerge\u003c/a\u003e，\n下面是论文中的截图：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/classification-time.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e即便是有大量 rules，至少论文中的仿真结果看起来非常不错：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/bpf-datapath-ext-for-k8s/classification-ruleset-size.png\" width=\"70%\" height=\"70%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e但目前我们还没有 POC，在我们的 to-do-list 上。\n这样就可以免去动态重新编译的问题，如果在座的有这方面经验，我们非常感兴趣。\u003c/p\u003e\n\n\u003ch1 id=\"5-完场-qa-环节\"\u003e5 完场 Q\u0026amp;A 环节\u003c/h1\u003e\n\n\u003ch3 id=\"问题-6关于-wildcard-匹配算法\"\u003e问题 6：关于 wildcard 匹配算法\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eAlexei：这次分享的能力太密集了，要全程跟上非常困难。我有几个问题。\u003c/p\u003e\n\n  \u003cp\u003e内核有很多限制，所以不是所有\u003cstrong\u003e\u003cmark\u003e用户空间算法\u003c/mark\u003e\u003c/strong\u003e都适合在内核实现。\n但从论文提供的数据看，如果算法能在内核实现，性能收益的确很可观。\u003c/p\u003e\n\n  \u003cp\u003e另外，有没有试过 map_for_each helper？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e还没。其实我们现在只在 5.4 上需要这个特性，用户在生产环境运行 LB，但对于其他版本，我们需要再深入研究。\u003c/p\u003e\n\n\u003cp\u003e总体来说，我非常同意你的观点，例如必须兼容 rcu 以及其他一些东西，不是所有东西都适合在内核。\n论文中提到的一些结果都很不错，但这些终归都是仿真结果，还是需要实现一个真实的版\n本来验证性能到底怎么样。\u003c/p\u003e\n\n\u003ch3 id=\"问题-7其中一些算法是不是有专利\"\u003e问题 7：其中一些算法是不是有专利？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e上面论文中的算法是不是有专利？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个问题我确实还没考虑到，需要回去确认一下。\u003c/p\u003e\n\n\u003ch3 id=\"问题-8cilium-是否已经不需要-direct-interface-概念\"\u003e问题 8：Cilium 是否已经不需要 direct interface 概念？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e你们在设计中似乎倾向于有所谓的 direct interfaces 概念，但听了前面的分享之后，我认为\n你们并再需要这个东西。我的意思是，有了 BPF 中的 fib lookup 功能之后，\n出向和入向该用哪个接口，交给内核决定就行了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e是的，这种自维护的状态能通过定时刷新或其他方式，保证 neighbor entry 在内核中存在且持续处于 reachable。\n这样我们就能用 fib lookup 来查找邻居，后者也为 XDP datapath 提供了便利。\u003c/p\u003e\n\n\u003cp\u003e今天的基础设施，例如 NTF_USE flag，我认为是非常古老的代码，\n它没有主动 refresh 进入 reachable 状态，除非有外部流量或内部流量事件，比如 ping node。\n如果这些完全由内核的邻居子系统来管理（completely self-managed by the kernel）那自然是很好的。\n这样我们就无需外部流量触发更新。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eMartynas：明确一下，在选择源地址时我们无需任何邻居表项。\u003c/p\u003e\n\n  \u003cp\u003eDaniel：哦是的是的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"问题-9用-libpcap-将-cbpf-编译成-ebpf-是否可以解决你们不支持-port-range-的问题\"\u003e问题 9：用 libpcap 将 cbpf 编译成 ebpf 是否可以解决你们不支持 port-range 的问题？\u003c/h3\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e我们用 libpcap 将 cbpf 编译成 ebpf，它支持 subnet/port ranges。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种方式是可行的，但我认为这种方式生成的程序将迅速膨胀。\n如果你只有很少的 mask，loop unroll 不会产生问题；但如果要匹配几千个地方，\n那生成的代码就会非常长。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e是的，其实就是用真实 BPF 代码来换 hash map entries 了。\n我们的场景都是只有几百条 entries，太多确实会有问题；另外就是指令数也是有限制的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e我们想做的一件事情就是将这段代码从 LB 节点移到 CNI datapath 部分，\n而后者中已经有非常复杂的 bpf 代码了，因此再加一段这样的代码将会使其进一步膨胀。\n我最大的顾虑是校验器，太大或太复杂会无法通过。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e理解，这里的确有挑战。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"6-本文翻译时原作者特别更新\"\u003e6 本文翻译时，原作者特别更新\u003c/h1\u003e\n\n\u003cp\u003eDaniel 和 Martynas 在本文翻译时非常热心地提供了以下更新：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003ecgroup v1/v2 patch 已经完全合并到内核；\u003c/li\u003e\n  \u003cli\u003e自维护 neighbor entries 也已经合并到内核；对于不支持这个新特性的老内核，Cilium 1.11 中做了兼容；\u003c/li\u003e\n  \u003cli\u003eTCP 时间戳问题，已经从 Facebook 收到积极反馈，他们也需要这个东西，有望在 12 月份解决。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e以下是详细 patch 列表。\u003c/p\u003e\n\n\u003ch2 id=\"61-merged-cgroup-v1v2-patches\"\u003e6.1 Merged cgroup v1/v2 patches\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=8520e224f547cd070c7c8f97b1fc6d58cff7ccaa\"\u003ebpf, cgroups: Fix cgroup v2 fallback on v1/v2 mixed mode\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=d8079d8026f82e4435445297d1b77bba1c4c7960\"\u003ebpf, selftests: Add cgroup v1 net_cls classid helpers\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=43d2b88c29f2d120b4dc22f27b3483eb14bd9815\"\u003ebpf, selftests: Add test case for mixed cgroup v1/v2\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=78cc316e9583067884eb8bd154301dc1e9ee945c\"\u003ebpf, cgroup: Assign cgroup in cgroup_sk_alloc when called from interrupt\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=435b08ec0094ac1e128afe6cfd0d9311a8c617a7\"\u003ebpf, test, cgroup: Use sk_{alloc,free} for test cases\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"62-merged-managed-neighbor-entries--fixes\"\u003e6.2 Merged managed neighbor entries \u0026amp; fixes\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=e4400bbf5b15750e1b59bf4722d18d99be60c69f\"\u003enet, neigh: Fix NTF_EXT_LEARNED in combination with NTF_USE\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=3dc20f4762c62d3b3f0940644881ed818aa7b2f5\"\u003enet, neigh: Enable state migration between NUD_PERMANENT and NTF_USE\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=7482e3841d520a368426ac196720601687e2dc47\"\u003enet, neigh: Add NTF_MANAGED flag for managed neighbor entries\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=507c2f1d2936e07aef83734983a36df01b458ef9\"\u003enet, neigh: Add build-time assertion to avoid neigh-\u0026gt;flags overflow\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=c8e80c1169b2b3b91453f9ff3c34687c42233ef7\"\u003enet, neigh: Use NLA_POLICY_MASK helper for NDA_FLAGS_EXT attribute\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=30fc7efa38f21afa48b0be6bf2053e4c10ae2c78\"\u003enet, neigh: Reject creating NUD_PERMANENT with NTF_MANAGED entries\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/linux/kernel/git/netdev/net.git/commit/?id=4177d5b017a71433d4760889b88f7a29e11fad10\"\u003enet, neigh: Fix crash in v6 module initialization error path\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"63-iproute2\"\u003e6.3 iproute2\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=c76a3849ec307ae216eb7ae674dcc7aea2f7dde1\"\u003eip, neigh: Fix up spacing in netlink dump\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=040e52526c22163a218b9cb2224f51a2de0e6576\"\u003eip, neigh: Add missing NTF_USE support\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://git.kernel.org/pub/scm/network/iproute2/iproute2.git/commit/?id=9e009e78e7f14ec98efdaca38998d0f472e45ea5\"\u003eip, neigh: Add NTF_EXT_MANAGED support\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"64-go-netlink-lib\"\u003e6.4 go netlink lib\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/vishvananda/netlink/pull/707\"\u003eAdd support for NDA_FLAGS_EXT neighboring attribute\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"65-cilium-111-neighbor-rework-using-managed-neighbors-on-newer-kernels\"\u003e6.5 Cilium 1.11 neighbor rework (using managed neighbors on newer kernels)\u003c/h2\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium/pull/17713\"\u003ecilium: Rework neighbor handling\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium/pull/17842\"\u003ecilium: fix ipv6 neighbor discovery\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium/pull/17862\"\u003eneigh: add runtime test for changing next hop address\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium/pull/17918\"\u003eneigh: Clean up stale/untracked non-GC’ed neighbors\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://github.com/cilium/cilium/pull/17932\"\u003eneigh: Init new neighbor for older kernel with NUD_STALE\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/formal-requirements-for-virtualizable-arch-zh/\"\u003e\u003cspan\u003e« [译] [论文] 可虚拟化第三代（计算机）架构的规范化条件（ACM, 1974）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/facebook-from-xdp-to-socket-zh/\"\u003e\u003cspan\u003e[译] Facebook 流量路由最佳实践：从公网入口到内网业务的全路径 XDP/BPF 基础设施（LPC, 2021） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-11-24T00:00:00Z",
  "Author": "Arthur Chiao"
}