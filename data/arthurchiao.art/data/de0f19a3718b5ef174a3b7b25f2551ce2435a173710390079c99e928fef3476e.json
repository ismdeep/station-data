{
  "Source": "arthurchiao.art",
  "Title": "[译] 简明 x86 汇编指南（2017）",
  "Link": "https://arthurchiao.art/blog/x86-asm-guide-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] 简明 x86 汇编指南（2017）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2017-08-14 | Last Update 2019-05-08\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003eTranslated from \u003ca href=\"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\"\u003eCS216, University of Virginia\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e一份非常好的 x86 汇编教程，国外 CS 课程所用资料，篇幅简短，逻辑清晰，合适作为入\n门参考。以原理为主，有两个例子帮助理解。其开始提到使用 MicroSoft MASM 和 Visual\nStudio，但非必须, 事实上如果你有 Linux 更好。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e本文根据原文内容意译，而非逐词逐句翻译，如需了解更多，推荐阅读\u003c/strong\u003e\u003ca href=\"http://www.cs.virginia.edu/~evans/cs216/guides/x86.html\"\u003e原文\n\u003c/a\u003e.\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e内容：\u003cstrong\u003e寄存器, 内存和寻址, 指令, 函数调用约定（Calling Convention）\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e本文介绍 \u003cstrong\u003e32bit x86 汇编\u003c/strong\u003e基础，覆盖其中虽小但很有用的一部分。\n有多种汇编语言可以生成 x86 机器代码。我们在 CS216 课程中使用的是 MASM（\nMicrosoft Macro Assembler）。MASM 使用标准 Intel 语法。\u003c/p\u003e\n\n\u003cp\u003e整套 x86 指令集庞大而复杂（Intel x86 指令集手册超过 2900 页），本文不会全部覆盖。\u003c/p\u003e\n\n\u003ch2 id=\"1-参考资料\"\u003e1. 参考资料\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003eGuide to Using Assembly in Visual Studio — a tutorial on building and debugging assembly code in Visual Studio\u003c/li\u003e\n  \u003cli\u003eIntel x86 Instruction Set Reference\u003c/li\u003e\n  \u003cli\u003eIntel’s Pentium Manuals (the full gory details)\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"2-寄存器\"\u003e2. 寄存器\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/x86-asm-guide/x86-registers.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 2.1 x86 registers\u003c/p\u003e\n\n\u003cp\u003e现代 x86 处理器有 8 个 32 bit 寄存器，如图 1 所示。寄存器名字是早期计算机历史上\n流传下来的。例如，EAX 表示 Accumulator，因为它用作算术运算的累加器，ECX 表示\nCounter，用来存储循环变量（计数）。大部分寄存器的名字已经失去了原来的意义，但有\n两个是例外：栈指针寄存器（Stack Pointer）ESP 和基址寄存器（ Base Pointer）EBP。\u003c/p\u003e\n\n\u003cp\u003e对于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEBX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eECX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEDX\u003c/code\u003e 四个寄存器，可以再将 32bit 划分成多个子寄存器，\n每个子寄存器有专门的名字。例如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e 的高 16bit 叫 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAX\u003c/code\u003e（去掉 E, E 大概表示\n\u003cstrong\u003eExtended\u003c/strong\u003e）,低 8bit 叫 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAL\u003c/code\u003e (\u003cstrong\u003eLow\u003c/strong\u003e）, 8-16bit 叫 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAH\u003c/code\u003e （\u003cstrong\u003eHigh\u003c/strong\u003e）。如图 1\n所示。\u003c/p\u003e\n\n\u003cp\u003e在汇编语言中，这些寄存器的名字是\u003cstrong\u003e大小写无关\u003c/strong\u003e的，既可以用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e，也可以写 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeax\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"3-内存和寻址模式\"\u003e3. 内存和寻址模式\u003c/h2\u003e\n\n\u003ch3 id=\"31-声明静态数据区\"\u003e3.1 声明静态数据区\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.DATA\u003c/code\u003e 声明静态数据区。\u003c/p\u003e\n\n\u003cp\u003e数据类型修饰原语：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDB\u003c/code\u003e: Byte,        1 Byte（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDB\u003c/code\u003e 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eD\u003c/code\u003e 可能表示 Data）\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDW\u003c/code\u003e: Word,        2 Bytes\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDD\u003c/code\u003e: Double Word, 4 Bytes\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e.DATA\nvar     DB 64    ; 声明一个 byte 值, referred to as location var, containing the value 64.\nvar2    DB ?     ; 声明一个未初始化 byte 值, referred to as location var2.\n        DB 10    ; 声明一个没有 label 的 byte 值, containing the value 10. Its location is var2 + 1.\nX       DW ?     ; 声明一个 2-byte 未初始化值, referred to as location X.\nY       DD 30000 ; 声明一个 4-byte 值, referred to as location Y, initialized to 30000.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e和高级语言不同，\u003cstrong\u003e在汇编中只有一维数组\u003c/strong\u003e，只有没有二维和多维数组。一维数组其实就\n是内存中的一块连续区域。另外，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDUP\u003c/code\u003e 和字符串常量也是声明数组的两种方法。\u003c/p\u003e\n\n\u003cp\u003e例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eZ       DD 1, 2, 3      ; 声明 3 个 4-byte values, 初始化为 1, 2, and 3. The value of location Z + 8 will be 3.\nbytes   DB 10 DUP(?)    ; 声明 10 个 uninitialized bytes starting at location bytes.\narr     DD 100 DUP(0)   ; 声明 100 个 4-byte words starting at location arr, all initialized to 0\nstr     DB \u0026#39;hello\u0026#39;,0    ; 声明 6 bytes starting at the address str, 初始化为 hello and the null (0) byte.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"32-内存寻址-addressing-memory\"\u003e3.2 内存寻址 (Addressing Memory)\u003c/h3\u003e\n\n\u003cp\u003e有多个指令可以用于内存寻址，我们先看使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMOV\u003c/code\u003e 的例子。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMOV\u003c/code\u003e 将在内存和寄存器之\n间移动数据，接受两个参数：第一个参数是目的地，第二个是源。\u003c/p\u003e\n\n\u003cp\u003e合法寻址的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003emov eax, [ebx]        ; Move the 4 bytes in memory at the address contained in EBX into EAX\nmov [var], ebx        ; Move the contents of EBX into the 4 bytes at memory address var. (Note, var is a 32-bit constant).\nmov eax, [esi-4]      ; Move 4 bytes at memory address ESI + (-4) into EAX\nmov [esi+eax], cl     ; Move the contents of CL into the byte at address ESI+EAX\nmov edx, [esi+4*ebx]  ; Move the 4 bytes of data at address ESI+4*EBX into EDX\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e非法寻址\u003c/strong\u003e的例子：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003emov eax, [ebx-ecx]      ; 只能对寄存器的值相加，不能相减\nmov [eax+esi+edi], ebx  ; 最多只能有 2 个寄存器参与地址计算\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"33-数据类型大小原语size-directives\"\u003e3.3 数据类型(大小)原语（Size Directives）\u003c/h3\u003e\n\n\u003cp\u003e修饰\u003cstrong\u003e指针\u003c/strong\u003e类型：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBYTE PTR\u003c/code\u003e - 1 Byte\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWORD PTR\u003c/code\u003e - 2 Bytes\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDWORD PTR\u003c/code\u003e - 4 Bytes\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003emov BYTE PTR [ebx], 2   ; Move 2 into the single byte at the address stored in EBX.\nmov WORD PTR [ebx], 2   ; Move the 16-bit integer representation of 2 into the 2 bytes starting at the address in EBX.\nmov DWORD PTR [ebx], 2  ; Move the 32-bit integer representation of 2 into the 4 bytes starting at the address in EBX.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"4-指令\"\u003e4. 指令\u003c/h2\u003e\n\n\u003cp\u003e三大类：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e数据移动\n    \u003col\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emov\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epush\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003epop\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elea\u003c/code\u003e - Load Effective Address\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e算术/逻辑运算\n    \u003col\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eadd\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esub\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003einc\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edec\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimul\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidiv\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eand\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eor\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003exor\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enot\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eneg\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eshl\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eshr\u003c/code\u003e\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e控制流\n    \u003col\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejmp\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eje\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejne\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejz\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejg\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ejl\u003c/code\u003e …\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecmp\u003c/code\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eret\u003c/code\u003e\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"5-调用约定\"\u003e5. 调用约定\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e这是最重要的部分。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e子过程（函数）调用需要遵守一套共同的\u003cstrong\u003e调用约定\u003c/strong\u003e（\u003cstrong\u003e\u003cem\u003eCalling Convention\u003c/em\u003e\u003c/strong\u003e）。\n\u003cstrong\u003e调用约定是一个协议，规定了如何调用以及如何从过程返回\u003c/strong\u003e。例如，给定一组 calling\nconvention rules，程序员无需查看子函数的定义就可以确定如何将参数传给它。进一步地\n，给定一组 calling convention rules，高级语言编译器只要遵循这些 rules，就可以使\n得汇编函数和高级语言函数互相调用。\u003c/p\u003e\n\n\u003cp\u003eCalling conventions 有多种。我们这里介绍使用最广泛的一种：\u003cstrong\u003eC 语言调用约定\u003c/strong\u003e（C\nLanguage Calling Convention）。遵循这个约定，可以使汇编代码安全地被 C/C++ 调用\n，也可以从汇编代码调用 C 函数库。\u003c/p\u003e\n\n\u003cp\u003eC 调用约定:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e强烈依赖\u003cstrong\u003e硬件栈\u003c/strong\u003e的支持 (hardwared-supported stack)\u003c/li\u003e\n  \u003cli\u003e基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epush\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epop\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eret\u003c/code\u003e 指令\u003c/li\u003e\n  \u003cli\u003e子过程\u003cstrong\u003e参数通过栈传递\u003c/strong\u003e: 寄存器保存在栈上，子过程用到的局部变量也放在栈上\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在大部分处理器上实现的大部分高级过程式语言，都使用与此相似的调用惯例。\u003c/p\u003e\n\n\u003cp\u003e调用惯例分为两部分。第一部分用于 \u003cstrong\u003e调用方\u003c/strong\u003e（\u003cstrong\u003e\u003cem\u003ecaller\u003c/em\u003e\u003c/strong\u003e），第二部分用于\u003cstrong\u003e被调\n用方\u003c/strong\u003e（\u003cstrong\u003e\u003cem\u003ecallee\u003c/em\u003e\u003c/strong\u003e）。需要强调的是，错误地使用这些规则将导致\u003cstrong\u003e栈被破坏\u003c/strong\u003e，程序\n很快出错；因此在你自己的子过程中实现 calling convention 时需要格外仔细。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/x86-asm-guide/stack-convention.png\" width=\"60%\" height=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 5.1 Stack during Subroutine Call\u003c/p\u003e\n\n\u003ch3 id=\"51-调用方规则-caller-rules\"\u003e5.1 调用方规则 (Caller Rules)\u003c/h3\u003e\n\n\u003cp\u003e在一个子过程调用之前，调用方应该：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e保存应由调用方保存的寄存器\u003c/strong\u003e（\u003cstrong\u003e\u003cem\u003ecaller-saved\u003c/em\u003e\u003c/strong\u003e registers): \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eECX\u003c/code\u003e,\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEDX\u003c/code\u003e\u003c/p\u003e\n\n    \u003cp\u003e这几个寄存器可能会被被调用方（callee）修改，所以先保存它们，以便调用结\n 束后恢复栈的状态。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e将需要传给子过程的参数入栈\u003c/strong\u003e（push onto stack)\u003c/p\u003e\n\n    \u003cp\u003e参数按\u003cstrong\u003e逆序\u003c/strong\u003e push 入栈（最后一个参数先入栈）。由于栈是向下生长的，第一个参数\n 会被存储在最低地址（\u003cstrong\u003e这个特性使得变长参数列表成为可能\u003c/strong\u003e）。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e 指令，调用子过程(函数）\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e 先将返回地址 push 到栈上，然后开始执行子过程代码。子过程代码需要遵\n 守的 callee rules。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e子过程返回后（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecall\u003c/code\u003e 执行结束之后），被调用方会将返回值放到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e 寄存器，调用方\n可以从中读取。为恢复机器状态，调用方需要做：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e从栈上删除传递的参数\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e栈恢复到准备发起调用之前的状态。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e恢复由调用方保存的寄存器\u003c/strong\u003e（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eECX\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEDX\u003c/code\u003e）—— 从栈上 pop 出来\u003c/p\u003e\n\n    \u003cp\u003e调用方可以认为，除这三个之外，其他寄存器的值没有被修改过。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"例子\"\u003e例子\u003c/h4\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epush [var] ; Push last parameter first\npush 216   ; Push the second parameter\npush eax   ; Push first parameter last\n\ncall _myFunc ; Call the function (assume C naming)\n\nadd esp, 12\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"52-被调用方规则-callee-rules\"\u003e5.2 被调用方规则 (Callee Rules)\u003c/h3\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e将寄存器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEBP\u003c/code\u003e 的值入栈，然后 copy \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eESP\u003c/code\u003e to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEBP\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epush ebp\nmov  ebp, esp\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e    \u003c/div\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e在栈上为局部变量分配空间\u003c/strong\u003e\u003c/p\u003e\n\n    \u003cp\u003e栈自顶向下生长，故随着变量的分配，栈顶指针不断减小。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e保存应有被调用方保存（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecallee-saved\u003c/code\u003e）的寄存器\u003c/strong\u003e —— 将他们压入栈。包括 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEBX\u003c/code\u003e,\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEDI\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eESI\u003c/code\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e以上工作完成，就可以执行子过程的代码了。当子过程返回后，必须做以下工作：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e将返回值保存在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEAX\u003c/code\u003e\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e恢复应由被调用方保存的寄存器\u003c/strong\u003e(\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEDI\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eESI\u003c/code\u003e) —— 从栈上 pop 出来\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e释放局部变量\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e恢复调用方 base pointer \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eEBP\u003c/code\u003e —— 从栈上 pop 出来\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003cstrong\u003e最后，执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eret\u003c/code\u003e，返回给调用方 (caller)\u003c/strong\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch4 id=\"例子-1\"\u003e例子\u003c/h4\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e.486\n.MODEL FLAT\n.CODE\nPUBLIC _myFunc\n_myFunc PROC\n  ; Subroutine Prologue\n  push ebp     ; Save the old base pointer value.\n  mov ebp, esp ; Set the new base pointer value.\n  sub esp, 4   ; Make room for one 4-byte local variable.\n  push edi     ; Save the values of registers that the function\n  push esi     ; will modify. This function uses EDI and ESI.\n  ; (no need to save EBX, EBP, or ESP)\n\n  ; Subroutine Body\n  mov eax, [ebp+8]   ; Move value of parameter 1 into EAX\n  mov esi, [ebp+12]  ; Move value of parameter 2 into ESI\n  mov edi, [ebp+16]  ; Move value of parameter 3 into EDI\n\n  mov [ebp-4], edi   ; Move EDI into the local variable\n  add [ebp-4], esi   ; Add ESI into the local variable\n  add eax, [ebp-4]   ; Add the contents of the local variable\n                     ; into EAX (final result)\n\n  ; Subroutine Epilogue \n  pop esi      ; Recover register values\n  pop  edi\n  mov esp, ebp ; Deallocate local variables\n  pop ebp ; Restore the caller\u0026#39;s base pointer value\n  ret\n_myFunc ENDP\nEND\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/ovs-deep-dive-6-internal-port/\"\u003e\u003cspan\u003e« OVS Deep Dive 6: Internal Port\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/vim-pickups-001-zh/\"\u003e\u003cspan\u003eVim Pickups 001 »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2017-08-14T00:00:00Z",
  "Author": "Arthur Chiao"
}