{
  "Source": "arthurchiao.art",
  "Title": "[译] eBPF 内核探测：如何将任意系统调用转换成事件（2016）",
  "Link": "https://arthurchiao.art/blog/ebpf-turn-syscall-to-event-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003e[译] eBPF 内核探测：如何将任意系统调用转换成事件（2016）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2018-12-03 | Last Update 2022-05-04\u003c/p\u003e\n  \n  \u003ch3 id=\"译者序\"\u003e译者序\u003c/h3\u003e\n\n\u003cp\u003e本文翻译自 2016 年的一篇英文博客\n\u003ca href=\"https://blog.yadutaf.fr/2016/03/30/turn-any-syscall-into-event-introducing-ebpf-kernel-probes/\"\u003eHow to turn any syscall into an event: Introducing eBPF Kernel probes\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e由于译者水平有限，本文不免存在遗漏或错误之处。如有疑问，请查阅原文。\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e以下是译文。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#译者序\" id=\"markdown-toc-译者序\"\u003e译者序\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#太长不读tl-dr\" id=\"markdown-toc-太长不读tl-dr\"\u003e太长不读（TL; DR）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#1-消息系统push-还是-pull\" id=\"markdown-toc-1-消息系统push-还是-pull\"\u003e1 消息系统：Push 还是 Pull\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-内核跟踪和-ebpf-简史\" id=\"markdown-toc-2-内核跟踪和-ebpf-简史\"\u003e2 内核跟踪和 eBPF 简史\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-hello--world\" id=\"markdown-toc-3-hello--world\"\u003e3 Hello,  World!\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-改进\" id=\"markdown-toc-4-改进\"\u003e4 改进\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-抓取-tcp-backlog-信息\" id=\"markdown-toc-41-抓取-tcp-backlog-信息\"\u003e4.1 抓取 TCP backlog 信息\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-抓取-port-和-ip-信息\" id=\"markdown-toc-42-抓取-port-和-ip-信息\"\u003e4.2 抓取 Port 和 IP 信息\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-抓取网络命名空间信息\" id=\"markdown-toc-43-抓取网络命名空间信息\"\u003e4.3 抓取网络命名空间信息\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-结束语\" id=\"markdown-toc-5-结束语\"\u003e5 结束语\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch2 id=\"太长不读tl-dr\"\u003e太长不读（TL; DR）\u003c/h2\u003e\n\n\u003cp\u003eLinux \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4.4+\u003c/code\u003e 支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeBPF\u003c/code\u003e。基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeBPF\u003c/code\u003e 可以将任何\u003cstrong\u003e内核函数调用\u003c/strong\u003e转换成可带任何\n数据的\u003cstrong\u003e用户空间事件\u003c/strong\u003e。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebcc\u003c/code\u003e 作为一个更上层的工具使这个过程更加方便。内核探测\n代码用 C 写，数据处理代码用 Python。\u003c/p\u003e\n\n\u003cp\u003e如果对 eBPF 或 Linux tracing 不是太熟悉，建议阅读全文。本文循序渐进，并介绍\n了我在上手 bcc/eBPF 时遇到的一些坑，这会节省你大量时间。\u003c/p\u003e\n\n\u003ch1 id=\"1-消息系统push-还是-pull\"\u003e1 消息系统：Push 还是 Pull\u003c/h1\u003e\n\n\u003cp\u003e刚接触容器时，我曾思考如何根据系统的真实状态\u003cstrong\u003e动态更新负载均衡器的配置\u003c/strong\u003e。一\n个可行的方案是，每次容器编排服务（orchestrator）启动一个容器，就由它去负责轮\n询这个容器，然后根据健康检查的结果触发一次负载均衡器的配置更新。这属于简单\n的 \u003cstrong\u003e“SYN” test\u003c/strong\u003e（探测新启动的服务是否正常）类型。\u003c/p\u003e\n\n\u003cp\u003e这种方式显然是可行的，但也有缺点：\u003cstrong\u003e负载均衡器需要（分心）等待其他系统的结果，而\n它实际上只应该负责负载均衡\u003c/strong\u003e。我们能做的更好吗？\u003c/p\u003e\n\n\u003cp\u003e当希望一个程序能对系统变化做出反应时，通常有 2 种可能的方式：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e一种是程序主动去轮询，检查系统变化；\u003c/li\u003e\n  \u003cli\u003e另一种，如果系统支持事件通知的话，让它主动通知程序。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cstrong\u003e使用 push 还是 pull 取决于具体的问题\u003c/strong\u003e。通常的经验是，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e如果事件频率相对于事件处理时间来说比较低，那 push 模型比较合适；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e如果事件频率很高，就采用 pull 模型\u003c/strong\u003e，否则系统变得不稳定。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e例如，通常的网络驱动会等待网卡事件，而 dpdk 这样的框架会主动 poll 网卡，\n以获得最高的吞吐性能和最低的延迟。\u003c/p\u003e\n\n\u003cp\u003e在一个理想的世界中，我们有如下事件机制：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e操作系统     –\u0026gt; 容器管理服务\u003c/strong\u003e：“我刚给一个容器创建了一个 socket，你需要更新你的状态吗？”\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e容器管理服务 –\u0026gt; 操作系统\u003c/strong\u003e：“谢谢通知，我需要更新。”\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e虽然 Linux 有大量的函数接口用于事件处理，其中包括 3 个用于文件事件的，但\u003cstrong\u003e并没有专\n门用于 socket 事件的\u003c/strong\u003e。你能获取路由表事件、邻居表（2 层转发表）事件，conntrack\n事件，接口（网络设备）变动事件，但就是没有 socket 事件。非要说有的话也行，但它深\n深地隐藏在一个 Netlink 接口中。\u003c/p\u003e\n\n\u003cp\u003e理想情况下，我们需要一个\u003cstrong\u003e通用的方式\u003c/strong\u003e处理事件。怎么做呢？\u003c/p\u003e\n\n\u003ch1 id=\"2-内核跟踪和-ebpf-简史\"\u003e2 内核跟踪和 eBPF 简史\u003c/h1\u003e\n\n\u003cp\u003e直到最近，唯一的通用方式是\u003cstrong\u003e给内核打补丁，或者使用\n\u003ca href=\"https://en.wikipedia.org/wiki/SystemTap\"\u003eSystemTap\u003c/a\u003e\u003c/strong\u003e。SystemTap 是一个 tracing\n系统，简单来说，它\u003cstrong\u003e\u003cmark\u003e提供了一种领域特定语言（DSL），代码编译成内核模块，\n然后热加载到运行中的内核\u003c/mark\u003e\u003c/strong\u003e。但\u003cstrong\u003e出于安全考虑，一些生产系统禁止动态模块加载\u003c/strong\u003e，\n例如我研究 eBPF 时所用的系统就不允许。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e另一种方式是给内核打补丁来触发事件，可能会基于 Netlink\u003c/strong\u003e。这种方式不太方便，内\n核 hacking 有副作用，例如新引入的特性也许有毒，而且会增加维护成本。\u003c/p\u003e\n\n\u003cp\u003e从 Linux 3.15 开始，将任何可跟踪的内核函数\u003cstrong\u003e\u003cmark\u003e安全地\u003c/mark\u003e\u003c/strong\u003e转换成事件，\n很可能将成为现实。在计算机科学的表述中，\u003cstrong\u003e“安全地”\u003c/strong\u003e经常是指通过“某种类型的虚拟机”\n来执行代码，这里也不例外。事实上，Linux 内部的这个“虚拟机”已经存\n在几年了，从 1997 年的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2.1.75\u003c/code\u003e 版本有了，称作伯克利包过滤器（Berkeley Packet\nFilter），缩写 BPF。从名字就可以看出，它最开始是为 BSD 防火墙开发的。\u003cstrong\u003e它只有两\n个寄存器，只允许前向跳转，这意味着无法用它实现循环\u003c/strong\u003e（如果非要说行也可以：如果\n你知道最大的循环次数，那可以手动做循环展开）。这样设计是为了\u003cstrong\u003e保证程序会在有限步骤\n内结束\u003c/strong\u003e，而不会让操作系统卡住。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e更多信息见 \u003ca href=\"/blog/linux-socket-filtering-aka-bpf-zh/\"\u003e(译) Linux Socket Filtering (LSF, aka BPF)（Kernel，2021）\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e你可能在考虑，我已经有 iptables 做防火墙了，要这个有\n什么用？（作为一个例子，）它是 CloudFlare 的防 DDOS 攻击工具\n\u003ca href=\"https://blog.cloudflare.com/bpf-the-forgotten-bytecode/\"\u003eAntiDDos\u003c/a\u003e的基础。\u003c/p\u003e\n\n\u003cp\u003e从 Linux 3.15 开始，BPF 被扩展成了 eBPF，extended BPF 的缩写。它\u003cstrong\u003e从 2 个 32bit\n寄存器扩展到了 10 个 64bit 寄存器，并增加了后向跳转\u003c/strong\u003e。Linux 3.18 中又进行了进一\n步扩展，将它从网络子系统中移出来，并添加了 maps 等工具。为了保证安全性又引入了一\n个校验器，用于验证内存访问的合法性和可能的代码路径。如果校验器不能推断出程序会在\n有限的步骤内结束，就会拒绝程序的注入（内核）。\u003c/p\u003e\n\n\u003cp\u003e更多关于 eBPF 的历史，可以参考 Oracle 的一篇精彩\u003ca href=\"http://events.linuxfoundation.org/sites/events/files/slides/tracing-linux-ezannoni-linuxcon-ja-2015_0.pdf\"\u003e分享\n\u003c/a\u003e\n。\u003c/p\u003e\n\n\u003cp\u003e下面让我们正式开始。\u003c/p\u003e\n\n\u003ch1 id=\"3-hello--world\"\u003e3 Hello,  World!\u003c/h1\u003e\n\n\u003cp\u003e即使对大神级程序员来说写汇编代码也并不是一件方便的事，因此我们这里使用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebcc\u003c/code\u003e。\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebcc\u003c/code\u003e 是基于 LLVM 的工具集，用 Python 封装了底层机器相关的细节。探测代码用 C 写，\n数据用 Python 分析，可以比较容易地开发一些实用工具。\u003c/p\u003e\n\n\u003cp\u003e我们从安装 bcc 开始。本文的一些例子需要 4.4 以上内核。如果你想运行这些例子，我强\n烈建议你启动一个\u003cstrong\u003e虚拟机\u003c/strong\u003e。注意是虚拟机，而不是\u003cstrong\u003edocker 容器\u003c/strong\u003e。容器使用的是宿\n主机内核，因此无法单独更改容器内核。安装参考\n\u003ca href=\"https://github.com/iovisor/bcc/blob/master/INSTALL.md\"\u003eGitHub\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e我们的目标是：每当有程序监听 TCP socket，就得到一个事件通知。当在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAF_INET +\nSOCK_STREAM\u003c/code\u003e 类型 socket 上调用系统调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elisten()\u003c/code\u003e 时，底层负责处理的内核函数就\n是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet_listen()\u003c/code\u003e。我们从用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekprobe\u003c/code\u003e 在它的入口做 hook，打印一个 “Hello, World”\n开始。\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003ebcc\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Hello BPF Program\n\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_text\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u0026#34;\n#include \u0026lt;net/inet_sock.h\u0026gt;\n#include \u0026lt;bcc/proto.h\u0026gt;\n\n// 1. Attach kprobe to \u0026#34;inet_listen\u0026#34;\nint kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)\n{\n    bpf_trace_printk(\u0026#34;Hello World!\u003c/span\u003e\u003cspan class=\"se\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"s\"\u003en\u0026#34;);\n    return 0;\n};\n\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# 2. Build and Inject program\n\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etext\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_text\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# 3. Print debug output\n\u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"bp\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eprint\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etrace_readline\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这个程序做了 3 件事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e依据命名规则，将探测点 attach 到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet_listen\u003c/code\u003e 函数。例如按照这种规则，如果 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emy_probe\u003c/code\u003e 被调用，它\n将会通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb.attach_kprobe(\u0026#34;inet_listen\u0026#34;, \u0026#34;my_probe\u0026#34;)\u003c/code\u003e 显式 attach\u003c/li\u003e\n  \u003cli\u003e使用 LLM eBPF 编译，将生成的字节码用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf()\u003c/code\u003e 系统调用注入（inject）内核，并自动根据命名规则 attach 到 probe 点\u003c/li\u003e\n  \u003cli\u003e从内核管道读取原始格式的输出\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk()\u003c/code\u003e 是内核函数 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eprintk()\u003c/code\u003e 的简单版，用于 debug。它可以将\ntracing 信息打印到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/sys/kernel/debug/tracing/trace_pipe\u003c/code\u003e 下面的一个特殊管道，从\n名字就可以看出这是一个管道。注意如果有多个程序读，只有一个会读到，因此对生产环境\n并不适用。\u003c/p\u003e\n\n\u003cp\u003e幸运的是，Linux 3.19 为消息传递引入了 maps，4.4 引入了任意 perf 事件的支持。本文\n后面会展示基于 perf 事件的例子。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# From a first console\u003c/span\u003e\nubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo\u003c/span\u003e /python tcv4listen.py\nnc-4940  \u003cspan class=\"o\"\u003e[\u003c/span\u003e000] d... 22666.991714: : Hello World!\n\n\u003cspan class=\"c\"\u003e# From a second console\u003c/span\u003e\nubuntu@bcc:~\u003cspan class=\"nv\"\u003e$ \u003c/span\u003enc \u003cspan class=\"nt\"\u003e-l\u003c/span\u003e 0 4242\n^C\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e成功！\u003c/p\u003e\n\n\u003ch1 id=\"4-改进\"\u003e4 改进\u003c/h1\u003e\n\n\u003cp\u003e接下来让我们通过事件发一些有用的信息出来。\u003c/p\u003e\n\n\u003ch2 id=\"41-抓取-tcp-backlog-信息\"\u003e4.1 抓取 TCP backlog 信息\u003c/h2\u003e\n\n\u003cp\u003e“backlog” 是 TCP socket 允许建立的最大连接数（等待被 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaccept()\u003c/code\u003e 的连接数量）。\u003c/p\u003e\n\n\u003cp\u003e对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk\u003c/code\u003e 稍作调整：\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Listening with with up to %d pending connections!\u003c/span\u003e\u003cspan class=\"se\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"s\"\u003en\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e重新运行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003ebcc\u003cspan class=\"o\"\u003e)\u003c/span\u003eubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003epython tcv4listen.py\nnc-5020  \u003cspan class=\"o\"\u003e[\u003c/span\u003e000] d... 25497.154070: : Listening with with up to 1 pending connections!\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 是个\u003cstrong\u003e单连接\u003c/strong\u003e的小工具，因此 backlog 是 1。如果 Nginx 或 Redis，这里将会是\n128，后面会看到。\u003c/p\u003e\n\n\u003cp\u003e是不是很简单？接下来再获取端口和 IP 信息。\u003c/p\u003e\n\n\u003ch2 id=\"42-抓取-port-和-ip-信息\"\u003e4.2 抓取 Port 和 IP 信息\u003c/h2\u003e\n\n\u003cp\u003e浏览内核 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet_listen\u003c/code\u003e 代码发现，我们需要从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esocket\u003c/code\u003e 对象中拿到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet_sock\u003c/code\u003e 字段\n。从内核直接拷贝这两行代码，放到我们 tracing 程序的开始处：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// cast types. Intermediate cast not needed, kept for readability\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003esock\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esk\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esock\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003esk\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003einet_sock\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003einet\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003einet_sk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esk\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在 Port 可以从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet-\u0026gt;inet_sport\u003c/code\u003e 中获得，注意是网络序（大端）。\u003c/p\u003e\n\n\u003cp\u003e如此简单！再更新下打印：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Listening on port %d!\u003c/span\u003e\u003cspan class=\"se\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"s\"\u003en\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003einet\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003einet_sport\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e运行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo\u003c/span\u003e /python tcv4listen.py\n...\nR1 invalid mem access \u003cspan class=\"s1\"\u003e\u0026#39;inv\u0026#39;\u003c/span\u003e\n...\nException: Failed to load BPF program kprobe__inet_listen\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从出错信息看，内核校验器无法验证这个程序的内存访问是合法的。解决办法是让内存访问\n变得更加显式：使用受信任的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_probe_read\u003c/code\u003e 函数，只要有必要的安全检测，可以用它\n读取任何内存地址。\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// Explicit initialization. The \u0026#34;=0\u0026#34; part is needed to \u0026#34;give life\u0026#34; to the variable on the stack\u003c/span\u003e\n\u003cspan class=\"n\"\u003eu16\u003c/span\u003e \u003cspan class=\"n\"\u003elport\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Explicit arbitrary memory access. Read it:\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// Read into \u0026#39;lport\u0026#39;, \u0026#39;sizeof(lport)\u0026#39; bytes from \u0026#39;inet-\u0026gt;inet_sport\u0026#39; memory location\u003c/span\u003e\n\u003cspan class=\"n\"\u003ebpf_probe_read\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003einet\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003einet_sport\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e获取 IP 与此类似，从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einet-\u0026gt;inet_rcv_saddr\u003c/code\u003e 读取。综上，现在我们可以读取 backlog\n，port 和绑定的 IP：\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kn\"\u003efrom\u003c/span\u003e \u003cspan class=\"nn\"\u003ebcc\u003c/span\u003e \u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# BPF Program\n\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_text\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;\u0026#34;\u0026#34;\n#include \u0026lt;net/sock.h\u0026gt;\n#include \u0026lt;net/inet_sock.h\u0026gt;\n#include \u0026lt;bcc/proto.h\u0026gt;\n\n// Send an event for each IPv4 listen with PID, bound address and port\nint kprobe__inet_listen(struct pt_regs *ctx, struct socket *sock, int backlog)\n{\n    // Cast types. Intermediate cast not needed, kept for readability\n    struct sock *sk = sock-\u0026gt;sk;\n    struct inet_sock *inet = inet_sk(sk);\n\n    // Working values. You *need* to initialize them to give them \u0026#34;life\u0026#34; on the stack and use them afterward\n    u32 laddr = 0;\n    u16 lport = 0;\n\n    // Pull in details. As \u0026#39;inet_sk\u0026#39; is internally a type cast, we need to use \u0026#39;bpf_probe_read\u0026#39;\n    // read: load into \u0026#39;laddr\u0026#39; \u0026#39;sizeof(laddr)\u0026#39; bytes from address \u0026#39;inet-\u0026gt;inet_rcv_saddr\u0026#39;\n    bpf_probe_read(\u0026amp;laddr, sizeof(laddr), \u0026amp;(inet-\u0026gt;inet_rcv_saddr));\n    bpf_probe_read(\u0026amp;lport, sizeof(lport), \u0026amp;(inet-\u0026gt;inet_sport));\n\n    // Push event\n    bpf_trace_printk(\u0026#34;Listening on %x %d with %d pending connections\u003c/span\u003e\u003cspan class=\"se\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"s\"\u003en\u0026#34;, ntohl(laddr), ntohs(lport), backlog);\n    return 0;\n};\n\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Build and Inject BPF\n\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eBPF\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003etext\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003ebpf_text\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Print debug output\n\u003c/span\u003e\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"bp\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"k\"\u003eprint\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etrace_readline\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e输出信息：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003ebcc\u003cspan class=\"o\"\u003e)\u003c/span\u003eubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003epython tcv4listen.py\nnc-5024  \u003cspan class=\"o\"\u003e[\u003c/span\u003e000] d... 25821.166286: : Listening on 7f000001 4242 with 1 pending connections\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里 IP 是用 16 进制打印的，没有转换成适合人读的格式。\u003c/p\u003e\n\n\u003cp\u003e注：你可能会有疑问，为什么 \u003cstrong\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003entohs\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003entohl\u003c/code\u003e 并不是受信任的\u003c/strong\u003e，却可以在 BPF 里\n被调用。这是因为他们是定义在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.h\u003c/code\u003e 文件中的内联函数，在写作本文期间，修了一个与此相\n关的小\u003ca href=\"https://github.com/iovisor/bcc/pull/453\"\u003ebug\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e接下来，我们想获取相关的容器（container）。对于网络，这意味着我们要获得网络命名\n空间。网络命名空间是容器的基石之一，使得（docker 等）容器拥有隔离的网络。\u003c/p\u003e\n\n\u003ch2 id=\"43-抓取网络命名空间信息\"\u003e4.3 抓取网络命名空间信息\u003c/h2\u003e\n\n\u003cp\u003e在用户空间，可以在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc/PID/ns/net\u003c/code\u003e 查看网络命名空间，格式类似于\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet:[4026531957]\u003c/code\u003e。中括号中的数字是\u003cstrong\u003e网络命名空间的 inode\u003c/strong\u003e。这意味着，想获取命\n名空间，我们直接去读 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/proc\u003c/code\u003e 就行了。但是，这种方式太粗暴，只适用于运行时间比较\n短的进程；而且还存在竞争。我们接下来从 kernel 直接读取 inode 值，幸运的是，这很\n容易：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// Create an populate the variable\u003c/span\u003e\n\u003cspan class=\"n\"\u003eu32\u003c/span\u003e \u003cspan class=\"n\"\u003enetns\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// Read the netns inode number, like /proc does\u003c/span\u003e\n\u003cspan class=\"n\"\u003enetns\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esk\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003e__sk_common\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eskc_net\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enet\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ens\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einum\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e更新打印格式：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003ebpf_trace_printk\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Listening on %x %d with %d pending connections in container %d\u003c/span\u003e\u003cspan class=\"se\"\u003e\\\\\u003c/span\u003e\u003cspan class=\"s\"\u003en\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003entohl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eladdr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003entohs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003enetns\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e执行的时候，遇到如下错误：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003ebcc\u003cspan class=\"o\"\u003e)\u003c/span\u003eubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003epython tcv4listen.py\nerror: \u003cspan class=\"k\"\u003ein function \u003c/span\u003ekprobe__inet_listen i32 \u003cspan class=\"o\"\u003e(\u003c/span\u003e%struct.pt_regs\u003cspan class=\"k\"\u003e*\u003c/span\u003e, %struct.socket\u003cspan class=\"k\"\u003e*\u003c/span\u003e, i32\u003cspan class=\"o\"\u003e)\u003c/span\u003e\ntoo many args to 0x1ba9108: i64 \u003cspan class=\"o\"\u003e=\u003c/span\u003e Constant\u0026lt;6\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eClang 想告诉你的是：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf_trace_printk\u003c/code\u003e 只能带 4 个参数，而你传了 5 个给它。这里\n我不展开，只告诉你结论：这是 BPF 的限制。想深入了解，\u003ca href=\"http://lxr.free-electrons.com/source/kernel/trace/bpf_trace.c#L86\"\u003e这里\n\u003c/a\u003e是不错的入门\n点。\u003c/p\u003e\n\n\u003cp\u003e唯一解决这个问题的办法就是。。把 eBPF 做到生产 ready（写作本文时还没，因此 eBPF\n的探索就都这里了，译者注）。所以接下来我们换到 perf，它支持传递任意大小的结构体\n到用户空间。注意需要 Linux 4.4 以上内核。\u003c/p\u003e\n\n\u003cp\u003e要使用 perf，我们需要：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e定义一个结构体\u003c/li\u003e\n  \u003cli\u003e声明一个事件\u003c/li\u003e\n  \u003cli\u003e推送（push）事件\u003c/li\u003e\n  \u003cli\u003ePython 端再定义一遍这个事件（将来这一步就不需要了）\u003c/li\u003e\n  \u003cli\u003e消费并格式化输出事件\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e看起来要做的事情很多，其实不是。\u003c/p\u003e\n\n\u003cp\u003eC 端：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e// At the begining of the C program, declare our event\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elisten_evt_t\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003eladdr\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003enetns\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eu64\u003c/span\u003e \u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003cspan class=\"n\"\u003eBPF_PERF_OUTPUT\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elisten_evt\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e// In kprobe__inet_listen, replace the printk with\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003elisten_evt_t\u003c/span\u003e \u003cspan class=\"n\"\u003eevt\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eladdr\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003entohl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eladdr\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003entohs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enetns\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003enetns\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003cspan class=\"n\"\u003elisten_evt\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eperf_submit\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eevt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003esizeof\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eevt\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ePython 端事情稍微多一点：\u003c/p\u003e\n\n\u003cdiv class=\"language-python highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c1\"\u003e# We need ctypes to parse the event structure\n\u003c/span\u003e\u003cspan class=\"kn\"\u003eimport\u003c/span\u003e \u003cspan class=\"nn\"\u003ectypes\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Declare data format\n\u003c/span\u003e\u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eListenEvt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eStructure\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e_fields_\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;laddr\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e   \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec_ulonglong\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;lport\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e   \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec_ulonglong\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;netns\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e   \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec_ulonglong\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;backlog\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ec_ulonglong\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e]\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Declare event printer\n\u003c/span\u003e\u003cspan class=\"k\"\u003edef\u003c/span\u003e \u003cspan class=\"nf\"\u003eprint_event\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecpu\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esize\u003c/span\u003e\u003cspan class=\"p\"\u003e):\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eevent\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ecast\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ectypes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ePOINTER\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eListenEvt\u003c/span\u003e\u003cspan class=\"p\"\u003e)).\u003c/span\u003e\u003cspan class=\"n\"\u003econtents\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eprint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Listening on %x %d with %d pending connections in container %d\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e%\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eladdr\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003elport\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebacklog\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eevent\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003enetns\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\n\u003cspan class=\"c1\"\u003e# Replace the event loop\n\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;listen_evt\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e].\u003c/span\u003e\u003cspan class=\"n\"\u003eopen_perf_buffer\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eprint_event\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"bp\"\u003eTrue\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ekprobe_poll\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e测试一下，这里我用一个跑在容器里的 redis，在宿主机上用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enc\u003c/code\u003e 命令：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003ebcc\u003cspan class=\"o\"\u003e)\u003c/span\u003eubuntu@bcc:~/dev/listen-evts\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003epython tcv4listen.py\nListening on 0 6379 with 128 pending connections \u003cspan class=\"k\"\u003ein \u003c/span\u003econtainer 4026532165\nListening on 0 6379 with 128 pending connections \u003cspan class=\"k\"\u003ein \u003c/span\u003econtainer 4026532165\nListening on 7f000001 6588 with 1 pending connections \u003cspan class=\"k\"\u003ein \u003c/span\u003econtainer 4026531957\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1 id=\"5-结束语\"\u003e5 结束语\u003c/h1\u003e\n\n\u003cp\u003e使用 eBPF，任何内核的函数调用都可以转换成事件触发的方式。本文也展示了笔者过程中\n遇到的一些常见的坑。完整代码（包括 IPv6 支持）见\n\u003ca href=\"https://github.com/iovisor/bcc/blob/master/tools/solisten.py\"\u003e这里\u003c/a\u003e，\n感谢 bcc team 的支持，现在它已经是一个正式工具。\u003c/p\u003e\n\n\u003cp\u003e想更深入了解这个 topic，建议阅读 Brendan Gregg 的博客。Brendan\nGregg 是这个项目的主要贡献者之一。\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/trace-packet-with-tracepoint-perf-ebpf-zh/\"\u003e\u003cspan\u003e« [译] 使用 Linux tracepoint、perf 和 eBPF 跟踪数据包 (2017)\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/tuning-stack-rx-zh/\"\u003e\u003cspan\u003e[译] Linux 网络栈监控和调优：接收数据（2016） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2018-12-03T00:00:00Z",
  "Author": "Arthur Chiao"
}