{
  "Source": "arthurchiao.art",
  "Title": "Linux 服务器功耗与性能管理（五）：问题讨论（2024）",
  "Link": "https://arthurchiao.art/blog/linux-cpu-5-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux 服务器功耗与性能管理（五）：问题讨论（2024）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2024-02-15 | Last Update 2024-02-15\u003c/p\u003e\n  \n  \u003cp\u003e整理一些 Linux 服务器性能相关的 CPU 硬件基础及内核子系统知识。\u003c/p\u003e\n\n\u003cp\u003e水平有限，文中不免有错误或过时之处，请酌情参考。\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-1-zh/\"\u003eLinux 服务器功耗与性能管理（一）：CPU 硬件基础（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-2-zh/\"\u003eLinux 服务器功耗与性能管理（二）：几个内核子系统的设计（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-3-zh/\"\u003eLinux 服务器功耗与性能管理（三）：cpuidle 子系统的实现（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-4-zh/\"\u003eLinux 服务器功耗与性能管理（四）：监控、配置、调优（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-5-zh/\"\u003eLinux 服务器功耗与性能管理（五）：问题讨论（2024）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-idlepoll-的潜在风险\" id=\"markdown-toc-1-idlepoll-的潜在风险\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 的潜在风险\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-515-内核文档-cpu-idle-time-management\" id=\"markdown-toc-11-515-内核文档-cpu-idle-time-management\"\u003e1.1. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “CPU Idle Time Management”\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12--515-内核文档-no_hz-reducing-scheduling-clock-ticks\" id=\"markdown-toc-12--515-内核文档-no_hz-reducing-scheduling-clock-ticks\"\u003e1.2  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “NO_HZ: Reducing Scheduling-Clock Ticks”\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-515-内核文档-amd64-specific-boot-options\" id=\"markdown-toc-13-515-内核文档-amd64-specific-boot-options\"\u003e1.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “AMD64 Specific Boot Options”\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#14-dell-whitepaper-controlling-processor-c-state-usage-in-linux-2013\" id=\"markdown-toc-14-dell-whitepaper-controlling-processor-c-state-usage-in-linux-2013\"\u003e1.4 Dell Whitepaper: Controlling Processor C-State Usage in Linux, 2013\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#15-i-really-dont-think-you-should-really-ever-use-idlepoll-on-ht-enabled-hardware-linus-2003\" id=\"markdown-toc-15-i-really-dont-think-you-should-really-ever-use-idlepoll-on-ht-enabled-hardware-linus-2003\"\u003e1.5 I really don’t think you should really ever use “idle=poll” on HT-enabled hardware, Linus, 2003\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#16-小结\" id=\"markdown-toc-16-小结\"\u003e1.6 小结\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-内核大量-acpi-日志\" id=\"markdown-toc-2-内核大量-acpi-日志\"\u003e2 内核大量 ACPI 日志\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-idlepoll-的潜在风险\"\u003e1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 的潜在风险\u003c/h1\u003e\n\n\u003cp\u003e前面已经介绍过，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 就是强制处理器工作在 C0，保持最高性能。\n但内核文档中好几个地方提示这样设置是有风险的，这里整理一下。\u003c/p\u003e\n\n\u003ch2 id=\"11-515-内核文档-cpu-idle-time-management\"\u003e1.1. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “CPU Idle Time Management”\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/admin-guide/pm/cpuidle.rst\"\u003eCPU Idle Time Management\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eusing ``idle=poll`` is somewhat drastic in many cases, as preventing idle\nCPUs from saving almost any energy at all may not be the only effect of it.\n\nFor example, on Intel hardware it effectively prevents CPUs from using\nP-states (see |cpufreq|) that require any number of CPUs in a package to be\nidle, so it very well may hurt single-thread computations performance as well as\nenergy-efficiency.  Thus using it for performance reasons may not be a good idea\nat all.]\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这段写的比较晦涩，基于本系列前几篇的基础，尝试给大家翻译一下：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 除了功耗高，还有其他后果；例如，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 Intel 处理器上，这会使得 p-states 功能无法正常工作，\n因而\u003cstrong\u003e\u003cmark\u003e无法将同属一个 PKG 的那些空闲 CPU 的功耗降低\u003c/mark\u003e\u003c/strong\u003e，\n这不是省不省电本身的问题：\u003cstrong\u003e\u003cmark\u003e空闲的 CPU 不降低功耗，其他的 CPU 可能就无法超频！\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e所以对于单线程的任务来说（更宽泛的来说，是这样一类场景下：系统比较空闲，只有少量线程在执行），\n\u003cstrong\u003e\u003cmark\u003e性能反而无法达到最优\u003c/mark\u003e\u003c/strong\u003e，因为总功耗限制下，少量在工作的 CPU 无法超频（turbo）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e另外，这个文档是 Intel 的人写的，但看过超频原理就应该明白，这个问题不仅限于 Intel CPU。\u003c/p\u003e\n\n\u003ch2 id=\"12--515-内核文档-no_hz-reducing-scheduling-clock-ticks\"\u003e1.2  \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “NO_HZ: Reducing Scheduling-Clock Ticks”\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/timers/no_hz.rst\"\u003eNO_HZ: Reducing Scheduling-Clock Ticks\u003c/a\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eKnown Issues\n    d.    On x86 systems, use the \u0026#34;idle=poll\u0026#34; boot parameter.\n        However, please note that use of this parameter can cause\n        your CPU to overheat, which may cause thermal throttling\n        to degrade your latencies -- and that this degradation can\n        be even worse than that of dyntick-idle.  Furthermore,\n        this parameter effectively disables Turbo Mode on Intel\n        CPUs, which can significantly reduce maximum performance.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这是归类到了\u003cstrong\u003e\u003cmark\u003e已知问题\u003c/mark\u003e\u003c/strong\u003e，写的比前一篇清楚多了：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e导致 CPU 过热，延迟可能上升，可能比 tickless 模式（dyntick）的延迟还大；\u003c/li\u003e\n  \u003cli\u003e更重要的，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e effectively \u003cstrong\u003e\u003cmark\u003e禁用了 Intel Turbo Mode\u003c/mark\u003e\u003c/strong\u003e，\n  也就是无法超频到 base frequency 以上，因此\u003cstrong\u003e\u003cmark\u003e峰值性能显著变差\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch2 id=\"13-515-内核文档-amd64-specific-boot-options\"\u003e1.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e5.15\u003c/code\u003e 内核文档 “AMD64 Specific Boot Options”\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/Documentation/x86/x86_64/boot-options.rst\"\u003eAMD64 Specific Boot Options\u003c/a\u003e：\u003c/p\u003e\n\n\u003cp\u003e这个是启动项说明，里面以 Intel CPU 为例但问题不仅限于 Intel，\nAMD 的很多在用参数和功能这个文档里都没有，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eIdle loop\n=========\n\n  idle=poll\n    Don\u0026#39;t do power saving in the idle loop using HLT, but poll for rescheduling\n    event. This will make the CPUs eat a lot more power, but may be useful\n    to get slightly better performance in multiprocessor benchmarks. It also\n    makes some profiling using performance counters more accurate.\n    Please note that on systems with MONITOR/MWAIT support (like Intel EM64T\n    CPUs) this option has no performance advantage over the normal idle loop.\n    It may also interact badly with hyperthreading.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 在某些场景下能提升 multiple benchmark 的性能，也能让某些 profiling 更准确一些；\u003c/li\u003e\n  \u003cli\u003e在支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMONITOR/MWAIT\u003c/code\u003e 的平台上，这个配置并不会带来性能提升；\u003c/li\u003e\n  \u003cli\u003e最后一句：\u003cstrong\u003e\u003cmark\u003e与超线程的交互（兼容）可能很差\u003c/mark\u003e\u003c/strong\u003e。为什么？没说，\n但是下面来自 Dell 的一篇白皮书做了一些进一步解释。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"14-dell-whitepaper-controlling-processor-c-state-usage-in-linux-2013\"\u003e1.4 Dell Whitepaper: Controlling Processor C-State Usage in Linux, 2013\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://wiki.bu.ost.ch/infoportal/_media/embedded_systems/ethercat/controlling_processor_c-state_usage_in_linux_v1.1_nov2013.pdf\"\u003eDell Whitepaper: Controlling Processor C-State Usage in Linux\u003c/a\u003e，\n服务器厂商 Dell 的技术白皮书，其中一段，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eIf a user wants the absolute minimum latency, kernel parameter “idle=poll” can be used to keep the\nprocessors in C0 even when they are idle (the processors will run in a loop when idle, constantly\nchecking to see if they are needed). If this kernel parameter is used, it should not be necessary to\ndisable C-states in BIOS (or use the “idle=halt” kernel parameter).\n\nTake care when keeping processors in C0, though--this will increase power usage considerably.\nAlso, hyperthreading should probably be\ndisabled, as keeping processors in C0 can interfere with proper operation of logical cores\n(hyperthreading). (The hyperthreading hardware works best when it knows when the logical processors\nare idle, and it doesn’t know that if processors are kept busy in a loop when they are not running\nuseful code.)\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n  \u003cli\u003e可能需要关闭 hyperthreading，因为\u003cstrong\u003e\u003cmark\u003e处理器保持在 C0 状态\u003c/mark\u003e\u003c/strong\u003e会\u003cstrong\u003e\u003cmark\u003e干扰逻辑核（也就是超线程）的正常功能\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e超线程硬件的工作原理：\u003c/p\u003e\n\n    \u003cul\u003e\n      \u003cli\u003e根据逻辑核（硬件线程）的\u003cstrong\u003e\u003cmark\u003e空闲状态\u003c/mark\u003e\u003c/strong\u003e，做出下一步判断和动作；\u003c/li\u003e\n      \u003cli\u003eC0 会在没有任务时\u003cstrong\u003e\u003cmark\u003e执行无意义代码\u003c/mark\u003e\u003c/strong\u003e（即前面说的“轻量级”指令流）来保持处理器处于繁忙状态，\n用这种方式\u003cstrong\u003e\u003cmark\u003e避免处理器进入节能状态\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eC0 模式的这种行为使得\u003cstrong\u003e\u003cmark\u003e超线程硬件无法判断硬件处理器的真实状态\u003c/mark\u003e\u003c/strong\u003e（区分不出在执行有意义代码还是无意义代码），\n因而无法有效工作。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"15-i-really-dont-think-you-should-really-ever-use-idlepoll-on-ht-enabled-hardware-linus-2003\"\u003e1.5 I really don’t think you should really ever use “idle=poll” on HT-enabled hardware, Linus, 2003\u003c/h2\u003e\n\n\u003cp\u003e用户报告 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll + hyperthreading\u003c/code\u003e 导致并发性能显著变差，\nLinus 回复说，\n\u003ca href=\"https://linux-kernel.vger.kernel.narkive.com/gVqKQELn/ht-and-idle-poll\"\u003eI really don’t think you should really ever use “idle=poll” on HT-enabled hardware\u003c/a\u003e，\n\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eHT\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 是超线程的缩写。\u003c/p\u003e\n\n\u003ch2 id=\"16-小结\"\u003e1.6 小结\u003c/h2\u003e\n\n\u003cp\u003e看起来 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eidle=poll\u003c/code\u003e 与 turbo-frequency/hyperthreading 存在工作机制的冲突。\u003c/p\u003e\n\n\u003cp\u003e需要一些场景和 testcase 来验证。有经验的专家大佬，欢迎交流。\u003c/p\u003e\n\n\u003ch1 id=\"2-内核大量-acpi-日志\"\u003e2 内核大量 ACPI 日志\u003c/h1\u003e\n\n\u003cp\u003e一台惠普机器：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edmesg \u003cspan class=\"nt\"\u003e-T\u003c/span\u003e\nkernel: ACPI Error: SMBus/IPMI/GenericSerialBus write requires Buffer of length 66, found length 32 \u003cspan class=\"o\"\u003e(\u003c/span\u003e20180810/exfield-393\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nkernel: ACPI Error: Method parse/execution failed \u003cspan class=\"se\"\u003e\\_\u003c/span\u003eSB.PMI0._PMM, AE_AML_BUFFER_LIMIT \u003cspan class=\"o\"\u003e(\u003c/span\u003e20180810/psparse-516\u003cspan class=\"o\"\u003e)\u003c/span\u003e\nkernel: ACPI Error: AE_AML_BUFFER_LIMIT, Evaluating _PMM \u003cspan class=\"o\"\u003e(\u003c/span\u003e20180810/power_meter-338\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这是 HP 的 BIOS 实现没有遵守协议，实际上这个报错不会产生硬件性能影响之类的（但是打印的日志量可能很大，每分钟十几条，不间断）。\u003c/p\u003e\n\n\u003cp\u003e一台联想机器：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edmesg \u003cspan class=\"nt\"\u003e-T\u003c/span\u003e\nkernel: power_meter ACPI000D:00: Found ACPI power meter.\nkernel: power_meter ACPI000D:00: Found ACPI power meter.\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e如果是 k8s node 遇到以上问题，可能是部署了 \u003ca href=\"https://github.com/prometheus/node_exporter\"\u003eprometheus/node_exporter\u003c/a\u003e 导致的 [2]，\n试试关闭其 hwmon collector。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://wiki.bu.ost.ch/infoportal/_media/embedded_systems/ethercat/controlling_processor_c-state_usage_in_linux_v1.1_nov2013.pdf\"\u003eControlling Processor C-State Usage in Linux\u003c/a\u003e, A Dell technical white paper describing the use of C-states with Linux operating systems, 2013\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://forums.percona.com/t/after-pmm2-client-installation-kernel-acpi-error-smbus-ipmi-genericserialbus-write-requires-buffer-of-length-66/20425/2\"\u003eAfter PMM2 client installation kernel: ACPI Error: SMBus/IPMI/GenericSerialBus write requires Buffer of length 66\u003c/a\u003e, forums.percona.com, 2023\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/linux-cpu-4-zh/\"\u003e\u003cspan\u003e« Linux 服务器功耗与性能管理（四）：监控、配置、调优（2024）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2024-02-15T00:00:00Z",
  "Author": "Arthur Chiao"
}