{
  "Source": "arthurchiao.art",
  "Title": "Linux 时钟源之 TSC：软硬件原理、使用场景、已知问题（2024）",
  "Link": "https://arthurchiao.art/blog/linux-clock-source-tsc-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLinux 时钟源之 TSC：软硬件原理、使用场景、已知问题（2024）\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2024-07-28 | Last Update 2024-10-10\u003c/p\u003e\n  \n  \u003cp\u003e本文整理了一些 Linux 时钟源 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etsc\u003c/code\u003e 相关的软硬件知识，在一些故障排查场景可能会用到。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/freq-scale-up.gif\" width=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Scaling up crystal frequency for different components of a computer.\nImage source \u003ca href=\"https://www.youtube.com/watch?v=B7djs4zSbuU\u0026amp;t=150s\"\u003eYoutube\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e水平及维护精力所限，文中不免存在错误或过时之处，请酌情参考。\n\u003cstrong\u003e\u003cmark\u003e传播知识，尊重劳动，年满十八周岁，转载请注明\u003ca href=\"https://arthurchiao.art\"\u003e出处\u003c/a\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003chr/\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#1-计算机组件的运行频率\" id=\"markdown-toc-1-计算机组件的运行频率\"\u003e1 计算机组件的运行频率\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-时钟源20mhz-的石英晶体谐振器quartz-crystal-resonator\" id=\"markdown-toc-11-时钟源20mhz-的石英晶体谐振器quartz-crystal-resonator\"\u003e1.1 时钟源：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~20MHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的石英晶体谐振器（quartz crystal resonator）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-clock-generator针对不同部分内存pciecpu-等倍频\" id=\"markdown-toc-12-clock-generator针对不同部分内存pciecpu-等倍频\"\u003e1.2 Clock generator：针对不同部分（内存、PCIe、CPU 等）倍频\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-cpu-频率是如何从-20mhz-提升到-3ghz-的\" id=\"markdown-toc-13-cpu-频率是如何从-20mhz-提升到-3ghz-的\"\u003e1.3 CPU 频率是如何从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~20MHz\u003c/code\u003e 提升到 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~3GHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#131-传递路径最终连接到-cpu-clk-引脚\" id=\"markdown-toc-131-传递路径最终连接到-cpu-clk-引脚\"\u003e1.3.1 传递路径：最终连接到 CPU \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCLK\u003c/code\u003e 引脚\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#132-cpu-内部还有一个-clock-generator\" id=\"markdown-toc-132-cpu-内部还有一个-clock-generator\"\u003e1.3.2 CPU 内部：还有一个 clock generator\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#2-x86-架构的寄存器\" id=\"markdown-toc-2-x86-架构的寄存器\"\u003e2 x86 架构的寄存器\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-通用目的寄存器\" id=\"markdown-toc-21-通用目的寄存器\"\u003e2.1 通用目的寄存器\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-特殊目的寄存器\" id=\"markdown-toc-22-特殊目的寄存器\"\u003e2.2 特殊目的寄存器\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#221-model-specific-register-msr\" id=\"markdown-toc-221-model-specific-register-msr\"\u003e2.2.1 model-specific register (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR\u003c/code\u003e)\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#222-msr-之一tsc\" id=\"markdown-toc-222-msr-之一tsc\"\u003e2.2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR\u003c/code\u003e 之一：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTSC\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#3-tsc时间戳计数器\" id=\"markdown-toc-3-tsc时间戳计数器\"\u003e3 TSC（时间戳计数器）\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#31-本质x86-处理器中的一个-特殊寄存器\" id=\"markdown-toc-31-本质x86-处理器中的一个-特殊寄存器\"\u003e3.1 本质：X86 处理器中的一个 \u003cstrong\u003e\u003cmark\u003e特殊寄存器\u003c/mark\u003e\u003c/strong\u003e\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#32-作用记录-cpu-启动以来累计的-cycles-数量\" id=\"markdown-toc-32-作用记录-cpu-启动以来累计的-cycles-数量\"\u003e3.2 作用：记录 cpu 启动以来累计的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecycles\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 数量\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#33-实际经常被当做高精度时钟用\" id=\"markdown-toc-33-实际经常被当做高精度时钟用\"\u003e3.3 实际：经常被当做（高精度）时钟用\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#331-使用代码\" id=\"markdown-toc-331-使用代码\"\u003e3.3.1 使用代码\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#331-潜在问题\" id=\"markdown-toc-331-潜在问题\"\u003e3.3.1 潜在问题\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#34-挑战tsc-的准确性越来越难以保证\" id=\"markdown-toc-34-挑战tsc-的准确性越来越难以保证\"\u003e3.4 挑战：TSC 的准确性越来越难以保证\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-改进引入-constantinvariant-tsc\" id=\"markdown-toc-35-改进引入-constantinvariant-tsc\"\u003e3.5 改进：引入 constant/invariant TSC\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#35-小结计数器counter而非时钟clock\" id=\"markdown-toc-35-小结计数器counter而非时钟clock\"\u003e3.5 小结：\u003cstrong\u003e\u003cmark\u003e计数器\u003c/mark\u003e\u003c/strong\u003e（counter），而非时钟（clock）\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#4-查看和监控-tsc-相关信息\" id=\"markdown-toc-4-查看和监控-tsc-相关信息\"\u003e4 查看和监控 TSC 相关信息\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-linux-系统时钟源clocksource配置\" id=\"markdown-toc-41-linux-系统时钟源clocksource配置\"\u003e4.1 Linux 系统时钟源（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclocksource\u003c/code\u003e）配置\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#411-tsc优先\" id=\"markdown-toc-411-tsc优先\"\u003e4.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etsc\u003c/code\u003e：优先\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#412-hpet性能开销太大\" id=\"markdown-toc-412-hpet性能开销太大\"\u003e4.1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehpet\u003c/code\u003e：性能开销太大\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-turbostat-查看实际-tsc-计数可能不准\" id=\"markdown-toc-42-turbostat-查看实际-tsc-计数可能不准\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e 查看实际 TSC 计数（可能不准）\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-rdtscrdtscp-指令采集-tsc-计数\" id=\"markdown-toc-43-rdtscrdtscp-指令采集-tsc-计数\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtsc/rdtscp\u003c/code\u003e 指令采集 TSC 计数\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#431-c-代码\" id=\"markdown-toc-431-c-代码\"\u003e4.3.1 C 代码\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#432-执行效果\" id=\"markdown-toc-432-执行效果\"\u003e4.3.2 执行效果\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#44-监控\" id=\"markdown-toc-44-监控\"\u003e4.4 监控\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#441-基于-turbostat不推荐\" id=\"markdown-toc-441-基于-turbostat不推荐\"\u003e4.4.1 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e（不推荐）\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#442-基于-rdtscp\" id=\"markdown-toc-442-基于-rdtscp\"\u003e4.4.2 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#443-基于-rdtscp--内核模块\" id=\"markdown-toc-443-基于-rdtscp--内核模块\"\u003e4.4.3 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e + 内核模块\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#5-tsc-若干坑\" id=\"markdown-toc-5-tsc-若干坑\"\u003e5 TSC 若干坑\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#51-constant_tsc-a-feature-not-a-runtime-guarantee\" id=\"markdown-toc-51-constant_tsc-a-feature-not-a-runtime-guarantee\"\u003e5.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econstant_tsc\u003c/code\u003e: a feature, not a runtime guarantee\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#511-lenovo-sr645-amd-epyc-7543-cpu-tsc-不稳定\" id=\"markdown-toc-511-lenovo-sr645-amd-epyc-7543-cpu-tsc-不稳定\"\u003e5.1.1 Lenovo SR645 (AMD EPYC 7543 CPU) TSC 不稳定\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#512-原因及解决方式\" id=\"markdown-toc-512-原因及解决方式\"\u003e5.1.2 原因及解决方式\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#52-bios-设置致使-tsc-不恒定\" id=\"markdown-toc-52-bios-设置致使-tsc-不恒定\"\u003e5.2 BIOS 设置致使 TSC 不恒定\u003c/a\u003e        \u003cul\u003e\n          \u003cli\u003e\u003ca href=\"#521-tsc-寄存器是可写的\" id=\"markdown-toc-521-tsc-寄存器是可写的\"\u003e5.2.1 TSC 寄存器是\u003cstrong\u003e\u003cmark\u003e可写\u003c/mark\u003e\u003c/strong\u003e的！\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#522-bios-smi-handler-通过修改-tsc-隐藏它们的执行\" id=\"markdown-toc-522-bios-smi-handler-通过修改-tsc-隐藏它们的执行\"\u003e5.2.2 BIOS SMI handler 通过修改 TSC 隐藏它们的执行\u003c/a\u003e\u003c/li\u003e\n          \u003cli\u003e\u003ca href=\"#523-服务器厂商出于功耗控制等原因在-bios-修改-tsc-同步逻辑\" id=\"markdown-toc-523-服务器厂商出于功耗控制等原因在-bios-修改-tsc-同步逻辑\"\u003e5.2.3 服务器厂商出于功耗控制等原因在 BIOS 修改 TSC 同步逻辑\u003c/a\u003e\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#53-smi-中断风暴导致-tsc-不稳\" id=\"markdown-toc-53-smi-中断风暴导致-tsc-不稳\"\u003e5.3 SMI 中断风暴导致 TSC 不稳\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#54-vm-tsc-不稳\" id=\"markdown-toc-54-vm-tsc-不稳\"\u003e5.4 VM TSC 不稳\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#6-总结\" id=\"markdown-toc-6-总结\"\u003e6 总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#参考资料\" id=\"markdown-toc-参考资料\"\u003e参考资料\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"1-计算机组件的运行频率\"\u003e1 计算机组件的运行频率\u003c/h1\u003e\n\n\u003ch2 id=\"11-时钟源20mhz-的石英晶体谐振器quartz-crystal-resonator\"\u003e1.1 时钟源：\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~20MHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的石英晶体谐振器（quartz crystal resonator）\u003c/h2\u003e\n\n\u003cp\u003e石英晶体谐振器是利用\u003cstrong\u003e\u003cmark\u003e石英晶体（又称水晶）\u003c/mark\u003e\u003c/strong\u003e的\u003cstrong\u003e\u003cmark\u003e压电效应\u003c/mark\u003e\u003c/strong\u003e\n来产生高精度\u003cstrong\u003e\u003cmark\u003e振荡频率\u003c/mark\u003e\u003c/strong\u003e的一种电子器件。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003e1880 年由雅克·居里与皮埃尔·居里发现压电效应。\u003c/li\u003e\n    \u003cli\u003e一战期间 保罗·朗之万首先探讨了石英谐振器在声纳上的应用。\u003c/li\u003e\n    \u003cli\u003e1917 第一个由晶体控制的电子式振荡器。\u003c/li\u003e\n    \u003cli\u003e1918 年贝尔实验室的 Alexander M. Nicholson 取得专利，虽然与同时申请专利的 Walter Guyton Cady 曾有争议。\u003c/li\u003e\n    \u003cli\u003e1921 年 Cady 制作了第一个石英晶体振荡器。\u003c/li\u003e\n  \u003c/ul\u003e\n\n  \u003cp\u003eWikipedia \u003ca href=\"https://zh.wikipedia.org/zh-cn/%E7%9F%B3%E8%8B%B1%E6%99%B6%E4%BD%93%E8%B0%90%E6%8C%AF%E5%99%A8\"\u003e石英晶体谐振器\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e现在一般长这样，焊在计算机\u003cstrong\u003e\u003cmark\u003e主板\u003c/mark\u003e\u003c/strong\u003e上，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/Crystal_oscillator_4MHz.jpg\" width=\"40%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. A miniature 16 MHz quartz crystal enclosed in a hermetically sealed HC-49/S package, used as the resonator in a crystal oscillator.\nImage source \u003ca href=\"https://en.wikipedia.org/wiki/Crystal_oscillator\"\u003ewikipedia\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e受物理特性的限制，只有\u003cstrong\u003e\u003cmark\u003e几十 MHz\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"12-clock-generator针对不同部分内存pciecpu-等倍频\"\u003e1.2 Clock generator：针对不同部分（内存、PCIe、CPU 等）倍频\u003c/h2\u003e\n\n\u003cp\u003e计算机的内存、PCIe 设备、CPU 等等组件需要的工作频率不一样（主要原因之一是其他组件跟不上 CPU 的频率），\n而且都\u003cstrong\u003e\u003cmark\u003e远大于几十 MHz\u003c/mark\u003e\u003c/strong\u003e，因此需要对频率做提升。工作原理：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"https://cs.stackexchange.com/questions/153752/what-is-a-cpu-clock-physically\"\u003eWhat is a CPU clock physically?\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Phase-locked_loop\"\u003eWikipedia: Phase-locked_loop (PLL)\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e有个视频解释地很形象，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/freq-scale-up.gif\" width=\"70%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Scaling up crystal frequency for different components of a computer.\nImage source \u003ca href=\"https://www.youtube.com/watch?v=B7djs4zSbuU\u0026amp;t=150s\"\u003eYoutube\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e图中的 clock generator 是个专用芯片，也是\u003cstrong\u003e\u003cmark\u003e焊在主板上\u003c/mark\u003e\u003c/strong\u003e，一般跟晶振挨着。\u003c/p\u003e\n\n\u003ch2 id=\"13-cpu-频率是如何从-20mhz-提升到-3ghz-的\"\u003e1.3 CPU 频率是如何从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~20MHz\u003c/code\u003e 提升到 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~3GHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的\u003c/h2\u003e\n\n\u003cp\u003e本节稍微再开展一下，看看 CPU 频率是如何提升到我们常见的 ~3GHz 这么高的。\u003c/p\u003e\n\n\u003ch3 id=\"131-传递路径最终连接到-cpu-clk-引脚\"\u003e1.3.1 传递路径：最终连接到 CPU \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCLK\u003c/code\u003e 引脚\u003c/h3\u003e\n\n\u003cp\u003e结合上面的图，时钟信号的\u003cstrong\u003e\u003cmark\u003e传递/提升路径\u003c/mark\u003e\u003c/strong\u003e：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e晶振（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e~20MHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e主板上的 clock generator 芯片\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n  \u003cli\u003e北桥芯片\u003c/li\u003e\n  \u003cli\u003eCPU\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e时钟信号连接到 CPU 的一个名为 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCLK\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的引脚。\n两个具体的 CLK 引脚实物图：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eIntel 486 处理器（\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e1989\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e）\u003c/p\u003e\n\n    \u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/intel-486-pin-map.png\" width=\"50%\"/\u003e\u003c/p\u003e\n    \u003cp align=\"center\"\u003eFig. Intel 486 pin map\u003ca href=\"http://ps-2.kev009.com/eprmhtml/eprmx/12203.htm\"\u003eImage Source\u003c/a\u003e\u003c/p\u003e\n\n    \u003cp\u003e这种 CPU 引脚今天看来还是很简单的，CLK 在第三行倒数第三列。\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eAMD SP3 CPU Socket (\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e2017\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e)\u003c/p\u003e\n\n    \u003cp\u003eEPYC 7001/7002/7003 系列用的这种。图太大了就不放了，见\n  \u003ca href=\"https://en.wikichip.org/wiki/amd/packages/socket_sp3#Pin_Map\"\u003eSP3 Pin Map\u003c/a\u003e。\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"132-cpu-内部还有一个-clock-generator\"\u003e1.3.2 CPU 内部：还有一个 clock generator\u003c/h3\u003e\n\n\u003cp\u003e现代 CPU 内部一般还有一个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eclock generator\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，可以继续提升频率，\n最终达到厂商宣传里的基频（base frequency）或标称频率（nominal frequency），例如 EPYC 6543 的 2795MHz。\n这跟原始晶振频率比，已经提升了上百倍。\u003c/p\u003e\n\n\u003ch1 id=\"2-x86-架构的寄存器\"\u003e2 x86 架构的寄存器\u003c/h1\u003e\n\n\u003cp\u003e介绍点必要的背景知识，有基础的可跳过。\u003c/p\u003e\n\n\u003ch2 id=\"21-通用目的寄存器\"\u003e2.1 通用目的寄存器\u003c/h2\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/x86-asm-guide/x86-registers.png\" width=\"50%\" height=\"50%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. 32-bit x86 general purpose registers [1]\u003c/p\u003e\n\n\u003cp\u003e计算机执行的所有代码，几乎都是经由通用寄存器完成的。\n进一步了解：\u003ca href=\"/blog/x86-asm-guide-zh/\"\u003e简明 x86 汇编指南（2017）\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"22-特殊目的寄存器\"\u003e2.2 特殊目的寄存器\u003c/h2\u003e\n\n\u003cp\u003e如名字所示，用于特殊目的，一般也需要配套的特殊指令读写。大致分为几类：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003econtrol registers\u003c/li\u003e\n  \u003cli\u003edebug registers\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003emode-specific registers (MSR)\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e接下来我们主要看下 MSR 类型。\u003c/p\u003e\n\n\u003ch3 id=\"221-model-specific-register-msr\"\u003e2.2.1 model-specific register (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR\u003c/code\u003e)\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Model-specific_register\"\u003eMSR\u003c/a\u003e 是 x86 架构中的一组\u003cstrong\u003e\u003cmark\u003e控制寄存器\u003c/mark\u003e\u003c/strong\u003e（control registers），\n设计用于 debugging/tracing/monitoring 等等目的，以下是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eAMD\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 的一些系统寄存器，\n其中就包括了 MSR 寄存器们，来自 \u003ca href=\"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf\"\u003eAMD64 Architecture Programmer’s Manual, Volume 3 (PDF)\u003c/a\u003e，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/amd-system-registers.png\" width=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. AMD system registers, which include some MSR registers\u003c/p\u003e\n\n\u003cp\u003e几个相关的指令：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eRDMSR/WRMSR\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 指令：读写 MSR registers；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCPUID\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 指令：检查 CPU 是否支持某些特性。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eRDMSR/WRMSR 指令使用方式：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e需要 priviledged 权限。\u003c/li\u003e\n    \u003cli\u003eLinux \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emsr\u003c/code\u003e 内核模块创建了一个伪文件 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e/dev/cpu/{id}/msr\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，用户可以读写这个文件。还有一个 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emsr-tools\u003c/code\u003e 工具包。\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"222-msr-之一tsc\"\u003e2.2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMSR\u003c/code\u003e 之一：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTSC\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e今天我们要讨论的是 MSR 中与时间有关的一个寄存器，叫 TSC (Time Stamp Counter)。\u003c/p\u003e\n\n\u003ch1 id=\"3-tsc时间戳计数器\"\u003e3 TSC（时间戳计数器）\u003c/h1\u003e\n\n\u003ch2 id=\"31-本质x86-处理器中的一个-特殊寄存器\"\u003e3.1 本质：X86 处理器中的一个 \u003cstrong\u003e\u003cmark\u003e特殊寄存器\u003c/mark\u003e\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eTime Stamp Counter\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e (TSC) 是 X86 处理器\n（Intel/AMD/…）中的一个 64-bit 特殊目的 \u003cstrong\u003e\u003cmark\u003e寄存器\u003c/mark\u003e\u003c/strong\u003e，属于 MRS 的一种。\n还是 AMD 编程手册中的图，可以看到 MSR 和 TSC 的关系：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/amd-system-registers.png\" width=\"60%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. AMD system registers, which include some MSR registers\u003c/p\u003e\n\n\u003cp\u003e注意：在多核情况下（如今几乎都是多核了），每个物理核（processor）都有一个 TSC register，\n或者说这是一个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eper-processor register\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"32-作用记录-cpu-启动以来累计的-cycles-数量\"\u003e3.2 作用：记录 cpu 启动以来累计的 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ecycles\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 数量\u003c/h2\u003e\n\n\u003cp\u003e前面已经介绍过，时钟信号经过层层提升之后，最终达到 CPU 期望的高运行频率，然后就会在这个频率上工作。\u003c/p\u003e\n\n\u003cp\u003e这里有个 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCPU cycles\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e（指令周期）的概念：\n频率没经过一个周期（1Hz），CPU cycles 就增加 1 —— TSC 记录的就是\u003cstrong\u003e\u003cmark\u003e从 CPU 启动（或重置）以来的累计 cycles\u003c/mark\u003e\u003c/strong\u003e。\n这也呼应了它的名字：\u003cstrong\u003e\u003cmark\u003e时间戳计数器\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"33-实际经常被当做高精度时钟用\"\u003e3.3 实际：经常被当做（高精度）时钟用\u003c/h2\u003e\n\n\u003cp\u003e根据以上原理，\u003cstrong\u003e\u003cmark\u003e如果\u003c/mark\u003e\u003c/strong\u003e CPU 频率恒定且不存在 CPU 重置的话，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eTSC 记录的就是\u003cstrong\u003e\u003cmark\u003e系统启动以来的 cycles 数量\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003ecycles 可以\u003cstrong\u003e\u003cmark\u003e精确换算成时间\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e这个时间的\u003cstrong\u003e\u003cmark\u003e精度还非常高！\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e使用开销还很低（这涉及到操作系统和内核实现了）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e所以无怪乎 TSC 被大量\u003cstrong\u003e\u003cmark\u003e用户空间程序\u003c/mark\u003e\u003c/strong\u003e当做\u003cstrong\u003e\u003cmark\u003e开销地高精度的时钟\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch3 id=\"331-使用代码\"\u003e3.3.1 使用代码\u003c/h3\u003e\n\n\u003cp\u003e本质上用户空间程序只需要一条指令（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRDTSC\u003c/code\u003e），就能读取这个值。非常简单的几行代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"nf\"\u003erdtsc\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003elo\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ehi\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__asm__\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;rdtsc\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=a\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elo\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=d\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ehi\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ehi\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003elo\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e就能拿到当前时刻的 cpu cycles。所以统计耗时就很直接：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erdtsc\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\n    \u003cspan class=\"c1\"\u003e// business logic here\u003c/span\u003e\n\n    \u003cspan class=\"n\"\u003eend\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erdtsc\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eelapsed_seconds\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"n\"\u003ecycles_per_sec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"331-潜在问题\"\u003e3.3.1 潜在问题\u003c/h3\u003e\n\n\u003cp\u003e以上的假设是 TSC 恒定，随着 wall time 均匀增加。\u003c/p\u003e\n\n\u003cp\u003e如果 CPU 频率恒定的话（也就是没有超频、节能之类的特殊配置），cycles 就是以恒定速率增加的，\n这时 TSC 确实能跟时钟保持同步，所以可以作为一种获取时间或计时的方式。\n但接下来会看到，cycles 恒定这个前提条件如今已经很难满足了，内核也不推荐用 tsc 作为时间度量。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e乱序执行会导致 RDTSC 的执行顺序与期望的顺序发生偏差，导致计时不准，两种解决方式：\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003e插入一个同步指令（a serializing instruction），例如 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCPUID\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，强制前面的指令必现执行完，才能才执行 RDTSC；\u003c/li\u003e\n    \u003cli\u003e使用一个变种指令 RDTSCP，但这个指令只是对指令流做了部分顺序化（partial serialization of the instruction stream），并不完全可靠。\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"34-挑战tsc-的准确性越来越难以保证\"\u003e3.4 挑战：TSC 的准确性越来越难以保证\u003c/h2\u003e\n\n\u003cp\u003e如果一台机器只有一个处理器，并且工作频率也一直是稳定的，那拿 TSC 作为计时方式倒也没什么问题。\n但随着下面这些技术的引入，TSC 作为时钟就不准了：\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e多核处理器：意味着每个核上都有一个 TSC，如何保持这些 TSC 寄存器值的严格同步；\u003c/li\u003e\n  \u003cli\u003e不同处理器的\u003ca href=\"https://lwn.net/Articles/388188/\"\u003e温度差异也会导致 TSC 偏差\u003c/a\u003e；\u003c/li\u003e\n  \u003cli\u003e超线程：一个处理器上两个硬件线程（Linux 中看就是两个 CPU）；\u003c/li\u003e\n  \u003cli\u003e超频、降频等等\u003cstrong\u003e\u003cmark\u003e功耗管理\u003c/mark\u003e\u003c/strong\u003e功能：导致时钟不再是稳定的；\u003c/li\u003e\n  \u003cli\u003eCPU 指令乱序执行功能：获取 TSC 的指令的执行顺序和预期的可能不一致，导致计时不准；\u003c/li\u003e\n  \u003cli\u003e休眠状态：恢复到运行状态时重置 TSC；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e还有其他一些方面的挑战，都会导致\u003cstrong\u003e\u003cmark\u003e无法保证一台机器多个 CPU 的 TSC 严格同步\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"35-改进引入-constantinvariant-tsc\"\u003e3.5 改进：引入 constant/invariant TSC\u003c/h2\u003e\n\n\u003cp\u003e解决方式之一，是一种称为\u003cstrong\u003e\u003cmark\u003e恒定速率\u003c/mark\u003e\u003c/strong\u003e（constant rate） TSC 的技术，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e在 Linux 中，可以通过 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecat /proc/cpuinfo | grep constant_tsc\u003c/code\u003e 来判断；\u003c/li\u003e\n  \u003cli\u003e有这个 flag 的 CPU，TSC 以 CPU 的标称频率（nominal frequency）累积；超频或功耗控制等等导致的实际 CPU 时钟频率变化，不会影响到 TSC。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e较新的 Intel、AMD 处理器都支持这个特性。\u003c/p\u003e\n\n\u003cp\u003e但是，constant_tsc 只是表明 \u003cstrong\u003e\u003cmark\u003eCPU 有提供恒定 TSC 的能力\u003c/mark\u003e\u003c/strong\u003e，\n并不表示实际工作 TSC 就是恒定的。后面会详细介绍。\u003c/p\u003e\n\n\u003ch2 id=\"35-小结计数器counter而非时钟clock\"\u003e3.5 小结：\u003cstrong\u003e\u003cmark\u003e计数器\u003c/mark\u003e\u003c/strong\u003e（counter），而非时钟（clock）\u003c/h2\u003e\n\n\u003cp\u003e从上面的内容已经可以看出，\nTSC 如其名字“时间戳计数器”所说，确实本质上只是一个\u003cstrong\u003e\u003cmark\u003e计数器\u003c/mark\u003e\u003c/strong\u003e，\n记录的是 CPU 启动以来的 \u003cstrong\u003e\u003cmark\u003ecpu cycles 次数\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e虽然在很多情况下把它当时钟用，结果也是正确的，但这个是没有保证的，因为影响它稳定性的因素太多了 —— 不稳拿它计时也就不准了。\u003c/p\u003e\n\n\u003cp\u003e另外，它是一个 x86 架构的特殊寄存器，换了其他 cpu 架构可能就不支持，所以依赖 TSC 的代码\u003cstrong\u003e\u003cmark\u003e可移植性\u003c/mark\u003e\u003c/strong\u003e会变差。\u003c/p\u003e\n\n\u003ch1 id=\"4-查看和监控-tsc-相关信息\"\u003e4 查看和监控 TSC 相关信息\u003c/h1\u003e\n\n\u003cp\u003e以上几节介绍的基本都是硬件问题，很好理解。接下来设计到软件部分就复杂了，一部分原因是命名导致的。\u003c/p\u003e\n\n\u003ch2 id=\"41-linux-系统时钟源clocksource配置\"\u003e4.1 Linux 系统时钟源（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclocksource\u003c/code\u003e）配置\u003c/h2\u003e\n\n\u003cp\u003e我们前面提到不要把 tsc 作为时钟来看待，它只是一个计数器。但另一方面，内核确实需要一个时钟，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e内核自己的定时器、调度、网络收发包等等需要时钟；\u003c/li\u003e\n  \u003cli\u003e用户程序也需要时间功能，例如 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003egettimeofday() / clock_gettime()\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在底层，内核肯定是要基于启动以来的计数器，这时 tsc 就成为它的备选之一（而且优先级很高）。\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /sys/devices/system/clocksource/clocksource0/available_clocksource\ntsc hpet acpi_pm\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /sys/devices/system/clocksource/clocksource0/current_clocksource\ntsc\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"411-tsc优先\"\u003e4.1.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etsc\u003c/code\u003e：优先\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e高精度\u003c/mark\u003e\u003c/strong\u003e：基于 cycles，所以精度是几个 GHz，对应 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ens\u003c/code\u003e 级别；\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e\u003cmark\u003e低开销\u003c/mark\u003e\u003c/strong\u003e：跟内核实现有关。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"412-hpet性能开销太大\"\u003e4.1.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehpet\u003c/code\u003e：性能开销太大\u003c/h3\u003e\n\n\u003cp\u003e原理暂不展开，只说结论：相比 tsc，hpet 在很多场景会明显导致系统\u003cstrong\u003e\u003cmark\u003e负载升高\u003c/mark\u003e\u003c/strong\u003e。所以能用 tsc 就不要用 hpet。\u003c/p\u003e\n\n\u003ch2 id=\"42-turbostat-查看实际-tsc-计数可能不准\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e 查看实际 TSC 计数（可能不准）\u003c/h2\u003e\n\n\u003cp\u003e前面提到用户空间程序写几行代码就能方便地获取 TSC 计数。所以对监控采集来说，还是很方便的。\n我们甚至不需要自己写代码获取 TSC，一些内核的内置工具已经实现了这个功能，简单地执行一条 shell 命令就行了。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e 是 Linux 内核自带的一个工具，可以查看包括 TSC 在内的很多信息。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eturbostat 源码在内核\u003cstrong\u003e\u003cmark\u003e源码\u003c/mark\u003e\u003c/strong\u003e树中：\u003ca href=\"https://github.com/torvalds/linux/blob/v5.15/tools/power/x86/turbostat/turbostat.c\"\u003etools/power/x86/turbostat/turbostat.c\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e不加任何参数时，turbostat 会 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e5s\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e 打印一次统计信息，内容非常丰富。\n我们这里用精简模式，只打印每个 CPU 在过去 1s 的 TSC 频率和所有 CPU 的平均 TSC：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# sample 1s and only one time, print only per-CPU \u0026amp; average TSCs\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eturbostat \u003cspan class=\"nt\"\u003e--quiet\u003c/span\u003e \u003cspan class=\"nt\"\u003e--show\u003c/span\u003e CPU,TSC_MHz \u003cspan class=\"nt\"\u003e--interval\u003c/span\u003e 1 \u003cspan class=\"nt\"\u003e--num_iterations\u003c/span\u003e 1\nCPU     TSC_MHz\n-       2441\n0       2445\n64      2445\n1       2445\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e但 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e 如果执行的时间非常短，比如 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1s\u003c/code\u003e，统计到数据就不太准，偏差比较大；\n持续运行一段时间后，得到的数据才比较准。\u003c/p\u003e\n\n\u003ch2 id=\"43-rdtscrdtscp-指令采集-tsc-计数\"\u003e4.3 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtsc/rdtscp\u003c/code\u003e 指令采集 TSC 计数\u003c/h2\u003e\n\n\u003ch3 id=\"431-c-代码\"\u003e4.3.1 C 代码\u003c/h3\u003e\n\n\u003cp\u003e完整代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\n\u003cspan class=\"c1\"\u003e// https://stackoverflow.com/questions/16862620/numa-get-current-node-core\u003c/span\u003e\n\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"nf\"\u003erdtscp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003echip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecore\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"n\"\u003e__asm__\u003c/span\u003e \u003cspan class=\"k\"\u003evolatile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;rdtscp\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=a\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=d\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;=c\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\n    \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003echip\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xFFF000\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026gt;\u003c/span\u003e\u003cspan class=\"mi\"\u003e12\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecore\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ec\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"mh\"\u003e0xFFF\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e(((\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"n\"\u003ed\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e32\u003c/span\u003e\u003cspan class=\"p\"\u003e);;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"nf\"\u003emain\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003esleep_us\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e100000\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003etsc_nominal_hz\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e2795000000\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003eexpected_inc\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003esleep_us\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"mi\"\u003e1000000\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003etsc_nominal_hz\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003elow\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003eexpected_inc\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e95\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003ehigh\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e\u003cspan class=\"p\"\u003e)(\u003c/span\u003e\u003cspan class=\"n\"\u003eexpected_inc\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mo\"\u003e05\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Sleep interval: %d us, expected tsc increase range [%lu,%lu]\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esleep_us\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003elow\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ehigh\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"kt\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"kt\"\u003elong\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edelta\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003estart_chip\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estart_core\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eend_chip\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eend_core\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ewhile\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"n\"\u003estart\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erdtscp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003estart_chip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003estart_core\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003eusleep\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esleep_us\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"n\"\u003edelta\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erdtscp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eend_chip\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eend_core\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003estart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edelta\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ehigh\u003c/span\u003e \u003cspan class=\"o\"\u003e||\u003c/span\u003e \u003cspan class=\"n\"\u003edelta\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003elow\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"kt\"\u003etime_t\u003c/span\u003e \u003cspan class=\"n\"\u003eseconds\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003etime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eNULL\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// seconds since Unix epoch (1970.1.1)\u003c/span\u003e\n            \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003etm\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003elocaltime\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003eseconds\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003eprintf\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;%02d-%02d %02d:%02d:%02d TSC jitter: %lu\u003c/span\u003e\u003cspan class=\"se\"\u003e\\n\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n                    \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etm_mon\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etm_mday\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etm_hour\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etm_min\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003etm_sec\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edelta\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"n\"\u003efflush\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estdout\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e几点说明：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e程序 hardcode 了预期的 TSC 频率是 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e2795MHz\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e；\u003c/li\u003e\n  \u003cli\u003e每 100ms 采集一次 TSC 计数，如果 TSC 计数的偏差超过 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e+/- 5%\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，就将这个异常值打印出来；\u003c/li\u003e\n  \u003cli\u003e在哪个 chip/cpu 上执行的，这里没打印出来，有需要可以打印；\u003c/li\u003e\n  \u003cli\u003e这个程序虽然采集很频繁，但开销很小，主要是因为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e 指令的开销很小。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch3 id=\"432-执行效果\"\u003e4.3.2 执行效果\u003c/h3\u003e\n\n\u003cp\u003e编译运行，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003egcc tsc-checker.c \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e tsc-checker\n\n\u003cspan class=\"c\"\u003e# print to stdout and copy to a log file, using stream buffer instead of line buffers\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003estdbuf\u003c/span\u003e \u003cspan class=\"nt\"\u003e--output\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eL ./tsc-checker | \u003cspan class=\"nb\"\u003etee \u003c/span\u003etsc.log\nSleep interval: 100000 us, expected tsc increase range \u003cspan class=\"o\"\u003e[\u003c/span\u003e265525000,293475000]\n08-05 19:46:31 303640792\n08-05 20:13:06 301869652\n08-05 20:38:27 300751948\n08-05 22:40:39 324424884\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到这台机器（\u003cstrong\u003e\u003cmark\u003e真实服务器\u003c/mark\u003e\u003c/strong\u003e）有偶发 TSC 抖动，\n能偏离正常范围 \u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e324424884/2795000000 - 1 = 16%\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e，\n也就是说 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e100ms\u003c/code\u003e 的时间它能偏离 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e16ms\u003c/code\u003e，非常离谱。TSC 短时间连续抖动时，\n机器就会出现各种奇怪现象，比如 load 升高、网络超时、活跃线程数增加等等，因为内核系统因为时钟抖动乱了。\u003c/p\u003e\n\n\u003ch2 id=\"44-监控\"\u003e4.4 监控\u003c/h2\u003e\n\n\u003cp\u003e用合适的采集工具把以上数据送到监控平台（例如 Prometheus/VictoriaMetrics），就能很直观地看到 TSC 的状态。\u003c/p\u003e\n\n\u003ch3 id=\"441-基于-turbostat不推荐\"\u003e4.4.1 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e（不推荐）\u003c/h3\u003e\n\n\u003cp\u003e例如下面是 1 分钟采集一次，每次采集过去 1s 内的平均 TSC，得到的结果：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/monitoring-node-tsc.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. TSC runnning average of an AMD EPYC 7543 node\u003c/p\u003e\n\n\u003cp\u003e但前面提到，\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eturbostat\u003c/code\u003e 如果执行的时间非常短，统计到数据就不太准，偏差比较大；\n持续运行一段时间后，得到的数据才比较准。但作为采集程序，可能不方便执行太长时间。\u003c/p\u003e\n\n\u003ch3 id=\"442-基于-rdtscp\"\u003e4.4.2 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e\u003c/h3\u003e\n\n\u003cp\u003e基于上面的 rdtscp 自己写代码采集，就非常准确了，例如，下面是 1 分钟采集一次得到的结果展示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/tsc-collect-with-rdtscp.jpg\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. TSC jitter of an AMD EPYC 7543 node\u003c/p\u003e\n\n\u003cp\u003e不过，要抓一些偶发抖动导致的问题，1 分钟采集一次粒度太粗了。比如我们上一小节的 C 程序是 100ms 采集一次，\n相当于 1 分钟采集 600 次，一小时采集 3.6w 次。我们 3 个小时总共 10 万多次跑下来，也才能抓到几次抖动，这已经算很幸运了。\u003c/p\u003e\n\n\u003ch3 id=\"443-基于-rdtscp--内核模块\"\u003e4.4.3 基于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e + 内核模块\u003c/h3\u003e\n\n\u003cp\u003e还是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdtscp\u003c/code\u003e，但作为内核模块 + 定时器运行，应该会比用户空间程序更准，可以避免 Linux 内核调度器的调度偏差。\u003c/p\u003e\n\n\u003ch1 id=\"5-tsc-若干坑\"\u003e5 TSC 若干坑\u003c/h1\u003e\n\n\u003ch2 id=\"51-constant_tsc-a-feature-not-a-runtime-guarantee\"\u003e5.1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econstant_tsc\u003c/code\u003e: a feature, not a runtime guarantee\u003c/h2\u003e\n\n\u003ch3 id=\"511-lenovo-sr645-amd-epyc-7543-cpu-tsc-不稳定\"\u003e5.1.1 Lenovo SR645 (AMD EPYC 7543 CPU) TSC 不稳定\u003c/h3\u003e\n\n\u003cp\u003eCPU 信息：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /proc/cpuinfo\n...\nprocessor       : 127\nvendor_id       : AuthenticAMD\nmodel name      : AMD EPYC 7543 32-Core Processor\ncpu MHz         : 3717.449\nflags           : fpu ... tsc msr rdtscp constant_tsc nonstop_tsc cpuid tsc_scale ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eflags 里面显式支持 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003econstant_tsc\u003c/code\u003e 和 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enonstop_tsc\u003c/code\u003e，所以按照文档的描述 TSC 应该是恒定的。\u003c/p\u003e\n\n\u003cp\u003e但是，看一下下面的监控，都是这款 CPU，机器来自两个不同的服务器厂商，\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/linux-clock-source/tsc-fluctuations.png\" width=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. TSC fluctuations (delta of running average) of AMD EPYC 7543 nodes, from two server vendors\u003c/p\u003e\n\n\u003cp\u003e可以看到，\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e联想和浪潮的 TSC 都有波动，\u003c/li\u003e\n  \u003cli\u003e联想的偶尔波动非常剧烈（相对 base 2795MHz 偏离 16% 甚至更高）；\u003c/li\u003e\n  \u003cli\u003e浪潮的相对较小（base 2445 MHz）。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这个波动可能有几方面原因，比如各厂商的 BIOS 逻辑，或者 SMI 中断风暴。\u003c/p\u003e\n\n\u003ch3 id=\"512-原因及解决方式\"\u003e5.1.2 原因及解决方式\u003c/h3\u003e\n\n\u003cp\u003e最后定位到是厂商 BIOS (UEFI) 设置导致的，做如下修改之后稳定多了，\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth style=\"text-align: left\"\u003eNo.\u003c/th\u003e\n      \u003cth style=\"text-align: left\"\u003eOption\u003c/th\u003e\n      \u003cth style=\"text-align: left\"\u003eBefore\u003c/th\u003e\n      \u003cth style=\"text-align: left\"\u003eAfter\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e1\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eOperatingModes.ChooseOperatingMode\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eMaximum Efficiency\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eCustom Mode\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e2\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.DeterminismSlider\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003ePerformance\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003ePower\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e3\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.CorePerformanceBoost\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e4\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.cTDP\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eAuto\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eMaximum\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e5\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.PackagePowerLimit\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eAuto\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eMaximum\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e6\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.GlobalC-stateControl\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e7\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.SOCP-states\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eAuto\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eP0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e8\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.DFC-States\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eDisable\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e9\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.P-state1\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eDisable\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e10\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.SMTMode\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e11\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.CPPC\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e12\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.BoostFmax\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eAuto\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eManual\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e13\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eProcessors.BoostFmaxManual\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e \u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003e0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e14\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003ePower EfficiencyMode\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eEnable\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eDisable\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003e15\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eMemory.NUMANodesperSocket\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003eNPS1\u003c/td\u003e\n      \u003ctd style=\"text-align: left\"\u003e\u003cstrong\u003e\u003cmark\u003e\u003ccode\u003eNPS0\u003c/code\u003e\u003c/mark\u003e\u003c/strong\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eNote:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eProcessors.BoostFmaxManual\u003c/code\u003e option only exists when \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBoostFmax=Manual\u003c/code\u003e;\u003c/li\u003e\n  \u003cli\u003eSee \u003ca href=\"https://lenovopress.lenovo.com/lp1977-tuning-uefi-settings-4th-gen-amd-epyc-processor-servers\"\u003eTuning UEFI Settings for Performance and Energy Efficiency on 4th Gen AMD EPYC Processor-Based ThinkSystem Servers\u003c/a\u003e\nfor more details of each option.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"52-bios-设置致使-tsc-不恒定\"\u003e5.2 BIOS 设置致使 TSC 不恒定\u003c/h2\u003e\n\n\u003cp\u003e除了以上具体配置，还有一些可能会导致 TSC 不稳的场景。\u003c/p\u003e\n\n\u003ch3 id=\"521-tsc-寄存器是可写的\"\u003e5.2.1 TSC 寄存器是\u003cstrong\u003e\u003cmark\u003e可写\u003c/mark\u003e\u003c/strong\u003e的！\u003c/h3\u003e\n\n\u003cp\u003eTSC 可写，所以某些 BIOS 固件代码会修改 TSC 值，导致操作系统时序不同步（或者说不符合预期）。\u003c/p\u003e\n\n\u003ch3 id=\"522-bios-smi-handler-通过修改-tsc-隐藏它们的执行\"\u003e5.2.2 BIOS SMI handler 通过修改 TSC 隐藏它们的执行\u003c/h3\u003e\n\n\u003cp\u003e例如，2010 年内核社区的一个讨论 \u003ca href=\"https://lwn.net/Articles/388286/\"\u003ex86: Export tsc related information in sysfs\u003c/a\u003e\n就提到，某些 BIOS SMI handler 会通过\u003cstrong\u003e\u003cmark\u003e修改 TSC value\u003c/mark\u003e\u003c/strong\u003e 的方式来\u003cstrong\u003e\u003cmark\u003e隐藏它们的执行\u003c/mark\u003e\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e为什么要隐藏？\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch3 id=\"523-服务器厂商出于功耗控制等原因在-bios-修改-tsc-同步逻辑\"\u003e5.2.3 服务器厂商出于功耗控制等原因在 BIOS 修改 TSC 同步逻辑\u003c/h3\u003e\n\n\u003cp\u003e前面提到，恒定 TSC 特性只是说处理器提供了恒定的能力，但用不用这个能力，服务器厂商有非常大的决定权。\u003c/p\u003e\n\n\u003cp\u003e某些厂商的固件代码会在 TSC sync 逻辑中中修改 TSC 的值。\n这种修改在固件这边没什么问题，但会破坏内核层面的时序视角，例如内核调度器工作会出问题。\n因此，内核最后引入了一个 \u003ca href=\"https://github.com/torvalds/linux/commit/cd7240c0b900eb6d690ccee088a6c9b46dae815a\"\u003epatch\u003c/a\u003e\n来处理 ACPI suspend/resume，以保证 TSC sync 机制在操作系统层面还是正常的，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ex86, tsc, sched: Recompute cyc2ns_offset\u0026#39;s during resume from sleep states\n\nTSC\u0026#39;s get reset after suspend/resume (even on cpu\u0026#39;s with invariant TSC\nwhich runs at a constant rate across ACPI P-, C- and T-states). And in\nsome systems BIOS seem to reinit TSC to arbitrary large value (still\nsync\u0026#39;d across cpu\u0026#39;s) during resume.\n\nThis leads to a scenario of scheduler rq-\u0026gt;clock (sched_clock_cpu()) less\nthan rq-\u0026gt;age_stamp (introduced in 2.6.32). This leads to a big value\nreturned by scale_rt_power() and the resulting big group power set by the\nupdate_group_power() is causing improper load balancing between busy and\nidle cpu\u0026#39;s after suspend/resume.\n\nThis resulted in multi-threaded workloads (like kernel-compilation) go\nslower after suspend/resume cycle on core i5 laptops.\n\nFix this by recomputing cyc2ns_offset\u0026#39;s during resume, so that\nsched_clock() continues from the point where it was left off during\nsuspend.\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"53-smi-中断风暴导致-tsc-不稳\"\u003e5.3 SMI 中断风暴导致 TSC 不稳\u003c/h2\u003e\n\n\u003cp\u003e上一节提到，BIOS SMI handler 通过修改 TSC 隐藏它们的执行。如果有大量这种中断（可能是有 bug），\n就会导致大量时间花在中断处理时，但又不会计入 TSC，最终导致系统出现卡顿等问题。\u003c/p\u003e\n\n\u003cp\u003eAMD 的机器比较尴尬，看不到 SMI 统计（试了几台 Intel 机器是能看到的），\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eturbostat \u003cspan class=\"nt\"\u003e--quiet\u003c/span\u003e \u003cspan class=\"nt\"\u003e--show\u003c/span\u003e CPU,TSC_MHz,SMI \u003cspan class=\"nt\"\u003e--interval\u003c/span\u003e 1 \u003cspan class=\"nt\"\u003e--num_iterations\u003c/span\u003e 1\nCPU     TSC_MHz\n-       2441\n0       2445\n64      2445\n1       2445\n...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"54-vm-tsc-不稳\"\u003e5.4 VM TSC 不稳\u003c/h2\u003e\n\n\u003cp\u003e例如\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003ehttps://www.phoronix.com/news/AMD-Secure-TSC-Linux-Patches\u003c/li\u003e\n  \u003cli\u003ehttp://oliveryang.net/2015/09/pitfalls-of-TSC-usage/\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"6-总结\"\u003e6 总结\u003c/h1\u003e\n\n\u003cp\u003e本文整理了一些 TSC 相关的软硬件知识，在一些故障排查场景可能会用到。\u003c/p\u003e\n\n\u003ch1 id=\"参考资料\"\u003e参考资料\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/x86-asm-guide-zh/\"\u003e简明 x86 汇编指南（2017）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf\"\u003eAMD64 Architecture Programmer’s Manual, Volume 3 (PDF)\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/linux-cpu-1-zh/\"\u003eLinux 服务器功耗与性能管理（一）：CPU 硬件基础（2024）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"http://oliveryang.net/2015/09/pitfalls-of-TSC-usage/\"\u003ePitfalls of TSC usage\u003c/a\u003e, 2015\u003c/li\u003e\n  \u003cli\u003eWikipedia \u003ca href=\"https://en.wikipedia.org/wiki/Model-specific_register\"\u003eMSR\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eWikipedia \u003ca href=\"https://en.wikipedia.org/wiki/Time_Stamp_Counter\"\u003eTSC\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003eWikipedia \u003ca href=\"https://en.wikipedia.org/wiki/Clock_generator\"\u003eClock Generator\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003chr/\u003e\n\n\u003cp\u003e\u003ca href=\"https://notbyai.fyi\"\u003e\u003cimg src=\"/assets/img/Written-By-Human-Not-By-AI-Badge-white.svg\" alt=\"Written by Human, Not by AI\"/\u003e\u003c/a\u003e\n\u003ca href=\"https://notbyai.fyi\"\u003e\u003cimg src=\"/assets/img/Written-By-Human-Not-By-AI-Badge-black.svg\" alt=\"Written by Human, Not by AI\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/k8s-juicefs-csi-workflow-zh/\"\u003e\u003cspan\u003e« 图解 JuiceFS CSI 工作流：K8s 创建带 PV 的 Pod 时，背后发生了什么（2024）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/rag-basis-bge-zh/\"\u003e\u003cspan\u003e大模型 RAG 基础：信息检索、文本向量化及 BGE-M3 embedding 实践（2024） »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2024-07-28T00:00:00Z",
  "Author": "Arthur Chiao"
}