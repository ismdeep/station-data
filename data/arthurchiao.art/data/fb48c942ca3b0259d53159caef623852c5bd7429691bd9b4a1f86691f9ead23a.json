{
  "Source": "arthurchiao.art",
  "Title": "Life of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑",
  "Link": "https://arthurchiao.art/blog/cilium-life-of-a-packet-pod-to-service-zh/",
  "Content": "\u003cdiv class=\"post\"\u003e\n  \n  \u003ch1 class=\"postTitle\"\u003eLife of a Packet in Cilium：实地探索 Pod-to-Service 转发路径及 BPF 处理逻辑\u003c/h1\u003e\n  \u003cp class=\"meta\"\u003ePublished at 2020-09-12 | Last Update 2020-09-12\u003c/p\u003e\n  \n  \u003cblockquote\u003e\n  \u003cp\u003eNote: this post also provides a\n\u003ca href=\"/blog/cilium-life-of-a-packet-pod-to-service/\"\u003eEnglish version\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cul id=\"markdown-toc\"\u003e\n  \u003cli\u003e\u003ca href=\"#引言\" id=\"markdown-toc-引言\"\u003e引言\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#面临的问题\" id=\"markdown-toc-面临的问题\"\u003e面临的问题\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#本文目的\" id=\"markdown-toc-本文目的\"\u003e本文目的\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#环境及配置信息\" id=\"markdown-toc-环境及配置信息\"\u003e环境及配置信息\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#其他说明\" id=\"markdown-toc-其他说明\"\u003e其他说明\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-1-pod1-eth0-发送\" id=\"markdown-toc-step-1-pod1-eth0-发送\"\u003eStep 1: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 发送\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#11-访问-serviceip\" id=\"markdown-toc-11-访问-serviceip\"\u003e1.1 访问 ServiceIP\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#12-确定目的-mac-地址\" id=\"markdown-toc-12-确定目的-mac-地址\"\u003e1.2 确定目的 MAC 地址\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#13-进一步探究\" id=\"markdown-toc-13-进一步探究\"\u003e1.3 进一步探究\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-2-pod1-eth0-对端设备lxcxxbpf-处理\" id=\"markdown-toc-step-2-pod1-eth0-对端设备lxcxxbpf-处理\"\u003eStep 2: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 对端设备（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxcxx\u003c/code\u003e）BPF 处理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#21-查看加载的-bpf-程序\" id=\"markdown-toc-21-查看加载的-bpf-程序\"\u003e2.1 查看加载的 BPF 程序\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#22-from-container-bpf-程序分析\" id=\"markdown-toc-22-from-container-bpf-程序分析\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF 程序分析\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-3-node1内核路由判断\" id=\"markdown-toc-step-3-node1内核路由判断\"\u003eStep 3: NODE1：内核路由判断\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-4-node1-bond物理网卡egress-bpf-处理\" id=\"markdown-toc-step-4-node1-bond物理网卡egress-bpf-处理\"\u003eStep 4: NODE1 bond/物理网卡：egress BPF 处理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#41-查看加载的-bpf-程序\" id=\"markdown-toc-41-查看加载的-bpf-程序\"\u003e4.1 查看加载的 BPF 程序\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#42-to-netdev-bpf-程序分析\" id=\"markdown-toc-42-to-netdev-bpf-程序分析\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-netdev\u003c/code\u003e BPF 程序分析\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#43-确定源和目的-mac-地址\" id=\"markdown-toc-43-确定源和目的-mac-地址\"\u003e4.3 确定源和目的 MAC 地址\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-5-数据中心网络路由转发\" id=\"markdown-toc-step-5-数据中心网络路由转发\"\u003eStep 5: 数据中心网络：路由转发\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-6-node2-物理网卡bondingress-bpf-处理\" id=\"markdown-toc-step-6-node2-物理网卡bondingress-bpf-处理\"\u003eStep 6: NODE2 物理网卡/bond：ingress BPF 处理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#61-查看加载的-bpf-程序\" id=\"markdown-toc-61-查看加载的-bpf-程序\"\u003e6.1 查看加载的 BPF 程序\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#62-from-netdev-bpf-程序分析\" id=\"markdown-toc-62-from-netdev-bpf-程序分析\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-netdev\u003c/code\u003e BPF 程序分析\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-7-pod2-eth0-对端设备lxcxx的-bpf-处理\" id=\"markdown-toc-step-7-pod2-eth0-对端设备lxcxx的-bpf-处理\"\u003eStep 7: Pod2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 对端设备（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxcxx\u003c/code\u003e）的 BPF 处理\u003c/a\u003e    \u003cul\u003e\n      \u003cli\u003e\u003ca href=\"#71-查看加载的-bpf-程序\" id=\"markdown-toc-71-查看加载的-bpf-程序\"\u003e7.1 查看加载的 BPF 程序\u003c/a\u003e\u003c/li\u003e\n      \u003cli\u003e\u003ca href=\"#72-to-container-bpf-程序分析\" id=\"markdown-toc-72-to-container-bpf-程序分析\"\u003e7.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF 程序分析\u003c/a\u003e\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#step-8-到达-pod4-容器\" id=\"markdown-toc-step-8-到达-pod4-容器\"\u003eStep 8: 到达 POD4 容器\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#总结\" id=\"markdown-toc-总结\"\u003e总结\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"#references\" id=\"markdown-toc-references\"\u003eReferences\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003chr/\u003e\n\n\u003ch1 id=\"引言\"\u003e引言\u003c/h1\u003e\n\n\u003ch2 id=\"面临的问题\"\u003e面临的问题\u003c/h2\u003e\n\n\u003cp\u003e传统的基于\u003cstrong\u003e二层转发\u003c/strong\u003e（Linux bridge、Netfilter/iptables、OVS 等）和/或\n\u003cstrong\u003e三层路由\u003c/strong\u003e的网络虚拟化方案中，\u003cstrong\u003e数据包的转发路径通常非常清晰\u003c/strong\u003e，通过一些常见工\n具或命令就能判断包的下一跳（可能是一个端口或网络设备），最终能画出一张类似下\n图的网络拓扑图 [1]：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/neutron-ovs-path.png\" width=\"80%\" height=\"80%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 1. Network topology inside an OpenStack compute node\u003c/p\u003e\n\n\u003cp\u003e当网络出现问题时，例如，一个容器访问另一个容器网络不通，只要\u003cstrong\u003e沿着这条路径上的设\n备依次抓包\u003c/strong\u003e，再配合路由表、ARP 表分析，\u003cstrong\u003e一般很快就能定位到问题出在那个环节\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e不幸的是，\u003cstrong\u003e在 Cilium/eBPF 方案中，网络拓扑已经没有这么直观了\u003c/strong\u003e，例如，下面是默认\n安装时 Cilium 节点的网络拓扑：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/network-topology.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 2. Network topology inside an Cilium-powered k8s node\u003c/p\u003e\n\n\u003cp\u003e可以看到，各个设备之间看上去都是“孤立的”，很多地方并没有\u003cstrong\u003e桥接设备\u003c/strong\u003e或常规的\u003cstrong\u003e路由/转\n发规则\u003c/strong\u003e将它们连起来。如果用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etcpdump\u003c/code\u003e 抓包，会看到包一会从一个地方消失了，一会\n又从另一个地方冒出来了，中间怎么过来的，一头雾水，只知道是 eBPF 干的。\u003c/p\u003e\n\n\u003cp\u003e这可能是\u003cstrong\u003e上手 Cilium 网络排障（trouble shooting）时最苦恼的事情之一\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"本文目的\"\u003e本文目的\u003c/h2\u003e\n\n\u003cp\u003e本文试图用常规 Linux 工具来\u003cstrong\u003e探索 Cilium 的整个转发路径，并分析在每个转发\n节点分别做了什么事情\u003c/strong\u003e，最终得到一张与图 1 一样直观的转发路径图，结果如图 3\n所示：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/pod-to-service-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig 3. Traffic path of Pod-to-ServiceIP\u003c/p\u003e\n\n\u003cp\u003e具体来说，我们从一个 Pod 访问 ServiceIP 开始，并假设这个 ServiceIP 对应\n的后端 Pod 位于另一台 node 上，然后探索包所经过的路径和处理过程。\u003c/p\u003e\n\n\u003cp\u003e[2,3,5] 都有较大的篇幅介绍 Cilium/eBPF 的转发路径，但并没有具体到 BPF 代码层面。\u003c/p\u003e\n\n\u003cp\u003e如前面所说，转发路径的许多地方是靠 BPF 代码“粘合”到一起的，因此完成本文的任务\n离不开\u003cstrong\u003e对相应 BPF 代码的分析\u003c/strong\u003e，这是本文最大的不同。\u003c/p\u003e\n\n\u003cp\u003e但要理解整个转发路径，还是\u003cstrong\u003e强烈建议\u003c/strong\u003e理论先行，在阅读本文之前先理解 [2,3]。\u003c/p\u003e\n\n\u003ch2 id=\"环境及配置信息\"\u003e环境及配置信息\u003c/h2\u003e\n\n\u003cp\u003eCilium 的 eBPF 转发路径随\u003cstrong\u003e跨主机网络方案\u003c/strong\u003e和\u003cstrong\u003e内核版本\u003c/strong\u003e而有差异，本文假设：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e跨主机网络方案：直接路由（BGP [4]）\u003c/li\u003e\n  \u003cli\u003eLinux kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4.19\u003c/code\u003e：Cilium/eBPF 的较完整功能依赖这个版本及以上的内核\u003c/li\u003e\n  \u003cli\u003eCilium \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.8.2\u003c/code\u003e，配置：\n    \u003cul\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekube-proxy-replacement=probe\u003c/code\u003e（默认）\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eenable-ipv4=true\u003c/code\u003e（默认）\u003c/li\u003e\n      \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edatapath-mode=veth\u003c/code\u003e（默认）\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003e没有对通信双方应用任何 network policy（默认）\u003c/li\u003e\n  \u003cli\u003e两个物理网卡做 bond，宿主机 IP 配置在 bond 上\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e满足以上 2 \u0026amp; 3 条件下，所有对包的拦截和修改操作都由 BPF 代码完成，不依赖\nNetfilter/iptables，即所谓的 kube-proxy free 模式。\u003c/p\u003e\n\n\u003ch2 id=\"其他说明\"\u003e其他说明\u003c/h2\u003e\n\n\u003cp\u003e为方便起见，本文会在宿主机上用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensenter-ctn\u003c/code\u003e \u003cstrong\u003e进入到容器执行命令\u003c/strong\u003e，它\n其实是对 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ensenter\u003c/code\u003e 命令的一个简单封装：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat\u003c/span\u003e ~/.bashrc\n...\n\u003cspan class=\"k\"\u003efunction \u003c/span\u003ensenter-ctn \u003cspan class=\"o\"\u003e()\u003c/span\u003e \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003eCTN\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003e$1\u003c/span\u003e  \u003cspan class=\"c\"\u003e# container ID or name\u003c/span\u003e\n    \u003cspan class=\"nv\"\u003ePID\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"si\"\u003e$(\u003c/span\u003e\u003cspan class=\"nb\"\u003esudo \u003c/span\u003edocker inspect \u003cspan class=\"nt\"\u003e--format\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#34;{{.State.Pid}}\u0026#34;\u003c/span\u003e \u003cspan class=\"nv\"\u003e$CTN\u003c/span\u003e\u003cspan class=\"si\"\u003e)\u003c/span\u003e\n    \u003cspan class=\"nb\"\u003eshift \u003c/span\u003e1 \u003cspan class=\"c\"\u003e# remove the first argument, shift others to the left\u003c/span\u003e\n    nsenter \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e \u003cspan class=\"nv\"\u003e$PID\u003c/span\u003e \u003cspan class=\"nv\"\u003e$@\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这和登录到容器里执行相应的命令效果是一样的，更多信息参考 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eman nseneter\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"step-1-pod1-eth0-发送\"\u003eStep 1: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 发送\u003c/h1\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e下面几个网络设备在我们的场景中用不到，因此后面的拓扑图中不再画它们：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_net/cilium_host\u003c/code\u003e 这对 veth pair 在 Kernel \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e4.19\u003c/code\u003e + Cilium \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.8\u003c/code\u003e\n部署中已经没什么作用了（事实上社区在考虑去掉它们）。\u003c/li\u003e\n    \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_vxlan\u003c/code\u003e 这个设备是 VxLAN 封装/接封装用的，在直接路由模式中不会出现。\u003c/li\u003e\n  \u003c/ol\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e拓扑简化为下图：\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-1.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 1.\u003c/p\u003e\n\n\u003ch2 id=\"11-访问-serviceip\"\u003e1.1 访问 ServiceIP\u003c/h2\u003e\n\n\u003cp\u003e从 POD1 访问 ServiceIP 开始，例如：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"c\"\u003e# * -n: execute command in pod\u0026#39;s network namespace\u003c/span\u003e\n\u003cspan class=\"c\"\u003e# * 10.224.1.1: ServiceIP\u003c/span\u003e\n\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn POD1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e curl 10.224.1.1:80\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e包会从容器的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 虚拟网卡发出去，此时能确定的 IP 和 MAC 地址信息有，\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_ip=POD1_IP\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac=POD1_MAC\u003c/code\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip=ServiceIP\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e这都很好理解，\u003cstrong\u003e那 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e 是多少呢\u003c/strong\u003e？\u003c/p\u003e\n\n\u003ch2 id=\"12-确定目的-mac-地址\"\u003e1.2 确定目的 MAC 地址\u003c/h2\u003e\n\n\u003cp\u003e确定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e 需要查看容器内的\u003cstrong\u003e路由表和 ARP 表\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e先看路由表：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn POD1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e route \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.1.1.1        0.0.0.0         UG    0      0        0 eth0\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 eth0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这台 node 管理的 PodCIDR 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.0/24\u003c/code\u003e。而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e 是这个 PodCIDR 的网关，\n配置在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_host\u003c/code\u003e 上（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eifconfig cilium_host\u003c/code\u003e 能看到）。这些都是 Cilium\nagent 启动时自己配置的。\u003c/p\u003e\n\n\u003cp\u003e由以上路由规则可知：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e到网关 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e 的包，命中第二条路由\u003c/li\u003e\n  \u003cli\u003e所有其他包，命中第一条路由（默认路由）\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e由于 ServiceIP 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.224.1.1\u003c/code\u003e，因此走默认路由，\u003cstrong\u003e下一跳就是网关 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e\u003c/strong\u003e。\n所以，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e 就要填 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.1.1.1\u003c/code\u003e 对应的 MAC。\u003cstrong\u003eMAC 和 IP 的对应关系在 ARP 表里\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e查看容器 ARP 表\u003c/strong\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e(NODE1) $ nsenter-ctn POD1 -n arp -n\nAddress               HWtype  HWaddress           Flags Mask            Iface\n10.1.1.1              ether   3e:74:f2:60:ab:9b   C                     eth0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e对应的 MAC 地址是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e3e:74:f2:60:ab:9b\u003c/code\u003e。至此，确定了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e，包就可以可以正常发送出去了。\u003c/p\u003e\n\n\u003ch2 id=\"13-进一步探究\"\u003e1.3 进一步探究\u003c/h2\u003e\n\n\u003cp\u003e但是，如果去 NODE1 上查看，会发现这个 MAC 其实并不是网关 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecilium_host/cilium_net\u003c/code\u003e，\n宿主机上执行：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eifconfig cilium_host\ncilium_host: \u003cspan class=\"nv\"\u003eflags\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4291\u0026lt;UP,BROADCAST,RUNNING,NOARP,MULTICAST\u0026gt;  mtu 1500\n        inet 10.1.1.1  netmask 255.255.255.255  broadcast 0.0.0.0\n        ether 3e:7d:6b:32:44:8e  txqueuelen 1000  \u003cspan class=\"o\"\u003e(\u003c/span\u003eEthernet\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n        ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以及，\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eip \u003cspan class=\"nb\"\u003elink\u003c/span\u003e | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003e3e:74:f2:60:ab:9b \u003cspan class=\"nt\"\u003e-B\u003c/span\u003e 1\n699: lxc00aa@if698: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 3e:74:f2:60:ab:9b brd ff:ff:ff:ff:ff:ff link-netnsid 4\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，这个 MAC 属于 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e 设备，并且从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e@\u003c/code\u003e 符号判断，它属于某个\nveth pair 的一端，另一端的 interface index 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e698\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e容器内执行 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link\u003c/code\u003e：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003ensenter-ctn POD1 \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e ip \u003cspan class=\"nb\"\u003elink\n\u003c/span\u003e698: eth0@if699: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc noqueue\n    \u003cspan class=\"nb\"\u003elink\u003c/span\u003e/ether 5e:d9:e5:0d:a1:ed brd ff:ff:ff:ff:ff:ff link-netnsid 0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，容器的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e index 就是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e698\u003c/code\u003e，对端是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e699\u003c/code\u003e。\u003c/p\u003e\n\n\u003cp\u003e至此明白了：\u003cstrong\u003eCilium 通过 hardcode ARP 表，强制将 Pod 流量的下一跳劫持到 veth\npair 的主机端\u003c/strong\u003e。这里不过多讨论设计，只说一点：这并不是 Cilium 独有的设计，其他\n方案也有这么做的。\u003c/p\u003e\n\n\u003ch1 id=\"step-2-pod1-eth0-对端设备lxcxxbpf-处理\"\u003eStep 2: POD1 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 对端设备（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxcxx\u003c/code\u003e）BPF 处理\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-2.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 2.\u003c/p\u003e\n\n\u003ch2 id=\"21-查看加载的-bpf-程序\"\u003e2.1 查看加载的 BPF 程序\u003c/h2\u003e\n\n\u003cp\u003e包从容器 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 发出，然后被 lxc 收进来，因此在 lxc 的 \u003cstrong\u003etc ingress hook\u003c/strong\u003e（注意\n是 ingress hook 而不是 egress hook）能对\u003cstrong\u003e容器发出的包\u003c/strong\u003e进行拦截和处理：\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cul\u003e\n    \u003cli\u003ePOD1’s egress corresponds to lxc’s ingress.\u003c/li\u003e\n    \u003cli\u003ePOD1’s ingress corresponds to lxc’s egress.\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev lxc00aa ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_lxc.o:[from-container] direct-action not_in_hw tag 3855f578c6616972\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，在 \u003cstrong\u003etc ingress hook 点的确加载了 BPF\u003c/strong\u003e，section 是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e。\n这里的 \u003cstrong\u003esection 标签 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e 是这段程序的唯一标识，在 Cilium 源代码\n里搜索这个标签就能找到相应的 BPF 源码\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e在 veth pair 模式中，你可以用上面的 tc 命令分别在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 的 ingress/egress 以\n及 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00aa\u003c/code\u003e 的 egress 点查看，最后会发现这些地方都没有加载 BPF。\u003c/p\u003e\n\n  \u003cp\u003e那就有一个疑问，没有\u003cstrong\u003e相应的 BPF，怎么对容器的入向包做拦截和处理呢\u003c/strong\u003e？后面会揭晓。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e接下来看这段 BPF 具体做了哪些事情。\u003c/p\u003e\n\n\u003ch2 id=\"22-from-container-bpf-程序分析\"\u003e2.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF 程序分析\u003c/h2\u003e\n\n\u003cp\u003eBPF 代码都在 Cilium 源代码的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebpf/\u003c/code\u003e 目录中。为避免本文过长，将只贴出核心调用栈。\u003c/p\u003e\n\n\u003cp\u003e大致调用栈如下：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;from-container\u0026#34;)\nhandle_xgress                                                                   // bpf/bpf_lxc.c\n  |-validate_ethertype(skb, \u0026amp;proto)\n  |-switch (proto) {\n      case ETH_P_IP:\n          tail_handle_ipv4                                                     // bpf/bpf_lxc.c\n            |-handle_ipv4_from_lxc                                             // bpf/bpf_lxc.c\n                |-if dst is k8s Service\n                |    lb4_local()\n                |      |-ct_create4\n                |      |-lb4_lookup_backend\n                |      |-lb4_xlate\n                |\n                |-policy_can_egress4()\n                |\n                |-if tunnel\n                |     encap vxlan\n                | else // direct routing, pass to kernel stack (continue normal routing)\n                |     ipv4_l3()                       // dec TTL, set src/dst MAC\n                |     asm_set_seclabel_identity(skb); // set identity to skb\n                |-return TC_ACT_OK;\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e所做的事情：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e对包进行验证，并提\u003cstrong\u003e取出 L3 proto\u003c/strong\u003e（协议类型）。\u003c/li\u003e\n  \u003cli\u003e如果 L3 proto 是 IPv4，调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e 进行处理。\u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e 进一步调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4_from_lxc()\u003c/code\u003e，后者完成：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003eService 负载均衡\u003c/strong\u003e，即从 Service 的后端 Pod 中选择一个合适的，这里假设选择 NODE2 上的 POD4。\u003c/li\u003e\n      \u003cli\u003e创建或更新\u003cstrong\u003e连接跟踪\u003c/strong\u003e（CT）记录。\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e执行 DNAT\u003c/strong\u003e，将包的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e 由 ServiceIP 改成 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e。\u003c/li\u003e\n      \u003cli\u003e进行容器出向（egress）\u003cstrong\u003e安全策略验证\u003c/strong\u003e，这里假设没有安全策略，因此能通过验证。\u003c/li\u003e\n      \u003cli\u003e\u003cstrong\u003e对包进行封装，或者通过主机进行路由\u003c/strong\u003e，本文只看直接路由的情况。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e在送回协议栈之前，调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_l3()\u003c/code\u003e 设置 TTL、MAC 地址等：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\n\u003cspan class=\"nf\"\u003eipv4_l3\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003e__ctx_buff\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003e__u8\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003edmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eiphdr\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eipv4_dec_ttl\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003el3_off\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eip4\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n       \u003cspan class=\"n\"\u003eeth_store_saddr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003esmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003eeth_store_daddr\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003edmac\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eCTX_ACT_OK\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e以上假设都成立的情况下，BPF 程序最后\u003cstrong\u003e返回 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACK_OK\u003c/code\u003e\u003c/strong\u003e，这个包就\u003cstrong\u003e进入内核协议\n栈继续处理了\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"step-3-node1内核路由判断\"\u003eStep 3: NODE1：内核路由判断\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-3.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 3.\u003c/p\u003e\n\n\u003cp\u003e经过 Step 2 的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-container\u003c/code\u003e BPF 程序处理之后，\u003cstrong\u003e包的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e 已经是真实 Pod\nIP（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e）了\u003c/strong\u003e。\u003c/p\u003e\n\n\u003cp\u003e接下来就进入内核协议栈进行路由（kernel routing）。此时内核就\u003cstrong\u003e相当于一台路由\n器（router），查询内核路由表\u003c/strong\u003e，根据包的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e 进行路由判断，确定下一跳。\u003c/p\u003e\n\n\u003cp\u003e来看内核路由表：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003eroute \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0\n10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e根据以上路由规则，只要目的 IP 不是本机 PodCIDR 网段的，都会命中默认路由（第一条）\n，走 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e 设备。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e内核路由子系统（三层路由）、邻居子系统（二层转发），推荐阅读大部头\n\u003cstrong\u003e《深入理解 Linux 网络技术内幕》\u003c/strong\u003e（中国电力出版社）。书中所用的内核版本可能\n有些老，但基本的路由、转发功能还是一样的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e因此包接下来会到达 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e 设备。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e本文的 node 都是两个物理网卡做了 bond，如果没有 bond，例如只有一个 eth0 物理网\n卡，宿主机 IP 配置在 eth0，那接下来包到达的就是 eth0 物理网卡。这种主机上配置\n了 IP 地址的设备，在 Cilium 里叫 native device。文档或代码中经常会看到。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-4-node1-bond物理网卡egress-bpf-处理\"\u003eStep 4: NODE1 bond/物理网卡：egress BPF 处理\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-4.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 4.\u003c/p\u003e\n\n\u003ch2 id=\"41-查看加载的-bpf-程序\"\u003e4.1 查看加载的 BPF 程序\u003c/h2\u003e\n\n\u003cp\u003e查看 bond 设备上的出向（egress）BPF，这是包出宿主机之前最后的 tc BPF hook 点：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE1\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev bond0 egress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_netdev_bond0.o:[to-netdev] direct-action not_in_hw tag b536a7e2744a4cdb\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e接下来看代码实现。\u003c/p\u003e\n\n\u003ch2 id=\"42-to-netdev-bpf-程序分析\"\u003e4.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-netdev\u003c/code\u003e BPF 程序分析\u003c/h2\u003e\n\n\u003cp\u003e调用栈如下，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;to-netdev\u0026#34;)\nto_netdev\n  |-policy_clear_mark\n  |-src_id = resolve_srcid_ipv4\n  |   |-lookup_ip4_remote_endpoint\n  |       |-ipcache_lookup4\n  |-ipv4_host_policy_egress(src_id)\n      |-policy_can_egress4\n      |-ret = ct_lookup4()\n      |-switch (ret) {\n          case CT_NEW        : ct_create4(); break;\n          case CT_ESTABLISHED:\n          case CT_RELATED    :\n          case CT_REPLY      :               break;\n          default            : ret = DROP;   break;\n        }\n        return ret;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e粗略地说，对于我们这个 case，这段 BPF 其实并不会做什么实际的事情，程序最后返回\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTC_ACK_OK\u003c/code\u003e 放行。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e\u003cstrong\u003eNative device 上的 BPF 主要处理南北向流量\u003c/strong\u003e，即，容器和集群外交互的流量 [3]。这包括，\u003c/p\u003e\n\n  \u003cul\u003e\n    \u003cli\u003eLoadBalancer Service 流量\u003c/li\u003e\n    \u003cli\u003e带 externalIPs 的 Service 流量\u003c/li\u003e\n    \u003cli\u003eNodePort Service 流量\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e接下来\u003cstrong\u003e根据内核路由表和 ARP 表封装 L2 头\u003c/strong\u003e。\u003c/p\u003e\n\n\u003ch2 id=\"43-确定源和目的-mac-地址\"\u003e4.3 确定源和目的 MAC 地址\u003c/h2\u003e\n\n\u003cp\u003e与 1.2 节原理一样，就不具体分析了，直接看结果：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e$ route -n\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.255.255.1    0.0.0.0         UG    0      0        0 bond0\n10.1.1.0        10.1.1.1        255.255.255.0   UG    0      0        0 cilium_host\n10.1.1.1        0.0.0.0         255.255.255.255 UH    0      0        0 cilium_host\n\n$ arp -n\nAddress                  HWtype  HWaddress           Flags Mask            Iface\n10.255.255.1             ether   00:00:5e:00:01:0c   C                     bond0\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e命中宿主机默认路由，因此会\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003cstrong\u003e将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e 的 MAC 作为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e\u003c/strong\u003e：MAC 地址只在二层网络内有效，宿主机和\nPod 属于不同二层网络（Cilium 自己管理了一个 CIDR），宿主机做转发时会将 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc_mac\u003c/code\u003e 换成自己的 MAC。\u003c/li\u003e\n  \u003cli\u003e\u003cstrong\u003e将宿主机网关对应的 MAC 作为 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_mac\u003c/code\u003e\u003c/strong\u003e：下一跳是宿主机网关。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e然后包就经过 bond0 和物理网卡发送到数据中心网络了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e可以在 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e 及物理网卡上抓包验证，指定 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-e\u003c/code\u003e 打印 MAC 地址。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-5-数据中心网络路由转发\"\u003eStep 5: 数据中心网络：路由转发\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-4.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 5.\u003c/p\u003e\n\n\u003cp\u003e数据中心网络根据 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e 对包进行路由。\u003c/p\u003e\n\n\u003cp\u003e由于 NODE2 之前已经通过 BGP 宣告自己管理了 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePodCIDR2\u003c/code\u003e 网段，而 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePOD4_IP\u003c/code\u003e 属于\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePodCIDR2\u003c/code\u003e，因此交换机（路由器）会将包转发给 NODE2。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e网络虚拟化：跨主机网络方案。\u003c/p\u003e\n\n  \u003cp\u003e从网络层次来说，有两种典型的跨主机网络方式：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e二层、大二层组网：每个 node 内部运行一个\u003cstrong\u003e软件交换机或软件网桥\u003c/strong\u003e，代表：OpenStack Neutron+OVS 方式 [1]。\u003c/li\u003e\n    \u003cli\u003e三层组网：每个 node 内部运行一个\u003cstrong\u003e软件路由器\u003c/strong\u003e（其实就是内核本身，它自带路由功能），每个 node 都是一个三层节点，代表：Cilium+BGP 方式 [4]。\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e排障时的一个区别：\u003c/p\u003e\n\n  \u003col\u003e\n    \u003cli\u003e在二层/大二层网络中，对于同一个包，\u003cstrong\u003e发送方和接收方看到的 src_mac 是一样的\u003c/strong\u003e，因为二\n层转发只修改 dst_mac，不会修改 src_mac。\u003c/li\u003e\n    \u003cli\u003e三层组网中，src_mac 和 dst_mac 都会变。\u003c/li\u003e\n  \u003c/ol\u003e\n\n  \u003cp\u003e抓包时要理解这一点。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch1 id=\"step-6-node2-物理网卡bondingress-bpf-处理\"\u003eStep 6: NODE2 物理网卡/bond：ingress BPF 处理\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-6.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 6.\u003c/p\u003e\n\n\u003cp\u003e以 Intel 10G 网卡为例，从驱动开始，接收方向调用栈，\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e// kernel source tree, 4.19\n\nixgbe_poll\n |-ixgbe_clean_rx_irq\n    |-if support XDP offload\n    |    skb = ixgbe_run_xdp()\n    |-skb = ixgbe_construct_skb()\n    |-ixgbe_rx_skb\n       |-napi_gro_receive\n          |-napi_skb_finish(dev_gro_receive(skb))\n             |-netif_receive_skb_internal\n                |-if generic XDP\n                |  |-if do_xdp_generic() != XDP_PASS\n                |       return NET_RX_DROP\n                |-__netif_receive_skb(skb)\n                   |-__netif_receive_skb_one_core\n                      |-__netif_receive_skb_core(\u0026amp;pt_prev)\n                         |-for tap in taps:\n                         |   deliver_skb\n                         |-sch_handle_ingress                     // net/core/dev.c\n                            |-tcf_classify                        // net/sched/cls_api.c\n                               |-for tp in tps:\n                                   tp-\u0026gt;classify\n                                       |-cls_bpf_classify         // net/sched/cls_bpf.c\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e大致过程：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e网卡收包\u003c/li\u003e\n  \u003cli\u003e如果网卡支持 XDP offload，并且有 XDP 程序，就会执行 XDP 程序。我们这里没有启\n用 XDP。\u003c/li\u003e\n  \u003cli\u003e创建 skb。\u003c/li\u003e\n  \u003cli\u003eGRO，对分片的包进行重组。\u003c/li\u003e\n  \u003cli\u003eGeneric XDP 处理：如果网卡不支持 XDP offload，那 XDP 程序会从 step 2 延后到这里执行。\u003c/li\u003e\n  \u003cli\u003eTap 处理（此处没有）。\u003c/li\u003e\n  \u003cli\u003eTC ingress 处理，支持包括 BPF 在内的 TC 程序。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e其中的 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esch_handle_ingress()\u003c/code\u003e 会进入 TC ingress hook 执行处理。\u003c/p\u003e\n\n\u003ch2 id=\"61-查看加载的-bpf-程序\"\u003e6.1 查看加载的 BPF 程序\u003c/h2\u003e\n\n\u003cp\u003e查看 ingress 方向加载的 BPF：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev bond0 ingress\nfilter protocol all pref 1 bpf\nfilter protocol all pref 1 bpf handle 0x1 bpf_netdev_bond0.o:[from-netdev] direct-action not_in_hw tag 75f509de02b2dfaf\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这段 BPF 程序会对\u003cstrong\u003e从物理网卡进入 bond0 的包\u003c/strong\u003e进行处理。\u003c/p\u003e\n\n\u003ch2 id=\"62-from-netdev-bpf-程序分析\"\u003e6.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efrom-netdev\u003c/code\u003e BPF 程序分析\u003c/h2\u003e\n\n\u003cp\u003e调用栈：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;from-netdev\u0026#34;)\nfrom_netdev\n  |-handle_netdev\n      |-validate_ethertype\n      |-do_netdev\n          |-identity = resolve_srcid_ipv4()                // 从 ctx 中提取 src identity\n          |-ctx_store_meta(CB_SRC_IDENTITY, identity)      // 将 identity 存储到 ctx-\u0026gt;cb[CB_SRC_IDENTITY]\n          |-ep_tail_call(ctx, CILIUM_CALL_IPV4_FROM_LXC)   // 尾调用到 endpoint BPF\n                               |\n |------------------------------\n |\n__section_tail(CILIUM_MAP_CALLS, CILIUM_CALL_IPV4_FROM_LXC)\ntail_handle_ipv4_from_netdev\n  |-tail_handle_ipv4\n      |-handle_ipv4\n          |-ep = lookup_ip4_endpoint()\n          |-ipv4_local_delivery(ctx, ep)\n              |-tail_call_dynamic(ctx, \u0026amp;POLICY_CALL_MAP, ep-\u0026gt;lxc_id);\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e主要逻辑：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\n    \u003cp\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_netdev()\u003c/code\u003e 处理\u003cstrong\u003e将从宿主机进入 Cilium 管理的网络\u003c/strong\u003e的流量，具体事情：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003e解析这个包所属的 identity\u003c/strong\u003e（Cilium 依赖 identity 做安全策略），并存储到包的结构体中。\n        \u003cul\u003e\n          \u003cli\u003e对于 direct routing 模式，从 ipcache 中根据 IP 查询 identity。\u003c/li\u003e\n          \u003cli\u003e对于 tunnel 模式，直接从 VxLAN 头中携带过来了。\u003c/li\u003e\n        \u003c/ul\u003e\n      \u003c/li\u003e\n      \u003cli\u003e尾调用到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4_from_netdev()\u003c/code\u003e。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4_from_netdev()\u003c/code\u003e 进一步调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_handle_ipv4()\u003c/code\u003e，后者再调用\n\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4()\u003c/code\u003e。\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehandle_ipv4()\u003c/code\u003e 做的事情：\u003c/p\u003e\n\n    \u003col\u003e\n      \u003cli\u003e\u003cstrong\u003e查找 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edst_ip\u003c/code\u003e 对应的 endpoint\u003c/strong\u003e（即 POD4）。\u003c/li\u003e\n      \u003cli\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_local_delivery()\u003c/code\u003e 执行处理，这个函数会\u003cstrong\u003e根据 endpoint id 直接尾调用到 endpoint (POD4) 的 BPF 程序\u003c/strong\u003e。\u003c/li\u003e\n    \u003c/ol\u003e\n  \u003c/li\u003e\n\u003c/ol\u003e\n\n\u003ch1 id=\"step-7-pod2-eth0-对端设备lxcxx的-bpf-处理\"\u003eStep 7: Pod2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e 对端设备（\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxcxx\u003c/code\u003e）的 BPF 处理\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/step-7.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 7.\u003c/p\u003e\n\n\u003ch2 id=\"71-查看加载的-bpf-程序\"\u003e7.1 查看加载的 BPF 程序\u003c/h2\u003e\n\n\u003cp\u003e跟前面一样，来查看 lxc 设备加载的 BPF 程序：\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"o\"\u003e(\u003c/span\u003eNODE2\u003cspan class=\"o\"\u003e)\u003c/span\u003e \u003cspan class=\"nv\"\u003e$ \u003c/span\u003etc filter show dev lxc00dd egress\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e没有加载任何 BPF 程序，为什么\u003c/strong\u003e？\u003c/p\u003e\n\n\u003cp\u003e因为设计中，这段代码并不是在包经过 egress 点触发执行的（常规 BPF 程序执行方式）\n，而是\u003cstrong\u003e直接从 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebond0\u003c/code\u003e 的 BPF 程序尾调用过来继续的\u003c/strong\u003e，即上一节最后的一行代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-c highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"n\"\u003etail_call_dynamic\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ectx\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003ePOLICY_CALL_MAP\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eep\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003elxc_id\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e因此不需要通过 tc 加载到 lxc 设备，这也回答了 2.1 节中提出的问题。这使得从 bond0\n（或物理网卡）到容器的路径大大缩短，可以显著提升性能。\u003c/p\u003e\n\n\u003ch2 id=\"72-to-container-bpf-程序分析\"\u003e7.2 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF 程序分析\u003c/h2\u003e\n\n\u003cp\u003e这次尾调用到达的是 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eto-container\u003c/code\u003e BPF 程序。调用栈：\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e__section(\u0026#34;to-container\u0026#34;)\nhandle_to_container                                            //    bpf/bpf_lxc.c\n  |-inherit_identity_from_host(skb, \u0026amp;identity)                 // -\u0026gt; bpf/lib/identity.h\n  |-tail_ipv4_to_endpoint                                      //    bpf/bpf_lxc.c\n      |-ipv4_policy                                            //    bpf/bpf_lxc.c\n          |-policy_can_access_ingress                          //    bpf/lib/policy.h\n              |-__policy_can_access                            //    bpf/lib/policy.h\n                  |-if p = map_lookup_elem(l3l4_key); p     // L3+L4 policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(l4only_key); p   // L4-Only policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(l3only_key); p   // L3-Only policy\n                  |    return TC_ACK_OK\n                  |-if p = map_lookup_elem(allowall_key); p // Allow-all policy\n                  |    return TC_ACK_OK\n                  |-return DROP_POLICY;                     // DROP\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e所做的事情也很清楚：\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e提取包的 src identity 信息，这个信息此时已经在包的元数据里面了。\u003c/li\u003e\n  \u003cli\u003e调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etail_ipv4_to_endpoint()\u003c/code\u003e，这个函数会进一步调用 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eipv4_policy()\u003c/code\u003e 执行\n容器入向（ingress）安全策略检查。\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003e如果包没有被策略拒绝，就会被转发到 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elxc00dd\u003c/code\u003e 的对端，即 POD4 的虚拟网卡 \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eeth0\u003c/code\u003e。\u003c/p\u003e\n\n\u003ch1 id=\"step-8-到达-pod4-容器\"\u003eStep 8: 到达 POD4 容器\u003c/h1\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/pod-to-service-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\u003cp align=\"center\"\u003eFig. Step 8.\u003c/p\u003e\n\n\u003cp\u003e包到达容器的虚拟网卡，接下来就会被更上层读取了。\u003c/p\u003e\n\n\u003ch1 id=\"总结\"\u003e总结\u003c/h1\u003e\n\n\u003cp\u003e本文探索了端到端的 Cilium/eBPF 的包转发路径，并结合 eBPF 代码进行了分析。\u003c/p\u003e\n\n\u003cp\u003e受篇幅限制，本文只分析了去向的路径；反向路径（POD4 回包）是类似的，只是\n BPF 中处理 reply 包的逻辑会有所不同，感兴趣的可以继续深挖。\u003c/p\u003e\n\n\u003cp align=\"center\"\u003e\u003cimg src=\"/assets/img/cilium-life-of-a-packet/round-trip-path.png\" width=\"100%\" height=\"100%\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e最后，非常重要的一点：\u003cstrong\u003e不要通过对比本文中 Cilium/eBPF 和 OpenStack/OVS 拓扑中的\n跳数，而对两种方案作出任何性能判断\u003c/strong\u003e。本文中，Cilium/eBPF 中的“跳”是一个完全不同\n的概念，更多地是为了方便理解整个转发过程而标注的序号，例如，从 Step 6 到 Step 7\n其实只是一次函数调用，从转发性能考虑，几乎没什么开销。\u003c/p\u003e\n\n\u003ch1 id=\"references\"\u003eReferences\u003c/h1\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ca href=\"/blog/ctrip-network-arch-evolution/\"\u003e云计算时代携程的网络架构变迁（2019）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/understanding-ebpf-datapath-in-cilium-zh/\"\u003e(译) 深入理解 Cilium 的 eBPF 收发包路径（datapath）（KubeCon, 2019）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/ebpf-and-k8s-zh/\"\u003e(译) 大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://docs.cilium.io/en/v1.8/gettingstarted/bird/\"\u003eUsing BIRD to run BGP — Cilium 1.8.3 documentation\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"/blog/cilium-network-topology-on-aws/\"\u003eCilium Network Topology and Traffic Path on AWS\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\n\n  \u003c!-- POST NAVIGATION --\u003e\n  \u003cdiv class=\"postNav clearfix\"\u003e\n     \n      \u003ca class=\"prev\" href=\"/blog/ebpf-and-k8s-zh/\"\u003e\u003cspan\u003e« [译] 大规模微服务利器：eBPF + Kubernetes（KubeCon, 2020）\u003c/span\u003e\n      \n    \u003c/a\u003e\n      \n      \n      \u003ca class=\"next\" href=\"/blog/cilium-life-of-a-packet-pod-to-service/\"\u003e\u003cspan\u003eLife of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics »\u003c/span\u003e\n       \n      \u003c/a\u003e\n     \n  \u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-09-12T00:00:00Z",
  "Author": "Arthur Chiao"
}