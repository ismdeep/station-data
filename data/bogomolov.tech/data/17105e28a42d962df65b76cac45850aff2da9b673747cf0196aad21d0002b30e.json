{
  "Source": "bogomolov.tech",
  "Title": "What is Big-O notation",
  "Link": "https://bogomolov.tech/What-is-Big-O-notation/",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cp\u003eYou have probably heard about the term Big-O notation. Many companies ask about it in the interview for the software engineer position. In practice, this term is using quite rare. Becoming more experienced you will know that one solution is better than the other without using Big-O notation. If you not sure, there are profilers to help you to measure your algorithm.\u003c/p\u003e\u003cp\u003eStill, it is worth knowing the basics. So, in this post we will observe:\u003c/p\u003e\u003cul\u003e\u003cli\u003eWhat is Big-O notation\u003c/li\u003e\u003cli\u003eBig-O complexity code examples using Javascript\u003c/li\u003e\u003cli\u003eHow to use Big O for algorithms complexity comparison\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"What-is-Big-O-notation\"\u003e\u003ca href=\"#What-is-Big-O-notation\" class=\"headerlink\" title=\"What is Big-O notation\"\u003e\u003c/a\u003eWhat is Big-O notation\u003c/h3\u003e\u003cp\u003eBig O notation is a notation, used to describe the performance or complexity of an algorithm. It describes the limiting behavior of a function when the argument tends towards a particular value or infinity.\u003c/p\u003e\u003cp\u003eIn programming, we need to write code using algorithms. For the same solution, we might use different algorithms. Some of them will work fast, and some will be very slow. A Big-O notation will help us to compare and choose the right solution.\u003c/p\u003e\u003cp\u003eLet’s see an example of notation: O(n\u003csup\u003e2\u003c/sup\u003e). Function inside brackets shows us the complexity of an algorithm. Simplified, it means that when we run this algorithm with 10 elements array size, and it will take 100 seconds to finish, when we run it 100 elements array size it will take 10000 seconds to finish.\u003c/p\u003e\u003cp\u003eHere is a code sample for O(n\u003csup\u003e2\u003c/sup\u003e) complexity written in Javascript.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; array.length; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; array.length; i++) {\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIn calculations, we care only about the dominant terms. The dominant term is the term that gets biggest as n gets bigger. For example, if the function is (n\u003csup\u003e2\u003c/sup\u003e + 2), we will use only (n\u003csup\u003e2\u003c/sup\u003e) and Big O will be O(n\u003csup\u003e2\u003c/sup\u003e). Another example: n\u003csup\u003e2\u003c/sup\u003e + n\u003csup\u003e4\u003c/sup\u003e. In this formula, n\u003csup\u003e4\u003c/sup\u003e will grow faster, and it will be the dominant term. Big O notation will be O(n\u003csup\u003e4\u003c/sup\u003e).\u003c/p\u003e\u003ch2 id=\"Big-O-complexity-code-examples-using-Javascript\"\u003e\u003ca href=\"#Big-O-complexity-code-examples-using-Javascript\" class=\"headerlink\" title=\"Big-O complexity code examples using Javascript\"\u003e\u003c/a\u003eBig-O complexity code examples using Javascript\u003c/h2\u003e\u003cp\u003eLet’s see code examples of the most common Big-O notations.\u003c/p\u003e\u003cp\u003eThe time I am using in the examples below is not the actual time. Its main goal is to show you the difference depending on the input size, not the actual time.\u003c/p\u003e\u003ch3 id=\"O-1-complexity\"\u003e\u003ca href=\"#O-1-complexity\" class=\"headerlink\" title=\"O(1) complexity\"\u003e\u003c/a\u003eO(1) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elogFirstElement\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(array[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThis notation means constant time. Whether we run this code with 1 or 1000 elements array, there will be the same 1 second.\u003c/p\u003e\u003ch3 id=\"O-log-n-complexity\"\u003e\u003ca href=\"#O-log-n-complexity\" class=\"headerlink\" title=\"O(log n) complexity\"\u003e\u003c/a\u003eO(log n) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ebinarySearch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earray, target\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e lowIndex = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; \n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e highIndex = array.length - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e middleIndex; \n      \n    \u003cspan class=\"hljs-keyword\"\u003ewhile\u003c/span\u003e (lowIndex \u0026lt;= highIndex) {  \n        middleIndex = \u003cspan class=\"hljs-built_in\"\u003eMath\u003c/span\u003e.floor((lowIndex + highIndex) / \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e(array[middleIndex] === target) { \n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e middleIndex;\n        } \n  \n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (target \u0026lt; array[middleIndex]) {  \n            highIndex = middleIndex - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \n        } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {  \n            lowIndex = middleIndex + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e; \n        } \n    } \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e; \n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s say we run this function with 100 elements size array, and it takes 2 seconds. Then if we run it with a 10000 elements size array, and it will take 4 seconds. Increasing the input size, time grows slower.\u003c/p\u003e\u003ch3 id=\"O-n-complexity\"\u003e\u003ca href=\"#O-n-complexity\" class=\"headerlink\" title=\"O(n) complexity\"\u003e\u003c/a\u003eO(n) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elogAllArrayElements\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; array.length; i++) {\n        \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(array[i]);\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s say we run with 100 elements size array, and it takes 100 seconds. Then if we run it with 1000 elements it will take 1000 seconds.\u003c/p\u003e\u003ch3 id=\"O-n-log-n-complexity\"\u003e\u003ca href=\"#O-n-log-n-complexity\" class=\"headerlink\" title=\"O(n log n) complexity\"\u003e\u003c/a\u003eO(n log n) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emultiDimentionalBinarySearch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earrayOfArrays, target\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; arrayOfArrays.length; i++) {\n        binarySearch(arrayOfArrays[i], target); \u003cspan class=\"hljs-comment\"\u003e// binarySearch from example above\u003c/span\u003e\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLet’s say we have two arrays with 100 elements each and using the function above, it will take approximately 4 seconds, 2 seconds for each binary search. Then if we run the function with 10 arrays with 100 elements each, it will take 20 seconds.\u003c/p\u003e\u003ch3 id=\"O-n2-complexity\"\u003e\u003ca href=\"#O-n2-complexity\" class=\"headerlink\" title=\"O(n2) complexity\"\u003e\u003c/a\u003eO(n\u003csup\u003e2\u003c/sup\u003e) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003emultiplyAllArrayElements\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earray\u003c/span\u003e) \u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; array.length; i++) {\n        \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e n = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; n \u0026lt; array.length; n++) {\n            \u003cspan class=\"hljs-built_in\"\u003econsole\u003c/span\u003e.log(i * n);\n        }\n    }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf we have an array with 2 elements, and it takes 4 seconds to run, then if we have 10 elements array it will take 100 seconds to finish.\u003c/p\u003e\u003ch3 id=\"O-2n-complexity\"\u003e\u003ca href=\"#O-2n-complexity\" class=\"headerlink\" title=\"O(2n) complexity\"\u003e\u003c/a\u003eO(2\u003csup\u003en\u003c/sup\u003e) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecalculateFibonacci\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enumber\u003c/span\u003e)\n\u003c/span\u003e{\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (number \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num;    \n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e calculateFibonacci(number - \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) + calculateFibonacci(number - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eIf we have an array with 2 elements, and it takes 4 seconds to run, then if we have 10 elements array it will take 1024 seconds to finish.\u003c/p\u003e\u003ch3 id=\"O-n-complexity-1\"\u003e\u003ca href=\"#O-n-complexity-1\" class=\"headerlink\" title=\"O(n!) complexity\"\u003e\u003c/a\u003eO(n!) complexity\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"hljs javascript\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eiterateRecursive\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einputNumber\u003c/span\u003e) \u003c/span\u003e{\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; inputNumber; i++) {\n    iterateRecursive(inputNumber - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eThe exclamation mark (!) here is a factorial. Factorial means to multiply all numbers decreasing input number by one. If we have an input number equals to 3, and it takes 6 seconds to run then if we run the function with an input number equals to 5 it will take 120 seconds to finish.\u003c/p\u003e\u003ch2 id=\"How-to-use-Big-O-for-algorithms-complexity-comparison\"\u003e\u003ca href=\"#How-to-use-Big-O-for-algorithms-complexity-comparison\" class=\"headerlink\" title=\"How to use Big O for algorithms complexity comparison\"\u003e\u003c/a\u003eHow to use Big O for algorithms complexity comparison\u003c/h2\u003e\u003cp\u003eNow you know the most common algorithm complexities. Let’s say you have to choose one of two algorithms. You might calculate abstract time for both as we did above for every example and then choose the best algorithm depending on these numbers.\u003c/p\u003e\u003cp\u003eOr you might use the chart below to compare algorithms without sample calculations.\u003c/p\u003e\u003cimg src=\"/What-is-Big-O-notation/big-o-complexity-chart.png\" title=\"Big O notations comparison\"/\u003e\u003cp\u003eChart from \u003ca href=\"https://www.bigocheatsheet.com/\" target=\"_blank\" rel=\"noopener\"\u003ebigocheatsheet.com\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"Other-complexity-notations\"\u003e\u003ca href=\"#Other-complexity-notations\" class=\"headerlink\" title=\"Other complexity notations\"\u003e\u003c/a\u003eOther complexity notations\u003c/h2\u003e\u003cp\u003eBig-O notation is not the only notation used to describe algorithm complexity. Big O (O()) is mainly used, and it describes the upper bound of the complexity.\u003c/p\u003e\u003cp\u003eHere are some more examples or notations.\u003c/p\u003e\u003cul\u003e\u003cli\u003eOmega (Ω()) describes the lower bound of the complexity.\u003c/li\u003e\u003cli\u003eTheta (Θ()) describes the tight bound of the complexity, i.e. upper and lower bound.\u003c/li\u003e\u003cli\u003eLittle O (o()) describes the upper bound excluding the exact bound.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eBesides time complexity, Big O notation is used for memory complexity. Use it the same way as for the time complexity.\u003c/p\u003e\u003cbr/\u003e\u003cdiv class=\"related-posts\"\u003e\u003chr/\u003e\u003ch3\u003eRelated posts:\u003c/h3\u003e\u003cul class=\"popular-posts\"\u003e\u003cli class=\"popular-posts-item\"\u003e\u003cdiv class=\"popular-posts-title\"\u003e\u003ch3\u003e\u003ca href=\"/Facebook-Log-Id-Symfony/\" title=\"Implement Facebook login button with Symfony\" rel=\"bookmark\"\u003eImplement Facebook login button with Symfony\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\"popular-posts-item\"\u003e\u003cdiv class=\"popular-posts-title\"\u003e\u003ch3\u003e\u003ca href=\"/Basics-of-sound/\" title=\"Beat detection in Java for Android\" rel=\"bookmark\"\u003eBeat detection in Java for Android\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\"popular-posts-item\"\u003e\u003cdiv class=\"popular-posts-title\"\u003e\u003ch3\u003e\u003ca href=\"/Nodejs-production-systemd/\" title=\"How to manage Nodejs process using systemd\" rel=\"bookmark\"\u003eHow to manage Nodejs process using systemd\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\"popular-posts-item\"\u003e\u003cdiv class=\"popular-posts-title\"\u003e\u003ch3\u003e\u003ca href=\"/Telegram-notification-on-SSH-login/\" title=\"Send message to Telegram on any SSH login\" rel=\"bookmark\"\u003eSend message to Telegram on any SSH login\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003c/li\u003e\u003cli class=\"popular-posts-item\"\u003e\u003cdiv class=\"popular-posts-title\"\u003e\u003ch3\u003e\u003ca href=\"/android-sms-forwarding/\" title=\"SMS Forwarding - Android App Sends Texts to Webserver\" rel=\"bookmark\"\u003eSMS Forwarding - Android App Sends Texts to Webserver\u003c/a\u003e\u003c/h3\u003e\u003c/div\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003cdiv id=\"comment-container\"\u003e\u003c/div\u003e\u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-11-16T00:00:00Z",
  "Author": "Konstantin Bogomolov"
}