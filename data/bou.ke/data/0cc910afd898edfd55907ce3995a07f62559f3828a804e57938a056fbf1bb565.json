{
  "Source": "bou.ke",
  "Title": "A Couple Small Nix Tips",
  "Link": "https://bou.ke/blog/nix-tips/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eA Couple Small Nix Tips\u003c/h1\u003e\n  \u003cp\u003eHere’s a bunch of small nix tips, for my own future reference. Everything assumes you’ve enabled \u003ca href=\"https://nixos.wiki/wiki/Flakes\" target=\"_blank\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix-command\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eflakes\u003c/code\u003e experimental features\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"remote-builders\"\u003eRemote builders\u003c/h2\u003e\n\n\u003cp\u003eNix has a neat feature where you can add ‘remote builders’ which it can send build tasks to during the build process. This is especially useful if you’re e.g. building a Linux package from macOS. There’s two ways to do this:\u003c/p\u003e\n\n\u003ch3 id=\"nixbuild\"\u003e\u003ca href=\"https://nixbuild.net/\" target=\"_blank\"\u003enixbuild\u003c/a\u003e\u003c/h3\u003e\n\n\u003cp\u003e\u003ca href=\"https://nixbuild.net/\" target=\"_blank\"\u003enixbuild\u003c/a\u003e is a service that providers remote Linux builders as a service—you even get a quite generous 25 CPU hours per month. \u003ca href=\"https://docs.nixbuild.net/getting-started/index.html\" target=\"_blank\"\u003eSetup is not too complicated\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"using-a-virtual-machine\"\u003eUsing a virtual machine\u003c/h3\u003e\n\n\u003cp\u003eYou can run a ‘remote’ builder VM on your computer that runs Linux. The coolest implementation I’ve seen of this is \u003ca href=\"https://xyno.space/post/nixos-utm-rosetta\" target=\"_blank\"\u003eusing Rosetta 2 to execute \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e binaries\u003c/a\u003e in the VM so you get \u003cem\u003etwo architectures\u003c/em\u003e (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eaarch64\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex86_64\u003c/code\u003e) for the price of one.\u003c/p\u003e\n\n\u003cp\u003eA way of running a Linux VM through QEMU as a builder \u003ca href=\"https://github.com/NixOS/nixpkgs/issues/108984\" target=\"_blank\"\u003ewas recently merged\u003c/a\u003e into Nixpkgs, this doesn’t provide the Rosetta 2 thing though because QEMU doesn’t support that.\u003c/p\u003e\n\n\u003cp\u003eIt would be nice if someone made a nicely packaged app that would run in the background accepting SSH connections, quickly booting up a Linux VM when needed and spinning it down when idle after a while.\u003c/p\u003e\n\n\u003cp\u003eThis could even use \u003ca href=\"https://developer.apple.com/documentation/virtualization/shared_directories?language=objc\" target=\"_blank\"\u003edirectory shares\u003c/a\u003e to share the Nix store and avoid copying the files over, though that might require some Nix changes to deal with file locking.\u003c/p\u003e\n\n\u003ch2 id=\"deploying-to-a-nixos-machine-from-macos\"\u003eDeploying to a NixOS machine from macOS\u003c/h2\u003e\n\n\u003cp\u003eThere’s a bunch of different tools for deploying NixOS machines but it turns out that nixos-rebuild supports remote deployment directly.\u003c/p\u003e\n\n\u003cdiv class=\"language-sh highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003enix run nixpkgs#nixos-rebuild \u003cspan class=\"nt\"\u003e--\u003c/span\u003e \u003cspan class=\"nt\"\u003e--fast\u003c/span\u003e \u003cspan class=\"nt\"\u003e--target-host\u003c/span\u003e user@remote-host \u003cspan class=\"nt\"\u003e--build-host\u003c/span\u003e user@remote-host \u003cspan class=\"nt\"\u003e--flake\u003c/span\u003e .#machine \u003cspan class=\"nt\"\u003e--use-remote-sudo\u003c/span\u003e switch\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eLet’s go to this command step by step:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix run nixpkgs#nixos-rebuild\u003c/code\u003e run the nixos-rebuild command from nixpkgs. You could also install the nixos-rebuild package into your environment.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--fast\u003c/code\u003e this avoids re-executing nixos-rebuild from the resulting system. This doesn’t work from macOS because it’ll try to execute a Linux bash binary on Mac…\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--target-host user@remote-host --build-host user@remote-host\u003c/code\u003e the most important thing, the target to deploy to and where to build the system, as an SSH target. If you omit the build host it’ll build it locally, which can work if you’ve set up a Linux remote builder.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--flake .#machine\u003c/code\u003e which flake to configure the system with. Note that this is evaluated locally—so you don’t need to copy any nix files to the target host!\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--use-remote-sudo\u003c/code\u003e use sudo on the remote machine to execute the commands.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eI figured out these things from reading \u003ca href=\"https://github.com/NixOS/nixpkgs/blob/master/pkgs/os-specific/linux/nixos-rebuild/nixos-rebuild.sh\" target=\"_blank\"\u003ethe source\u003c/a\u003e (always read the source!) which is a pretty straightforward bash script.\u003c/p\u003e\n\n\u003ch2 id=\"flake-pinning\"\u003eFlake pinning\u003c/h2\u003e\n\n\u003cp\u003eWhat does Nix evaluate when you do \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix run nixpkgs#hello\u003c/code\u003e? The first part of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enixpkgs#hello\u003c/code\u003e specifies which flake to evaluate. This can be a path like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e./directory\u003c/code\u003e, a URL or an identifier that’s in the flake ‘registry’. You can view the flake registry with: \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix registry list\u003c/code\u003e. The flake registry is actually tiered:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eglobal\u003c/code\u003e are defined at \u003ca href=\"https://github.com/NixOS/flake-registry/blob/master/flake-registry.json\" target=\"_blank\"\u003eflake-registry\u003c/a\u003e and are the same for everyone\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem\u003c/code\u003e is defined at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/nix/registry.json\u003c/code\u003e and shared for all the users.\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003euser\u003c/code\u003e is at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~/.config/nix/registry.json\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThe registry JSON format is defined \u003ca href=\"https://nixos.org/manual/nix/stable/command-ref/new-cli/nix3-registry.html#registry-format\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eYou can run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix flake registry pin nixpkgs\u003c/code\u003e to add something to the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003euser\u003c/code\u003e registry.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esystem\u003c/code\u003e registry is best managed using your \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enixos\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix-darwin\u003c/code\u003e configuration. Something cool you can do is create the following \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enixos\u003c/code\u003e module:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e{ nixpkgs }: { nix.registry.nixpkgs.flake = nixpkgs; }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis pins nixpkgs to whatever nixpkgs is when you install your nixos configuration. This makes it much faster to do \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix run nixpkgs#hello\u003c/code\u003e because the nixpkgs repository is already available and some dependencies might already be installed.\u003c/p\u003e\n\n\u003ch2 id=\"install-binaries-globally-for-nix-darwin\"\u003eInstall binaries globally for nix-darwin\u003c/h2\u003e\n\n\u003cp\u003eIf you use \u003ca href=\"https://github.com/LnL7/nix-darwin\" target=\"_blank\"\u003enix-darwin\u003c/a\u003e you can add things to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eenvironment.systemPackages\u003c/code\u003e which then makes them available at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/run/current-system/sw/bin\u003c/code\u003e. It can be hard to configure all of your tools to take this path into consideration however, so I have the following in my nix-darwin config:\u003c/p\u003e\n\n\u003cdiv class=\"language-nix highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"nv\"\u003esystem\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nv\"\u003eactivationScripts\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nv\"\u003epostActivation\u003c/span\u003e\u003cspan class=\"o\"\u003e.\u003c/span\u003e\u003cspan class=\"nv\"\u003etext\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s2\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003cspan class=\"s2\"\u003e    ln -sfn /run/current-system/sw/bin/ /usr/local/bin\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003cspan class=\"s2\"\u003e    ln -sfn /run/current-system/sw/lib/ /usr/local/lib\u003c/span\u003e\u003cspan class=\"err\"\u003e\n\u003c/span\u003e\u003cspan class=\"s2\"\u003e  \u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis links the bin and lib directories into /usr/local, so everything that’s installed there will be available in e.g. VS Code.\u003c/p\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eJan 2023\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2023-01-01T00:00:00Z",
  "Author": "bou.ke"
}