{
  "Source": "bou.ke",
  "Title": "Doubling Go's template performance by generating code",
  "Link": "https://bou.ke/blog/code-generating-code/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eDoubling Go\u0026#39;s template performance by generating code\u003c/h1\u003e\n  \u003cp\u003eSome of the most useful built in-packages in Go are \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etext/template\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehtml/template\u003c/code\u003e. They are very easy to use with whatever objects you hand to it, but this flexibility incurs a cost because they interpret the templates dynamically. This means that every time you execute the template, Go has to go through the syntax tree and decide what to do for every different kind of construct, including using reflection to access methods and fields.\u003c/p\u003e\n\n\u003cp\u003eI thought it would be a fun challenge to take a stab at implementing a code generator for the built-in template engine. The result is \u003ca href=\"https://github.com/bouk/statictemplate\" target=\"_blank\"\u003estatictemplate\u003c/a\u003e. It is a code generator that will analyze your template and produce the equivalent Go-code, which you can then compile into your program. This gives you way better performance! The repository contains an \u003ca href=\"https://github.com/bouk/statictemplate/tree/master/example\" target=\"_blank\"\u003eexample\u003c/a\u003e for a blog, with just a simple index page. \u003ca href=\"https://github.com/bouk/statictemplate/blob/master/example/template/template.go\" target=\"_blank\"\u003eThe result\u003c/a\u003e after putting the templates through the generator uses no reflection whatsoever, still does HTML escaping and is substantially more performant than the built-in template engine. Running a benchmark against it gives me the following numbers:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003eBenchmarkStaticTemplate-8  20000  65479 ns/op\nBenchmarkDynamicTemplate-8 10000 135933 ns/op\nPASS\nok      github.com/bouk/statictemplate/example  3.390s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eDo note that the performance heavily depends on the complexity of the template, with more complex templates benefitting the most from being compiled. The example is fairly simple, so in practice the numbers are probably better!\u003c/p\u003e\n\n\u003ch2 id=\"support\"\u003eSupport\u003c/h2\u003e\n\n\u003cp\u003eI have re-implemented every structure used in the template engine, taking care to support less-used features like being able to call methods that can return an error. The generator is \u003ca href=\"https://github.com/bouk/statictemplate/blob/master/statictemplate/translate_test.go\" target=\"_blank\"\u003equite extensively tested\u003c/a\u003e, but if you find an issue, please report it.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-use-it\"\u003eHow to use it\u003c/h2\u003e\n\n\u003cp\u003eWhile generating the code for your template the generator needs type information to be able to generate the appropriate code for expressions like the following:\u003c/p\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e{{ .Value }}\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003eThe reason is that \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eValue\u003c/code\u003e could be either a field or a method, and the only way to figure that out at runtime is through reflection.\u003c/p\u003e\n\n\u003cp\u003eTo supply this type information, you will need to write some code. You can do something like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epackage main\n\nimport (\n\t\u0026#34;github.com/bouk/statictemplate/statictemplate\u0026#34;\n\t\u0026#34;os\u0026#34;\n\t\u0026#34;reflect\u0026#34;\n\t\u0026#34;text/template\u0026#34;\n)\n\nfunc main() {\n\tt := template.Must(template.New(\u0026#34;template.tmpl\u0026#34;).Parse(\u0026#34;Hi there {{ . }}!\u0026#34;))\n\tcode, _ := statictemplate.Translate(t, \u0026#34;main\u0026#34;, []statictemplate.TranslateInstruction{\n\t\t{\u0026#34;Neat\u0026#34;, \u0026#34;template.tmpl\u0026#34;, reflect.TypeOf(\u0026#34;\u0026#34;)},\n\t})\n\tos.Stdout.Write(code)\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWhen run, this will output the following code:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003epackage main\n\nimport (\n\t\u0026#34;io\u0026#34;\n)\n\nfunc Neat(w io.Writer, dot string) (err error) {\n\tdefer func() {\n\t\tif recovered := recover(); recovered != nil {\n\t\t\tvar ok bool\n\t\t\tif err, ok = recovered.(error); !ok {\n\t\t\t\tpanic(recovered)\n\t\t\t}\n\t\t}\n\t}()\n\treturn fun0(w, dot)\n}\n\n// template.tmpl(string)\nfunc fun0(w io.Writer, dot string) error {\n\t_, _ = io.WriteString(w, \u0026#34;Hi there \u0026#34;)\n\t_, _ = io.WriteString(w, dot)\n\t_, _ = io.WriteString(w, \u0026#34;!\u0026#34;)\n\treturn nil\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eNeat\u003c/code\u003e function can then be called with an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eio.Writer\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003estring\u003c/code\u003e. \u003ca href=\"https://godoc.org/github.com/bouk/statictemplate/statictemplate\" target=\"_blank\"\u003eCheck out the docs for this package\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"code-generating-code-generating-code\"\u003eCode generating code generating code\u003c/h2\u003e\n\n\u003cp\u003eRemember two paragraphs ago where I said you needed to write some code? I was lying!\u003c/p\u003e\n\n\u003cp\u003eThe way the generator code should be written is basically the same for most scenarios, so I decided to create a CLI-tool to do this job for you. We are lazy programmers after all. This tool is actually code that generates code, that generates code! It then immediately executes the generates code and outputs the result to a file you specify. It even supports generating a file that can be used while developing, using the regular standard library template package to re-interpret the files on every use, which means you can work on the templates without recompiling between changes. You can install the CLI-tool by running:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003ego get bou.ke/statictemplate\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eYou then specify what functions you want to generate by using the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-t\u003c/code\u003e argument. The command used for the example in the repository is as follows:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003estatictemplate -html -o example/template/template.go -t \u0026#34;Index:index.tmpl:[]github.com/bouk/statictemplate/example.Post\u0026#34; example/template/*.tmpl\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis will generate one function named \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eIndex\u003c/code\u003e that executes \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eindex.tmpl\u003c/code\u003e using an array of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePost\u003c/code\u003es. As you can see you need to specify the full type name including the package name.\u003c/p\u003e\n\n\u003ch2 id=\"support-for-functions-and-html-templates\"\u003eSupport for functions and HTML templates\u003c/h2\u003e\n\n\u003cp\u003eSupporting the built-in functions like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elen\u003c/code\u003e required performing some linking acrobatics, as not all the functions are available publicly. The way these functions are accessed is a bit sketchy, but it’s done using the \u003ca href=\"https://sitano.github.io/2016/04/28/golang-private/\" target=\"_blank\"\u003e//go:linkname\u003c/a\u003e construct. Using this method I created \u003ca href=\"https://github.com/bouk/statictemplate/blob/master/funcs/funcs.go\" target=\"_blank\"\u003ealiases\u003c/a\u003e of all the template functions that are accessible.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://github.com/bouk/statictemplate/blob/master/statictemplate/wrapper.go#L56\" target=\"_blank\"\u003esame\u003c/a\u003e technique was required for adding support for HTML templates, as the method that automatically augments the template with escaping functions isn’t accessible. HTML escaping can be enabled by passing \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e-html\u003c/code\u003e to the CLI-tool.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eI had a lot of fun with this project, and I hope it’s useful for somebody. Please \u003ca href=\"https://github.com/bouk/statictemplate\" target=\"_blank\"\u003echeck out it out\u003c/a\u003e, and use it in your own project! I think there’s lots of benefits the Go community can derive from code generators, in both performance and functionality. Compiling the template in like this makes it super easy to distribute the binary, as you don’t need to rsync over any template directory but can just copy over a single binary.\u003c/p\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eJan 2017\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2017-01-01T00:00:00Z",
  "Author": "bou.ke"
}