{
  "Source": "bou.ke",
  "Title": "Monkey Patching in Go",
  "Link": "https://bou.ke/blog/monkey-patching-in-go/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eMonkey Patching in Go\u003c/h1\u003e\n  \u003cp\u003eMany people think that monkey patching is something that is restricted to dynamic languages like Ruby and Python. That is not true however, as computers are just dumb machines and we can always make them do what we want! Let’s look at how Go functions work and how we can modify them at runtime. This article will use a lot of Intel assembly syntax, so I’m assuming you can read it already or are using a \u003ca href=\"https://software.intel.com/en-us/articles/introduction-to-x64-assembly\" target=\"_blank\"\u003ereference\u003c/a\u003e while reading.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eIf you’re not interested in how it works and you just want to do monkey patching, then you can find the library \u003ca href=\"https://github.com/bouk/monkey\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eLet’s look at what the following code produces when disassembled:\u003c/p\u003e\n\n\u003cp\u003e\u003cspan class=\"marginnote\"\u003eSamples should be built with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ego build -gcflags=-l\u003c/code\u003e to disable inlining. For this article I assume your architecture is 64-bits and that you’re using a unix-based operating system like Mac OSX or a Linux variant.\u003c/span\u003e\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/17262666fae75dd24a25.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eWhen compiled and looked at through \u003ca href=\"https://hopperapp.com/\" target=\"_blank\"\u003eHopper\u003c/a\u003e, the above code will produce this assembly code:\u003c/p\u003e\n\n\u003cimg src=\"/images/hopper-1.png\" width=\"566\"/\u003e\n\u003cp\u003eI will be referring to the addresses of the various instructions displayed on the left side of the screen.\u003c/p\u003e\n\n\u003cp\u003eOur code starts in procedure \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.main\u003c/code\u003e, where instructions \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2010\u003c/code\u003e to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2026\u003c/code\u003e set up the stack. You can read more about that \u003ca href=\"https://dave.cheney.net/2013/06/02/why-is-a-goroutines-stack-infinite\" target=\"_blank\"\u003ehere\u003c/a\u003e, I will be ignoring that code for the rest of the article.\u003c/p\u003e\n\n\u003cp\u003eLine \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x202a\u003c/code\u003e is the call to function \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a\u003c/code\u003e at line \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2000\u003c/code\u003e which simply moves \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x1\u003c/code\u003e onto the stack and returns. Lines \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x202f\u003c/code\u003e to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2037\u003c/code\u003e then pass that value on to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eruntime.printint\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eSimple enough! Now let’s take a look at how function values are implemented in Go.\u003c/p\u003e\n\n\u003ch2 id=\"how-function-values-work-in-go\"\u003eHow function values work in Go\u003c/h2\u003e\n\n\u003cp\u003eConsider the following code:\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/c921c3627ddbaae05356.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eWhat I’m doing on line 11 is assigning \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef\u003c/code\u003e, which means that doing \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef()\u003c/code\u003e will now call \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e. Then I use the \u003ca href=\"https://golang.org/pkg/unsafe/\" target=\"_blank\"\u003eunsafe\u003c/a\u003e Go package to directly read out the value stored in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef\u003c/code\u003e. If you come from a C background you might expect \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef\u003c/code\u003e to simply be a function pointer to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e and thus this code to print out \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2000\u003c/code\u003e (the location of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a\u003c/code\u003e as we saw above). When I run this on my machine I get \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x102c38\u003c/code\u003e, which is an address not even close to our code! When disassembled, this is what happens on line 11 above:\u003c/p\u003e\n\n\u003cimg src=\"/images/hopper-2.png\" width=\"488\"/\u003e\n\u003cp\u003eThis references something called \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a.f\u003c/code\u003e, and when we look at that location, we see this:\u003c/p\u003e\n\n\u003cimg src=\"/images/hopper-3.png\" width=\"398\"/\u003e\n\u003cp\u003eAha! \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a.f\u003c/code\u003e is at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x102c38\u003c/code\u003e and contains \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2000\u003c/code\u003e, which is the location of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a\u003c/code\u003e. It seems \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef\u003c/code\u003e isn’t a pointer to a function, but a pointer to a pointer to a function. Let’s modify the code to compensate for that.\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/c470c4d80ae80d7b30af.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eThis will now print \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e0x2000\u003c/code\u003e, as expected. We can find a clue as to why this is implemented as it is \u003ca href=\"https://github.com/golang/go/blob/e9d9d0befc634f6e9f906b5ef7476fbd7ebd25e3/src/runtime/runtime2.go#L75-L78\" target=\"_blank\"\u003ehere\u003c/a\u003e. Go function values can contain extra information, which is how closures and bound instance methods are implemented.\u003c/p\u003e\n\n\u003cp\u003eLet’s look at how calling a function value works. I’ll change the code to call \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef\u003c/code\u003e after assigning it.\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/58bba533fb3b742ed964.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eWhen we disassemble this we get the following:\u003c/p\u003e\n\n\u003cimg src=\"/images/hopper-4.png\" width=\"442\"/\u003e\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emain.a.f\u003c/code\u003e gets loaded into \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e, then whatever \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e points at gets loaded into \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erbx\u003c/code\u003e, which then gets called. The address of the function value always gets loaded into \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e, which the code being called can use to load any extra information it might need. This extra information is a pointer to the instance for a bound instance method and the closure for an anonymous function. I advise you to take out a disassembler and dive deeper if you want to know more!\u003c/p\u003e\n\n\u003cp\u003eLet’s use our newly gained knowledge to implement monkeypatching in Go.\u003c/p\u003e\n\n\u003ch2 id=\"replacing-a-function-at-runtime\"\u003eReplacing a function at runtime\u003c/h2\u003e\n\n\u003cp\u003eWhat we want to achieve is to have the following code print out \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2\u003c/code\u003e:\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/713f3df2115e1b5e554d.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eNow how do we implement \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ereplace\u003c/code\u003e? We need to modify function \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e to jump to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e’s code instead of executing its own body. Essentialy, we need to replace it with this, which loads the function value of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e into \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e and then jumps to the location pointed to by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erdx\u003c/code\u003e.\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/e886664740906bfffd76.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eI’ve put the corresponding machine code that those lines generate when assembled next to it (you can easily play around with assembly using an online assembler like \u003ca href=\"https://defuse.ca/online-x86-assembler.htm\" target=\"_blank\"\u003ethis\u003c/a\u003e). Writing a function that will generate this code is now straightforward, and looks like this:\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/4ed563abdcd06fc45fa0.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eWe now have everything we need to replace \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e’s function body with a jump to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e! The following code attempts to copy the machine code directly to the location of the function body.\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/305264604c38a8815def.js\"\u003e\u003c/script\u003e\n\n\u003cp\u003eRunning this code does not work however, and will result in a segmentation fault. This is because the loaded binary \u003ca href=\"https://en.wikipedia.org/wiki/Segmentation_fault#Writing_to_read-only_memory\" target=\"_blank\"\u003eis not writable by default\u003c/a\u003e. We can use the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emprotect\u003c/code\u003e syscall to disable this protection, and this final version of the code does exactly that, resulting in function \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea\u003c/code\u003e being replaced by function \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eb\u003c/code\u003e, and ‘2’ being printed.\u003c/p\u003e\n\n\u003cscript src=\"https://gist.github.com/bouk/55900e1d964099368ab0.js\"\u003e\u003c/script\u003e\n\n\u003ch2 id=\"wrapping-it-up-in-a-nice-library\"\u003eWrapping it up in a nice library\u003c/h2\u003e\n\n\u003cp\u003eI took the above code and \u003ca href=\"https://github.com/bouk/monkey\" target=\"_blank\"\u003eput it in an easy to use library\u003c/a\u003e. It supports 32 bit, reversing patches, and patching instance methods. I wrote a couple of examples and put those in the README.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eWhere there’s a will there’s a way! It’s possible for a program to modify itself at runtime, which allows us to implement cool tricks like monkey patching.\u003c/p\u003e\n\n\u003cp\u003eI hope you got something useful out of this blogpost, I know I had fun making it!\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://news.ycombinator.com/item?id=9290917\" target=\"_blank\"\u003eHacker News\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.reddit.com/r/golang/comments/30try1/monkey_patching_in_go/\" target=\"_blank\"\u003eReddit\u003c/a\u003e\u003c/p\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eMar 2015\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2015-03-01T00:00:00Z",
  "Author": "bou.ke"
}