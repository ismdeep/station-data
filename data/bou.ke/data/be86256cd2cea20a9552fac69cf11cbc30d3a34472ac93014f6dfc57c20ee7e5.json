{
  "Source": "bou.ke",
  "Title": "How to steal any developer's local database",
  "Link": "https://bou.ke/blog/hacking-developers/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eHow to steal any developer\u0026#39;s local database\u003c/h1\u003e\n  \u003cp\u003eIf you’re reading this and you’re a software developer, you’re probably running some services locally. Redis, Memcached, and Elasticsearch are software products that many rely on. What you might not know, is that these locally running services are accessible by any website you visit, making it possible for bad guys to steal the data you have locally!\u003c/p\u003e\n\n\u003ch2 id=\"how-it-works\"\u003eHow it works\u003c/h2\u003e\n\u003cp\u003eWhile I am not presenting anything new in this post, I have never see anyone put together this attack as complete as I’ll be showing here. I combined two different attack approaches, namely ‘cross protocol scripting’ and ‘DNS rebinding’.\u003c/p\u003e\n\n\u003ch2 id=\"talking-to-redis-memcached-and-elasticsearch\"\u003eTalking to Redis, Memcached, and Elasticsearch\u003c/h2\u003e\n\u003cp\u003eThe first technique is an old one sometimes called ‘cross protocol scripting’. A \u003ca href=\"https://www.jochentopf.com/hfpa/hfpa.pdf\" target=\"_blank\"\u003epaper\u003c/a\u003e was published in 2001 detailing this attack, but the gist is that both Redis and Memcached have a simple line-based protocol that ignores any invalid commands. This means that if a browser sends the following HTTP request to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elocalhost:6379\u003c/code\u003e (where Redis usually runs), Redis will happily execute the SET command.\u003c/p\u003e\n\n\u003cpre class=\"code\"\u003ePOST / HTTP/1.1\nHost: localhost:6379\n\nSET abc 123\nQUIT\n\u003c/pre\u003e\n\n\u003cp\u003eWe can send a request like this by submitting the following form:\u003c/p\u003e\n\n\u003cpre class=\"code\"\u003e\u0026lt;form enctype=\u0026#34;text/plain\u0026#34; method=\u0026#34;POST\u0026#34; action=\u0026#34;http://localhost:6379\u0026#34;\u0026gt;\n\u0026lt;textarea name=\u0026#34;abc\u0026#34;\u0026gt;\n\nSET abc 123\nQUIT\n\u0026lt;/textarea\u0026gt;\n\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34; /\u0026gt;\n\u0026lt;/form\u0026gt;\n\u003c/pre\u003e\n\n\u003cp\u003eElasticsearch’s protocol is fully HTTP-based so there are no tricks needed to communicate with it.\u003c/p\u003e\n\n\u003cp\u003eWhile we can execute any command, we can’t actually retrieve the result. This is because of the browser’s \u003ca href=\"https://en.wikipedia.org/wiki/Same-origin_policy\" target=\"_blank\"\u003esame-origin policy\u003c/a\u003e, which ensures that reading data from a request to another domain is not possible. That’s where the second technique comes in!\u003c/p\u003e\n\n\u003ch2 id=\"dns-rebinding\"\u003eDNS Rebinding\u003c/h2\u003e\n\u003cp\u003eTo get around the origin protection we can use a technique called \u003ca href=\"https://crypto.stanford.edu/dns/dns-rebinding.pdf\" target=\"_blank\"\u003eDNS rebinding\u003c/a\u003e. DNS rebinding involves having a server accessible through a public domain with a very low TTL. Once a browser connects to the site, the site will immediately change the DNS record to point to a different IP address (like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e127.0.0.1\u003c/code\u003e). This leads to a situation where the site runs the attackers’ code, in the context of a private IP address. This site can then go ahead and steal any data that is available on a service, that was set up with the assumption of only being available through authorized clients.\u003c/p\u003e\n\n\u003ch2 id=\"poc\"\u003ePoC\u003c/h2\u003e\n\u003cp\u003eI have created a proof of concept of this attack on \u003ca href=\"http://extractdata.club\" target=\"_blank\"\u003eextractdata.club\u003c/a\u003e. The site will attempt to connect to Redis, Memcached and Elasticsearch running on their default ports on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elocalhost\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eAfter about a minute that link should display something similar to the following:\u003c/p\u003e\n\n\u003cimg style=\"max-width:475px\" src=\"https://i.imgur.com/Jx9HrhE.jpg\"/\u003e\n\u003cp\u003eWhile my PoC only retrieves the version information of each service, it can’t be hard to imagine building a sort of scraper that goes through the whole database and extracts all of the data. The code is available \u003ca href=\"https://github.com/bouk/extractdata\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"mitigation\"\u003eMitigation\u003c/h2\u003e\n\u003cp\u003eUnfortunately, there is no easy way for the databases to structurally fix the issues shown here. You could set up your services with passwords, but as long as the default state is vulnerable, lots of people will keep being susceptible. The only thing that I can come up with is for Redis and Memcached to add \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eHost:\u003c/code\u003e as an alias to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eQUIT\u003c/code\u003e, so the connection is immediately aborted as soon as it is identified as being a HTTP request.\u003c/p\u003e\n\n\u003cp\u003eThe other place this could be fixed is in the browser. Browser vendors could implement a ‘DNS pinning’ of sorts, which makes it ignore DNS changes that are made after the site is done loading.\u003c/p\u003e\n\n\u003cp\u003eAlternatively browser vendors could add the Redis and Memcached ports to their \u003ca href=\"https://src.chromium.org/viewvc/chrome/trunk/src/net/base/net_util.cc?view=markup\" target=\"_blank\"\u003elist of blocked ports\u003c/a\u003e, which already contains common protocols like SMTP and IRC. This would be not a structural fix however, and new services could pop up that are vulnerable.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eEdit\u003c/strong\u003e – The Chromium developers are \u003ca href=\"https://bugs.chromium.org/p/chromium/issues/detail?id=600352\" target=\"_blank\"\u003eworking on\u003c/a\u003e removing HTTP/0.9 support, which will make the browser unable to read the response from Redis and Memcached. This is great progress, but still leaves the possibility for any page to execute commands.\u003c/p\u003e\n\n\u003ch2 id=\"building-on-this-attack\"\u003eBuilding on this attack\u003c/h2\u003e\n\u003cp\u003eFor some people it might not be a big deal to have data stolen from their development database, but read and write access could potentially lead to remote code execution. As an example, an attacker could overwrite anything that looks like Ruby marshalled or Python pickled data with their own payload, leading to a compromise of the developer’s computer.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis proof of concept shows why computer security is incredibly hard to get right. The attack depends on multiple software products all making very reasonable decisions about how they should work, but the way they interact with each other leads to a vulnerability.\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.jochentopf.com/hfpa/hfpa.pdf\" target=\"_blank\"\u003ePaper on cross-protocol scripting\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://crypto.stanford.edu/dns/dns-rebinding.pdf\" target=\"_blank\"\u003ePaper on DNS rebinding\u003c/a\u003e\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://benmmurphy.github.io/blog/2016/07/11/rails-webconsole-dns-rebinding/\" target=\"_blank\"\u003eBen Murphy’s blog on using DNS rebinding to own Rails\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eAug 2016\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2016-08-01T00:00:00Z",
  "Author": "bou.ke"
}