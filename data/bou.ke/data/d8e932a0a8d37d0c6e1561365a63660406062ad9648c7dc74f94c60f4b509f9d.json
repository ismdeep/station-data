{
  "Source": "bou.ke",
  "Title": "Yes, I use Nix",
  "Link": "https://bou.ke/blog/nix/",
  "Content": "\u003cdiv class=\"content\"\u003e\n\u003cdiv class=\"post\"\u003e\n  \u003ch1\u003eYes, I use Nix\u003c/h1\u003e\n  \u003cp\u003eI’ve been on the \u003ca href=\"https://nixos.org\" target=\"_blank\"\u003eNix\u003c/a\u003e train for about half a year now, and I have to say that it has completely changed how I look at my development setup. Before Nix, setting up my computer on the Mac was always a mess of Homebrew packages that I would install, being dependent on whatever’s available in the repository, and being forced to have everything installed globally. There’s also not a good way to keep track of what I have installed, there’s potential for conflicting packages, it’s just not great.\u003c/p\u003e\n\n\u003cp\u003eNix changed all of that. I could now version check my environment, I could try out a package in a subshell before installing it globally, I can even easily pin a package to a specific version using \u003ca href=\"https://nixos.wiki/wiki/Overlays\" target=\"_blank\"\u003eOverlays\u003c/a\u003e. Installing things is very fast in general because Nix has great caching, which it can download and install from without any compilation or linking.\u003c/p\u003e\n\n\u003ch2 id=\"but-what-is-it\"\u003eBut what is it?\u003c/h2\u003e\n\n\u003cp\u003eIt took me a while to understand Nix and all the different projects that are affiliated with it, but the gist of it is this:\u003c/p\u003e\n\n\u003col\u003e\n  \u003cli\u003eNix is a \u003cem\u003ebuild\u003c/em\u003e tool that is aware of all the dependencies (files, other things that have already been built) for a dependency. When something is built, it takes all the names of the dependencies, and all the files that are needed and hashes those together. That hash is then the name of the thing you just built (hold that thought) and put into the ‘Nix store’—this resides at \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/nix\u003c/code\u003e on your system.\u003c/li\u003e\n  \u003cli\u003eAll the Nix packages are set up to build in a way that they don’t reference anything outside of Nix. So when they build, then can only reference other Nix packages (for which that is also true etc. etc.) and files on the web by hash. So if you want to download the source code of something on the web, you need to put the sha hash of that thing in your Nix build instructions so it can ensure that the same thing is always used. The Nix build tool ensures that nothing outside the Nix store is used during build—by clearing out the environment variables for example.\u003c/li\u003e\n  \u003cli\u003eOnce you build something in this way, you can reference it by linking to it from outside the store. For example, I can setup a Vim config and a bunch of plugins and then I can link \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e~/.vimrc\u003c/code\u003e to the Vim config after it was built inside the store. This link is to some hashed name.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eThis clever set up makes sure that if I can build a package on my machine, you will \u003cem\u003ealways\u003c/em\u003e be able to build it on yours as well, because Nix makes sure that all the packages that need to be built are unable to be influenced by all the other mess on our computers. This is super cool!\u003c/p\u003e\n\n\u003ch2 id=\"fun-tricks\"\u003eFun tricks\u003c/h2\u003e\n\n\u003cp\u003eI put my whole environment on GitHub at \u003ca href=\"https://github.com/bouk/b\" target=\"_blank\"\u003ebouk/b\u003c/a\u003e which means I can check it out and install it very quickly. I can even install the same configuration on Mac and Linux, which is pretty mind-blowing! It just works.\u003c/p\u003e\n\n\u003cp\u003eYou can run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enix-shell https://bou.ke\u003c/code\u003e and get my whole environment in a subshell (note: it will take a while to build everything). I achieved that little trick by adding this to my \u003ca href=\"https://workers.cloudflare.com\" target=\"_blank\"\u003eCloudflare Workers\u003c/a\u003e config:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003econst ua = event.request.headers.get(\u0026#39;User-Agent\u0026#39;);\nif (url.pathname === \u0026#39;/\u0026#39; \u0026amp;\u0026amp; ua.match(/\\bNix\\//) != null) {\n  return new Response(\u0026#39;\u0026#39;, { status: 302, headers: { location: `https://github.com/bouk/b/archive/master.tar.gz` } });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eBecause it doesn’t matter what else is on your machine, Nix can safely build up my environment with the versions of software that \u003cstrong\u003eI\u003c/strong\u003e want and run it on your computer, without worrying about what’s already on there! So cool!\u003c/p\u003e\n\n\u003ch2 id=\"what-i-want-development-environments-to-be-like\"\u003eWhat I want development environments to be like\u003c/h2\u003e\n\n\u003cp\u003eI got onto this whole Nix path because of my former colleague \u003ca href=\"https://burke.libbey.me\" target=\"_blank\"\u003eBurke\u003c/a\u003e’s writing and YouTube series \u003ca href=\"https://shopify.engineering/what-is-nix\" target=\"_blank\"\u003eover at Shopify\u003c/a\u003e. Nix can really shine in development environments, where you have to share a bunch of dependencies (a compiler, database, etc.) between a large number of developers. Being able to use Nix to specify all the programs that you’re depending on means you don’t need to tell people to install a bunch of crap onto their machine and fight with stuff just to get it all working, just let them install Nix and use its magic to make everything work.\u003c/p\u003e\n\n\u003cp\u003eWhat I want is for \u003ca href=\"https://nixos.wiki/wiki/Flakes\" target=\"_blank\"\u003eNix Flakes\u003c/a\u003e to become a thing, so you also don’t need people to install stuff like direnv into their shell and have a daemon running like \u003ca href=\"https://github.com/target/lorri\" target=\"_blank\"\u003elorri\u003c/a\u003e just to have a decent workflow. No, what I want is to be able to write a bash script like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e#! /usr/bin/env nix \u0026lt;something flakes something\u0026gt;\npg_ctl start -D ./tmp/postgres start\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd have it run the exact same version of Postgres on everyone’s machines. Whenever this file is run, Nix should make sure that the locked dependencies are installed—if I understand correctly, then with Flakes this should be instant. Then it will run this script inside a shell that contains all the required things, so everyone can consistently share versions.\u003c/p\u003e\n\n\u003cp\u003eI’m not a Nix maximalist, I don’t think we need to have all of a projects dependencies in Nix. For example, I use \u003ca href=\"https://golang.org\" target=\"_blank\"\u003eGo\u003c/a\u003e a lot for projects and I’m not using some ‘Go module to Nix translation’ thing, because I can rely on Go’s package manager to do the right thing. I do want to use Nix to make sure that everyone is using the same Go version however. This strikes the right balance between developer experience and reliability, in my opinion.\u003c/p\u003e\n\n\u003cp\u003eLately I’ve also been railing against Docker for local development. It’s nuts that on Macbooks we are running a virtual machine to run containers to run databases, when this should just be a process on your computer. The only reason people are doing this is because there is a need to consistently install dependencies, Docker is the only hammer people think they have in their toolbox. With Nix we could just run it on everyone’s computer directly, without nested virtualization and killing people’s battery. It’s aesthetically gross to run a whole VM to run a single process. But we can do better!\u003c/p\u003e\n\n  \u003cp\u003e\u003cspan class=\"date\"\u003eNov 2020\u003c/span\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-11-01T00:00:00Z",
  "Author": "bou.ke"
}