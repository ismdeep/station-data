{
  "Source": "coolshell.cn",
  "Title": "理解Javascript的闭包",
  "Link": "https://coolshell.cn/articles/6731.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"25b503e195c4ce9b8e34f782-text/javascript\"\u003e\u003c/script\u003e【\u003cspan style=\"color: #cc0000\"\u003e感谢 Neo 投递本文 – 微博帐号：\u003ca title=\"_锟_\" href=\"http://weibo.com/gandalfthegrey\" target=\"_blank\"\u003e_锟_\u003c/a\u003e \u003c/span\u003e】\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e前言：还是一篇入门文章。\u003c/strong\u003eJavascript中有几个非常重要的语言特性——对象、原型继承、闭包。其中闭包对于那些使用传统静态语言C/C++的程序员来说是一个新的语言特性。本文将以例子入手来介绍Javascript闭包的语言特性，并结合一点ECMAScript语言规范来使读者可以更深入的理解闭包。\u003c/p\u003e\n\u003cp\u003e注：\u003cstrong\u003e本文是入门文章，例子素材整理于网络\u003cstrong\u003e，如果你是高手，欢迎针对文章提出技术性建议和意见。本文讨论的是Javascript，不想做语言对比，如果您对Javascript天生不适，请自行绕道。\u003c/strong\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85\" title=\"什么是闭包\"\u003e什么是闭包\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#ECMAScript%E9%97%AD%E5%8C%85%E6%A8%A1%E5%9E%8B\" title=\"ECMAScript闭包模型\"\u003eECMAScript闭包模型\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B7%E5%88%97\" title=\"闭包的样列\"\u003e闭包的样列\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8\" title=\"闭包的应用\"\u003e闭包的应用\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E9%97%AD%E5%8C%85\"\u003e\u003c/span\u003e\u003cstrong\u003e\u003cspan style=\"color: #008000\"\u003e什么是闭包\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e闭包是什么?闭包是Closure，这是静态语言所不具有的一个新特性。但是闭包也不是什么复杂到不可理解的东西，简而言之，闭包就是：\u003cstrong\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e当在一个函数内定义另外一个函数就会产生闭包\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上面的第二定义是第一个补充说明，抽取第一个定义的主谓宾——闭包是\u003cstrong\u003e函数的‘局部变量’集合\u003c/strong\u003e。只是这个局部变量是可以在函数返回后被访问。（这个不是官方定义，但是这个定义应该更有利于你理解闭包）\u003c/p\u003e\n\u003cp\u003e做为局部变量都可以被函数内的代码访问，这个和静态语言是没有差别。闭包的差别在于局部变变量可以在函数执行结束后仍然被函数外的代码访问。这意味着函数必须返回一个指向闭包的“引用”，或将这个”引用”赋值给某个外部变量，才能保证闭包中局部变量被外部代码访问。当然包含这个引用的实体应该是一个对象，因为在Javascript中除了基本类型剩下的就都是对象了。可惜的是，ECMAScript并没有提供相关的成员和方法来访问闭包中的局部变量。但是在ECMAScript中，函数对象中定义的\u003cstrong\u003e内部函数(inner function)\u003c/strong\u003e是可以直接访问外部函数的局部变量，通过这种机制，我们就可以以如下的方式完成对闭包的访问了。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-6731\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction greeting(name) {\u003cbr/\u003e\nvar text = ‘Hello ‘ + name; // local variable\u003cbr/\u003e\n// 每次调用时，产生闭包，并返回内部函数对象给调用者\u003cbr/\u003e\nreturn function() { alert(text); }\u003cbr/\u003e\n}\u003cbr/\u003e\nvar sayHello=greeting(\u0026#34;Closure\u0026#34;);\u003cbr/\u003e\nsayHello() // 通过闭包访问到了局部变量text\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003e上述代码的执行结果是：Hello Closure，因为sayHello()函数在greeting函数执行完毕后，仍然可以访问到了定义在其之内的局部变量text。\u003c/p\u003e\n\u003cp\u003e好了，这个就是传说中闭包的效果，闭包在Javascript中有多种应用场景和模式，比如Singleton，Power Constructor等这些Javascript模式都离不开对闭包的使用。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"ECMAScript%E9%97%AD%E5%8C%85%E6%A8%A1%E5%9E%8B\"\u003e\u003c/span\u003e\u003cstrong\u003e\u003cspan style=\"color: #008000\"\u003eECMAScript闭包模型\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eECMAScript到底是如何实现闭包的呢？想深入了解的亲们可以获取\u003ca href=\"http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\"\u003eECMAScript 规范\u003c/a\u003e进行研究，我这里也只做一个简单的讲解，内容也是来自于网络。\u003c/p\u003e\n\u003cp\u003e在ECMAscript的脚本的函数运行时，每个函数关联都有一个执行上下文场景(Execution Context) ，这个执行上下文场景中包含三个部分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e文法环境（The LexicalEnvironment）\u003c/li\u003e\n\u003cli\u003e变量环境（The VariableEnvironment）\u003c/li\u003e\n\u003cli\u003ethis绑定\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中第三点this绑定与闭包无关，不在本文中讨论。文法环境中用于解析函数执行过程使用到的变量标识符。我们可以将文法环境想象成一个对象，该对象包含了两个重要组件，环境记录(Enviroment Recode)，和外部引用(指针)。环境记录包含包含了函数内部声明的局部变量和参数变量，外部引用指向了外部函数对象的上下文执行场景。全局的上下文场景中此引用值为NULL。这样的数据结构就构成了一个单向的链表，每个引用都指向外层的上下文场景。\u003c/p\u003e\n\u003cp\u003e例如上面我们例子的闭包模型应该是这样，sayHello函数在最下层，上层是函数greeting，最外层是全局场景。如下图：\u003cbr/\u003e\n\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-6741\" src=\"https://coolshell.cn/wp-content/uploads/2012/03/closure.png\" alt=\"\" width=\"658\" height=\"478\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/03/closure.png 658w, https://coolshell.cn/wp-content/uploads/2012/03/closure-300x218.png 300w, https://coolshell.cn/wp-content/uploads/2012/03/closure-372x270.png 372w\" sizes=\"(max-width: 658px) 100vw, 658px\"/\u003e\u003cbr/\u003e\n因此当sayHello被调用的时候，sayHello会通过上下文场景找到局部变量text的值，因此在屏幕的对话框中显示出”Hello Closure”\u003cbr/\u003e\n变量环境(The VariableEnvironment)和文法环境的作用基本相似，具体的区别请参看ECMAScript的规范文档。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AD%E5%8C%85%E7%9A%84%E6%A0%B7%E5%88%97\"\u003e\u003c/span\u003e\u003cstrong\u003e\u003cspan style=\"color: #008000\"\u003e闭包的样列\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e前面的我大致了解了Javascript闭包是什么，闭包在Javascript是怎么实现的。下面我们通过针对一些例子来帮助大家更加深入的理解闭包，下面共有5个样例，例子来自于\u003ca href=\"http://blog.morrisjohns.com/javascript_closures_for_dummies.html\"\u003eJavaScript Closures For Dummies(\u003c/a\u003e\u003ca href=\"http://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies\"\u003e镜像\u003c/a\u003e\u003ca href=\"http://blog.morrisjohns.com/javascript_closures_for_dummies.html\"\u003e)\u003c/a\u003e。\u003cbr/\u003e\n\u003cstrong\u003e例子1:闭包中局部变量是引用而非拷贝\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction say667() {\u003cbr/\u003e\n// Local variable that ends up within closure\u003cbr/\u003e\nvar num = 666;\u003cbr/\u003e\nvar sayAlert = function() { alert(num); }\u003cbr/\u003e\nnum++;\u003cbr/\u003e\nreturn sayAlert;\u003cbr/\u003e\n}\u003c/p\u003e\n\u003cp\u003evar sayAlert = say667();\u003cbr/\u003e\nsayAlert()\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003e因此执行结果应该弹出的667而非666。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例子2：多个函数绑定同一个闭包，因为他们定义在同一个函数内。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction setupSomeGlobals() {\u003cbr/\u003e\n// Local variable that ends up within closure\u003cbr/\u003e\nvar num = 666;\u003cbr/\u003e\n// Store some references to functions as global variables\u003cbr/\u003e\ngAlertNumber = function() { alert(num); }\u003cbr/\u003e\ngIncreaseNumber = function() { num++; }\u003cbr/\u003e\ngSetNumber = function(x) { num = x; }\u003cbr/\u003e\n}\u003cbr/\u003e\nsetupSomeGlobals(); // 为三个全局变量赋值\u003cbr/\u003e\ngAlertNumber(); //666\u003cbr/\u003e\ngIncreaseNumber();\u003cbr/\u003e\ngAlertNumber(); // 667\u003cbr/\u003e\ngSetNumber(12);//\u003cbr/\u003e\ngAlertNumber();//12\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例子3：当在一个循环中赋值函数时，这些函数将绑定同样的闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction buildList(list) {\u003cbr/\u003e\nvar result = [];\u003cbr/\u003e\nfor (var i = 0; i \u0026lt; list.length; i++) {\u003cbr/\u003e\nvar item = ‘item’ + list[i];\u003cbr/\u003e\nresult.push( function() {alert(item + ‘ ‘ + list[i])} );\u003cbr/\u003e\n}\u003cbr/\u003e\nreturn result;\u003cbr/\u003e\n}\u003c/p\u003e\n\u003cp\u003efunction testList() {\u003cbr/\u003e\nvar fnlist = buildList([1,2,3]);\u003cbr/\u003e\n// using j only to help prevent confusion – could use i\u003cbr/\u003e\nfor (var j = 0; j \u0026lt; fnlist.length; j++) {\u003cbr/\u003e\nfnlist[j]();\u003cbr/\u003e\n}\u003cbr/\u003e\n}\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003etestList的执行结果是弹出item3 undefined窗口三次，因为这三个函数绑定了同一个闭包，而且item的值为最后计算的结果，但是当i跳出循环时i值为4，所以list[4]的结果为undefined.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例子4：外部函数所有局部变量都在闭包内，即使这个变量声明在内部函数定义之后。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction sayAlice() {\u003cbr/\u003e\nvar sayAlert = function() { alert(alice); }\u003cbr/\u003e\n// Local variable that ends up within closure\u003cbr/\u003e\nvar alice = ‘Hello Alice’;\u003cbr/\u003e\nreturn sayAlert;\u003cbr/\u003e\n}\u003cbr/\u003e\nvar helloAlice=sayAlice();\u003cbr/\u003e\nhelloAlice();\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003e执行结果是弹出”Hello Alice”的窗口。即使局部变量声明在函数sayAlert之后，局部变量仍然可以被访问到。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例子5：每次函数调用的时候创建一个新的闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nfunction newClosure(someNum, someRef) {\u003cbr/\u003e\n// Local variables that end up within closure\u003cbr/\u003e\nvar num = someNum;\u003cbr/\u003e\nvar anArray = [1,2,3];\u003cbr/\u003e\nvar ref = someRef;\u003cbr/\u003e\nreturn function(x) {\u003cbr/\u003e\nnum += x;\u003cbr/\u003e\nanArray.push(num);\u003cbr/\u003e\nalert(‘num: ‘ + num +\u003cbr/\u003e\n‘\\nanArray ‘ + anArray.toString() +\u003cbr/\u003e\n‘\\nref.someVar ‘ + ref.someVar);\u003cbr/\u003e\n}\u003cbr/\u003e\n}\u003cbr/\u003e\nclosure1=newClosure(40,{someVar:’closure 1′});\u003cbr/\u003e\nclosure2=newClosure(1000,{someVar:’closure 2′});\u003c/p\u003e\n\u003cp\u003eclosure1(5); // num:45 anArray[1,2,3,45] ref:’someVar closure1′\u003cbr/\u003e\nclosure2(-10);// num:990 anArray[1,2,3,990] ref:’someVar closure2’\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AD%E5%8C%85%E7%9A%84%E5%BA%94%E7%94%A8\"\u003e\u003c/span\u003e\u003cstrong\u003e\u003cspan style=\"color: #008000\"\u003e闭包的应用\u003c/span\u003e\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eSingleton 单件：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e[javascript]\u003cbr/\u003e\nvar singleton = function () {\u003cbr/\u003e\nvar privateVariable;\u003cbr/\u003e\nfunction privateFunction(x) {\u003cbr/\u003e\n…privateVariable…\u003cbr/\u003e\n}\u003c/p\u003e\n\u003cp\u003e return {\u003cbr/\u003e\nfirstMethod: function (a, b) {\u003cbr/\u003e\n…privateVariable…\u003cbr/\u003e\n},\u003cbr/\u003e\nsecondMethod: function (c) {\u003cbr/\u003e\n…privateFunction()…\u003cbr/\u003e\n}\u003cbr/\u003e\n};\u003cbr/\u003e\n}();\u003cbr/\u003e\n[/javascript]\u003c/p\u003e\n\u003cp\u003e这个单件通过闭包来实现。通过闭包完成了私有的成员和方法的封装。匿名主函数返回一个对象。对象包含了两个方法，方法1可以方法私有变量，方法2访问内部私有函数。需要注意的地方是匿名主函数结束的地方的\u0026#39;()’，如果没有这个\u0026#39;()’就不能产生单件。因为匿名函数只能返回了唯一的对象，而且不能被其他地方调用。这个就是利用闭包产生单件的方法。\u003c/p\u003e\n\u003ch2\u003e\u003cstrong\u003e\u003cspan style=\"color: #008000\"\u003e参考：\u003c/span\u003e\u003c/strong\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://blog.morrisjohns.com/javascript_closures_for_dummies.html\"\u003eJavaScript Closures For Dummies(\u003c/a\u003e\u003ca href=\"http://web.archive.org/web/20080209105120/http://blog.morrisjohns.com/javascript_closures_for_dummies\"\u003e镜像\u003c/a\u003e\u003ca href=\"http://blog.morrisjohns.com/javascript_closures_for_dummies.html\"\u003e)\u003c/a\u003e 可惜都被墙了。\u003cbr/\u003e\n\u003ca href=\"http://yuiblog.com/blog/2006/11/27/video-crockford-advjs/\"\u003eAdvance Javascript\u003c/a\u003e （Douglas Crockford 大神的视频，一定要看啊）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6668.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/02/joo_1-150x150.png\" alt=\"再谈javascript面向对象编程 \" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6668.html\" class=\"wp_rp_title\"\u003e再谈javascript面向对象编程 \u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6441.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/18.jpg\" alt=\"Javascript 面向对象编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6441.html\" class=\"wp_rp_title\"\u003eJavascript 面向对象编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/5202.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg\" alt=\"对象的消息模型\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/5202.html\" class=\"wp_rp_title\"\u003e对象的消息模型\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17634.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/01/pretty-code-150x150.gif\" alt=\"Chrome开发者工具的小技巧\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17634.html\" class=\"wp_rp_title\"\u003eChrome开发者工具的小技巧\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17524.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2016/10/drawing-recursive-150x150.jpg\" alt=\"如何读懂并写出装逼的函数式代码\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17524.html\" class=\"wp_rp_title\"\u003e如何读懂并写出装逼的函数式代码\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-6731\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"213ee33d7d\"\u003e\u003cimg id=\"rating_6731_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(6731, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-25b503e195c4ce9b8e34f782-=\"\"/\u003e\u003cimg id=\"rating_6731_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(6731, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-25b503e195c4ce9b8e34f782-=\"\"/\u003e\u003cimg id=\"rating_6731_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(6731, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-25b503e195c4ce9b8e34f782-=\"\"/\u003e\u003cimg id=\"rating_6731_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(6731, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-25b503e195c4ce9b8e34f782-=\"\"/\u003e\u003cimg id=\"rating_6731_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(6731, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-25b503e195c4ce9b8e34f782-=\"\"/\u003e (\u003cstrong\u003e19\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.16\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_6731_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"理解Javascript的闭包\"/\u003e\u003cmeta itemprop=\"headline\" content=\"理解Javascript的闭包\"/\u003e\u003cmeta itemprop=\"description\" content=\"【感谢 Neo 投递本文 - 微博帐号：_锟_ 】\n\n前言：还是一篇入门文章。Javascript中有几个非常重要的语言特性——对象、原型继承、闭包。其中闭包对于那些使用传统静态语言C/C++的程序员来说是一个新的语言特性。本文将以例子入手来介绍Javascript闭包的语言特性，并结合一点ECMAScript语言规范来使读者可以更深入的理解闭包。\n\n注：本文是入门文章，例子素材整理于网络...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-03-07T08:30:43+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2012-03-07T22:13:14+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/6731.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"Neo\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/6731.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.16\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"19\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-6731-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-03-07T08:30:43+08:00",
  "Author": "Neo"
}