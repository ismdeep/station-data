{
  "Source": "coolshell.cn",
  "Title": "Go编程模式：修饰器",
  "Link": "https://coolshell.cn/articles/17929.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"f77ba65bb99f0c8f528ebbdc-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-full wp-image-17945\" src=\"https://coolshell.cn/wp-content/uploads/2017/06/go-hardhat.png\" alt=\"\" width=\"200\" height=\"193\"/\u003e之前写过一篇《\u003ca href=\"https://coolshell.cn/articles/11265.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePython修饰器的函数式编程\u003c/a\u003e》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第7 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式：修饰器\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21179.html\" rel=\"prev\" title=\"Go 编程模式：Go Generation\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" rel=\"next\" title=\"Go编程模式：Pipeline\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cp\u003e看过\u003ca href=\"https://coolshell.cn/articles/11265.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePython修饰器\u003c/a\u003e那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高阶函数来包装一下。多唠叨一句，关于函数式编程，可以参看我之前写过一篇文章《\u003ca href=\"https://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e函数式编程\u003c/a\u003e》，这篇文章主要是，想通过从过程式编程的思维方式过渡到函数式编程的思维方式，从而带动更多的人玩函数式编程，所以，如果你想了解一下函数式编程，那么可以移步先阅读一下。所以，Go语言的修饰器编程模式，其实也就是函数式编程的模式。\u003c/p\u003e\n\u003cp\u003e不过，要提醒注意的是，Go 语言的“糖”不多，而且又是强类型的静态无虚拟机的语言，所以，无法做到像 Java 和 Python 那样的优雅的修饰器的代码。当然，也许是我才才疏学浅，如果你知道有更多的写法，请你一定告诉我。先谢过了。\u003cbr/\u003e\n\u003cspan id=\"more-17929\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\" title=\"简单示例\"\u003e简单示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#HTTP_%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B\" title=\"HTTP 相关的一个示例\"\u003eHTTP 相关的一个示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%A4%9A%E4%B8%AA%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84_Pipeline\" title=\"多个修饰器的 Pipeline\"\u003e多个修饰器的 Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8\" title=\"泛型的修饰器\"\u003e泛型的修饰器\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e简单示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们先来看一个示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc decorator(f func(s string)) func(s string) {\n\n    return func(s string) {\n        fmt.Println(\u0026#34;Started\u0026#34;)\n        f(s)\n        fmt.Println(\u0026#34;Done\u0026#34;)\n    }\n}\n\nfunc Hello(s string) {\n    fmt.Println(s)\n}\n\nfunc main() {\n        decorator(Hello)(\u0026#34;Hello, World!\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，我们动用了一个高阶函数 \u003ccode\u003edecorator()\u003c/code\u003e，在调用的时候，先把 \u003ccode\u003eHello()\u003c/code\u003e 函数传进去，然后其返回一个匿名函数，这个匿名函数中除了运行了自己的代码，也调用了被传入的 \u003ccode\u003eHello()\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cp\u003e这个玩法和 Python 的异曲同工，只不过，有些遗憾的是，Go 并不支持像 Python 那样的 \u003ccode\u003e@decorator\u003c/code\u003e 语法糖。所以，在调用上有些难看。当然，如果你要想让代码容易读一些，你可以这样：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ehello := decorator(Hello)\nhello(\u0026#34;Hello\u0026#34;)\u003c/pre\u003e\n\u003cp\u003e我们再来看一个和计算运行时间的例子：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"16-26\"\u003epackage main\n\nimport (\n  \u0026#34;fmt\u0026#34;\n  \u0026#34;reflect\u0026#34;\n  \u0026#34;runtime\u0026#34;\n  \u0026#34;time\u0026#34;\n)\n\ntype SumFunc func(int64, int64) int64\n\nfunc getFunctionName(i interface{}) string {\n  return runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n\nfunc timedSumFunc(f SumFunc) SumFunc {\n  return func(start, end int64) int64 {\n\n    defer func(t time.Time) {\n      fmt.Printf(\u0026#34;--- Time Elapsed (%s): %v ---\\n\u0026#34;, \n          getFunctionName(f), time.Since(t))\n    }(time.Now())\n\n    return f(start, end)\n  }\n}\n\nfunc Sum1(start, end int64) int64 {\n  var sum int64\n  sum = 0\n  if start \u0026gt; end {\n    start, end = end, start\n  }\n  for i := start; i \u0026lt;= end; i++ {\n    sum += i\n  }\n  return sum\n}\n\nfunc Sum2(start, end int64) int64 {\n  if start \u0026gt; end {\n    start, end = end, start\n  }\n  return (end - start + 1) * (end + start) / 2\n}\n\nfunc main() {\n\n  sum1 := timedSumFunc(Sum1)\n  sum2 := timedSumFunc(Sum2)\n\n  fmt.Printf(\u0026#34;%d, %d\\n\u0026#34;, sum1(-10000, 10000000), sum2(-10000, 10000000))\n}\u003c/pre\u003e\n\u003cp\u003e关于上面的代码，有几个事说明一下：\u003c/p\u003e\n\u003cp\u003e1）有两个 Sum 函数，\u003ccode\u003eSum1()\u003c/code\u003e 函数就是简单的做个循环，\u003ccode\u003eSum2()\u003c/code\u003e 函数动用了数据公式。（注意：start 和 end 有可能有负数的情况）\u003c/p\u003e\n\u003cp\u003e2）代码中使用了 Go 语言的反射机器来获取函数名。\u003c/p\u003e\n\u003cp\u003e3）修饰器函数是 \u003ccode\u003etimedSumFunc()\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e运行后输出：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$ go run time.sum.go\n--- Time Elapsed (main.Sum1): 3.557469ms ---\n--- Time Elapsed (main.Sum2): 291ns ---\n49999954995000, 49999954995000\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"HTTP_%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003eHTTP 相关的一个示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们再来看一个处理 HTTP 请求的相关的例子。\u003c/p\u003e\n\u003cp\u003e先看一个简单的 HTTP Server 的代码。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"10-16,24\"\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;net/http\u0026#34;\n    \u0026#34;strings\u0026#34;\n)\n\nfunc WithServerHeader(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\u0026#34;---\u0026gt;WithServerHeader()\u0026#34;)\n        w.Header().Set(\u0026#34;Server\u0026#34;, \u0026#34;HelloServer v0.0.1\u0026#34;)\n        h(w, r)\n    }\n}\n\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    log.Printf(\u0026#34;Recieved Request %s from %s\\n\u0026#34;, r.URL.Path, r.RemoteAddr)\n    fmt.Fprintf(w, \u0026#34;Hello, World! \u0026#34;+r.URL.Path)\n}\n\nfunc main() {\n    http.HandleFunc(\u0026#34;/v1/hello\u0026#34;, WithServerHeader(hello))\n    err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)\n    if err != nil {\n        log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err)\n    }\n}\u003c/pre\u003e\n\u003cp\u003e上面代码中使用到了修饰模式，\u003ccode\u003eWithServerHeader()\u003c/code\u003e 函数就是一个 Decorator，其传入一个 \u003ccode\u003ehttp.HandlerFunc\u003c/code\u003e，然后返回一个改写的版本。上面的例子还是比较简单，用 \u003ccode\u003eWithServerHeader()\u003c/code\u003e 就可以加入一个 Response 的 Header。\u003c/p\u003e\n\u003cp\u003e于是，这样的函数我们可以写出好些个。如下所示，有写 HTTP 响应头的，有写认证 Cookie 的，有检查认证Cookie的，有打日志的……\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"60-62\"\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;net/http\u0026#34;\n    \u0026#34;strings\u0026#34;\n)\n\nfunc WithServerHeader(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\u0026#34;---\u0026gt;WithServerHeader()\u0026#34;)\n        w.Header().Set(\u0026#34;Server\u0026#34;, \u0026#34;HelloServer v0.0.1\u0026#34;)\n        h(w, r)\n    }\n}\n\nfunc WithAuthCookie(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\u0026#34;---\u0026gt;WithAuthCookie()\u0026#34;)\n        cookie := \u0026amp;http.Cookie{Name: \u0026#34;Auth\u0026#34;, Value: \u0026#34;Pass\u0026#34;, Path: \u0026#34;/\u0026#34;}\n        http.SetCookie(w, cookie)\n        h(w, r)\n    }\n}\n\nfunc WithBasicAuth(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\u0026#34;---\u0026gt;WithBasicAuth()\u0026#34;)\n        cookie, err := r.Cookie(\u0026#34;Auth\u0026#34;)\n        if err != nil || cookie.Value != \u0026#34;Pass\u0026#34; {\n            w.WriteHeader(http.StatusForbidden)\n            return\n        }\n        h(w, r)\n    }\n}\n\nfunc WithDebugLog(h http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Println(\u0026#34;---\u0026gt;WithDebugLog\u0026#34;)\n        r.ParseForm()\n        log.Println(r.Form)\n        log.Println(\u0026#34;path\u0026#34;, r.URL.Path)\n        log.Println(\u0026#34;scheme\u0026#34;, r.URL.Scheme)\n        log.Println(r.Form[\u0026#34;url_long\u0026#34;])\n        for k, v := range r.Form {\n            log.Println(\u0026#34;key:\u0026#34;, k)\n            log.Println(\u0026#34;val:\u0026#34;, strings.Join(v, \u0026#34;\u0026#34;))\n        }\n        h(w, r)\n    }\n}\nfunc hello(w http.ResponseWriter, r *http.Request) {\n    log.Printf(\u0026#34;Recieved Request %s from %s\\n\u0026#34;, r.URL.Path, r.RemoteAddr)\n    fmt.Fprintf(w, \u0026#34;Hello, World! \u0026#34;+r.URL.Path)\n}\n\nfunc main() {\n    http.HandleFunc(\u0026#34;/v1/hello\u0026#34;, WithServerHeader(WithAuthCookie(hello)))\n    http.HandleFunc(\u0026#34;/v2/hello\u0026#34;, WithServerHeader(WithBasicAuth(hello)))\n    http.HandleFunc(\u0026#34;/v3/hello\u0026#34;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))\n    err := http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)\n    if err != nil {\n        log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err)\n    }\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%A4%9A%E4%B8%AA%E4%BF%AE%E9%A5%B0%E5%99%A8%E7%9A%84_Pipeline\"\u003e\u003c/span\u003e多个修饰器的 Pipeline\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在使用上，需要对函数一层层的套起来，看上去好像不是很好看，如果需要 decorator 比较多的话，代码会比较难看了。嗯，我们可以重构一下。\u003c/p\u003e\n\u003cp\u003e重构时，我们需要先写一个工具函数——用来遍历并调用各个 decorator：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc\n\nfunc Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {\n    for i := range decors {\n        d := decors[len(decors)-1-i] // iterate in reverse\n        h = d(h)\n    }\n    return h\n}\u003c/pre\u003e\n\u003cp\u003e然后，我们就可以像下面这样使用了。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ehttp.HandleFunc(\u0026#34;/v4/hello\u0026#34;, Handler(hello,\n                WithServerHeader, WithBasicAuth, WithDebugLog))\u003c/pre\u003e\n\u003cp\u003e这样的代码是不是更易读了一些？pipeline 的功能也就出来了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8\"\u003e\u003c/span\u003e泛型的修饰器\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e不过，对于 Go 的修饰器模式，还有一个小问题 —— 好像无法做到泛型，就像上面那个计算时间的函数一样，其代码耦合了需要被修饰的函数的接口类型，无法做到非常通用，如果这个事解决不了，那么，这个修饰器模式还是有点不好用的。\u003c/p\u003e\n\u003cp\u003e因为 Go 语言不像 Python 和 Java，Python是动态语言，而 Java 有语言虚拟机，所以他们可以干好些比较变态的事，然而 Go 语言是一个静态的语言，这意味着其类型需要在编译时就要搞定，否则无法编译。不过，Go 语言支持的最大的泛型是 \u003ccode\u003einterface{}\u003c/code\u003e 还有比较简单的 reflection 机制，在上面做做文章，应该还是可以搞定的。\u003c/p\u003e\n\u003cp\u003e废话不说，下面是我用 reflection 机制写的一个比较通用的修饰器（为了便于阅读，我删除了出错判断代码）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"7,10\"\u003efunc Decorator(decoPtr, fn interface{}) (err error) {\n    var decoratedFunc, targetFunc reflect.Value\n\n    decoratedFunc = reflect.ValueOf(decoPtr).Elem()\n    targetFunc = reflect.ValueOf(fn)\n\n    v := reflect.MakeFunc(targetFunc.Type(),\n            func(in []reflect.Value) (out []reflect.Value) {\n                fmt.Println(\u0026#34;before\u0026#34;)\n                out = targetFunc.Call(in)\n                fmt.Println(\u0026#34;after\u0026#34;)\n                return\n            })\n\n    decoratedFunc.Set(v)\n    return\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码动用了 \u003ccode\u003ereflect.MakeFunc()\u003c/code\u003e 函数制出了一个新的函数其中的 \u003ccode\u003etargetFunc.Call(in)\u003c/code\u003e 调用了被修饰的函数。关于 Go 语言的反射机制，推荐官方文章 —— 《\u003ca href=\"https://blog.golang.org/laws-of-reflection\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eThe Laws of Reflection\u003c/a\u003e》，在这里我不多说了。\u003c/p\u003e\n\u003cp\u003e上面这个 \u003ccode\u003eDecorator()\u003c/code\u003e 需要两个参数，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一个是出参 \u003ccode\u003edecoPtr\u003c/code\u003e ，就是完成修饰后的函数\u003c/li\u003e\n\u003cli\u003e第二个是入参 \u003ccode\u003efn\u003c/code\u003e ，就是需要修饰的函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样写是不是有些二？的确是的。不过，这是我个人在 Go 语言里所能写出来的最好的的代码了。如果你知道更多优雅的，请你一定告诉我！\u003c/p\u003e\n\u003cp\u003e好的，让我们来看一下使用效果。首先假设我们有两个需要修饰的函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc foo(a, b, c int) int {\n    fmt.Printf(\u0026#34;%d, %d, %d \\n\u0026#34;, a, b, c)\n    return a + b + c\n}\n\nfunc bar(a, b string) string {\n    fmt.Printf(\u0026#34;%s, %s \\n\u0026#34;, a, b)\n    return a + b\n}\u003c/pre\u003e\n\u003cp\u003e然后，我们可以这样做：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype MyFoo func(int, int, int) int\nvar myfoo MyFoo\nDecorator(\u0026amp;myfoo, foo)\nmyfoo(1, 2, 3)\n\u003c/pre\u003e\n\u003cp\u003e你会发现，使用 \u003ccode\u003eDecorator()\u003c/code\u003e 时，还需要先声明一个函数签名，感觉好傻啊。一点都不泛型，不是吗？\u003c/p\u003e\n\u003cp\u003e嗯。如果你不想声明函数签名，那么你也可以这样\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003emybar := bar\nDecorator(\u0026amp;mybar, bar)\nmybar(\u0026#34;hello,\u0026#34;, \u0026#34;world!\u0026#34;)\u003c/pre\u003e\n\u003cp\u003e好吧，看上去不是那么的漂亮，但是 it works。看样子 Go 语言目前本身的特性无法做成像 Java 或 Python 那样，对此，我们只能多求 Go 语言多放糖了！\u003c/p\u003e\n\u003cp\u003eAgain， 如果你有更好的写法，请你一定要告诉我。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11265.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960-150x150.jpg\" alt=\"Python修饰器的函数式编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11265.html\" class=\"wp_rp_title\"\u003ePython修饰器的函数式编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-17929\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"c8c4c921da\"\u003e\u003cimg id=\"rating_17929_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17929, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f77ba65bb99f0c8f528ebbdc-=\"\"/\u003e\u003cimg id=\"rating_17929_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17929, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f77ba65bb99f0c8f528ebbdc-=\"\"/\u003e\u003cimg id=\"rating_17929_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17929, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f77ba65bb99f0c8f528ebbdc-=\"\"/\u003e\u003cimg id=\"rating_17929_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17929, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f77ba65bb99f0c8f528ebbdc-=\"\"/\u003e\u003cimg id=\"rating_17929_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17929, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f77ba65bb99f0c8f528ebbdc-=\"\"/\u003e (\u003cstrong\u003e53\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.06\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_17929_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式：修饰器\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式：修饰器\"/\u003e\u003cmeta itemprop=\"description\" content=\"之前写过一篇《Python修饰器的函数式编程》，这种模式很容易的可以把一些函数装配到另外一些函数上，可以让你的代码更为的简单，也可以让一些“小功能型”的代码复用性更高，让代码中的函数可以像乐高玩具那样自由地拼装。所以，一直以来，我对修饰器decoration这种编程模式情有独钟，这里写一篇Go语言相关的文章。\n\n\n\n看过Python修饰器那篇文章的同学，一定知道这是一种函数式编程的玩法——用一个高...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2017-06-01T16:48:15+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-26T16:20:49+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/17929.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/17929.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.06\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"53\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-17929-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2017-06-01T16:48:15+08:00",
  "Author": "陈皓"
}