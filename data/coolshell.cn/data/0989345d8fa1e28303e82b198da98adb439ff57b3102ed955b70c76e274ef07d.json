{
  "Source": "coolshell.cn",
  "Title": "eBPF 介绍",
  "Link": "https://coolshell.cn/articles/22320.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"1059f687e264fc84cb9a65e5-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright wp-image-22329 size-full\" src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.jpeg\" alt=\"\" width=\"301\" height=\"167\"/\u003e很早前就想写一篇关于eBPF的文章，但是迟迟没有动手，这两天有点时间，所以就来写一篇，这文章主要还是简单的介绍eBPF 是用来干什么的，并通过几个示例来介绍是怎么玩的，这个技术非常非常之强，Linux 操作系统的观测性实在是太强大了，并在 BCC 加持下变得一览无余。这个技术不是一般的运维人员或是系统管理员可以驾驭的，这个还是要有底层系统知识并有一定开发能力的技术人员才能驾驭的了的。\u003cstrong\u003e我在这篇文章的最后给了个彩蛋。\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E4%BB%8B%E7%BB%8D\" title=\"介绍\"\u003e介绍\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E7%94%A8%E9%80%94\" title=\"用途\"\u003e用途\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" title=\"工作原理\"\u003e工作原理\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E7%A4%BA%E4%BE%8B\" title=\"示例\"\u003e示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB\" title=\"延伸阅读\"\u003e延伸阅读\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E5%BD%A9%E8%9B%8B\" title=\"彩蛋\"\u003e彩蛋\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BB%8B%E7%BB%8D\"\u003e\u003c/span\u003e介绍\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eeBPF（extened Berkeley Packet Filter）是一种内核技术，它允许开发人员在不修改内核代码的情况下运行特定的功能。eBPF 的概念源自于 Berkeley Packet Filter（BPF），后者是由贝尔实验室开发的一种网络过滤器，可以捕获和过滤网络数据包。\u003c/p\u003e\n\u003cp\u003e出于对更好的 Linux 跟踪工具的需求，eBPF 从 \u003ca href=\"https://illumos.org/books/dtrace/chp-intro.html\"\u003edtrace\u003c/a\u003e中汲取灵感，dtrace 是一种主要用于 Solaris 和 BSD 操作系统的动态跟踪工具。与 dtrace 不同，Linux 无法全面了解正在运行的系统，因为它仅限于系统调用、库调用和函数的特定框架。\u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/index.html\"\u003e在Berkeley Packet Filter\u003c/a\u003e  (BPF)（一种使用内核 VM 编写打包过滤代码的工具）的基础上，一小群工程师开始扩展 BPF 后端以提供与 dtrace 类似的功能集。 eBPF 诞生了。\u003cstrong\u003e2014 年随 Linux 3.18 首次限量发布，充分利用 eBPF 至少需要 Linux 4.4 以上版本\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-22320\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003eeBPF 比起传统的 BPF 来说，传统的 BPF 只能用于网络过滤，而 eBPF 则可以用于更多的应用场景，包括网络监控、安全过滤和性能分析等。另外，eBPF 允许常规用户空间应用程序将要在 Linux 内核中执行的逻辑打包为字节码，当某些事件（称为挂钩）发生时，内核会调用 eBPF 程序。此类挂钩的示例包括系统调用、网络事件等。用于编写和调试 eBPF 程序的最流行的工具链称为 \u003ca href=\"https://github.com/iovisor/bcc\"\u003eBPF 编译器集合\u003c/a\u003e (BCC)，它基于 LLVM 和 CLang。\u003c/p\u003e\n\u003cp\u003eeBPF 有一些类似的工具。例如，SystemTap 是一种开源工具，可以帮助用户收集 Linux 内核的运行时数据。它通过动态加载内核模块来实现这一功能，类似于 eBPF。另外，DTrace 是一种动态跟踪和分析工具，可以用于收集系统的运行时数据，类似于 eBPF 和 SystemTap。\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e以下是一个简单的比较表格，可以帮助您更好地了解 eBPF、SystemTap 和 DTrace 这三种工具的不同之处：\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e工具\u003c/th\u003e\n\u003cth\u003eeBPF\u003c/th\u003e\n\u003cth\u003eSystemTap\u003c/th\u003e\n\u003cth\u003eDTrace\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e定位\u003c/td\u003e\n\u003ctd\u003e内核技术，可用于多种应用场景\u003c/td\u003e\n\u003ctd\u003e内核模块\u003c/td\u003e\n\u003ctd\u003e动态跟踪和分析工具\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e工作原理\u003c/td\u003e\n\u003ctd\u003e动态加载和执行无损编译过的代码\u003c/td\u003e\n\u003ctd\u003e动态加载内核模块\u003c/td\u003e\n\u003ctd\u003e动态插接分析器，通过 probe 获取数据并进行分析\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e常见用途\u003c/td\u003e\n\u003ctd\u003e网络监控、安全过滤、性能分析等\u003c/td\u003e\n\u003ctd\u003e系统性能分析、故障诊断等\u003c/td\u003e\n\u003ctd\u003e系统性能分析、故障诊断等\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e优点\u003c/td\u003e\n\u003ctd\u003e灵活、安全、可用于多种应用场景\u003c/td\u003e\n\u003ctd\u003e功能强大、可视化界面\u003c/td\u003e\n\u003ctd\u003e功能强大、高性能、支持多种编程语言\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e缺点\u003c/td\u003e\n\u003ctd\u003e学习曲线高，安全性依赖于编译器的正确性\u003c/td\u003e\n\u003ctd\u003e学习曲线高，安全性依赖于内核模块的正确性\u003c/td\u003e\n\u003ctd\u003e配置复杂，对系统性能影响较大\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp style=\"text-align: center;\"\u003e对比表格\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e从上表可以看出，eBPF、SystemTap 和 DTrace 都是非常强大的工具，可以用于收集和分析系统的运行情况。\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%94%A8%E9%80%94\"\u003e\u003c/span\u003e用途\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eeBPF 是一种非常灵活和强大的内核技术，可以用于多种应用场景。下面是 eBPF 的一些常见用途：\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e网络监控：eBPF 可以用于捕获网络数据包，并执行特定的逻辑来分析网络流量。例如，可以使用 eBPF 程序来监控网络流量，并在发现异常流量时进行警报。\u003ccode\u003e[1]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e安全过滤：eBPF 可以用于对网络数据包进行安全过滤。例如，可以使用 eBPF 程序来阻止恶意流量的传播，或者在发现恶意流量时对其进行拦截。\u003ccode\u003e[1]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e性能分析：eBPF 可以用于对内核的性能进行分析。例如，可以使用 eBPF 程序来收集内核的性能指标，并通过特定的接口将其可视化。这样，可以更好地了解内核的性能瓶颈，并进行优化。\u003ccode\u003e[1]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e虚拟化：eBPF 可以用于虚拟化技术。例如，可以使用 eBPF 程序来收集虚拟机的性能指标，并进行负载均衡。这样，可以更好地利用虚拟化环境的资源，提高系统的性能和稳定性。\u003ccode\u003e[1]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总之，eBPF 的常见用途非常广泛，可以用于网络监控、安全过滤、性能分析和虚拟化等多种应用场景。\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"\u003e\u003c/span\u003e工作原理\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eeBPF 的工作原理主要分为三个步骤：加载、编译和执行。\u003c/p\u003e\n\u003cp\u003eeBPF 需要在内核中运行。这通常是由用户态的应用程序完成的，它会通过系统调用来加载 eBPF 程序。在加载过程中，内核会将 eBPF 程序的代码复制到内核空间。\u003c/p\u003e\n\u003cp\u003eeBPF 程序需要经过编译和执行。这通常是由Clang/LLVM的编译器完成，然后形成字节码后，将用户态的字节码装载进内核，Verifier会对要注入内核的程序进行一些内核安全机制的检查,这是为了确保 eBPF 程序不会破坏内核的稳定性和安全性。在检查过程中，内核会对 eBPF 程序的代码进行分析，以确保它不会进行恶意操作，如系统调用、内存访问等。如果 eBPF 程序通过了内核安全机制的检查，它就可以在内核中正常运行了，其会通过通过一个JIT编译步骤将程序的通用字节码转换为机器特定指令集，以优化程序的执行速度。\u003c/p\u003e\n\u003cp\u003e下图是其架构图。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"aligncenter\" src=\"https://imgopt.infoq.com/fit-in/1200x2400/filters:quality(80)/filters:no_upscale()/articles/gentle-linux-ebpf-introduction/en/resources/47image005-1619704397592.jpg\"/\u003e\u003c/p\u003e\n\u003cp style=\"text-align: center;\"\u003e（图片来自：\u003ca href=\"https://www.infoq.com/articles/gentle-linux-ebpf-introduction/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.infoq.com/articles/gentle-linux-ebpf-introduction/\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e在内核中运行时，eBPF 程序通常会挂载到一个内核钩子（hook）上，以便在特定的事件发生时被执行。例如，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cspan\u003e系统调用——当用户空间函数将执行转移到内核时插入\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003e函数进入和退出——拦截对预先存在的函数的调用\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003e网络事件 – 在收到数据包时执行\u003c/span\u003e\u003c/li\u003e\n\u003cli\u003e\u003cspan\u003eKprobes 和 uprobes – 附加到内核或用户函数的探测器\u003c/span\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后 eBPF Maps，允许eBPF程序在调用之间保持状态，以便进行相关的数据统计，并与用户空间的应用程序共享数据。一个eBPF映射基本上是一个键值存储，其中的值通常被视为任意数据的二进制块。它们是通过带有BPF_MAP_CREATE参数的\u003ccode\u003ebpf_cmd\u003c/code\u003e系统调用来创建的，和Linux世界中的其他东西一样，它们是通过文件描述符来寻址。与地图的交互是通过查找/更新/删除系统调用进行的\u003c/p\u003e\n\u003cp\u003e总之，eBPF 的工作原理是通过动态加载、执行和检查\u003cstrong\u003e无损编译\u003c/strong\u003e过的代码来实现的。\u003ccode\u003e[1]\u003c/code\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eeBPF 可以用于对内核的性能进行分析。下面是一个基于 eBPF 的性能分析的 step-by-step 示例：\u003c/p\u003e\n\u003cp\u003e第一步：准备工作：首先，需要确保内核已经支持 eBPF 功能。这通常需要在内核配置文件中启用 eBPF 相关的选项，并重新编译内核。检查是否支持 eBPF，你可以用这两个命令查看 \u003ccode\u003els /sys/fs/bpf\u003c/code\u003e 和 \u003ccode\u003elsmod | grep bpf\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e第二步：写 eBPF 程序：接下来，需要编写 eBPF 程序，用于收集内核的性能指标。eBPF 程序的语言可以选择 C 或者 Python，它需要通过特定的接口访问内核的数据结构，并将收集到的数据保存到指定的位置。\u003c/p\u003e\n\u003cp\u003e下面是一个Python 示例（其实还是C语言，用python来加载一段C程序到Linux内核）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e#!/usr/bin/python3\n\nfrom bcc import BPF\nfrom time import sleep\n\n# 定义 eBPF 程序\nbpf_text = \u0026#34;\u0026#34;\u0026#34;\n#include \u0026lt;uapi/linux/ptrace.h\u0026gt;\n\nBPF_HASH(stats, u32);\n\nint count(struct pt_regs *ctx) {\n    u32 key = 0;\n    u64 *val, zero=0;\n    val = stats.lookup_or_init(\u0026amp;key, \u0026amp;zero);\n    (*val)++;\n    return 0;\n}\n\u0026#34;\u0026#34;\u0026#34;\n\n# 编译 eBPF 程序\nb = BPF(text=bpf_text, cflags=[\u0026#34;-Wno-macro-redefined\u0026#34;])\n\n# 加载 eBPF 程序\nb.attach_kprobe(event=\u0026#34;tcp_sendmsg\u0026#34;, fn_name=\u0026#34;count\u0026#34;)\n\nname = {\n  0: \u0026#34;tcp_sendmsg\u0026#34;\n}\n# 输出统计结果\nwhile True:\n    try:\n        #print(\u0026#34;Total packets: %d\u0026#34; % b[\u0026#34;stats\u0026#34;][0].value)\n        for k, v in b[\u0026#34;stats\u0026#34;].items():\n           print(\u0026#34;{}: {}\u0026#34;.format(name[k.value], v.value))\n        sleep(1)\n    except KeyboardInterrupt:\n        exit()\u003c/pre\u003e\n\u003cp\u003e这个 eBPF 程序的功能是统计网络中传输的数据包数量。它通过定义一个 \u003ccode\u003eBPF_HASH\u003c/code\u003e 数据结构来保存统计结果（eBPF Maps），并通过捕获 \u003ccode\u003etcp_sendmsg\u003c/code\u003e 事件来实现实时统计。最后，它通过每秒输出一次统计结果来展示数据。这个 eBPF 程序只是一个简单的示例，实际应用中可能需要进行更复杂的统计和分析。\u003c/p\u003e\n\u003cp\u003e第三步：运行 eBPF 程序：接下来，需要使用 eBPF 编译器将 eBPF 程序编译成内核可执行的格式（这个在上面的Python程序里你可以看到——Python引入了一个bcc的包，然后用这个包，把那段 C语言的程序编译成字节码加载在内核中并把某个函数 attach 到某个事件上）。这个过程可以使用 BPF Compiler Collection（BCC）工具来完成。BCC 工具可以通过命令行的方式将 eBPF 程序编译成内核可执行的格式，并将其加载到内核中。\u003c/p\u003e\n\u003cp\u003e下面是运行上面的 Python3 程序的步骤：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003esudo apt install python3-bpfcc\u003c/pre\u003e\n\u003cp\u003e注：在Python3下请不要使用 \u003ccode\u003epip3 install bcc\u003c/code\u003e （参看：\u003ca href=\"https://github.com/iovisor/bcc/issues/2278#issuecomment-825356087\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e如果你是 Ubuntu 20.10 以上的版本，最好通过源码安装（否则程序会有编译问题），参看：\u003ca href=\"https://github.com/iovisor/bcc/issues/3993#issuecomment-1228217609\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"bash\"\u003eapt purge bpfcc-tools libbpfcc python3-bpfcc\nwget https://github.com/iovisor/bcc/releases/download/v0.25.0/bcc-src-with-submodule.tar.gz\ntar xf bcc-src-with-submodule.tar.gz\ncd bcc/\napt install -y python-is-python3\napt install -y bison build-essential cmake flex git libedit-dev   libllvm11 llvm-11-dev libclang-11-dev zlib1g-dev libelf-dev libfl-dev python3-distutils\napt install -y checkinstall\nmkdir build\ncd build/\ncmake -DCMAKE_INSTALL_PREFIX=/usr -DPYTHON_CMD=python3 ..\nmake\ncheckinstall\u003c/pre\u003e\n\u003cp\u003e接下来，需要将上面的 Python 程序保存到本地，例如保存到文件 netstat.py。运行程序：最后，可以通过执行以下命令来运行 Python 程序：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$ chmod +x ./netstat.py\n$ sudo ./netstat.py\ntcp_sendmsg: 29\ntcp_sendmsg: 216\ntcp_sendmsg: 277\ntcp_sendmsg: 379\ntcp_sendmsg: 419\ntcp_sendmsg: 468\ntcp_sendmsg: 574\ntcp_sendmsg: 645\ntcp_sendmsg: 29\n\u003c/pre\u003e\n\u003cp\u003e程序开始运行后，会在控制台输出网络数据包的统计信息。可以通过按 Ctrl+C 组合键来结束程序的运行。\u003c/p\u003e\n\u003cp\u003e下面我们再看一个比较复杂的示例，这个示例会计算TCP的发包时间（示例参考于Github上 \u003ca href=\"https://github.com/iovisor/bcc/issues/2972\" target=\"_blank\" rel=\"noopener\"\u003e这个issue\u003c/a\u003e里的程序）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e#!/usr/bin/python3\n\nfrom bcc import BPF\nimport time\n\n# 定义 eBPF 程序\nbpf_text = \u0026#34;\u0026#34;\u0026#34;\n#include \u0026lt;uapi/linux/ptrace.h\u0026gt;\n#include \u0026lt;net/sock.h\u0026gt;\n#include \u0026lt;net/inet_sock.h\u0026gt;\n#include \u0026lt;bcc/proto.h\u0026gt;\n\nstruct packet_t {\n    u64 ts, size;\n    u32 pid;\n    u32 saddr, daddr;\n    u16 sport, dport;\n};\n\nBPF_HASH(packets, u64, struct packet_t);\n\nint on_send(struct pt_regs *ctx, struct sock *sk, struct msghdr *msg, size_t size)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    u32 pid = id;\n\n    // 记录数据包的时间戳和信息\n    struct packet_t pkt = {}; // 结构体一定要初始化，可以使用下面的方法\n                              //__builtin_memset(\u0026amp;pkt, 0, sizeof(pkt)); \n    pkt.ts = bpf_ktime_get_ns();\n    pkt.size = size;\n    pkt.pid = pid;\n    pkt.saddr = sk-\u0026gt;__sk_common.skc_rcv_saddr;\n    pkt.daddr = sk-\u0026gt;__sk_common.skc_daddr;\n    struct inet_sock *sockp = (struct inet_sock *)sk;\n    pkt.sport = sockp-\u0026gt;inet_sport;\n    pkt.dport = sk-\u0026gt;__sk_common.skc_dport;\n\n    packets.update(\u0026amp;id, \u0026amp;pkt);\n    return 0;\n}\n\nint on_recv(struct pt_regs *ctx, struct sock *sk)\n{\n    u64 id = bpf_get_current_pid_tgid();\n    u32 pid = id;\n\n    // 获取数据包的时间戳和编号\n    struct packet_t *pkt = packets.lookup(\u0026amp;id);\n    if (!pkt) {\n        return 0;\n    }\n\n    // 计算传输时间\n    u64 delta = bpf_ktime_get_ns() - pkt-\u0026gt;ts;\n\n    // 统计结果\n    bpf_trace_printk(\u0026#34;tcp_time: %llu.%llums, size: %llu\\\\n\u0026#34;, \n       delta/1000, delta%1000%100, pkt-\u0026gt;size);\n\n    // 删除统计结果\n    packets.delete(\u0026amp;id);\n\n    return 0;\n}\n\u0026#34;\u0026#34;\u0026#34;\n\n# 编译 eBPF 程序\nb = BPF(text=bpf_text, cflags=[\u0026#34;-Wno-macro-redefined\u0026#34;])\n\n# 注册 eBPF 程序\nb.attach_kprobe(event=\u0026#34;tcp_sendmsg\u0026#34;, fn_name=\u0026#34;on_send\u0026#34;)\nb.attach_kprobe(event=\u0026#34;tcp_v4_do_rcv\u0026#34;, fn_name=\u0026#34;on_recv\u0026#34;)\n\n# 输出统计信息\nprint(\u0026#34;Tracing TCP latency... Hit Ctrl-C to end.\u0026#34;)\nwhile True:\n    try:\n        (task, pid, cpu, flags, ts, msg) = b.trace_fields()\n        print(\u0026#34;%-18.9f %-16s %-6d %s\u0026#34; % (ts, task, pid, msg))\n    except KeyboardInterrupt:\n        exit()\u003c/pre\u003e\n\u003cp\u003e上面这个程序通过捕获每个数据包的时间戳来统计传输时间。在捕获 \u003ccode\u003etcp_sendmsg\u003c/code\u003e 事件时，记录数据包的发送时间；在捕获 \u003ccode\u003etcp_v4_do_rcv\u003c/code\u003e 事件时，记录数据包的接收时间；最后，通过比较两个时间戳来计算传输时间。\u003c/p\u003e\n\u003cp\u003e从上面的两个程序我们可以看到，eBPF 的一个编程的基本方法，这样的在Python里向内核的某些事件挂载一段 “C语言” 的方式就是 eBPF 的编程方式。实话实说，这样的代码很不好写，而且有很多非常诡异的东西，一般人是很难驾驭的（上面的代码我也不是很容易都能写通的，把 Google 都用了个底儿掉，读了很多晦涩的文档……）好在这样的代码已经有人写了，我们不必再写了，在 \u003ca href=\"https://github.com/iovisor/bcc/tree/master/tools\" target=\"_blank\" rel=\"noopener\"\u003eGithub 上的 bcc 库下的 tools 目录\u003c/a\u003e有很多……\u003c/p\u003e\n\u003cp\u003eBCC（\u003ca href=\"https://github.com/iovisor/bcc\" target=\"_blank\" rel=\"noopener\"\u003eBPF Compiler Collection\u003c/a\u003e）是一套开源的工具集，可以在 Linux 系统中使用 BPF（Berkeley Packet Filter）程序进行系统级性能分析和监测。BCC 包含了许多实用工具，如：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ebcc-tools：一个包含许多常用的 BCC 工具的软件包。\u003c/li\u003e\n\u003cli\u003ebpftrace：一个高级语言，用于编写和执行 BPF 程序。\u003c/li\u003e\n\u003cli\u003etcptop：一个实时监控和分析 TCP 流量的工具。\u003c/li\u003e\n\u003cli\u003eexecsnoop：一个用于监控进程执行情况的工具。\u003c/li\u003e\n\u003cli\u003efiletop：一个实时监控和分析文件系统流量的工具。\u003c/li\u003e\n\u003cli\u003etrace：一个用于跟踪和分析函数调用的工具。\u003c/li\u003e\n\u003cli\u003efunccount：一个用于统计函数调用次数的工具。\u003c/li\u003e\n\u003cli\u003eopensnoop：一个用于监控文件打开操作的工具。\u003c/li\u003e\n\u003cli\u003epidstat：一个用于监控进程性能的工具。\u003c/li\u003e\n\u003cli\u003eprofile：一个用于分析系统 CPU 使用情况的工具。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e下面这张图你可能见过多次了，你可以看看他可以干多少事，内核里发生什么事一览无余。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://github.com/iovisor/bcc/raw/master/images/bcc_tracing_tools_2019.png\"/\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB\"\u003e\u003c/span\u003e延伸阅读\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e一些经典的文章和书籍关于 eBPF 包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBrendan Gregg 的《\u003ca href=\"https://book.douban.com/subject/34467459/\" target=\"_blank\" rel=\"noopener\"\u003eBPF Performance Tools: Linux System and Application Observability\u003c/a\u003e》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。\u003c/li\u003e\n\u003cli\u003eeBPF 的官网：\u003ca href=\"https://ebpf.io/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://ebpf.io/\u003c/a\u003e 由 \u003ca href=\"https://cilium.io/\" rel=\"nofollow\"\u003eCilium\u003c/a\u003e 建立\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://docs.cilium.io/en/latest/bpf/\" rel=\"nofollow\"\u003eCilium’s BPF and XDP Reference Guide\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/index.html\" rel=\"nofollow\"\u003eBPF Documentation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.kernel.org/doc/html/latest/bpf/bpf_design_QA.html\" rel=\"nofollow\"\u003eBPF Design Q\u0026amp;A\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e还有 Github 上的 \u003ca href=\"https://github.com/zoidbergwill/awesome-ebpf\" target=\"_blank\" rel=\"noopener\"\u003eAwesome eBPF\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%BD%A9%E8%9B%8B\"\u003e\u003c/span\u003e彩蛋\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e最后来到彩蛋环节。因为最近 ChatGPT 很火，于是，我想通过 ChatGPT 来帮助我书写这篇文章，一开始我让ChatGPT 帮我列提纲，并根据提纲生成文章内容，并查找相关的资料，非常之顺利，包括生成的代码，我以为我们以很快地完成这篇文章。\u003c/p\u003e\n\u003cp\u003e但是，到了代码生成的时候，我发现，ChatGPT 生成的代码的思路和方法都是对的，但是是比较老的，而且是跑不起来的，\u003cstrong\u003e出现了好些低级错误，如：使用了未声明的变量，没有引用完整的C语言的头文件，没有正确地初始化变量，错误地获取数据，类型没有匹配……等等\u003c/strong\u003e，在程序调试上，挖了很多的坑，C语言本来就不好搞，挖的很多运行时的坑很难察觉，所以，耗费了我大量的时间来排除各种各样的问题，其中有环境上的问题，还有代码上的问题，这些问题即便是通过 Google 也不容易找到解决方案，我找到的解决方案都放在文章中了，尤其是第二个示例，让我调试了3个多小时，读了很多 bcc 上的issue和相关的晦涩的手册和文档，才让程序跑通。\u003c/p\u003e\n\u003cp\u003e到了文章收关的阶段，我让ChatGPT 给我几个延伸阅读，也是很好的，但是没有给出链接，于是我只得人肉 Google 了一下，然后让我吃惊的是，\u003cstrong\u003e好多ChatGPT给出来的文章是根本不存在的，完全是它伪造的\u003c/strong\u003e。我连让它干了两次都是这样，这个让我惊掉大牙。这让我开始怀疑它之前生成的内容，于是，我不得我返回仔细Review我的文章，尤其是“介绍”、“用途”和“工作原理”这三个章节，基本都是ChatGPT生成的，在Review完后，我发现了ChatGPT 给我生造了一个叫 “无损编译器”的术语，这个术语简直了，于是我开始重写我的文章。我把一些段落重写了，有一些没有，保留下来的我都标记上了 \u003ccode\u003e[1]\u003c/code\u003e，大家读的时候要小心阅读。\u003c/p\u003e\n\u003cp\u003e最后，\u003cstrong\u003e我的结论是，ChatGPT只是一个不成熟的玩具，只能回答一些没有价值的日常聊天的问题，要说能取代Google，我觉得不可能，因为Google会基于基本的事实，而ChatGPT会基于内容生成的算法，在造假方面称得上是高手，可以列为电信诈骗的范畴了，我以后不会再使用ChatGPT生成文章内容或是作我的帮手了。StackOverflow把其ban了真是不能太赞了！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e附件一：ChatGPT的造假载图和样本\u003c/strong\u003e\u003c/p\u003e\n\u003ctable width=\"100%\"\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure id=\"attachment_22325\" aria-describedby=\"caption-attachment-22325\" style=\"width: 195px\" class=\"wp-caption aligncenter\"\u003e\u003ca href=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1.png\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22325 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-195x300.png\" alt=\"\" width=\"195\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-195x300.png 195w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-665x1024.png 665w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-768x1183.png 768w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-997x1536.png 997w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1-175x270.png 175w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.1.png 1096w\" sizes=\"(max-width: 195px) 100vw, 195px\"/\u003e\u003c/a\u003e\u003cfigcaption id=\"caption-attachment-22325\" class=\"wp-caption-text\"\u003e点击看大图\u003c/figcaption\u003e\u003c/figure\u003e\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure id=\"attachment_22326\" aria-describedby=\"caption-attachment-22326\" style=\"width: 286px\" class=\"wp-caption aligncenter\"\u003e\u003ca href=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2.png\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22326 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2-286x300.png\" alt=\"\" width=\"286\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2-286x300.png 286w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2-978x1024.png 978w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2-768x804.png 768w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2-258x270.png 258w, https://coolshell.cn/wp-content/uploads/2022/12/eBPF.ref_.2.png 1096w\" sizes=\"(max-width: 286px) 100vw, 286px\"/\u003e\u003c/a\u003e\u003cfigcaption id=\"caption-attachment-22326\" class=\"wp-caption-text\"\u003e点击看大图\u003c/figcaption\u003e\u003c/figure\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003eChatGPT 生成的样本一\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBrendan Gregg 的《BPF Performance Tools: Linux System and Application Observability》一书是一个全面的指南，涵盖了 eBPF 的基础知识和实践应用。\u003c/li\u003e\n\u003cli\u003eAlexei Starovoitov 在 2015 年的 LPC 大会上发表的《eBPF and XDP: fast programmable datapath in the Linux kernel》一文，是一个介绍 eBPF 和 XDP（eXpress Data Path）的综述。\u003c/li\u003e\n\u003cli\u003e谷歌的《BPF: The Future of Linux Monitoring and Observability》一文介绍了 eBPF 的基本概念，并探讨了它对于 Linux 监控和可观察性的影响。\u003c/li\u003e\n\u003cli\u003e微软的《A Survey of Techniques for Hardware Acceleration of BPF》一文，介绍了 eBPF 在硬件加速方面的研究现状。\u003c/li\u003e\n\u003cli\u003eDaniel Borkmann 的《Linux kernel networking: implementation and theory》一书涵盖了 eBPF 的实现和理论。\u003c/li\u003e\n\u003cli\u003eMartin KaFai Lau 在 2015 年的 SOSP 大会上发表的《eBPF: a new execution environment for the Linux kernel》一文，介绍了 eBPF 在 Linux 内核中的新执行环境。\u003c/li\u003e\n\u003cli\u003e来自两名谷歌工程师的《eBPF: A New Frontier in Performance Analysis》一文，探讨了 eBPF 对性能分析的影响。\u003c/li\u003e\n\u003cli\u003e《BPF Performance Tools: Linux System and Application Observability》一书中的第三章，讨论了 eBPF 的编译器和运行时系统。\u003c/li\u003e\n\u003cli\u003e来自三名谷歌工程师的《eBPF: The New Solaris DTrace》一文，比较了 eBPF 和 Solaris DTrace 系统的区别。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eChatGPT 生成的样本二\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eeBPF 程序开发指南（\u003ca href=\"https://cilium.io/doc/ebpf/ebpf-guide/\" target=\"_new\" rel=\"noopener\"\u003ehttps://cilium.io/doc/ebpf/ebpf-guide/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 官方文档（\u003ca href=\"https://www.kernel.org/doc/Documentation/networking/filter.txt\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.kernel.org/doc/Documentation/networking/filter.txt\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eLinux 内核 eBPF 介绍（\u003ca href=\"https://www.ibm.com/developerworks/cn/linux/kernel/ebpf/index.html\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.ibm.com/developerworks/cn/linux/kernel/ebpf/index.html\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 性能优化技巧（\u003ca href=\"https://www.infoq.com/cn/news/2018/08/ebpf-performance-tips/\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.infoq.com/cn/news/2018/08/ebpf-performance-tips/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 实战经验分享（\u003ca href=\"https://blog.cloudflare.com/ebpf-in-practice/\" target=\"_new\" rel=\"noopener\"\u003ehttps://blog.cloudflare.com/ebpf-in-practice/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 在网络安全中的应用（\u003ca href=\"https://www.zdnet.com/article/ebpf-how-to-use-it-for-network-security/\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.zdnet.com/article/ebpf-how-to-use-it-for-network-security/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 实现 Linux 系统性能监控（\u003ca href=\"https://www.percona.com/blog/2017/08/15/how-to-use-ebpf-to-monitor-linux-system-performance/\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.percona.com/blog/2017/08/15/how-to-use-ebpf-to-monitor-linux-system-performance/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 入门教程（\u003ca href=\"https://sysdig.com/blog/ebpf-getting-started/\" target=\"_new\" rel=\"noopener\"\u003ehttps://sysdig.com/blog/ebpf-getting-started/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 与 BPF 比较（\u003ca href=\"https://lwn.net/Articles/724647/\" target=\"_new\" rel=\"noopener\"\u003ehttps://lwn.net/Articles/724647/\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003eeBPF 提高课程（\u003ca href=\"https://www.pluralsight.com/courses/ebpf-advanced\" target=\"_new\" rel=\"noopener\"\u003ehttps://www.pluralsight.com/courses/ebpf-advanced\u003c/a\u003e）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e附件二：发明的术语：无损编译器\u003c/strong\u003e\u003c/p\u003e\n\u003ctable width=\"100%\"\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure id=\"attachment_22328\" aria-describedby=\"caption-attachment-22328\" style=\"width: 180px\" class=\"wp-caption aligncenter\"\u003e\u003ca href=\"https://coolshell.cn/wp-content/uploads/2022/12/fake.png\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22328 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2022/12/fake-180x300.png\" alt=\"\" width=\"180\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/12/fake-180x300.png 180w, https://coolshell.cn/wp-content/uploads/2022/12/fake-616x1024.png 616w, https://coolshell.cn/wp-content/uploads/2022/12/fake-768x1277.png 768w, https://coolshell.cn/wp-content/uploads/2022/12/fake-924x1536.png 924w, https://coolshell.cn/wp-content/uploads/2022/12/fake-162x270.png 162w, https://coolshell.cn/wp-content/uploads/2022/12/fake.png 1080w\" sizes=\"(max-width: 180px) 100vw, 180px\"/\u003e\u003c/a\u003e\u003cfigcaption id=\"caption-attachment-22328\" class=\"wp-caption-text\"\u003e点击看大图\u003c/figcaption\u003e\u003c/figure\u003e\u003c/td\u003e\n\u003ctd\u003e\n\u003cp\u003e\u003c/p\u003e\u003cfigure id=\"attachment_22335\" aria-describedby=\"caption-attachment-22335\" style=\"width: 223px\" class=\"wp-caption aligncenter\"\u003e\u003ca href=\"https://coolshell.cn/wp-content/uploads/2022/12/fake.term_.png\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22335 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-223x300.png\" alt=\"\" width=\"223\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-223x300.png 223w, https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-761x1024.png 761w, https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-768x1033.png 768w, https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-1142x1536.png 1142w, https://coolshell.cn/wp-content/uploads/2022/12/fake.term_-201x270.png 201w, https://coolshell.cn/wp-content/uploads/2022/12/fake.term_.png 1176w\" sizes=\"(max-width: 223px) 100vw, 223px\"/\u003e\u003c/a\u003e\u003cfigcaption id=\"caption-attachment-22335\" class=\"wp-caption-text\"\u003e点击看大图\u003c/figcaption\u003e\u003c/figure\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1379.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/13.jpg\" alt=\"如何调试bash脚本\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1379.html\" class=\"wp_rp_title\"\u003e如何调试bash脚本\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/19219.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2019/03/linux.ninja_-150x150.png\" alt=\"打造高效的工作环境 – Shell 篇\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/19219.html\" class=\"wp_rp_title\"\u003e打造高效的工作环境 – Shell 篇\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1-150x150.png\" alt=\"记一次Kubernetes/Docker网络排障\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_title\"\u003e记一次Kubernetes/Docker网络排障\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17998.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/systemd-1-150x150.jpeg\" alt=\"Linux PID 1 和 Systemd\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17998.html\" class=\"wp_rp_title\"\u003eLinux PID 1 和 Systemd\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17416.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2016/07/cache-150x150.png\" alt=\"缓存更新的套路\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17416.html\" class=\"wp_rp_title\"\u003e缓存更新的套路\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-22320\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"d364e3edd5\"\u003e\u003cimg id=\"rating_22320_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22320, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1059f687e264fc84cb9a65e5-=\"\"/\u003e\u003cimg id=\"rating_22320_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22320, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1059f687e264fc84cb9a65e5-=\"\"/\u003e\u003cimg id=\"rating_22320_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22320, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1059f687e264fc84cb9a65e5-=\"\"/\u003e\u003cimg id=\"rating_22320_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22320, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1059f687e264fc84cb9a65e5-=\"\"/\u003e\u003cimg id=\"rating_22320_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22320, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1059f687e264fc84cb9a65e5-=\"\"/\u003e (\u003cstrong\u003e34\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.12\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_22320_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"eBPF 介绍\"/\u003e\u003cmeta itemprop=\"headline\" content=\"eBPF 介绍\"/\u003e\u003cmeta itemprop=\"description\" content=\"很早前就想写一篇关于eBPF的文章，但是迟迟没有动手，这两天有点时间，所以就来写一篇，这文章主要还是简单的介绍eBPF 是用来干什么的，并通过几个示例来介绍是怎么玩的，这个技术非常非常之强，Linux 操作系统的观测性实在是太强大了，并在 BCC 加持下变得一览无余。这个技术不是一般的运维人员或是系统管理员可以驾驭的，这个还是要有底层系统知识并有一定开发能力的技术人员才能驾驭的了的。我在这篇文章的...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2022-12-10T10:38:51+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2022-12-12T10:56:31+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/22320.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/22320.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.12\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"34\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-22320-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-12-10T10:38:51+08:00",
  "Author": "陈皓"
}