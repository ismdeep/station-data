{
  "Source": "coolshell.cn",
  "Title": "Go 语言简介（上）— 语法",
  "Link": "https://coolshell.cn/articles/8460.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"34e3059e0b4eebdbf1ef64cc-text/javascript\"\u003e\u003c/script\u003e周末天气不好，只能宅在家里，于是就顺便看了一下Go语言，觉得比较有意思，所以写篇文章介绍一下。\u003cstrong\u003e我想写一篇你可以在乘坐地铁或公交车上下班时就可以初步了解一门语言的文章\u003c/strong\u003e。所以，下面的文章主要是以代码和注释为主。只需要你对C语言，Unix，Python有一点基础，我相信你会在30分钟左右读完并对Go语言有一些初步了解的。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-8485\" title=\"go\" src=\"https://coolshell.cn/wp-content/uploads/2012/11/go2.jpg\" alt=\"\" width=\"435\" height=\"255\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/11/go2.jpg 435w, https://coolshell.cn/wp-content/uploads/2012/11/go2-300x176.jpg 300w\" sizes=\"(max-width: 435px) 100vw, 435px\"/\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#Hello_World\" title=\"Hello World\"\u003eHello World\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E8%BF%90%E8%A1%8C\" title=\"运行\"\u003e运行\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E8%87%AA%E5%B7%B1%E7%9A%84package\" title=\"自己的package\"\u003e自己的package\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#fmt%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\" title=\"fmt输出格式\"\u003efmt输出格式\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F\" title=\"变量和常量\"\u003e变量和常量\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E6%95%B0%E7%BB%84\" title=\"数组\"\u003e数组\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C\" title=\"数组的切片操作\"\u003e数组的切片操作\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\" title=\"分支循环语句\"\u003e分支循环语句\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7\" title=\"关于分号\"\u003e关于分号\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#map\" title=\"map\"\u003emap\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-11\" href=\"#%E6%8C%87%E9%92%88\" title=\"指针\"\u003e指针\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-12\" href=\"#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\" title=\"内存分配 \"\u003e内存分配 \u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-13\" href=\"#%E5%87%BD%E6%95%B0\" title=\"函数\"\u003e函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-14\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93\" title=\"结构体\"\u003e结构体\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-15\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95\" title=\"结构体方法\"\u003e结构体方法\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-16\" href=\"#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81\" title=\"接口和多态\"\u003e接口和多态\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-17\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_Error%E6%8E%A5%E5%8F%A3\" title=\"错误处理 – Error接口\"\u003e错误处理 – Error接口\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-18\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_Defer\" title=\"错误处理 – Defer\"\u003e错误处理 – Defer\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-19\" href=\"#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_PanicRecover\" title=\"错误处理 – Panic/Recover\"\u003e错误处理 – Panic/Recover\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Hello_World\"\u003e\u003c/span\u003eHello World\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//文件名：hello.go\npackage main //声明本文件的package名\n\nimport \u0026#34;fmt\u0026#34; //import语言的fmt库——用于输出\n\nfunc main() {\n    fmt.Println(\u0026#34;hello world\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e\u003cspan id=\"more-8460\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%BF%90%E8%A1%8C\"\u003e\u003c/span\u003e运行\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e你可以有两种运行方式，\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e#解释执行（实际是编译成a.out再执行）\n$go run hello.go\nhello world\n\n#编译执行\n$go build hello.go\n\n$ls\nhello hello.go\n\n$./hello\nhello world\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%87%AA%E5%B7%B1%E7%9A%84package\"\u003e\u003c/span\u003e自己的package\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e你可以使用GOPATH环境变量，或是使用相对路径来import你自己的package。\u003c/p\u003e\n\u003cp\u003eGo的规约是这样的：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）\u003cstrong\u003e在import中，你可以使用相对路径，如 ./或 ../ 来引用你的package\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）\u003cstrong\u003e如果没有使用相对路径，那么，go会去找$GOPATH/src/目录。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//使用相对路径\nimport \u0026#34;./haoel\u0026#34;  //import当前目录里haoel子目录里的所有的go文件\n\u003c/pre\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//使用GOPATH路径\nimport \u0026#34;haoel\u0026#34;  //import 环境变量 $GOPATH/src/haoel子目录里的所有的go文件\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"fmt%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"\u003e\u003c/span\u003efmt输出格式\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003efmt包和libc里的那堆使用printf， scanf，fprintf，fscanf 很相似。下面的东西对于C程序员不会陌生。\u003c/p\u003e\n\u003cp\u003e注意：Println不支持，Printf才支持%式的输出：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;math\u0026#34;\n\nfunc main() {\n    fmt.Println(\u0026#34;hello world\u0026#34;)\n\n    fmt.Printf(\u0026#34;%t\\n\u0026#34;, 1==2)\n    fmt.Printf(\u0026#34;二进制：%b\\n\u0026#34;, 255)\n    fmt.Printf(\u0026#34;八进制：%o\\n\u0026#34;, 255)\n    fmt.Printf(\u0026#34;十六进制：%X\\n\u0026#34;, 255)\n    fmt.Printf(\u0026#34;十进制：%d\\n\u0026#34;, 255)\n    fmt.Printf(\u0026#34;浮点数：%f\\n\u0026#34;, math.Pi)\n    fmt.Printf(\u0026#34;字符串：%s\\n\u0026#34;, \u0026#34;hello world\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e当然，也可以使用如\\n\\t\\r这样的和C语言一样的控制字符\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%98%E9%87%8F%E5%92%8C%E5%B8%B8%E9%87%8F\"\u003e\u003c/span\u003e变量和常量\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e变量的声明很像 javascript，使用 var关键字。注意：\u003cstrong\u003ego是静态类型的语言\u003c/strong\u003e，下面是代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//声明初始化一个变量\nvar  x int = 100\nvar str string = \u0026#34;hello world\u0026#34;\u0026lt;/pre\u0026gt;\n//声明初始化多个变量\nvar  i, j, k int = 1, 2, 3\n\n//不用指明类型，通过初始化值来推导\nvar b = true //bool型\n\u003c/pre\u003e\n\u003cp\u003e还有一种定义变量的方式（这让我想到了Pascal语言，但完全不一样）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ex := 100 //等价于 var x int = 100;\n\u003c/pre\u003e\n\u003cp\u003e常量很简单，使用const关键字：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003econst s string = \u0026#34;hello world\u0026#34;\nconst pi float32 = 3.1415926\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%95%B0%E7%BB%84\"\u003e\u003c/span\u003e数组\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e直接看代码（注意其中的for语句，和C很相似吧，就是没有括号了）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main() {\n    var a [5]int\n    fmt.Println(\u0026#34;array a:\u0026#34;, a)\n\n    a[1] = 10\n    a[3] = 30\n    fmt.Println(\u0026#34;assign:\u0026#34;, a)\n\n    fmt.Println(\u0026#34;len:\u0026#34;, len(a))\n\n    b := [5]int{1, 2, 3, 4, 5}\n    fmt.Println(\u0026#34;init:\u0026#34;, b)\n\n    var c [2][3]int\n    for i := 0; i \u0026lt; 2; i++ {\n        for j := 0; j \u0026lt; 3; j++ {\n            c[i][j] = i + j\n        }\n    }\n    fmt.Println(\u0026#34;2d: \u0026#34;, c)\n}\n\u003c/pre\u003e\n\u003cp\u003e运行结果：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e\n\narray a: [0 0 0 0 0]\nassign: [0 10 0 30 0]\nlen: 5\ninit: [1 2 3 4 5]\n2d:  [[0 1 2] [1 2 3]]\n\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%87%E7%89%87%E6%93%8D%E4%BD%9C\"\u003e\u003c/span\u003e数组的切片操作\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e这个很Python了。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e\n\na := [5]int{1, 2, 3, 4, 5}\n\nb := a[2:4] // a[2] 和 a[3]，但不包括a[4]\nfmt.Println(b)\n\nb = a[:4] // 从 a[0]到a[4]，但不包括a[4]\nfmt.Println(b)\n\nb = a[2:] // 从 a[2]到a[4]，且包括a[2]\nfmt.Println(b)\n\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e但是，我们要记住，Golang的切片是共享内存的，也就是说，没有数据的复制，只是记录从哪切到哪的信息。\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%88%86%E6%94%AF%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5\"\u003e\u003c/span\u003e分支循环语句\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003eif语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e注意：if 语句没有圆括号，而必需要有花括号\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//if 语句\nif x % 2 == 0 {\n    //...\n}\n//if - else\nif x % 2 == 0 {\n    //偶数...\n} else {\n    //奇数...\n}\n\n//多分支\nif num \u0026lt; 0 {\n    //负数\n} else if num == 0 {\n    //零\n} else {\n    //正数\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eswitch 语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e注意：switch语句没有break，还可以使用逗号case多个值\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eswitch i {\n    case 1:\n        fmt.Println(\u0026#34;one\u0026#34;)\n    case 2:\n        fmt.Println(\u0026#34;two\u0026#34;)\n    case 3:\n        fmt.Println(\u0026#34;three\u0026#34;)\n    case 4,5,6:\n        fmt.Println(\u0026#34;four, five, six\u0026#34;)\n    default:\n        fmt.Println(\u0026#34;invalid value!\u0026#34;)\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003efor 语句\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e前面你已见过了，下面再来看看for的三种形式：（注意：Go语言中没有while）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//经典的for语句 init; condition; post\nfor i := 0; i\u0026lt;10; i++{\n     fmt.Println(i)\n}\n\n//精简的for语句 condition\ni := 1\nfor i\u0026lt;10 {\n    fmt.Println(i)\n    i++\n}\n\n//死循环的for语句 相当于for(;;)\ni :=1\nfor {\n    if i\u0026gt;10 {\n        break\n    }\n    i++\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7\"\u003e\u003c/span\u003e关于分号\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e从上面的代码我们可以看到代码里没有分号。其实，\u003cstrong\u003e和C一样，Go的正式的语法使用分号来终止语句。和C不同的是，这些分号由词法分析器在扫描源代码过程中使用简单的规则自动插入分号，因此输入源代码多数时候就不需要分号了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e规则是这样的：如果在一个新行前方的最后一个标记是一个标识符（包括像\u003ccode\u003eint\u003c/code\u003e和\u003ccode\u003efloat64\u003c/code\u003e这样的单词）、一个基本的如数值这样的文字、或以下标记中的一个时，会自动插入分号：\u003c/p\u003e\n\u003cpre\u003ebreak continue fallthrough return ++ -- ) }\u003c/pre\u003e\n\u003cp\u003e通常Go程序仅在\u003ccode\u003efor\u003c/code\u003e循环语句中使用分号，以此来分开初始化器、条件和增量单元。如果你在一行中写多个语句，也需要用分号分开。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e：\u003cstrong\u003e无论任何时候，你都不应该将一个控制结构（(\u003ccode\u003eif\u003c/code\u003e、\u003ccode\u003efor\u003c/code\u003e、\u003ccode\u003eswitch\u003c/code\u003e或\u003ccode\u003eselect\u003c/code\u003e）的左大括号放在下一行。如果这样做，将会在大括号的前方插入一个分号，这可能导致出现不想要的结果\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"map\"\u003e\u003c/span\u003emap\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003emap在别的语言里可能叫哈希表或叫dict，下面是和map的相关操作的代码，代码很容易懂\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main(){\n    m := make(map[string]int) //使用make创建一个空的map\n\n    m[\u0026#34;one\u0026#34;] = 1\n    m[\u0026#34;two\u0026#34;] = 2\n    m[\u0026#34;three\u0026#34;] = 3\n\n    fmt.Println(m) //输出 map[three:3 two:2 one:1] (顺序在运行时可能不一样)\n    fmt.Println(len(m)) //输出 3\n\n    v := m[\u0026#34;two\u0026#34;] //从map里取值\n    fmt.Println(v) // 输出 2\n\n    delete(m, \u0026#34;two\u0026#34;)\n    fmt.Println(m) //输出 map[three:3 one:1]\n\n    m1 := map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3}\n    fmt.Println(m1) //输出 map[two:2 three:3 one:1] (顺序在运行时可能不一样)\n\n    for key, val := range m1{\n        fmt.Printf(\u0026#34;%s =\u0026gt; %d \\n\u0026#34;, key, val)\n        /*输出：(顺序在运行时可能不一样)\n            three =\u0026gt; 3\n            one =\u0026gt; 1\n            two =\u0026gt; 2*/\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%8C%87%E9%92%88\"\u003e\u003c/span\u003e指针\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo语言一样有指针，看代码\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e\n\nvar i int = 1\nvar pInt *int = \u0026amp;i\n//输出：i=1     pInt=0xf8400371b0       *pInt=1\nfmt.Printf(\u0026#34;i=%d\\tpInt=%p\\t*pInt=%d\\n\u0026#34;, i, pInt, *pInt)\n\n*pInt = 2\n//输出：i=2     pInt=0xf8400371b0       *pInt=2\nfmt.Printf(\u0026#34;i=%d\\tpInt=%p\\t*pInt=%d\\n\u0026#34;, i, pInt, *pInt)\n\ni = 3\n//输出：i=3     pInt=0xf8400371b0       *pInt=3\nfmt.Printf(\u0026#34;i=%d\\tpInt=%p\\t*pInt=%d\\n\u0026#34;, i, pInt, *pInt)\n\n\u003c/pre\u003e\n\u003cp\u003eGo具有两个分配内存的机制，分别是内建的函数new和make。他们所做的事不同，所应用到的类型也不同，这可能引起混淆，但规则却很简单。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D\"\u003e\u003c/span\u003e\u003cstrong\u003e内存分配 \u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003enew\u003c/strong\u003e 是一个分配内存的内建函数，但不同于其他语言中同名的new所作的工作，\u003cstrong\u003e它只是将内存清零，而不是初始化内存\u003c/strong\u003e。new(T)为一个类型为T的新项目分配了值为零的存储空间并返回其地址，也就是一个类型为*T的值。用Go的术语来说，就是\u003cstrong\u003e它返回了一个指向新分配的类型为T的零值的指针\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u003cstrong\u003emake\u003c/strong\u003e(T, \u003c/code\u003e\u003cem\u003eargs\u003c/em\u003e\u003ccode\u003e)\u003c/code\u003e函数的目的与\u003ccode\u003enew(T)\u003c/code\u003e不同。它仅用于创建切片、map和chan（消息管道），并返回类型\u003ccode\u003eT\u003c/code\u003e（不是\u003ccode\u003e*T\u003c/code\u003e）的一个\u003cstrong\u003e被初始化了的\u003c/strong\u003e（不是\u003cstrong\u003e零\u003c/strong\u003e）实例。这种差别的出现是由于这三种类型实质上是对在使用前必须进行初始化的数据结构的引用。例如，切片是一个具有三项内容的描述符，包括指向数据（在一个数组内部）的指针、长度以及容量，在这三项内容被初始化之前，切片值为\u003ccode\u003enil\u003c/code\u003e。对于切片、映射和信道，\u003ccode\u003emake\u003c/code\u003e初始化了其内部的数据结构并准备了将要使用的值。如：\u003c/p\u003e\n\u003cp\u003e下面的代码分配了一个整型数组，长度为10，容量为100，并返回前10个数组的切片\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003emake([]int, 10, 100)\u003c/pre\u003e\n\u003cp\u003e以下示例说明了\u003ccode\u003enew\u003c/code\u003e和\u003ccode\u003emake\u003c/code\u003e的不同。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar p *[]int = new([]int)   // 为切片结构分配内存；*p == nil；很少使用\nvar v  []int = make([]int, 10) // 切片v现在是对一个新的有10个整数的数组的引用\n\n// 不必要地使问题复杂化：\nvar p *[]int = new([]int)\nfmt.Println(p) //输出：\u0026amp;[]\n*p = make([]int, 10, 10)\nfmt.Println(p) //输出：\u0026amp;[0 0 0 0 0 0 0 0 0 0]\nfmt.Println((*p)[2]) //输出： 0\n\n// 习惯用法:\nv := make([]int, 10)\nfmt.Println(v) //输出：[0 0 0 0 0 0 0 0 0 0]\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e老实说，我对Go语言这种反过来声明变量类型和函数返回值的做法有点不满（保持和C一样的不可以吗? 呵呵）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\nimport \u0026#34;fmt\u0026#34;\n\nfunc max(a int, b int) int { //注意参数和返回值是怎么声明的\n\n    if a \u0026gt; b {\n        return a\n    }\n    return b\n}\n\nfunc main(){\n    fmt.Println(max(4, 5))\n}\n\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e函数返回多个值\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGo中很多Package 都会返回两个值，一个是正常值，一个是错误，如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\nimport \u0026#34;fmt\u0026#34;\n\nfunc main(){\n    v, e := multi_ret(\u0026#34;one\u0026#34;)\n    fmt.Println(v,e) //输出 1 true\n\n    v, e = multi_ret(\u0026#34;four\u0026#34;)\n    fmt.Println(v,e) //输出 0 false\n\n    //通常的用法(注意分号后有e)\n    if v, e = multi_ret(\u0026#34;four\u0026#34;); e {\n        // 正常返回\n    }else{\n        // 出错返回\n    }\n}\n\nfunc multi_ret(key string) (int, bool){\n    m := map[string]int{\u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3}\n\n    var err bool\n    var val int\n\n    val, err = m[key]\n\n    return val, err\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e函数不定参数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e例子很清楚了，我就不多说了\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc sum(nums ...int) {\n    fmt.Print(nums, \u0026#34; \u0026#34;)  //输出如 [1, 2, 3] 之类的数组\n    total := 0\n    for _, num := range nums { //要的是值而不是下标\n        total += num\n    }\n    fmt.Println(total)\n}\nfunc main() {\n    sum(1, 2)\n    sum(1, 2, 3)\n\n    //传数组\n    nums := []int{1, 2, 3, 4}\n    sum(nums...)\n}\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e函数闭包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003enextNum这个函数返回了一个匿名函数，这个匿名函数记住了nextNum中i+j的值，并改变了i,j的值，于是形成了一个闭包的用法\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc nextNum() func() int {\n    i,j := 1,1\n    return func() int {\n        var tmp = i+j\n        i, j = j, tmp\n        return tmp\n    }\n}\n//main函数中是对nextNum的调用，其主要是打出下一个斐波拉契数\nfunc main(){\n    nextNumFunc := nextNum()\n    for i:=0; i\u0026lt;10; i++ {\n        fmt.Println(nextNumFunc())\n    }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e函数的递归\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e和c基本是一样的\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc fact(n int) int {\n    if n == 0 {\n        return 1\n    }\n    return n * fact(n-1)\n}\n\nfunc main() {\n    fmt.Println(fact(7))\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%93%E6%9E%84%E4%BD%93\"\u003e\u003c/span\u003e结构体\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo的结构体和C的基本上一样，不过在初始化时有些不一样，Go支持带名字的初始化。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Person struct {\n    name string\n    age  int\n    email string\n}\n\nfunc main() {\n    //初始化\n    person := Person{\u0026#34;Tom\u0026#34;, 30, \u0026#34;\u003ca href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\"03776c6e43646e626a6f2d606c6e\"\u003e[email protected]\u003c/a\u003e\u0026#34;}\n    person = Person{name:\u0026#34;Tom\u0026#34;, age: 30, email:\u0026#34;\u003ca href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\"ea9e8587aa8d878b8386c4898587\"\u003e[email protected]\u003c/a\u003e\u0026#34;}\n\n    fmt.Println(person) //输出 {Tom 30 \u003ca href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\"0672696b46616b676f6a2865696b\"\u003e[email protected]\u003c/a\u003e}\n\n    pPerson := \u0026amp;person\n\n    fmt.Println(pPerson) //输出 \u0026amp;{Tom 30 \u003ca href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\"e692898ba6818b878f8ac885898b\"\u003e[email protected]\u003c/a\u003e}\n\n    pPerson.age = 40\n    person.name = \u0026#34;Jerry\u0026#34;\n    fmt.Println(person) //输出 {Jerry 40 \u003ca href=\"/cdn-cgi/l/email-protection\" class=\"__cf_email__\" data-cfemail=\"25514a48654248444c490b464a48\"\u003e[email protected]\u003c/a\u003e}\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%93%E6%9E%84%E4%BD%93%E6%96%B9%E6%B3%95\"\u003e\u003c/span\u003e结构体方法\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e不多说了，看代码吧。\u003c/p\u003e\n\u003cp\u003e注意：Go语言中没有public, protected, private的关键字，所以，\u003cstrong\u003e如果你想让一个方法可以被别的包访问的话，你需要把这个方法的第一个字母大写。这是一种约定\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype rect struct {\n    width, height int\n}\n\nfunc (r *rect) area() int { //求面积\n    return r.width * r.height\n}\n\nfunc (r *rect) perimeter() int{ //求周长\n    return 2*(r.width + r.height)\n}\n\nfunc main() {\n    r := rect{width: 10, height: 15}\n\n    fmt.Println(\u0026#34;面积: \u0026#34;, r.area())\n    fmt.Println(\u0026#34;周长: \u0026#34;, r.perimeter())\n\n    rp := \u0026amp;r\n    fmt.Println(\u0026#34;面积: \u0026#34;, rp.area())\n    fmt.Println(\u0026#34;周长: \u0026#34;, rp.perimeter())\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81\"\u003e\u003c/span\u003e接口和多态\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e接口意味着多态，下面是一个经典的例子，不用多说了，自己看代码吧。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//---------- 接 口 --------//\ntype shape interface {\n    area() float64 //计算面积\n    perimeter() float64 //计算周长\n}\n\n//--------- 长方形 ----------//\ntype rect struct {\n    width, height float64\n}\n\nfunc (r *rect) area() float64 { //面积\n    return r.width * r.height\n}\n\nfunc (r *rect) perimeter() float64 { //周长\n    return 2*(r.width + r.height)\n}\n\n//----------- 圆  形 ----------//\ntype circle struct {\n    radius float64\n}\n\nfunc (c *circle) area() float64 { //面积\n    return math.Pi * c.radius * c.radius\n}\n\nfunc (c *circle) perimeter() float64 { //周长\n    return 2 * math.Pi * c.radius\n}\n\n// ----------- 接口的使用 -----------//\nfunc interface_test() {\n    r := rect {width:2.9, height:4.8}\n    c := circle {radius:4.3}\n\n    s := []shape{\u0026amp;r, \u0026amp;c} //通过指针实现\n\n    for _, sh := range s {\n        fmt.Println(sh)\n        fmt.Println(sh.area())\n        fmt.Println(sh.perimeter())\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_Error%E6%8E%A5%E5%8F%A3\"\u003e\u003c/span\u003e错误处理 – Error接口\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e函数错误返回可能是C/C++时最让人纠结的东西的，Go的多值返回可以让我们更容易的返回错误，其可以在返回一个常规的返回值之外，还能轻易地返回一个详细的错误描述。通常情况下，错误的类型是error，它有一个内建的接口。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype error interface {\n    Error() string\n}\u003c/pre\u003e\n\u003cp\u003e还是看个示例吧：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;errors\u0026#34;\n\n//自定义的出错结构\ntype myError struct {\n    arg  int\n    errMsg string\n}\n//实现Error接口\nfunc (e *myError) Error() string {\n    return fmt.Sprintf(\u0026#34;%d - %s\u0026#34;, e.arg, e.errMsg)\n}\n\n//两种出错\nfunc error_test(arg int) (int, error) {\n    if arg \u0026lt; 0  {\n         return -1, errors.New(\u0026#34;Bad Arguments - negtive!\u0026#34;)\n     }else if arg \u0026gt;256 {\n        return -1, \u0026amp;myError{arg, \u0026#34;Bad Arguments - too large!\u0026#34;}\n    }\n    return arg*arg, nil\n}\n\n//相关的测试\nfunc main() {\n    for _, i := range []int{-1, 4, 1000} {\n        if r, e := error_test(i); e != nil {\n            fmt.Println(\u0026#34;failed:\u0026#34;, e)\n        } else {\n            fmt.Println(\u0026#34;success:\u0026#34;, r)\n        }\n    }\n}\u003c/pre\u003e\n\u003cp\u003e程序运行后输出：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003efailed: Bad Arguments - negtive!\nsuccess: 16\nfailed: 1000 - Bad Arguments - too large!\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_Defer\"\u003e\u003c/span\u003e错误处理 – Defer\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面的程序对于每一个熟悉C语言的人来说都不陌生（有资源泄露的问题），C++使用RAII来解决这种问题。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc CopyFile(dstName, srcName string) (written int64, err error) {\n    src, err := os.Open(srcName)\n    if err != nil {\n        return\n    }\n\n    dst, err := os.Create(dstName)\n    if err != nil {\n        return\n    }\n\n    written, err = io.Copy(dst, src)\n    dst.Close()\n    src.Close()\n    return\n}\u003c/pre\u003e\n\u003cp\u003eGo语言引入了Defer来确保那些被打开的文件能被关闭。如下所示：（这种解决方式还是比较优雅的）\u003c/p\u003e\n\u003cp\u003e\u0026lt;\u003c/p\u003e\n\u003cp\u003epre class=”EnlighterJSRAW” data-enlighter-language=”golang” data-enlighter-highlight=”6,12″\u0026gt;\u003cbr/\u003e\nfunc CopyFile(dstName, srcName string) (written int64, err error) {\u003cbr/\u003e\nsrc, err := os.Open(srcName)\u003cbr/\u003e\nif err != nil {\u003cbr/\u003e\nreturn\u003cbr/\u003e\n}\u003cbr/\u003e\ndefer src.Close()\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edst, err := os.Create(dstName)\nif err != nil {\n    return\n}\ndefer dst.Close()\n\nreturn io.Copy(dst, src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e}[/c]\u003c/p\u003e\n\u003cp\u003eGo的defer语句预设一个函数调用（延期的函数），该调用在函数执行defer返回时立刻运行。该方法显得不同常规，但却是处理上述情况很有效，无论函数怎样返回，都必须进行资源释放。\u003c/p\u003e\n\u003cp\u003e我们再来看一个defer函数的示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efor i := 0; i \u0026lt; 5; i++ {\n    defer fmt.Printf(\u0026#34;%d \u0026#34;, i)\n}\u003c/pre\u003e\n\u003cp\u003e被延期的函数以后进先出（LIFO）的顺行执行，因此以上代码在返回时将打印4 3 2 1 0。\u003c/p\u003e\n\u003cp\u003e总之，我个人觉得defer的函数行为有点怪异，我现在还没有完全搞清楚。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86_%E2%80%93_PanicRecover\"\u003e\u003c/span\u003e错误处理 – Panic/Recover\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e对于不可恢复的错误，Go提供了一个内建的panic函数，它将创建一个运行时错误并使程序停止（相当暴力）。该函数接收一个任意类型（往往是字符串）作为程序死亡时要打印的东西。当编译器在函数的结尾处检查到一个panic时，就会停止进行常规的return语句检查。\u003c/p\u003e\n\u003cp\u003e下面的仅仅是一个示例。实际的库函数应避免panic。如果问题可以容忍，最好是让事情继续下去而不是终止整个程序。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar user = os.Getenv(\u0026#34;USER\u0026#34;)\n\nfunc init() {\n    if user == \u0026#34;\u0026#34; {\n        panic(\u0026#34;no value for $USER\u0026#34;)\n    }\n}\u003c/pre\u003e\n\u003cp\u003e当panic被调用时，它将立即停止当前函数的执行并开始逐级解开函数堆栈，同时运行所有被defer的函数。如果这种解开达到堆栈的顶端，程序就死亡了。但是，也可以使用内建的recover函数来重新获得Go程的控制权并恢复正常的执行。 对recover的调用会通知解开堆栈并返回传递到panic的参量。由于仅在解开期间运行的代码处在被defer的函数之内，recover仅在被延期的函数内部才是有用的。\u003c/p\u003e\n\u003cp\u003e你可以简单地理解为recover就是用来捕捉Painc的，防止程序一下子就挂掉了。\u003c/p\u003e\n\u003cp\u003e下面是一个例程，很简单了，不解释了\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc g(i int) {\n    if i\u0026gt;1 {\n        fmt.Println(\u0026#34;Panic!\u0026#34;)\n        panic(fmt.Sprintf(\u0026#34;%v\u0026#34;, i))\n    }\n\n}\n\nfunc f() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\u0026#34;Recovered in f\u0026#34;, r)\n        }\n    }()\n\n    for i := 0; i \u0026lt; 4; i++ {\n        fmt.Println(\u0026#34;Calling g with \u0026#34;, i)\n        g(i)\n        fmt.Println(\u0026#34;Returned normally from g.\u0026#34;)\n     }\n}\n\nfunc main() {\n    f()\n    fmt.Println(\u0026#34;Returned normally from f.\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e运行结果如下：（我们可以看到Painc后的for循环就没有往下执行了，但是main的程序还在往下走）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003eCalling g with  0\nReturned normally from g.\nCalling g with  1\nReturned normally from g.\nCalling g with  2\nPanic!\nRecovered in f 2\nReturned normally from f.\n\u003c/pre\u003e\n\u003cp\u003e你习惯这种编程方式吗？我觉得有点诡异。呵呵。\u003c/p\u003e\n\u003cp\u003e好了，上面是是一Go语言相关的编程语法的介绍，我没有事无巨细，只是让你了解一下Go语言是长什么样的。\u003cstrong\u003e当然，这还没完，请期待下篇——Go语言的特性\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-8460\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"c7d88b9818\"\u003e\u003cimg id=\"rating_8460_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8460, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-34e3059e0b4eebdbf1ef64cc-=\"\"/\u003e\u003cimg id=\"rating_8460_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8460, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-34e3059e0b4eebdbf1ef64cc-=\"\"/\u003e\u003cimg id=\"rating_8460_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8460, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-34e3059e0b4eebdbf1ef64cc-=\"\"/\u003e\u003cimg id=\"rating_8460_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8460, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-34e3059e0b4eebdbf1ef64cc-=\"\"/\u003e\u003cimg id=\"rating_8460_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8460, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-34e3059e0b4eebdbf1ef64cc-=\"\"/\u003e (\u003cstrong\u003e40\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.40\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_8460_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go 语言简介（上）— 语法\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go 语言简介（上）— 语法\"/\u003e\u003cmeta itemprop=\"description\" content=\"周末天气不好，只能宅在家里，于是就顺便看了一下Go语言，觉得比较有意思，所以写篇文章介绍一下。我想写一篇你可以在乘坐地铁或公交车上下班时就可以初步了解一门语言的文章。所以，下面的文章主要是以代码和注释为主。只需要你对C语言，Unix，Python有一点基础，我相信你会在30分钟左右读完并对Go语言有一些初步了解的。\n\n\n\nHello World\n\n\n//文件名：hello.go\npackage m...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-11-06T08:27:48+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-06T17:52:01+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/8460.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/8460.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.4\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"40\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-8460-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-11-06T08:27:48+08:00",
  "Author": "陈皓"
}