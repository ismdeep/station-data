{
  "Source": "coolshell.cn",
  "Title": "Java中的CopyOnWrite容器",
  "Link": "https://coolshell.cn/articles/11175.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"7d3a7cbbdbb8124f7cb1213c-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-medium wp-image-11219\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2014/03/cow-copy-300x222.jpg\" width=\"300\" height=\"222\"/\u003e\u003cstrong\u003e感谢 \u003ca href=\"http://ifeve.com\" target=\"_blank\"\u003e清英\u003c/a\u003e 同学的投稿\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eCopy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8\" title=\"什么是CopyOnWrite容器\"\u003e什么是CopyOnWrite容器\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#CopyOnWriteArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\" title=\"CopyOnWriteArrayList的实现原理\"\u003eCopyOnWriteArrayList的实现原理\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#CopyOnWrite%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\" title=\"CopyOnWrite的应用场景\"\u003eCopyOnWrite的应用场景\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#CopyOnWrite%E7%9A%84%E7%BC%BA%E7%82%B9\" title=\"CopyOnWrite的缺点\"\u003eCopyOnWrite的缺点\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BB%80%E4%B9%88%E6%98%AFCopyOnWrite%E5%AE%B9%E5%99%A8\"\u003e\u003c/span\u003e什么是CopyOnWrite容器\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eCopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11175\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CopyOnWriteArrayList%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86\"\u003e\u003c/span\u003eCopyOnWriteArrayList的实现原理\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在使用CopyOnWriteArrayList之前，我们先阅读其源码了解下它是如何实现的。以下代码是向ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\"\u003epublic boolean add(T e) {\n    final ReentrantLock lock = this.lock;\n    lock.lock();\n    try {\n\n        Object[] elements = getArray();\n\n        int len = elements.length;\n        // 复制出新数组\n\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n        // 把新元素添加到新数组里\n\n        newElements[len] = e;\n        // 把原数组引用指向新数组\n\n        setArray(newElements);\n\n        return true;\n\n    } finally {\n\n        lock.unlock();\n\n    }\n\n}\n\nfinal void setArray(Object[] a) {\n    array = a;\n}\n\u003c/pre\u003e\n\u003cp\u003e读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\"\u003epublic E get(int index) {\n    return get(getArray(), index);\n}\n\u003c/pre\u003e\n\u003cp\u003eJDK中并没有提供CopyOnWriteMap，我们可以参考CopyOnWriteArrayList来实现一个，基本代码如下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\"\u003e\n\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CopyOnWriteMap\u0026lt;K, V\u0026gt; implements Map\u0026lt;K, V\u0026gt;, Cloneable {\n    private volatile Map\u0026lt;K, V\u0026gt; internalMap;\n\n    public CopyOnWriteMap() {\n        internalMap = new HashMap\u0026lt;K, V\u0026gt;();\n    }\n\n    public V put(K key, V value) {\n\n        synchronized (this) {\n            Map\u0026lt;K, V\u0026gt; newMap = new HashMap\u0026lt;K, V\u0026gt;(internalMap);\n            V val = newMap.put(key, value);\n            internalMap = newMap;\n            return val;\n        }\n    }\n\n    public V get(Object key) {\n        return internalMap.get(key);\n    }\n\n    public void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; newData) {\n        synchronized (this) {\n            Map\u0026lt;K, V\u0026gt; newMap = new HashMap\u0026lt;K, V\u0026gt;(internalMap);\n            newMap.putAll(newData);\n            internalMap = newMap;\n        }\n    }\n}\n\u003c/pre\u003e\n\u003cp\u003e实现很简单，只要了解了CopyOnWrite机制，我们可以实现各种CopyOnWrite容器，并且在不同的应用场景中使用。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CopyOnWrite%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"\u003e\u003c/span\u003eCopyOnWrite的应用场景\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eCopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。实现代码如下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\"\u003epackage com.ifeve.book;\n\nimport java.util.Map;\n\nimport com.ifeve.book.forkjoin.CopyOnWriteMap;\n\n/**\n * 黑名单服务\n *\n * @author fangtengfei\n *\n */\npublic class BlackListServiceImpl {\n\n    private static CopyOnWriteMap\u0026lt;String, Boolean\u0026gt; blackListMap = new CopyOnWriteMap\u0026lt;String, Boolean\u0026gt;(\n            1000);\n\n    public static boolean isBlackList(String id) {\n        return blackListMap.get(id) == null ? false : true;\n    }\n\n    public static void addBlackList(String id) {\n        blackListMap.put(id, Boolean.TRUE);\n    }\n\n    /**\n     * 批量添加黑名单\n     *\n     * @param ids\n     */\n    public static void addBlackList(Map\u0026lt;String,Boolean\u0026gt; ids) {\n        blackListMap.putAll(ids);\n    }\n\n}\n\u003c/pre\u003e\n\u003cp\u003e代码很简单，但是使用CopyOnWriteMap需要注意两件事情：\u003c/p\u003e\n\u003cp\u003e1. 减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。\u003c/p\u003e\n\u003cp\u003e2. 使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。如使用上面代码里的addBlackList方法。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CopyOnWrite%E7%9A%84%E7%BC%BA%E7%82%B9\"\u003e\u003c/span\u003eCopyOnWrite的缺点\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eCopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e内存占用问题\u003c/strong\u003e。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。之前我们系统中使用了一个服务由于每晚使用CopyOnWrite机制更新大对象，造成了每晚15秒的Full GC，应用响应时间也随之变长。\u003c/p\u003e\n\u003cp\u003e针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如\u003ca href=\"http://ifeve.com/concurrenthashmap/\" target=\"_blank\"\u003eConcurrentHashMap\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e数据一致性问题\u003c/strong\u003e。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。\u003c/p\u003e\n\u003cp\u003e关于C++的STL中，曾经也有过Copy-On-Write的玩法，参见陈皓的《\u003ca href=\"http://blog.csdn.net/haoel/article/details/24058\" target=\"_blank\"\u003eC++ STL String类中的Copy-On-Write\u003c/a\u003e》，后来，因为有很多线程安全上的事，就被去掉了。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11541.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg\" alt=\"面向GC的Java编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11541.html\" class=\"wp_rp_title\"\u003e面向GC的Java编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11454.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/17.jpg\" alt=\"从LongAdder看更高效的无锁实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11454.html\" class=\"wp_rp_title\"\u003e从LongAdder看更高效的无锁实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/05/图1-3-150x150.jpg\" alt=\"无锁HashMap的原理与实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_title\"\u003e无锁HashMap的原理与实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9606.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/05/race_condition-150x150.jpg\" alt=\"疫苗：Java HashMap的死循环\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9606.html\" class=\"wp_rp_title\"\u003e疫苗：Java HashMap的死循环\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11175\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"821ba6e71b\"\u003e\u003cimg id=\"rating_11175_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11175, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-7d3a7cbbdbb8124f7cb1213c-=\"\"/\u003e\u003cimg id=\"rating_11175_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11175, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-7d3a7cbbdbb8124f7cb1213c-=\"\"/\u003e\u003cimg id=\"rating_11175_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11175, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-7d3a7cbbdbb8124f7cb1213c-=\"\"/\u003e\u003cimg id=\"rating_11175_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11175, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-7d3a7cbbdbb8124f7cb1213c-=\"\"/\u003e\u003cimg id=\"rating_11175_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11175, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-7d3a7cbbdbb8124f7cb1213c-=\"\"/\u003e (\u003cstrong\u003e32\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.63\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11175_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Java中的CopyOnWrite容器\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Java中的CopyOnWrite容器\"/\u003e\u003cmeta itemprop=\"description\" content=\"感谢 清英 同学的投稿\n\nCopy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyO...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-03-07T08:26:31+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2014-03-08T15:55:37+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11175.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"方 腾飞\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11175.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.63\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"32\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11175-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-03-07T08:26:31+08:00",
  "Author": "方 腾飞"
}