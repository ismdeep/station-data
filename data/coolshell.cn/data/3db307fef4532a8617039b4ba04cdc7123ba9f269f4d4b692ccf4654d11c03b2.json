{
  "Source": "coolshell.cn",
  "Title": "Go编程模式：委托和反转控制",
  "Link": "https://coolshell.cn/articles/21214.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"d412ad25f3c36fee8b6dd053-text/javascript\"\u003e\u003c/script\u003e\u003c/p\u003e\u003cfigure id=\"attachment_21256\" aria-describedby=\"caption-attachment-21256\" style=\"width: 300px\" class=\"wp-caption alignright\"\u003e\u003cimg decoding=\"async\" class=\"wp-image-21256 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-300x298.png\" alt=\"\" width=\"300\" height=\"298\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-300x298.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-1024x1017.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png 150w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-768x762.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-1536x1525.png 1536w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-2048x2033.png 2048w, https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-272x270.png 272w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003cfigcaption id=\"caption-attachment-21256\" class=\"wp-caption-text\"\u003e图片来源：\u003ca href=\"https://gophersource.com/\" target=\"_blank\" rel=\"noopener\"\u003eGopherSource\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e反转控制\u003ca title=\"IoC - Inversion of Control\" href=\"https://en.wikipedia.org/wiki/Inversion_of_control\" target=\"_blank\" rel=\"noopener\"\u003eIoC – Inversion of Control\u003c/a\u003e 是一种软件设计的方法，其主要的思想是把控制逻辑与业务逻辑分享，不要在业务逻辑里写控制逻辑，这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。在《\u003ca href=\"https://coolshell.cn/articles/9949.html\" target=\"_blank\" rel=\"noopener\"\u003eIoC/DIP其实是一种管理思想\u003c/a\u003e》中的那个开关和电灯的示例一样，开关是控制逻辑，电器是业务逻辑，不要在电器中实现开关，而是把开关抽象成一种协议，让电器都依赖之。这样的编程方式可以有效的降低程序复杂度，并提升代码重用。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第4 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式：委托和反转控制\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21146.html\" rel=\"prev\" title=\"Go 编程模式：Functional Options\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" rel=\"next\" title=\"Go编程模式：Map-Reduce\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cp\u003e面向对象的设计模式这里不提了，我们来看看Go语言使用Embed结构的一个示例。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21214\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E5%B5%8C%E5%85%A5%E5%92%8C%E5%A7%94%E6%89%98\" title=\"嵌入和委托\"\u003e嵌入和委托\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5\" title=\"结构体嵌入\"\u003e结构体嵌入\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99\" title=\"方法重写\"\u003e方法重写\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E5%A4%9A%E6%80%81\" title=\"嵌入结构多态\"\u003e嵌入结构多态\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6\" title=\"反转控制\"\u003e反转控制\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E5%AE%9E%E7%8E%B0Undo%E5%8A%9F%E8%83%BD\" title=\"实现Undo功能\"\u003e实现Undo功能\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E5%8F%8D%E8%BD%AC%E4%BE%9D%E8%B5%96\" title=\"反转依赖\"\u003e反转依赖\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B5%8C%E5%85%A5%E5%92%8C%E5%A7%94%E6%89%98\"\u003e\u003c/span\u003e嵌入和委托\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%93%E6%9E%84%E4%BD%93%E5%B5%8C%E5%85%A5\"\u003e\u003c/span\u003e结构体嵌入\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e在Go语言中，我们可以很方便的把一个结构体给嵌到另一个结构体中。如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Widget struct {\n    X, Y int\n}\ntype Label struct {\n    Widget        // Embedding (delegation)\n    Text   string // Aggregation\n}\u003c/pre\u003e\n\u003cp\u003e上面的示例中，我们把 \u003ccode\u003eWidget\u003c/code\u003e嵌入到了 \u003ccode\u003eLabel\u003c/code\u003e 中，于是，我们可以这样使用：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003elabel := Label{Widget{10, 10}, \u0026#34;State:\u0026#34;}\n\nlabel.X = 11\nlabel.Y = 12\u003c/pre\u003e\n\u003cp\u003e如果在 \u003ccode\u003eLabel\u003c/code\u003e 结构体里出现了重名，就需要解决重名，例如，如果 成员 \u003ccode\u003eX\u003c/code\u003e 重名，用 \u003ccode\u003elabel.X\u003c/code\u003e表明 是自己的\u003ccode\u003eX\u003c/code\u003e ，用  \u003ccode\u003elabel.Wedget.X\u003c/code\u003e 表示嵌入过来的。\u003c/p\u003e\n\u003cp\u003e有了这样的嵌入，就可以像UI组件一样的在结构构的设计上进行层层分解。比如，我可以新出来两个结构体 \u003ccode\u003eButton\u003c/code\u003e 和 \u003ccode\u003eListBox\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Button struct {\n    Label // Embedding (delegation)\n}\n\ntype ListBox struct {\n    Widget          // Embedding (delegation)\n    Texts  []string // Aggregation\n    Index  int      // Aggregation\n}\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99\"\u003e\u003c/span\u003e方法重写\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e然后，我们需要两个接口 \u003ccode\u003ePainter\u003c/code\u003e 用于把组件画出来，\u003ccode\u003eClicker\u003c/code\u003e 用于表明点击事件：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Painter interface {\n    Paint()\n}\n \ntype Clicker interface {\n    Click()\n}\u003c/pre\u003e\n\u003cp\u003e当然，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于 \u003ccode\u003eLable\u003c/code\u003e 来说，只有 \u003ccode\u003ePainter\u003c/code\u003e ，没有\u003ccode\u003eClicker\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e对于 \u003ccode\u003eButton\u003c/code\u003e 和 \u003ccode\u003eListBox\u003c/code\u003e来说，\u003ccode\u003ePainter\u003c/code\u003e 和\u003ccode\u003eClicker\u003c/code\u003e都有。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面是一些实现：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc (label Label) Paint() {\n  fmt.Printf(\u0026#34;%p:Label.Paint(%q)\\n\u0026#34;, \u0026amp;label, label.Text)\n}\n\n//因为这个接口可以通过 Label 的嵌入带到新的结构体，\n//所以，可以在 Button 中可以重载这个接口方法以\nfunc (button Button) Paint() { // Override\n    fmt.Printf(\u0026#34;Button.Paint(%s)\\n\u0026#34;, button.Text)\n}\nfunc (button Button) Click() {\n    fmt.Printf(\u0026#34;Button.Click(%s)\\n\u0026#34;, button.Text)\n}\n\n\nfunc (listBox ListBox) Paint() {\n    fmt.Printf(\u0026#34;ListBox.Paint(%q)\\n\u0026#34;, listBox.Texts)\n}\nfunc (listBox ListBox) Click() {\n    fmt.Printf(\u0026#34;ListBox.Click(%q)\\n\u0026#34;, listBox.Texts)\n}\u003c/pre\u003e\n\u003cp\u003e这里，需要重点提示一下，\u003cstrong\u003e\u003ccode\u003eButton.Paint()\u003c/code\u003e 接口可以通过 Label 的嵌入带到新的结构体，如果 \u003ccode\u003eButton.Paint()\u003c/code\u003e 不实现的话，会调用 \u003ccode\u003eLabel.Paint()\u003c/code\u003e ，所以，在 \u003ccode\u003eButton\u003c/code\u003e 中声明 \u003ccode\u003ePaint()\u003c/code\u003e 方法，相当于Override\u003c/strong\u003e。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B5%8C%E5%85%A5%E7%BB%93%E6%9E%84%E5%A4%9A%E6%80%81\"\u003e\u003c/span\u003e嵌入结构多态\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e通过下面的程序可以看到，整个多态是怎么执行的。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ebutton1 := Button{Label{Widget{10, 70}, \u0026#34;OK\u0026#34;}}\nbutton2 := NewButton(50, 70, \u0026#34;Cancel\u0026#34;)\nlistBox := ListBox{Widget{10, 40}, \n    []string{\u0026#34;AL\u0026#34;, \u0026#34;AK\u0026#34;, \u0026#34;AZ\u0026#34;, \u0026#34;AR\u0026#34;}, 0}\n\nfor _, painter := range []Painter{label, listBox, button1, button2} {\n    painter.Paint()\n}\n \nfor _, widget := range []interface{}{label, listBox, button1, button2} {\n  widget.(Painter).Paint()\n  if clicker, ok := widget.(Clicker); ok {\n    clicker.Click()\n  }\n  fmt.Println() // print a empty line \n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，我们可以使用接口来多态，也可以使用 泛型的 \u003ccode\u003einterface{}\u003c/code\u003e 来多态，但是需要有一个类型转换。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%8D%E8%BD%AC%E6%8E%A7%E5%88%B6\"\u003e\u003c/span\u003e反转控制\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们再来看一个示例，我们有一个存放整数的数据结构，如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype IntSet struct {\n    data map[int]bool\n}\nfunc NewIntSet() IntSet {\n    return IntSet{make(map[int]bool)}\n}\nfunc (set *IntSet) Add(x int) {\n    set.data[x] = true\n}\nfunc (set *IntSet) Delete(x int) {\n    delete(set.data, x)\n}\nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\u003c/pre\u003e\n\u003cp\u003e其中实现了 \u003ccode\u003eAdd()\u003c/code\u003e 、\u003ccode\u003eDelete()\u003c/code\u003e 和 \u003ccode\u003eContains()\u003c/code\u003e 三个操作，前两个是写操作，后一个是读操作。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%AE%9E%E7%8E%B0Undo%E5%8A%9F%E8%83%BD\"\u003e\u003c/span\u003e实现Undo功能\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e现在我们想实现一个 Undo 的功能。我们可以把把 \u003ccode\u003eIntSet\u003c/code\u003e 再包装一下变成 \u003ccode\u003eUndoableIntSet\u003c/code\u003e 代码如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype UndoableIntSet struct { // Poor style\n    IntSet    // Embedding (delegation)\n    functions []func()\n}\n \nfunc NewUndoableIntSet() UndoableIntSet {\n    return UndoableIntSet{NewIntSet(), nil}\n}\n \n\nfunc (set *UndoableIntSet) Add(x int) { // Override\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.functions = append(set.functions, func() { set.Delete(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\n\nfunc (set *UndoableIntSet) Delete(x int) { // Override\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.functions = append(set.functions, func() { set.Add(x) })\n    } else {\n        set.functions = append(set.functions, nil)\n    }\n}\n\nfunc (set *UndoableIntSet) Undo() error {\n    if len(set.functions) == 0 {\n        return errors.New(\u0026#34;No functions to undo\u0026#34;)\n    }\n    index := len(set.functions) - 1\n    if function := set.functions[index]; function != nil {\n        function()\n        set.functions[index] = nil // For garbage collection\n    }\n    set.functions = set.functions[:index]\n    return nil\n}\u003c/pre\u003e\n\u003cp\u003e在上面的代码中，我们可以看到\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们在 \u003ccode\u003eUndoableIntSet\u003c/code\u003e 中嵌入了\u003ccode\u003eIntSet\u003c/code\u003e ，然后Override了 它的 \u003ccode\u003eAdd()\u003c/code\u003e和 \u003ccode\u003eDelete()\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eContains()\u003c/code\u003e 方法没有Override，所以，会被带到 \u003ccode\u003eUndoableInSet\u003c/code\u003e 中来了。\u003c/li\u003e\n\u003cli\u003e在Override的 \u003ccode\u003eAdd()\u003c/code\u003e中，记录 \u003ccode\u003eDelete\u003c/code\u003e 操作\u003c/li\u003e\n\u003cli\u003e在Override的 \u003ccode\u003eDelete()\u003c/code\u003e 中，记录 \u003ccode\u003eAdd\u003c/code\u003e 操作\u003c/li\u003e\n\u003cli\u003e在新加入 \u003ccode\u003eUndo()\u003c/code\u003e 中进行Undo操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e通过这样的方式来为已有的代码扩展新的功能是一个很好的选择，这样，可以在重用原有代码功能和重新新的功能中达到一个平衡。但是，这种方式最大的问题是，Undo操作其实是一种控制逻辑，并不是业务逻辑，所以，在复用 Undo这个功能上是有问题。因为其中加入了大量跟 \u003ccode\u003eIntSet\u003c/code\u003e 相关的业务逻辑。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%8D%E8%BD%AC%E4%BE%9D%E8%B5%96\"\u003e\u003c/span\u003e反转依赖\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e现在我们来看另一种方法：\u003c/p\u003e\n\u003cp\u003e我们先声明一种函数接口，表现我们的Undo控制可以接受的函数签名是什么样的：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Undo []func()\u003c/pre\u003e\n\u003cp\u003e有了上面这个协议后，我们的Undo控制逻辑就可以写成如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc (undo *Undo) Add(function func()) {\n  *undo = append(*undo, function)\n}\n\nfunc (undo *Undo) Undo() error {\n  functions := *undo\n  if len(functions) == 0 {\n    return errors.New(\u0026#34;No functions to undo\u0026#34;)\n  }\n  index := len(functions) - 1\n  if function := functions[index]; function != nil {\n    function()\n    functions[index] = nil // For garbage collection\n  }\n  *undo = functions[:index]\n  return nil\n}\u003c/pre\u003e\n\u003cp\u003e这里你不必觉得奇怪， \u003ccode\u003eUndo\u003c/code\u003e 本来就是一个类型，不必是一个结构体，是一个函数数组也没什么问题。\u003c/p\u003e\n\u003cp\u003e然后，我们在我们的IntSet里嵌入 Undo，然后，再在 \u003ccode\u003eAdd()\u003c/code\u003e 和 \u003ccode\u003eDelete()\u003c/code\u003e 里使用上面的方法，就可以完成功能。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"3\"\u003etype IntSet struct {\n    data map[int]bool\n    undo Undo\n}\n \nfunc NewIntSet() IntSet {\n    return IntSet{data: make(map[int]bool)}\n}\n\nfunc (set *IntSet) Undo() error {\n    return set.undo.Undo()\n}\n \nfunc (set *IntSet) Contains(x int) bool {\n    return set.data[x]\n}\n\nfunc (set *IntSet) Add(x int) {\n    if !set.Contains(x) {\n        set.data[x] = true\n        set.undo.Add(func() { set.Delete(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\n \nfunc (set *IntSet) Delete(x int) {\n    if set.Contains(x) {\n        delete(set.data, x)\n        set.undo.Add(func() { set.Add(x) })\n    } else {\n        set.undo.Add(nil)\n    }\n}\u003c/pre\u003e\n\u003cp\u003e这个就是控制反转，不再由 控制逻辑 \u003ccode\u003eUndo\u003c/code\u003e 来依赖业务逻辑 \u003ccode\u003eIntSet\u003c/code\u003e，而是由业务逻辑 \u003ccode\u003eIntSet\u003c/code\u003e 来依赖 \u003ccode\u003eUndo\u003c/code\u003e 。其依赖的是其实是一个协议，这个协议是一个没有参数的函数数组。我们也可以看到，我们 Undo 的代码就可以复用了。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21214\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"ec8adda080\"\u003e\u003cimg id=\"rating_21214_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21214, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-d412ad25f3c36fee8b6dd053-=\"\"/\u003e\u003cimg id=\"rating_21214_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21214, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-d412ad25f3c36fee8b6dd053-=\"\"/\u003e\u003cimg id=\"rating_21214_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21214, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-d412ad25f3c36fee8b6dd053-=\"\"/\u003e\u003cimg id=\"rating_21214_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21214, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-d412ad25f3c36fee8b6dd053-=\"\"/\u003e\u003cimg id=\"rating_21214_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21214, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-d412ad25f3c36fee8b6dd053-=\"\"/\u003e (\u003cstrong\u003e40\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.05\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21214_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式：委托和反转控制\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式：委托和反转控制\"/\u003e\u003cmeta itemprop=\"description\" content=\"\n\n反转控制IoC - Inversion of Control 是一种软件设计的方法，其主要的思想是把控制逻辑与业务逻辑分享，不要在业务逻辑里写控制逻辑，这样会让控制逻辑依赖于业务逻辑，而是反过来，让业务逻辑依赖控制逻辑。在《IoC/DIP其实是一种管理思想》中的那个开关和电灯的示例一样，开关是控制逻辑，电器是业务逻辑，不要在电器中实现开关，而是把开关抽象成一种协议，让电器都依赖之。这样的编程方...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-26T16:57:48+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-28T10:57:06+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21214.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21214.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.05\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"40\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21214-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-26T16:57:48+08:00",
  "Author": "陈皓"
}