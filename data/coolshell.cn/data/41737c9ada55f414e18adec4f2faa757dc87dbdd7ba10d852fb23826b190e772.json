{
  "Source": "coolshell.cn",
  "Title": "Go 编程模式：Go Generation",
  "Link": "https://coolshell.cn/articles/21179.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"f2a9df5fbe1024f114f1a5bf-text/javascript\"\u003e\u003c/script\u003e\u003c/p\u003e\u003cfigure id=\"attachment_21254\" aria-describedby=\"caption-attachment-21254\" style=\"width: 296px\" class=\"wp-caption alignright\"\u003e\u003cimg decoding=\"async\" class=\"wp-image-21254 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-296x300.png\" alt=\"\" width=\"296\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-296x300.png 296w, https://coolshell.cn/wp-content/uploads/2020/12/go.generate-1011x1024.png 1011w, https://coolshell.cn/wp-content/uploads/2020/12/go.generate-768x778.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.generate-1516x1536.png 1516w, https://coolshell.cn/wp-content/uploads/2020/12/go.generate-267x270.png 267w, https://coolshell.cn/wp-content/uploads/2020/12/go.generate.png 1524w\" sizes=\"(max-width: 296px) 100vw, 296px\"/\u003e\u003cfigcaption id=\"caption-attachment-21254\" class=\"wp-caption-text\"\u003e图片来源：\u003ca href=\"https://gophersource.com/\" target=\"_blank\" rel=\"noopener\"\u003eGopherSource\u003c/a\u003e\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e在本篇文章中，我们将要学习一下Go语言的代码生成的玩法。Go语言代码生成主要还是用来解决编程泛型的问题，泛型编程主要解决的问题是因为静态类型语言有类型，所以，相关的算法或是对数据处理的程序会因为类型不同而需要复制一份，这样导致数据类型和算法功能耦合的问题。泛型编程可以解决这样的问题，就是说，在写代码的时候，不用关心处理数据的类型，只需要关心相当处理逻辑。泛型编程是静态语言中非常非常重要的特征，如果没有泛型，我们很难做到多态，也很难完成抽象，会导致我们的代码冗余量很大。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第6 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo 编程模式：Go Generation\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21164.html\" rel=\"prev\" title=\"Go编程模式：Map-Reduce\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\" rel=\"next\" title=\"Go编程模式：修饰器\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94\" title=\"现实中的类比\"\u003e现实中的类比\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Go%E8%AF%AD%E6%96%B9%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5\" title=\"Go语方的类型检查\"\u003eGo语方的类型检查\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Type_Assert\" title=\"Type Assert\"\u003eType Assert\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Reflection\" title=\"Reflection\"\u003eReflection\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3\" title=\"它山之石\"\u003e它山之石\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Go_Generator\" title=\"Go Generator\"\u003eGo Generator\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF\" title=\"函数模板\"\u003e函数模板\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC\" title=\"函数生成脚本\"\u003e函数生成脚本\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81\" title=\"生成代码\"\u003e生成代码\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E6%96%B0%E7%89%88Filter\" title=\"新版Filter\"\u003e新版Filter\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-11\" href=\"#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7\" title=\"第三方工具\"\u003e第三方工具\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%8E%B0%E5%AE%9E%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%AF%94\"\u003e\u003c/span\u003e现实中的类比\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e举个现实当中的例子，用螺丝刀来做具比方，螺丝刀本来就是一个拧螺丝的动作，但是因为螺丝的类型太多，有平口的，有十字口的，有六角的……螺丝还有大小尺寸，导致我们的螺丝刀为了要适配各种千奇百怪的螺丝类型（样式和尺寸），导致要做出各种各样的螺丝刀。\u003c/p\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-21180 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/type01-300x225.png\" alt=\"\" width=\"300\" height=\"225\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/type01-300x225.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/type01-360x270.png 360w, https://coolshell.cn/wp-content/uploads/2020/12/type01.png 750w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-21181 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/type02-300x225.png\" alt=\"\" width=\"300\" height=\"225\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/type02-300x225.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/type02-768x576.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/type02-360x270.png 360w, https://coolshell.cn/wp-content/uploads/2020/12/type02.png 802w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e而真正的抽象是螺丝刀不应该关心螺丝的类型，只要关注好自己的功能是否完备，并让自己可以适配于不同类型的螺丝，如下所示，这就是所谓的泛型编程要解决的实际问题。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21179\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd colspan=\"2\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-21182 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/type03-300x226.png\" alt=\"\" width=\"300\" height=\"226\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/type03-300x226.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/type03-359x270.png 359w, https://coolshell.cn/wp-content/uploads/2020/12/type03.png 750w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Go%E8%AF%AD%E6%96%B9%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5\"\u003e\u003c/span\u003eGo语方的类型检查\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e因为Go语言目前并不支持真正的泛型，所以，只能用 \u003ccode\u003einterface{}\u003c/code\u003e 这样的类似于 \u003ccode\u003evoid*\u003c/code\u003e 这种过度泛型来玩这就导致了我们在实际过程中就需要进行类型检查。Go语言的类型检查有两种技术，一种是 Type Assert，一种是Reflection。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Type_Assert\"\u003e\u003c/span\u003eType Assert\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这种技术，一般是对某个变量进行 \u003ccode\u003e.(type)\u003c/code\u003e的转型操作，其会返回两个值， \u003ccode\u003evariable, error\u003c/code\u003e，第一个返回值是被转换好的类型，第二个是如果不能转换类型，则会报错。\u003c/p\u003e\n\u003cp\u003e比如下面的示例，我们有一个通用类型的容器，可以进行 \u003ccode\u003ePut(val)\u003c/code\u003e和 \u003ccode\u003eGet()\u003c/code\u003e，注意，其使用了 \u003ccode\u003einterface{}\u003c/code\u003e作泛型\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003e//Container is a generic container, accepting anything.\ntype Container []interface{}\n\n//Put adds an element to the container.\nfunc (c *Container) Put(elem interface{}) {\n    *c = append(*c, elem)\n}\n//Get gets an element from the container.\nfunc (c *Container) Get() interface{} {\n    elem := (*c)[0]\n    *c = (*c)[1:]\n    return elem\n}\u003c/pre\u003e\n\u003cp\u003e在使用中，我们可以这样使用\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eintContainer := \u0026amp;Container{}\nintContainer.Put(7)\nintContainer.Put(42)\u003c/pre\u003e\n\u003cp\u003e但是，在把数据取出来时，因为类型是 \u003ccode\u003einterface{}\u003c/code\u003e ，所以，你还要做一个转型，如果转型成功能才能进行后续操作（因为 \u003ccode\u003einterface{}\u003c/code\u003e太泛了，泛到什么类型都可以放）下在是一个Type Assert的示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"2\"\u003e// assert that the actual type is int\nelem, ok := intContainer.Get().(int)\nif !ok {\n    fmt.Println(\u0026#34;Unable to read an int from intContainer\u0026#34;)\n}\n\nfmt.Printf(\u0026#34;assertExample: %d (%T)\\n\u0026#34;, elem, elem)\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Reflection\"\u003e\u003c/span\u003eReflection\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e对于反射，我们需要把上面的代码修改如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Container struct {\n    s reflect.Value\n}\nfunc NewContainer(t reflect.Type, size int) *Container {\n    if size \u0026lt;=0  { size=64 }\n    return \u0026amp;Container{\n        s: reflect.MakeSlice(reflect.SliceOf(t), 0, size), \n    }\n}\nfunc (c *Container) Put(val interface{})  error {\n    if reflect.ValueOf(val).Type() != c.s.Type().Elem() {\n        return fmt.Errorf(“Put: cannot put a %T into a slice of %s\u0026#34;, \n            val, c.s.Type().Elem()))\n    }\n    c.s = reflect.Append(c.s, reflect.ValueOf(val))\n    return nil\n}\nfunc (c *Container) Get(refval interface{}) error {\n    if reflect.ValueOf(refval).Kind() != reflect.Ptr ||\n        reflect.ValueOf(refval).Elem().Type() != c.s.Type().Elem() {\n        return fmt.Errorf(\u0026#34;Get: needs *%s but got %T\u0026#34;, c.s.Type().Elem(), refval)\n    }\n    reflect.ValueOf(refval).Elem().Set( c.s.Index(0) )\n    c.s = c.s.Slice(1, c.s.Len())\n    return nil\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码并不难读，这是完全使用 reflection的玩法，其中\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 \u003ccode\u003eNewContainer()\u003c/code\u003e会根据参数的类型初始化一个Slice\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003ePut()\u003c/code\u003e时候，会检查 \u003ccode\u003eval\u003c/code\u003e 是否和Slice的类型一致。\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003eGet()\u003c/code\u003e时，我们需要用一个入参的方式，因为我们没有办法返回 \u003ccode\u003ereflect.Value\u003c/code\u003e 或是 \u003ccode\u003einterface{}\u003c/code\u003e，不然还要做Type Assert\u003c/li\u003e\n\u003cli\u003e但是有类型检查，所以，必然会有检查不对的道理 ，因此，需要返回 \u003ccode\u003eerror\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e于是在使用上面这段代码的时候，会是下面这个样子：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003ef1 := 3.1415926\nf2 := 1.41421356237\n\nc := NewMyContainer(reflect.TypeOf(f1), 16)\n\nif err := c.Put(f1); err != nil {\n  panic(err)\n}\nif err := c.Put(f2); err != nil {\n  panic(err)\n}\n\ng := 0.0\n\nif err := c.Get(\u0026amp;g); err != nil {\n  panic(err)\n}\nfmt.Printf(\u0026#34;%v (%T)\\n\u0026#34;, g, g) //3.1415926 (float64)\nfmt.Println(c.s.Index(0)) //1.4142135623\u003c/pre\u003e\n\u003cp\u003e我们可以看到，Type Assert是不用了，但是用反射写出来的代码还是有点复杂的。那么有没有什么好的方法？\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%AE%83%E5%B1%B1%E4%B9%8B%E7%9F%B3\"\u003e\u003c/span\u003e它山之石\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e对于泛型编程最牛的语言 C++ 来说，这类的问题都是使用 Template来解决的。\u003c/p\u003e\n\u003ctable style=\"border: 0px;\"\u003e\n\u003ctbody\u003e\n\u003ctr style=\"background: none;\"\u003e\n\u003ctd style=\"border: 0px;\"\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\"\u003e//用\u0026lt;class T\u0026gt;来描述泛型\ntemplate \u0026lt;class T\u0026gt; \nT GetMax (T a, T b)  { \n    T result; \n    result = (a\u0026gt;b)? a : b; \n    return (result); \n} \n\u003c/pre\u003e\n\u003c/td\u003e\n\u003ctd style=\"border: 0px;\"\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\"\u003eint i=5, j=6, k; \n//生成int类型的函数\nk=GetMax\u0026lt;int\u0026gt;(i,j);\n \nlong l=10, m=5, n; \n//生成long类型的函数\nn=GetMax\u0026lt;long\u0026gt;(l,m); \n\u003c/pre\u003e\n\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003eC++的编译器会在编译时分析代码，根据不同的变量类型来自动化的生成相关类型的函数或类。C++叫模板的具体化。\u003c/p\u003e\n\u003cp\u003e这个技术是编译时的问题，所以，不需要我们在运行时进行任何的运行的类型识别，我们的程序也会变得比较的干净。\u003c/p\u003e\n\u003cp\u003e那么，我们是否可以在Go中使用C++的这种技术呢？答案是肯定的，只是Go的编译器不帮你干，你需要自己动手。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Go_Generator\"\u003e\u003c/span\u003eGo Generator\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e要玩 Go的代码生成，你需要三件事：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e一个函数模板，其中设置好相应的占位符。\u003c/li\u003e\n\u003cli\u003e一个脚本，用于按规则来替换文本并生成新的代码。\u003c/li\u003e\n\u003cli\u003e一行注释代码。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF\"\u003e\u003c/span\u003e函数模板\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e我们把我们之前的示例改成模板。取名为 \u003ccode\u003econtainer.tmp.go\u003c/code\u003e 放在 \u003ccode\u003e./template/\u003c/code\u003e下\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage PACKAGE_NAME\ntype GENERIC_NAMEContainer struct {\n    s []GENERIC_TYPE\n}\nfunc NewGENERIC_NAMEContainer() *GENERIC_NAMEContainer {\n    return \u0026amp;GENERIC_NAMEContainer{s: []GENERIC_TYPE{}}\n}\nfunc (c *GENERIC_NAMEContainer) Put(val GENERIC_TYPE) {\n    c.s = append(c.s, val)\n}\nfunc (c *GENERIC_NAMEContainer) Get() GENERIC_TYPE {\n    r := c.s[0]\n    c.s = c.s[1:]\n    return r\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到函数模板中我们有如下的占位符：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePACKAGE_NAME\u003c/code\u003e – 包名\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGENERIC_NAME\u003c/code\u003e – 名字\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGENERIC_TYPE\u003c/code\u003e – 实际的类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其它的代码都是一样的。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%87%BD%E6%95%B0%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC\"\u003e\u003c/span\u003e函数生成脚本\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e然后，我们有一个叫\u003ccode\u003egen.sh\u003c/code\u003e的生成脚本，如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\" data-enlighter-title=\"gen.sh\"\u003e#!/bin/bash\n\nset -e\n\nSRC_FILE=${1}\nPACKAGE=${2}\nTYPE=${3}\nDES=${4}\n#uppcase the first char\nPREFIX=\u0026#34;$(tr \u0026#39;[:lower:]\u0026#39; \u0026#39;[:upper:]\u0026#39; \u0026lt;\u0026lt;\u0026lt; ${TYPE:0:1})${TYPE:1}\u0026#34;\n\nDES_FILE=$(echo ${TYPE}| tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;)_${DES}.go\n\nsed \u0026#39;s/PACKAGE_NAME/\u0026#39;\u0026#34;${PACKAGE}\u0026#34;\u0026#39;/g\u0026#39; ${SRC_FILE} | \\\n    sed \u0026#39;s/GENERIC_TYPE/\u0026#39;\u0026#34;${TYPE}\u0026#34;\u0026#39;/g\u0026#39; | \\\n    sed \u0026#39;s/GENERIC_NAME/\u0026#39;\u0026#34;${PREFIX}\u0026#34;\u0026#39;/g\u0026#39; \u0026gt; ${DES_FILE}\u003c/pre\u003e\n\u003cp\u003e其需要4个参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e模板源文件\u003c/li\u003e\n\u003cli\u003e包名\u003c/li\u003e\n\u003cli\u003e实际需要具体化的类型\u003c/li\u003e\n\u003cli\u003e用于构造目标文件名的后缀\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后其会用 \u003ccode\u003esed\u003c/code\u003e 命令去替换我们的上面的函数模板，并生成到目标文件中。（关于sed命令请参看本站的《\u003ca title=\"sed 简明教程\" href=\"https://coolshell.cn/articles/9104.html\" target=\"_blank\" rel=\"noopener\"\u003esed 简明教程\u003c/a\u003e》）\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81\"\u003e\u003c/span\u003e生成代码\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e接下来，我们只需要在代码中打一个特殊的注释：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"1,10\"\u003e//go:generate ./gen.sh ./template/container.tmp.go gen uint32 container\nfunc generateUint32Example() {\n    var u uint32 = 42\n    c := NewUint32Container()\n    c.Put(u)\n    v := c.Get()\n    fmt.Printf(\u0026#34;generateExample: %d (%T)\\n\u0026#34;, v, v)\n}\n\n//go:generate ./gen.sh ./template/container.tmp.go gen string container\nfunc generateStringExample() {\n    var s string = \u0026#34;Hello\u0026#34;\n    c := NewStringContainer()\n    c.Put(s)\n    v := c.Get()\n    fmt.Printf(\u0026#34;generateExample: %s (%T)\\n\u0026#34;, v, v)\n}\u003c/pre\u003e\n\u003cp\u003e其中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一个注释是生成包名为 \u003ccode\u003egen\u003c/code\u003e 类型为 \u003ccode\u003euint32\u003c/code\u003e 目标文件名以 \u003ccode\u003econtainer\u003c/code\u003e 为后缀\u003c/li\u003e\n\u003cli\u003e第二个注释是生成包名为 \u003ccode\u003egen\u003c/code\u003e 类型为 \u003ccode\u003estring\u003c/code\u003e 目标文件名以 \u003ccode\u003econtainer\u003c/code\u003e 为后缀\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后，在工程目录中直接执行 \u003ccode\u003e go generate\u003c/code\u003e 命令，就会生成如下两份代码，\u003c/p\u003e\n\u003cp\u003e一份文件名为\u003ccode\u003euint32_container.go\u003c/code\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\" data-enlighter-title=\"uint32_container.go\"\u003epackage gen\n\ntype Uint32Container struct {\n    s []uint32\n}\nfunc NewUint32Container() *Uint32Container {\n    return \u0026amp;Uint32Container{s: []uint32{}}\n}\nfunc (c *Uint32Container) Put(val uint32) {\n    c.s = append(c.s, val)\n}\nfunc (c *Uint32Container) Get() uint32 {\n    r := c.s[0]\n    c.s = c.s[1:]\n    return r\n}\u003c/pre\u003e\n\u003cp\u003e另一份的文件名为 \u003ccode\u003estring_container.go\u003c/code\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"cpp\" data-enlighter-title=\"string_container.go\"\u003epackage gen\n\ntype StringContainer struct {\n    s []string\n}\nfunc NewStringContainer() *StringContainer {\n    return \u0026amp;StringContainer{s: []string{}}\n}\nfunc (c *StringContainer) Put(val string) {\n    c.s = append(c.s, val)\n}\nfunc (c *StringContainer) Get() string {\n    r := c.s[0]\n    c.s = c.s[1:]\n    return r\n}\n\u003c/pre\u003e\n\u003cp\u003e这两份代码可以让我们的代码完全编译通过，所付出的代价就是需要多执行一步 \u003ccode\u003ego generate\u003c/code\u003e 命令。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%96%B0%E7%89%88Filter\"\u003e\u003c/span\u003e新版Filter\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e现在我们再回头看看我们之前《\u003ca href=\"https://coolshell.cn/articles/21164.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e》中的那些个用反射整出来的例子，有了这样的技术，我就不必在代码里用那些晦涩难懂的反射来做运行时的类型检查了。我们可以写下很干净的代码，让编译器在编译时检查类型对不对。下面是一个Fitler的模板文件 \u003ccode\u003efilter.tmp.go\u003c/code\u003e：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage PACKAGE_NAME\n\ntype GENERIC_NAMEList []GENERIC_TYPE\n\ntype GENERIC_NAMEToBool func(*GENERIC_TYPE) bool\n\nfunc (al GENERIC_NAMEList) Filter(f GENERIC_NAMEToBool) GENERIC_NAMEList {\n    var ret GENERIC_NAMEList\n    for _, a := range al {\n        if f(\u0026amp;a) {\n            ret = append(ret, a)\n        }\n    }\n    return ret\n}\n\u003c/pre\u003e\n\u003cp\u003e于是我们可在需要使用这个的地方，加上相关的 go generate 的注释\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\" data-enlighter-highlight=\"8\"\u003etype Employee struct {\n  Name     string\n  Age      int\n  Vacation int\n  Salary   int\n}\n\n//go:generate ./gen.sh ./template/filter.tmp.go gen Employee filter\nfunc filterEmployeeExample() {\n\n  var list = EmployeeList{\n    {\u0026#34;Hao\u0026#34;, 44, 0, 8000},\n    {\u0026#34;Bob\u0026#34;, 34, 10, 5000},\n    {\u0026#34;Alice\u0026#34;, 23, 5, 9000},\n    {\u0026#34;Jack\u0026#34;, 26, 0, 4000},\n    {\u0026#34;Tom\u0026#34;, 48, 9, 7500},\n  }\n\n  var filter EmployeeList\n  filter = list.Filter(func(e *Employee) bool {\n    return e.Age \u0026gt; 40\n  })\n\n  fmt.Println(\u0026#34;----- Employee.Age \u0026gt; 40 ------\u0026#34;)\n  for _, e := range filter {\n    fmt.Println(e)\n  }\n\n  filter = list.Filter(func(e *Employee) bool {\n    return e.Salary \u0026lt;= 5000\n  })\n\n  fmt.Println(\u0026#34;----- Employee.Salary \u0026lt;= 5000 ------\u0026#34;)\n  for _, e := range filter {\n    fmt.Println(e)\n  }\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%AC%AC%E4%B8%89%E6%96%B9%E5%B7%A5%E5%85%B7\"\u003e\u003c/span\u003e第三方工具\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们并不需要自己手写 \u003ccode\u003egen.sh\u003c/code\u003e 这样的工具类，已经有很多第三方的已经写好的可以使用。下面是一个列表：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGenny –  \u003ca href=\"https://github.com/cheekybits/genny\"\u003ehttps://github.com/cheekybits/genny\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGeneric – \u003ca href=\"https://github.com/taylorchu/generic\"\u003ehttps://github.com/taylorchu/generic\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGenGen – \u003ca href=\"https://github.com/joeshaw/gengen\"\u003ehttps://github.com/joeshaw/gengen\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eGen – \u003ca href=\"https://github.com/clipperhouse/gen\"\u003ehttps://github.com/clipperhouse/gen\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21179\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"9099ca4709\"\u003e\u003cimg id=\"rating_21179_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21179, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f2a9df5fbe1024f114f1a5bf-=\"\"/\u003e\u003cimg id=\"rating_21179_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21179, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f2a9df5fbe1024f114f1a5bf-=\"\"/\u003e\u003cimg id=\"rating_21179_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21179, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f2a9df5fbe1024f114f1a5bf-=\"\"/\u003e\u003cimg id=\"rating_21179_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21179, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f2a9df5fbe1024f114f1a5bf-=\"\"/\u003e\u003cimg id=\"rating_21179_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21179, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.6, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f2a9df5fbe1024f114f1a5bf-=\"\"/\u003e (\u003cstrong\u003e30\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.63\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21179_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go 编程模式：Go Generation\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go 编程模式：Go Generation\"/\u003e\u003cmeta itemprop=\"description\" content=\"\n\n在本篇文章中，我们将要学习一下Go语言的代码生成的玩法。Go语言代码生成主要还是用来解决编程泛型的问题，泛型编程主要解决的问题是因为静态类型语言有类型，所以，相关的算法或是对数据处理的程序会因为类型不同而需要复制一份，这样导致数据类型和算法功能耦合的问题。泛型编程可以解决这样的问题，就是说，在写代码的时候，不用关心处理数据的类型，只需要关心相当处理逻辑。泛型编程是静态语言中非常非常重要的特征，...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-25T17:06:36+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-28T10:57:50+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21179.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21179.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.63\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"30\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21179-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-25T17:06:36+08:00",
  "Author": "陈皓"
}