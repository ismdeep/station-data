{
  "Source": "coolshell.cn",
  "Title": "bash代码注入的安全漏洞",
  "Link": "https://coolshell.cn/articles/11973.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"a48a945e48f8c8b9f6e84555-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-medium wp-image-11979\" src=\"https://coolshell.cn/wp-content/uploads/2014/09/bashbug-300x152.jpg\" alt=\"bashbug\" width=\"300\" height=\"152\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/09/bashbug-300x152.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/09/bashbug.jpg 315w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e很多人或许对上半年发生的安全问题“心脏流血”（Heartbleed Bug）事件记忆颇深，这两天，又出现了另外一个“毁灭级”的漏洞——Bash软件安全漏洞。这个漏洞由法国GNU/Linux爱好者Stéphane Chazelas所发现。随后，美国电脑紧急应变中心（US-CERT）、红帽以及多家从事安全的公司于周三（北京时间9月24日）发出警告。 关于这个安全漏洞的细节可参看美国政府计算安全的这两个漏洞披露：\u003ca href=\"http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-6271\"\u003eCVE-2014-6271\u003c/a\u003e 和 \u003ca href=\"http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2014-7169\"\u003eCVE-2014-7169\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e这个漏洞其实是非常经典的“注入式攻击”，也就是可以向 bash注入一段命令，从bash1.14 到4.3都存在这样的漏洞。我们先来看一下这个安全问题的症状。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#Shellshock_CVE-2014-6271\" title=\"Shellshock (CVE-2014-6271)\"\u003eShellshock (CVE-2014-6271)\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#AfterShock_%E2%80%93_CVE-2014-7169_%EF%BC%88%E5%8F%88%E5%8F%ABIncomplete_fix_to_Shellshock%EF%BC%89\" title=\"AfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）\"\u003eAfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82\" title=\"原理和技术细节\"\u003e原理和技术细节\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#bash%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\" title=\"bash的环境变量\"\u003ebash的环境变量\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#bash%E7%9A%84%E5%87%BD%E6%95%B0\" title=\"bash的函数\"\u003ebash的函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#bash%E7%9A%84bug\" title=\"bash的bug\"\u003ebash的bug\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#bash%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%89%E5%A4%9A%E5%A4%A7\" title=\"bash漏洞的影响有多大\"\u003ebash漏洞的影响有多大\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%85%B3%E4%BA%8E_AfterShock_%E2%80%93_CVE-2014-7169_%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A\" title=\"关于 AfterShock – CVE-2014-7169 测试脚本的解释\"\u003e关于 AfterShock – CVE-2014-7169 测试脚本的解释\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Shellshock_CVE-2014-6271\"\u003e\u003c/span\u003eShellshock (CVE-2014-6271)\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是一个简单的测试：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ env VAR=\u0026#39;() { :;}; echo Bash is vulnerable!\u0026#39; bash -c \u0026#34;echo Bash Test\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e如果你发现上面这个命令在你的bash下有这样的输出，那你就说明你的bash是有漏洞的：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"1\"\u003eBash is vulnerable!\nBash Test\u003c/pre\u003e\n\u003cp\u003e简单地看一下，其实就是向环境变量中注入了一段代码 \u003cstrong\u003eecho Bash is vulnerable\u003c/strong\u003e。关于其中的原理我会在后面给出。\u003c/p\u003e\n\u003cp\u003e很快，CVE-2014-6271的官方补丁出来的了——\u003ca href=\"https://lists.gnu.org/archive/html/bug-bash/2014-09/msg00081.html\" target=\"_blank\"\u003eBash-4.3 Official Patch 25\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11973\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"AfterShock_%E2%80%93_CVE-2014-7169_%EF%BC%88%E5%8F%88%E5%8F%ABIncomplete_fix_to_Shellshock%EF%BC%89\"\u003e\u003c/span\u003eAfterShock – CVE-2014-7169 （又叫Incomplete fix to Shellshock）\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e但随后，马上有人在Twitter上发贴——\u003ca href=\"https://twitter.com/taviso/statuses/514887394294652929\" target=\"_blank\"\u003e说这是一个不完整的fix\u003c/a\u003e，并给出了相关的攻击方法。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://twitter.com/taviso/statuses/514887394294652929\" target=\"_blank\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-medium wp-image-11974\" src=\"https://coolshell.cn/wp-content/uploads/2014/09/bash-300x153.jpg\" alt=\"\" width=\"300\" height=\"153\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/09/bash-300x153.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/09/bash.jpg 582w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e也就是下面这段测试代码（注意，其中的sh在linux下等价于bash）：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eenv X=\u0026#39;() { (a)=\u0026gt;\\\u0026#39; sh -c \u0026#34;echo date\u0026#34;; cat echo\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e上面这段代码运行起来会报错，但是它要的就是报错，报错后会在你在当前目录下生成一个echo的文件，这个文件的内容是一个时间文本。下面是上面 这段命令执行出来的样子。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ env X=\u0026#39;() { (a)=\u0026gt;\\\u0026#39; sh -c \u0026#34;echo date\u0026#34;; cat echo\nsh: X: line 1: syntax error near unexpected token `=\u0026#39;\nsh: X: line 1: `\u0026#39;\nsh: error importing function definition for `X\u0026#39;\nSat Sep 27 22:06:29 CST 2014\u003c/pre\u003e\n\u003cp\u003e这段测试脚本代码相当的诡异，就像“天书”一样，我会在后面详细说明这段代码的原理。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8E%9F%E7%90%86%E5%92%8C%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82\"\u003e\u003c/span\u003e原理和技术细节\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e要说清楚这个原理和细节，我们需要从 bash的环境变量开始说起。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"bash%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\"\u003e\u003c/span\u003ebash的环境变量\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e环境变量大家知道吧，这个不用我普及了吧。环境变量是操作系统运行shell中的变量，很多程序会通过环境变量改变自己的执行行为。在bash中要定义一个环境变量的语法很简单（注：=号的前后不能有空格）：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ var=\u0026#34;hello world\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e然后你就可以使用这个变量了，比如：echo $var什么的。但是，我们要知道，这个变量只是一个当前shell的“局部变量”，只在当前的shell进程中可以访问，这个shell进程fork出来的进程是访问不到的。\u003c/p\u003e\n\u003cp\u003e你可以做这样的测试：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ var=\u0026#34;hello coolshell\u0026#34;\n$ echo $var\nhello coolshell\n$ bash\n$ echo $var\n\u003c/pre\u003e\n\u003cp\u003e上面的测试中，第三个命令执行了一个bash，也就是开了一个bash的子进程，你就会发现var不能访问了。\u003c/p\u003e\n\u003cp\u003e为了要让shell的子进程可以访问，我们需要export一下：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ export var=\u0026#34;hello coolshell\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这样，这个环境变量就会在其子进程中可见了。\u003c/p\u003e\n\u003cp\u003e如果你要查看一下有哪些环境变量可以在子进程中可见（也就是是否被export了），你可使用\u003cstrong\u003eenv\u003c/strong\u003e命令。不过，env命令也可以用来定义export的环境变量。如下所示：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ env var=\u0026#34;hello haoel\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e有了这些基础知识还不够，我们还要知道一个基础知识——shell的函数。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"bash%E7%9A%84%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003ebash的函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e在bash下定义一个函数很简单，如下所示：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ foo(){ echo \u0026#34;hello coolshell\u0026#34;; }\n$ foo\nhello coolshell\u003c/pre\u003e\n\u003cp\u003e有了上面的环境变量的基础知识后，你一定会想试试这个函数是否可以在子进程中调用，答案当然是不行的。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ foo(){ echo \u0026#34;hello coolshell\u0026#34;; }\n$ foo\nhello coolshell\n$ bash\n$ foo\nbash: foo: command not found\u003c/pre\u003e\n\u003cp\u003e你看，和环境变量是一样的，如果要在子进程中可以访问的话，那么，还是一样的，需要export，export有个参数 -f，意思是export一个函数。如：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"4\"\u003e$ foo(){ echo \u0026#34;hello coolshell\u0026#34;; }\n$ foo\nhello coolshell\n$ export -f foo\n$ bash\n$ foo\nhello coolshell\u003c/pre\u003e\n\u003cp\u003e好了，我讲了这么半天的基础知识，别烦，懂了这些，你才会很容易地理解这两个漏洞是怎么回事。\u003c/p\u003e\n\u003cp\u003e好，现在要进入正题。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"bash%E7%9A%84bug\"\u003e\u003c/span\u003ebash的bug\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e从上面我们可以看到，bash的变量和函数用了一模一样的机制，如果你用env命令看一下export出来的东西，你会看到上面我们定义的变量和函数都在，如下所示（我省略了其它的环境变量）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ env\nvar=hello coolshell\nfoo=() { echo \u0026#34;hello coolshell\u0026#34;\n}\u003c/pre\u003e\n\u003cp\u003e原来，都用同样的方式啊——\u003cstrong\u003e无论是函数还是变量都是变量啊\u003c/strong\u003e。于是，看都不用看bash的源代码，聪明的黑客就能猜得到——\u003cstrong\u003ebash判断一个环境变量是不是一个函数，就看它的值是否以”()”开始\u003c/strong\u003e。于是，一股邪念涌上心头。\u003c/p\u003e\n\u003cp\u003e黑客定义了这样的环境变量（注：() 和 { 间的空格不能少）：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ export X=\u0026#39;() { echo \u0026#34;inside X\u0026#34;; }; echo \u0026#34;outside X\u0026#34;;\u0026#39;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eenv一下，你会看到X已经在了：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ env\nX=(){ echo \u0026#34;inside X\u0026#34;; }; echo \u0026#34;outside X\u0026#34;;\u003c/pre\u003e\n\u003cp\u003e然后，\u003cstrong\u003e当我们在当前的bash shell进程下产生一个bash的子进程时，新的子进程会读取父进程的所有export的环境变量，并复制到自己的进程空间中，很明显，上面的X变量的函数的后面还注入了一条命令：echo “outside X”，这会在父进程向子进程复制的过程中被执行吗？\u003c/strong\u003e（关于fork相关的东西你可以看一下我以前写的《\u003ca title=\"一个fork的面试题\" href=\"https://coolshell.cn/articles/7965.html\" target=\"_blank\"\u003efork的一个面试题\u003c/a\u003e》）\u003c/p\u003e\n\u003cp\u003e答案是肯定的。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ export X=\u0026#39;() { echo \u0026#34;inside X\u0026#34;; }; echo \u0026#34;outside X\u0026#34;;\u0026#39;\n$ bash\noutside X\u003c/pre\u003e\n\u003cp\u003e你看，一个代码注入就这样完成了。这就是bash的bug—— \u003cstrong\u003e函数体外面的代码被默认地执行了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e我们并不一定非要像上面那样创建另一个bash的子进程，我们可以使用bash -c的参数来执行一个bash子进程命令。就像这个安全漏洞的测试脚本一样：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eenv VAR=\u0026#39;() { :;}; echo Bash is vulnerable!\u0026#39; bash -c \u0026#34;echo Bash Test\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，() { :;} 中的冒号就相当于/bin/true，返回true并退出。而bash -c其实就是在spawn一个bash的echo的子进程，用于触发函数体外的echo命令。所以，更为友好一点的测试脚本应该是：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eenv VAR=\u0026#39;() { :;}; echo Bash is vulnerable!\u0026#39; bash -c \u0026#34;echo 如果你看到了vulnerable字样说明你的bash有安全问题\u0026#34;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eOK，你应该明白这个漏洞是怎么一回事了吧。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"bash%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%BD%B1%E5%93%8D%E6%9C%89%E5%A4%9A%E5%A4%A7\"\u003e\u003c/span\u003ebash漏洞的影响有多大\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在网上看到好多人说这个漏洞不大，还说这个事只有那些陈旧的执行CGI脚本的网站才会有，现在已经没有网站用CGI了。我靠，这真是无知者无畏啊。\u003c/p\u003e\n\u003cp\u003e我举个例子，如果你的网站中有调用操作系统的shell命令，比如你用PHP执行个exec之类的东西。这样的需求是有的，特别是对于一些需要和操作系统交互的重要的后台用于系统管理的程序。于是就会开一个bash的进程来执行。\u003c/p\u003e\n\u003cp\u003e我们还知道，现在的HTTP服务器基本上都是以子进程式的，所以，其中必然会存在export 一些环境变量的事，而有的环境变量的值是从用户端来的，比如：HTTP_USER_AGENT这样的环境变量，只由浏览器发出的。其实这个变量你想写成什么就写成什么。\u003c/p\u003e\n\u003cp\u003e于是，我可以把这个HTTP_USER_AGENT的环境变量设置成上述的测试脚本，只不过，我会把echo Bash is vulnerable!这个东西换成别的更为凶残的命令。呵呵。\u003c/p\u003e\n\u003cp\u003e关于这个漏洞会影响哪些已有的系统，你可以自己Google，几乎所有的报告这个漏洞的文章都说了（比如：\u003ca href=\"https://securityblog.redhat.com/2014/09/24/bash-specially-crafted-environment-variables-code-injection-attack/\" target=\"_blank\"\u003e这篇\u003c/a\u003e，\u003ca href=\"https://www.digitalocean.com/community/tutorials/how-to-protect-your-server-against-the-shellshock-bash-vulnerability\" target=\"_blank\"\u003e这篇\u003c/a\u003e），我这里就不复述了。\u003c/p\u003e\n\u003cp\u003e注：如果你要看看你的网站有没有这样的问题，你可以用这个在线工具测试一下：\u003ca href=\"http://shellshock.brandonpotter.com/\"\u003e‘ShellShock’ Bash Vulnerability CVE-2014-6271 Test Tool\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e现在，你知道这事可能会很大了吧。还不赶快去打补丁。（注，yum update bash 把bash版本升级到 4.1.2-15.el6_5.2 ， ）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B3%E4%BA%8E_AfterShock_%E2%80%93_CVE-2014-7169_%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC%E7%9A%84%E8%A7%A3%E9%87%8A\"\u003e\u003c/span\u003e关于 AfterShock – CVE-2014-7169 测试脚本的解释\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e很多同学没有看懂下面这个测试脚本是什么意思，我这里解释一下。\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eenv X=\u0026#39;() { (a)=\u0026gt;\\\u0026#39; sh -c \u0026#34;echo date\u0026#34;; cat echo\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eX=\u0026#39;() { (a)=\u0026gt;\\’ 这个不用说了，定义一个X的环境变量。但是，这个函数不完整啊，是的，这是故意的。另外你一定要注意，\\’不是为了单引号的转义，X这个变量的值就是 \u003cstrong\u003e() { (a)=\u0026gt;\\\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e其中的 (a)=这个东西目的就是为了让bash的解释器出错（语法错误）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e语法出错后，在缓冲区中就会只剩下了 “\u0026gt;\\”这两个字符。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e于是，这个神奇的bash会把后面的命令echo date换个行放到这个缓冲区中，然后执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e相当于在shell 下执行了下面这个命令：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ \u0026gt;\\\necho date\u003c/pre\u003e\n\u003cp\u003e如果你了解bash，你会知道 \\ 是用于命令行上换行的，于是相当于执行了：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e $ \u0026gt;echo date\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这不就是一个重定向么？上述的命令相当于：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ date \u0026gt; echo \u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e于是，你的当前目录下会出现一个echo的文件，这个文件的内容就是date命令的输出。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e能发现这个种玩法的人真是个变态，完全是为bash的源代码量身定制的一个攻击\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/8619.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/11/shell.01-150x150.png\" alt=\"你可能不知道的Shell\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/8619.html\" class=\"wp_rp_title\"\u003e你可能不知道的Shell\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1399.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2009/09/bashprompts-hurring-150x150.jpg\" alt=\"8个实用而有趣Bash命令提示行\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1399.html\" class=\"wp_rp_title\"\u003e8个实用而有趣Bash命令提示行\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7965.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/07/fork01jpg-150x150.jpg\" alt=\"一个fork的面试题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7965.html\" class=\"wp_rp_title\"\u003e一个fork的面试题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11021.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/02/Github-Security-150x150.png\" alt=\"从“黑掉Github”学Web安全开发\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11021.html\" class=\"wp_rp_title\"\u003e从“黑掉Github”学Web安全开发\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg\" alt=\"C语言的整型溢出问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_title\"\u003eC语言的整型溢出问题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6976.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/04/61e04755jw1drlo96bsktj-150x150.jpg\" alt=\"谈谈数据安全和云存储\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6976.html\" class=\"wp_rp_title\"\u003e谈谈数据安全和云存储\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11973\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"e1ec87fb51\"\u003e\u003cimg id=\"rating_11973_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11973, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a48a945e48f8c8b9f6e84555-=\"\"/\u003e\u003cimg id=\"rating_11973_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11973, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a48a945e48f8c8b9f6e84555-=\"\"/\u003e\u003cimg id=\"rating_11973_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11973, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a48a945e48f8c8b9f6e84555-=\"\"/\u003e\u003cimg id=\"rating_11973_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11973, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a48a945e48f8c8b9f6e84555-=\"\"/\u003e\u003cimg id=\"rating_11973_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11973, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a48a945e48f8c8b9f6e84555-=\"\"/\u003e (\u003cstrong\u003e78\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.50\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11973_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"bash代码注入的安全漏洞\"/\u003e\u003cmeta itemprop=\"headline\" content=\"bash代码注入的安全漏洞\"/\u003e\u003cmeta itemprop=\"description\" content=\"很多人或许对上半年发生的安全问题“心脏流血”（Heartbleed Bug）事件记忆颇深，这两天，又出现了另外一个“毁灭级”的漏洞——Bash软件安全漏洞。这个漏洞由法国GNU/Linux爱好者Stéphane Chazelas所发现。随后，美国电脑紧急应变中心（US-CERT）、红帽以及多家从事安全的公司于周三（北京时间9月24日）发出警告。 关于这个安全漏洞的细节可参看美国政府计算安全的这两个...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-09-28T07:56:46+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2014-10-08T16:26:21+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11973.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11973.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.5\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"78\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11973-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-09-28T07:56:46+08:00",
  "Author": "陈皓"
}