{
  "Source": "coolshell.cn",
  "Title": "Go编程模式：Map-Reduce",
  "Link": "https://coolshell.cn/articles/21164.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"e89803c953344196aab4647f-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-medium wp-image-21251\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-300x192.png\" alt=\"\" width=\"300\" height=\"192\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-300x192.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-768x491.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-422x270.png 422w, https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce.png 992w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e在本篇文章中，我们学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以让我们非常方便灵活地进行一些数据处理——我们的程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法。下面先来看几个例子：\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第5 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式：Map-Reduce\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21214.html\" rel=\"prev\" title=\"Go编程模式：委托和反转控制\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" rel=\"next\" title=\"Go 编程模式：Go Generation\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B\" title=\"基本示例\"\u003e基本示例\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Map%E7%A4%BA%E4%BE%8B\" title=\"Map示例\"\u003eMap示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Reduce_%E7%A4%BA%E4%BE%8B\" title=\"Reduce 示例\"\u003eReduce 示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Filter%E7%A4%BA%E4%BE%8B\" title=\"Filter示例\"\u003eFilter示例\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E4%B8%9A%E5%8A%A1%E7%A4%BA%E4%BE%8B\" title=\"业务示例\"\u003e业务示例\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF\" title=\"员工信息\"\u003e员工信息\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E7%9B%B8%E5%85%B3%E7%9A%84ReduceFitler%E5%87%BD%E6%95%B0\" title=\"相关的Reduce/Fitler函数\"\u003e相关的Reduce/Fitler函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%90%84%E7%A7%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%9F%E8%AE%A1%E7%A4%BA%E4%BE%8B\" title=\"各种自定义的统计示例\"\u003e各种自定义的统计示例\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E6%B3%9B%E5%9E%8BMap-Reduce\" title=\"泛型Map-Reduce\"\u003e泛型Map-Reduce\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E7%AE%80%E5%8D%95%E7%89%88_Generic_Map\" title=\"简单版 Generic Map\"\u003e简单版 Generic Map\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-11\" href=\"#%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84Generic_Map\" title=\"健壮版的Generic Map\"\u003e健壮版的Generic Map\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-12\" href=\"#%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84_Generic_Reduce\" title=\"健壮版的 Generic Reduce\"\u003e健壮版的 Generic Reduce\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-13\" href=\"#%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84_Generic_Filter\" title=\"健壮版的 Generic Filter\"\u003e健壮版的 Generic Filter\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-14\" href=\"#%E5%90%8E%E8%AE%B0\" title=\"后记\"\u003e后记\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%9F%BA%E6%9C%AC%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e基本示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Map%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003eMap示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面的程序代码中，我们写了两个Map函数，这两个函数需要两个参数，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个是字符串数组 \u003ccode\u003e[]string\u003c/code\u003e，说明需要处理的数据一个字符串\u003c/li\u003e\n\u003cli\u003e另一个是一个函数\u003ccode\u003efunc(s string) string\u003c/code\u003e 或 \u003ccode\u003efunc(s string) int\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc MapStrToStr(arr []string, fn func(s string) string) []string {\n    var newArray = []string{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\n\nfunc MapStrToInt(arr []string, fn func(s string) int) []int {\n    var newArray = []int{}\n    for _, it := range arr {\n        newArray = append(newArray, fn(it))\n    }\n    return newArray\n}\u003c/pre\u003e\n\u003cp\u003e整个Map函数运行逻辑都很相似，函数体都是在遍历第一个参数的数组，然后，调用第二个参数的函数，然后把其值组合成另一个数组返回。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21164\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e于是我们就可以这样使用这两个函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar list = []string{\u0026#34;Hao\u0026#34;, \u0026#34;Chen\u0026#34;, \u0026#34;MegaEase\u0026#34;}\n\nx := MapStrToStr(list, func(s string) string {\n    return strings.ToUpper(s)\n})\nfmt.Printf(\u0026#34;%v\\n\u0026#34;, x)\n//[\u0026#34;HAO\u0026#34;, \u0026#34;CHEN\u0026#34;, \u0026#34;MEGAEASE\u0026#34;]\n\ny := MapStrToInt(list, func(s string) int {\n    return len(s)\n})\nfmt.Printf(\u0026#34;%v\\n\u0026#34;, y)\n//[3, 4, 8]\u003c/pre\u003e\n\u003cp\u003e我们可以看到，我们给第一个 \u003ccode\u003eMapStrToStr()\u003c/code\u003e 传了函数做的是 转大写，于是出来的数组就成了全大写的，给\u003ccode\u003eMapStrToInt()\u003c/code\u003e 传的是算其长度，所以出来的数组是每个字符串的长度。\u003c/p\u003e\n\u003cp\u003e我们再来看一下Reduce和Filter的函数是什么样的。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Reduce_%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e\u003cstrong\u003eReduce 示例\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc Reduce(arr []string, fn func(s string) int) int {\n    sum := 0\n    for _, it := range arr {\n        sum += fn(it)\n    }\n    return sum\n}\n\nvar list = []string{\u0026#34;Hao\u0026#34;, \u0026#34;Chen\u0026#34;, \u0026#34;MegaEase\u0026#34;}\n\nx := Reduce(list, func(s string) int {\n    return len(s)\n})\nfmt.Printf(\u0026#34;%v\\n\u0026#34;, x)\n// 15\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Filter%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e\u003cstrong\u003eFilter示例\u003c/strong\u003e\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc Filter(arr []int, fn func(n int) bool) []int {\n    var newArray = []int{}\n    for _, it := range arr {\n        if fn(it) {\n            newArray = append(newArray, it)\n        }\n    }\n    return newArray\n}\n\nvar intset = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nout := Filter(intset, func(n int) bool {\n   return n%2 == 1\n})\nfmt.Printf(\u0026#34;%v\\n\u0026#34;, out)\n\nout = Filter(intset, func(n int) bool {\n    return n \u0026gt; 5\n})\nfmt.Printf(\u0026#34;%v\\n\u0026#34;, out)\n\u003c/pre\u003e\n\u003cp\u003e下图是一个比喻，其非常形象地说明了Map-Reduce是的业务语义，其在数据处理中非常有用。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-21169\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/map-reduce.png\" alt=\"\" width=\"794\" height=\"442\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/map-reduce.png 794w, https://coolshell.cn/wp-content/uploads/2020/12/map-reduce-300x167.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/map-reduce-768x428.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/map-reduce-360x200.png 360w, https://coolshell.cn/wp-content/uploads/2020/12/map-reduce-485x270.png 485w\" sizes=\"(max-width: 794px) 100vw, 794px\"/\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%9A%E5%8A%A1%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e业务示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e通过上面的一些示例，你可能有一些明白，Map/Reduce/Filter只是一种控制逻辑，真正的业务逻辑是在传给他们的数据和那个函数来定义的。是的，这是一个很经典的“业务逻辑”和“控制逻辑”分离解耦的编程模式。下面我们来看一个有业务意义的代码，来让大家强化理解一下什么叫“控制逻辑”与业务逻辑分离。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%91%98%E5%B7%A5%E4%BF%A1%E6%81%AF\"\u003e\u003c/span\u003e员工信息\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e首先，我们一个员工对象，以及一些数据\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Employee struct {\n    Name     string\n    Age      int\n    Vacation int\n    Salary   int\n}\n\nvar list = []Employee{\n    {\u0026#34;Hao\u0026#34;, 44, 0, 8000},\n    {\u0026#34;Bob\u0026#34;, 34, 10, 5000},\n    {\u0026#34;Alice\u0026#34;, 23, 5, 9000},\n    {\u0026#34;Jack\u0026#34;, 26, 0, 4000},\n    {\u0026#34;Tom\u0026#34;, 48, 9, 7500},\n    {\u0026#34;Marry\u0026#34;, 29, 0, 6000},\n    {\u0026#34;Mike\u0026#34;, 32, 8, 4000},\n}\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%9B%B8%E5%85%B3%E7%9A%84ReduceFitler%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e相关的Reduce/Fitler函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e然后，我们有如下的几个函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003efunc EmployeeCountIf(list []Employee, fn func(e *Employee) bool) int {\n    count := 0\n    for i, _ := range list {\n        if fn(\u0026amp;list[i]) {\n            count += 1\n        }\n    }\n    return count\n}\n\nfunc EmployeeFilterIn(list []Employee, fn func(e *Employee) bool) []Employee {\n    var newList []Employee\n    for i, _ := range list {\n        if fn(\u0026amp;list[i]) {\n            newList = append(newList, list[i])\n        }\n    }\n    return newList\n}\n\nfunc EmployeeSumIf(list []Employee, fn func(e *Employee) int) int {\n    var sum = 0\n    for i, _ := range list {\n        sum += fn(\u0026amp;list[i])\n    }\n    return sum\n}\u003c/pre\u003e\n\u003cp\u003e简单说明一下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEmployeeConutIf\u003c/code\u003e 和 \u003ccode\u003eEmployeeSumIf\u003c/code\u003e 分别用于统满足某个条件的个数或总数。它们都是Filter + Reduce的语义。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEmployeeFilterIn\u003c/code\u003e 就是按某种条件过虑。就是Fitler的语义。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%90%84%E7%A7%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%9F%E8%AE%A1%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e各种自定义的统计示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e于是我们就可以有如下的代码。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1）统计有多少员工大于40岁\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eold := EmployeeCountIf(list, func(e *Employee) bool {\n    return e.Age \u0026gt; 40\n})\nfmt.Printf(\u0026#34;old people: %d\\n\u0026#34;, old)\n//old people: 2\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2）统计有多少员工薪水大于6000\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ehigh_pay := EmployeeCountIf(list, func(e *Employee) bool {\n    return e.Salary \u0026gt;= 6000\n})\nfmt.Printf(\u0026#34;High Salary people: %d\\n\u0026#34;, high_pay)\n//High Salary people: 4\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3）列出有没有休假的员工\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eno_vacation := EmployeeFilterIn(list, func(e *Employee) bool {\n    return e.Vacation == 0\n})\nfmt.Printf(\u0026#34;People no vacation: %v\\n\u0026#34;, no_vacation)\n//People no vacation: [{Hao 44 0 8000} {Jack 26 0 4000} {Marry 29 0 6000}]\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4）统计所有员工的薪资总和\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etotal_pay := EmployeeSumIf(list, func(e *Employee) int {\n    return e.Salary\n})\n\nfmt.Printf(\u0026#34;Total Salary: %d\\n\u0026#34;, total_pay)\n//Total Salary: 43500\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5）统计30岁以下员工的薪资总和\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eyounger_pay := EmployeeSumIf(list, func(e *Employee) int {\n    if e.Age \u0026lt; 30 {\n        return e.Salary\n    } \n    return 0\n})\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%9B%E5%9E%8BMap-Reduce\"\u003e\u003c/span\u003e泛型Map-Reduce\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们可以看到，上面的Map-Reduce都因为要处理数据的类型不同而需要写出不同版本的Map-Reduce，虽然他们的代码看上去是很类似的。所以，这里就要带出来泛型编程了，Go语言在本文写作的时候还不支持泛型（注：Go开发团队技术负责人Russ Cox在2012年11月21golang-dev上的mail确认了Go泛型(type parameter)将在Go 1.18版本落地，即2022.2月份）。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%AE%80%E5%8D%95%E7%89%88_Generic_Map\"\u003e\u003c/span\u003e简单版 Generic Map\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e所以，目前的Go语言的泛型只能用 \u003ccode\u003einterface{}\u003c/code\u003e + \u003ccode\u003ereflect\u003c/code\u003e来完成，\u003ccode\u003einterface{}\u003c/code\u003e 可以理解为C中的 \u003ccode\u003evoid*\u003c/code\u003e，Java中的 \u003ccode\u003eObject\u003c/code\u003e ，\u003ccode\u003ereflect\u003c/code\u003e是Go的反射机制包，用于在运行时检查类型。\u003c/p\u003e\n\u003cp\u003e下面我们来看一下一个非常简单不作任何类型检查的泛型的Map函数怎么写。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003efunc Map(data interface{}, fn interface{}) []interface{} {\n    vfn := reflect.ValueOf(fn)\n    vdata := reflect.ValueOf(data)\n    result := make([]interface{}, vdata.Len())\n\n    for i := 0; i \u0026lt; vdata.Len(); i++ {\n        result[i] = vfn.Call([]reflect.Value{vdata.Index(i)})[0].Interface()\n    }\n    return result\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过 \u003ccode\u003ereflect.ValueOf()\u003c/code\u003e 来获得 \u003ccode\u003einterface{}\u003c/code\u003e 的值，其中一个是数据 \u003ccode\u003evdata\u003c/code\u003e，另一个是函数 \u003ccode\u003evfn\u003c/code\u003e，\u003c/li\u003e\n\u003cli\u003e然后通过 \u003ccode\u003evfn.Call()\u003c/code\u003e 方法来调用函数，通过 \u003ccode\u003e[]refelct.Value{vdata.Index(i)}\u003c/code\u003e来获得数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGo语言中的反射的语法还是有点令人费解的，但是简单看一下手册还是能够读懂的。我这篇文章不讲反射，所以相关的基础知识还请大家自行Google相关的教程。\u003c/p\u003e\n\u003cp\u003e于是，我们就可以有下面的代码——不同类型的数据可以使用相同逻辑的\u003ccode\u003eMap()\u003c/code\u003e代码。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003esquare := func(x int) int {\n  return x * x\n}\nnums := []int{1, 2, 3, 4}\n\nsquared_arr := Map(nums,square)\nfmt.Println(squared_arr)\n//[1 4 9 16]\n\n\n\nupcase := func(s string) string {\n  return strings.ToUpper(s)\n}\nstrs := []string{\u0026#34;Hao\u0026#34;, \u0026#34;Chen\u0026#34;, \u0026#34;MegaEase\u0026#34;}\nupstrs := Map(strs, upcase);\nfmt.Println(upstrs)\n//[HAO CHEN MEGAEASE]\u003c/pre\u003e\n\u003cp\u003e但是因为反射是运行时的事，所以，如果类型什么出问题的话，就会有运行时的错误。比如：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ex := Map(5, 5)\nfmt.Println(x)\u003c/pre\u003e\n\u003cp\u003e上面的代码可以很轻松的编译通过，但是在运行时就出问题了，还是panic错误……\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003epanic: reflect: call of reflect.Value.Len on int Value\n\ngoroutine 1 [running]:\nreflect.Value.Len(0x10b5240, 0x10eeb58, 0x82, 0x10716bc)\n        /usr/local/Cellar/go/1.15.3/libexec/src/reflect/value.go:1162 +0x185\nmain.Map(0x10b5240, 0x10eeb58, 0x10b5240, 0x10eeb60, 0x1, 0x14, 0x0)\n        /Users/chenhao/.../map.go:12 +0x16b\nmain.main()\n        /Users/chenhao/.../map.go:42 +0x465\nexit status 2\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84Generic_Map\"\u003e\u003c/span\u003e健壮版的Generic Map\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e所以，如果要写一个健壮的程序，对于这种用\u003ccode\u003einterface{}\u003c/code\u003e 的“过度泛型”，就需要我们自己来做类型检查。下面是一个有类型检查的Map代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc Transform(slice, function interface{}) interface{} {\n  return transform(slice, function, false)\n}\n\nfunc TransformInPlace(slice, function interface{}) interface{} {\n  return transform(slice, function, true)\n}\n\nfunc transform(slice, function interface{}, inPlace bool) interface{} {\n \n  //check the \u003ccode data-enlighter-language=\"raw\" class=\"EnlighterJSRAW\"\u003eslice\u003c/code\u003e type is Slice\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(\u0026#34;transform: not slice\u0026#34;)\n  }\n\n  //check the function signature\n  fn := reflect.ValueOf(function)\n  elemType := sliceInType.Type().Elem()\n  if !verifyFuncSignature(fn, elemType, nil) {\n    panic(\u0026#34;trasform: function must be of type func(\u0026#34; + sliceInType.Type().Elem().String() + \u0026#34;) outputElemType\u0026#34;)\n  }\n\n  sliceOutType := sliceInType\n  if !inPlace {\n    sliceOutType = reflect.MakeSlice(reflect.SliceOf(fn.Type().Out(0)), sliceInType.Len(), sliceInType.Len())\n  }\n  for i := 0; i \u0026lt; sliceInType.Len(); i++ {\n    sliceOutType.Index(i).Set(fn.Call([]reflect.Value{sliceInType.Index(i)})[0])\n  }\n  return sliceOutType.Interface()\n\n}\n\nfunc verifyFuncSignature(fn reflect.Value, types ...reflect.Type) bool {\n\n  //Check it is a funciton\n  if fn.Kind() != reflect.Func {\n    return false\n  }\n  // NumIn() - returns a function type\u0026#39;s input parameter count.\n  // NumOut() - returns a function type\u0026#39;s output parameter count.\n  if (fn.Type().NumIn() != len(types)-1) || (fn.Type().NumOut() != 1) {\n    return false\n  }\n  // In() - returns the type of a function type\u0026#39;s i\u0026#39;th input parameter.\n  for i := 0; i \u0026lt; len(types)-1; i++ {\n    if fn.Type().In(i) != types[i] {\n      return false\n    }\n  }\n  // Out() - returns the type of a function type\u0026#39;s i\u0026#39;th output parameter.\n  outType := types[len(types)-1]\n  if outType != nil \u0026amp;\u0026amp; fn.Type().Out(0) != outType {\n    return false\n  }\n  return true\n}\n\u003c/pre\u003e\n\u003cp\u003e上面的代码一下子就复杂起来了，可见，复杂的代码都是在处理异常的地方。我不打算Walk through 所有的代码，别看代码多，但是还是可以读懂的，下面列几个代码中的要点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e代码中没有使用Map函数，因为和数据结构和关键有含义冲突的问题，所以使用\u003ccode\u003eTransform\u003c/code\u003e，这个来源于 C++ STL库中的命名。\u003c/li\u003e\n\u003cli\u003e有两个版本的函数，一个是返回一个全新的数组 – \u003ccode\u003eTransform()\u003c/code\u003e，一个是“就地完成” – \u003ccode\u003eTransformInPlace()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在主函数中，用 \u003ccode\u003eKind()\u003c/code\u003e 方法检查了数据类型是不是 Slice，函数类型是不是Func\u003c/li\u003e\n\u003cli\u003e检查函数的参数和返回类型是通过 \u003ccode\u003everifyFuncSignature()\u003c/code\u003e 来完成的，其中：\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eNumIn()\u003c/code\u003e – 用来检查函数的“入参”\u003c/li\u003e\n\u003cli\u003e \u003ccode\u003eNumOut()\u003c/code\u003e 用来检查函数的“返回值”\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果需要新生成一个Slice，会使用 \u003ccode\u003ereflect.MakeSlice()\u003c/code\u003e 来完成。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e好了，有了上面的这段代码，我们的代码就很可以很开心的使用了：\u003c/p\u003e\n\u003cp\u003e可以用于字符串数组\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003elist := []string{\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;}\nresult := Transform(list, func(a string) string{\n    return a +a +a\n})\n//{\u0026#34;111\u0026#34;,\u0026#34;222\u0026#34;,\u0026#34;333\u0026#34;,\u0026#34;444\u0026#34;,\u0026#34;555\u0026#34;,\u0026#34;666\u0026#34;}\n\u003c/pre\u003e\n\u003cp\u003e可以用于整形数组\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003elist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9}\nTransformInPlace(list, func (a int) int {\n  return a*3\n})\n//{3, 6, 9, 12, 15, 18, 21, 24, 27}\n\u003c/pre\u003e\n\u003cp\u003e可以用于结构体\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar list = []Employee{\n    {\u0026#34;Hao\u0026#34;, 44, 0, 8000},\n    {\u0026#34;Bob\u0026#34;, 34, 10, 5000},\n    {\u0026#34;Alice\u0026#34;, 23, 5, 9000},\n    {\u0026#34;Jack\u0026#34;, 26, 0, 4000},\n    {\u0026#34;Tom\u0026#34;, 48, 9, 7500},\n}\n\nresult := TransformInPlace(list, func(e Employee) Employee {\n    e.Salary += 1000\n    e.Age += 1\n    return e\n})\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84_Generic_Reduce\"\u003e\u003c/span\u003e健壮版的 Generic Reduce\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e同样，泛型版的 Reduce 代码如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc Reduce(slice, pairFunc, zero interface{}) interface{} {\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(\u0026#34;reduce: wrong type, not slice\u0026#34;)\n  }\n\n  len := sliceInType.Len()\n  if len == 0 {\n    return zero\n  } else if len == 1 {\n    return sliceInType.Index(0)\n  }\n\n  elemType := sliceInType.Type().Elem()\n  fn := reflect.ValueOf(pairFunc)\n  if !verifyFuncSignature(fn, elemType, elemType, elemType) {\n    t := elemType.String()\n    panic(\u0026#34;reduce: function must be of type func(\u0026#34; + t + \u0026#34;, \u0026#34; + t + \u0026#34;) \u0026#34; + t)\n  }\n\n  var ins [2]reflect.Value\n  ins[0] = sliceInType.Index(0)\n  ins[1] = sliceInType.Index(1)\n  out := fn.Call(ins[:])[0]\n\n  for i := 2; i \u0026lt; len; i++ {\n    ins[0] = out\n    ins[1] = sliceInType.Index(i)\n    out = fn.Call(ins[:])[0]\n  }\n  return out.Interface()\n}\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%81%A5%E5%A3%AE%E7%89%88%E7%9A%84_Generic_Filter\"\u003e\u003c/span\u003e健壮版的 Generic Filter\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e同样，泛型版的 Filter 代码如下（同样分是否“就地计算”的两个版本）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003efunc Filter(slice, function interface{}) interface{} {\n  result, _ := filter(slice, function, false)\n  return result\n}\n\nfunc FilterInPlace(slicePtr, function interface{}) {\n  in := reflect.ValueOf(slicePtr)\n  if in.Kind() != reflect.Ptr {\n    panic(\u0026#34;FilterInPlace: wrong type, \u0026#34; +\n      \u0026#34;not a pointer to slice\u0026#34;)\n  }\n  _, n := filter(in.Elem().Interface(), function, true)\n  in.Elem().SetLen(n)\n}\n\nvar boolType = reflect.ValueOf(true).Type()\n\nfunc filter(slice, function interface{}, inPlace bool) (interface{}, int) {\n\n  sliceInType := reflect.ValueOf(slice)\n  if sliceInType.Kind() != reflect.Slice {\n    panic(\u0026#34;filter: wrong type, not a slice\u0026#34;)\n  }\n\n  fn := reflect.ValueOf(function)\n  elemType := sliceInType.Type().Elem()\n  if !verifyFuncSignature(fn, elemType, boolType) {\n    panic(\u0026#34;filter: function must be of type func(\u0026#34; + elemType.String() + \u0026#34;) bool\u0026#34;)\n  }\n\n  var which []int\n  for i := 0; i \u0026lt; sliceInType.Len(); i++ {\n    if fn.Call([]reflect.Value{sliceInType.Index(i)})[0].Bool() {\n      which = append(which, i)\n    }\n  }\n\n  out := sliceInType\n\n  if !inPlace {\n    out = reflect.MakeSlice(sliceInType.Type(), len(which), len(which))\n  }\n  for i := range which {\n    out.Index(i).Set(sliceInType.Index(which[i]))\n  }\n\n  return out.Interface(), len(which)\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%90%8E%E8%AE%B0\"\u003e\u003c/span\u003e后记\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e还有几个未尽事宜：\u003c/p\u003e\n\u003cp\u003e1）使用反射来做这些东西，会有一个问题，\u003cstrong\u003e那就是代码的性能会很差。所以，上面的代码不能用于你需要高性能的地方\u003c/strong\u003e。怎么解决这个问题，我们会在本系列文章的下一篇文章中讨论。\u003c/p\u003e\n\u003cp\u003e2）上面的代码大量的参考了 Rob Pike的版本，他的代码在 \u003ca href=\"https://github.com/robpike/filter\" target=\"_blank\" rel=\"noopener\"\u003ehttps://github.com/robpike/filter\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e3）其实，在全世界范围内，有大量的程序员都在问Go语言官方什么时候在标准库中支持 Map/Reduce，Rob Pike说，这种东西难写吗？还要我们官方来帮你们写么？这种代码我多少年前就写过了，但是，我从来一次都没有用过，我还是喜欢用“For循环”，我觉得你最好也跟我一起用 “For循环”。\u003c/p\u003e\n\u003cp\u003e我个人觉得，Map/Reduce在数据处理的时候还是很有用的，Rob Pike可能平时也不怎么写“业务逻辑”的代码，所以，对他来说可能也不太了解业务的变化有多么的频繁……\u003c/p\u003e\n\u003cp\u003e当然，好还是不好，由你来判断，但多学一些编程模式是对自己的帮助也是很有帮助的。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/06/go-hardhat-150x150.png\" alt=\"Go编程模式：修饰器\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\" class=\"wp_rp_title\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21164\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"01813c072b\"\u003e\u003cimg id=\"rating_21164_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21164, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e89803c953344196aab4647f-=\"\"/\u003e\u003cimg id=\"rating_21164_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21164, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e89803c953344196aab4647f-=\"\"/\u003e\u003cimg id=\"rating_21164_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21164, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e89803c953344196aab4647f-=\"\"/\u003e\u003cimg id=\"rating_21164_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21164, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e89803c953344196aab4647f-=\"\"/\u003e\u003cimg id=\"rating_21164_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21164, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e89803c953344196aab4647f-=\"\"/\u003e (\u003cstrong\u003e26\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.73\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21164_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式：Map-Reduce\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式：Map-Reduce\"/\u003e\u003cmeta itemprop=\"description\" content=\"在本篇文章中，我们学习一下函数式编程的中非常重要的Map、Reduce、Filter的三种操作，这三种操作可以让我们非常方便灵活地进行一些数据处理——我们的程序中大多数情况下都是在到倒腾数据，尤其对于一些需要统计的业务场景，Map/Reduce/Filter是非常通用的玩法。下面先来看几个例子：\n\n\n\n基本示例\n\nMap示例\n\n下面的程序代码中，我们写了两个Map函数，这两个函数需要两个参数，\n\n...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-24T15:13:52+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-28T15:38:22+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21164.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21164.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.73\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"26\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21164-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-24T15:13:52+08:00",
  "Author": "陈皓"
}