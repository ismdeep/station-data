{
  "Source": "coolshell.cn",
  "Title": "代码执行的效率",
  "Link": "https://coolshell.cn/articles/7886.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"42410b68ab247306681642fd-text/javascript\"\u003e\u003c/script\u003e在《\u003ca title=\"性能调优攻略\" href=\"https://coolshell.cn/articles/7490.html\" target=\"_blank\"\u003e性能调优攻略\u003c/a\u003e》里，我说过，要调优性需要找到程序中的Hotspot，也就是被调用最多的地方，这种地方，只要你能优化一点点，你的性能就会有质的提高。在这里我给大家举三个关于代码执行效率的例子（它们都来自于网上）\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e第一个例子\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e PHP中Getter和Setter的效率\u003c/strong\u003e（\u003ca href=\"http://www.reddit.com/r/programming/comments/wdsgn/today_i_learned_that_creating_getters_setters_in/\" target=\"_blank\"\u003e来源reddit\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e这个例子比较简单，你可以跳过。\u003c/p\u003e\n\u003cp\u003e考虑下面的PHP代码：我们可看到，使用Getter/Setter的方式，性能要比直接读写成员变量要差一倍以上。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"php\" class=\"EnlighterJSRAW\"\u003e\u0026lt;?php\n\t//dog_naive.php\n\n\tclass dog {\n\t\tpublic $name = \u0026#34;\u0026#34;;\n\t\tpublic function setName($name) {\n\t\t\t$this-\u0026amp;gt;name = $name;\n\t\t}\n\t\tpublic function getName() {\n\t\t\treturn $this-\u0026amp;gt;name;\n\t\t}\n\t}\n\n\t$rover = new dog();\n        //通过Getter/Setter方式\n\tfor ($x=0; $x\u0026lt;10; $x++) {\n\t\t$t = microtime(true);\n\t\tfor ($i=0; $i\u0026lt;1000000; $i++) {\n\t\t\t$rover-\u0026gt;setName(\u0026#34;rover\u0026#34;);\n\t\t\t$n = $rover-\u0026gt;getName();\n\t\t}\n\t\techo microtime(true) - $t;\n\t\techo \u0026#34;\\n\u0026#34;;\n\t}\n        //直接存取变量方式\n        for ($x=0; $x\u0026lt;10; $x++) {\n\t\t$t = microtime(true);\n\t\tfor($i=0; $i\u0026lt;1000000; $i++) {\n\t\t\t$rover-\u0026gt;name = \u0026#34;rover\u0026#34;;\n\t\t\t$n = $rover-\u0026gt;name;\n\t\t}\n\t\techo microtime(true) - $t;\n\t\techo \u0026#34;\\n\u0026#34;;\n\t}\n?\u0026gt;\u003c/pre\u003e\n\u003cp\u003e这个并没有什么稀，因为有函数调用的开销，函数调用需要压栈出栈，需要传值，有时还要需要中断，要干的事太多了。所以，代码多了，效率自然就慢了。所有的语言都这个德行，这就是为什么C++要引入inline的原因。而且Java在打开优化的时候也可以优化之。但是对于动态语言来说，这个事就变得有点困难了。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-7886\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e你可能会以为使用下面的代码（Magic Function）会好一些，但实际其性能更差。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"php\" class=\"EnlighterJSRAW\"\u003eclass dog {\n\tprivate $_name = \u0026#34;\u0026#34;;\n\tfunction __set($property,$value) {\n\t\tif($property == \u0026#39;name\u0026#39;) $this-\u0026gt;_name = $value;\n\t}\n\tfunction __get($property) {\n\t\tif($property == \u0026#39;name\u0026#39;) return $this-\u0026gt;_name;\n\t}\n}\u003c/pre\u003e\n\u003cp\u003e动态语言的效率从来都是一个问题，如果你需要PHP有更好的性能，你可能需要使用\u003ca href=\"https://github.com/facebook/hiphop-php\" target=\"_blank\"\u003eFaceBook的HipHop\u003c/a\u003e来把PHP编译成C语言。\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e第二个例子\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e为什么Python程序在函数内执行得更快？\u003c/strong\u003e（\u003ca href=\"http://stackoverflow.com/questions/11241523/why-does-python-code-run-faster-in-a-function\" target=\"_blank\"\u003e来源StackOverflow\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e考虑下面的代码，一个在函数体内，一个是全局的代码。\u003c/p\u003e\n\u003cp\u003e函数内的代码执行效率为 1.8s\u003c/p\u003e\n\u003cpre data-enlighter-language=\"python\" class=\"EnlighterJSRAW\"\u003edef main():\n    for i in xrange(10**8):\n        pass\nmain()\u003c/pre\u003e\n\u003cp\u003e函数体外的代码执行效率为 4.5s\u003c/p\u003e\n\u003cpre data-enlighter-language=\"python\" class=\"EnlighterJSRAW\"\u003efor i in xrange(10**8):\n    pass\u003c/pre\u003e\n\u003cp\u003e不用太纠结时间，只是一个示例，我们可以看到效率查得很多。为什么会这样呢？我们使用 \u003ca href=\"https://docs.python.org/library/dis.html\" target=\"_blank\"\u003e\u003ccode\u003edis\u003c/code\u003e module\u003c/a\u003e 反汇编函数体内的bytecode 代码，使用 \u003ca href=\"https://docs.python.org/library/functions.html#compile\" target=\"_blank\"\u003e\u003ccode\u003ecompile\u003c/code\u003e builtin\u003c/a\u003e 反汇编全局bytecode，我们可以看到下面的反汇编（注意我高亮的地方）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"2\"\u003e13 FOR_ITER                 6 (to 22)\n16 STORE_FAST               1 (i)\n19 JUMP_ABSOLUTE           13\u003c/pre\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"2\"\u003e13 FOR_ITER                 6 (to 22)\n16 STORE_NAME               1 (i)\n19 JUMP_ABSOLUTE           13\u003c/pre\u003e\n\u003cp\u003e我们可以看到，差别就是 \u003ca href=\"https://docs.python.org/library/dis.html#opcode-STORE_FAST\" target=\"_blank\"\u003e\u003ccode\u003eSTORE_FAST\u003c/code\u003e\u003c/a\u003e 和 \u003ccode\u003e\u003ca href=\"https://docs.python.org/library/dis.html#opcode-STORE_NAME\" target=\"_blank\"\u003eSTORE_NAME\u003c/a\u003e，前者比后者快很多。所以，在全局代码中，变量i成了一个全局变量，而函数中的i是放在本地变量表中，所以在全局变量表中查找变量就慢很多。如果你在main函数中声明global i 那么效率也就下来了。\u003c/code\u003e原因是，本地变量是存在一个数组中（直到），用一个整型常量去访问，而全局变量存在一个dictionary中，查询很慢。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e（注：在\u003c/code\u003eC/C++中，这个不是一个问题）\u003c/p\u003e\n\u003ch4\u003e\u003cstrong\u003e第三个例子\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e 为什么排好序的数据在遍历时会更快？\u003c/strong\u003e（\u003ca href=\"http://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array\" target=\"_blank\"\u003e来源StackOverflow\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e参看如下C/C++的代码：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"4\"\u003e for (unsigned i = 0; i \u0026lt; 100000; ++i) {\n   // primary loop\n    for (unsigned j = 0; j \u0026lt; arraySize; ++j) {\n        if (data[j] \u0026gt;= 128)\n            sum += data[j];\n    }\n}\u003c/pre\u003e\n\u003cp\u003e如果你的data数组是排好序的，那么性能是1.93s，如果没有排序，性能为11.54秒。差5倍多。无论是C/C++/Java，或是别的什么语言都基本上一样。\u003c/p\u003e\n\u003cp\u003e这个问题的原因是——\u003cstrong\u003e \u003ca href=\"https://en.wikipedia.org/wiki/Branch_predictor\"\u003ebranch prediction\u003c/a\u003e （分支预判）\u003c/strong\u003e伟大的stackoverflow给了一个非常不错的解释。\u003c/p\u003e\n\u003cp\u003e考虑我们一个铁路分叉，当我们的列车来的时候， 扳道员知道分个分叉通往哪，但不知道这个列车要去哪儿，司机知道要去哪，但是不知道走哪条分叉。所以，我们需要让列车停下来，然后司机和扳道员沟通一下。这样的性能太差了。\u003c/p\u003e\n\u003cp\u003e所以，我们可以优化一下，那就是猜，我们至少有50%的概率猜对，如果猜对了，火车行驶性能巨高，猜错了，就得让火车退回来。如果我猜对的概率高，那么，我们的性能就会高，否则老是猜错了，性能就很差。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-7893\" title=\"muxnt\" src=\"https://coolshell.cn/wp-content/uploads/2012/07/muxnt.jpg\" alt=\"\" width=\"440\" height=\"330\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/07/muxnt.jpg 440w, https://coolshell.cn/wp-content/uploads/2012/07/muxnt-300x225.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/07/muxnt-360x270.jpg 360w\" sizes=\"(max-width: 440px) 100vw, 440px\"/\u003e\u003c/p\u003e\n\u003cp style=\"text-align: center;\"\u003eImage by Mecanismo, from Wikimedia Commons:\u003ca href=\"https://commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\"\u003ehttp://commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e我们的if-else 就像这个铁路分叉一样，下面红箭头所指的就是搬道器。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-7892\" title=\"pyfwC\" src=\"https://coolshell.cn/wp-content/uploads/2012/07/pyfwC.png\" alt=\"\" width=\"567\" height=\"91\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/07/pyfwC.png 567w, https://coolshell.cn/wp-content/uploads/2012/07/pyfwC-300x48.png 300w\" sizes=\"(max-width: 567px) 100vw, 567px\"/\u003e\u003c/p\u003e\n\u003cp\u003e那么，我们的搬道器是怎么预判的呢？就是使用过去的历史数据，如果历史数据有90%以上的走左边，那么就走左边。所以，我们排好序的数据就更容易猜得对。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eT = 走分支（条件表达式为true）\nN = 不走分支(条件表达式为false)\n\ndata[] = 0, 1, 2, 3, 4, ... 126, 127, 128, 129, 130, ... 250, 251, 252, ...\nbranch = N  N  N  N  N  ...   N    N    T    T    T  ...   T    T    T  ...\n\n= NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)\u003c/pre\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003edata[] = 226, 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...\nbranch =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N  ...\n\n= TTNTTTTNTNNTTTN ...   (completely random - hard to predict)\u003c/pre\u003e\n\u003cp\u003e从上面我们可以看到，排好序的数据更容易预测分支。\u003c/p\u003e\n\u003cp\u003e对此，那我们怎么办？我们需要在这种循环中除去if-else语句。比如：\u003c/p\u003e\n\u003cp\u003e我们把条件语句：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eif (data[j] \u0026gt;= 128)\nsum += data[j];\n\u003c/pre\u003e\n\u003cp\u003e变成：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint t = (data[j] - 128) \u0026gt;\u0026gt; 31;\nsum += ~t \u0026amp; data[j];\u003c/pre\u003e\n\u003cp\u003e“没有分叉”的性能基本上和“排好序有分支”一个样，无论是C/C++，还是Java。\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e注：\u003c/strong\u003e在GCC下，如果你使用 \u003ccode\u003e-O3\u003c/code\u003e or \u003ccode\u003e-ftree-vectorize\u003c/code\u003e 编译参数，GCC会帮你优化分叉语句为无分叉语句。VC++2010没有这个功能。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e最后，推荐大家一个网站——\u003ca href=\"https://developers.google.com/speed/\" target=\"_blank\"\u003eGoogle Speed\u003c/a\u003e，网站上的有一些教程告诉你\u003ca href=\"https://developers.google.com/speed/articles/\" target=\"_blank\"\u003e如何写出更快的Web程序\u003c/a\u003e。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003c/strong\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1839.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2009/11/oscar-meyer-wienermobile-150x150.jpg\" alt=\"编程语言汽车\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1839.html\" class=\"wp_rp_title\"\u003e编程语言汽车\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1532.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg\" alt=\"到处都是Unix的胎记\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1532.html\" class=\"wp_rp_title\"\u003e到处都是Unix的胎记\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_title\"\u003eAPI设计原则 – Qt官网的设计实践总结\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/10169.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/5.jpg\" alt=\"类型的本质和函数式实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/10169.html\" class=\"wp_rp_title\"\u003e类型的本质和函数式实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/8990.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/02/linus_pointer_to_pointer-150x150.jpg\" alt=\"Linus：利用二级指针删除单向链表\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/8990.html\" class=\"wp_rp_title\"\u003eLinus：利用二级指针删除单向链表\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-7886\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"0d0cc5a268\"\u003e\u003cimg id=\"rating_7886_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(7886, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-42410b68ab247306681642fd-=\"\"/\u003e\u003cimg id=\"rating_7886_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(7886, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-42410b68ab247306681642fd-=\"\"/\u003e\u003cimg id=\"rating_7886_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(7886, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-42410b68ab247306681642fd-=\"\"/\u003e\u003cimg id=\"rating_7886_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(7886, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-42410b68ab247306681642fd-=\"\"/\u003e\u003cimg id=\"rating_7886_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(7886, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.7, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-42410b68ab247306681642fd-=\"\"/\u003e (\u003cstrong\u003e18\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.72\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_7886_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"代码执行的效率\"/\u003e\u003cmeta itemprop=\"headline\" content=\"代码执行的效率\"/\u003e\u003cmeta itemprop=\"description\" content=\"在《性能调优攻略》里，我说过，要调优性需要找到程序中的Hotspot，也就是被调用最多的地方，这种地方，只要你能优化一点点，你的性能就会有质的提高。在这里我给大家举三个关于代码执行效率的例子（它们都来自于网上）\n第一个例子\n PHP中Getter和Setter的效率（来源reddit）\n\n这个例子比较简单，你可以跳过。\n\n考虑下面的PHP代码：我们可看到，使用Getter/Setter...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-07-13T08:18:32+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2012-07-13T12:26:47+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/7886.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/7886.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.72\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"18\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-7886-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-07-13T08:18:32+08:00",
  "Author": "陈皓"
}