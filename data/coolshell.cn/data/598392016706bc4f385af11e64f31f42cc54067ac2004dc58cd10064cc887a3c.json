{
  "Source": "coolshell.cn",
  "Title": "无锁队列的实现",
  "Link": "https://coolshell.cn/articles/8239.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"fc3045d72b2ed62ee7156d35-text/javascript\"\u003e\u003c/script\u003e\u003c/p\u003e\n\u003cp style=\"text-align: center;\"\u003e\u003cstrong\u003e\u003cem\u003e————注：本文于2019年11月4日更新————\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关于无锁队列的实现，网上有很多文章，虽然本文可能和那些文章有所重复，但是我还是想以我自己的方式把这些文章中的重要的知识点串起来和大家讲一讲这个技术。下面开始正文。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E5%85%B3%E4%BA%8ECAS%E7%AD%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\" title=\"关于CAS等原子操作\"\u003e关于CAS等原子操作\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0\" title=\"无锁队列的链表实现\"\u003e无锁队列的链表实现\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98\" title=\"CAS的ABA问题\"\u003eCAS的ABA问题\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E8%A7%A3%E5%86%B3ABA%E7%9A%84%E9%97%AE%E9%A2%98\" title=\"解决ABA的问题\"\u003e解决ABA的问题\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97\" title=\"用数组实现无锁队列\"\u003e用数组实现无锁队列\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#_%E5%B0%8F%E7%BB%93\" title=\" 小结\"\u003e 小结\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B3%E4%BA%8ECAS%E7%AD%89%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\"\u003e\u003c/span\u003e关于CAS等原子操作\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"alignright size-full wp-image-8245\" title=\"lock free bicycle\" src=\"https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle.jpg\" alt=\"\" width=\"350\" height=\"261\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle.jpg 350w, https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle-300x224.jpg 300w\" sizes=\"(max-width: 350px) 100vw, 350px\"/\u003e在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare \u0026amp; Set，或是 Compare \u0026amp; Swap，\u003cstrong\u003e现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 \u003cspan style=\"color: #ff0000;\"\u003eCMPXCHG \u003c/span\u003e汇编指令。\u003c/strong\u003e有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构。\u003c/p\u003e\n\u003cp\u003e这个操作用C语言来描述就是下面这个样子：（代码来自\u003ca href=\"https://en.wikipedia.org/wiki/Compare-and-swap\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eWikipedia的Compare And Swap\u003c/a\u003e词条）意思就是说，看一看内存\u003ccode\u003e*reg\u003c/code\u003e里的值是不是\u003ccode\u003eoldval\u003c/code\u003e，如果是的话，则对其赋值\u003ccode\u003enewval\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint compare_and_swap (int* reg, int oldval, int newval)\n{\n  int old_reg_val = *reg;\n  if (old_reg_val == oldval) {\n     *reg = newval;\n  }\n  return old_reg_val;\n}\n\u003c/pre\u003e\n\u003cp\u003e我们可以看到，\u003ccode\u003eold_reg_val\u003c/code\u003e 总是返回，于是，我们可以在 \u003ccode\u003ecompare_and_swap\u003c/code\u003e 操作之后对其进行测试，以查看它是否与 \u003ccode\u003eoldval\u003c/code\u003e相匹配，因为它可能有所不同，这意味着另一个并发线程已成功地竞争到 \u003ccode\u003ecompare_and_swap\u003c/code\u003e 并成功将 \u003ccode\u003ereg\u003c/code\u003e 值从 \u003ccode\u003eoldval\u003c/code\u003e 更改为别的值了。\u003c/p\u003e\n\u003cp\u003e这个操作可以变种为返回bool值的形式（返回 bool值的好处在于，可以调用者知道有没有更新成功）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003ebool compare_and_swap (int *addr, int oldval, int newval)\n{\n  if ( *addr != oldval ) {\n      return false;\n  }\n  *addr = newval;\n  return true;\n}\u003c/pre\u003e\n\u003cp\u003e与CAS相似的还有下面的原子操作：（这些东西大家自己看Wikipedia，也没什么复杂的）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Fetch-and-add\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eFetch And Add\u003c/a\u003e，一般用来对变量做 +1 的原子操作\u003c/li\u003e\n\u003cli\u003e\u003ca title=\"Test-and-set\" href=\"https://en.wikipedia.org/wiki/Test-and-set\"\u003eTest-and-set\u003c/a\u003e，写值到某个内存位置并传回其旧值。汇编指令BST\u003c/li\u003e\n\u003cli\u003e\u003ca title=\"Test and Test-and-set\" href=\"https://en.wikipedia.org/wiki/Test_and_Test-and-set\"\u003eTest and Test-and-set\u003c/a\u003e，用来低低Test-and-Set的资源争夺情况\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e注：\u003c/strong\u003e在实际的C/C++程序中，CAS的各种实现版本如下：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-8239\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1）GCC的CAS\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eGCC4.1+版本中支持CAS的原子操作（完整的原子操作可参看\u003ca href=\"http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e GCC Atomic Builtins\u003c/a\u003e）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003ebool __sync_bool_compare_and_swap (type *ptr, type oldval type newval, ...)\ntype __sync_val_compare_and_swap (type *ptr, type oldval type newval, ...)\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2）Windows的CAS\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e在Windows下，你可以使用下面的Windows API来完成CAS：（完整的Windows原子操作可参看MSDN的\u003ca href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/ms686360(v=vs.85).aspx#interlocked_functions\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eInterLocked Functions\u003c/a\u003e）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e InterlockedCompareExchange ( __inout LONG volatile *Target,\n                                 __in LONG Exchange,\n                                 __in LONG Comperand);\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3) C++11中的CAS\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eC++11中的STL中的atomic类的函数可以让你跨平台。（完整的C++11的原子操作可参看 \u003ca href=\"http://en.cppreference.com/w/cpp/atomic\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eAtomic Operation Library\u003c/a\u003e）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003etemplate\u0026lt; class T \u0026gt;\nbool atomic_compare_exchange_weak( std::atomic* obj,\n                                   T* expected, T desired );\ntemplate\u0026lt; class T \u0026gt;\nbool atomic_compare_exchange_weak( volatile std::atomic* obj,\n                                   T* expected, T desired );\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0\"\u003e\u003c/span\u003e无锁队列的链表实现\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面的代码主要参考于两篇论文：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eJohn D. Valois 1994年10月在拉斯维加斯的并行和分布系统系统国际大会上的一篇论文——《\u003ca href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674\u0026amp;rep=rep1\u0026amp;type=pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eImplementing Lock-Free Queues\u003c/a\u003e》\u003c/li\u003e\n\u003cli\u003e美国纽约罗切斯特大学 Maged M. Michael 和 Michael L. Scott 在1996年3月发表的一篇论文 《\u003ca href=\"https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSimple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms\u003c/a\u003e》\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（注：下面的代码并不完全与这篇论文相同）\u003c/p\u003e\n\u003cp\u003e初始化一个队列的代码很简，初始化一个dummy结点（注：在链表操作中，使用一个dummy结点，可以少掉很多边界条件的判断），如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eInitQueue(Q)\n{\n    node = new node()\n    node-\u0026gt;next = NULL;\n    Q-\u0026gt;head = Q-\u0026gt;tail = node;\n}\n\u003c/pre\u003e\n\u003cp\u003e我们先来看一下进队列用CAS实现的方式，基本上来说就是链表的两步操作：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e第一步，把tail指针的next指向要加入的结点。 \u003ccode\u003etail-\u0026gt;next = p;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e第二步，把tail指针移到队尾。 \u003ccode\u003etail = p;\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eEnQueue(Q, data) //进队列\n{\n    //准备新加入的结点数据\n    n = new node();\n    n-\u0026gt;value = data;\n    n-\u0026gt;next = NULL;\n\n    do {\n        p = Q-\u0026gt;tail; //取链表尾指针的快照\n    } while( CAS(p-\u0026gt;next, NULL, n) != TRUE); \n    //while条件注释：如果没有把结点链在尾指针上，再试\n\n    CAS(Q-\u0026gt;tail, p, n); //置尾结点 tail = n;\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，程序中的那个 do-while 的 Retry-Loop 中的 CAS 操作：如果 \u003ccode\u003ep-\u0026gt;next\u003c/code\u003e 是 \u003ccode\u003eNULL\u003c/code\u003e，那么，把新结点 \u003ccode\u003en\u003c/code\u003e 加到队尾。如果不成功，则重新再来一次！\u003c/p\u003e\n\u003cp\u003e就是说，很有可能我在准备在队列尾加入结点时，别的线程已经加成功了，于是tail指针就变了，于是我的CAS返回了false，于是程序再试，直到试成功为止。这个很像我们的抢电话热线的不停重播的情况。\u003c/p\u003e\n\u003cp\u003e但是你会看到，为什么我们的“置尾结点”的操作（第13行）不判断是否成功，因为：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果有一个线程T1，它的while中的CAS如果成功的话，那么其它所有的 随后线程的CAS都会失败，然后就会再循环，\u003c/li\u003e\n\u003cli\u003e此时，如果T1 线程还没有更新tail指针，其它的线程继续失败，因为\u003ccode\u003etail-\u0026gt;next\u003c/code\u003e不是NULL了。\u003c/li\u003e\n\u003cli\u003e直到T1线程更新完 \u003ccode\u003etail\u003c/code\u003e 指针，于是其它的线程中的某个线程就可以得到新的 \u003ccode\u003etail\u003c/code\u003e 指针，继续往下走了。\u003c/li\u003e\n\u003cli\u003e所以，只要线程能从 while 循环中退出来，意味着，它已经“独占”了，\u003ccode\u003etail\u003c/code\u003e 指针必然可以被更新。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里有一个潜在的问题——\u003cstrong\u003e如果T1线程在用CAS更新tail指针的之前，线程停掉或是挂掉了，那么其它线程就进入死循环了\u003c/strong\u003e。下面是改良版的EnQueue()\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"10,11\"\u003eEnQueue(Q, data) //进队列改良版 v1\n{\n    n = new node();\n    n-\u0026gt;value = data;\n    n-\u0026gt;next = NULL;\n\n    p = Q-\u0026gt;tail;\n    oldp = p\n    do {\n        while (p-\u0026gt;next != NULL)\n            p = p-\u0026gt;next;\n    } while( CAS(p.next, NULL, n) != TRUE); //如果没有把结点链在尾上，再试\n\n    CAS(Q-\u0026gt;tail, oldp, n); //置尾结点\n}\u003c/pre\u003e\n\u003cp\u003e我们让每个线程，自己fetch 指针 \u003ccode\u003ep\u003c/code\u003e 到链表尾。但是这样的fetch会很影响性能。而且，如果一个线程不断的EnQueue，会导致所有的其它线程都去 fetch 他们的 \u003ccode\u003ep\u003c/code\u003e 指针到队尾，能不能不要所有的线程都干同一个事？这样可以节省整体的时间？\u003c/p\u003e\n\u003cp\u003e比如：直接 fetch \u003ccode\u003eQ-\u0026gt;tail\u003c/code\u003e 到队尾？因为，所有的线程都共享着 Q-\u0026gt;tail，所以，一旦有人动了它后，相当于其它的线程也跟着动了，于是，我们的代码可以改进成如下的实现：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eEnQueue(Q, data) //进队列改良版 v2 \n{\n    n = new node();\n    n-\u0026gt;value = data;\n    n-\u0026gt;next = NULL;\n\n    while(TRUE) {\n        //先取一下尾指针和尾指针的next\n        tail = Q-\u0026gt;tail;\n        next = tail-\u0026gt;next;\n\n        //如果尾指针已经被移动了，则重新开始\n        if ( tail != Q-\u0026gt;tail ) continue;\n\n        //如果尾指针的 next 不为NULL，则 fetch 全局尾指针到next\n        if ( next != NULL ) {\n            CAS(Q-\u0026gt;tail, tail, next);\n            continue;\n        }\n\n        //如果加入结点成功，则退出\n        if ( CAS(tail-\u0026gt;next, next, n) == TRUE ) break;\n    }\n    CAS(Q-\u0026gt;tail, tail, n); //置尾结点\n}\n\u003c/pre\u003e\n\u003cp\u003e上述的代码还是很清楚的，相信你一定能看懂，而且，这也是 Java 中的 \u003ccode\u003eConcurrentLinkedQueue\u003c/code\u003e 的实现逻辑，当然，我上面的这个版本比 Java 的好一点，因为没有 if 嵌套，嘿嘿。\u003c/p\u003e\n\u003cp\u003e好了，我们解决了EnQueue，我们再来看看DeQueue的代码：（很简单，我就不解释了）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eDeQueue(Q) //出队列\n{\n    do{\n        p = Q-\u0026gt;head;\n        if (p-\u0026gt;next == NULL){\n            return ERR_EMPTY_QUEUE;\n        }\n    while( CAS(Q-\u0026gt;head, p, p-\u0026gt;next) != TRUE );\n    return p-\u0026gt;next-\u0026gt;value;\n}\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e我们可以看到，DeQueue的代码操作的是 \u003ccode\u003ehead-\u0026gt;next\u003c/code\u003e，而不是 \u003ccode\u003ehead\u003c/code\u003e 本身。这样考虑是因为一个边界条件，我们需要一个dummy的头指针来解决链表中如果只有一个元素，\u003ccode\u003ehead\u003c/code\u003e 和 \u003ccode\u003etail\u003c/code\u003e 都指向同一个结点的问题，这样 \u003ccode\u003eEnQueue\u003c/code\u003e 和 \u003ccode\u003eDeQueue\u003c/code\u003e 要互相排斥了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e但是，如果 \u003ccode\u003ehead\u003c/code\u003e 和 \u003ccode\u003etail\u003c/code\u003e 都指向同一个结点，这意味着队列为空，应该返回 \u003ccode\u003eERR_EMPTY_QUEUE\u003c/code\u003e，但是，在判断 \u003ccode\u003ep-\u0026gt;next == NULL\u003c/code\u003e 时，另外一个EnQueue操作做了一半，此时的 p-\u0026gt;next 不为 NULL了，但是 tail 指针还差最后一步，没有更新到新加的结点，这个时候就会出现，在 EnQueue 并没有完成的时候， DeQueue 已经把新增加的结点给取走了，此时，队列为空，但是，head 与 tail 并没有指向同一个结点。如下所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-20047\" src=\"https://coolshell.cn/wp-content/uploads/2012/09/lock.free_.queue_-224x300.png\" alt=\"\" width=\"400\" height=\"537\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/09/lock.free_.queue_-224x300.png 224w, https://coolshell.cn/wp-content/uploads/2012/09/lock.free_.queue_-201x270.png 201w, https://coolshell.cn/wp-content/uploads/2012/09/lock.free_.queue_.png 706w\" sizes=\"(max-width: 400px) 100vw, 400px\"/\u003e\u003c/p\u003e\n\u003cp\u003e虽然，EnQueue的函数会把 tail 指针置对，但是，这种情况可能还是会导致一些并发问题，所以，严谨来说，我们需要避免这种情况。于是，我们需要加入更多的判断条件，还确保这个问题。下面是相关的改进代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eDeQueue(Q) //出队列，改进版\n{\n    while(TRUE) {\n        //取出头指针，尾指针，和第一个元素的指针\n        head = Q-\u0026gt;head;\n        tail = Q-\u0026gt;tail;\n        next = head-\u0026gt;next;\n\n        // Q-\u0026gt;head 指针已移动，重新取 head指针\n        if ( head != Q-\u0026gt;head ) continue;\n        \n        // 如果是空队列\n        if ( head == tail \u0026amp;\u0026amp; next == NULL ) {\n            return ERR_EMPTY_QUEUE;\n        }\n        \n        //如果 tail 指针落后了\n        if ( head == tail \u0026amp;\u0026amp; next == NULL ) {\n            CAS(Q-\u0026gt;tail, tail, next);\n            continue;\n        }\n\n        //移动 head 指针成功后，取出数据\n        if ( CAS( Q-\u0026gt;head, head, next) == TRUE){\n            value = next-\u0026gt;value;\n            break;\n        }\n    }\n    free(head); //释放老的dummy结点\n    return value;\n}\u003c/pre\u003e\n\u003cp\u003e上面这段代码的逻辑和 Java 的 \u003ccode\u003eConcurrentLinkedQueue\u003c/code\u003e 的 \u003ccode\u003epoll\u003c/code\u003e 方法很一致了。也是《\u003ca href=\"https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSimple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms\u003c/a\u003e》这篇论文中的实现。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CAS%E7%9A%84ABA%E9%97%AE%E9%A2%98\"\u003e\u003c/span\u003eCAS的ABA问题\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e所谓ABA（\u003ca href=\"https://en.wikipedia.org/wiki/ABA_problem\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e见维基百科的ABA词条\u003c/a\u003e），问题基本是这个样子：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e进程P1在共享变量中读到值为A\u003c/li\u003e\n\u003cli\u003eP1被抢占了，进程P2执行\u003c/li\u003e\n\u003cli\u003eP2把共享变量里的值从A改成了B，再改回到A，此时被P1抢占。\u003c/li\u003e\n\u003cli\u003eP1回来看到共享变量里的值没有被改变，于是继续执行。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e虽然P1以为变量值没有改变，继续执行了，但是这个会引发一些潜在的问题。\u003cstrong\u003eABA问题最容易发生在lock free 的算法中的，CAS首当其冲，因为CAS判断的是指针的值。很明显，值是很容易又变成原样的。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e比如上述的DeQueue()函数，因为我们要让head和tail分开，所以我们引入了一个dummy指针给head，当我们做CAS的之前，如果head的那块内存被回收并被重用了，而重用的内存又被EnQueue()进来了，这会有很大的问题。（\u003cstrong\u003e内存管理中重用内存基本上是一种很常见的行为\u003c/strong\u003e）\u003c/p\u003e\n\u003cp\u003e这个例子你可能没有看懂，维基百科上给了一个活生生的例子——\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e你拿着一个装满钱的手提箱在飞机场，此时过来了一个火辣性感的美女，然后她很暖昧地挑逗着你，并趁你不注意的时候，把用一个一模一样的手提箱和你那装满钱的箱子调了个包，然后就离开了，你看到你的手提箱还在那，于是就提着手提箱去赶飞机去了。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这就是ABA的问题。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%A7%A3%E5%86%B3ABA%E7%9A%84%E9%97%AE%E9%A2%98\"\u003e\u003c/span\u003e解决ABA的问题\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e维基百科上给了一个解——使用double-CAS（双保险的CAS），例如，在32位系统上，我们要检查64位的内容\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）一次用CAS检查双倍长度的值，前半部是值，后半部分是一个计数器。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）只有这两个都一样，才算通过检查，要吧赋新的值。并把计数器累加1。\u003c/p\u003e\n\u003cp\u003e这样一来，ABA发生时，虽然值一样，但是计数器就不一样（但是在32位的系统上，这个计数器会溢出回来又从1开始的，这还是会有ABA的问题）\u003c/p\u003e\n\u003cp\u003e当然，我们这个队列的问题就是不想让那个内存重用，这样明确的业务问题比较好解决，论文《\u003ca href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674\u0026amp;rep=rep1\u0026amp;type=pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eImplementing Lock-Free Queues\u003c/a\u003e》给出一这么一个方法——\u003cstrong\u003e使用结点内存引用计数refcnt\u003c/strong\u003e！（论文《\u003ca href=\"https://www.cs.rochester.edu/u/scott/papers/1996_PODC_queues.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSimple, Fast, and Practical Non-Blocking and Blocking ConcurrentQueue Algorithms\u003c/a\u003e》中的实现方法也基本上是一样的，用到的是增加一个计数，可以理解为版本号）\u003c/p\u003e\n\u003cp\u003e）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"9,14\"\u003eSafeRead(q)\n{\n    loop:\n        p = q-\u0026gt;next;\n        if (p == NULL){\n            return p;\n        }\n\n        Fetch\u0026amp;Add(p-\u0026gt;refcnt, 1);\n\n        if (p == q-\u0026gt;next){\n            return p;\n        }else{\n            Release(p);\n        }\n    goto loop;\n}\u003c/pre\u003e\n\u003cp\u003e其中的 Fetch\u0026amp;Add和Release分是是加引用计数和减引用计数，都是原子操作，这样就可以阻止内存被回收了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97\"\u003e\u003c/span\u003e用数组实现无锁队列\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e本实现来自论文《\u003ca href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.8674\u0026amp;rep=rep1\u0026amp;type=pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eImplementing Lock-Free Queues\u003c/a\u003e》\u003c/p\u003e\n\u003cp\u003e使用数组来实现队列是很常见的方法，因为没有内存的分部和释放，一切都会变得简单，实现的思路如下：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）数组队列应该是一个ring buffer形式的数组（环形数组）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）数组的元素应该有三个可能的值：HEAD，TAIL，EMPTY（当然，还有实际的数据）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）数组一开始全部初始化成EMPTY，有两个相邻的元素要初始化成HEAD和TAIL，这代表空队列。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）EnQueue操作。假设数据x要入队列，定位TAIL的位置，使用double-CAS方法把(TAIL, EMPTY) 更新成 (x, TAIL)。需要注意，如果找不到(TAIL, EMPTY)，则说明队列满了。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e5）DeQueue操作。定位HEAD的位置，把(HEAD, x)更新成(EMPTY, HEAD)，并把x返回。同样需要注意，如果x是TAIL，则说明队列为空。\u003c/p\u003e\n\u003cp\u003e算法的一个关键是——如何定位HEAD或TAIL？\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）我们可以声明两个计数器，一个用来计数EnQueue的次数，一个用来计数DeQueue的次数。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）这两个计算器使用使用Fetch\u0026amp;ADD来进行原子累加，在EnQueue或DeQueue完成的时候累加就好了。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）累加后求个模什么的就可以知道TAIL和HEAD的位置了。\u003c/p\u003e\n\u003cp\u003e如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-8240\" title=\"Lock-Free Queue(Array)\" src=\"https://coolshell.cn/wp-content/uploads/2012/09/lock-free-array.jpg\" alt=\"\" width=\"477\" height=\"215\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/09/lock-free-array.jpg 477w, https://coolshell.cn/wp-content/uploads/2012/09/lock-free-array-300x135.jpg 300w\" sizes=\"(max-width: 477px) 100vw, 477px\"/\u003e\u003c/p\u003e\n\u003ch4 style=\"text-align: left;\"\u003e\u003cspan class=\"ez-toc-section\" id=\"_%E5%B0%8F%E7%BB%93\"\u003e\u003c/span\u003e 小结\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp style=\"text-align: left;\"\u003e以上基本上就是所有的无锁队列的技术细节，这些技术都可以用在其它的无锁数据结构上。\u003c/p\u003e\n\u003cp style=\"text-align: left; padding-left: 30px;\"\u003e1）无锁队列主要是通过CAS、FAA这些原子操作，和Retry-Loop实现。\u003c/p\u003e\n\u003cp style=\"text-align: left; padding-left: 30px;\"\u003e2）对于Retry-Loop，我个人感觉其实和锁什么什么两样。只是这种“锁”的粒度变小了，主要是“锁”HEAD和TAIL这两个关键资源。而不是整个数据结构。\u003c/p\u003e\n\u003cp style=\"text-align: left;\"\u003e还有一些和Lock Free的文章你可以去看看：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCode Project 上的雄文 《\u003ca href=\"http://www.codeproject.com/Articles/153898/Yet-another-implementation-of-a-lock-free-circular\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eYet another implementation of a lock-free circular array queue\u003c/a\u003e》\u003c/li\u003e\n\u003cli\u003eHerb Sutter的《\u003ca href=\"http://www.drdobbs.com/parallel/writing-lock-free-code-a-corrected-queue/210604448?pgno=1\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eWriting Lock-Free Code: A Corrected Queue\u003c/a\u003e》– 用C++11的std::atomic模板。\u003c/li\u003e\n\u003cli\u003eIBM developerWorks的《\u003ca href=\"http://www.ibm.com/developerworks/cn/aix/library/au-multithreaded_structures2/index.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e设计不使用互斥锁的并发数据结构\u003c/a\u003e》\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv\u003e【\u003cstrong\u003e注：我配了一张look-free的自行车，寓意为——如果不用专门的车锁，那么自行得自己锁自己！\u003c/strong\u003e】\u003c/div\u003e\n\u003cp style=\"text-align: left;\"\u003e （全文完）\u003c/p\u003e\n\u003cp\u003e\u003caudio style=\"display: none;\" controls=\"controls\"\u003e\u003c/audio\u003e\u003c/p\u003e\n\u003cp\u003e\u003caudio style=\"display: none;\" controls=\"controls\"\u003e\u003c/audio\u003e\u003c/p\u003e\n\u003cp\u003e\u003caudio style=\"display: none;\" controls=\"controls\"\u003e\u003c/audio\u003e\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg\" alt=\"Leetcode 编程训练\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_title\"\u003eLeetcode 编程训练\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/10975.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/0.jpg\" alt=\"一个“蝇量级” C 语言协程库\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/10975.html\" class=\"wp_rp_title\"\u003e一个“蝇量级” C 语言协程库\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9886.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/8.jpg\" alt=\"二叉树迭代器算法\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9886.html\" class=\"wp_rp_title\"\u003e二叉树迭代器算法\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7886.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/07/muxnt-150x150.jpg\" alt=\"代码执行的效率\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7886.html\" class=\"wp_rp_title\"\u003e代码执行的效率\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6548.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/02/WhyCPP.01-150x150.jpg\" alt=\"Why C++ ? 王者归来\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6548.html\" class=\"wp_rp_title\"\u003eWhy C++ ? 王者归来\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6010.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/23.jpg\" alt=\"一些有意思的算法代码\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6010.html\" class=\"wp_rp_title\"\u003e一些有意思的算法代码\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-8239\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"88efaf8464\"\u003e\u003cimg id=\"rating_8239_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8239, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-fc3045d72b2ed62ee7156d35-=\"\"/\u003e\u003cimg id=\"rating_8239_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8239, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-fc3045d72b2ed62ee7156d35-=\"\"/\u003e\u003cimg id=\"rating_8239_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8239, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-fc3045d72b2ed62ee7156d35-=\"\"/\u003e\u003cimg id=\"rating_8239_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8239, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-fc3045d72b2ed62ee7156d35-=\"\"/\u003e\u003cimg id=\"rating_8239_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8239, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-fc3045d72b2ed62ee7156d35-=\"\"/\u003e (\u003cstrong\u003e56\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.25\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_8239_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"无锁队列的实现\"/\u003e\u003cmeta itemprop=\"headline\" content=\"无锁队列的实现\"/\u003e\u003cmeta itemprop=\"description\" content=\"————注：本文于2019年11月4日更新————\n\n关于无锁队列的实现，网上有很多文章，虽然本文可能和那些文章有所重复，但是我还是想以我自己的方式把这些文章中的重要的知识点串起来和大家讲一讲这个技术。下面开始正文。\n\n关于CAS等原子操作\n\n在开始说无锁队列之前，我们需要知道一个很重要的技术就是CAS操作——Compare \u0026amp; Set，或是 Compare \u0026amp; Swap，现在几乎所有的CPU指令...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-09-07T08:26:55+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-06T18:11:27+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/8239.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/8239.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.25\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"56\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-8239-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-09-07T08:26:55+08:00",
  "Author": "陈皓"
}