{
  "Source": "coolshell.cn",
  "Title": "Go编程模式 ： 泛型编程",
  "Link": "https://coolshell.cn/articles/21615.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"86b4b3650bc1bd4ee36a9c88-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright wp-image-21627 \" src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-1024x512.png\" alt=\"\" width=\"406\" height=\"203\" srcset=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-1024x512.png 1024w, https://coolshell.cn/wp-content/uploads/2021/09/go-generics-300x150.png 300w, https://coolshell.cn/wp-content/uploads/2021/09/go-generics-768x384.png 768w, https://coolshell.cn/wp-content/uploads/2021/09/go-generics-540x270.png 540w, https://coolshell.cn/wp-content/uploads/2021/09/go-generics.png 1200w\" sizes=\"(max-width: 406px) 100vw, 406px\"/\u003eGo语言的1.17版本发布了，其中开始正式支持泛型了。虽然还有一些限制（比如，不能把泛型函数export），但是，可以体验了。我的这个《Go编程模式》的系列终于有了真正的泛型编程了，再也不需要使用反射或是go generation这些难用的技术了。周末的时候，我把Go 1.17下载下来，然后，体验了一下泛型编程，还是很不错的。下面，就让我们来看一下Go的泛型编程。（注：不过，如果你对泛型编程的重要性还不是很了解的话，你可以先看一下之前的这篇文章《\u003ca title=\"Go 编程模式：Go Generation\" href=\"https://coolshell.cn/articles/21179.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：Go Generation\u003c/a\u003e》，然后再读一下《\u003ca title=\"Go编程模式：Map-Reduce\" href=\"https://coolshell.cn/articles/21164.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：MapReduce\u003c/a\u003e》）\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第10 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式 ： 泛型编程\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21263.html\" rel=\"prev\" title=\"Go 编程模式：k8s Visitor 模式\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E5%88%9D%E6%8E%A2\" title=\"初探\"\u003e初探\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" title=\"数据结构\"\u003e数据结构\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Stack_%E6%A0%88\" title=\"Stack 栈\"\u003eStack 栈\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#LinkList_%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\" title=\"LinkList 双向链表\"\u003eLinkList 双向链表\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%87%BD%E6%95%B0%E5%BC%8F%E8%8C%83%E5%9E%8B\" title=\"函数式范型\"\u003e函数式范型\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E6%B3%9B%E5%9E%8BMap\" title=\"泛型Map\"\u003e泛型Map\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E6%B3%9B%E5%9E%8B_Reduce\" title=\"泛型 Reduce\"\u003e泛型 Reduce\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E6%B3%9B%E5%9E%8B_filter\" title=\"泛型 filter\"\u003e泛型 filter\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E4%B8%9A%E5%8A%A1%E7%A4%BA%E4%BE%8B\" title=\"业务示例\"\u003e业务示例\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%88%9D%E6%8E%A2\"\u003e\u003c/span\u003e初探\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们先来看一个简单的示例：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21615\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc print[T any] (arr []T) {\n  for _, v := range arr {\n    fmt.Print(v)\n    fmt.Print(\u0026#34; \u0026#34;)\n  }\n  fmt.Println(\u0026#34;\u0026#34;)\n}\n\nfunc main() {\n  strs := []string{\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;,  \u0026#34;Generics\u0026#34;}\n  decs := []float64{3.14, 1.14, 1.618, 2.718 }\n  nums := []int{2,4,6,8}\n\n  print(strs)\n  print(decs)\n  print(nums)\n}\u003c/pre\u003e\n\u003cp\u003e上面这个例子中，有一个 \u003ccode\u003eprint()\u003c/code\u003e 函数，这个函数就是想输出数组的值，如果没有泛型的话，这个函数需要写出 \u003ccode\u003eint\u003c/code\u003e 版，\u003ccode\u003efloat\u003c/code\u003e版，\u003ccode\u003estring\u003c/code\u003e 版，以及我们的自定义类型（\u003ccode\u003estruct\u003c/code\u003e）的版本。现在好了，有了泛型的支持后，我们可以使用 \u003ccode\u003e[T any]\u003c/code\u003e 这样的方式来声明一个泛型类型（有点像C++的 \u003ccode\u003etypename T\u003c/code\u003e），然后面都使用 \u003ccode\u003eT\u003c/code\u003e 来声明变量就好。\u003c/p\u003e\n\u003cp\u003e上面这个示例中，我们泛型的 \u003ccode\u003eprint()\u003c/code\u003e 支持了三种类型的适配—— \u003ccode\u003eint\u003c/code\u003e型，\u003ccode\u003efloat64\u003c/code\u003e型，和 \u003ccode\u003estring\u003c/code\u003e型。要让这段程序跑起来需要在编译行上加上 \u003ccode\u003e-gcflags=-G=3\u003c/code\u003e编译参数（这个编译参数会在1.18版上成为默认参数），如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$ go run -gcflags=-G=3 ./main.go\u003c/pre\u003e\n\u003cp\u003e有了个操作以后，我们就可以写一些标准的算法了，比如，一个查找的算法\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc find[T comparable] (arr []T, elem T) int {\n  for i, v := range arr {\n    if  v == elem {\n      return i\n    }\n  }\n  return -1\n}\u003c/pre\u003e\n\u003cp\u003e我们注意到，我们没有使用 \u003ccode\u003e[T any]\u003c/code\u003e的形式，而是使用 \u003ccode\u003e[T comparable]\u003c/code\u003e的形式，\u003ccode\u003ecomparable\u003c/code\u003e是一个接口类型，其约束了我们的类型需要支持 \u003ccode\u003e==\u003c/code\u003e 的操作， 不然就会有类型不对的编译错误。上面的这个 \u003ccode\u003efind()\u003c/code\u003e 函数同样可以使用于 \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat64\u003c/code\u003e或是\u003ccode\u003estring\u003c/code\u003e类型。\u003c/p\u003e\n\u003cp\u003e从上面的这两个小程序来看，Go语言的泛型已基本可用了，只不过，还有三个问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个是 \u003ccode\u003efmt.Printf()\u003c/code\u003e中的泛型类型是 \u003ccode\u003e%v\u003c/code\u003e 还不够好，不能像c++ \u003ccode\u003eiostream\u003c/code\u003e重载 \u003ccode\u003e\u0026gt;\u0026gt;\u003c/code\u003e 来获得程序自定义的输出。\u003c/li\u003e\n\u003cli\u003e另外一个是，go不支持操作符重载，所以，你也很难在泛型算法中使用“泛型操作符”如：\u003ccode\u003e==\u003c/code\u003e 等\u003c/li\u003e\n\u003cli\u003e最后一个是，上面的 \u003ccode\u003efind()\u003c/code\u003e 算法依赖于“数组”，对于hash-table、tree、graph、link等数据结构还要重写。也就是说，没有一个像C++ STL那样的一个泛型迭代器（这其中的一部分工作当然也需要通过重载操作符（如：\u003ccode\u003e++\u003c/code\u003e 来实现）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不过，这个已经很好了，让我们来看一下，可以干哪些事了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"\u003e\u003c/span\u003e数据结构\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Stack_%E6%A0%88\"\u003e\u003c/span\u003eStack 栈\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e编程支持泛型最大的优势就是可以实现类型无关的数据结构了。下面，我们用Slices这个结构体来实现一个Stack的数结构。\u003c/p\u003e\n\u003cp\u003e首先，我们可以定义一个泛型的Stack\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype stack [T any] []T\u003c/pre\u003e\n\u003cp\u003e看上去很简单，还是 \u003ccode\u003e[T any]\u003c/code\u003e ，然后 \u003ccode\u003e[]T\u003c/code\u003e 就是一个数组，接下来就是实现这个数据结构的各种方法了。下面的代码实现了 \u003ccode\u003epush()\u003c/code\u003e ，\u003ccode\u003epop()\u003c/code\u003e，\u003ccode\u003etop()\u003c/code\u003e，\u003ccode\u003elen()\u003c/code\u003e，\u003ccode\u003eprint()\u003c/code\u003e这几个方法，这几个方法和 C++的STL中的 Stack很类似。（注：目前Go的泛型函数不支持 export，所以只能使用第一个字符是小写的函数名）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc (s *stack[T]) push(elem T) {\n  *s = append(*s, elem)\n}\n\nfunc (s *stack[T]) pop() {\n  if len(*s) \u0026gt; 0 {\n    *s = (*s)[:len(*s)-1]\n  } \n}\nfunc (s *stack[T]) top() *T{\n  if len(*s) \u0026gt; 0 {\n    return \u0026amp;(*s)[len(*s)-1]\n  } \n  return nil\n}\n\nfunc (s *stack[T]) len() int{\n  return len(*s)\n}\n\nfunc (s *stack[T]) print() {\n  for _, elem := range *s {\n    fmt.Print(elem)\n    fmt.Print(\u0026#34; \u0026#34;)\n  }\n  fmt.Println(\u0026#34;\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e上面的这个例子还是比较简单的，不过在实现的过程中，对于一个如果栈为空，那么 \u003ccode\u003etop()\u003c/code\u003e要么返回\u003ccode\u003eerror\u003c/code\u003e要么返回空值，在这个地方卡了一下。因为，之前，我们返回的“空”值，要么是 int 的\u003ccode\u003e0\u003c/code\u003e，要么是 string 的 \u003ccode\u003e“”\u003c/code\u003e，然而在泛型的\u003ccode\u003eT\u003c/code\u003e下，这个值就不容易搞了。也就是说，除了类型泛型后，还需要有一些“值的泛型”（注：在C++中，如果你要用一个空栈进行 \u003ccode\u003etop()\u003c/code\u003e 操作，你会得到一个 segmentation fault），所以，这里我们返回的是一个指针，这样可以判断一下指针是否为空。\u003c/p\u003e\n\u003cp\u003e下面是如何使用这个stack的代码。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main() {\n\n  ss := stack[string]{}\n  ss.push(\u0026#34;Hello\u0026#34;)\n  ss.push(\u0026#34;Hao\u0026#34;)\n  ss.push(\u0026#34;Chen\u0026#34;)\n  ss.print()\n  fmt.Printf(\u0026#34;stack top is - %v\\n\u0026#34;, *(ss.top()))\n  ss.pop()\n  ss.pop()\n  ss.print()\n\n  \n  ns := stack[int]{}\n  ns.push(10)\n  ns.push(20)\n  ns.print()\n  ns.pop()\n  ns.print()\n  *ns.top() += 1\n  ns.print()\n  ns.pop()\n  fmt.Printf(\u0026#34;stack top is - %v\\n\u0026#34;, ns.top())\n\n}\u003c/pre\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"LinkList_%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"\u003e\u003c/span\u003eLinkList 双向链表\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面我们再来看一个双向链表的实现。下面这个实现中实现了 这几个方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eadd()\u003c/code\u003e – 从头插入一个数据结点\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epush()\u003c/code\u003e – 从尾插入一个数据结点\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edel()\u003c/code\u003e – 删除一个结点（因为需要比较，所以使用了 \u003ccode\u003ecompareable\u003c/code\u003e 的泛型）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprint()\u003c/code\u003e – 从头遍历一个链表，并输出值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype node[T comparable] struct {\n  data T\n  prev *node[T]\n  next *node[T]\n}\n\ntype list[T comparable] struct {\n  head, tail *node[T]\n  len int\n}\n\nfunc (l *list[T]) isEmpty() bool {\n  return l.head == nil \u0026amp;\u0026amp; l.tail == nil\n}\n\nfunc (l *list[T]) add(data T) {\n  n := \u0026amp;node[T] {\n    data : data,\n    prev : nil,\n    next : l.head,\n  }\n  if l.isEmpty() {\n    l.head = n\n    l.tail = n\n  }\n  l.head.prev = n\n  l.head = n\n}\n\nfunc (l *list[T]) push(data T) { \n  n := \u0026amp;node[T] {\n    data : data,\n    prev : l.tail,\n    next : nil,\n  }\n  if l.isEmpty() {\n    l.head = n\n    l.tail = n\n  }\n  l.tail.next = n\n  l.tail = n\n}\n\nfunc (l *list[T]) del(data T) { \n  for p := l.head; p != nil; p = p.next {\n    if data == p.data {\n      \n      if p == l.head {\n        l.head = p.next\n      }\n      if p == l.tail {\n        l.tail = p.prev\n      }\n      if p.prev != nil {\n        p.prev.next = p.next\n      }\n      if p.next != nil {\n        p.next.prev = p.prev\n      }\n      return \n    }\n  } \n}\n\nfunc (l *list[T]) print() {\n  if l.isEmpty() {\n    fmt.Println(\u0026#34;the link list is empty.\u0026#34;)\n    return \n  }\n  for p := l.head; p != nil; p = p.next {\n    fmt.Printf(\u0026#34;[%v] -\u0026gt; \u0026#34;, p.data)\n  }\n  fmt.Println(\u0026#34;nil\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e上面这个代码都是一些比较常规的链表操作，学过链表数据结构的同学应该都不陌生，使用的代码也不难，如下所示，都很简单，看代码就好了。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main(){\n  var l = list[int]{}\n  l.add(1)\n  l.add(2)\n  l.push(3)\n  l.push(4)\n  l.add(5)\n  l.print() //[5] -\u0026gt; [2] -\u0026gt; [1] -\u0026gt; [3] -\u0026gt; [4] -\u0026gt; nil\n  l.del(5)\n  l.del(1)\n  l.del(4)\n  l.print() //[2] -\u0026gt; [3] -\u0026gt; nil\n  \n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%87%BD%E6%95%B0%E5%BC%8F%E8%8C%83%E5%9E%8B\"\u003e\u003c/span\u003e函数式范型\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e接下来，我们就要来看一下我们函数式编程的三大件 \u003ccode\u003emap()\u003c/code\u003e 、 \u003ccode\u003ereduce()\u003c/code\u003e 和 \u003ccode\u003efilter()\u003c/code\u003e 在之前的《\u003ca title=\"Go编程模式：Map-Reduce\" href=\"https://coolshell.cn/articles/21164.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e》文章中，我们可以看到要实现这样的泛型，需要用到反射，代码复杂到完全读不懂。下面来看一下真正的泛型版本。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%9B%E5%9E%8BMap\"\u003e\u003c/span\u003e泛型Map\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc gMap[T1 any, T2 any] (arr []T1, f func(T1) T2) []T2 {\n  result := make([]T2, len(arr))\n  for i, elem := range arr {\n    result[i] = f(elem)\n  }\n  return result\n}\u003c/pre\u003e\n\u003cp\u003e在上面的这个 map函数中我使用了两个类型 – \u003ccode\u003eT1\u003c/code\u003e 和 \u003ccode\u003eT2\u003c/code\u003e ，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eT1\u003c/code\u003e – 是需要处理数据的类型\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eT2\u003c/code\u003e – 是处理后的数据类型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eT1\u003c/code\u003e 和 \u003ccode\u003eT2\u003c/code\u003e 可以一样，也可以不一样。\u003c/p\u003e\n\u003cp\u003e我们还有一个函数参数 –  \u003ccode\u003efunc(T1) T2\u003c/code\u003e 意味着，进入的是 \u003ccode\u003eT1\u003c/code\u003e 类型的，出来的是 \u003ccode\u003eT2\u003c/code\u003e 类型的。\u003c/p\u003e\n\u003cp\u003e然后，整个函数返回的是一个 \u003ccode\u003e[]T2\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e好的，我们来看一下怎么使用这个map函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003enums := []int {0,1,2,3,4,5,6,7,8,9}\nsquares := gMap(nums, func (elem int) int {\n  return elem * elem\n})\nprint(squares)  //0 1 4 9 16 25 36 49 64 81 \n\nstrs := []string{\u0026#34;Hao\u0026#34;, \u0026#34;Chen\u0026#34;, \u0026#34;MegaEase\u0026#34;}\nupstrs := gMap(strs, func(s string) string  {\n  return strings.ToUpper(s)\n})\nprint(upstrs) // HAO CHEN MEGAEASE \n\n\ndict := []string{\u0026#34;零\u0026#34;, \u0026#34;壹\u0026#34;, \u0026#34;贰\u0026#34;, \u0026#34;叁\u0026#34;, \u0026#34;肆\u0026#34;, \u0026#34;伍\u0026#34;, \u0026#34;陆\u0026#34;, \u0026#34;柒\u0026#34;, \u0026#34;捌\u0026#34;, \u0026#34;玖\u0026#34;}\nstrs =  gMap(nums, func (elem int) string  {\n  return  dict[elem]\n})\nprint(strs) // 零 壹 贰 叁 肆 伍 陆 柒 捌 玖\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%9B%E5%9E%8B_Reduce\"\u003e\u003c/span\u003e泛型 Reduce\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e接下来，我们再来看一下我们的Reduce函数，reduce函数是把一堆数据合成一个。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc gReduce[T1 any, T2 any] (arr []T1, init T2, f func(T2, T1) T2) T2 {\n  result := init\n  for _, elem := range arr {\n    result = f(result, elem)\n  }\n  return result\n}\u003c/pre\u003e\n\u003cp\u003e函数实现起来很简单，但是感觉不是很优雅。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e也是有两个类型 \u003ccode\u003eT1\u003c/code\u003e 和 \u003ccode\u003eT2\u003c/code\u003e，前者是输出数据的类型，后者是佃出数据的类型。\u003c/li\u003e\n\u003cli\u003e因为要合成一个数据，所以需要有这个数据的初始值 \u003ccode\u003einit\u003c/code\u003e，是 \u003ccode\u003eT2\u003c/code\u003e 类型\u003c/li\u003e\n\u003cli\u003e而自定义函数 \u003ccode\u003efunc(T2, T1) T2\u003c/code\u003e，会把这个init值传给用户，然后用户处理完后再返回出来。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e下面是一个使用上的示例——求一个数组的和\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003enums := []int {0,1,2,3,4,5,6,7,8,9}\nsum := gReduce(nums, 0, func (result, elem int) int  {\n    return result + elem\n})\nfmt.Printf(\u0026#34;Sum = %d \\n\u0026#34;, sum)\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%9B%E5%9E%8B_filter\"\u003e\u003c/span\u003e泛型 filter\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003efilter函数主要是用来做过滤的，把数据中一些符合条件（filter in）或是不符合条件（filter out）的数据过滤出来，下面是相关的代码示例\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc gFilter[T any] (arr []T, in bool, f func(T) bool) []T {\n  result := []T{}\n  for _, elem := range arr {\n    choose := f(elem)\n    if (in \u0026amp;\u0026amp; choose) || (!in \u0026amp;\u0026amp; !choose) {\n      result = append(result, elem)\n    }\n  }\n  return result\n}\n\nfunc gFilterIn[T any] (arr []T, f func(T) bool) []T {\n  return gFilter(arr, true, f)\n}\n\nfunc gFilterOut[T any] (arr []T, f func(T) bool) []T {\n  return gFilter(arr, false, f)\n}\u003c/pre\u003e\n\u003cp\u003e其中，用户需要提从一个 \u003ccode\u003ebool\u003c/code\u003e 的函数，我们会把数据传给用户，然后用户只需要告诉我行还是不行，于是我们就会返回一个过滤好的数组给用户。\u003c/p\u003e\n\u003cp\u003e比如，我们想把数组中所有的奇数过滤出来\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003enums := []int {0,1,2,3,4,5,6,7,8,9}\nodds := gFilterIn(nums, func (elem int) bool  {\n    return elem % 2 == 1\n})\nprint(odds)\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%9A%E5%8A%A1%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e业务示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e正如《\u003ca title=\"Go编程模式：Map-Reduce\" href=\"https://coolshell.cn/articles/21164.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e》中的那个业务示例，我们在这里再做一遍。\u003c/p\u003e\n\u003cp\u003e首先，我们先声明一个员工对象和相关的数据\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Employee struct {\n  Name     string\n  Age      int\n  Vacation int\n  Salary   float32\n}\n\nvar employees = []Employee{\n  {\u0026#34;Hao\u0026#34;, 44, 0, 8000.5},\n  {\u0026#34;Bob\u0026#34;, 34, 10, 5000.5},\n  {\u0026#34;Alice\u0026#34;, 23, 5, 9000.0},\n  {\u0026#34;Jack\u0026#34;, 26, 0, 4000.0},\n  {\u0026#34;Tom\u0026#34;, 48, 9, 7500.75},\n  {\u0026#34;Marry\u0026#34;, 29, 0, 6000.0},\n  {\u0026#34;Mike\u0026#34;, 32, 8, 4000.3},\n}\u003c/pre\u003e\n\u003cp\u003e然后，我们想统一下所有员工的薪水，我们就可以使用前面的reduce函数\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etotal_pay := gReduce(employees, 0.0, func(result float32, e Employee) float32 {\n  return result + e.Salary\n})\nfmt.Printf(\u0026#34;Total Salary: %0.2f\\n\u0026#34;, total_pay) // Total Salary: 43502.05\u003c/pre\u003e\n\u003cp\u003e我们函数这个 \u003ccode\u003egReduce\u003c/code\u003e 函数有点啰嗦，还需要传一个初始值，在用户自己的函数中，还要关心 \u003ccode\u003eresult\u003c/code\u003e 我们还是来定义一个更好的版本。\u003c/p\u003e\n\u003cp\u003e一般来说，我们用 reduce 函数大多时候基本上是统计求和或是数个数，所以，是不是我们可以定义的更为直接一些？比如下面的这个 \u003ccode\u003eCountIf()\u003c/code\u003e，就比上面的 Reduce 干净了很多。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc gCountIf[T any](arr []T, f func(T) bool) int {\n  cnt := 0\n  for _, elem := range arr {\n    if f(elem) {\n      cnt += 1\n    }\n  }\n  return cnt;\n}\u003c/pre\u003e\n\u003cp\u003e我们做求和，我们也可以写一个Sum的泛型。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e处理 \u003ccode\u003eT\u003c/code\u003e 类型的数据，返回 \u003ccode\u003eU\u003c/code\u003e类型的结果\u003c/li\u003e\n\u003cli\u003e然后，用户只需要给我一个需要统计的 \u003ccode\u003eT\u003c/code\u003e 的 \u003ccode\u003eU\u003c/code\u003e 类型的数据就可以了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e代码如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Sumable interface {\n  type int, int8, int16, int32, int64,\n        uint, uint8, uint16, uint32, uint64,\n        float32, float64\n}\n\nfunc gSum[T any, U Sumable](arr []T, f func(T) U) U {\n  var sum U\n  for _, elem := range arr {\n    sum += f(elem)\n  }\n  return sum\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码我们动用了一个叫 Sumable 的接口，其限定了 U 类型，只能是 Sumable里的那些类型，也就是整型或浮点型，这个支持可以让我们的泛型代码更健壮一些。\u003c/p\u003e\n\u003cp\u003e于是，我们就可以完成下面的事了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e1）统计年龄大于40岁的员工数\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eold := gCountIf(employees, func (e Employee) bool  {\n    return e.Age \u0026gt; 40\n})\nfmt.Printf(\u0026#34;old people(\u0026gt;40): %d\\n\u0026#34;, old) \n// ld people(\u0026gt;40): 2\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e2）统计薪水超过 6000元的员工数\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003ehigh_pay := gCountIf(employees, func(e Employee) bool {\n  return e.Salary \u0026gt;= 6000\n})\nfmt.Printf(\u0026#34;High Salary people(\u0026gt;6k): %d\\n\u0026#34;, high_pay) \n//High Salary people(\u0026gt;6k): 4\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e3）统计年龄小于30岁的员工的薪水\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eyounger_pay := gSum(employees, func(e Employee) float32 {\n  if e.Age \u0026lt; 30 {\n      return e.Salary\n  } \n  return 0\n})\nfmt.Printf(\u0026#34;Total Salary of Young People: %0.2f\\n\u0026#34;, younger_pay)\n//Total Salary of Young People: 19000.00\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e4）统计全员的休假天数\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etotal_vacation := gSum(employees, func(e Employee) int {\n  return e.Vacation\n})\nfmt.Printf(\u0026#34;Total Vacation: %d day(s)\\n\u0026#34;, total_vacation)\n//Total Vacation: 32 day(s)\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e5）把没有休假的员工过滤出来\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eno_vacation := gFilterIn(employees, func(e Employee) bool {\n  return e.Vacation == 0\n})\nprint(no_vacation)\n//{Hao 44 0 8000.5} {Jack 26 0 4000} {Marry 29 0 6000}\u003c/pre\u003e\n\u003cp\u003e怎么样，你大概了解了泛型编程的意义了吧。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21615\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"8171356f9c\"\u003e\u003cimg id=\"rating_21615_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21615, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-86b4b3650bc1bd4ee36a9c88-=\"\"/\u003e\u003cimg id=\"rating_21615_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21615, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-86b4b3650bc1bd4ee36a9c88-=\"\"/\u003e\u003cimg id=\"rating_21615_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21615, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-86b4b3650bc1bd4ee36a9c88-=\"\"/\u003e\u003cimg id=\"rating_21615_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21615, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-86b4b3650bc1bd4ee36a9c88-=\"\"/\u003e\u003cimg id=\"rating_21615_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21615, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-86b4b3650bc1bd4ee36a9c88-=\"\"/\u003e (\u003cstrong\u003e43\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.19\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21615_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式 ： 泛型编程\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式 ： 泛型编程\"/\u003e\u003cmeta itemprop=\"description\" content=\"Go语言的1.17版本发布了，其中开始正式支持泛型了。虽然还有一些限制（比如，不能把泛型函数export），但是，可以体验了。我的这个《Go编程模式》的系列终于有了真正的泛型编程了，再也不需要使用反射或是go generation这些难用的技术了。周末的时候，我把Go 1.17下载下来，然后，体验了一下泛型编程，还是很不错的。下面，就让我们来看一下Go的泛型编程。（注：不过，如果你对泛型编程的重要...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2021-09-04T13:44:02+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2021-09-04T13:44:02+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21615.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21615.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.19\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"43\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21615-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2021-09-04T13:44:02+08:00",
  "Author": "陈皓"
}