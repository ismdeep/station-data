{
  "Source": "coolshell.cn",
  "Title": "Alan Cox：单向链表中prev指针的妙用",
  "Link": "https://coolshell.cn/articles/9859.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"5842dce7b052e7ac9223d8ff-text/javascript\"\u003e\u003c/script\u003e\u003c/p\u003e\u003cfigure id=\"attachment_9906\" aria-describedby=\"caption-attachment-9906\" style=\"width: 200px\" class=\"wp-caption alignright\"\u003e\u003cimg decoding=\"async\" class=\"size-medium wp-image-9906\" title=\"Alan Cox\" alt=\"Alan Cox\" src=\"https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-200x300.jpg\" width=\"200\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-200x300.jpg 200w, https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-180x270.jpg 180w, https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox.jpg 667w\" sizes=\"(max-width: 200px) 100vw, 200px\"/\u003e\u003cfigcaption id=\"caption-attachment-9906\" class=\"wp-caption-text\"\u003eAlan Cox\u003c/figcaption\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan style=\"color: #cc0000;\"\u003e\u003cstrong\u003e （感谢网友 \u003c/strong\u003e\u003c/span\u003e\u003ca href=\"http://weibo.com/fullofbull\" target=\"_blank\"\u003e\u003cstrong\u003e@我的上铺叫路遥\u003c/strong\u003e\u003c/a\u003e\u003cspan style=\"color: #cc0000;\"\u003e\u003cstrong\u003e 投稿）\u003c/strong\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e之前发过一篇\u003ca href=\"https://coolshell.cn/articles/8990.html\" target=\"_blank\"\u003e二级指针操作单向链表\u003c/a\u003e的例子，显示了C语言指针的灵活性，这次再探讨一个指针操作链表的例子，而且是一种完全不同的用法。\u003c/p\u003e\n\u003cp\u003e这个例子是linux-1.2.13网络协议栈里的，关于链表遍历\u0026amp;数据拷贝的一处实现。源文件是/net/inet/dev.c，你可以从\u003ca href=\"https://www.kernel.org/pub/linux/kernel/v1.2/\" target=\"_blank\"\u003ekernel.org\u003c/a\u003e官网上下载。\u003c/p\u003e\n\u003cp\u003e从最早的0.96c版本开始，linux网络部分一直采取TCP/IP协议族实现，这是最为广泛应用的网络协议，整个架构就是经典的OSI七层模型的描述，其中dev.c是属于链路层实现。从功能上看，其位于网络设备驱动程序和网络层协议实现模块之间，作为二者之间的数据包传输通道，一种接口模块而存在——对驱动层的接口函数netif_rx, 以及对网络层的接口函数net_bh。前者提供给驱动模块的中断例程调用，用于链路数据帧的封装；后者作为驱动中断例程\u003cstrong\u003e底半部(buttom half)\u003c/strong\u003e，用于对数据帧的解析处理并向上层传送。\u003c/p\u003e\n\u003cp\u003e为了便于理解，这里补充一下网络通信原理和linux驱动中断机制的背景知识。从最底层的物理层说起，当主机和路由器相互之间进行通信的时候，在物理介质上（同轴、光纤等）以电平信号进行传输。主机或路由器的\u003cstrong\u003e硬件接口（网卡）\u003c/strong\u003e负责收发这些信号，当信号发送到接口，再由内置的\u003cstrong\u003e调制解调器(modem)\u003c/strong\u003e将数字信号转换成二进制码，这样才能驻留在主机的硬件缓存中。这时接口（网卡）设备驱动程序将通过\u003cstrong\u003e硬中断\u003c/strong\u003e来获取硬件缓存中的数据，驱动程序是操作系统中负责直接同硬件设备打交道的模块，硬中断的触发是初始化时通过设置控制寄存器实现的，用于通知驱动程序硬件缓存中有新的数据到来。linux卡设备驱动就是在\u003cstrong\u003e中断处理例程(ISR)\u003c/strong\u003e中将硬件缓存数据拷贝到内核缓存中，打包成数据链路帧进行解析处理，再向上分发到各种协议层。由于ISR上下文是原子性的、中断屏蔽的，整个步骤又较为繁琐，因此全部放在ISR中处理会影响到其它中断响应实时性，于是linux有实现一种bottom half的\u003cstrong\u003e软中断\u003c/strong\u003e处理机制，将整个ISR一分为二，前半部上下文屏蔽所有中断，专门处理紧急的、实时性强的事务，如拷贝硬件缓存并打包封装，后半部上下文没有屏蔽中断（但代码不可重入），用于处理比较耗时且非紧急事务，包括数据帧的解析处理和分发。下面要讲的net_bh就属于后半部。\u003c/p\u003e\n\u003cp\u003e我们主要关心的是将链路帧分发到协议层那一段逻辑，下面摘自net_bh函数中的一段代码：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-9859\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e526 void net_bh(void *tmp)\n527 {\n       ...\n577\n578    /*\n579    * We got a packet ID.  Now loop over the \u0026#34;known protocols\u0026#34;\n580    * table (which is actually a linked list, but this will\n581    * change soon if I get my way- FvK), and forward the packet\n582    * to anyone who wants it.\n583    *\n584    * [FvK didn\u0026#39;t get his way but he is right this ought to be\n585    * hashed so we typically get a single hit. The speed cost\n586    * here is minimal but no doubt adds up at the 4,000+ pkts/second\n587    * rate we can hit flat out]\n588    */\n589   pt_prev = NULL;\n590   for (ptype = ptype_base; ptype != NULL; ptype = ptype-\u0026gt;next)\n591   {\n592    if ((ptype-\u0026gt;type == type || ptype-\u0026gt;type == htons(ETH_P_ALL)) \u0026amp;\u0026amp; (!ptype-\u0026gt;dev || ptype-\u0026gt;dev==skb-\u0026gt;dev))\n593    {\n594      /*\n595      * We already have a match queued. Deliver\n596      * to it and then remember the new match\n597      */\n598      if(pt_prev)\n599      {\n600        struct sk_buff *skb2;\n601        skb2=skb_clone(skb, GFP_ATOMIC);\n602        /*\n603        * Kick the protocol handler. This should be fast\n604        * and efficient code.\n605        */\n606        if(skb2)\n607          pt_prev-\u0026gt;func(skb2, skb-\u0026gt;dev, pt_prev);\n608      }\n609      /* Remember the current last to do */\n610      pt_prev=ptype;\n611    }\n612   } /* End of protocol list loop */\n613   /*\n614   * Is there a last item to send to ?\n615   */\n616   if(pt_prev)\n617     pt_prev-\u0026gt;func(skb, skb-\u0026gt;dev, pt_prev);\n618   /*\n619    *  Has an unknown packet has been received ?\n620    */\n621   else\n622     kfree_skb(skb, FREE_WRITE);\n623\n      ...\n640 }\u003c/pre\u003e\n\u003cp\u003e在此稍稍解说一下数据结构，skb就是内核缓存中sock数据封装，协议栈里从链路层到传输层都会用到，只不过封装格式不同，主要是对\u003cstrong\u003e协议首部(header)\u003c/strong\u003e的由下而上层层剥离（反之由上而下是层层创建），在此你只需理解为一个链路数据帧即可。这段代码的逻辑是解析skb中的协议字段，从协议类型链表（由ptype_base维护）中查询对应的协议节点进行函数指针func回调，以便将数据帧分发到相应的协议层（如ARP、IP、8022、8023等）。\u003c/p\u003e\n\u003cp\u003e第一眼看上去是不是有点奇怪？这段代码竟然用一个pt_prev指针去维护ptype链表中前一个节点，从而产生了额外的条件分支判断，咋一看是否多了很多“余”了？回顾一下那篇\u003ca href=\"https://coolshell.cn/articles/8990.html\" target=\"_blank\"\u003e二级指针操作单向链表\u003c/a\u003e的博文，简直完全是反其道而行之的。如果把pt_prev去掉，代码可以精简为：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e  for (ptype = ptype_base; ptype != NULL; ptype = ptype-\u0026gt;next)\n  {\n    if ((ptype-\u0026gt;type == type || ptype-\u0026gt;type == htons(ETH_P_ALL)) \u0026amp;\u0026amp; (!ptype-\u0026gt;dev || ptype-\u0026gt;dev==skb-\u0026gt;dev))\n    {\n        /*\n        * We already have a match queued. Deliver\n        * to it and then remember the new match\n        */\n        struct sk_buff *skb2;\n        skb2=skb_clone(skb, GFP_ATOMIC);\n        /*\n        * Kick the protocol handler. This should be fast\n        * and efficient code.\n        */\n        if(skb2)\n            pt_prev-\u0026gt;func(skb2, skb-\u0026gt;dev, pt_prev);\n    }\n} /* End of protocol list loop */\n\nkfree_skb(skb, FREE_WRITE);\u003c/pre\u003e\n\u003cp\u003e咋看一下“干净”了很多，不是吗？但我们要记住一点，凡是网上发布的linux内核源代码，都是都是经过众多黑客高手们重重检视并验证过的，人家这么写肯定有十分充足的理由，所以不要太过于相信自己的直觉了，让我们再好好review一下代码吧！看看这段循环里做了什么事情？特别是第592~611行。\u003c/p\u003e\n\u003cp\u003e由于从网络上拷贝过来skb是唯一的，而分发的协议对象可能是多个，所以在回调之前要做一次clone动作（注意这里是深度拷贝，相当于一次kmalloc）。分发之后还需要调用kfree_skb释放掉原始skb数据块，它的历史使命到此完成了，没有保留的必要（第622行）。\u003cstrong\u003e注意，这两个动作都是存在内核开销的。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e然而这里为啥要pt_prev维护一个后向节点呢？这是有深意的，它的作用就是将当前匹配协议项的回调操作延时了。举个例子，如果链表遍历中找到某个匹配项，当前循环仅仅用pt_prev去记录这个匹配项，除此之外不做任何事情，待到下一次匹配项找到时，才去做上一个匹配项pt_prev的回调操作，直到循环结束，才会去做最后的匹配项的回调（当然pt_prev==NULL表示没有一次匹配，直接释放掉），所以这是一种\u003cstrong\u003e拖延战术\u003c/strong\u003e。有什么好处呢？就是比原先节省了很多不必要的操作。那么哪些操作是不必要的呢？这里我们逆向思考一下，我们看到clone是在协议字段匹配并且pt_prev!=NULL的前提条件下执行的，而kfree是在pt_prev==NULL的前提条件下执行的。在此可以假设一下，如果ptype链表中存在N项协议与之匹配，那么这段代码只会执行N-1次clone，而没有pt_prev时将会执行N次clone和1次kfree，再如果ptype链表中有且仅有一项协议与之匹配，那么整个循环既不会执行到第601行的clone，也不会执行到第622行的kfree。\u003c/p\u003e\n\u003cp\u003e也就是说，\u003cstrong\u003e当整个链表至少有一项匹配的一般情况下，pt_prev存在比没有时减少了一次clone和一次kfree的开销；只有全部不匹配的最差情况下，两者都只做一次kfree动作，持平。这就是延迟策略产生的效益\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e熟悉TCP/IP协议族的开发人员应该知道\u003cstrong\u003eMTU（最大传输单元）\u003c/strong\u003e这个概念，遵循不同协议的MTU值是不同的。比如以太网帧MTU是1500个字节，802.3帧MTU是1492字节，PPP链路帧MTU是269字节，而超通道MTU理论上是65535字节。要知道在一个高速吞吐量通信网络环境下，在大块数据分片传输线路里，在内核级别代码中，减少一处系统开销意味着什么？\u003c/p\u003e\n\u003cp\u003e其实我们完全可以抛开一切网络协议相关知识，这不过是一段极其普通的单向链表操作而已，逻辑并不复杂。但是看看人家顶级黑客是怎么思考和coding的，对比一下自己写过的代码，多少次数据处理是用一个简单的for循环匆匆敷衍了事而没有进一步思考其中的粗陋和不合理之处？面对真正的编程高手这种“心计”与“城府”，你是不是有种莫名不安感？你会怀疑你真的了解怎么去使用和操作C语言中基本的链表数据结构么？如果答案是肯定的，那就开始颤抖吧（哈，别误会，其实上面这段话不过是笔者的自我告解罢了）~~~\u003c/p\u003e\n\u003cp\u003e最后，让我们感谢尊敬的\u003ca href=\"https://en.wikipedia.org/wiki/Alan_Cox\" target=\"_blank\"\u003eAlan Cox\u003c/a\u003e大大对Linux社区卓越精细、无与伦比的贡献！（Alan是图中中部戴红帽子的那位）\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter\" alt=\"Linux Kernel Team\" src=\"http://old.lwn.net/images/ks/group2.jpg\" width=\"704\" height=\"323\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e附注：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e最新的Linux-2.6.x版本中协议栈实现部分变动很大，但/net/core/dev.c的netif_receive_skb函数里仍然保留了pt_prev这种用法，目的是一样的，都是为了减少一次系统开销的优化操作。\u003c/p\u003e\n\u003cp\u003e关于Alan，他在斯旺西大学工作时，在学校服务器上安装了一个早期的linux版本，供学校使用。他修正了许多的问题，重写了网络系统中的许多部份。随后成为linux内核开发小组中的重要成员。\u003ca href=\"https://en.wikipedia.org/wiki/Alan_Cox\" target=\"_blank\"\u003eAlan Cox\u003c/a\u003e负责维持2.2版，在2.4版上拥有自己的分支（在版本号上会冠上ac，如 2.4.13-ac1）。他的分支版本非常稳定，修正许多错误，许多厂商都使用他的版本。在他去进修工商管理硕士之前，涉入许多linux内核开发的事务，在社群中有很高的地位，有时会被视为是Linus之下的第二号领导者。\u003c/p\u003e\n\u003cp\u003e不过，今年1月28日的时候，Alan因为家庭原因宣布退出Linux项目了，下面是他Google+的声明：\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e“I’m leaving the Linux world and Intel for a bit for family reasons, I’m aware that ‘family reasons’ is usually management speak for ‘I think the boss is an asshole’ but I’d like to assure everyone that while I frequently think Linus is an asshole (and therefore very good as kernel dictator) I am departing quite genuinely for family reasons and not because I’ve fallen out with Linus or Intel or anyone else. Far from it I’ve had great fun working there.”\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/8990.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/02/linus_pointer_to_pointer-150x150.jpg\" alt=\"Linus：利用二级指针删除单向链表\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/8990.html\" class=\"wp_rp_title\"\u003eLinus：利用二级指针删除单向链表\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1-150x150.png\" alt=\"记一次Kubernetes/Docker网络排障\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_title\"\u003e记一次Kubernetes/Docker网络排障\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9917.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/10.jpg\" alt=\"Alan Cox：大教堂、市集与市议会\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9917.html\" class=\"wp_rp_title\"\u003eAlan Cox：大教堂、市集与市议会\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/8088.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/7.jpg\" alt=\"对技术的态度\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/8088.html\" class=\"wp_rp_title\"\u003e对技术的态度\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7490.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/06/f1-150x150.jpg\" alt=\"性能调优攻略\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7490.html\" class=\"wp_rp_title\"\u003e性能调优攻略\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-9859\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"7270cf2673\"\u003e\u003cimg id=\"rating_9859_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9859, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5842dce7b052e7ac9223d8ff-=\"\"/\u003e\u003cimg id=\"rating_9859_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9859, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5842dce7b052e7ac9223d8ff-=\"\"/\u003e\u003cimg id=\"rating_9859_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9859, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5842dce7b052e7ac9223d8ff-=\"\"/\u003e\u003cimg id=\"rating_9859_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9859, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5842dce7b052e7ac9223d8ff-=\"\"/\u003e\u003cimg id=\"rating_9859_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9859, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5842dce7b052e7ac9223d8ff-=\"\"/\u003e (\u003cstrong\u003e36\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.11\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_9859_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Alan Cox：单向链表中prev指针的妙用\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Alan Cox：单向链表中prev指针的妙用\"/\u003e\u003cmeta itemprop=\"description\" content=\"\n\n （感谢网友 @我的上铺叫路遥 投稿）\n\n之前发过一篇二级指针操作单向链表的例子，显示了C语言指针的灵活性，这次再探讨一个指针操作链表的例子，而且是一种完全不同的用法。\n\n这个例子是linux-1.2.13网络协议栈里的，关于链表遍历\u0026amp;数据拷贝的一处实现。源文件是/net/inet/dev.c，你可以从kernel.org官网上下载。\n\n从最早的0.96c版本开始，linux网...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2013-06-30T12:27:04+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2013-06-30T15:38:37+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/9859.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"Leo\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/9859.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.11\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"36\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-9859-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2013-06-30T12:27:04+08:00",
  "Author": "Leo"
}