{
  "Source": "coolshell.cn",
  "Title": "Go 语言简介（下）— 特性",
  "Link": "https://coolshell.cn/articles/8489.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"6bea283b35281e374fce33a6-text/javascript\"\u003e\u003c/script\u003e希望你看到这篇文章的时候还是在公交车和地铁上正在上下班的时间，我希望我的这篇文章可以让你利用这段时间了解一门语言。当然，希望你不会因为看我的文章而错过站。呵呵。\u003c/p\u003e\n\u003cp\u003e如果你还不了解Go语言的语法，还请你移步先看一下上篇——《\u003cstrong\u003e\u003ca title=\"Go语言简介（上）：语法\" href=\"https://coolshell.cn/articles/8460.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eGo语言简介（上）：语法\u003c/a\u003e\u003c/strong\u003e》\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" src=\"https://coolshell.cn/wp-content/uploads/2012/11/google-go-language.jpg\" alt=\"\" title=\"google-go-language\" width=\"450\" height=\"272\" class=\"aligncenter size-full wp-image-8531\" srcset=\"https://coolshell.cn/wp-content/uploads/2012/11/google-go-language.jpg 450w, https://coolshell.cn/wp-content/uploads/2012/11/google-go-language-300x181.jpg 300w, https://coolshell.cn/wp-content/uploads/2012/11/google-go-language-447x270.jpg 447w\" sizes=\"(max-width: 450px) 100vw, 450px\"/\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#goroutine\" title=\"goroutine\"\u003egoroutine\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#goroutine%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7\" title=\"goroutine的并发安全性\"\u003egoroutine的并发安全性\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\" title=\"原子操作\"\u003e原子操作\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Channel_%E4%BF%A1%E9%81%93\" title=\"Channel 信道\"\u003eChannel 信道\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%AE%9A%E6%97%B6%E5%99%A8\" title=\"定时器\"\u003e定时器\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Socket%E7%BC%96%E7%A8%8B\" title=\"Socket编程\"\u003eSocket编程\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\" title=\"系统调用\"\u003e系统调用\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C\" title=\"执行命令行\"\u003e执行命令行\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\" title=\"命令行参数\"\u003e命令行参数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP_Server\" title=\"一个简单的HTTP Server\"\u003e一个简单的HTTP Server\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"goroutine\"\u003e\u003c/span\u003egoroutine\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGoRoutine主要是使用go关键字来调用函数，你还可以使用匿名函数，如下所示：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-8489\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"9,11\"\u003epackage main\nimport \u0026#34;fmt\u0026#34;\n\nfunc f(msg string) {\n    fmt.Println(msg)\n}\n\nfunc main(){\n    go f(\u0026#34;goroutine\u0026#34;)\n\n    go func(msg string) {\n        fmt.Println(msg)\n    }(\u0026#34;going\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e我们再来看一个示例，下面的代码中包括很多内容，包括时间处理，随机数处理，还有goroutine的代码。如果你熟悉C语言，你应该会很容易理解下面的代码。\u003c/p\u003e\n\u003cp\u003e你可以简单的把go关键字调用的函数想像成pthread_create。下面的代码使用for循环创建了3个线程，每个线程使用一个随机的Sleep时间，然后在routine()函数中会输出一些线程执行的时间信息。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;math/rand\u0026#34;\n\nfunc routine(name string, delay time.Duration) {\n\n    t0 := time.Now()\n    fmt.Println(name, \u0026#34; start at \u0026#34;, t0)\n\n    time.Sleep(delay)\n\n    t1 := time.Now()\n    fmt.Println(name, \u0026#34; end at \u0026#34;, t1)\n\n    fmt.Println(name, \u0026#34; lasted \u0026#34;, t1.Sub(t0))\n}\n\nfunc main() {\n\n    //生成随机种子\n    rand.Seed(time.Now().Unix())\n\n    var name string\n    for i:=0; i\u0026lt;3; i++{\n        name = fmt.Sprintf(\u0026#34;go_%02d\u0026#34;, i) //生成ID\n        //生成随机等待时间，从0-4秒\n        go routine(name, time.Duration(rand.Intn(5)) * time.Second)\n    }\n\n    //让主进程停住，不然主进程退了，goroutine也就退了\n    var input string\n    fmt.Scanln(\u0026amp;input)\n    fmt.Println(\u0026#34;done\u0026#34;)\n}\n\u003c/pre\u003e\n\u003cp\u003e运行的结果可能是：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ego_00  start at  2012-11-04 19:46:35.8974894 +0800 +0800\ngo_01  start at  2012-11-04 19:46:35.8974894 +0800 +0800\ngo_02  start at  2012-11-04 19:46:35.8974894 +0800 +0800\ngo_01  end at  2012-11-04 19:46:36.8975894 +0800 +0800\ngo_01  lasted  1.0001s\ngo_02  end at  2012-11-04 19:46:38.8987895 +0800 +0800\ngo_02  lasted  3.0013001s\ngo_00  end at  2012-11-04 19:46:39.8978894 +0800 +0800\ngo_00  lasted  4.0004s\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"goroutine%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E6%80%A7\"\u003e\u003c/span\u003egoroutine的并发安全性\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e关于goroutine，我试了一下，无论是Windows还是Linux，基本上来说是用操作系统的线程来实现的。不过，goroutine有个特性，也就是说，\u003cstrong\u003e如果一个goroutine没有被阻塞，那么别的goroutine就不会得到执行\u003c/strong\u003e。这并不是真正的并发，如果你要真正的并发，你需要在你的main函数的第一行加上下面的这段代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eimport \u0026#34;runtime\u0026#34;\n...\nruntime.GOMAXPROCS(4)\u003c/pre\u003e\n\u003cp\u003e还是让我们来看一个有并发安全性问题的示例（注意：我使用了C的方式来写这段Go的程序）\u003c/p\u003e\n\u003cp\u003e这是一个经常出现在教科书里卖票的例子，我启了5个goroutine来卖票，卖票的函数sell_tickets很简单，就是随机的sleep一下，然后对全局变量total_tickets作减一操作。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;math/rand\u0026#34;\nimport \u0026#34;runtime\u0026#34;\n\nvar total_tickets int32 = 10;\n\nfunc sell_tickets(i int){\n    for{\n        if total_tickets \u0026gt; 0 { //如果有票就卖\n            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)\n            total_tickets-- //卖一张票\n            fmt.Println(\u0026#34;id:\u0026#34;, i, \u0026#34;  ticket:\u0026#34;, total_tickets)\n        }else{\n            break\n        }\n    }\n}\n\nfunc main() {\n    runtime.GOMAXPROCS(4) //我的电脑是4核处理器，所以我设置了4\n    rand.Seed(time.Now().Unix()) //生成随机种子\n\n    for i := 0; i \u0026lt; 5; i++ { //并发5个goroutine来卖票\n         go sell_tickets(i)\n    }\n    //等待线程执行完\n    var input string\n    fmt.Scanln(\u0026amp;input)\n    fmt.Println(total_tickets, \u0026#34;done\u0026#34;) //退出时打印还有多少票\n}\u003c/pre\u003e\n\u003cp\u003e这个程序毋庸置疑有并发安全性问题，所以执行起来你会看到下面的结果：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$go run sell_tickets.go\nid: 0   ticket: 9  \nid: 0   ticket: 8  \nid: 4   ticket: 7  \nid: 1   ticket: 6  \nid: 3   ticket: 5  \nid: 0   ticket: 4  \nid: 3   ticket: 3  \nid: 2   ticket: 2  \nid: 0   ticket: 1  \nid: 3   ticket: 0  \nid: 1   ticket: -1  \nid: 4   ticket: -2  \nid: 2   ticket: -3  \nid: 0   ticket: -4  \n-4 done\u003c/pre\u003e\n\u003cp\u003e可见，我们需要使用上锁，我们可以使用互斥量来解决这个问题。下面的代码，我只列出了修改过的内容：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"5,9,13,19\"\u003e package main\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;math/rand\u0026#34;\nimport \u0026#34;sync\u0026#34;\nimport \u0026#34;runtime\u0026#34;\n\nvar total_tickets int32 = 10;\nvar mutex = \u0026amp;sync.Mutex{} //可简写成：var mutex sync.Mutex\n\nfunc sell_tickets(i int){\n    for total_tickets\u0026gt;0 {\n        mutex.Lock()\n        if total_tickets \u0026gt; 0 {\n            time.Sleep( time.Duration(rand.Intn(5)) * time.Millisecond)\n            total_tickets--\n            fmt.Println(i, total_tickets)\n        }\n        mutex.Unlock()\n    }\n}\n.......\n......\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C\"\u003e\u003c/span\u003e原子操作\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e说到并发就需要说说原子操作，相信大家还记得我写的那篇《\u003ca title=\"无锁队列的实现\" href=\"https://coolshell.cn/articles/8239.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e无锁队列的实现\u003c/a\u003e》一文，里面说到了一些CAS – CompareAndSwap的操作。Go语言也支持。你可以看一下相当的文档\u003c/p\u003e\n\u003cp\u003e我在这里就举一个很简单的示例：下面的程序有10个goroutine，每个会对cnt变量累加20次，所以，最后的cnt应该是200。如果没有atomic的原子操作，那么cnt将有可能得到一个小于200的数。\u003c/p\u003e\n\u003cp\u003e下面使用了atomic操作，所以是安全的。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"5,13,18\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;sync/atomic\u0026#34;\n\nfunc main() {\n    var cnt uint32 = 0\n    for i := 0; i \u0026lt; 10; i++ {\n        go func() {\n            for i:=0; i\u0026lt;20; i++ {\n                time.Sleep(time.Millisecond)\n                atomic.AddUint32(\u0026amp;cnt, 1)\n            }\n        }()\n    }\n    time.Sleep(time.Second)//等一秒钟等goroutine完成\n    cntFinal := atomic.LoadUint32(\u0026amp;cnt)//取数据\n    fmt.Println(\u0026#34;cnt:\u0026#34;, cntFinal)\n}\u003c/pre\u003e\n\u003cp\u003e这样的函数还有很多，参看\u003ca href=\"https://golang.org/pkg/sync/atomic/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ego的atomic包文档\u003c/a\u003e（被墙）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Channel_%E4%BF%A1%E9%81%93\"\u003e\u003c/span\u003eChannel 信道\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eChannal是什么？Channal就是用来通信的，就像Unix下的管道一样，在Go中是这样使用Channel的。\u003c/p\u003e\n\u003cp\u003e下面的程序演示了一个goroutine和主程序通信的例程。这个程序足够简单了。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"7,10\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    //创建一个string类型的channel\n    channel := make(chan string)\n\n    //创建一个goroutine向channel里发一个字符串\n    go func() { channel \u0026lt;- \u0026#34;hello\u0026#34; }()\n\n    msg := \u0026lt;- channel\n    fmt.Println(msg)\n}[\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e指定channel的buffer\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e指定buffer的大小很简单，看下面的程序：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"5\"\u003epackage main\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    channel := make(chan string, 2)\n\n    go func() {\n        channel \u0026lt;- \u0026#34;hello\u0026#34;\n        channel \u0026lt;- \u0026#34;World\u0026#34;\n    }()\n\n    msg1 := \u0026lt;-channel\n    msg2 := \u0026lt;-channel\n    fmt.Println(msg1, msg2)\n}\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eChannel的阻塞\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e注意，channel默认上是阻塞的，也就是说，如果Channel满了，就阻塞写，如果Channel空了，就阻塞读。于是，我们就可以使用这种特性来同步我们的发送和接收端。\u003c/p\u003e\n\u003cp\u003e下面这个例程说明了这一点，代码有点乱，不过我觉得不难理解。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\n\nfunc main() {\n\n    channel := make(chan string) //注意: buffer为1\n\n    go func() {\n        channel \u0026lt;- \u0026#34;hello\u0026#34;\n        fmt.Println(\u0026#34;write \\\u0026#34;hello\\\u0026#34; done!\u0026#34;)\n\n        channel \u0026lt;- \u0026#34;World\u0026#34; //Reader在Sleep，这里在阻塞\n        fmt.Println(\u0026#34;write \\\u0026#34;World\\\u0026#34; done!\u0026#34;)\n\n        fmt.Println(\u0026#34;Write go sleep...\u0026#34;)\n        time.Sleep(3*time.Second)\n        channel \u0026lt;- \u0026#34;channel\u0026#34;\n        fmt.Println(\u0026#34;write \\\u0026#34;channel\\\u0026#34; done!\u0026#34;)\n    }()\n\n    time.Sleep(2*time.Second)\n    fmt.Println(\u0026#34;Reader Wake up...\u0026#34;)\n\n    msg := \u0026lt;-channel\n    fmt.Println(\u0026#34;Reader: \u0026#34;, msg)\n\n    msg = \u0026lt;-channel\n    fmt.Println(\u0026#34;Reader: \u0026#34;, msg)\n\n    msg = \u0026lt;-channel //Writer在Sleep，这里在阻塞\n    fmt.Println(\u0026#34;Reader: \u0026#34;, msg)\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码输出的结果如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003eReader Wake up...\nReader:  hello\nwrite \u0026#34;hello\u0026#34; done!\nwrite \u0026#34;World\u0026#34; done!\nWrite go sleep...\nReader:  World\nwrite \u0026#34;channel\u0026#34; done!\nReader:  channel\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eChannel阻塞的这个特性还有一个好处是，可以让我们的goroutine在运行的一开始就阻塞在从某个channel领任务，这样就可以作成一个类似于线程池一样的东西。关于这个程序我就不写了。我相信你可以自己实现的。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e多个Channel的select\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    //创建两个channel - c1 c2\n    c1 := make(chan string)\n    c2 := make(chan string)\n\n    //创建两个goruntine来分别向这两个channel发送数据\n    go func() {\n        time.Sleep(time.Second * 1)\n        c1 \u0026lt;- \u0026#34;Hello\u0026#34;\n    }()\n    go func() {\n        time.Sleep(time.Second * 1)\n        c2 \u0026lt;- \u0026#34;World\u0026#34;\n    }()\n\n    //使用select来侦听两个channel\n    for i := 0; i \u0026lt; 2; i++ {\n        select {\n        case msg1 := \u0026lt;-c1:\n            fmt.Println(\u0026#34;received\u0026#34;, msg1)\n        case msg2 := \u0026lt;-c2:\n            fmt.Println(\u0026#34;received\u0026#34;, msg2)\n        }\n    }\n}\u003c/pre\u003e\n\u003cp\u003e注意：上面的select是阻塞的，所以，才搞出ugly的for i \u0026lt;2这种东西\u003cstrong\u003e。\u003cbr/\u003e\n\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eChannel select阻塞的Timeout\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e解决上述那个for循环的问题，一般有两种方法：一种是阻塞但有timeout，一种是无阻塞。我们来看看如果给select设置上timeout的。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"8\"\u003e    for {\n        timeout_cnt := 0\n        select {\n        case msg1 := \u0026lt;-c1:\n            fmt.Println(\u0026#34;msg1 received\u0026#34;, msg1)\n        case msg2 := \u0026lt;-c2:\n            fmt.Println(\u0026#34;msg2 received\u0026#34;, msg2)\n        case  \u0026lt;-time.After(time.Second * 30)：\n            fmt.Println(\u0026#34;Time Out\u0026#34;)\n            timout_cnt++\n        }\n        if time_cnt \u0026gt; 3 {\n            break\n        }\n    }\n\u003c/pre\u003e\n\u003cp\u003e上面代码中高亮的代码主要是用来让select返回的，注意 case中的time.After事件。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eChannel的无阻塞\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e好，我们再来看看无阻塞的channel，其实也很简单，就是在select中加入default，如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"8\"\u003e    for {\n        select {\n        case msg1 := \u0026lt;-c1:\n            fmt.Println(\u0026#34;received\u0026#34;, msg1)\n        case msg2 := \u0026lt;-c2:\n            fmt.Println(\u0026#34;received\u0026#34;, msg2)\n        default: //default会导致无阻塞\n            fmt.Println(\u0026#34;nothing received!\u0026#34;)\n            time.Sleep(time.Second)\n        }\n    }\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eChannel的关闭\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关闭Channel可以通知对方内容发送完了，不用再等了。参看下面的例程：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"19,27\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;math/rand\u0026#34;\n\nfunc main() {\n\n    channel := make(chan string)\n    rand.Seed(time.Now().Unix())\n\n    //向channel发送随机个数的message\n    go func () {\n        cnt := rand.Intn(10)\n        fmt.Println(\u0026#34;message cnt :\u0026#34;, cnt)\n        for i:=0; i\u0026lt;cnt; i++{\n            channel \u0026lt;- fmt.Sprintf(\u0026#34;message-%2d\u0026#34;, i)\n        }\n        close(channel) //关闭Channel\n    }()\n\n    var more bool = true\n    var msg string\n    for more {\n        select{\n        //channel会返回两个值，一个是内容，一个是还有没有内容\n        case msg, more = \u0026lt;- channel:\n            if more {\n                fmt.Println(msg)\n            }else{\n                fmt.Println(\u0026#34;channel closed!\u0026#34;)\n            }\n        }\n    }\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%AE%9A%E6%97%B6%E5%99%A8\"\u003e\u003c/span\u003e定时器\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo语言中可以使用time.NewTimer或time.NewTicker来设置一个定时器，这个定时器会绑定在你的当前channel中，通过channel的阻塞通知机器来通知你的程序。\u003c/p\u003e\n\u003cp\u003e下面是一个timer的示例。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"9\"\u003epackage main\n\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    timer := time.NewTimer(2*time.Second)\n\n    \u0026lt;- timer.C\n    fmt.Println(\u0026#34;timer expired!\u0026#34;)\n}\u003c/pre\u003e\n\u003cp\u003e上面的例程看起来像一个Sleep，是的，不过Timer是可以Stop的。你需要注意Timer只通知一次。如果你要像C中的Timer能持续通知的话，你需要使用Ticker。下面是Ticker的例程：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"9\"\u003epackage main\n\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    ticker := time.NewTicker(time.Second)\n\n    for t := range ticker.C {\n        fmt.Println(\u0026#34;Tick at\u0026#34;, t)\n    }\n}\u003c/pre\u003e\n\u003cp\u003e上面的这个ticker会让你程序进入死循环，我们应该放其放在一个goroutine中。下面这个程序结合了timer和ticker\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;time\u0026#34;\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\n    ticker := time.NewTicker(time.Second)\n\n    go func () {\n        for t := range ticker.C {\n            fmt.Println(t)\n        }\n    }()\n\n    //设置一个timer，10钞后停掉ticker\n    timer := time.NewTimer(10*time.Second)\n    \u0026lt;- timer.C\n\n    ticker.Stop()\n    fmt.Println(\u0026#34;timer expired!\u0026#34;)\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Socket%E7%BC%96%E7%A8%8B\"\u003e\u003c/span\u003eSocket编程\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是我尝试的一个Echo Server的Socket代码，感觉还是挺简单的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eServer端\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"12,19,24,33,36\"\u003e \npackage main\n\nimport (\n    \u0026#34;net\u0026#34;\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;io\u0026#34;\n)\n\nconst RECV_BUF_LEN = 1024\n\nfunc main() {\n    listener, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;0.0.0.0:6666\u0026#34;)//侦听在6666端口\n    if err != nil {\n        panic(\u0026#34;error listening:\u0026#34;+err.Error())\n    }\n    fmt.Println(\u0026#34;Starting the server\u0026#34;)\n\n    for {\n        conn, err := listener.Accept() //接受连接\n        if err != nil {\n            panic(\u0026#34;Error accept:\u0026#34;+err.Error())\n        }\n        fmt.Println(\u0026#34;Accepted the Connection :\u0026#34;, conn.RemoteAddr())\n        go EchoServer(conn)\n    }\n}\n\nfunc EchoServer(conn net.Conn) {\n    buf := make([]byte, RECV_BUF_LEN)\n    defer conn.Close()\n\n    for {\n        n, err := conn.Read(buf);\n        switch err {\n            case nil:\n                conn.Write( buf[0:n] )\n            case io.EOF:\n                fmt.Printf(\u0026#34;Warning: End of data: %s \\n\u0026#34;, err);\n                return\n            default:\n                fmt.Printf(\u0026#34;Error: Reading data : %s \\n\u0026#34;, err);\n                return\n        }\n     }\n}\n\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eClient端\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"12,23,31\"\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;time\u0026#34;\n    \u0026#34;net\u0026#34;\n)\n\nconst RECV_BUF_LEN = 1024\n\nfunc main() {\n    conn,err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:6666\u0026#34;)\n    if err != nil {\n        panic(err.Error())\n    }\n    defer conn.Close()\n\n    buf := make([]byte, RECV_BUF_LEN)\n\n    for i := 0; i \u0026lt; 5; i++ {\n        //准备要发送的字符串\n        msg := fmt.Sprintf(\u0026#34;Hello World, %03d\u0026#34;, i)\n        n, err := conn.Write([]byte(msg))\n        if err != nil {\n            println(\u0026#34;Write Buffer Error:\u0026#34;, err.Error())\n            break\n        }\n        fmt.Println(msg)\n\n        //从服务器端收字符串\n        n, err = conn.Read(buf)\n        if err !=nil {\n            println(\u0026#34;Read Buffer Error:\u0026#34;, err.Error())\n            break\n        }\n        fmt.Println(string(buf[0:n]))\n\n        //等一秒钟\n        time.Sleep(time.Second)\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"\u003e\u003c/span\u003e系统调用\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo语言那么C，所以，一定会有一些系统调用。Go语言主要是通过两个包完成的。一个是\u003ca href=\"https://golang.org/pkg/os/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eos包\u003c/a\u003e，一个是\u003ca href=\"https://golang.org/pkg/syscall/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003esyscall包\u003c/a\u003e。（注意，链接被墙）\u003c/p\u003e\n\u003cp\u003e这两个包里提供都是Unix-Like的系统调用，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003esyscall里提供了什么Chroot/Chmod/Chmod/Chdir…，Getenv/Getgid/Getpid/Getgroups/Getpid/Getppid…，还有很多如Inotify/Ptrace/Epoll/Socket/…的系统调用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003eos包里提供的东西不多，主要是一个跨平台的调用。它有三个子包，Exec（运行别的命令）, Signal（捕捉信号）和User（通过uid查name之类的）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003esyscall包的东西我不举例了，大家可以看看《Unix高级环境编程》一书。\u003c/p\u003e\n\u003cp\u003eos里的取几个例：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e环境变量\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport \u0026#34;os\u0026#34;\nimport \u0026#34;strings\u0026#34;\n\n\nfunc main() {\n    os.Setenv(\u0026#34;WEB\u0026#34;, \u0026#34;https://coolshell.cn\u0026#34;) //设置环境变量\n    println(os.Getenv(\u0026#34;WEB\u0026#34;)) //读出来\n\n    for _, env := range os.Environ() { //穷举环境变量\n        e := strings.Split(env, \u0026#34;=\u0026#34;)\n        println(e[0], \u0026#34;=\u0026#34;, e[1])\n    }\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%A1%8C\"\u003e\u003c/span\u003e执行命令行\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是一个比较简单的示例\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\nimport \u0026#34;os/exec\u0026#34;\nimport \u0026#34;fmt\u0026#34;\nfunc main() {\n    cmd := exec.Command(\u0026#34;ping\u0026#34;, \u0026#34;127.0.0.1\u0026#34;)\n    out, err := cmd.Output()\n    if err!=nil {\n        println(\u0026#34;Command Error!\u0026#34;, err.Error())\n        return\n    }\n    fmt.Println(string(out))\n}\u003c/pre\u003e\n\u003cp\u003e正规一点的用来处理标准输入和输出的示例如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport (\n    \u0026#34;strings\u0026#34;\n    \u0026#34;bytes\u0026#34;\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;os/exec\u0026#34;\n)\n\nfunc main() {\n    cmd := exec.Command(\u0026#34;tr\u0026#34;, \u0026#34;a-z\u0026#34;, \u0026#34;A-Z\u0026#34;)\n    cmd.Stdin = strings.NewReader(\u0026#34;some input\u0026#34;)\n    var out bytes.Buffer\n    cmd.Stdout = \u0026amp;out\n    err := cmd.Run()\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Printf(\u0026#34;in all caps: %q\\n\u0026#34;, out.String())\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"\u003e\u003c/span\u003e命令行参数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo语言中处理命令行参数很简单：(使用os的Args就可以了)\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"2\"\u003efunc main() {\n    args := os.Args\n    fmt.Println(args) //带执行文件的\n    fmt.Println(args[1:]) //不带执行文件的\n}\u003c/pre\u003e\n\u003cp\u003e在Windows下，如果运行结果如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eC:\\Projects\\Go\u0026gt;go run args.go aaa bbb ccc ddd\u003cbr/\u003e\n[C:\\Users\\haoel\\AppData\\Local\\Temp\\go-build742679827\\command-line-arguments_\u003cbr/\u003e\nobj\\a.out.exe aaa bbb ccc ddd]\u003cbr/\u003e\n[aaa bbb ccc ddd]\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e那么，如果我们要搞出一些像 mysql -uRoot -hLocalhost -pPwd 或是像 cc -O3 -Wall -o a a.c 这样的命令行参数我们怎么办？Go提供了一个package叫flag可以容易地做到这一点\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"13\"\u003epackage main\nimport \u0026#34;flag\u0026#34;\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\n    //第一个参数是“参数名”，第二个是“默认值”，第三个是“说明”。返回的是指针\n    host := flag.String(\u0026#34;host\u0026#34;, \u0026#34;coolshell.cn\u0026#34;, \u0026#34;a host name \u0026#34;)\n    port := flag.Int(\u0026#34;port\u0026#34;, 80, \u0026#34;a port number\u0026#34;)\n    debug := flag.Bool(\u0026#34;d\u0026#34;, false, \u0026#34;enable/disable debug mode\u0026#34;)\n\n    //正式开始Parse命令行参数\n    flag.Parse()\n\n    fmt.Println(\u0026#34;host:\u0026#34;, *host)\n    fmt.Println(\u0026#34;port:\u0026#34;, *port)\n    fmt.Println(\u0026#34;debug:\u0026#34;, *debug)\n}\u003c/pre\u003e\n\u003cp\u003e执行起来会是这个样子：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e#如果没有指定参数名，则使用默认值\n$ go run flagtest.go\nhost: coolshell.cn\nport: 80\ndebug: false\n\n#指定了参数名后的情况\n$ go run flagtest.go -host=localhost -port=22 -d\nhost: localhost\nport: 22\ndebug: true\n\n#用法出错了（如：使用了不支持的参数，参数没有=）\n$ go build flagtest.go\n$ ./flagtest -debug -host localhost -port=22\nflag provided but not defined: -debug\nUsage of flagtest:\n  -d=false: enable/disable debug mode\n  -host=\u0026#34;coolshell.cn\u0026#34;: a host name\n  -port=80: a port number\nexit status 2\n\u003c/pre\u003e\n\u003cp\u003e感觉还是挺不错的吧。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84HTTP_Server\"\u003e\u003c/span\u003e一个简单的HTTP Server\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e代码胜过千言万语。呵呵。这个小程序让我又找回以前用C写CGI的时光了。（Go的官方文档是《\u003cstrong\u003e\u003ca href=\"https://golang.org/doc/articles/wiki/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eWriting Web Applications\u003c/a\u003e\u003c/strong\u003e》）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;net/http\u0026#34;\n    \u0026#34;io/ioutil\u0026#34;\n    \u0026#34;path/filepath\u0026#34;\n)\n\nconst http_root = \u0026#34;/home/haoel/coolshell.cn/\u0026#34;\n\nfunc main() {\n    http.HandleFunc(\u0026#34;/\u0026#34;, rootHandler)\n    http.HandleFunc(\u0026#34;/view/\u0026#34;, viewHandler)\n    http.HandleFunc(\u0026#34;/html/\u0026#34;, htmlHandler)\n\n    http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil)\n}\n\n//读取一些HTTP的头\nfunc rootHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \u0026#34;rootHandler: %s\\n\u0026#34;, r.URL.Path)\n    fmt.Fprintf(w, \u0026#34;URL: %s\\n\u0026#34;, r.URL)\n    fmt.Fprintf(w, \u0026#34;Method: %s\\n\u0026#34;, r.Method)\n    fmt.Fprintf(w, \u0026#34;RequestURI: %s\\n\u0026#34;, r.RequestURI )\n    fmt.Fprintf(w, \u0026#34;Proto: %s\\n\u0026#34;, r.Proto)\n    fmt.Fprintf(w, \u0026#34;HOST: %s\\n\u0026#34;, r.Host) \n}\n\n//特别的URL处理\nfunc viewHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprintf(w, \u0026#34;viewHandler: %s\u0026#34;, r.URL.Path)\n}\n\n//一个静态网页的服务示例。（在http_root的html目录下）\nfunc htmlHandler(w http.ResponseWriter, r *http.Request) {\n    fmt.Printf(\u0026#34;htmlHandler: %s\\n\u0026#34;, r.URL.Path)\n    \n    filename := http_root + r.URL.Path\n    fileext := filepath.Ext(filename)\n\n    content, err := ioutil.ReadFile(filename)\n    if err != nil {\n        fmt.Printf(\u0026#34;   404 Not Found!\\n\u0026#34;)\n        w.WriteHeader(http.StatusNotFound)\n        return\n    }\n    \n    var contype string\n    switch fileext {\n        case \u0026#34;.html\u0026#34;, \u0026#34;htm\u0026#34;:\n            contype = \u0026#34;text/html\u0026#34;\n        case \u0026#34;.css\u0026#34;:\n            contype = \u0026#34;text/css\u0026#34;\n        case \u0026#34;.js\u0026#34;:\n            contype = \u0026#34;application/javascript\u0026#34;\n        case \u0026#34;.png\u0026#34;:\n            contype = \u0026#34;image/png\u0026#34;\n        case \u0026#34;.jpg\u0026#34;, \u0026#34;.jpeg\u0026#34;:\n            contype = \u0026#34;image/jpeg\u0026#34;\n        case \u0026#34;.gif\u0026#34;:\n            contype = \u0026#34;image/gif\u0026#34;\n        default: \n            contype = \u0026#34;text/plain\u0026#34;\n    }\n    fmt.Printf(\u0026#34;ext %s, ct = %s\\n\u0026#34;, fileext, contype)\n    \n    w.Header().Set(\u0026#34;Content-Type\u0026#34;, contype)\n    fmt.Fprintf(w, \u0026#34;%s\u0026#34;, content)\n    \n}\u003c/pre\u003e\n\u003cp\u003eGo的功能库有很多，大家自己慢慢看吧。\u003cstrong\u003e我再吐个槽——Go的文档真不好读。例子太少了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e先说这么多吧。这是我周末两天学Go语言学到的东西，写得太仓促了，而且还有一些东西理解不到位，还大家请指正！\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-8489\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"bafb05b5e0\"\u003e\u003cimg id=\"rating_8489_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8489, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6bea283b35281e374fce33a6-=\"\"/\u003e\u003cimg id=\"rating_8489_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8489, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6bea283b35281e374fce33a6-=\"\"/\u003e\u003cimg id=\"rating_8489_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8489, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6bea283b35281e374fce33a6-=\"\"/\u003e\u003cimg id=\"rating_8489_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8489, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6bea283b35281e374fce33a6-=\"\"/\u003e\u003cimg id=\"rating_8489_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8489, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6bea283b35281e374fce33a6-=\"\"/\u003e (\u003cstrong\u003e35\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.23\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_8489_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go 语言简介（下）— 特性\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go 语言简介（下）— 特性\"/\u003e\u003cmeta itemprop=\"description\" content=\"希望你看到这篇文章的时候还是在公交车和地铁上正在上下班的时间，我希望我的这篇文章可以让你利用这段时间了解一门语言。当然，希望你不会因为看我的文章而错过站。呵呵。\n\n如果你还不了解Go语言的语法，还请你移步先看一下上篇——《Go语言简介（上）：语法》\n\n\n\ngoroutine\n\nGoRoutine主要是使用go关键字来调用函数，你还可以使用匿名函数，如下所示：\n\n\n\npackage main\nimp...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-11-07T08:17:20+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-06T18:00:52+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/8489.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/8489.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.23\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"35\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-8489-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-11-07T08:17:20+08:00",
  "Author": "陈皓"
}