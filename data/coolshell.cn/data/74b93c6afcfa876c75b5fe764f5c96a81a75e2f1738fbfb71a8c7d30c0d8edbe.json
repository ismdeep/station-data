{
  "Source": "coolshell.cn",
  "Title": "C/C++语言中闭包的探究及比较",
  "Link": "https://coolshell.cn/articles/8309.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"2f1b0a1c1ae95264ba142517-text/javascript\"\u003e\u003c/script\u003e（\u003cstrong\u003e\u003cspan style=\"color: #cc0000;\"\u003e感谢投稿人\u003c/span\u003e \u003ca href=\"http://weibo.com/jasonmblog\" target=\"_blank\"\u003e@思禽饮霜\u003c/a\u003e \u003c/strong\u003e）\u003c/p\u003e\n\u003cp\u003e这里主要讨论的是C语言的扩展特性\u003ca href=\"https://en.wikipedia.org/wiki/Blocks_(C_language_extension)\" target=\"_blank\"\u003eblock\u003c/a\u003e。该特性是Apple为C、C++、Objective-C增加的扩展，让这些语言可以用类Lambda表达式的语法来创建\u003ca href=\"https://en.wikipedia.org/wiki/Closure_(computer_science)\" target=\"_blank\"\u003e闭包\u003c/a\u003e。前段时间，在对CoreData存取进行封装时（让开发人员可以更简洁快速地写相关代码），我对block机制有了进一步了解，觉得可以和C++ 11中的Lambda表达式相互印证，所以最近重新做了下整理，分享给大家。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#0_%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\" title=\"0. 简单创建匿名函数\"\u003e0. 简单创建匿名函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#1_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\" title=\"1. 从语法上看如何捕获外部变量\"\u003e1. 从语法上看如何捕获外部变量\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#2_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\" title=\"2. 从语法上看如何修改外部变量\"\u003e2. 从语法上看如何修改外部变量\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#3_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\" title=\"3. 从实现上看如何捕获外部变量\"\u003e3. 从实现上看如何捕获外部变量\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#4_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88_block%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%89\" title=\"4. 从实现上看如何修改外部变量（__block类型指示符）\"\u003e4. 从实现上看如何修改外部变量（__block类型指示符）\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#5_%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%A8%E4%BD%9C\" title=\"5. 背后的内存管理动作\"\u003e5. 背后的内存管理动作\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#51_%E6%8B%B7%E8%B4%9Dblock%E7%BB%93%E6%9E%84%E4%BD%93\" title=\"5.1 拷贝block结构体\"\u003e5.1 拷贝block结构体\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#52_%E6%8B%B7%E8%B4%9D%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88_block%E5%8F%98%E9%87%8F%EF%BC%89\" title=\"5.2 拷贝捕获的变量（__block变量）\"\u003e5.2 拷贝捕获的变量（__block变量）\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#53_forwarding%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8\" title=\"5.3 __forwarding指针的作用\"\u003e5.3 __forwarding指针的作用\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A\" title=\"参考资料：\"\u003e参考资料：\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"0_%E7%AE%80%E5%8D%95%E5%88%9B%E5%BB%BA%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e0. 简单创建匿名函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面两段代码的作用都是创建匿名函数并调用，输出Hello, World语句。分别使用Objective-C和C++ 11：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e^{ printf(\u0026#34;Hello, World!\\n\u0026#34;); } ();\u003c/code\u003e\u003cbr/\u003e\n\u003ccode data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e[] { cout \u0026lt;\u0026lt; \u0026#34;Hello, World\u0026#34; \u0026lt;\u0026lt; endl; } ();\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eLambda表达式的一个好处就是让开发人员可以在需要的时候临时创建函数，便捷。\u003c/p\u003e\n\u003cp\u003e在创建闭包（或者说Lambda函数）的语法上，Objective-C采用的是上尖号\u003cspan style=\"color: #ff0000;\"\u003e^\u003c/span\u003e，而C++ 11采用的是配对的方括号\u003cspan style=\"color: #ff0000;\"\u003e[]\u003c/span\u003e。\u003c/p\u003e\n\u003cp\u003e不过“\u003cspan style=\"color: #808000;\"\u003e匿名函数\u003c/span\u003e”一词是针对程序员而言的，编译器还是采取了一定的命名规则。\u003c/p\u003e\n\u003cp\u003e比如下面Objective-C代码中的3个block，\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#import \u0026lt;Foundation/Foundation.h\u0026gt;\n\nint (^maxBlk)(int , int) = ^(int m, int n){ return m \u0026gt; n ? m : n; };\n\nint main(int argc, const char * argv[])\n{\n    ^{ printf(\u0026#34;Hello, World!\\n\u0026#34;); } ();\n\n    int i = 1024;\n    void (^blk)(void) = ^{ printf(\u0026#34;%d\\n\u0026#34;, i); };\n    blk();\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e会产生对应的3个函数：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-8309\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e__maxBlk_block_func_0\n__main_block_func_0\n__main_block_func_1\n\u003c/pre\u003e\n\u003cp\u003e可见函数的命名规则为：__\u003cspan style=\"color: #ff0000;\"\u003e{$Scope}\u003c/span\u003e_block_func_\u003cspan style=\"color: #ff0000;\"\u003e{$index}\u003c/span\u003e。其中{$Scope}为block所在函数，如果{$Scope}为全局就取block本身的名称；{$index}表示该block在{$Scope}作用域内出现的顺序（第几个block）。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"1_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\"\u003e\u003c/span\u003e1. 从语法上看如何捕获外部变量\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在上面的代码中，已经看到“\u003cspan style=\"color: #808000;\"\u003e匿名函数\u003c/span\u003e”可以直接访问外围作用域的变量i：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint i = 1024;\nvoid (^blk)(void) = ^{ printf(\u0026#34;%d\\n\u0026#34;, i); };\nblk();\n\u003c/pre\u003e\n\u003cp\u003e当匿名函数和non-local变量结合起来，就形成了闭包（个人看法）。\u003cbr/\u003e\n这一段代码可以成功输出i的值。\u003c/p\u003e\n\u003cp\u003e我们把一样的逻辑搬到C++上：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint i = 1024;\nauto func = [] { printf(\u0026#34;%d\\n\u0026#34;, i); };\nfunc();\n\u003c/pre\u003e\n\u003cp\u003eGCC会输出：\u003cspan style=\"color: #808000;\"\u003e\u003cspan style=\"color: #ff0000;\"\u003e错误\u003c/span\u003e：‘i’未被捕获\u003c/span\u003e。可见在C++中无法直接捕获外围作用域的变量。\u003c/p\u003e\n\u003cp\u003e以BNF来表示Lambda表达式的上下文无关文法，存在：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003elambda-expression : lambda-introducer lambda-parameter-declarationopt compound-statement\nlambda-introducer : [ lambda-captureopt ]\n\u003c/pre\u003e\n\u003cp\u003e因此，方括号中还可以加入一些选项：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e[]        Capture nothing (or, a scorched earth strategy?)\n[\u0026amp;]       Capture any referenced variable by reference\n[=]       Capture any referenced variable by making a copy\n[=, \u0026amp;foo] Capture any referenced variable by making a copy, but capture variable foo by reference\n[bar]     Capture bar by making a copy; don\u0026#39;t copy anything else\n[this]    Capture the this pointer of the enclosing class\n\u003c/pre\u003e\n\u003cp\u003e根据文法，对代码加以修改，使其能够成功运行：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003ebash-3.2# vi testLambda.cpp\nbash-3.2# g++-4.7 -std=c++11 testLambda.cpp -o testLambda\nbash-3.2# ./testLambda\n1024\nbash-3.2# cat testLambda.cpp\n#include \u0026lt;iostream\u0026gt;\n\nusing  namespace std;\n\nint main()\n{\n     int i = 1024;\n     auto func = [=] { printf(\u0026#34;%d\\n\u0026#34;, i); };\n     func();\n\n     return 0;\n}\nbash-3.2#\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"2_%E4%BB%8E%E8%AF%AD%E6%B3%95%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\"\u003e\u003c/span\u003e2. 从语法上看如何修改外部变量\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e上面代码中使用了符号\u003cspan style=\"color: #ff0000;\"\u003e=\u003c/span\u003e，通过\u003cspan style=\"color: #808000;\"\u003e拷贝方式\u003c/span\u003e捕获了外部变量i。\u003cbr/\u003e\n但是如果尝试在Lambda表达式中修改变量i：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eauto func = [=] { i = 0; printf(\u0026#34;%d\\n\u0026#34;, i); };\n\u003c/pre\u003e\n\u003cp\u003e会得到错误：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003etestLambda.cpp: 在 lambda 函数中:\ntestLambda.cpp:9:24: 错误：向只读变量‘i’赋值\n\u003c/pre\u003e\n\u003cp\u003e可见\u003cem\u003e\u003cspan style=\"color: #808000;\"\u003e通过拷贝方式捕获的外部变量是只读的\u003c/span\u003e\u003c/em\u003e。Python中也有一个类似的经典case，个人觉得有相通之处：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"python\" class=\"EnlighterJSRAW\"\u003ex = 10\ndef foo():\n    print(x)\n    x += 1\nfoo()\n\u003c/pre\u003e\n\u003cp\u003e这段代码会抛出\u003cspan style=\"color: #ff0000;\"\u003eUnboundLocalError\u003c/span\u003e错误，原因可以参见\u003ca href=\"https://docs.python.org/faq/programming.html#why-am-i-getting-an-unboundlocalerror-when-the-variable-has-a-value\" target=\"_blank\"\u003eFAQ\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e在C++的闭包语法中，如果需要对外部变量的写权限，可以使用符号\u003cspan style=\"color: #ff0000;\"\u003e\u0026amp;\u003c/span\u003e，通过\u003cspan style=\"color: #808000;\"\u003e\u003cem\u003e引用方式\u003c/em\u003e\u003c/span\u003e捕获：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint i = 1024;\nauto func = [\u0026amp;] { i = 0; printf(\u0026#34;%d\\n\u0026#34;, i); };\nfunc();\n\u003c/pre\u003e\n\u003cp\u003e反过来，将修改外部变量的逻辑放到Objective-C代码中：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint i = 1024;\nvoid (^blk)(void) = ^{ i = 0; printf(\u0026#34;%d\\n\u0026#34;, i); };\nblk();\n\u003c/pre\u003e\n\u003cp\u003e会得到如下错误：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003emain.m:14:29: error: variable is not assignable (missing __block type specifier)\n    void (^blk)(void) = ^{ i++; printf(\u0026#34;%d\\n\u0026#34;, i); };\n                           ~^\n1 error generated.\n\u003c/pre\u003e\n\u003cp\u003e可见在block的语法中，默认捕获的外部变量也是只读的，如果要修改外部变量，需要使用\u003cspan style=\"color: #ff0000;\"\u003e__block\u003c/span\u003e类型指示符进行修饰。\u003cbr/\u003e\n为什么呢？请继续往下看 ：）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"3_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E6%8D%95%E8%8E%B7%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F\"\u003e\u003c/span\u003e3. 从实现上看如何捕获外部变量\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e闭包对于编程语言来说是一种语法糖，包括Block和Lambda，是为了方便程序员开发而引入的。因此，对Block特性的支持会落地在\u003cspan style=\"color: #808000;\"\u003e\u003cem\u003e编译器前端\u003c/em\u003e\u003c/span\u003e，中间代码将会是C语言。\u003c/p\u003e\n\u003cp\u003e先看如下代码会产生怎样的中间代码。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint main(int argc, const char * argv[])\n{\n    int i = 1024;\n    void (^blk)(void) = ^{ printf(\u0026#34;%d\\n\u0026#34;, i); };\n    blk();\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e首先是\u003cspan style=\"color: #ff0000;\"\u003eblock结构体\u003c/span\u003e的实现：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#ifndef BLOCK_IMPL\n#define BLOCK_IMPL\nstruct __block_impl {\n    void *isa;\n    int Flags;\n    int Reserved;\n    void *FuncPtr;\n};\n// 省略部分代码\n\n#endif\n\u003c/pre\u003e\n\u003cp\u003e第一个成员\u003cspan style=\"color: #ff0000;\"\u003eisa\u003c/span\u003e指针用来表示该结构体的类型，使其仍然处于Cocoa的对象体系中，类似Python对象系统中的PyObject。\u003c/p\u003e\n\u003cp\u003e第二、三个成员是标志位和保留位。\u003c/p\u003e\n\u003cp\u003e第四个成员是对应的“匿名函数”，在这个例子中对应函数：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic void __main_block_func_0(struct __main_block_impl_0 *__cself) {\n    int i = __cself-\u0026gt;i; // bound by copy\n    printf(\u0026#34;%d\\n\u0026#34;, i);\n}\n\u003c/pre\u003e\n\u003cp\u003e函数__main_block_func_0引入了参数\u003cspan style=\"color: #808000;\"\u003e__cself\u003c/span\u003e，为struct __main_block_impl_0 *类型，从参数名称就可以看出它的功能类似于C++中的this指针或者Objective-C的self。\u003cbr/\u003e\n而struct __main_block_impl_0的结构如下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    int i;\n    __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _i, int flags=0) : i(_i) {\n        impl.isa = \u0026amp;_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\u003c/pre\u003e\n\u003cp\u003e从__main_block_impl_0这个名称可以看出该结构体是为main函数中第零个block服务的，即示例代码中的blk；也可以猜到不同场景下的block对应的结构体不同，但本质上第一个成员一定是\u003cspan style=\"color: #808000;\"\u003estruct __block_impl impl\u003c/span\u003e，因为这个成员是block实现的基石。\u003c/p\u003e\n\u003cp\u003e结构体__main_block_impl_0又引入了一个新的结构体，也是中间代码里最后一个结构体：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic struct __main_block_desc_0 {\n    unsigned long reserved;\n    unsigned long Block_size;\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};\n\u003c/pre\u003e\n\u003cp\u003e可以看出，这个描述性质的结构体包含的价值信息就是struct __main_block_impl_0的大小。\u003c/p\u003e\n\u003cp\u003e最后剩下main函数对应的中间代码：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint main(int argc, const char * argv[])\n{\n    int i = 1024;\n    void (*blk)(void) = (void (*)(void))\u0026amp;__main_block_impl_0((void *)__main_block_func_0, \u0026amp;__main_block_desc_0_DATA, i);\n    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-\u0026gt;FuncPtr)((struct __block_impl *)blk);\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e从main函数对应的中间代码可以看出\u003cspan style=\"color: #ff0000;\"\u003e执行block的本质\u003c/span\u003e就是\u003cspan style=\"color: #808000;\"\u003e以block结构体自身作为__cself参数\u003c/span\u003e，这里对应__main_block_impl_0，\u003cspan style=\"color: #808000;\"\u003e通过结构体成员FuncPtr函数指针调用对应的函数\u003c/span\u003e，这里对应__main_block_func_0。\u003c/p\u003e\n\u003cp\u003e其中，局部变量i是以\u003cspan style=\"color: #808000;\"\u003e值传递\u003c/span\u003e的方式拷贝一份，作为__main_block_impl_0的构造函数的参数，并以初始化列表的形式赋值给其成员变量i。所以，基于这样的实现，不允许直接修改外部变量是合理的——因为按值传递根本改不到外部变量。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"4_%E4%BB%8E%E5%AE%9E%E7%8E%B0%E4%B8%8A%E7%9C%8B%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88_block%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6%EF%BC%89\"\u003e\u003c/span\u003e4. 从实现上看如何修改外部变量（\u003cspan style=\"color: #ff0000;\"\u003e__block\u003c/span\u003e类型指示符）\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e如果想要修改外部变量，则需要用\u003cspan style=\"color: #ff0000;\"\u003e__block\u003c/span\u003e来修饰：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint main(int argc, const char * argv[])\n{\n    __block int i = 1024;\n    void (^blk)(void) = ^{ i = 0; printf(\u0026#34;%d\\n\u0026#34;, i); };\n    blk();\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e此时再看中间代码，发现多了一个结构体：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct __Block_byref_i_0 {\n    void *__isa;\n    __Block_byref_i_0 *__forwarding;\n    int __flags;\n    int __size;\n    int i;\n};\n\u003c/pre\u003e\n\u003cp\u003e于是，用__block修饰的int变量\u003cspan style=\"color: #808000;\"\u003ei化身为\u003c/span\u003e__Block_byref_i_0结构体的最后一个\u003cspan style=\"color: #808000;\"\u003e成员变量\u003c/span\u003e。\u003c/p\u003e\n\u003cp\u003e代码中blk对应的结构体也发生了变化：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct __main_block_impl_0 {\n    struct __block_impl impl;\n    struct __main_block_desc_0* Desc;\n    __Block_byref_i_0 *i; // by ref\n    __main_block_impl_0(void *fp, struct__main_block_desc_0 *desc, __Block_byref_i_0 *_i, int flags=0) : i(_i-\u0026gt;__forwarding) {\n        impl.isa = \u0026amp;_NSConcreteStackBlock;\n        impl.Flags = flags;\n        impl.FuncPtr = fp;\n        Desc = desc;\n    }\n};\n\u003c/pre\u003e\n\u003cp\u003e__main_block_impl_0发生的变化就是int类型的成员变量i换成了__Block_byref_i_0 *类型，从名称可以看出现在要通过引用方式来捕获了。\u003c/p\u003e\n\u003cp\u003e对应的函数也不同了：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic void __main_block_func_0(struct  __main_block_impl_0 *__cself) {\n    __Block_byref_i_0 *i = __cself-\u0026gt;i; // bound by ref\n    (i-\u0026gt;__forwarding-\u0026gt;i) = 0; // 看起来很厉害的样子\n    printf(\u0026#34;%d\\n\u0026#34;, (i-\u0026gt;__forwarding-\u0026gt;i));\n}\n\u003c/pre\u003e\n\u003cp\u003emain函数也有了变动：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint main(int argc, const char * argv[])\n{\n    __block __Block_byref_i_0 i = {(void*)0,(__Block_byref_i_0 *)\u0026amp;i, 0, sizeof(__Block_byref_i_0), 1024};\n    void (*blk)(void) = (void (*)(void))\u0026amp;__main_block_impl_0((void *)__main_block_func_0, \u0026amp;__main_block_desc_0_DATA, (struct __Block_byref_i_0 *)\u0026amp;i, 570425344);\n    ((void (*)(struct __block_impl *))((struct __block_impl *)blk)-\u0026gt;FuncPtr)((struct __block_impl *)blk);\n\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e前两行代码创建了两个关键结构体，特地高亮显示。\u003c/p\u003e\n\u003cp\u003e这里没有看__main_block_desc_0发生的变化，\u003cem\u003e\u003cspan style=\"color: #808000;\"\u003e放到后面讨论\u003c/span\u003e\u003c/em\u003e。\u003c/p\u003e\n\u003cp\u003e使用\u003cspan style=\"color: #ff0000;\"\u003e__block类型指示符的本质\u003c/span\u003e就是引入了__Block_byref_\u003cspan style=\"color: #ff0000;\"\u003e{$var_name}\u003c/span\u003e_\u003cspan style=\"color: #ff0000;\"\u003e{$index}\u003c/span\u003e结构体，而被__block关键字修饰的变量就被放到这个结构体中。另外，block结构体通过引入__Block_byref_{$var_name}_{$index}指针类型的成员，得以间接访问到外部变量。\u003c/p\u003e\n\u003cp\u003e通过这样的设计，我们就可以修改外部作用域的变量了，再一次应了那句话：\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003eThere is no problem in computer science that can’t be solved by adding another level of indirection.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e指针是我们最经常使用的间接手段，而这里的本质也是通过指针来间接访问，为什么要特地引入__Block_byref_{$var_name}_{$index}结构体，而不是直接使用int *来访问外部变量i呢？\u003c/p\u003e\n\u003cp\u003e另外，__Block_byref_{$var_name}_{$index}结构体中的\u003cspan style=\"color: #ff0000;\"\u003e__forwarding\u003c/span\u003e指针成员有何作用？\u003c/p\u003e\n\u003cp\u003e请继续往下看 ：）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"5_%E8%83%8C%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8A%A8%E4%BD%9C\"\u003e\u003c/span\u003e5. 背后的内存管理动作\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在Objective-C中，block特性的引入是\u003cem\u003e\u003cspan style=\"color: #808000;\"\u003e为了让程序员可以更简洁优雅地编写并发代码\u003c/span\u003e\u003c/em\u003e（配合看起来像敏感词的GCD）。比较常见的就是将block作为函数参数传递，以供后续回调执行。\u003c/p\u003e\n\u003cp\u003e先看一段完整的、可执行的代码：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#import \u0026lt;Foundation/Foundation.h\u0026gt;\n#include \u0026lt;pthread.h\u0026gt;\n\ntypedef void (^DemoBlock)(void);\n\nvoid test();\nvoid *testBlock(void *blk);\n\nint main(int argc, const char * argv[])\n{\n    printf(\u0026#34;Before test()\\n\u0026#34;);\n    test();\n    printf(\u0026#34;After test()\\n\u0026#34;);\n\n    sleep(5);\n    return 0;\n}\n\nvoid test()\n{\n    __block int i = 1024;\n    void (^blk)(void) = ^{ i = 2048; printf(\u0026#34;%d\\n\u0026#34;, i); };\n\n    pthread_t thread;\n    int ret = pthread_create(\u0026amp;thread, NULL, testBlock, (void *)blk);\n    printf(\u0026#34;thread returns : %d\\n\u0026#34;, ret);\n\n    sleep(3); // 这里睡眠1s的话，程序会崩溃\n}\n\nvoid *testBlock(void *blk)\n{\n    sleep(2);\n\n    printf(\u0026#34;testBlock : Begin to exec blk.\\n\u0026#34;);\n    DemoBlock demoBlk = (DemoBlock)blk;\n    demoBlk();\n\n    return NULL;\n}\n\u003c/pre\u003e\n\u003cp\u003e在这个示例中，位于test()函数的block类型的变量blk就作为函数参数传递给testBlock。\u003c/p\u003e\n\u003cp\u003e正常情况下，这段代码可以成功运行，输出：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eBefore test()\nthread returns : 0\ntestBlock : Begin to exec blk.\n2048\nAfter test()\n\u003c/pre\u003e\n\u003cp\u003e如果按照注释，将test()函数最后一行改为休眠1s的话，正常情况下程序会在输出如下结果后崩溃：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eBefore test()\nthread returns : 0\nAfter test()\ntestBlock : Begin to exec blk.\n\u003c/pre\u003e\n\u003cp\u003e从输出可以看出，当要执行blk的时候，test()已经执行完毕回到main函数中，对应的\u003cspan style=\"color: #808000;\"\u003e函数栈也已经展开\u003c/span\u003e，此时栈上的变量已经不存在了，继续访问导致崩溃——这也是不用int *直接访问外部变量i的原因。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"51_%E6%8B%B7%E8%B4%9Dblock%E7%BB%93%E6%9E%84%E4%BD%93\"\u003e\u003c/span\u003e5.1 拷贝block结构体\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e上文提到block结构体__block_impl的第一个成员是isa指针，使其成为NSObject的子类，所以我们可以通过相应的\u003cspan style=\"color: #808000;\"\u003e内存管理机制\u003c/span\u003e将其拷贝到堆上：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003evoid test()\n{\n    __block int i = 1024;\n    void (^blk)(void) = ^{ i = 2048; printf(\u0026#34;%d\\n\u0026#34;, i); };\n\n    pthread_t thread;\n    int ret = pthread_create(\u0026amp;thread, NULL, testBlock, (void *)[blk copy]);\n    printf(\u0026#34;thread returns : %d\\n\u0026#34;, ret);\n\n    sleep(1);\n}\n\nvoid *testBlock(void *blk)\n{\n    sleep(2);\n\n    printf(\u0026#34;testBlock : Begin to exec blk.\\n\u0026#34;);\n    DemoBlock demoBlk = (DemoBlock)blk;\n    demoBlk();\n    [demoBlk release];\n\n    returnNULL;\n}\n\u003c/pre\u003e\n\u003cp\u003e再次执行，得到输出：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eBefore test()\nthread returns : 0\nAfter test()\ntestBlock : Begin to exec blk.\n2048\n\u003c/pre\u003e\n\u003cp\u003e可以看出，在test()函数栈展开后，demoBlk仍然可以成功执行，这是由于blk对应的block结构体__main_block_impl_0已经在堆上了。\u003cspan style=\"color: #808000;\"\u003e不过这还不够\u003c/span\u003e——\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"52_%E6%8B%B7%E8%B4%9D%E6%8D%95%E8%8E%B7%E7%9A%84%E5%8F%98%E9%87%8F%EF%BC%88_block%E5%8F%98%E9%87%8F%EF%BC%89\"\u003e\u003c/span\u003e5.2 拷贝捕获的变量（\u003cspan style=\"color: #ff0000;\"\u003e__block\u003c/span\u003e变量）\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e在拷贝block结构体的同时，还会将捕获的\u003cspan style=\"color: #ff0000;\"\u003e__block\u003c/span\u003e变量，即结构体__Block_byref_i_0，复制到堆上。这个任务落在前面没有讨论的__main_block_desc_0结构体身上：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)\u0026amp;dst-\u0026gt;i, (void*)src-\u0026gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-\u0026gt;i, 8/*BLOCK_FIELD_IS_BYREF*/);}\n\nstatic struct __main_block_desc_0 {\n    unsigned long reserved;\n    unsigned long Block_size;\n    void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*);\n    void (*dispose)(struct __main_block_impl_0*);\n} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};\n\u003c/pre\u003e\n\u003cp\u003e栈上的__main_block_impl_0结构体为src，堆上的__main_block_impl_0结构体为dst，当发生复制动作时，__main_block_copy_0函数会得到调用，将src的成员变量i，即__Block_byref_i_0结构体，也\u003cspan style=\"color: #808000;\"\u003e复制到堆上\u003c/span\u003e。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"53_forwarding%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8\"\u003e\u003c/span\u003e5.3 __forwarding指针的作用\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e当复制动作完成后，\u003cspan style=\"color: #808000;\"\u003e栈上和堆上都存在\u003c/span\u003e着__main_block_impl_0结构体。如果栈上、堆上的block结构体都对捕获的外部变量进行操作，会如何？\u003c/p\u003e\n\u003cp\u003e下面是一段示例代码：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003evoid test()\n{\n    __block int i = 1024;\n    void (^blk)(void) = ^{ i++; printf(\u0026#34;%d\\n\u0026#34;, i); };\n\n    pthread_t thread;\n    int ret = pthread_create(\u0026amp;thread, NULL, testBlock, (void *)[blk copy]);\n    printf(\u0026#34;thread returns : %d\\n\u0026#34;, ret);\n\n    sleep(1);\n    blk();\n}\n\nvoid *testBlock(void *blk)\n{\n    sleep(2);\n\n    printf(\u0026#34;testBlock : Begin to exec blk.\\n\u0026#34;);\n    DemoBlock demoBlk = (DemoBlock)blk;\n    demoBlk();\n    [demoBlk release];\n\n    returnNULL;\n}\n\u003c/pre\u003e\n\u003col\u003e\n\u003cli\u003e在test()函数中调用pthread_create创建线程时，\u003cspan style=\"color: #808000;\"\u003eblk被复制了一份到堆上\u003c/span\u003e作为testBlock函数的参数。\u003c/li\u003e\n\u003cli\u003etest()函数中的\u003cspan style=\"color: #808000;\"\u003eblk结构体位于栈中，在休眠1s后被执行\u003c/span\u003e，对i进行自增动作。\u003c/li\u003e\n\u003cli\u003etestBlock函数在休眠2s后，\u003cspan style=\"color: #808000;\"\u003e执行位于堆上的block结构体\u003c/span\u003e，这里为demoBlk。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e上述代码执行后输出：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eBefore test()\nthread returns : 0\n1025\nAfter test()\ntestBlock : Begin to exec blk.\n1026\n\u003c/pre\u003e\n\u003cp\u003e可见无论是栈上的还是堆上的block结构体，修改的都是\u003cspan style=\"color: #808000;\"\u003e同一个__block变量\u003c/span\u003e。\u003c/p\u003e\n\u003cp\u003e这就是前面提到的__forwarding指针成员的作用了：\u003c/p\u003e\n\u003cp\u003e\u003cspan style=\"color: #ff0000;\"\u003e起初\u003c/span\u003e，栈上的__block变量的成员指针__forwarding指向__block变量本身，即栈上的__Block_byref_i_0结构体。\u003c/p\u003e\n\u003cp\u003e\u003cspan style=\"color: #ff0000;\"\u003e当__block变量被复制到堆上后\u003c/span\u003e，栈上的__block变量的__forwarding成员会指向堆上的那一份拷贝，从而保持一致。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99%EF%BC%9A\"\u003e\u003c/span\u003e参考资料：\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://msdn.microsoft.com/en-us/library/dd293603.aspx\" target=\"_blank\"\u003ehttp://msdn.microsoft.com/en-us/library/dd293603.aspx\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.cprogramming.com/c++11/c++11-lambda-closures.html\" target=\"_blank\"\u003ehttp://www.cprogramming.com/c++11/c++11-lambda-closures.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html\" target=\"_blank\"\u003ehttp://developer.apple.com/library/ios/#documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Closure_(computer_science)\" target=\"_blank\"\u003ehttp://en.wikipedia.org/wiki/Closure_(computer_science)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_title\"\u003eAPI设计原则 – Qt官网的设计实践总结\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17524.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2016/10/drawing-recursive-150x150.jpg\" alt=\"如何读懂并写出装逼的函数式代码\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17524.html\" class=\"wp_rp_title\"\u003e如何读懂并写出装逼的函数式代码\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg\" alt=\"Leetcode 编程训练\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_title\"\u003eLeetcode 编程训练\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif\" alt=\"State Threads 回调终结者\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_title\"\u003eState Threads 回调终结者\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-8309\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"f8e4a75fa7\"\u003e\u003cimg id=\"rating_8309_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8309, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-2f1b0a1c1ae95264ba142517-=\"\"/\u003e\u003cimg id=\"rating_8309_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8309, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-2f1b0a1c1ae95264ba142517-=\"\"/\u003e\u003cimg id=\"rating_8309_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8309, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-2f1b0a1c1ae95264ba142517-=\"\"/\u003e\u003cimg id=\"rating_8309_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8309, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-2f1b0a1c1ae95264ba142517-=\"\"/\u003e\u003cimg id=\"rating_8309_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(8309, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-2f1b0a1c1ae95264ba142517-=\"\"/\u003e (\u003cstrong\u003e19\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.89\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_8309_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"C/C++语言中闭包的探究及比较\"/\u003e\u003cmeta itemprop=\"headline\" content=\"C/C++语言中闭包的探究及比较\"/\u003e\u003cmeta itemprop=\"description\" content=\"（感谢投稿人 @思禽饮霜 ）\n\n这里主要讨论的是C语言的扩展特性block。该特性是Apple为C、C++、Objective-C增加的扩展，让这些语言可以用类Lambda表达式的语法来创建闭包。前段时间，在对CoreData存取进行封装时（让开发人员可以更简洁快速地写相关代码），我对block机制有了进一步了解，觉得可以和C++ 11中的Lambda表达式相互印证，所以最近重新做了下整理，分...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2012-09-20T08:17:07+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2012-09-21T08:42:21+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/8309.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"Jason Lee\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/8309.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.89\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"19\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-8309-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2012-09-20T08:17:07+08:00",
  "Author": "Jason Lee"
}