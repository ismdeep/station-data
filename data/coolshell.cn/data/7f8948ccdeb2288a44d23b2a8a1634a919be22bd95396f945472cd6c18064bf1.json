{
  "Source": "coolshell.cn",
  "Title": "C语言结构体里的成员数组和指针",
  "Link": "https://coolshell.cn/articles/11377.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"964a7398a65110688d14b445-text/javascript\"\u003e\u003c/script\u003e单看这文章的标题，你可能会觉得好像没什么意思。你先别下这个结论，相信这篇文章会对你理解C语言有帮助。这篇文章产生的背景是在微博上，看到\u003ca title=\"Laruence\" href=\"http://weibo.com/laruence\" target=\"_blank\"\u003e@Laruence\u003c/a\u003e同学出了一个关于C语言的题，\u003ca href=\"http://weibo.com/1170999921/ADojDbuSe\" target=\"_blank\"\u003e微博链接\u003c/a\u003e。微博截图如下。我觉得好多人对这段代码的理解还不够深入，所以写下了这篇文章。\u003c/p\u003e\n\u003cp style=\"text-align: center;\"\u003e\u003ca href=\"http://weibo.com/1170999921/ADojDbuSe\" target=\"_blank\"\u003e\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-11378\" alt=\"zero_array\" src=\"https://coolshell.cn/wp-content/uploads/2014/03/zero_array.png\" width=\"549\" height=\"204\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/03/zero_array.png 549w, https://coolshell.cn/wp-content/uploads/2014/03/zero_array-300x111.png 300w\" sizes=\"(max-width: 549px) 100vw, 549px\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e为了方便你把代码copy过去编译和调试，我把代码列在下面：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#include \u0026lt;stdio.h\u0026gt;\nstruct str{\n    int len;\n    char s[0];\n};\n\nstruct foo {\n    struct str *a;\n};\n\nint main(int argc, char** argv) {\n    struct foo f={0};\n    if (f.a-\u0026gt;s) {\n        printf( f.a-\u0026gt;s);\n    }\n    return 0;\n}\n\u003c/pre\u003e\n\u003cp\u003e你编译一下上面的代码，在VC++和GCC下都会在14行的printf处crash掉你的程序。\u003ca title=\"Laruence\" href=\"http://weibo.com/laruence\" target=\"_blank\"\u003e@Laruence\u003c/a\u003e 说这个是个经典的坑，我觉得这怎么会是经典的坑呢？上面这代码，你一定会问，为什么if语句判断的不是f.a？而是f.a里面的数组？写这样代码的人脑子里在想什么？还是用这样的代码来玩票？不管怎么样，看过原微博的回复，我个人觉得大家主要还是对C语言理解不深，如果这算坑的话，那么全都是坑。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11377\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e接下来，你调试一下，或是你把14行的printf语句改成：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eprintf(\u0026#34;%x\\n\u0026#34;, f.a-\u0026gt;s);\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e你会看到程序不crash了。程序输出：4。 这下你知道了，访问0x4的内存地址，不crash才怪。于是，你一定会有如下的问题：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e1）为什么不是 13行if语句出错？f.a被初始化为空了嘛，用空指针访问成员变量为什么不crash？\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e2）为什么会访问到了0x4的地址？靠，4是怎么出来的？\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e3）代码中的第4行，char s[0] 是个什么东西？零长度的数组？为什么要这样玩？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e让我们从基础开始一点一点地来解释C语言中这些诡异的问题。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98\" title=\"结构体中的成员\"\u003e结构体中的成员\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%AB\" title=\"指针和数组的差别\"\u003e指针和数组的差别\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%85%B3%E4%BA%8E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84\" title=\"关于零长度的数组\"\u003e关于零长度的数组\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E5%90%8E%E8%AE%B0\" title=\"后记\"\u003e后记\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98\"\u003e\u003c/span\u003e结构体中的成员\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e首先，我们需要知道——\u003cstrong\u003e所谓变量，其实是内存地址的一个抽像名字罢了\u003c/strong\u003e。在静态编译的程序中，所有的变量名都会在编译时被转成内存地址。机器是不知道我们取的名字的，只知道地址。\u003c/p\u003e\n\u003cp\u003e所以有了——栈内存区，堆内存区，静态内存区，常量内存区，我们代码中的所有变量都会被编译器预先放到这些内存区中。\u003c/p\u003e\n\u003cp\u003e有了上面这个基础，我们来看一下结构体中的成员的地址是什么？我们先简单化一下代码：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct test{\n    int i;\n    char *p;\n};\u003c/pre\u003e\n\u003cp\u003e上面代码中，test结构中i和p指针，在C的编译器中保存的是相对地址——也就是说，他们的地址是相对于struct test的实例的。如果我们有这样的代码：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct test t;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们用gdb跟进去，对于实例t，我们可以看到：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e# t实例中的p就是一个野指针\n(gdb) p t\n$1 = {i = 0, c = 0 \u0026#39;\\000\u0026#39;, d = 0 \u0026#39;\\000\u0026#39;, p = 0x4003e0 \u0026#34;1\\355I\\211\\...\u0026#34;}\n\n# 输出t的地址\n(gdb) p \u0026amp;t\n$2 = (struct test *) 0x7fffffffe5f0\n\n#输出(t.i)的地址\n(gdb) p \u0026amp;(t.i)\n$3 = (char **) 0x7fffffffe5f0\n\n#输出(t.p)的地址\n(gdb) p \u0026amp;(t.p)\n$4 = (char **) 0x7fffffffe5f4\u003c/pre\u003e\n\u003cp\u003e我们可以看到，t.i的地址和t的地址是一样的，t.p的址址相对于t的地址多了个4。说白了，\u003cstrong\u003et.i 其实就是(\u0026amp;t + 0x0)\u003c/strong\u003e, \u003cstrong\u003et.p 的其实就是 (\u0026amp;t + 0x4)\u003c/strong\u003e。0x0和0x4这个偏移地址就是成员i和p在编译时就被编译器给hard code了的地址。于是，你就知道，\u003cstrong\u003e不管结构体的实例是什么——访问其成员其实就是加成员的偏移量\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e下面我们来做个实验：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct test{\n    int i;\n    short c;\n    char *p;\n};\n\nint main(){\n    struct test *pt=NULL;\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e编译后，我们用gdb调试一下，当初始化pt后，我们看看如下的调试：（我们可以看到就算是pt为NULL，访问其中的成员时，其实就是在访问相对于pt的内址）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e(gdb) p pt\n$1 = (struct test *) 0x0\n(gdb) p pt-\u0026gt;i\nCannot access memory at address 0x0\n(gdb) p pt-\u0026gt;c\nCannot access memory at address 0x4\n(gdb) p pt-\u0026gt;p\nCannot access memory at address 0x8\u003c/pre\u003e\n\u003cp\u003e注意：上面的pt-\u0026gt;p的偏移之所以是0x8而不是0x6，是因为内存对齐了（我在64位系统上）。关于内存对齐，可参看《\u003ca title=\"深入理解C语言\" href=\"https://coolshell.cn/articles/5761.html\" target=\"_blank\" rel=\"bookmark\"\u003e深入理解C语言\u003c/a\u003e》一文。\u003c/p\u003e\n\u003cp\u003e好了，现在你知道为什么原题中会访问到了0x4的地址了吧，因为是相对地址。\u003c/p\u003e\n\u003cp\u003e相对地址有很好多处，其可以玩出一些有意思的编程技巧，比如把C搞出面向对象式的感觉来，你可以参看我正好11年前的文章《\u003ca href=\"http://blog.csdn.net/haoel/article/details/2864\" target=\"_blank\"\u003e用C写面向对像的程序\u003c/a\u003e》（用指针类型强转的危险玩法——相对于C++来说，C++编译器帮你管了继承和虚函数表，语义也清楚了很多）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%B7%AE%E5%88%AB\"\u003e\u003c/span\u003e指针和数组的差别\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e有了上面的基础后，你把源代码中的struct str结构体中的char s[0];改成char *s;试试看，你会发现，在13行if条件的时候，程序因为Cannot access memory就直接挂掉了。为什么声明成char s[0]，程序会在14行挂掉，而声明成char *s，程序会在13行挂掉呢？\u003cstrong\u003e那么char *s 和 char s[0]有什么差别呢\u003c/strong\u003e？\u003c/p\u003e\n\u003cp\u003e在说明这个事之前，有必要看一下汇编代码，用GDB查看后发现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于char s[0]来说，汇编代码用了lea指令，lea   0x04(%rax),   %rdx\u003c/li\u003e\n\u003cli\u003e对于char*s来说，汇编代码用了mov指令，mov 0x04(%rax),   %rdx\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003elea全称load effective address，是把地址放进去，而mov则是把地址里的内容放进去。所以，就crash了。\u003c/p\u003e\n\u003cp\u003e从这里，我们可以看到，\u003cstrong\u003e访问成员数组名其实得到的是数组的相对地址，而访问成员指针其实是相对地址里的内容\u003c/strong\u003e（这和访问其它非指针或数组的变量是一样的）\u003c/p\u003e\n\u003cp\u003e换句话说，\u003cstrong\u003e对于数组 char s[10]来说，数组名 s 和 \u0026amp;s 都是一样的\u003c/strong\u003e（不信你可以自己写个程序试试）。在我们这个例子中，也就是说，都表示了偏移后的地址。这样，如果我们访问 指针的地址（或是成员变量的地址），那么也就不会让程序挂掉了。\u003c/p\u003e\n\u003cp\u003e正如下面的代码，可以运行一点也不会crash掉（你汇编一下你会看到用的都是lea指令）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estruct test{\n    int i;\n    short c;\n    char *p;\n    char s[10];\n};\n\nint main(){\n    struct test *pt=NULL;\n    printf(\u0026#34;\u0026amp;s = %x\\n\u0026#34;, pt-\u0026gt;s); //等价于 printf(\u0026#34;%x\\n\u0026#34;, \u0026amp;(pt-\u0026gt;s) );\n    printf(\u0026#34;\u0026amp;i = %x\\n\u0026#34;, \u0026amp;pt-\u0026gt;i); //因为操作符优先级，我没有写成\u0026amp;(pt-\u0026gt;i)\n    printf(\u0026#34;\u0026amp;c = %x\\n\u0026#34;, \u0026amp;pt-\u0026gt;c);\n    printf(\u0026#34;\u0026amp;p = %x\\n\u0026#34;, \u0026amp;pt-\u0026gt;p);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e看到这里，你觉得这能算坑吗？不要出什么事都去怪语言，大家要想想是不是问题出在自己身上。\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B3%E4%BA%8E%E9%9B%B6%E9%95%BF%E5%BA%A6%E7%9A%84%E6%95%B0%E7%BB%84\"\u003e\u003c/span\u003e关于零长度的数组\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e首先，我们要知道，\u003cstrong\u003e0长度的数组在ISO C和C++的规格说明书中是不允许的\u003c/strong\u003e。这也就是为什么在VC++2012下编译你会得到一个警告：“arning C4200: 使用了非标准扩展 : 结构/联合中的零大小数组”。\u003c/p\u003e\n\u003cp\u003e那么为什么gcc可以通过而连一个警告都没有？那是因为gcc 为了预先支持C99的这种玩法，所以，让“零长度数组”这种玩法合法了。关于GCC对于这个事的文档在这里：“\u003ca title=\"Arrays of Length Zero\" href=\"http://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html\" target=\"_blank\"\u003eArrays of Length Zero\u003c/a\u003e”，文档中给了一个例子（我改了一下，改成可以运行的了）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n\nstruct line {\n   int length;\n   char contents[0]; // C99的玩法是：char contents[]; 没有指定数组长度\n};\n\nint main(){\n    int this_length=10;\n    struct line *thisline = (struct line *)\n                     malloc (sizeof (struct line) + this_length);\n    thisline-\u0026gt;length = this_length;\n    memset(thisline-\u0026gt;contents, \u0026#39;a\u0026#39;, this_length);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e上面这段代码的意思是：我想分配一个不定长的数组，于是我有一个结构体，其中有两个成员，一个是length，代表数组的长度，一个是contents，代码数组的内容。后面代码里的 this_length（长度是10）代表是我想分配的数据的长度。（这看上去是不是像一个C++的类？）这种玩法英文叫：Flexible Array，中文翻译叫：柔性数组。\u003c/p\u003e\n\u003cp\u003e我们来用gdb看一下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e(gdb) p thisline\n$1 = (struct line *) 0x601010\n\n(gdb) p *thisline\n$2 = {length = 10, contents = 0x601010 \u0026#34;\\n\u0026#34;}\n\n(gdb) p thisline-\u0026gt;contents\n$3 = 0x601014 \u0026#34;aaaaaaaaaa\u0026#34;\u003c/pre\u003e\n\u003cp\u003e我们可以看到：在输出*thisline时，我们发现其中的成员变量contents的地址居然和thisline是一样的（偏移量为0x0??!!）。但是当我们输出thisline-\u0026gt;contents的时候，你又发现contents的地址是被offset了0x4了的，内容也变成了10个‘a’。（我觉得这是一个GDB的bug，VC++的调试器就能很好的显示）\u003c/p\u003e\n\u003cp\u003e我们继续，如果你sizeof(char[0])或是 sizeof(int[0]) 之类的零长度数组，你会发现sizeof返回了0，这就是说，零长度的数组是存在于结构体内的，但是不占结构体的size。你可以简单的理解为一个没有内容的占位标识，直到我们给结构体分配了内存，这个占位标识才变成了一个有长度的数组。\u003c/p\u003e\n\u003cp\u003e看到这里，你会说，为什么要这样搞啊，把contents声明成一个指针，然后为它再分配一下内存不行么？就像下面一样。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"3,9\"\u003estruct line {\n   int length;\n   char *contents;\n};\n\nint main(){\n    int this_length=10;\n    struct line *thisline = (struct line *)malloc (sizeof (struct line));\n    thisline-\u0026gt;contents = (char*) malloc( sizeof(char) * this_length );\n    thisline-\u0026gt;length = this_length;\n    memset(thisline-\u0026gt;contents, \u0026#39;a\u0026#39;, this_length);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e这不一样清楚吗？而且也没什么怪异难懂的东西。是的，这也是普遍的编程方式，代码是很清晰，也让人很容易理解。即然这样，那为什么要搞一个零长度的数组？有毛意义？！\u003c/p\u003e\n\u003cp\u003e这个事情出来的原因是——\u003cstrong\u003e我们想给一个结构体内的数据分配一个连续的内存！\u003c/strong\u003e这样做的意义有两个好处：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e第一个意义是，方便内存释放\u003c/strong\u003e。如果我们的代码是在一个给别人用的函数中，你在里面做了二次内存分配，并把整个结构体返回给用户。用户调用free可以释放结构体，但是用户并不知道这个结构体内的成员也需要free，所以你不能指望用户来发现这个事。所以，如果我们把结构体的内存以及其成员要的内存一次性分配好了，并返回给用户一个结构体指针，用户做一次free就可以把所有的内存也给释放掉。（读到这里，你一定会觉得C++的封闭中的析构函数会让这事容易和干净很多）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e第二个原因是，这样有利于访问速度\u003c/strong\u003e。连续的内存有益于提高访问速度，也有益于减少内存碎片。（其实，我个人觉得也没多高了，反正你跑不了要用做偏移量的加法来寻址）\u003c/p\u003e\n\u003cp\u003e我们来看看是怎么个连续的，用gdb的x命令来查看：(我们知道，用struct line {}中的那个char contents[]不占用结构体的内存，所以，struct line就只有一个int成员，4个字节，而我们还要为contents[]分配10个字节长度，所以，一共是14个字节)\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e(gdb) x /14b thisline\n0x601010:       10      0       0       0       97      97      97      97\n0x601018:       97      97      97      97      97      97\u003c/pre\u003e\n\u003cp\u003e从上面的内存布局我们可以看到，前4个字节是 int length，后10个字节就是char contents[]。\u003c/p\u003e\n\u003cp\u003e如果用指针的话，会变成这个样子：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e(gdb) x /16b thisline\n0x601010:       1       0       0       0       0       0       0       0\n0x601018:       32      16      96      0       0       0       0       0\n(gdb) x /10b this-\u0026gt;contents\n0x601020:       97      97      97      97      97      97      97      97\n0x601028:       97      97\u003c/pre\u003e\n\u003cp\u003e上面一共输出了四行内存，其中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一行前四个字节是 int length，第一行的后四个字节是对齐。\u003c/li\u003e\n\u003cli\u003e第二行是char* contents，64位系统指针8个长度，他的值是0x20 0x10 0x60 也就是0x601020。\u003c/li\u003e\n\u003cli\u003e第三行和第四行是char* contents指向的内容。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e从这里，我们看到，\u003cstrong\u003e其中的差别——数组的原地就是内容，而指针的那里保存的是内容的地址\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%90%8E%E8%AE%B0\"\u003e\u003c/span\u003e后记\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e好了，我的文章到这里就结束了。但是，请允许我再唠叨两句。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e1）看过这篇文章，你觉得C复杂吗？我觉得并不简单。某些地方的复杂程度不亚于C++。\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e2）那些学不好C++的人一定是连C都学不好的人。连C都没学好，你们根本没有资格鄙视C++。\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e3）当你们在说有坑的时候，你得问一下自己，是真有坑还是自己的学习能力上出了问题。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e如果你觉得你的C语言还不错，欢迎你看看《\u003ca title=\"C语言的谜题\" href=\"https://coolshell.cn/articles/945.html\" target=\"_blank\"\u003eC语言的谜题\u003c/a\u003e》还有《\u003ca title=\"谁说C语言很简单？\" href=\"https://coolshell.cn/articles/873.html\" target=\"_blank\"\u003e谁说C语言很简单？\u003c/a\u003e》还有《\u003ca href=\"https://coolshell.cn/articles/830.html\" target=\"_blank\"\u003e语言的歧义\u003c/a\u003e》以及《\u003ca title=\"深入理解C语言\" href=\"https://coolshell.cn/articles/5761.html\" target=\"_blank\" rel=\"bookmark\"\u003e深入理解C语言\u003c/a\u003e》一文。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11235.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/10.jpg\" alt=\"一个浮点数跨平台产生的问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11235.html\" class=\"wp_rp_title\"\u003e一个浮点数跨平台产生的问题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/873.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/6.jpg\" alt=\"谁说C语言很简单？\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/873.html\" class=\"wp_rp_title\"\u003e谁说C语言很简单？\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/945.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/19.jpg\" alt=\"C语言的谜题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/945.html\" class=\"wp_rp_title\"\u003eC语言的谜题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/830.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/12.jpg\" alt=\"语言的歧义\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/830.html\" class=\"wp_rp_title\"\u003e语言的歧义\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/5761.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/9.jpg\" alt=\"深入理解C语言\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/5761.html\" class=\"wp_rp_title\"\u003e深入理解C语言\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9859.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-150x150.jpg\" alt=\"Alan Cox：单向链表中prev指针的妙用\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9859.html\" class=\"wp_rp_title\"\u003eAlan Cox：单向链表中prev指针的妙用\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11377\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"3907b6dc9c\"\u003e\u003cimg id=\"rating_11377_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11377, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.6, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-964a7398a65110688d14b445-=\"\"/\u003e\u003cimg id=\"rating_11377_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11377, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.6, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-964a7398a65110688d14b445-=\"\"/\u003e\u003cimg id=\"rating_11377_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11377, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.6, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-964a7398a65110688d14b445-=\"\"/\u003e\u003cimg id=\"rating_11377_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11377, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.6, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-964a7398a65110688d14b445-=\"\"/\u003e\u003cimg id=\"rating_11377_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11377, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.6, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-964a7398a65110688d14b445-=\"\"/\u003e (\u003cstrong\u003e110\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.63\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11377_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"C语言结构体里的成员数组和指针\"/\u003e\u003cmeta itemprop=\"headline\" content=\"C语言结构体里的成员数组和指针\"/\u003e\u003cmeta itemprop=\"description\" content=\"单看这文章的标题，你可能会觉得好像没什么意思。你先别下这个结论，相信这篇文章会对你理解C语言有帮助。这篇文章产生的背景是在微博上，看到@Laruence同学出了一个关于C语言的题，微博链接。微博截图如下。我觉得好多人对这段代码的理解还不够深入，所以写下了这篇文章。\n\n为了方便你把代码copy过去编译和调试，我把代码列在下面：\n\n[c]#include \u0026lt;stdio.h\u0026gt;\nstruct s...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-04-01T08:17:15+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2014-04-02T00:19:50+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11377.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11377.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.63\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"110\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11377-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-04-01T08:17:15+08:00",
  "Author": "陈皓"
}