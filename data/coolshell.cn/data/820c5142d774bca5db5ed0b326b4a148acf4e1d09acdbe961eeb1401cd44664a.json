{
  "Source": "coolshell.cn",
  "Title": "Cuckoo Filter：设计与实现",
  "Link": "https://coolshell.cn/articles/17225.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"beca78160ce3ccf83a235435-text/javascript\"\u003e\u003c/script\u003e\u003cstrong\u003e（感谢网友 \u003c/strong\u003e\u003ca href=\"http://weibo.com/fullofbull\" target=\"_blank\"\u003e\u003cstrong\u003e@我的上铺叫路遥\u003c/strong\u003e\u003c/a\u003e\u003cstrong\u003e 投稿）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"alignright wp-image-17243 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-300x164.jpg\" alt=\"\" width=\"300\" height=\"164\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-300x164.jpg 300w, https://coolshell.cn/wp-content/uploads/2015/08/cuckoo.jpg 400w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/p\u003e\n\u003cp\u003e对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回馈客户端给出警告。\u003c/p\u003e\n\u003cp\u003e索引的存储又分为有序和无序，前者使用关联式容器，比如B树，后者使用哈希算法。这两类算法各有优劣：比如，关联式容器时间复杂度稳定O(logN)，且支持范围查询；又比如哈希算法的查询、增删都比较快O(1)，但这是在理想状态下的情形，遇到碰撞严重的情况，哈希算法的时间复杂度会退化到O(n)。因此，选择一个好的哈希算法是很重要的。\u003c/p\u003e\n\u003cp\u003e时下一个非常流行的哈希索引结构就是\u003cstrong\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\"\u003ebloom filter\u003c/a\u003e\u003c/strong\u003e，它类似于bitmap这样的hashset，所以空间利用率很高。其独特的地方在于它使用多个哈希函数来避免哈希碰撞，如图所示（\u003ca href=\"https://en.wikipedia.org/wiki/Bloom_filter\" target=\"_blank\"\u003e来源wikipedia\u003c/a\u003e），bit数组初始化为全0，插入x时，x被3个哈希函数分别映射到3个不同的bit位上并置1，查询x时，只有被这3个函数映射到的bit位全部是1才能说明x可能存在，但凡至少出现一个0表示x肯定不存在。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-17242\" src=\"https://coolshell.cn/wp-content/uploads/2015/08/Bloom_filter.png\" alt=\"Bloom_filter\" width=\"649\" height=\"233\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/08/Bloom_filter.png 649w, https://coolshell.cn/wp-content/uploads/2015/08/Bloom_filter-300x108.png 300w\" sizes=\"(max-width: 649px) 100vw, 649px\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-17225\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e但是，bloom filter的这种位图模式带来两个问题：一个是\u003cstrong\u003e误报（false positives）\u003c/strong\u003e，在查询时能提供“一定不存在”，但只能提供“可能存在”，因为存在其它元素被映射到部分相同bit位上，导致该位置1，那么一个不存在的元素可能会被误报成存在；另一个是\u003cstrong\u003e漏报（false nagatives）\u003c/strong\u003e，同样道理，如果删除了某个元素，导致该映射bit位被置0，那么本来存在的元素会被漏报成不存在。由于后者问题严重得多，所以bloom filter必须确保“definitely no”从而容忍“probably yes”，不允许元素的删除。\u003c/p\u003e\n\u003cp\u003e关于元素删除的问题，一个改良方案是对bloom filter引入计数，但这样一来，原来每个bit空间就要扩张成一个计数值，空间效率上又降低了。\u003c/p\u003e\n\u003ch4\u003eCuckoo Hashing\u003c/h4\u003e\n\u003cp\u003e为了解决这一问题，本文引入了一种新的哈希算法——\u003cstrong\u003ecuckoo filter\u003c/strong\u003e，它既可以确保该元素存在的必然性，又可以在不违背此前提下删除任意元素，仅仅比bitmap牺牲了微量空间效率。先说明一下，这个算法的思想来源是一篇\u003ca href=\"http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf\" target=\"_blank\"\u003eCMU论文\u003c/a\u003e，笔者按照其思路用C语言做了一个简单实现（\u003ca href=\"https://github.com/begeekmyfriend/CuckooFilter\" target=\"_blank\"\u003eGithub\u003c/a\u003e），附上对一段文本数据进行导入导出的正确性测试。\u003c/p\u003e\n\u003cp\u003e接下来我会结合自己的示例代码讲解哈希算法的实现。我们先来看看cuckoo hashing有什么特点，它的哈希函数是成对的（具体的实现可以根据需求设计），每一个元素都是两个，分别映射到两个位置，一个是记录的位置，另一个是备用位置。这个备用位置是处理碰撞时用的，这就要说到cuckoo这个名词的典故了，中文名叫布谷鸟，这种鸟有一种即狡猾又贪婪的习性，它不肯自己筑巢，而是把蛋下到别的鸟巢里，而且它的幼鸟又会比别的鸟早出生，布谷幼鸟天生有一种残忍的动作，幼鸟会拼命把未出生的其它鸟蛋挤出窝巢，今后以便独享“养父母”的食物。借助生物学上这一典故，cuckoo hashing处理碰撞的方法，就是把原来占用位置的这个元素踢走，不过被踢出去的元素还要比鸟蛋幸运，因为它还有一个备用位置可以安置，如果备用位置上还有人，再把它踢走，如此往复。直到被踢的次数达到一个上限，才确认哈希表已满，并执行rehash操作。如下图所示（\u003ca href=\"http://codecapsule.com/2013/07/20/cuckoo-hashing/\" target=\"_blank\"\u003e图片来源\u003c/a\u003e）：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://codecapsule.com/2013/07/20/cuckoo-hashing/\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-17244\" src=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo_preview.jpg\" alt=\"cuckoo_preview\" width=\"720\" height=\"326\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo_preview.jpg 720w, https://coolshell.cn/wp-content/uploads/2015/08/cuckoo_preview-300x136.jpg 300w\" sizes=\"(max-width: 720px) 100vw, 720px\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e我们不禁要问发生哈希碰撞之前的空间利用率是多少呢？不幸地告诉你，一维数组的哈希表上跟其它哈希函数没什么区别，也就50%而已。但如果是二维的呢？\u003c/p\u003e\n\u003cp\u003e一个改进的哈希表如下图所示，每个桶（bucket）有4路槽位（slot）。当哈希函数映射到同一个bucket中，在其它三路slot未被填满之前，是不会有元素被踢的，这大大缓冲了碰撞的几率。笔者自己的简单实现上测过，采用二维哈希表（4路slot）大约80%的占用率（CMU论文数据据说达到90%以上，应该是扩大了slot关联数目所致）。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-17241\" src=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-hashing-1024x392.png\" alt=\"cuckoo hashing\" width=\"650\" height=\"249\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-hashing-1024x392.png 1024w, https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-hashing-300x115.png 300w, https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-hashing-900x344.png 900w, https://coolshell.cn/wp-content/uploads/2015/08/cuckoo-hashing.png 1143w\" sizes=\"(max-width: 650px) 100vw, 650px\"/\u003e\u003c/p\u003e\n\u003ch4\u003eCuckoo Filter设计与实现\u003c/h4\u003e\n\u003cp\u003ecuckoo hashing的原理介绍完了，下面就来演示一下笔者自己实现的一个cuckoo filter应用，简单易用为主，不到500行C代码。应用场景是这样的：假设有一段文本数据，我们把它通过cuckoo filter导入到一个虚拟的flash中，再把它导出到另一个文本文件中。flash存储的单元页面是一个log_entry，里面包含了一对key/value，value就是文本数据，key就是这段大小的数据的SHA1值（照理说SHA1是可以通过数据源生成，没必要存储到flash，但这里主要为了测试而故意设计的，万一key和value之间没有推导关系呢）。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#define SECTOR_SIZE    (1 \u0026lt;\u0026lt; 10)\n#define DAT_LEN        (SECTOR_SIZE - 20)  /* minus sha1 size */\n\n/* The log entries store key-value pairs on flash and the\n * size of each entry is assumed just one sector fit.\n */\nstruct log_entry {\n        uint8_t sha1[20];\n        uint8_t data[DAT_LEN];\n};\n\u003c/pre\u003e\n\u003cp\u003e顺便说明一下DAT_LEN设置，之前我们设计了一个虚拟flash（用malloc模拟出来），由于flash的单位是按页大小SECTOR_SIZE读写，这里假设每个log_entry正好一个页大小，当然可以根据实际情况调整。\u003c/p\u003e\n\u003cp\u003e以上是flash的存储结构，至于哈希表里的slot有三个成员tag，status和offset，分别是哈希值，状态值和在flash的偏移位置。其中status有三个枚举值：AVAILIBLE，OCCUPIED，DELETED，分别表示这个slot是空闲的，占用的还是被删除的。至于tag，按理说应该有两个哈希值，对应两个哈希函数，但其中一个已经对应bucket的位置上了，所以我们只要保存另一个备用bucket的位置就行了，这样万一被踢，只要用这个tag就可以找到它的另一个安身之所。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eenum { AVAILIBLE, OCCUPIED, DELETED, };\n\n/* The in-memory hash bucket cache is to filter keys (which is assumed SHA1) via\n * cuckoo hashing function and map keys to log entries stored on flash.\n */\nstruct hash_slot_cache {\n        uint32_t tag : 30;  /* summary of key */\n        uint32_t status : 2;  /* FSM */\n        uint32_t offset;  /* offset on flash memory */\n};\n\u003c/pre\u003e\n\u003cp\u003e乍看之下size有点大是吗？没关系，你也可以根据情况调整数据类型大小，比如uint16_t，这里仅仅为了测试正确性。\u003c/p\u003e\n\u003cp\u003e至于哈希表以及bucket和slot的创建见初始化代码。buckets是一个二级指针，每个bucket指向4个slot大小的缓存，即4路slot，那么bucket_num也就是slot_num的1/4。这里我们故意把slot_num调小了点，为的是测试rehash的发生。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#define ASSOC_WAY  (4)  /* 4-way association */\n\nstruct hash_table {\n    struct hash_slot_cache **buckets;\n    struct hash_slot_cache *slots;\n    uint32_t slot_num;\n    uint32_t bucket_num;\n};\n\nint cuckoo_filter_init(size_t size)\n{\n    ...\n    /* Allocate hash slots */\n    hash_table.slot_num = nvrom_size / SECTOR_SIZE;\n    /* Make rehashing happen */\n    hash_table.slot_num /= 4;\n    hash_table.slots = calloc(hash_table.slot_num, sizeof(struct hash_slot_cache));\n    if (hash_table.slots == NULL) {\n        return -1;\n    }\n\n    /* Allocate hash buckets associated with slots */\n    hash_table.bucket_num = hash_table.slot_num / ASSOC_WAY;\n    hash_table.buckets = malloc(hash_table.bucket_num * sizeof(struct hash_slot_cache *));\n    if (hash_table.buckets == NULL) {\n        free(hash_table.slots);\n        return -1;\n    }\n    for (i = 0; i \u0026lt; hash_table.bucket_num; i++) {\n        hash_table.buckets[i] = \u0026amp;hash_table.slots[i * ASSOC_WAY];\n    }\n}\n\u003c/pre\u003e\n\u003cp\u003e下面是哈希函数的设计，这里有两个，前面提到既然key是20字节的SHA1值，我们就可以分别是对key的低32位和高32位进行位运算，只要bucket_num满足2的幂次方，我们就可以将key的一部分同bucket_num – 1相与，就可以定位到相应的bucket位置上，注意bucket_num随着rehash而增大，哈希函数简单的好处是求哈希值十分快。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#define cuckoo_hash_lsb(key, count)  (((size_t *)(key))[0] \u0026amp; (count - 1))\n#define cuckoo_hash_msb(key, count)  (((size_t *)(key))[1] \u0026amp; (count - 1))\n\u003c/pre\u003e\n\u003cp\u003e终于要讲解cuckoo filter最重要的三个操作了——查询、插入还有删除。查询操作是简单的，我们对传进来的参数key进行两次哈希求值tag[0]和tag[1]，并先用tag[0]定位到bucket的位置，从4路slot中再去对比tag[1]。只有比中了tag后，由于只是key的一部分，我们再去从flash中验证完整的key，并把数据在flash中的偏移值read_addr输出返回。相应的，如果bucket[tag[0]]的4路slot都没有比中，我们再去bucket[tag[1]]中比对（代码略），如果还比不中，可以肯定这个key不存在。\u003cstrong\u003e这种设计的好处就是减少了不必要的flash读操作，每次比对的是内存中的tag而不需要完整的key。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic int cuckoo_hash_get(struct hash_table *table, uint8_t *key, uint8_t **read_addr)\n{\n    int i, j;\n    uint8_t *addr;\n    uint32_t tag[2], offset;\n    struct hash_slot_cache *slot;\n\n    tag[0] = cuckoo_hash_lsb(key, table-\u0026gt;bucket_num);\n    tag[1] = cuckoo_hash_msb(key, table-\u0026gt;bucket_num);\n\n    /* Filter the key and verify if it exists. */\n    slot = table-\u0026amp;gt;buckets[tag[0]];\n    for (i = 0; i bucket_num) == slot[i].tag) {\n        if (slot[i].status == OCCUPIED) {\n            offset = slot[i].offset;\n            addr = key_verify(key, offset);\n            if (addr != NULL) {\n                if (read_addr != NULL) {\n                    *read_addr = addr;\n                }\n                break;\n            }\n        } else if (slot[i].status == DELETED) {\n            return DELETED;\n        }\n    }\n    ...\n}\u003c/pre\u003e\n\u003cp\u003e接下来先将简单的删除操作，之所以简单是因为delete除了将相应slot的状态值设置一下之外，其实什么都没有干，也就是说它不会真正到flash里面去把数据清除掉。为什么？很简单，没有必要。还有一个原因，flash的写操作之前需要擦除整个页面，这种擦除是会折寿的，\u003cstrong\u003e所以很多flash支持随机读，但必须保持顺序写。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic void cuckoo_hash_delete(struct hash_table *table, uint8_t *key)\n{\n    uint32_t i, j, tag[2];\n    struct hash_slot_cache *slot;\n\n    tag[0] = cuckoo_hash_lsb(key, table-\u0026gt;bucket_num);\n    tag[1] = cuckoo_hash_msb(key, table-\u0026gt;bucket_num);\n\n    slot = table-\u0026gt;buckets[tag[0]];\n    for (i = 0; i bucket_num) == slot[i].tag) {\n        slot[i].status = DELETED;\n        return;\n    }\n    ...\n}\u003c/pre\u003e\n\u003cp\u003e了解了flash的读写特性，你就知道为啥插入操作在flash层面要设计成append。不过我们这里不讨论过多flash细节，哈希表层面的插入逻辑其实跟查询差不多，我就不贴代码了。这里要贴的是如何判断并处理碰撞，其实这里也没啥玄机，就是用old_tag和old_offset保存一下临时变量，以便一个元素被踢出去之后还能找到备用的安身之所。但这里会有一个判断，每次踢人都会计数，当alt_cnt大于512时候表示哈希表真的快满了，这时候需要rehash了。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic int cuckoo_hash_collide(struct hash_table *table, uint32_t *tag, uint32_t *p_offset)\n{\n    int i, j, k, alt_cnt;\n    uint32_t old_tag[2], offset, old_offset;\n    struct hash_slot_cache *slot;\n\n    /* Kick out the old bucket and move it to the alternative bucket. */\n    offset = *p_offset;\n    slot = table-\u0026gt;buckets[tag[0]];\n    old_tag[0] = tag[0];\n    old_tag[1] = slot[0].tag;\n    old_offset = slot[0].offset;\n    slot[0].tag = tag[1];\n    slot[0].offset = offset;\n    i = 0 ^ 1;\n    k = 0;\n    alt_cnt = 0;\n\nKICK_OUT:\n    slot = table-\u0026gt;buckets[old_tag[i]];\n    for (j = 0; j \u0026lt; ASSOC_WAY; j++) {\n        if (offset == INVALID_OFFSET \u0026amp;\u0026amp; slot[j].status == DELETED) {\n            slot[j].status = OCCUPIED;\n            slot[j].tag = old_tag[i ^ 1];\n            *p_offset = offset = slot[j].offset;\n            break;\n        } else if (slot[j].status == AVAILIBLE) {\n            slot[j].status = OCCUPIED;\n            slot[j].tag = old_tag[i ^ 1];\n            slot[j].offset = old_offset;\n            break;\n        }\n    }\n\n    if (j == ASSOC_WAY) {\n        if (++alt_cnt \u0026gt; 512) {\n            if (k == ASSOC_WAY - 1) {\n                /* Hash table is almost full and needs to be resized */\n                return 1;\n            } else {\n                k++;\n            }\n        }\n        uint32_t tmp_tag = slot[k].tag;\n        uint32_t tmp_offset = slot[k].offset;\n        slot[k].tag = old_tag[i ^ 1];\n        slot[k].offset = old_offset;\n        old_tag[i ^ 1] = tmp_tag;\n        old_offset = tmp_offset;\n        i ^= 1;\n        goto KICK_OUT;\n    }\n\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003erehash的逻辑也很简单，无非就是把哈希表中的buckets和slots重新realloc一下，空间扩展一倍，然后再从flash中的key重新插入到新的哈希表里去。这里有个陷阱要注意，\u003cstrong\u003e千万不能有相同的key混进来！\u003c/strong\u003e虽然cuckoo hashing不像开链法那样会退化成O(n)，但由于每个元素有两个哈希值，而且每次计算的哈希值随着哈希表rehash的规模而不同，相同的key并不能立即检测到冲突，但当相同的key达到一定规模后，噩梦就开始了，由于rehash里面有插入操作，一旦在这里触发碰撞，又会触发rehash，这时就是一个rehash不断递归的过程，由于其中老的内存没释放，新的内存不断重新分配，整个程序就如同陷入DoS攻击一般瘫痪了。\u003cstrong\u003e所以每次插入操作前一定要判断一下key是否已经存在过，并且对rehash里的插入使用碰撞断言防止此类情况发生。\u003c/strong\u003e笔者在测试中不幸中了这样的彩蛋，调试了大半天才搞清楚原因，搞IT的同学们记住一定要防小人啊~\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003estatic void cuckoo_rehash(struct hash_table *table)\n{\n    ...\n    uint8_t *read_addr = nvrom_base_addr;\n    uint32_t entries = log_entries;\n    while (entries--) {\n        uint8_t key[20];\n        uint32_t offset = read_addr - nvrom_base_addr;\n        for (i = 0; i \u0026amp;lt; 20; i++) {\n            key[i] = flash_read(read_addr);\n            read_addr++;\n        }\n        /* Duplicated keys in hash table which can cause eternal\n         * hashing collision! Be careful of that!\n         */\n        assert(!cuckoo_hash_put(table, key, \u0026amp;offset));\n        if (cuckoo_hash_get(\u0026amp;old_table, key, NULL) == DELETED) {\n            cuckoo_hash_delete(table, key);\n        }\n        read_addr += DAT_LEN;\n    }\n    ...\n}\u003c/pre\u003e\n\u003cp\u003e到此为止代码的逻辑还是比较简单，使用效果如何呢？我来帮你找个大文件\u003ca href=\"https://github.com/unqlite/unqlite/blob/master/unqlite.c\" target=\"_blank\"\u003eunqlite.c\u003c/a\u003e测试一下，这是一个嵌入式数据库源代码，共59959行代码。作为需要导入的文件，编译我们的cuckoo filter，然后执行：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e./cuckoo_db unqlite.c output.c\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e你会发现生成output.c正好也是59959行代码，一分不差，probably yes终于变成了definitely yes。同时也可以看到，cuckoo filter真的很快！如果你想看hashing的整个过程，可以参照\u003ca href=\"https://github.com/begeekmyfriend/CuckooFilter/blob/master/README.md\" target=\"_blank\"\u003eREADME\u003c/a\u003e里把调试宏打开。最后，欢迎给\u003ca href=\"https://github.com/begeekmyfriend/CuckooFilter\" target=\"_blank\"\u003e这个小玩意\u003c/a\u003e提交PR！\u003c/p\u003e\n\u003ch4\u003e参考资料\u003c/h4\u003e\n\u003cp\u003eCuckoo Filter的\u003ca href=\"http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pdf\" target=\"_blank\"\u003e论文\u003c/a\u003e和\u003ca href=\"http://www.cs.cmu.edu/~binfan/papers/conext14_cuckoofilter.pptx\" target=\"_blank\"\u003ePPT\u003c/a\u003e：Cuckoo Filter: Practically Better Than Bloom\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg\" alt=\"Leetcode 编程训练\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_title\"\u003eLeetcode 编程训练\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11847.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/08/puzzle-150x150.png\" alt=\"谜题的答案和活动的心得体会\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11847.html\" class=\"wp_rp_title\"\u003e谜题的答案和活动的心得体会\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11832.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/08/538efefbgw1eiz9cvx78fj20rm0fmdi8-150x150.jpg\" alt=\"【活动】解迷题送礼物\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11832.html\" class=\"wp_rp_title\"\u003e【活动】解迷题送礼物\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/10590.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/10/QR-Code-Overview-150x150.jpeg\" alt=\"二维码的生成细节和原理\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/10590.html\" class=\"wp_rp_title\"\u003e二维码的生成细节和原理\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/10427.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/10/buddy-memory-allocation-150x150.jpg\" alt=\"伙伴分配器的一个极简实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/10427.html\" class=\"wp_rp_title\"\u003e伙伴分配器的一个极简实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9886.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/8.jpg\" alt=\"二叉树迭代器算法\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9886.html\" class=\"wp_rp_title\"\u003e二叉树迭代器算法\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-17225\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"736d415df1\"\u003e\u003cimg id=\"rating_17225_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17225, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-beca78160ce3ccf83a235435-=\"\"/\u003e\u003cimg id=\"rating_17225_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17225, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-beca78160ce3ccf83a235435-=\"\"/\u003e\u003cimg id=\"rating_17225_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17225, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-beca78160ce3ccf83a235435-=\"\"/\u003e\u003cimg id=\"rating_17225_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17225, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-beca78160ce3ccf83a235435-=\"\"/\u003e\u003cimg id=\"rating_17225_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17225, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-beca78160ce3ccf83a235435-=\"\"/\u003e (\u003cstrong\u003e52\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.13\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_17225_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Cuckoo Filter：设计与实现\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Cuckoo Filter：设计与实现\"/\u003e\u003cmeta itemprop=\"description\" content=\"（感谢网友 @我的上铺叫路遥 投稿）\n\n\n\n对于海量数据处理业务，我们通常需要一个索引数据结构，用来帮助查询，快速判断数据记录是否存在，这种数据结构通常又叫过滤器(filter)。考虑这样一个场景，上网的时候需要在浏览器上输入URL，这时浏览器需要去判断这是否一个恶意的网站，它将对本地缓存的成千上万的URL索引进行过滤，如果不存在，就放行，如果（可能）存在，则向远程服务端发起验证请求，并回...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2015-09-02T09:18:54+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2015-09-02T11:20:38+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/17225.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"Leo\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/17225.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.13\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"52\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-17225-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2015-09-02T09:18:54+08:00",
  "Author": "Leo"
}