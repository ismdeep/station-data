{
  "Source": "coolshell.cn",
  "Title": "到处都是Unix的胎记",
  "Link": "https://coolshell.cn/articles/1532.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"0e8c6ac189a7041635c01228-text/javascript\"\u003e\u003c/script\u003e一说起Unix编程，不必多说，最著名的系统调用就是fork，pipe，exec，kill或是socket了（\u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html\"\u003e\u003ccode\u003efork(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html\"\u003e\u003ccode\u003eexecve(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/pipe.2.html\"\u003e\u003ccode\u003epipe(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/socketpair.2.html\"\u003e\u003ccode\u003esocketpair(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html\"\u003e\u003ccode\u003eselect(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html\"\u003e\u003ccode\u003ekill(2)\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html\"\u003e\u003ccode\u003esigaction(2)\u003c/code\u003e\u003c/a\u003e）这些系统调用都像是Unix编程的胎记或签名一样，表明着它来自于Unix。\u003c/p\u003e\n\u003cp\u003e下面这篇文章，将向大家展示Unix下最经典的socket的编程例子——使用fork + socket来创建一个TCP/IP的服务程序。这个编程模式很简单，首先是创建Socket，然后把其绑定在某个IP和Port上上侦听连接，接下来的一般做法是使用一个fork创建一个client服务进程再加上一个死循环用于处理和client的交互。这个模式是Unix下最经典的Socket编程例子。\u003c/p\u003e\n\u003cp\u003e下面，让我们看看用C，Ruby，Python，Perl，PHP和Haskell来实现这一例子，你会发现这些例子中的Unix的胎记。如果你想知道这些例子中的技术细节，那么，向你推荐两本经典书——《Unix高级环境编程》和《Unix网络编程》。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-1532\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#C%E8%AF%AD%E8%A8%80\" title=\"C语言\"\u003eC语言\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Ruby\" title=\"Ruby\"\u003eRuby\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Python\" title=\"Python\"\u003ePython\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Perl\" title=\"Perl\"\u003ePerl\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#PHP\" title=\"PHP\"\u003ePHP\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Haskell\" title=\"Haskell\"\u003eHaskell\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"C%E8%AF%AD%E8%A8%80\"\u003e\u003c/span\u003eC语言\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们先来看一下经典的C是怎么实现的。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e/**\n * A simple preforking echo server in C.\n *\n * Building:\n *\n * $ gcc -Wall -o echo echo.c\n *\n * Usage:\n *\n * $ ./echo\n *\n *   ~ then in another terminal ... ~\n *\n * $ echo \u0026#39;Hello, world!\u0026#39; | nc localhost 4242\n *\n */\n\n#include \u0026lt;unistd.h\u0026gt; /* fork, close */\n#include \u0026lt;stdlib.h\u0026gt; /* exit */\n#include \u0026lt;string.h\u0026gt; /* strlen */\n#include \u0026lt;stdio.h\u0026gt; /* perror, fdopen, fgets */\n#include \u0026lt;sys/socket.h\u0026gt;\n#include \u0026lt;sys/wait.h\u0026gt; /* waitpid */\n#include \u0026lt;netdb.h\u0026gt; /* getaddrinfo */\n\n#define die(msg) do { perror(msg); exit(EXIT_FAILURE); } while (0)\n\n#define PORT \u0026#34;4242\u0026#34;\n#define NUM_CHILDREN 3\n\n#define MAXLEN 1024\n\nint readline(int fd, char *buf, int maxlen); // forward declaration\n\nint\nmain(int argc, char** argv)\n{\n    int i, n, sockfd, clientfd;\n    int yes = 1; // used in setsockopt(2)\n    struct addrinfo *ai;\n    struct sockaddr_in *client;\n    socklen_t client_t;\n    pid_t cpid; // child pid\n    char line[MAXLEN];\n    char cpid_s[32];\n    char welcome[32];\n\n    /* Create a socket and get its file descriptor -- socket(2) */\n    sockfd = socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd == -1) {\n    die(\u0026#34;Couldn\u0026#39;t create a socket\u0026#34;);\n    }\n\n    /* Prevents those dreaded \u0026#34;Address already in use\u0026#34; errors */\n    if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const void *)\u0026amp;yes, sizeof(int)) == -1) {\n    die(\u0026#34;Couldn\u0026#39;t setsockopt\u0026#34;);\n    }\n\n    /* Fill the address info struct (host + port) -- getaddrinfo(3) */\n    if (getaddrinfo(NULL, PORT, NULL, \u0026amp;ai) != 0) {\n    die(\u0026#34;Couldn\u0026#39;t get address\u0026#34;);\n    }\n\n    /* Assign address to this socket\u0026#39;s fd */\n    if (bind(sockfd, ai-\u0026gt;ai_addr, ai-\u0026gt;ai_addrlen) != 0) {\n    die(\u0026#34;Couldn\u0026#39;t bind socket to address\u0026#34;);\n    }\n\n    /* Free the memory used by our address info struct */\n    freeaddrinfo(ai);\n\n    /* Mark this socket as able to accept incoming connections */\n    if (listen(sockfd, 10) == -1) {\n    die(\u0026#34;Couldn\u0026#39;t make socket listen\u0026#34;);\n    }\n\n    /* Fork you some child processes. */\n    for (i = 0; i \u0026lt; NUM_CHILDREN; i++) {\n    cpid = fork();\n    if (cpid == -1) {\n        die(\u0026#34;Couldn\u0026#39;t fork\u0026#34;);\n    }\n\n    if (cpid == 0) { // We\u0026#39;re in the child ...\n        for (;;) { // Run forever ...\n        /* Necessary initialization for accept(2) */\n        client_t = sizeof client;\n\n        /* Blocks! */\n        clientfd = accept(sockfd, (struct sockaddr *)\u0026amp;client, \u0026amp;client_t);\n        if (clientfd == -1) {\n            die(\u0026#34;Couldn\u0026#39;t accept a connection\u0026#34;);\n        }\n\n        /* Send a welcome message/prompt */\n        bzero(cpid_s, 32);\n        bzero(welcome, 32);\n        sprintf(cpid_s, \u0026#34;%d\u0026#34;, getpid());\n        sprintf(welcome, \u0026#34;Child %s echo\u0026gt; \u0026#34;, cpid_s);\n        send(clientfd, welcome, strlen(welcome), 0);\n\n        /* Read a line from the client socket ... */\n        n = readline(clientfd, line, MAXLEN);\n        if (n == -1) {\n            die(\u0026#34;Couldn\u0026#39;t read line from connection\u0026#34;);\n        }\n\n        /* ... and echo it back */\n        send(clientfd, line, n, 0);\n\n        /* Clean up the client socket */\n        close(clientfd);\n        }\n    }\n    }\n\n    /* Sit back and wait for all child processes to exit */\n    while (waitpid(-1, NULL, 0) \u0026gt; 0);\n\n    /* Close up our socket */\n    close(sockfd);\n\n    return 0;\n}\n\n/**\n * Simple utility function that reads a line from a file descriptor fd,\n * up to maxlen bytes -- ripped from Unix Network Programming, Stevens.\n */\nint\nreadline(int fd, char *buf, int maxlen)\n{\n    int n, rc;\n    char c;\n\n    for (n = 1; n \u0026lt; maxlen; n++) {\n    if ((rc = read(fd, \u0026amp;c, 1)) == 1) {\n        *buf++ = c;\n        if (c == \u0026#39;\\n\u0026#39;)\n        break;\n    } else if (rc == 0) {\n        if (n == 1)\n        return 0; // EOF, no data read\n        else\n        break; // EOF, read some data\n    } else\n        return -1; // error\n    }\n\n    *buf = \u0026#39;\\0\u0026#39;; // null-terminate\n    return n;\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Ruby\"\u003e\u003c/span\u003eRuby\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是Ruby，你可以看到其中的fork\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"ruby\"\u003e# simple preforking echo server in Ruby\nrequire \u0026#39;socket\u0026#39;\n\n# Create a socket, bind it to localhost:4242, and start listening.\n# Runs once in the parent; all forked children inherit the socket\u0026#39;s\n# file descriptor.\nacceptor = Socket.new(Socket::AF_INET, Socket::SOCK_STREAM, 0)\naddress = Socket.pack_sockaddr_in(4242, \u0026#39;localhost\u0026#39;)\nacceptor.bind(address)\nacceptor.listen(10)\n\n# Close the socket when we exit the parent or any child process. This\n# only closes the file descriptor in the calling process, it does not\n# take the socket out of the listening state (until the last fd is\n# closed).\n#\n# The trap is guaranteed to happen, and guaranteed to happen only\n# once, right before the process exits for any reason (unless\n# it\u0026#39;s terminated with a SIGKILL).\ntrap(\u0026#39;EXIT\u0026#39;) { acceptor.close }\n\n# Fork you some child processes. In the parent, the call to fork\n# returns immediately with the pid of the child process; fork never\n# returns in the child because we exit at the end of the block.\n3.times do\n  fork do\n    # now we\u0026#39;re in the child process; trap (Ctrl-C) interrupts and\n    # exit immediately instead of dumping stack to stderr.\n    trap(\u0026#39;INT\u0026#39;) { exit }\n\n    puts \u0026#34;child #$$ accepting on shared socket (localhost:4242)\u0026#34;\n    loop {\n      # This is where the magic happens. accept(2) blocks until a\n      # new connection is ready to be dequeued.\n      socket, addr = acceptor.accept\n      socket.write \u0026#34;child #$$ echo\u0026gt; \u0026#34;\n      socket.flush\n      message = socket.gets\n      socket.write message\n      socket.close\n      puts \u0026#34;child #$$ echo\u0026#39;d: \u0026#39;#{message.strip}\u0026#39;\u0026#34;\n    }\n    exit\n  end\nend\n\n# Trap (Ctrl-C) interrupts, write a note, and exit immediately\n# in parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntrap(\u0026#39;INT\u0026#39;) { puts \u0026#34;\\nbailing\u0026#34; ; exit }\n\n# Sit back and wait for all child processes to exit.\nProcess.waitall\n\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Python\"\u003e\u003c/span\u003ePython\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e\u0026#34;\u0026#34;\u0026#34;\nSimple preforking echo server in Python.\n\u0026#34;\u0026#34;\u0026#34;\n\nimport os\nimport sys\nimport socket\n\n# Create a socket, bind it to localhost:4242, and start\n# listening. Runs once in the parent; all forked children\n# inherit the socket\u0026#39;s file descriptor.\nacceptor = socket.socket()\nacceptor.bind((\u0026#39;localhost\u0026#39;, 4242))\nacceptor.listen(10)\n\n# Ryan\u0026#39;s Ruby code here traps EXIT and closes the socket. This\n# isn\u0026#39;t required in Python; the socket will be closed when the\n# socket object gets garbage collected.\n\n# Fork you some child processes. In the parent, the call to\n# fork returns immediately with the pid of the child process;\n# fork never returns in the child because we exit at the end\n# of the block.\nfor i in range(3):\n    pid = os.fork()\n\n    # os.fork() returns 0 in the child process and the child\u0026#39;s\n    # process id in the parent. So if pid == 0 then we\u0026#39;re in\n    # the child process.\n    if pid == 0:\n        # now we\u0026#39;re in the child process; trap (Ctrl-C)\n        # interrupts by catching KeyboardInterrupt) and exit\n        # immediately instead of dumping stack to stderr.\n        childpid = os.getpid()\n        print \u0026#34;Child %s listening on localhost:4242\u0026#34; % childpid\n        try:\n            while 1:\n                # This is where the magic happens. accept(2)\n                # blocks until a new connection is ready to be\n                # dequeued.\n                conn, addr = acceptor.accept()\n\n                # For easier use, turn the socket connection\n                # into a file-like object.\n                flo = conn.makefile()\n                flo.write(\u0026#39;Child %s echo\u0026gt; \u0026#39; % childpid)\n                flo.flush()\n                message = flo.readline()\n                flo.write(message)\n                flo.close()\n                conn.close()\n                print \u0026#34;Child %s echo\u0026#39;d: %r\u0026#34; % \\\n                          (childpid, message.strip())\n        except KeyboardInterrupt:\n            sys.exit()\n\n# Sit back and wait for all child processes to exit.\n#\n# Trap interrupts, write a note, and exit immediately in\n# parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntry:\n    os.waitpid(-1, 0)\nexcept KeyboardInterrupt:\n    print \u0026#34;\\nbailing\u0026#34;\n    sys.exit()\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Perl\"\u003e\u003c/span\u003ePerl\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"perl\"\u003e#!/usr/bin/perl\nuse 5.010;\nuse strict;\n\n# simple preforking echo server in Perl\nuse Proc::Fork;\nuse IO::Socket::INET;\n\nsub strip { s/\\A\\s+//, s/\\s+\\z// for my @r = @_; @r }\n\n# Create a socket, bind it to localhost:4242, and start listening.\n# Runs once in the parent; all forked children inherit the socket\u0026#39;s\n# file descriptor.\nmy $acceptor = IO::Socket::INET-\u0026gt;new(\n    LocalPort =\u0026gt; 4242,\n    Reuse     =\u0026gt; 1,\n    Listen    =\u0026gt; 10,\n) or die \u0026#34;Couln\u0026#39;t start server: $!\\n\u0026#34;;\n\n# Close the socket when we exit the parent or any child process. This\n# only closes the file descriptor in the calling process, it does not\n# take the socket out of the listening state (until the last fd is\n# closed).\nEND { $acceptor-\u0026gt;close }\n\n# Fork you some child processes. The code after the run_fork block runs\n# in all process, but because the child block ends in an exit call, only\n# the parent executes the rest of the program. If a parent block were\n# specified here, it would be invoked in the parent only, and passed the\n# PID of the child process.\nfor ( 1 .. 3 ) {\n    run_fork { child {\n        while (1) {\n            my $socket = $acceptor-\u0026gt;accept;\n            $socket-\u0026gt;printflush( \u0026#34;child $$ echo\u0026gt; \u0026#34; );\n            my $message = $socket-\u0026gt;getline;\n            $socket-\u0026gt;print( $message );\n            $socket-\u0026gt;close;\n            say \u0026#34;child $$ echo\u0026#39;d: \u0026#39;${\\strip $message}\u0026#39;\u0026#34;;\n        }\n        exit;\n    } }\n}\n\n# Trap (Ctrl-C) interrupts, write a note, and exit immediately\n# in parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\n$SIG{ \u0026#39;INT\u0026#39; } = sub { print \u0026#34;bailing\\n\u0026#34;; exit };\n\n# Sit back and wait for all child processes to exit.\n1 while 0 \u0026lt; waitpid -1, 0;\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"PHP\"\u003e\u003c/span\u003ePHP\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"perl\"\u003e\u0026lt;?\n/*\nSimple preforking echo server in PHP.\nRussell Beattie (russellbeattie.com)\n*/\n\n/* Allow the script to hang around waiting for connections. */\nset_time_limit(0);\n\n# Create a socket, bind it to localhost:4242, and start\n# listening. Runs once in the parent; all forked children\n# inherit the socket\u0026#39;s file descriptor.\n$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);\nsocket_bind($socket,\u0026#39;localhost\u0026#39;, 4242);\nsocket_listen($socket, 10);\n\npcntl_signal(SIGTERM, \u0026#39;shutdown\u0026#39;);\npcntl_signal(SIGINT, \u0026#39;shutdown\u0026#39;);\n\nfunction shutdown($signal){\n    global $socket;\n    socket_close($socket);\n    exit();\n}\n# Fork you some child processes. In the parent, the call to\n# fork returns immediately with the pid of the child process;\n# fork never returns in the child because we exit at the end\n# of the block.\nfor($x = 1; $x \u0026lt;= 3; $x++){\n   \n    $pid = pcntl_fork();\n   \n    # pcntl_fork() returns 0 in the child process and the child\u0026#39;s\n    # process id in the parent. So if $pid == 0 then we\u0026#39;re in\n    # the child process.\n    if($pid == 0){\n\n        $childpid = posix_getpid();\n       \n        echo \u0026#34;Child $childpid listening on localhost:4242 \\n\u0026#34;;\n\n        while(true){\n            # This is where the magic happens. accept(2)\n            # blocks until a new connection is ready to be\n            # dequeued.\n            $conn = socket_accept($socket);\n\n            $message = socket_read($conn,1000,PHP_NORMAL_READ);\n           \n            socket_write($conn, \u0026#34;Child $childpid echo\u0026gt; $message\u0026#34;);\n       \n            socket_close($conn);\n       \n            echo \u0026#34;Child $childpid echo\u0026#39;d: $message \\n\u0026#34;;\n       \n        }\n\n    }\n}\n#\n# Trap interrupts, write a note, and exit immediately in\n# parent. This trap is not inherited by the forks because it\n# runs after forking has commenced.\ntry{\n\n    pcntl_waitpid(-1, $status);\n\n} catch (Exception $e) {\n\n    echo \u0026#34;bailing \\n\u0026#34;;\n    exit();\n\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Haskell\"\u003e\u003c/span\u003eHaskell\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"haskell\"\u003eimport Network\nimport Prelude hiding ((-))\nimport Control.Monad\nimport System.IO\nimport Control.Applicative\nimport System.Posix\nimport System.Exit\nimport System.Posix.Signals\n\nmain :: IO ()\nmain = with =\u0026lt;\u0026lt; (listenOn - PortNumber 4242) where\n\n  with socket = do\n    replicateM 3 - forkProcess work\n    wait\n\n    where\n    work = do\n      installHandler sigINT (Catch trap_int) Nothing\n      pid \u0026lt;- show \u0026lt;$\u0026gt; getProcessID\n      puts - \u0026#34;child \u0026#34; ++ pid ++ \u0026#34; accepting on shared socket (localhost:4242)\u0026#34;\n     \n      forever - do\n        (h, _, _) \u0026lt;- accept socket\n\n        let write   = hPutStr h\n            flush   = hFlush h\n            getline = hGetLine h\n            close   = hClose h\n\n        write - \u0026#34;child \u0026#34; ++ pid ++ \u0026#34; echo\u0026gt; \u0026#34;\n        flush\n        message \u0026lt;- getline\n        write - message ++ \u0026#34;\\n\u0026#34;\n        puts - \u0026#34;child \u0026#34; ++ pid ++ \u0026#34; echo\u0026#39;d: \u0026#39;\u0026#34; ++ message ++ \u0026#34;\u0026#39;\u0026#34;\n        close\n\n    wait = forever - do\n      ( const () \u0026lt;$\u0026gt; getAnyProcessStatus True True  ) \u003ccode data-enlighter-language=\"raw\" class=\"EnlighterJSRAW\"\u003ecatch\u003c/code\u003e const trap_exit\n\n    trap_int = exitImmediately ExitSuccess\n\n    trap_exit = do\n      puts \u0026#34;\\nbailing\u0026#34;\n      sClose socket\n      exitSuccess\n\n    puts = putStrLn\n\n  (-) = ($)\n  infixr 0 -\n\n\u003c/pre\u003e\n\u003cp\u003e如果你知道更多的，请你告诉我们。（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1839.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2009/11/oscar-meyer-wienermobile-150x150.jpg\" alt=\"编程语言汽车\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1839.html\" class=\"wp_rp_title\"\u003e编程语言汽车\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/2529.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/6.jpg\" alt=\"StackOverflow的404错误页\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/2529.html\" class=\"wp_rp_title\"\u003eStackOverflow的404错误页\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7965.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/07/fork01jpg-150x150.jpg\" alt=\"一个fork的面试题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7965.html\" class=\"wp_rp_title\"\u003e一个fork的面试题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7886.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/07/muxnt-150x150.jpg\" alt=\"代码执行的效率\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7886.html\" class=\"wp_rp_title\"\u003e代码执行的效率\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/2053.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/20.jpg\" alt=\"最为奇怪的程序语言的特性\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/2053.html\" class=\"wp_rp_title\"\u003e最为奇怪的程序语言的特性\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-1532\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"c4a95fd76b\"\u003e\u003cimg id=\"rating_1532_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(1532, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.3, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0e8c6ac189a7041635c01228-=\"\"/\u003e\u003cimg id=\"rating_1532_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(1532, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.3, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0e8c6ac189a7041635c01228-=\"\"/\u003e\u003cimg id=\"rating_1532_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(1532, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.3, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0e8c6ac189a7041635c01228-=\"\"/\u003e\u003cimg id=\"rating_1532_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(1532, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.3, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0e8c6ac189a7041635c01228-=\"\"/\u003e\u003cimg id=\"rating_1532_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(1532, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.3, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0e8c6ac189a7041635c01228-=\"\"/\u003e (\u003cstrong\u003e12\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.33\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_1532_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"到处都是Unix的胎记\"/\u003e\u003cmeta itemprop=\"headline\" content=\"到处都是Unix的胎记\"/\u003e\u003cmeta itemprop=\"description\" content=\"一说起Unix编程，不必多说，最著名的系统调用就是fork，pipe，exec，kill或是socket了（fork(2), execve(2), pipe(2), socketpair(2), select(2), kill(2), sigaction(2)）这些系统调用都像是Unix编程的胎记或签名一样，表明着它来自于Unix。\n\n下面这篇文章，将向大家展示Unix下最经典的socket的编程...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2009-10-11T18:01:06+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-28T16:22:50+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/1532.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/1532.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.33\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"12\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-1532-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2009-10-11T18:01:06+08:00",
  "Author": "陈皓"
}