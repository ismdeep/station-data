{
  "Source": "coolshell.cn",
  "Title": "Go 编程模式：k8s Visitor 模式",
  "Link": "https://coolshell.cn/articles/21263.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"f0150663aa96ace6afd48bf0-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-medium wp-image-21270\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-265x300.png\" alt=\"\" width=\"265\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-265x300.png 265w, https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-906x1024.png 906w, https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-768x868.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-239x270.png 239w, https://coolshell.cn/wp-content/uploads/2020/12/go.k8s.png 1333w\" sizes=\"(max-width: 265px) 100vw, 265px\"/\u003e本篇文章主要想讨论一下，Kubernetes 的 \u003ccode\u003ekubectl\u003c/code\u003e 命令中的使用到到的一个编程模式 – Visitor（注：其实，\u003ccode\u003ekubectl\u003c/code\u003e 主要使用到了两个一个是Builder，另一个是Visitor）。本来，Visitor 是面向对象设计模英中一个很重要的设计模款（参看Wikipedia\u003ca href=\"https://en.wikipedia.org/wiki/Visitor_pattern\" target=\"_blank\" rel=\"noopener\"\u003e Visitor Pattern词条\u003c/a\u003e），这个模式是一种将算法与操作对象的结构分离的一种方法。这种分离的实际结果是能够在不修改结构的情况下向现有对象结构添加新操作，是遵循开放/封闭原则的一种方法。这篇文章我们重点看一下 \u003ccode\u003ekubelet\u003c/code\u003e 中是怎么使用函数式的方法来实现这个模式的。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第9 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/21228.html\" rel=\"prev\" title=\"Go编程模式：Pipeline\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" rel=\"next\" title=\"Go编程模式 ： 泛型编程\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\" title=\"一个简单示例\"\u003e一个简单示例\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#k8s%E7%9B%B8%E5%85%B3%E8%83%8C%E6%99%AF\" title=\"k8s相关背景\"\u003ek8s相关背景\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#kubectl%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\" title=\"kubectl的实现方法\"\u003ekubectl的实现方法\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Visitor%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89\" title=\"Visitor模式定义\"\u003eVisitor模式定义\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#Name_Visitor\" title=\"Name Visitor\"\u003eName Visitor\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Other_Visitor\" title=\"Other Visitor\"\u003eOther Visitor\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#Log_Visitor\" title=\"Log Visitor\"\u003eLog Visitor\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E4%BB%A3%E7%A0%81\" title=\"使用方代码\"\u003e使用方代码\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#Visitor%E4%BF%AE%E9%A5%B0%E5%99%A8\" title=\"Visitor修饰器\"\u003eVisitor修饰器\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e一个简单示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们还是先来看一个简单设计模式的Visitor的示例。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们的代码中有一个\u003ccode\u003eVisitor\u003c/code\u003e的函数定义，还有一个\u003ccode\u003eShape\u003c/code\u003e接口，其需要使用 \u003ccode\u003eVisitor\u003c/code\u003e函数做为参数。\u003c/li\u003e\n\u003cli\u003e我们的实例的对象 \u003ccode\u003eCircle\u003c/code\u003e和 \u003ccode\u003eRectangle\u003c/code\u003e实现了 \u003ccode\u003eShape\u003c/code\u003e 的接口的 \u003ccode\u003eaccept()\u003c/code\u003e 方法，这个方法就是等外面给我传递一个Visitor。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cspan id=\"more-21263\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003epackage main\n\nimport (\n    \u0026#34;encoding/json\u0026#34;\n    \u0026#34;encoding/xml\u0026#34;\n    \u0026#34;fmt\u0026#34;\n)\n\ntype Visitor func(shape Shape)\n\ntype Shape interface {\n    accept(Visitor)\n}\n\ntype Circle struct {\n    Radius int\n}\n\nfunc (c Circle) accept(v Visitor) {\n    v(c)\n}\n\ntype Rectangle struct {\n    Width, Heigh int\n}\n\nfunc (r Rectangle) accept(v Visitor) {\n    v(r)\n}\n\u003c/pre\u003e\n\u003cp\u003e然后，我们实现两个Visitor，一个是用来做JSON序列化的，另一个是用来做XML序列化的\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc JsonVisitor(shape Shape) {\n    bytes, err := json.Marshal(shape)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(string(bytes))\n}\n\nfunc XmlVisitor(shape Shape) {\n    bytes, err := xml.Marshal(shape)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(string(bytes))\n}\n\u003c/pre\u003e\n\u003cp\u003e下面是我们的使用Visitor这个模式的代码\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main() {\n  c := Circle{10}\n  r :=  Rectangle{100, 200}\n  shapes := []Shape{c, r}\n\n  for _, s := range shapes {\n    s.accept(JsonVisitor)\n    s.accept(XmlVisitor)\n  }\n\n}\u003c/pre\u003e\n\u003cp\u003e其实，这段代码的目的就是想解耦 数据结构和 算法，使用 Strategy 模式也是可以完成的，而且会比较干净。\u003cstrong\u003e但是在有些情况下，多个Visitor是来访问一个数据结构的不同部分，这种情况下，数据结构有点像一个数据库，而各个Visitor会成为一个个小应用。\u003c/strong\u003e \u003ccode\u003ekubectl\u003c/code\u003e就是这种情况。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"k8s%E7%9B%B8%E5%85%B3%E8%83%8C%E6%99%AF\"\u003e\u003c/span\u003ek8s相关背景\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e接下来，我们再来了解一下相关的知识背景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于Kubernetes，其抽象了很多种的Resource，比如：Pod, ReplicaSet, ConfigMap, Volumes, Namespace, Roles …. 种类非常繁多，这些东西构成为了Kubernetes的数据模型（点击 \u003ca href=\"https://github.com/kubernauts/practical-kubernetes-problems/blob/master/images/k8s-resources-map.png\" target=\"_blank\" rel=\"noopener\"\u003eKubernetes Resources 地图\u003c/a\u003e 查看其有多复杂）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekubectl\u003c/code\u003e 是Kubernetes中的一个客户端命令，操作人员用这个命令来操作Kubernetes。\u003ccode\u003ekubectl\u003c/code\u003e 会联系到 Kubernetes 的API Server，API Server会联系每个节点上的 \u003ccode\u003ekubelet\u003c/code\u003e ，从而达到控制每个结点。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekubectl\u003c/code\u003e 主要的工作是处理用户提交的东西（包括，命令行参数，yaml文件等），然后其会把用户提交的这些东西组织成一个数据结构体，然后把其发送给 API Server。\u003c/li\u003e\n\u003cli\u003e相关的源代码在 \u003ccode\u003esrc/k8s.io/cli-runtime/pkg/resource/visitor.go\u003c/code\u003e 中（\u003ca href=\"https://github.com/kubernetes/kubernetes/blob/cea1d4e20b4a7886d8ff65f34c6d4f95efcb4742/staging/src/k8s.io/cli-runtime/pkg/resource/visitor.go\" target=\"_blank\" rel=\"noopener\"\u003e源码链接\u003c/a\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003ekubectl\u003c/code\u003e 的代码比较复杂，不过，其本原理简单来说，\u003cstrong\u003e它从命令行和yaml文件中获取信息，通过Builder模式并把其转成一系列的资源，最后用 Visitor 模式模式来迭代处理这些Reources\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e下面我们来看看 \u003ccode\u003ekubectl\u003c/code\u003e 的实现，为了简化，我用一个小的示例来表明 ，而不是直接分析复杂的源码。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"kubectl%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95\"\u003e\u003c/span\u003ekubectl的实现方法\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Visitor%E6%A8%A1%E5%BC%8F%E5%AE%9A%E4%B9%89\"\u003e\u003c/span\u003eVisitor模式定义\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e首先，\u003ccode\u003ekubectl\u003c/code\u003e 主要是用来处理 \u003ccode\u003eInfo\u003c/code\u003e结构体，下面是相关的定义：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype VisitorFunc func(*Info, error) error\n\ntype Visitor interface {\n    Visit(VisitorFunc) error\n}\n\ntype Info struct {\n    Namespace   string\n    Name        string\n    OtherThings string\n}\nfunc (info *Info) Visit(fn VisitorFunc) error {\n  return fn(info, nil)\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有一个 \u003ccode\u003eVisitorFunc\u003c/code\u003e 的函数类型的定义\u003c/li\u003e\n\u003cli\u003e一个 \u003ccode\u003eVisitor\u003c/code\u003e 的接口，其中需要 \u003ccode\u003eVisit(VisitorFunc) error\u003c/code\u003e  的方法（这就像是我们上面那个例子的 \u003ccode\u003eShape\u003c/code\u003e ）\u003c/li\u003e\n\u003cli\u003e最后，为\u003ccode\u003eInfo\u003c/code\u003e 实现 \u003ccode\u003eVisitor\u003c/code\u003e 接口中的 \u003ccode\u003eVisit()\u003c/code\u003e 方法，实现就是直接调用传进来的方法（与前面的例子相仿）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们再来定义几种不同类型的 Visitor。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Name_Visitor\"\u003e\u003c/span\u003eName Visitor\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这个Visitor 主要是用来访问 \u003ccode\u003eInfo\u003c/code\u003e 结构中的 \u003ccode\u003eName\u003c/code\u003e 和 \u003ccode\u003eNameSpace\u003c/code\u003e 成员\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype NameVisitor struct {\n  visitor Visitor\n}\n\nfunc (v NameVisitor) Visit(fn VisitorFunc) error {\n  return v.visitor.Visit(func(info *Info, err error) error {\n    fmt.Println(\u0026#34;NameVisitor() before call function\u0026#34;)\n    err = fn(info, err)\n    if err == nil {\n      fmt.Printf(\u0026#34;==\u0026gt; Name=%s, NameSpace=%s\\n\u0026#34;, info.Name, info.Namespace)\n    }\n    fmt.Println(\u0026#34;NameVisitor() after call function\u0026#34;)\n    return err\n  })\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，上面的代码：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e声明了一个 \u003ccode\u003eNameVisitor\u003c/code\u003e 的结构体，这个结构体里有一个 \u003ccode\u003eVisitor\u003c/code\u003e 接口成员，这里意味着多态。\u003c/li\u003e\n\u003cli\u003e在实现 \u003ccode\u003eVisit()\u003c/code\u003e 方法时，其调用了自己结构体内的那个 \u003ccode\u003eVisitor\u003c/code\u003e的 \u003ccode\u003eVisitor()\u003c/code\u003e 方法，这其实是一种修饰器的模式，用另一个Visitor修饰了自己（关于修饰器模式，参看《\u003ca title=\"Go编程模式：修饰器\" href=\"https://coolshell.cn/articles/17929.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：修饰器\u003c/a\u003e》）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Other_Visitor\"\u003e\u003c/span\u003eOther Visitor\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这个Visitor主要用来访问 \u003ccode\u003eInfo\u003c/code\u003e 结构中的 \u003ccode\u003eOtherThings\u003c/code\u003e 成员\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype OtherThingsVisitor struct {\n  visitor Visitor\n}\n\nfunc (v OtherThingsVisitor) Visit(fn VisitorFunc) error {\n  return v.visitor.Visit(func(info *Info, err error) error {\n    fmt.Println(\u0026#34;OtherThingsVisitor() before call function\u0026#34;)\n    err = fn(info, err)\n    if err == nil {\n      fmt.Printf(\u0026#34;==\u0026gt; OtherThings=%s\\n\u0026#34;, info.OtherThings)\n    }\n    fmt.Println(\u0026#34;OtherThingsVisitor() after call function\u0026#34;)\n    return err\n  })\n}\u003c/pre\u003e\n\u003cp\u003e实现逻辑同上，我就不再重新讲了\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Log_Visitor\"\u003e\u003c/span\u003eLog Visitor\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype LogVisitor struct {\n  visitor Visitor\n}\n\nfunc (v LogVisitor) Visit(fn VisitorFunc) error {\n  return v.visitor.Visit(func(info *Info, err error) error {\n    fmt.Println(\u0026#34;LogVisitor() before call function\u0026#34;)\n    err = fn(info, err)\n    fmt.Println(\u0026#34;LogVisitor() after call function\u0026#34;)\n    return err\n  })\n}\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BD%BF%E7%94%A8%E6%96%B9%E4%BB%A3%E7%A0%81\"\u003e\u003c/span\u003e使用方代码\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e现在我们看看如果使用上面的代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main() {\n  info := Info{}\n  var v Visitor = \u0026amp;info\n  v = LogVisitor{v}\n  v = NameVisitor{v}\n  v = OtherThingsVisitor{v}\n\n  loadFile := func(info *Info, err error) error {\n    info.Name = \u0026#34;Hao Chen\u0026#34;\n    info.Namespace = \u0026#34;MegaEase\u0026#34;\n    info.OtherThings = \u0026#34;We are running as remote team.\u0026#34;\n    return nil\n  }\n  v.Visit(loadFile)\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码，我们可以看到\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVisitor们一层套一层\u003c/li\u003e\n\u003cli\u003e我用 \u003ccode\u003eloadFile\u003c/code\u003e 假装从文件中读如数据\u003c/li\u003e\n\u003cli\u003e最后一条 \u003ccode\u003ev.Visit(loadfile)\u003c/code\u003e 我们上面的代码就全部开始激活工作了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e上面的代码输出如下的信息，你可以看到代码的执行顺序是怎么执行起来了\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003eLogVisitor() before call function\nNameVisitor() before call function\nOtherThingsVisitor() before call function\n==\u0026gt; OtherThings=We are running as remote team.\nOtherThingsVisitor() after call function\n==\u0026gt; Name=Hao Chen, NameSpace=MegaEase\nNameVisitor() after call function\nLogVisitor() after call function\u003c/pre\u003e\n\u003cp\u003e我们可以看到，上面的代码有以下几种功效：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e解耦了数据和程序。\u003c/li\u003e\n\u003cli\u003e使用了修饰器模式\u003c/li\u003e\n\u003cli\u003e还做出来pipeline的模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以，其实，我们是可以把上面的代码重构一下的。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Visitor%E4%BF%AE%E9%A5%B0%E5%99%A8\"\u003e\u003c/span\u003eVisitor修饰器\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面，我们用\u003ca title=\"Go编程模式：修饰器\" href=\"https://coolshell.cn/articles/17929.html\" target=\"_blank\" rel=\"noopener\"\u003e修饰器模式\u003c/a\u003e来重构一下上面的代码。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype DecoratedVisitor struct {\n  visitor    Visitor\n  decorators []VisitorFunc\n}\n\nfunc NewDecoratedVisitor(v Visitor, fn ...VisitorFunc) Visitor {\n  if len(fn) == 0 {\n    return v\n  }\n  return DecoratedVisitor{v, fn}\n}\n\n// Visit implements Visitor\nfunc (v DecoratedVisitor) Visit(fn VisitorFunc) error {\n  return v.visitor.Visit(func(info *Info, err error) error {\n    if err != nil {\n      return err\n    }\n    if err := fn(info, nil); err != nil {\n      return err\n    }\n    for i := range v.decorators {\n      if err := v.decorators[i](info, nil); err != nil {\n        return err\n      }\n    }\n    return nil\n  })\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码并不复杂，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用一个 \u003ccode\u003eDecoratedVisitor\u003c/code\u003e 的结构来存放所有的\u003ccode\u003eVistorFunc\u003c/code\u003e函数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNewDecoratedVisitor\u003c/code\u003e 可以把所有的 \u003ccode\u003eVisitorFunc\u003c/code\u003e转给它，构造 \u003ccode\u003eDecoratedVisitor\u003c/code\u003e 对象。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDecoratedVisitor\u003c/code\u003e实现了 \u003ccode\u003eVisit()\u003c/code\u003e 方法，里面就是来做一个for-loop，顺着调用所有的 \u003ccode\u003eVisitorFunc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e于是，我们的代码就可以这样运作了：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003einfo := Info{}\nvar v Visitor = \u0026amp;info\nv = NewDecoratedVisitor(v, NameVisitor, OtherVisitor)\n\nv.Visit(LoadFile)\u003c/pre\u003e\n\u003cp\u003e是不是比之前的那个简单？注意，这个\u003ccode\u003eDecoratedVisitor\u003c/code\u003e 同样可以成为一个Visitor来使用。\u003c/p\u003e\n\u003cp\u003e好，上面的这些代码全部存在于 \u003ccode\u003ekubectl\u003c/code\u003e 的代码中，你看懂了这里面的代码逻辑，相信你也能够看懂 \u003ccode\u003ekubectl\u003c/code\u003e 的代码了。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21263\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"ad23c92ba9\"\u003e\u003cimg id=\"rating_21263_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21263, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f0150663aa96ace6afd48bf0-=\"\"/\u003e\u003cimg id=\"rating_21263_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21263, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f0150663aa96ace6afd48bf0-=\"\"/\u003e\u003cimg id=\"rating_21263_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21263, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f0150663aa96ace6afd48bf0-=\"\"/\u003e\u003cimg id=\"rating_21263_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21263, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f0150663aa96ace6afd48bf0-=\"\"/\u003e\u003cimg id=\"rating_21263_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21263, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.1, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-f0150663aa96ace6afd48bf0-=\"\"/\u003e (\u003cstrong\u003e61\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.07\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21263_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go 编程模式：k8s Visitor 模式\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go 编程模式：k8s Visitor 模式\"/\u003e\u003cmeta itemprop=\"description\" content=\"本篇文章主要想讨论一下，Kubernetes 的 kubectl 命令中的使用到到的一个编程模式 - Visitor（注：其实，kubectl 主要使用到了两个一个是Builder，另一个是Visitor）。本来，Visitor 是面向对象设计模英中一个很重要的设计模款（参看Wikipedia Visitor Pattern词条），这个模式是一种将算法与操作对象的结构分离的一种方法。这种分离的实际...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-26T19:25:46+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-27T10:39:39+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21263.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21263.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.07\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"61\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21263-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-26T19:25:46+08:00",
  "Author": "陈皓"
}