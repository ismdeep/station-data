{
  "Source": "coolshell.cn",
  "Title": "Go编程模式：Pipeline",
  "Link": "https://coolshell.cn/articles/21228.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"19e5b5f13af6b6dd1baa3b8e-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"aligncenter wp-image-21258 size-large\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-1024x191.png\" alt=\"\" width=\"640\" height=\"119\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-1024x191.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-300x56.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-768x143.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-1536x286.png 1536w, https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-604x113.png 604w, https://coolshell.cn/wp-content/uploads/2020/12/go.line_..png 1920w\" sizes=\"(max-width: 640px) 100vw, 640px\"/\u003e\u003c/p\u003e\n\u003cp\u003e本篇文章，我们着重介绍Go编程中的Pipeline模式。对于Pipeline用过Unix/Linux命令行的人都不会陌生，他是一种把各种命令拼接起来完成一个更强功能的技术方法。在今天，流式处理，函数式编程，以及应用网关对微服务进行简单的API编排，其实都是受pipeline这种技术方式的影响，Pipeline这种技术在可以很容易的把代码按单一职责的原则拆分成多个高内聚低耦合的小模块，然后可以很方便地拼装起来去完成比较复杂的功能。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第8 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21128.html\"\u003eGo编程模式：切片，接口，时间和性能\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式：Pipeline\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-prev\"\u003e« \u003ca href=\"https://coolshell.cn/articles/17929.html\" rel=\"prev\" title=\"Go编程模式：修饰器\"\u003e上一篇文章\u003c/a\u003e\u003c/span\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" rel=\"next\" title=\"Go 编程模式：k8s Visitor 模式\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#HTTP_%E5%A4%84%E7%90%86\" title=\"HTTP 处理\"\u003eHTTP 处理\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Channel_%E7%AE%A1%E7%90%86\" title=\"Channel 管理\"\u003eChannel 管理\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Channel%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0\" title=\"Channel转发函数\"\u003eChannel转发函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E5%B9%B3%E6%96%B9%E5%87%BD%E6%95%B0\" title=\"平方函数\"\u003e平方函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E8%BF%87%E6%BB%A4%E5%A5%87%E6%95%B0%E5%87%BD%E6%95%B0\" title=\"过滤奇数函数\"\u003e过滤奇数函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E6%B1%82%E5%92%8C%E5%87%BD%E6%95%B0\" title=\"求和函数\"\u003e求和函数\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#Fan_inOut\" title=\"Fan in/Out\"\u003eFan in/Out\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB\" title=\"延伸阅读\"\u003e延伸阅读\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"HTTP_%E5%A4%84%E7%90%86\"\u003e\u003c/span\u003eHTTP 处理\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e这种Pipeline的模式，我们在《\u003ca title=\"Go编程模式：修饰器\" href=\"https://coolshell.cn/articles/17929.html\" target=\"_blank\" rel=\"noopener\"\u003eGo编程模式：修饰器\u003c/a\u003e》中有过一个示例，我们在这里再重温一下。在那篇文章中，我们有一堆如 \u003ccode\u003eWithServerHead()\u003c/code\u003e 、\u003ccode\u003eWithBasicAuth()\u003c/code\u003e 、\u003ccode\u003eWithDebugLog()\u003c/code\u003e这样的小功能代码，在我们需要实现某个HTTP API 的时候，我们就可以很容易的组织起来。\u003c/p\u003e\n\u003cp\u003e原来的代码是下面这个样子：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21228\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ehttp.HandleFunc(\u0026#34;/v1/hello\u0026#34;, WithServerHeader(WithAuthCookie(hello)))\nhttp.HandleFunc(\u0026#34;/v2/hello\u0026#34;, WithServerHeader(WithBasicAuth(hello)))\nhttp.HandleFunc(\u0026#34;/v3/hello\u0026#34;, WithServerHeader(WithBasicAuth(WithDebugLog(hello))))\u003c/pre\u003e\n\u003cp\u003e通过一个代理函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003etype HttpHandlerDecorator func(http.HandlerFunc) http.HandlerFunc\nfunc Handler(h http.HandlerFunc, decors ...HttpHandlerDecorator) http.HandlerFunc {\n    for i := range decors {\n        d := decors[len(decors)-1-i] // iterate in reverse\n        h = d(h)\n    }\n    return h\n}\u003c/pre\u003e\n\u003cp\u003e我们就可以移除不断的嵌套像下面这样使用了：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"generic\"\u003ehttp.HandleFunc(\u0026#34;/v4/hello\u0026#34;, Handler(hello,\n                WithServerHeader, WithBasicAuth, WithDebugLog))\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Channel_%E7%AE%A1%E7%90%86\"\u003e\u003c/span\u003eChannel 管理\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e当然，如果你要写出一个\u003ca href=\"https://coolshell.cn/articles/17929.html#%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BF%AE%E9%A5%B0%E5%99%A8\" target=\"_blank\" rel=\"noopener\"\u003e泛型的pipeline框架\u003c/a\u003e并不容易，而使用\u003ca title=\"GO 编程模式：Go Generation\" href=\"https://coolshell.cn/articles/21179.html\" target=\"_blank\" rel=\"noopener\"\u003eGo Generation\u003c/a\u003e，但是，我们别忘了Go语言最具特色的 Go Routine 和 Channel 这两个神器完全也可以被我们用来构造这种编程。\u003c/p\u003e\n\u003cp\u003eRob Pike在 \u003ca href=\"https://blog.golang.org/pipelines\" target=\"_blank\" rel=\"noopener\"\u003eGo Concurrency Patterns: Pipelines and cancellation\u003c/a\u003e 这篇blog中介绍了如下的一种编程模式。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Channel%E8%BD%AC%E5%8F%91%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003eChannel转发函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e首先，我们需一个 \u003ccode\u003eecho()\u003c/code\u003e函数，其会把一个整型数组放到一个Channel中，并返回这个Channel\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc echo(nums []int) \u0026lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for _, n := range nums {\n      out \u0026lt;- n\n    }\n    close(out)\n  }()\n  return out\n}\u003c/pre\u003e\n\u003cp\u003e然后，我们依照这个模式，我们可以写下这个函数。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B9%B3%E6%96%B9%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e平方函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc sq(in \u0026lt;-chan int) \u0026lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for n := range in {\n      out \u0026lt;- n * n\n    }\n    close(out)\n  }()\n  return out\n}\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%BF%87%E6%BB%A4%E5%A5%87%E6%95%B0%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e过滤奇数函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc odd(in \u0026lt;-chan int) \u0026lt;-chan int {\n  out := make(chan int)\n  go func() {\n    for n := range in {\n      if n%2 != 0 {\n        out \u0026lt;- n\n      }\n    }\n    close(out)\n  }()\n  return out\n}\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B1%82%E5%92%8C%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e求和函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc sum(in \u0026lt;-chan int) \u0026lt;-chan int {\n  out := make(chan int)\n  go func() {\n    var sum = 0\n    for n := range in {\n      sum += n\n    }\n    out \u0026lt;- sum\n    close(out)\n  }()\n  return out\n}\u003c/pre\u003e\n\u003cp\u003e然后，我们的用户端的代码如下所示：（注：\u003cstrong\u003e你可能会觉得，\u003ccode\u003esum()\u003c/code\u003e，\u003ccode\u003eodd()\u003c/code\u003e 和 \u003ccode\u003esq()\u003c/code\u003e太过于相似。你其实可以通过我们之前的\u003ca href=\"https://coolshell.cn/articles/21164.html\" target=\"_blank\" rel=\"noopener\"\u003eMap/Reduce编程模式\u003c/a\u003e或是\u003ca href=\"https://coolshell.cn/articles/21179.html\" target=\"_blank\" rel=\"noopener\"\u003eGo Generation的方式\u003c/a\u003e来合并一下\u003c/strong\u003e）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\nfor n := range sum(sq(odd(echo(nums)))) {\n  fmt.Println(n)\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码类似于我们执行了Unix/Linux命令： \u003ccode\u003eecho $nums | sq | sum\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e同样，如果你不想有那么多的函数嵌套，你可以使用一个代理函数来完成。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype EchoFunc func ([]int) (\u0026lt;- chan int) \ntype PipeFunc func (\u0026lt;- chan int) (\u0026lt;- chan int) \n\nfunc pipeline(nums []int, echo EchoFunc, pipeFns ... PipeFunc) \u0026lt;- chan int {\n  ch  := echo(nums)\n  for i := range pipeFns {\n    ch = pipeFns[i](ch)\n  }\n  return ch\n}\u003c/pre\u003e\n\u003cp\u003e然后，就可以这样做了：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar nums = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}    \nfor n := range pipeline(nums, gen, odd, sq, sum) {\n    fmt.Println(n)\n  }\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Fan_inOut\"\u003e\u003c/span\u003eFan in/Out\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e动用Go语言的 Go Routine和 Channel还有一个好处，就是可以写出1对多，或多对1的pipeline，也就是Fan In/ Fan Out。下面，我们来看一个Fan in的示例：\u003c/p\u003e\n\u003cp\u003e我们想通过并发的方式来对一个很长的数组中的质数进行求和运算，我们想先把数组分段求和，然后再把其集中起来。\u003c/p\u003e\n\u003cp\u003e下面是我们的主函数：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc makeRange(min, max int) []int {\n  a := make([]int, max-min+1)\n  for i := range a {\n    a[i] = min + i\n  }\n  return a\n}\n\nfunc main() {\n  nums := makeRange(1, 10000)\n  in := echo(nums)\n\n  const nProcess = 5\n  var chans [nProcess]\u0026lt;-chan int\n  for i := range chans {\n    chans[i] = sum(prime(in))\n  }\n\n  for n := range sum(merge(chans[:])) {\n    fmt.Println(n)\n  }\n}\u003c/pre\u003e\n\u003cp\u003e再看我们的 \u003ccode\u003eprime()\u003c/code\u003e 函数的实现 ：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc is_prime(value int) bool {\n  for i := 2; i \u0026lt;= int(math.Floor(float64(value) / 2)); i++ {\n    if value%i == 0 {\n      return false\n    }\n  }\n  return value \u0026gt; 1\n}\n\nfunc prime(in \u0026lt;-chan int) \u0026lt;-chan int {\n  out := make(chan int)\n  go func ()  {\n    for n := range in {\n      if is_prime(n) {\n        out \u0026lt;- n\n      }\n    }\n    close(out)\n  }()\n  return out\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我们先制造了从1到10000的一个数组，\u003c/li\u003e\n\u003cli\u003e然后，把这堆数组全部 \u003ccode\u003eecho\u003c/code\u003e到一个channel里 – \u003ccode\u003ein\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e此时，生成 5 个 Channel，然后都调用 \u003ccode\u003esum(prime(in))\u003c/code\u003e ，于是每个Sum的Go Routine都会开始计算和\u003c/li\u003e\n\u003cli\u003e最后再把所有的结果再求和拼起来，得到最终的结果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中的merge代码如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc merge(cs []\u0026lt;-chan int) \u0026lt;-chan int {\n  var wg sync.WaitGroup\n  out := make(chan int)\n\n  wg.Add(len(cs))\n  for _, c := range cs {\n    go func(c \u0026lt;-chan int) {\n      for n := range c {\n        out \u0026lt;- n\n      }\n      wg.Done()\n    }(c)\n  }\n  go func() {\n    wg.Wait()\n    close(out)\n  }()\n  return out\n}\u003c/pre\u003e\n\u003cp\u003e用图片表示一下，整个程序的结构如下所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-large wp-image-21231\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/pipeline-1024x425.png\" alt=\"\" width=\"640\" height=\"266\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/pipeline-1024x425.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/pipeline-300x124.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/pipeline-768x319.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/pipeline-1536x637.png 1536w, https://coolshell.cn/wp-content/uploads/2020/12/pipeline-604x251.png 604w, https://coolshell.cn/wp-content/uploads/2020/12/pipeline.png 1572w\" sizes=\"(max-width: 640px) 100vw, 640px\"/\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB\"\u003e\u003c/span\u003e延伸阅读\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e如果你还想了解更多的这样的与并发相关的技术，可以参看下面这些资源：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eGo\u003c/b\u003e \u003cb\u003eConcurrency\u003c/b\u003e \u003cb\u003ePatterns\u003c/b\u003e\u003cb\u003e\u003c/b\u003e – \u003cb\u003eRob\u003c/b\u003e \u003cb\u003ePike –\u003c/b\u003e 2012 Google I/O \u003cb\u003e\u003cbr/\u003e\n\u003c/b\u003epresents the basics of Go‘s concurrency primitives and several ways to apply them.\u003cbr/\u003e\n\u003cu\u003e\u003ca href=\"https://www.youtube.com/watch?v=f6kdp27TYZs\"\u003ehttps://www.youtube.com/watch?v=f6kdp27TYZs\u003c/a\u003e\u003c/u\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eAdvanced Go Concurrency Patterns \u003c/b\u003e– \u003cb\u003eRob\u003c/b\u003e \u003cb\u003ePike\u003c/b\u003e – 2013 Google I/O \u003cb\u003e\u003cbr/\u003e\n\u003c/b\u003ecovers more complex uses of Go’s primitives, especially select.\u003cbr/\u003e\n\u003ca href=\"https://blog.golang.org/advanced-go-concurrency-patterns\"\u003ehttps://blog.golang.org/advanced-go-concurrency-patterns\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eSquinting at Power Series \u003c/b\u003e– \u003cb\u003eDouglas McIlroy\u003c/b\u003e‘s paper \u003cb\u003e\u003cbr/\u003e\n\u003c/b\u003eshows how Go-like concurrency provides elegant support for complex calculations.\u003cbr/\u003e\n\u003ca href=\"https://swtch.com/~rsc/thread/squint.pdf\"\u003ehttps://swtch.com/~rsc/thread/squint.pdf\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21228\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"88b724c852\"\u003e\u003cimg id=\"rating_21228_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21228, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-19e5b5f13af6b6dd1baa3b8e-=\"\"/\u003e\u003cimg id=\"rating_21228_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21228, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-19e5b5f13af6b6dd1baa3b8e-=\"\"/\u003e\u003cimg id=\"rating_21228_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21228, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-19e5b5f13af6b6dd1baa3b8e-=\"\"/\u003e\u003cimg id=\"rating_21228_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21228, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-19e5b5f13af6b6dd1baa3b8e-=\"\"/\u003e\u003cimg id=\"rating_21228_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21228, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-19e5b5f13af6b6dd1baa3b8e-=\"\"/\u003e (\u003cstrong\u003e39\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.85\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21228_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式：Pipeline\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式：Pipeline\"/\u003e\u003cmeta itemprop=\"description\" content=\"\n\n本篇文章，我们着重介绍Go编程中的Pipeline模式。对于Pipeline用过Unix/Linux命令行的人都不会陌生，他是一种把各种命令拼接起来完成一个更强功能的技术方法。在今天，流式处理，函数式编程，以及应用网关对微服务进行简单的API编排，其实都是受pipeline这种技术方式的影响，Pipeline这种技术在可以很容易的把代码按单一职责的原则拆分成多个高内聚低耦合的小模块，然后可以很...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-26T17:04:59+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-12-26T17:07:07+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21228.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21228.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.85\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"39\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21228-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-26T17:04:59+08:00",
  "Author": "陈皓"
}