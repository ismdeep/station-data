{
  "Source": "coolshell.cn",
  "Title": "疫苗：Java HashMap的死循环",
  "Link": "https://coolshell.cn/articles/9606.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"0ebc933e34b792b4502df69c-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"size-medium wp-image-9618 alignright\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/race_condition-300x190.jpg\" width=\"300\" height=\"190\" srcset=\"https://coolshell.cn/wp-content/uploads/2013/05/race_condition-300x190.jpg 300w, https://coolshell.cn/wp-content/uploads/2013/05/race_condition-426x270.jpg 426w, https://coolshell.cn/wp-content/uploads/2013/05/race_condition.jpg 549w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程安全的，所以在并发下必然出现问题。但是，我发现近几年，很多人都经历过这个事（在网上查“HashMap Infinite Loop”可以看到很多人都在说这个事）所以，觉得这个是个普遍问题，需要写篇疫苗文章说一下这个事，并且给大家看看一个完美的“Race Condition”是怎么形成的。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6\" title=\"问题的症状\"\u003e问题的症状\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Hash%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\" title=\"Hash表数据结构\"\u003eHash表数据结构\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#HashMap%E7%9A%84rehash%E6%BA%90%E4%BB%A3%E7%A0%81\" title=\"HashMap的rehash源代码\"\u003eHashMap的rehash源代码\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E6%AD%A3%E5%B8%B8%E7%9A%84ReHash%E7%9A%84%E8%BF%87%E7%A8%8B\" title=\"正常的ReHash的过程\"\u003e正常的ReHash的过程\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash\" title=\"并发下的Rehash\"\u003e并发下的Rehash\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E5%85%B6%E5%AE%83\" title=\"其它\"\u003e其它\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6\"\u003e\u003c/span\u003e问题的症状\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e从前我们的Java代码因为一些原因使用了HashMap这个东西，但是当时的程序是单线程的，一切都没有问题。后来，我们的程序性能有问题，所以需要变成多线程的，于是，变成多线程后到了线上，发现程序经常占了100%的CPU，查看堆栈，你会发现程序都Hang在了HashMap.get()这个方法上了，重启程序后问题消失。但是过段时间又会来。而且，这个问题在测试环境里可能很难重现。\u003c/p\u003e\n\u003cp\u003e我们简单的看一下我们自己的代码，我们就知道HashMap被多个线程操作。而Java的文档说HashMap是非线程安全的，应该用ConcurrentHashMap。\u003c/p\u003e\n\u003cp\u003e但是在这里我们可以来研究一下原因。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-9606\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Hash%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\"\u003e\u003c/span\u003eHash表数据结构\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我需要简单地说一下HashMap这个经典的数据结构。\u003c/p\u003e\n\u003cp\u003eHashMap通常会用一个指针数组（假设为table[]）来做分散所有的key，当一个key被加入时，会通过Hash算法通过key算出这个数组的下标i，然后就把这个\u0026lt;key, value\u0026gt;插到table[i]中，如果有两个不同的key被算在了同一个i，那么就叫冲突，又叫碰撞，这样会在table[i]上形成一个链表。\u003c/p\u003e\n\u003cp\u003e我们知道，如果table[]的尺寸很小，比如只有2个，如果要放进10个keys的话，那么碰撞非常频繁，于是一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷（可参看《\u003ca title=\"Hash Collision DoS 问题\" href=\"https://coolshell.cn/articles/6424.html\" target=\"_blank\" rel=\"bookmark\"\u003eHash Collision DoS 问题\u003c/a\u003e》）。\u003c/p\u003e\n\u003cp\u003e所以，Hash表的尺寸和容量非常的重要。一般来说，Hash表这个容器当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的无素都需要被重算一遍。这叫rehash，这个成本相当的大。\u003c/p\u003e\n\u003cp\u003e相信大家对这个基础知识已经很熟悉了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"HashMap%E7%9A%84rehash%E6%BA%90%E4%BB%A3%E7%A0%81\"\u003e\u003c/span\u003eHashMap的rehash源代码\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面，我们来看一下Java的HashMap的源代码。\u003c/p\u003e\n\u003cp\u003ePut一个Key,Value对到Hash表中：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"19\"\u003epublic V put(K key, V value)\n{\n    ......\n    //算Hash值\n    int hash = hash(key.hashCode());\n    int i = indexFor(hash, table.length);\n    //如果该key已被插入，则替换掉旧的value （链接操作）\n    for (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) {\n        Object k;\n        if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) {\n            V oldValue = e.value;\n            e.value = value;\n            e.recordAccess(this);\n            return oldValue;\n        }\n    }\n    modCount++;\n    //该key不存在，需要增加一个结点\n    addEntry(hash, key, value, i);\n    return null;\n}\u003c/pre\u003e\n\u003cp\u003e检查容量是否超标\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"7\"\u003evoid addEntry(int hash, K key, V value, int bucketIndex)\n{\n    Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex];\n    table[bucketIndex] = new Entry\u0026lt;K,V\u0026gt;(hash, key, value, e);\n    //查看当前的size是否超过了我们设定的阈值threshold，如果超过，需要resize\n    if (size++ \u0026gt;= threshold)\n        resize(2 * table.length);\n} \u003c/pre\u003e\n\u003cp\u003e新建一个更大尺寸的hash表，然后把数据从老的Hash表中迁移到新的Hash表中。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"9\"\u003evoid resize(int newCapacity)\n{\n    Entry[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    ......\n    //创建一个新的Hash Table\n    Entry[] newTable = new Entry[newCapacity];\n    //将Old Hash Table上的数据迁移到New Hash Table上\n    transfer(newTable);\n    table = newTable;\n    threshold = (int)(newCapacity * loadFactor);\n}\u003c/pre\u003e\n\u003cp\u003e迁移的源代码，注意高亮处：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"12,14,15,16\"\u003evoid transfer(Entry[] newTable)\n{\n    Entry[] src = table;\n    int newCapacity = newTable.length;\n    //下面这段代码的意思是：\n    //  从OldTable里摘一个元素出来，然后放到NewTable中\n    for (int j = 0; j \u0026lt; src.length; j++) {\n        Entry\u0026lt;K,V\u0026gt; e = src[j];\n        if (e != null) {\n            src[j] = null;\n            do {\n                Entry\u0026lt;K,V\u0026gt; next = e.next;\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            } while (e != null);\n        }\n    }\n} \u003c/pre\u003e\n\u003cp\u003e好了，这个代码算是比较正常的。而且没有什么问题。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%AD%A3%E5%B8%B8%E7%9A%84ReHash%E7%9A%84%E8%BF%87%E7%A8%8B\"\u003e\u003c/span\u003e正常的ReHash的过程\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e画了个图做了个演示。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e我假设了我们的hash算法就是简单的用key mod 一下表的大小（也就是数组的长度）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e接下来的三个步骤是Hash表 resize成4，然后所有的\u0026lt;key,value\u0026gt; 重新rehash的过程\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp style=\"text-align: center;\"\u003e\u003cimg decoding=\"async\" class=\"aligncenter  wp-image-9607\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/HashMap01.jpg\"/\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash\"\u003e\u003c/span\u003e并发下的Rehash\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e\u003cstrong\u003e1）假设我们有两个线程。\u003c/strong\u003e我用红色和浅蓝色标注了一下。\u003c/p\u003e\n\u003cp\u003e我们再回头看一下我们的 transfer代码中的这个细节：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"2\"\u003edo {\n    Entry\u0026lt;K,V\u0026gt; next = e.next; // \u0026lt;--假设线程一执行到这里就被调度挂起了\n    int i = indexFor(e.hash, newCapacity);\n    e.next = newTable[i];\n    newTable[i] = e;\n    e = next;\n} while (e != null);\u003c/pre\u003e\n\u003cp\u003e而我们的线程二执行完成了。于是我们有下面的这个样子。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/HashMap02.jpg\" width=\"616\" height=\"434\"/\u003e\u003c/p\u003e\n\u003cp\u003e注意，\u003cstrong\u003e因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表\u003c/strong\u003e。我们可以看到链表的顺序被反转后。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e2）线程一被调度回来执行。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e先是执行 newTalbe[i] = e;\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e然后是e = next，导致了e指向了key(7)，\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e而下一次循环的next = e.next导致了next指向了key(3)\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/HashMap03.jpg\" width=\"591\" height=\"376\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e3）一切安好。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e线程一接着工作。\u003cstrong\u003e把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/HashMap04.jpg\" width=\"627\" height=\"411\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e4）环形链接出现。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ee.next = newTable[i] 导致  key(3).next 指向了 key(7)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"text-align: left;\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter\" alt=\"\" src=\"https://coolshell.cn/wp-content/uploads/2013/05/HashMap05.jpg\" width=\"623\" height=\"395\"/\u003e\u003c/p\u003e\n\u003cp style=\"text-align: left;\"\u003e\u003cstrong\u003e于是，当我们的线程一调用到，HashTable.get(11)时，悲剧就出现了——Infinite Loop。\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 style=\"text-align: left;\"\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B6%E5%AE%83\"\u003e\u003c/span\u003e其它\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e有人把这个问题报给了Sun，不过Sun不认为这个是一个问题。因为HashMap本来就不支持并发。要并发就用ConcurrentHashmap\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457\" target=\"_blank\"\u003ehttp://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6423457\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e我在这里把这个事情记录下来，只是为了让大家了解并体会一下并发环境下的危险。\u003c/p\u003e\n\u003cp\u003e参考：\u003ca href=\"https://mailinator.blogspot.com/2009/06/beautiful-race-condition.html\" rel=\"nofollow\"\u003ehttp://mailinator.blogspot.com/2009/06/beautiful-race-condition.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/05/图1-3-150x150.jpg\" alt=\"无锁HashMap的原理与实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_title\"\u003e无锁HashMap的原理与实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6424.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/1.jpg\" alt=\"Hash Collision DoS 问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6424.html\" class=\"wp_rp_title\"\u003eHash Collision DoS 问题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11541.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/24.jpg\" alt=\"面向GC的Java编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11541.html\" class=\"wp_rp_title\"\u003e面向GC的Java编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11454.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/17.jpg\" alt=\"从LongAdder看更高效的无锁实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11454.html\" class=\"wp_rp_title\"\u003e从LongAdder看更高效的无锁实现\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-9606\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"c771261e1e\"\u003e\u003cimg id=\"rating_9606_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9606, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.7, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ebc933e34b792b4502df69c-=\"\"/\u003e\u003cimg id=\"rating_9606_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9606, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.7, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ebc933e34b792b4502df69c-=\"\"/\u003e\u003cimg id=\"rating_9606_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9606, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.7, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ebc933e34b792b4502df69c-=\"\"/\u003e\u003cimg id=\"rating_9606_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9606, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.7, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ebc933e34b792b4502df69c-=\"\"/\u003e\u003cimg id=\"rating_9606_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(9606, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.7, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ebc933e34b792b4502df69c-=\"\"/\u003e (\u003cstrong\u003e202\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.69\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_9606_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"疫苗：Java HashMap的死循环\"/\u003e\u003cmeta itemprop=\"headline\" content=\"疫苗：Java HashMap的死循环\"/\u003e\u003cmeta itemprop=\"description\" content=\"在淘宝内网里看到同事发了贴说了一个CPU被100%的线上故障，并且这个事发生了很多次，原因是在Java语言在并发情况下使用HashMap造成Race Condition，从而导致死循环。这个事情我4、5年前也经历过，本来觉得没什么好写的，因为Java的HashMap是非线程安全的，所以在并发下必然出现问题。但是，我发现近几年，很多人都经历过这个事（在网上查“HashMap Infinite Loo...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2013-05-10T08:12:12+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2013-05-11T22:04:03+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/9606.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/9606.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.69\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"202\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-9606-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2013-05-10T08:12:12+08:00",
  "Author": "陈皓"
}