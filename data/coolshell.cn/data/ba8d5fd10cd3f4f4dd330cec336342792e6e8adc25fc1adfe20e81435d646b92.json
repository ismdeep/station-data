{
  "Source": "coolshell.cn",
  "Title": "记一次Kubernetes/Docker网络排障",
  "Link": "https://coolshell.cn/articles/18654.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"a5270038e84173b54a7eb6ee-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-full wp-image-18662\" src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1.png\" alt=\"\" width=\"300\" height=\"238\"/\u003e昨天周五晚上，临下班的时候，用户给我们报了一个比较怪异的Kubernetes集群下的网络不能正常访问的问题，让我们帮助查看一下，我们从下午5点半左右一直跟进到晚上十点左右，在远程不能访问用户机器只能远程遥控用户的情况找到了的问题。这个问题比较有意思，我个人觉得其中的调查用到的的命令以及排障的一些方法可以分享一下，所以写下了这篇文章。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6\" title=\"问题的症状\"\u003e问题的症状\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5\" title=\"问题的排查\"\u003e问题的排查\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E9%97%AE%E9%A2%98%E5%88%9D%E6%9F%A5\" title=\"问题初查\"\u003e问题初查\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86\" title=\"重新梳理\"\u003e重新梳理\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E\" title=\"柳暗花明\"\u003e柳暗花明\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E6%80%BB%E7%BB%93\" title=\"总结\"\u003e总结\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0\" title=\"问题原因\"\u003e问题原因\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%85%B6%E5%AE%83%E4%BA%8B%E5%AE%9C\" title=\"其它事宜\"\u003e其它事宜\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E7%9A%84%E7%97%87%E7%8A%B6\"\u003e\u003c/span\u003e问题的症状\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e用户直接在微信里说，他们发现在Kuberbnetes下的某个pod被重启了几百次甚至上千次，于是开启调查这个pod，发现上面的服务时而能够访问，时而不能访问，也就是有一定概率不能访问，不知道是什么原因。而且并不是所有的pod出问题，而只是特定的一两个pod出了网络访问的问题。用户说这个pod运行着Java程序，为了排除是Java的问题，用户用 \u003ccode\u003edocker exec -it\u003c/code\u003e 命令直接到容器内启了一个 Python的 SimpleHttpServer来测试发现也是一样的问题。\u003c/p\u003e\n\u003cp\u003e我们大概知道用户的集群是这样的版本，Kuberbnetes 是1.7，网络用的是flannel的gw模式，Docker版本未知，操作系统CentOS 7.4，直接在物理机上跑docker，物理的配置很高，512GB内存，若干CPU核，上面运行着几百个Docker容器。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-18654\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5\"\u003e\u003c/span\u003e问题的排查\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E5%88%9D%E6%9F%A5\"\u003e\u003c/span\u003e问题初查\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e首先，我们排除了flannel的问题，因为整个集群的网络通信都正常，只有特定的某一两个pod有问题。而用 \u003ccode\u003etelnet ip port\u003c/code\u003e 的命令手工测试网络连接时有很大的概率出现 \u003ccode\u003econnection refused\u003c/code\u003e 错误，大约 1/4的概率，而3/4的情况下是可以正常连接的。\u003c/p\u003e\n\u003cp\u003e当时，我们让用户抓个包看看，然后，用户抓到了有问题的TCP连接是收到了 \u003ccode\u003eSYN\u003c/code\u003e 后，立即返回了 \u003ccode\u003eRST, ACK\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-18655\" src=\"https://coolshell.cn/wp-content/uploads/2018/12/tcpdump.png\" alt=\"\" width=\"700\" height=\"80\"/\u003e\u003c/p\u003e\n\u003cp\u003e我问一下用户这两个IP所在的位置，知道了，\u003ccode\u003e10.233.14.129\u003c/code\u003e 是 \u003ccode\u003edocker0\u003c/code\u003e，\u003ccode\u003e10.233.14.145\u003c/code\u003e 是容器内的IP。所以，这基本上可以排除了所有和kubernets或是flannel的问题，这就是本地的Docker上的网络的问题。\u003c/p\u003e\n\u003cp\u003e对于这样被直接 Reset 的情况，在 \u003ccode\u003etelnet\u003c/code\u003e 上会显示 \u003ccode\u003econnection refused\u003c/code\u003e 的错误信息，对于我个人的经验，这种 \u003ccode\u003eSYN\u003c/code\u003e完直接返回 \u003ccode\u003eRST, ACK\u003c/code\u003e的情况只会有三种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e TCP链接不能建立，不能建立连接的原因基本上是标识一条TCP链接的那五元组不能完成，绝大多数情况都是服务端没有相关的端口号。\u003c/li\u003e\n\u003cli\u003eTCP链接建错误，有可能是因为修改了一些TCP参数，尤其是那些默认是关闭的参数，因为这些参数会导致TCP协议不完整。\u003c/li\u003e\n\u003cli\u003e有防火墙iptables的设置，其中有 \u003ccode\u003eREJECT\u003c/code\u003e 规则。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e因为当时还在开车，在等红灯的时候，我感觉到有点像 NAT 的网络中服务端开启了 \u003ccode\u003etcp_tw_recycle\u003c/code\u003e 和 \u003ccode\u003etcp_tw_reuse\u003c/code\u003e 的症况（详细参看《\u003ca href=\"https://coolshell.cn/articles/11564.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eTCP的那些事（上）\u003c/a\u003e》），所以，让用户查看了一上TCP参数，发现用户一个TCP的参数都没有改，全是默认的，于是我们排除了TCP参数的问题。\u003c/p\u003e\n\u003cp\u003e然后，我也不觉得容器内还会设置上iptables，而且如果有那就是100%的问题，不会时好时坏。所以，我怀疑容器内的端口号没有侦听上，但是马上又好了，这可能会是应用的问题。于是我让用户那边看一下，应用的日志，并用 \u003ccode\u003ekublet describe\u003c/code\u003e看一下运行的情况，并把宿主机的 iptables 看一下。\u003c/p\u003e\n\u003cp\u003e然而，我们发现并没有任何的问题。这时，\u003cstrong\u003e我们失去了所有的调查线索，感觉不能继续下去了……\u003c/strong\u003e\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%87%8D%E6%96%B0%E6%A2%B3%E7%90%86\"\u003e\u003c/span\u003e重新梳理\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这个时候，回到家，大家吃完饭，和用户通了一个电话，把所有的细节再重新梳理了一遍，这个时候，用户提供了一个比较关键的信息—— “\u003cstrong\u003e抓包这个事，在 \u003ccode\u003edocker0\u003c/code\u003e 上可以抓到，然而到了容器内抓不到容器返回 \u003ccode\u003eRST, ACK\u003c/code\u003e \u003c/strong\u003e” ！然而，根据我的知识，我知道在 \u003ccode\u003edocker0\u003c/code\u003e 和容器内的 \u003ccode\u003eveth\u003c/code\u003e 网卡上，中间再也没有什么网络设备了（参看《\u003ca href=\"https://coolshell.cn/articles/17029.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDocker基础技术：LINUX NAMESPACE（下）\u003c/a\u003e》）!\u003c/p\u003e\n\u003cp\u003e于是这个事把我们逼到了最后一种情况 —— IP地址冲突了！\u003c/p\u003e\n\u003cp\u003eLinux下看IP地址冲突还不是一件比较简单事的，而在用户的生产环境下没有办法安装一些其它的命令，所以只能用已有的命令，这个时候，我们发现用户的机器上有 \u003ccode\u003earping\u003c/code\u003e 于是我们用这个命令来检测有没有冲突的IP地址。使用了下面的命令：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ arping -D -I docker0 -c 2 10.233.14.145\n$ echo $?\n\u003c/pre\u003e\n\u003cp\u003e根据文档，\u003ccode\u003e-D\u003c/code\u003e 参数是检测IP地址冲突模式，如果这个命令的退状态是 \u003ccode\u003e0\u003c/code\u003e 那么就有冲突。结果返回了 \u003ccode\u003e1\u003c/code\u003e 。而且，我们用 \u003ccode\u003earping\u003c/code\u003e IP的时候，没有发现不同的mac地址。 \u003cstrong\u003e这个时候，似乎问题的线索又断了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e因为客户那边还在处理一些别的事情，所以，我们在时断时续的情况下工作，而还一些工作都需要用户完成，所以，进展有点缓慢，但是也给我们一些时间思考问题。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%9F%B3%E6%9A%97%E8%8A%B1%E6%98%8E\"\u003e\u003c/span\u003e柳暗花明\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e现在我们知道，IP冲突的可能性是非常大的，但是我们找不出来是和谁的IP冲突了。而且，我们知道只要把这台机器重启一下，问题一定就解决掉了，但是我们觉得这并不是解决问题的方式，因为重启机器可以暂时的解决掉到这个问题，而如果我们不知道这个问题怎么发生的，那么未来这个问题还会再来。而重启线上机器这个成本太高了。\u003c/p\u003e\n\u003cp\u003e于是，我们的好奇心驱使我们继续调查。我让用户 \u003ccode\u003ekubectl delete\u003c/code\u003e 其中两个有问题的pod，因为本来就服务不断重启，所以，删掉也没有什么问题。删掉这两个pod后（一个是IP为 \u003ccode\u003e10.233.14.145\u003c/code\u003e 另一个是 \u003ccode\u003e10.233.14.137\u003c/code\u003e），我们发现，kubernetes在其它机器上重新启动了这两个服务的新的实例。然而，\u003cstrong\u003e在问题机器上，这两个IP地址居然还可以ping得通\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e好了，IP地址冲突的问题可以确认了。因为\u003ccode\u003e10.233.14.xxx\u003c/code\u003e 这个网段是 docker 的，所以，这个IP地址一定是在这台机器上。所以，我们想看看所有的 network namespace 下的 veth 网卡上的IP。\u003c/p\u003e\n\u003cp\u003e在这个事上，我们费了点时间，因为对相关的命令也 很熟悉，所以花了点时间Google，以及看相关的man。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先，我们到 \u003ccode\u003e/var/run/netns\u003c/code\u003e目录下查看系统的network namespace，发现什么也没有。\u003c/li\u003e\n\u003cli\u003e然后，我们到 \u003ccode\u003e/var/run/docker/netns\u003c/code\u003e 目录下查看Docker的namespace，发现有好些。\u003c/li\u003e\n\u003cli\u003e于是，我们用指定位置的方式查看Docker的network namespace里的IP地址\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里要动用 \u003ccode\u003ensenter\u003c/code\u003e 命令，这个命令可以进入到namespace里执行一些命令。比如\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ nsenter --net=/var/run/docker/netns/421bdb2accf1 ifconfig -a\n\u003c/pre\u003e\n\u003cp\u003e上述的命令，到 \u003ccode\u003evar/run/docker/netns/421bdb2accf1\u003c/code\u003e 这个network namespace里执行了 \u003ccode\u003eifconfig -a\u003c/code\u003e 命令。于是我们可以用下面 命令来遍历所有的network namespace。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ ls /var/run/docker/netns | xargs -I {} nsenter --net=/var/run/docker/netns/{} ip addr \n\u003c/pre\u003e\n\u003cp\u003e然后，我们发现了比较诡异的事情。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e10.233.14.145\u003c/code\u003e 我们查到了这个IP，说明，docker的namespace下还有这个IP。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e10.233.14.137\u003c/code\u003e，这个IP没有在docker的network namespace下查到。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有namespace leaking？于是我上网查了一下，发现了一个docker的bug – 在docker remove/stop 一个容器的时候，没有清除相应的network namespace，这个问题被报告到了 \u003ca href=\"https://github.com/moby/moby/issues/31597\"\u003eIssue#31597\u003c/a\u003e 然后被fix在了 \u003ca href=\"https://github.com/moby/moby/pull/31996\"\u003ePR#31996\u003c/a\u003e，并Merge到了 Docker的 17.05版中。而用户的版本是 17.09，应该包含了这个fix。不应该是这个问题，感觉又走不下去了。\u003c/p\u003e\n\u003cp\u003e不过， \u003ccode\u003e10.233.14.137\u003c/code\u003e 这个IP可以ping得通，说明这个IP一定被绑在某个网卡，而且被隐藏到了某个network namespace下。\u003c/p\u003e\n\u003cp\u003e到这里，要查看所有network namespace，只有最后一条路了，那就是到 \u003ccode\u003e/proc/\u003c/code\u003e 目录下，把所有的pid下的 \u003ccode\u003e/proc/\u0026lt;pid\u0026gt;/ns\u003c/code\u003e 目录给穷举出来。好在这里有一个比较方便的命令可以干这个事 ： \u003ccode\u003elsns\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e于是我写下了如下的命令：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ lsns -t net | awk ‘{print $4}\u0026#39; | xargs -t -I {} nsenter -t {}\u0026amp;nbsp;-n ip addr | grep -C 4 \u0026#34;10.233.14.137\u0026#34;\n\u003c/pre\u003e\n\u003cp\u003e解释一下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elsns -t net\u003c/code\u003e 列出所有开了network namespace的进程，其第4列是进程PID\u003c/li\u003e\n\u003cli\u003e把所有开过network namespace的进程PID拿出来，转给 \u003ccode\u003exargs\u003c/code\u003e 命令\u003c/li\u003e\n\u003cli\u003e由 \u003ccode\u003exargs\u003c/code\u003e 命令把这些PID 依次传给 \u003ccode\u003ensenter\u003c/code\u003e 命令，\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003exargs -t\u003c/code\u003e 的意思是会把相关的执行命令打出来，这样我知道是那个PID。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exargs -I {}\u003c/code\u003e  是声明一个占位符来替换相关的PID\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后，我们发现，虽然在 \u003ccode\u003e/var/run/docker/netns\u003c/code\u003e 下没有找到 \u003ccode\u003e10.233.14.137\u003c/code\u003e ，但是在 \u003ccode\u003elsns\u003c/code\u003e 中找到了三个进程，他们都用了\u003ccode\u003e10.233.14.137\u003c/code\u003e 这个IP（冲突了这么多），\u003cstrong\u003e而且他们的MAC地址全是一样的！\u003c/strong\u003e（怪不得arping找不到）。通过\u003ccode\u003eps\u003c/code\u003e 命令，可以查到这三个进程，有两个是java的，还有一个是\u003ccode\u003e/pause\u003c/code\u003e （这个应该是kubernetes的沙盒）。\u003c/p\u003e\n\u003cp\u003e我们继续乘胜追击，穷追猛打，用\u003ccode\u003epstree\u003c/code\u003e命令把整个进程树打出来。发现上述的三个进程的父进程都在多个同样叫 \u003ccode\u003edocker-contiane\u003c/code\u003e 的进程下！\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e这明显还是docker的，但是在\u003ccode\u003edocker ps\u003c/code\u003e 中却找不道相应的容器，什么鬼！快崩溃了……\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e继续看进程树，发现，这些 \u003ccode\u003edocker-contiane\u003c/code\u003e 的进程的父进程不在 \u003ccode\u003edockerd\u003c/code\u003e 下面，而是在 \u003ccode\u003esystemd\u003c/code\u003e 这个超级父进程PID 1下，我靠！进而发现了一堆这样的野进程（这种野进程或是僵尸进程对系统是有害的，至少也是会让系统进入亚健康的状态，因为他们还在占着资源）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003edocker-contiane\u003c/code\u003e 应该是 \u003ccode\u003edockerd\u003c/code\u003e 的子进程，被挂到了 \u003ccode\u003epid 1\u003c/code\u003e 只有一个原因，那就是父进程“飞”掉了，只能找 pid 1 当养父。这说明，这台机器上出现了比较严重的 \u003ccode\u003edockerd\u003c/code\u003e 进程退出的问题，而且是非常规的，因为 \u003ccode\u003esystemd\u003c/code\u003e 之所以要成为 pid 1，其就是要监管所有进程的子子孙孙，居然也没有管理好，说明是个非常规的问题。（注，关于 systemd，请参看《\u003ca href=\"https://coolshell.cn/articles/17998.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux PID 1 和 Systemd \u003c/a\u003e》，关于父子进程的事，请参看《Unix高级环境编程》一书）\u003c/p\u003e\n\u003cp\u003e接下来就要看看 \u003ccode\u003esystemd\u003c/code\u003e 为 \u003ccode\u003edockerd\u003c/code\u003e 记录的日志了…… （然而日志只有3天的了，这3天\u003ccode\u003edockerd\u003c/code\u003e没有任何异常）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%80%BB%E7%BB%93\"\u003e\u003c/span\u003e总结\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e通过这个调查，可以总结一下，\u003c/p\u003e\n\u003cp\u003e1） 对于问题调查，需要比较扎实的基础知识，知道问题的成因和范围。\u003c/p\u003e\n\u003cp\u003e2）如果走不下去了，要重新梳理一下，回头仔细看一下一些蛛丝马迹，认真推敲每一个细节。\u003c/p\u003e\n\u003cp\u003e3） 各种诊断工具要比较熟悉，这会让你事半功倍。\u003c/p\u003e\n\u003cp\u003e4）系统维护和做清洁比较类似，需要经常看看系统中是否有一些僵尸进程或是一些垃圾东西，这些东西要及时清理掉。\u003c/p\u003e\n\u003cp\u003e最后，多说一下，很多人都说，\u003cstrong\u003eDocker适合放在物理机内运行，这并不完全对，因为他们只考虑到了性能成本，没有考虑到运维成本，在这样512GB中启动几百个容器的玩法，其实并不好，因为这本质上是个大单体，因为你一理要重启某些关键进程或是机器，你的影响面是巨大的\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e———————— 更新 2018/12/10 —————————\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E5%8E%9F%E5%9B%A0\"\u003e\u003c/span\u003e问题原因\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e这两天在自己的环境下测试了一下，发现，只要是通过 \u003ccode\u003esystemctl start/stop docker\u003c/code\u003e 这样的命令来启停 Docker， 是可以把所有的进程和资源全部干掉的。这个是没有什么问题的。我唯一能重现用户问题的的操作就是直接 \u003ccode\u003ekill -9 \u0026lt;dockerd pid\u0026gt;\u003c/code\u003e 但是这个事用户应该不会干。而 Docker 如果有 crash 事件时，Systemd 是可以通过 \u003ccode\u003ejournalctl -u docker\u003c/code\u003e 这样的命令查看相关的系统日志的。\u003c/p\u003e\n\u003cp\u003e于是，我找用户了解一下他们在Docker在启停时的问题，用户说，\u003cstrong\u003e他们的执行 \u003ccode\u003esystemctl stop docker\u003c/code\u003e 这个命令的时候，发现这个命令不响应了，有可能就直接按了 \u003ccode\u003eCtrl +C\u003c/code\u003e 了\u003c/strong\u003e！\u003c/p\u003e\n\u003cp\u003e这个应该就是导致大量的 \u003ccode\u003edocker-containe\u003c/code\u003e 进程挂到 \u003ccode\u003ePID 1\u003c/code\u003e 下的原因了。前面说过，用户的一台物理机上运行着上百个容器，所以，那个进程树也是非常庞大的，我想，停服的时候，系统一定是要遍历所有的docker子进程来一个一个发退出信号的，这个过程可能会非常的长。导致操作员以为命令假死，而直接按了 \u003ccode\u003eCtrl + C\u003c/code\u003e ，最后导致很多容器进程并没有终止……\u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B6%E5%AE%83%E4%BA%8B%E5%AE%9C\"\u003e\u003c/span\u003e其它事宜\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e有同学问，为什么我在这个文章里写的是 \u003ccode\u003edocker-containe\u003c/code\u003e 而不是 \u003ccode\u003econtaind\u003c/code\u003e 进程？这是因为被 \u003ccode\u003epstree\u003c/code\u003e 给截断了，用 \u003ccode\u003eps\u003c/code\u003e 命令可以看全，只是进程名的名字有一个 \u003ccode\u003edocker-\u003c/code\u003e的前缀。\u003c/p\u003e\n\u003cp\u003e下面是这两种不同安装包的进程树的差别（其中 \u003ccode\u003esleep\u003c/code\u003e 是我用 \u003ccode\u003ebuybox\u003c/code\u003e 镜像启动的）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003esystemd───dockerd─┬─docker-contained─┬─3*[docker-contained-shim─┬─sleep]\n                  │                 │                    └─9*[{docker-containe}]]\n                  │                 ├─docker-contained-shim─┬─sleep\n                  │                 │                 └─10*[{docker-containe}]\n                  │                 └─14*[{docker-contained-shim}]\n                  └─17*[{dockerd}]\n\u003c/pre\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003esystemd───dockerd─┬─containerd─┬─3*[containerd-shim─┬─sleep]\n                  │            │                 └─9*[{containerd-shim}]\n                  │            ├─2*[containerd-shim─┬─sleep]\n                  │            │                    └─9*[{containerd-shim}]]\n                  │            └─11*[{containerd}]\n                  └─10*[{dockerd}]\n\n\u003c/pre\u003e\n\u003cp\u003e顺便说一下，自从 Docker 1.11版以后，Docker进程组模型就改成上面这个样子了.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edockerd\u003c/code\u003e 是 Docker Engine守护进程，直接面向操作用户。\u003ccode\u003edockerd\u003c/code\u003e 启动时会启动 \u003ccode\u003econtainerd\u003c/code\u003e 子进程，他们之前通过RPC进行通信。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtainerd\u003c/code\u003e 是\u003ccode\u003edockerd\u003c/code\u003e和\u003ccode\u003erunc\u003c/code\u003e之间的一个中间交流组件。他与 \u003ccode\u003edockerd\u003c/code\u003e 的解耦是为了让Docker变得更为的中立，而支持OCI 的标准 。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003econtainerd-shim\u003c/code\u003e  是用来真正运行的容器的，每启动一个容器都会起一个新的shim进程， 它主要通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：\u003ccode\u003e/var/run/docker/libcontainerd/containerID\u003c/code\u003e）， 和运行命令（默认为 \u003ccode\u003erunc\u003c/code\u003e）来创建一个容器。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edocker-proxy\u003c/code\u003e 你有可能还会在新版本的Docker中见到这个进程，这个进程是用户级的代理路由。只要你用 \u003ccode\u003eps -elf\u003c/code\u003e 这样的命令把其命令行打出来，你就可以看到其就是做端口映射的。如果你不想要这个代理的话，你可以在 \u003ccode\u003edockerd\u003c/code\u003e 启动命令行参数上加上：  \u003ccode\u003e--userland-proxy=false\u003c/code\u003e 这个参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e更多的细节，大家可以自行Google。这里推荐两篇文章：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://hackernoon.com/docker-containerd-standalone-runtimes-heres-what-you-should-know-b834ef155426\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDocker, Containerd \u0026amp; Standalone Runtimes — Here’s What You Should Know\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://alexander.holbreich.org/docker-components-explained/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDocker components explained\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17998.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/systemd-1-150x150.jpeg\" alt=\"Linux PID 1 和 Systemd\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17998.html\" class=\"wp_rp_title\"\u003eLinux PID 1 和 Systemd\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/how_to_set_up_an_iSCSI_LUN_with_thin-150x150.jpg\" alt=\"Docker基础技术：DeviceMapper\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_title\"\u003eDocker基础技术：DeviceMapper\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw-150x150.png\" alt=\"Docker基础技术：AUFS\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_title\"\u003eDocker基础技术：AUFS\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/filter-150x150.png\" alt=\"Docker基础技术：Linux CGroup\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux CGroup\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/isolation-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（上）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（上）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/jail_cell-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（下）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（下）\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-18654\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"15cb27fc9a\"\u003e\u003cimg id=\"rating_18654_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(18654, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a5270038e84173b54a7eb6ee-=\"\"/\u003e\u003cimg id=\"rating_18654_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(18654, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a5270038e84173b54a7eb6ee-=\"\"/\u003e\u003cimg id=\"rating_18654_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(18654, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a5270038e84173b54a7eb6ee-=\"\"/\u003e\u003cimg id=\"rating_18654_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(18654, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a5270038e84173b54a7eb6ee-=\"\"/\u003e\u003cimg id=\"rating_18654_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(18654, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-a5270038e84173b54a7eb6ee-=\"\"/\u003e (\u003cstrong\u003e162\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.46\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_18654_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"记一次Kubernetes/Docker网络排障\"/\u003e\u003cmeta itemprop=\"headline\" content=\"记一次Kubernetes/Docker网络排障\"/\u003e\u003cmeta itemprop=\"description\" content=\"昨天周五晚上，临下班的时候，用户给我们报了一个比较怪异的Kubernetes集群下的网络不能正常访问的问题，让我们帮助查看一下，我们从下午5点半左右一直跟进到晚上十点左右，在远程不能访问用户机器只能远程遥控用户的情况找到了的问题。这个问题比较有意思，我个人觉得其中的调查用到的的命令以及排障的一些方法可以分享一下，所以写下了这篇文章。\n\n问题的症状\n\n用户直接在微信里说，他们发现在Kuberbnet...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2018-12-08T11:57:35+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2019-04-21T16:36:39+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/18654.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/18654.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.46\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"162\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-18654-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2018-12-08T11:57:35+08:00",
  "Author": "陈皓"
}