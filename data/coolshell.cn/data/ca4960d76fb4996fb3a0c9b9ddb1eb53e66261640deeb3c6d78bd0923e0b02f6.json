{
  "Source": "coolshell.cn",
  "Title": "Docker基础技术：Linux Namespace（下）",
  "Link": "https://coolshell.cn/articles/17029.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"1ed3889f06f2b5290005187e-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-full wp-image-17084\" src=\"https://coolshell.cn/wp-content/uploads/2015/04/jail_cell.jpg\" alt=\"jail_cell\" width=\"350\" height=\"252\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/04/jail_cell.jpg 350w, https://coolshell.cn/wp-content/uploads/2015/04/jail_cell-300x216.jpg 300w\" sizes=\"(max-width: 350px) 100vw, 350px\"/\u003e在 \u003cstrong\u003e\u003ca title=\"Docker基础技术：Linux Namespace（上）\" href=\"https://coolshell.cn/articles/17010.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDocker基础技术：Linux Namespace（上篇）\u003c/a\u003e\u003c/strong\u003e中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。\u003c/p\u003e\n\u003cp\u003e好，下面我们就介绍一下还剩下的这两个Namespace。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#User_Namespace\" title=\"User Namespace\"\u003eUser Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Network_Namespace\" title=\"Network Namespace\"\u003eNetwork Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#Namespace%E6%96%87%E4%BB%B6\" title=\"Namespace文件\"\u003eNamespace文件\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\" title=\"参考文档\"\u003e参考文档\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"User_Namespace\"\u003e\u003c/span\u003eUser Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eUser Namespace主要是用了CLONE_NEWUSER的参数。使用了这个参数后，内部看到的UID和GID已经与外部不同了，默认显示为65534。那是因为容器找不到其真正的UID所以，设置上了最大的UID（其设置定义在/proc/sys/kernel/overflowuid）。\u003c/p\u003e\n\u003cp\u003e要把容器中的uid和真实系统的uid给映射在一起，需要修改 \u003cstrong\u003e/proc/\u0026lt;pid\u0026gt;/uid_map\u003c/strong\u003e 和 \u003cstrong\u003e/proc/\u0026lt;pid\u0026gt;/gid_map\u003c/strong\u003e 这两个文件。这两个文件的格式为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u003ccode\u003e\u003c/code\u003e\u003c/code\u003e\u003cstrong\u003eID-inside-ns ID-outside-ns length\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-17029\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e第一个字段ID-inside-ns表示在容器显示的UID或GID，\u003c/li\u003e\n\u003cli\u003e第二个字段ID-outside-ns表示容器外映射的真实的UID或GID。\u003c/li\u003e\n\u003cli\u003e第三个字段表示映射的范围，一般填1，表示一一对应。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e比如，把真实的uid=1000映射成容器内的uid=0\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$ cat /proc/2465/uid_map\n         0       1000          1\u003c/pre\u003e\n\u003cp\u003e再比如下面的示例：表示把namespace内部从0开始的uid映射到外部从0开始的uid，其最大范围是无符号32位整形\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e$ cat /proc/$$/uid_map\n         0          0          4294967295\u003c/pre\u003e\n\u003cp\u003e另外，需要注意的是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e写这两个文件的进程需要这个namespace中的CAP_SETUID (CAP_SETGID)权限（可参看\u003ca href=\"http://man7.org/linux/man-pages/man7/capabilities.7.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCapabilities\u003c/a\u003e）\u003c/li\u003e\n\u003cli\u003e写入的进程必须是此user namespace的父或子的user namespace进程。\u003c/li\u003e\n\u003cli\u003e另外需要满如下条件之一：1）父进程将effective uid/gid映射到子进程的user namespace中，2）父进程如果有CAP_SETUID/CAP_SETGID权限，那么它将可以映射到父进程中的任一uid/gid。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些规则看着都烦，我们来看程序吧（下面的程序有点长，但是非常简单，如果你读过《Unix网络编程》上卷，你应该可以看懂）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e#define _GNU_SOURCE\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;sys/wait.h\u0026gt;\n#include \u0026lt;sys/mount.h\u0026gt;\n#include \u0026lt;sys/capability.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;sched.h\u0026gt;\n#include \u0026lt;signal.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\n#define STACK_SIZE (1024 * 1024)\n\nstatic char container_stack[STACK_SIZE];\nchar* const container_args[] = {\n    \u0026#34;/bin/bash\u0026#34;,\n    NULL\n};\n\nint pipefd[2];\n\nvoid set_map(char* file, int inside_id, int outside_id, int len) {\n    FILE* mapfd = fopen(file, \u0026#34;w\u0026#34;);\n    if (NULL == mapfd) {\n        perror(\u0026#34;open file error\u0026#34;);\n        return;\n    }\n    fprintf(mapfd, \u0026#34;%d %d %d\u0026#34;, inside_id, outside_id, len);\n    fclose(mapfd);\n}\n\nvoid set_uid_map(pid_t pid, int inside_id, int outside_id, int len) {\n    char file[256];\n    sprintf(file, \u0026#34;/proc/%d/uid_map\u0026#34;, pid);\n    set_map(file, inside_id, outside_id, len);\n}\n\nvoid set_gid_map(pid_t pid, int inside_id, int outside_id, int len) {\n    char file[256];\n    sprintf(file, \u0026#34;/proc/%d/gid_map\u0026#34;, pid);\n    set_map(file, inside_id, outside_id, len);\n}\n\nint container_main(void* arg)\n{\n\n    printf(\u0026#34;Container [%5d] - inside the container!\\n\u0026#34;, getpid());\n\n    printf(\u0026#34;Container: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\\n\u0026#34;,\n            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());\n\n    /* 等待父进程通知后再往下执行（进程间的同步） */\n    char ch;\n    close(pipefd[1]);\n    read(pipefd[0], \u0026amp;ch, 1);\n\n    printf(\u0026#34;Container [%5d] - setup hostname!\\n\u0026#34;, getpid());\n    //set hostname\n    sethostname(\u0026#34;container\u0026#34;,10);\n\n    //remount \u0026#34;/proc\u0026#34; to make sure the \u0026#34;top\u0026#34; and \u0026#34;ps\u0026#34; show container\u0026#39;s information\n    mount(\u0026#34;proc\u0026#34;, \u0026#34;/proc\u0026#34;, \u0026#34;proc\u0026#34;, 0, NULL);\n\n    execv(container_args[0], container_args);\n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    const int gid=getgid(), uid=getuid();\n\n    printf(\u0026#34;Parent: eUID = %ld;  eGID = %ld, UID=%ld, GID=%ld\\n\u0026#34;,\n            (long) geteuid(), (long) getegid(), (long) getuid(), (long) getgid());\n\n    pipe(pipefd);\n \n    printf(\u0026#34;Parent [%5d] - start a container!\\n\u0026#34;, getpid());\n\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWUSER | SIGCHLD, NULL);\n\n    \n    printf(\u0026#34;Parent [%5d] - Container [%5d]!\\n\u0026#34;, getpid(), container_pid);\n\n    //To map the uid/gid, \n    //   we need edit the /proc/PID/uid_map (or /proc/PID/gid_map) in parent\n    //The file format is\n    //   ID-inside-ns   ID-outside-ns   length\n    //if no mapping, \n    //   the uid will be taken from /proc/sys/kernel/overflowuid\n    //   the gid will be taken from /proc/sys/kernel/overflowgid\n    set_uid_map(container_pid, 0, uid, 1);\n    set_gid_map(container_pid, 0, gid, 1);\n\n    printf(\u0026#34;Parent [%5d] - user/group mapping done!\\n\u0026#34;, getpid());\n\n    /* 通知子进程 */\n    close(pipefd[1]);\n\n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e上面的程序，我们用了一个pipe来对父子进程进行同步，为什么要这样做？因为子进程中有一个execv的系统调用，这个系统调用会把当前子进程的进程空间给全部覆盖掉，我们希望在execv之前就做好user namespace的uid/gid的映射，这样，execv运行的/bin/bash就会因为我们设置了uid为0的inside-uid而变成#号的提示符。\u003c/p\u003e\n\u003cp\u003e整个程序的运行效果如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ id\nuid=1000(hchen) gid=1000(hchen) groups=1000(hchen)\n\nhchen@ubuntu:~$ ./user #\u0026lt;--以hchen用户运行\nParent: eUID = 1000;  eGID = 1000, UID=1000, GID=1000 \nParent [ 3262] - start a container!\nParent [ 3262] - Container [ 3263]!\nParent [ 3262] - user/group mapping done!\nContainer [    1] - inside the container!\nContainer: eUID = 0;  eGID = 0, UID=0, GID=0 #\u0026lt;---Container里的UID/GID都为0了\nContainer [    1] - setup hostname!\n\nroot@container:~# id #\u0026lt;----我们可以看到容器里的用户和命令行提示符是root用户了\nuid=0(root) gid=0(root) groups=0(root),65534(nogroup)\u003c/pre\u003e\n\u003cp\u003e虽然容器里是root，但其实这个容器的/bin/bash进程是以一个普通用户hchen来运行的。这样一来，我们容器的安全性会得到提高。\u003c/p\u003e\n\u003cp\u003e我们注意到，User Namespace是以普通用户运行，但是别的Namespace需要root权限，那么，如果我要同时使用多个Namespace，该怎么办呢？一般来说，我们先用一般用户创建User Namespace，然后把这个一般用户映射成root，在容器内用root来创建其它的Namesapce。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Network_Namespace\"\u003e\u003c/span\u003eNetwork Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eNetwork的Namespace比较啰嗦。在Linux下，我们一般用ip命令创建Network Namespace（Docker的源码中，它没有用ip命令，而是自己实现了ip命令内的一些功能——是用了Raw Socket发些“奇怪”的数据，呵呵）。这里，我还是用ip命令讲解一下。\u003c/p\u003e\n\u003cp\u003e首先，我们先看个图，下面这个图基本上就是Docker在宿主机上的网络示意图（其中的物理网卡并不准确，因为docker可能会运行在一个VM中，所以，这里所谓的“物理网卡”其实也就是一个有可以路由的IP的网卡）\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-17040\" src=\"https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg\" alt=\"network.namespace\" width=\"407\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/04/network.namespace.jpg 886w, https://coolshell.cn/wp-content/uploads/2015/04/network.namespace-300x221.jpg 300w\" sizes=\"(max-width: 407px) 100vw, 407px\"/\u003e\u003c/p\u003e\n\u003cp\u003e上图中，Docker使用了一个私有网段，172.40.1.0，docker还可能会使用10.0.0.0和192.168.0.0这两个私有网段，关键看你的路由表中是否配置了，如果没有配置，就会使用，如果你的路由表配置了所有私有网段，那么docker启动时就会出错了。\u003c/p\u003e\n\u003cp\u003e当你启动一个Docker容器后，你可以使用ip link show或ip addr show来查看当前宿主机的网络情况（我们可以看到有一个docker0，还有一个veth22a38e6的虚拟网卡——给容器用的）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"6,8\"\u003ehchen@ubuntu:~$ ip link show\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state ... \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n2: eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc ...\n    link/ether 00:0c:29:b7:67:7d brd ff:ff:ff:ff:ff:ff\n3: docker0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 ...\n    link/ether 56:84:7a:fe:97:99 brd ff:ff:ff:ff:ff:ff\n5: veth22a38e6: \u0026lt;BROADCAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc ...\n    link/ether 8e:30:2a:ac:8c:d1 brd ff:ff:ff:ff:ff:ff\u003c/pre\u003e\n\u003cp\u003e那么，要做成这个样子应该怎么办呢？我们来看一组命令：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e## 首先，我们先增加一个网桥lxcbr0，模仿docker0\nbrctl addbr lxcbr0\nbrctl stp lxcbr0 off\nifconfig lxcbr0 192.168.10.1/24 up #为网桥设置IP地址\n\n## 接下来，我们要创建一个network namespace - ns1\n\n# 增加一个namesapce 命令为 ns1 （使用ip netns add命令）\nip netns add ns1 \n\n# 激活namespace中的loopback，即127.0.0.1（使用ip netns exec ns1来操作ns1中的命令）\nip netns exec ns1   ip link set dev lo up \n\n## 然后，我们需要增加一对虚拟网卡\n\n# 增加一个pair虚拟网卡，注意其中的veth类型，其中一个网卡要按进容器中\nip link add veth-ns1 type veth peer name lxcbr0.1\n\n# 把 veth-ns1 按到namespace ns1中，这样容器中就会有一个新的网卡了\nip link set veth-ns1 netns ns1\n\n# 把容器里的 veth-ns1改名为 eth0 （容器外会冲突，容器内就不会了）\nip netns exec ns1  ip link set dev veth-ns1 name eth0 \n\n# 为容器中的网卡分配一个IP地址，并激活它\nip netns exec ns1 ifconfig eth0 192.168.10.11/24 up\n\n\n# 上面我们把veth-ns1这个网卡按到了容器中，然后我们要把lxcbr0.1添加上网桥上\nbrctl addif lxcbr0 lxcbr0.1\n\n# 为容器增加一个路由规则，让容器可以访问外面的网络\nip netns exec ns1     ip route add default via 192.168.10.1\n\n# 在/etc/netns下创建network namespce名称为ns1的目录，\n# 然后为这个namespace设置resolv.conf，这样，容器内就可以访问域名了\nmkdir -p /etc/netns/ns1\necho \u0026#34;nameserver 8.8.8.8\u0026#34; \u0026gt; /etc/netns/ns1/resolv.conf\u003c/pre\u003e\n\u003cp\u003e上面基本上就是docker网络的原理了，只不过，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDocker的resolv.conf没有用这样的方式，而是用了\u003ca title=\"Docker基础技术：Linux Namespace（上）\" href=\"https://coolshell.cn/articles/17010.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e上篇中的Mount Namesapce的那种方式\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e另外，docker是用进程的PID来做Network Namespace的名称的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e了解了这些后，你甚至可以为正在运行的docker容器增加一个新的网卡：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003eip link add peerA type veth peer name peerB \nbrctl addif docker0 peerA \nip link set peerA up \nip link set peerB netns ${container-pid} \nip netns exec ${container-pid} ip link set dev peerB name eth1 \nip netns exec ${container-pid} ip link set eth1 up ; \nip netns exec ${container-pid} ip addr add ${ROUTEABLE_IP} dev eth1 ;\u003c/pre\u003e\n\u003cp\u003e上面的示例是我们为正在运行的docker容器，增加一个eth1的网卡，并给了一个静态的可被外部访问到的IP地址。\u003c/p\u003e\n\u003cp\u003e这个需要把外部的“物理网卡”配置成混杂模式，这样这个eth1网卡就会向外通过ARP协议发送自己的Mac地址，然后外部的交换机就会把到这个IP地址的包转到“物理网卡”上，因为是混杂模式，所以eth1就能收到相关的数据，一看，是自己的，那么就收到。这样，Docker容器的网络就和外部通了。\u003c/p\u003e\n\u003cp\u003e当然，无论是Docker的NAT方式，还是混杂模式都会有性能上的问题，NAT不用说了，存在一个转发的开销，混杂模式呢，网卡上收到的负载都会完全交给所有的虚拟网卡上，于是就算一个网卡上没有数据，但也会被其它网卡上的数据所影响。\u003c/p\u003e\n\u003cp\u003e这两种方式都不够完美，我们知道，真正解决这种网络问题需要使用VLAN技术，于是Google的同学们为Linux内核实现了一个\u003ca href=\"https://lwn.net/Articles/620087/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eIPVLAN的驱动\u003c/a\u003e，这基本上就是为Docker量身定制的。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Namespace%E6%96%87%E4%BB%B6\"\u003e\u003c/span\u003eNamespace文件\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e上面就是目前Linux Namespace的玩法。 现在，我来看一下其它的相关东西。\u003c/p\u003e\n\u003cp\u003e让我们运行一下上篇中的那个pid.mnt的程序（也就是PID Namespace中那个mount proc的程序），然后不要退出。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e$ sudo ./pid.mnt \n[sudo] password for hchen: \nParent [ 4599] - start a container!\nContainer [    1] - inside the container!\u003c/pre\u003e\n\u003cp\u003e我们到另一个shell中查看一下父子进程的PID：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ pstree -p 4599\npid.mnt(4599)───bash(4600)\u003c/pre\u003e\n\u003cp\u003e我们可以到proc下（/proc//ns）查看进程的各个namespace的id（内核版本需要3.8以上）。\u003c/p\u003e\n\u003cp\u003e下面是父进程的：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ls -l /proc/4599/ns\ntotal 0\nlrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -\u0026gt; ipc:[4026531839]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -\u0026gt; mnt:[4026531840]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 net -\u0026gt; net:[4026531956]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 pid -\u0026gt; pid:[4026531836]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 user -\u0026gt; user:[4026531837]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 uts -\u0026gt; uts:[4026531838]\u003c/pre\u003e\n\u003cp\u003e下面是子进程的：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ls -l /proc/4600/ns\ntotal 0\nlrwxrwxrwx 1 root root 0  4月  7 22:01 ipc -\u0026gt; ipc:[4026531839]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 mnt -\u0026gt; mnt:[4026532520]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 net -\u0026gt; net:[4026531956]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 pid -\u0026gt; pid:[4026532522]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 user -\u0026gt; user:[4026531837]\nlrwxrwxrwx 1 root root 0  4月  7 22:01 uts -\u0026gt; uts:[4026532521]\u003c/pre\u003e\n\u003cp\u003e我们可以看到，其中的ipc，net，user是同一个ID，而mnt,pid,uts都是不一样的。如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，否则则在不同namespace里面。\u003c/p\u003e\n\u003cp\u003e这些文件还有另一个作用，那就是，一旦这些文件被打开，只要其fd被占用着，那么就算PID所属的所有进程都已经结束，创建的namespace也会一直存在。比如：我们可以通过：mount –bind /proc/4600/ns/uts ~/uts 来hold这个namespace。\u003c/p\u003e\n\u003cp\u003e另外，我们在上篇中讲过一个setns的系统调用，其函数声明如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint setns(int fd, int nstype);\u003c/pre\u003e\n\u003cp\u003e其中第一个参数就是一个fd，也就是一个open()系统调用打开了上述文件后返回的fd，比如：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003efd = open(\u0026#34;/proc/4600/ns/nts\u0026#34;, O_RDONLY);  // 获取namespace文件描述符\nsetns(fd, 0); // 加入新的namespace\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\"\u003e\u003c/span\u003e参考文档\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli style=\"list-style-type: none;\"\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://lwn.net/Articles/531114/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eNamespaces in operation\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://man7.org/linux/man-pages/man7/namespaces.7.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux Namespace Man Page\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://crosbymichael.com/creating-containers-part-1.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eCreat Containers – Part 1\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.jtlebi.fr/2013/12/22/introduction-to-linux-namespaces-part-1-uts/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eIntroduction to Linux namespaces\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（应网友card323加入）\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/isolation-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（上）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（上）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1-150x150.png\" alt=\"记一次Kubernetes/Docker网络排障\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_title\"\u003e记一次Kubernetes/Docker网络排障\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/how_to_set_up_an_iSCSI_LUN_with_thin-150x150.jpg\" alt=\"Docker基础技术：DeviceMapper\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_title\"\u003eDocker基础技术：DeviceMapper\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw-150x150.png\" alt=\"Docker基础技术：AUFS\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_title\"\u003eDocker基础技术：AUFS\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/filter-150x150.png\" alt=\"Docker基础技术：Linux CGroup\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux CGroup\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF-150x150.jpeg\" alt=\"eBPF 介绍\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_title\"\u003eeBPF 介绍\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-17029\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"ffb7271c93\"\u003e\u003cimg id=\"rating_17029_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17029, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1ed3889f06f2b5290005187e-=\"\"/\u003e\u003cimg id=\"rating_17029_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17029, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1ed3889f06f2b5290005187e-=\"\"/\u003e\u003cimg id=\"rating_17029_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17029, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1ed3889f06f2b5290005187e-=\"\"/\u003e\u003cimg id=\"rating_17029_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17029, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1ed3889f06f2b5290005187e-=\"\"/\u003e\u003cimg id=\"rating_17029_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17029, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.4, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-1ed3889f06f2b5290005187e-=\"\"/\u003e (\u003cstrong\u003e42\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.36\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_17029_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Docker基础技术：Linux Namespace（下）\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Docker基础技术：Linux Namespace（下）\"/\u003e\u003cmeta itemprop=\"description\" content=\"在 Docker基础技术：Linux Namespace（上篇）中我们了解了，UTD、IPC、PID、Mount 四个namespace，我们模仿Docker做了一个相当相当山寨的镜像。在这一篇中，主要想向大家介绍Linux的User和Network的Namespace。\n\n好，下面我们就介绍一下还剩下的这两个Namespace。\n\nUser Namespace\n\nUser Namespace主要...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2015-04-16T10:19:23+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-08T17:27:19+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/17029.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/17029.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.36\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"42\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-17029-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2015-04-16T10:19:23+08:00",
  "Author": "陈皓"
}