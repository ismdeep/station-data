{
  "Source": "coolshell.cn",
  "Title": "从LongAdder看更高效的无锁实现",
  "Link": "https://coolshell.cn/articles/11454.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"15052bf065efb9a871a085d1-text/javascript\"\u003e\u003c/script\u003e\u003cstrong\u003e（感谢 \u003ca href=\"http://weibo.com/liuinsect\" target=\"_blank\"\u003e@jd刘锟洋\u003c/a\u003e 投稿，更多文章参看他的博客：\u003ca href=\"http://www.liuinsect.com/\" target=\"_blank\"\u003e码梦为生\u003c/a\u003e）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e原文链接\u003c/strong\u003e：《\u003ca href=\"http://www.liuinsect.com/2014/04/15/%E6%AF%94atomiclong%E8%BF%98%E9%AB%98%E6%95%88%E7%9A%84longadder-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/\" target=\"_blank\"\u003e比AtomicLong还高效的LongAdder 源码解析\u003c/a\u003e》\u003c/p\u003e\n\u003cp\u003e接触到AtomicLong的原因是在看guava的LoadingCache相关代码时，关于LoadingCache，其实思路也非常简单清晰：用模板模式解决了缓存不命中时获取数据的逻辑，这个思路我早前也正好在项目中使用到。\u003c/p\u003e\n\u003cp\u003e言归正传，为什么说LongAdder引起了我的注意，原因有二：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e作者是Doug lea ，地位实在举足轻重。\u003c/li\u003e\n\u003cli\u003e他说这个比AtomicLong高效。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e我们知道，AtomicLong已经是非常好的解决方案了，涉及并发的地方都是使用CAS操作，在硬件层次上去做 compare and set操作。效率非常高。\u003c/p\u003e\n\u003cp\u003e因此，我决定研究下，为什么LongAdder比AtomicLong高效。\u003c/p\u003e\n\u003cp\u003e首先，看LongAdder的继承树：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"alignnone size-full wp-image-209 aligncenter\" alt=\"la1\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la1.png\" width=\"431\" height=\"104\"/\u003e\u003c/p\u003e\n\u003cp\u003e继承自Striped64，这个类包装了一些很重要的内部类和操作。稍候会看到。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11454\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e正式开始前，强调下，我们知道，AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e再看看LongAdder的方法：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-210 aligncenter\" alt=\"la2\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la2.png\" width=\"472\" height=\"436\"/\u003e\u003cbr/\u003e\n怪不得可以和AtomicLong作比较，连API都这么像。我们随便挑一个API入手分析，这个API通了，其他API都大同小异，因此，我选择了add这个方法。事实上,其他API也都依赖这个方法。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-211 aligncenter\" alt=\"la3\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png\" width=\"701\" height=\"281\"/\u003e\u003cbr/\u003e\nLongAdder中包含了一个Cell 数组，Cell是Striped64的一个内部类，顾名思义，Cell 代表了一个最小单元，这个单元有什么用，稍候会说道。先看定义：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-212 aligncenter\" alt=\"la4\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la4.png\" width=\"686\" height=\"649\"/\u003e\u003cbr/\u003e\nCell内部有一个非常重要的value变量，并且提供了一个CAS更新其值的方法。\u003c/p\u003e\n\u003cp\u003e回到add方法：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-211 aligncenter\" alt=\"la3\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png\" width=\"701\" height=\"281\"/\u003e\u003c/p\u003e\n\u003cp\u003e这里，我有个疑问，AtomicLong已经使用CAS指令，非常高效了（比起各种锁），LongAdder如果还是用CAS指令更新值，怎么可能比AtomicLong高效了？ 何况内部还这么多判断！！！\u003c/p\u003e\n\u003cp\u003e这是我开始时最大的疑问，所以，我猜想，难道有比CAS指令更高效的方式出现了？ 带着这个疑问，继续。\u003c/p\u003e\n\u003cp\u003e第一if 判断，第一次调用的时候cells数组肯定为null,因此，进入casBase方法：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-213 aligncenter\" alt=\"la5\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la5.png\" width=\"772\" height=\"81\"/\u003e\u003cbr/\u003e\n原子更新base没啥好说的，如果更新成功，本地调用开始返回，否则进入分支内部。\u003c/p\u003e\n\u003cp\u003e什么时候会更新失败？ 没错，并发的时候，好戏开始了，AtomicLong的处理方式是死循环尝试更新，直到成功才返回，而LongAdder则是进入这个分支。\u003c/p\u003e\n\u003cp\u003e分支内部，通过一个Threadlocal变量threadHashCode 获取一个HashCode对象，该HashCode对象依然是Striped64类的内部类，看定义：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-214 aligncenter\" alt=\"la6\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la6.png\" width=\"734\" height=\"203\"/\u003e\u003cbr/\u003e\n有个code变量，保存了一个非0的随机数随机值。\u003c/p\u003e\n\u003cp\u003e回到add方法：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"alignnone size-full wp-image-211 aligncenter\" alt=\"la3\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la3.png\" width=\"701\" height=\"281\"/\u003e\u003c/p\u003e\n\u003cp\u003e拿到该线程相关的HashCode对象后，获取它的code变量，as[(n-1)\u0026amp;h] 这句话相当于对h取模，只不过比起取模，因为是 与 的运算所以效率更高。\u003c/p\u003e\n\u003cp\u003e计算出一个在Cells 数组中当先线程的HashCode对应的 索引位置，并将该位置的Cell 对象拿出来用CAS更新它的value值。\u003c/p\u003e\n\u003cp\u003e当然，如果as 为null 并且更新失败，才会进入retryUpdate方法。\u003c/p\u003e\n\u003cp\u003e看到这里我想应该有很多人明白为什么LongAdder会比AtomicLong更高效了，没错，唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。 那怎么解决？\u003cstrong\u003e LongAdder给了我们一个非常容易想到的解决方案：减少并发，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，分段更新！！！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这样，线程数再多也会分担到多个value上去更新，只需要增加value就可以降低 value的 “热度”  AtomicLong中的 恶性循环不就解决了吗？ cells 就是这个 “段” cell中的value 就是存放更新值的， 这样，\u003cstrong\u003e当我需要总数时，把cells 中的value都累加一下不就可以了么！！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e当然，聪明之处远远不仅仅这里，在看看add方法中的代码，casBase方法可不可以不要，直接分段更新,上来就计算 索引位置，然后更新value？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e答案是不好，不是不行，因为，casBase操作等价于AtomicLong中的CAS操作，要知道，LongAdder这样的处理方式是有坏处的，分段操作必然带来空间上的浪费，可以空间换时间，但是，\u003cstrong\u003e能不换就不换，看空间时间都节约~！\u003c/strong\u003e 所以，\u003cstrong\u003ecasBase操作保证了在低并发时，不会立即进入分支做分段更新操作\u003c/strong\u003e，因为低并发时，casBase操作基本都会成功，只有并发高到一定程度了，才会进入分支，所以，Doug Lea对该类的说明是：\u003cstrong\u003e 低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效！\u003c/strong\u003e\u003c/p\u003e\n\u003cp style=\"text-align: center;\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\" wp-image-215 aligncenter\" alt=\"la7\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/la7.png\" width=\"750\" height=\"331\"/\u003e\u003c/p\u003e\n\u003cp\u003e但是，Doung Lea 还是没这么简单，聪明之处还没有结束……\u003c/p\u003e\n\u003cp\u003e如此，retryUpdate中做了什么事，也基本略知一二了，因为cell中的value都更新失败(说明该索引到这个cell的线程也很多，并发也很高时) 或者cells数组为空时才会调用retryUpdate,\u003c/p\u003e\n\u003cp\u003e因此，\u003cstrong\u003eretryUpdate里面应该会做两件事：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e扩容，将cells数组扩大\u003c/strong\u003e，降低每个cell的并发量，同样，这也意味着cells数组的rehash动作。\u003c/li\u003e\n\u003cli\u003e \u003cstrong\u003e给空的cells变量赋一个新的Cell数组\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e是不是这样呢？ 继续看代码：\u003c/p\u003e\n\u003cp\u003e代码比较长，变成文本看看，为了方便大家看if else 分支，对应的  { } 我用相同的颜色标注出来。可以看到，这个时候Doug Lea才愿意使用死循环保证更新成功~！\u003c/p\u003e\n\u003cpre data-enlighter-language=\"java\" class=\"EnlighterJSRAW\"\u003e  final void retryUpdate(long x, HashCode hc, boolean wasUncontended) {\n        int h = hc.code;\n        boolean collide = false;                // True if last slot nonempty\n        for (;;) {\n            Cell[] as; Cell a; int n; long v;\n            if ((as = cells) != null \u0026amp;\u0026amp; (n = as.length) \u0026gt; 0) {// 分支1\n                if ((a = as[(n - 1) \u0026amp; h]) == null) {\n                    if (busy == 0) {            // Try to attach new Cell\n                        Cell r = new Cell(x);   // Optimistically create\n                        if (busy == 0 \u0026amp;\u0026amp; casBusy()) {\n                            boolean created = false;\n                            try {               // Recheck under lock\n                                Cell[] rs; int m, j;\n                                if ((rs = cells) != null \u0026amp;\u0026amp;\n                                        (m = rs.length) \u0026gt; 0 \u0026amp;\u0026amp;\n                                        rs[j = (m - 1) \u0026amp; h] == null) {\n                                    rs[j] = r;\n                                    created = true;\n                                }\n                            } finally {\n                                busy = 0;\n                            }\n                            if (created)\n                                break;\n                            continue;           // Slot is now non-empty\n                        }\n                    }\n                    collide = false;\n                }\n                else if (!wasUncontended)       // CAS already known to fail\n                    wasUncontended = true;      // Continue after rehash\n                else if (a.cas(v = a.value, fn(v, x)))\n                    break;\n                else if (n \u0026gt;= NCPU || cells != as)\n                    collide = false;            // At max size or stale\n                else if (!collide)\n                    collide = true;\n                else if (busy == 0 \u0026amp;\u0026amp; casBusy()) {\n                    try {\n                        if (cells == as) {      // Expand table unless stale\n                            Cell[] rs = new Cell[n \u0026lt;\u0026lt; 1];\n                            for (int i = 0; i \u0026lt; n; ++i)\n                                rs[i] = as[i];\n                            cells = rs;\n                        }\n                    } finally {\n                        busy = 0;\n                    }\n                    collide = false;\n                    continue;                   // Retry with expanded table\n                }\n                h ^= h \u0026lt;\u0026lt; 13;                   // Rehash  h ^= h \u0026gt;\u0026gt;\u0026gt; 17;\n                h ^= h \u0026lt;\u0026lt; 5;\n            }\n            else if (busy == 0 \u0026amp;\u0026amp; cells == as \u0026amp;\u0026amp; casBusy()) {//分支2\n                boolean init = false;\n                try {                           // Initialize table\n                    if (cells == as) {\n                        Cell[] rs = new Cell[2];\n                        rs[h \u0026amp; 1] = new Cell(x);\n                        cells = rs;\n                        init = true;\n                    }\n                } finally {\n                    busy = 0;\n                }\n                if (init)\n                    break;\n            }\n            else if (casBase(v = base, fn(v, x)))\n                break;                          // Fall back on using base\n        }\n        hc.code = h;                            // Record index for next time\n    }\n\n\u003c/pre\u003e\n\u003cp\u003e分支2中，为cells为空的情况，需要new 一个Cell数组。\u003c/p\u003e\n\u003cp\u003e分支1分支中，略复杂一点点：\u003c/p\u003e\n\u003cp\u003e注意，几个分支中都提到了busy这个方法，这个可以理解为一个CAS实现的锁，只有在需要更新cells数组的时候才会更新该值为1，如果更新失败，则说明当前有线程在更新cells数组，当前线程需要等待。重试。\u003c/p\u003e\n\u003cp\u003e回到分支1中，这里首先判断当前cells数组中的索引位置的cell元素是否为空，如果为空，则添加一个cell到数组中。\u003c/p\u003e\n\u003cp\u003e否则更新 标示冲突的标志位wasUncontended 为 true ，重试。\u003c/p\u003e\n\u003cp\u003e否则，再次更新cell中的value,如果失败，重试。\u003c/p\u003e\n\u003cp\u003e。。。。。。。一系列的判断后\u003cspan style=\"line-height: 1.5em;\"\u003e，如果还是失败，下下下策，reHash,直接将cells数组扩容一倍，并更新当前线程的hash值，保证下次更新能尽可能成功。\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e可以看到，LongAdder确实用了很多心思减少并发量，并且，每一步都是在”没有更好的办法“的时候才会选择更大开销的操作，从而尽可能的用最最简单的办法去完成操作。追求简单，但是绝对不粗暴。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e———————\u003cstrong\u003e陈皓注————————\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e最后留给大家思考的两个问题：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）是不是AtomicLong可以被废了？\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）如果cell被创建后，原来的casBase就不走了，会不会性能更差？\u003c/p\u003e\n\u003cp\u003e———————liuinsect\u003cstrong\u003e注————————\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e昨天和左耳朵耗子简单讨论了下，发现左耳朵耗子,耗哥对读者思维的引导还是非常不错的，在第一次发现这个类后，对里面的实现又提出了更多的问题，引导大家思考，值得学习。\u003c/p\u003e\n\u003cp\u003e我们 发现的问题有这么几个（包括以上的问题），自己简单总结下，欢迎大家讨论：\u003c/p\u003e\n\u003cp\u003e1. jdk 1.7中是不是有这个类？\u003cbr/\u003e\n我确认后，结果如下：    jdk-7u51 版本上还没有  但是jdk-8u20版本上已经有了。代码基本一样 ，增加了对double类型的支持和删除了一些冗余的代码。有兴趣的同学可以去下载下JDK 1.8看看\u003c/p\u003e\n\u003cp\u003e2. base有没有参与汇总？\u003cbr/\u003e\nbase在调用intValue等方法的时候是会汇总的：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.liuinsect.com/wp-content/uploads/2014/04/LA101.bmp\"\u003e\u003cimg decoding=\"async\" alt=\"LA10\" src=\"http://www.liuinsect.com/wp-content/uploads/2014/04/LA101.bmp\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e3. 如果cell被创建后，原来的casBase就不走了，会不会性能更差？ base的顺序可不可以调换?\u003cbr/\u003e\n\u003cspan style=\"line-height: 1.5em;\"\u003e    刚开始我想可不可以调换add方法中的判断顺序，比如，先做casBase的判断？ 仔细思考后认为还是 不调换可能更好，调换后每次都要CAS一下，在高并发时，失败几率非常高，并且是恶性循环，比起一次判断，后者的开销明显小很多，还没有副作用（上一个问题，base变量在sum时base是会被统计的，并不会丢掉base的值）。因此，不调换可能会更好。\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e4. AtomicLong可不可以废掉？\u003cbr/\u003e\n我的想法是可以废掉了，因为，虽然LongAdder在空间上占用略大，但是，它的性能已经足以说明一切了,无论是从节约空的角度还是执行效率上，AtomicLong基本没有优势了，具体看这个测试（感谢\u003ca id=\"commentauthor-1431785\" href=\"http://lianming.info/\" rel=\"external nofollow\"\u003eLemon\u003c/a\u003e的回复）:http://blog.palominolabs.com/2014/02/10/java-8-performance-improvements-longadder-vs-atomiclong/\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\n\u003c/p\u003e\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/8239.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/09/lock_free_bicycle-150x150.jpg\" alt=\"无锁队列的实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/8239.html\" class=\"wp_rp_title\"\u003e无锁队列的实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/05/图1-3-150x150.jpg\" alt=\"无锁HashMap的原理与实现\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9703.html\" class=\"wp_rp_title\"\u003e无锁HashMap的原理与实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9169.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/02/Disruptor-150x150.png\" alt=\"并发框架Disruptor译文\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9169.html\" class=\"wp_rp_title\"\u003e并发框架Disruptor译文\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9606.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/05/race_condition-150x150.jpg\" alt=\"疫苗：Java HashMap的死循环\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9606.html\" class=\"wp_rp_title\"\u003e疫苗：Java HashMap的死循环\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/6424.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/20.jpg\" alt=\"Hash Collision DoS 问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/6424.html\" class=\"wp_rp_title\"\u003eHash Collision DoS 问题\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11175.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/03/cow-copy-150x150.jpg\" alt=\"Java中的CopyOnWrite容器\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11175.html\" class=\"wp_rp_title\"\u003eJava中的CopyOnWrite容器\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11454\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"eed74bfd6c\"\u003e\u003cimg id=\"rating_11454_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11454, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-15052bf065efb9a871a085d1-=\"\"/\u003e\u003cimg id=\"rating_11454_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11454, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-15052bf065efb9a871a085d1-=\"\"/\u003e\u003cimg id=\"rating_11454_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11454, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-15052bf065efb9a871a085d1-=\"\"/\u003e\u003cimg id=\"rating_11454_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11454, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-15052bf065efb9a871a085d1-=\"\"/\u003e\u003cimg id=\"rating_11454_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11454, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.9, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-15052bf065efb9a871a085d1-=\"\"/\u003e (\u003cstrong\u003e26\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.88\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11454_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"从LongAdder看更高效的无锁实现\"/\u003e\u003cmeta itemprop=\"headline\" content=\"从LongAdder看更高效的无锁实现\"/\u003e\u003cmeta itemprop=\"description\" content=\"（感谢 @jd刘锟洋 投稿，更多文章参看他的博客：码梦为生）\n\n原文链接：《比AtomicLong还高效的LongAdder 源码解析》\n\n接触到AtomicLong的原因是在看guava的LoadingCache相关代码时，关于LoadingCache，其实思路也非常简单清晰：用模板模式解决了缓存不命中时获取数据的逻辑，这个思路我早前也正好在项目中使用到。\n\n言归正传，为什么说Lon...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-04-17T23:11:40+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2014-04-18T17:57:45+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11454.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"liuinsect\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11454.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.88\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"26\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11454-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-04-17T23:11:40+08:00",
  "Author": "liuinsect"
}