{
  "Source": "coolshell.cn",
  "Title": "C++ 对象的内存布局",
  "Link": "https://coolshell.cn/articles/12176.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"3ca566f7af4b527cd0c89a75-text/javascript\"\u003e\u003c/script\u003e07年12月，我写了一篇《\u003ca title=\"C++ 虚函数表解析\" href=\"https://coolshell.cn/articles/12165.html\" target=\"_blank\"\u003eC++虚函数表解析\u003c/a\u003e》的文章，引起了大家的兴趣。有很多朋友对我的文章留了言，有鼓励我的，有批评我的，还有很多问问题的。我在这里一并对大家的留言表示感谢。这也是我为什么再写一篇续言的原因。因为，在上一篇文章中，我用了的示例都是非常简单的，主要是为了说明一些机理上的问题，也是为了图一些表达上方便和简单。不想，这篇文章成为了打开C++对象模型内存布局的一个引子，引发了大家对C++对象的更深层次的讨论。当然，我之前的文章还有很多方面没有涉及，从我个人感觉下来，在谈论虚函数表里，至少有以下这些内容没有涉及：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）有成员变量的情况。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）有重复继承的情况。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）有虚拟继承的情况。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）有钻石型虚拟继承的情况。\u003c/p\u003e\n\u003cp\u003e 这些都是我本篇文章需要向大家说明的东西。所以，这篇文章将会是《\u003ca href=\"https://coolshell.cn/articles/12165.html\" target=\"_blank\"\u003eC++虚函数表解析\u003c/a\u003e》的一个续篇，也是一篇高级进阶的文章。我希望大家在读这篇文章之前对C++有一定的基础和了解，并能先读我的上一篇文章。因为这篇文章的深度可能会比较深，而且会比较杂乱，我希望你在读本篇文章时不会有大脑思维紊乱导致大脑死机的情况。;-)\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0\" title=\"对象的影响因素\"\u003e对象的影响因素\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0\" title=\"知识复习\"\u003e知识复习\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%8D%95%E4%B8%80%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%A7%E6%89%BF\" title=\"单一的一般继承\"\u003e单一的一般继承\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\" title=\"多重继承\"\u003e多重继承\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E9%87%8D%E5%A4%8D%E7%BB%A7%E6%89%BF\" title=\"重复继承\"\u003e重复继承\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E9%92%BB%E7%9F%B3%E5%9E%8B%E5%A4%9A%E9%87%8D%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\" title=\"钻石型多重虚拟继承\"\u003e钻石型多重虚拟继承\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E7%BB%93%E6%9D%9F%E8%AF%AD\" title=\"结束语\"\u003e结束语\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0\"\u003e\u003c/span\u003e对象的影响因素\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e简而言之，我们一个类可能会有如下的影响因素：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）成员变量\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）虚函数（产生虚函数表）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）单一继承（只继承于一个类）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）多重继承（继承多个类）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e5）重复继承（继承的多个父类中其父类有相同的超类）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e6）虚拟继承（使用virtual方式继承，为了保证继承后父类的内存布局只会存在一份）\u003c/p\u003e\n\u003cp\u003e上述的东西通常是C++这门语言在语义方面对对象内部的影响因素，当然，还会有编译器的影响（比如优化），还有字节对齐的影响。在这里我们都不讨论，我们只讨论C++语言上的影响。\u003c/p\u003e\n\u003cp\u003e本篇文章着重讨论下述几个情况下的C++对象的内存布局情况。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-12176\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）\u003cstrong\u003e单一的一般继承\u003c/strong\u003e（带成员变量、虚函数、虚函数覆盖）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）\u003cstrong\u003e单一的虚拟继承\u003c/strong\u003e（带成员变量、虚函数、虚函数覆盖）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）\u003cstrong\u003e多重继承\u003c/strong\u003e（带成员变量、虚函数、虚函数覆盖）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）\u003cstrong\u003e重复多重继承\u003c/strong\u003e（带成员变量、虚函数、虚函数覆盖）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e5）\u003cstrong\u003e钻石型的虚拟多重继承\u003c/strong\u003e（带成员变量、虚函数、虚函数覆盖）\u003c/p\u003e\n\u003cp\u003e我们的目标就是，让事情越来越复杂。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0\"\u003e\u003c/span\u003e知识复习\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们简单地复习一下，我们可以通过对象的地址来取得虚函数表的地址，如：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003etypedef void(*Fun)(void);\n\nBase b;\n\nFun pFun = NULL;\n\ncout \u0026lt;\u0026lt; \u0026#34;虚函数表地址：\u0026#34; \u0026lt;\u0026lt; (int*)(\u0026amp;b) \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;虚函数表 — 第一个函数地址：\u0026#34; \u0026lt;\u0026lt; (int*)*(int*)(\u0026amp;b) \u0026lt;\u0026lt; endl;\n\n// Invoke the first virtual function\npFun = (Fun)*((int*)*(int*)(\u0026amp;b));\npFun();\u003c/pre\u003e\n\u003cp\u003e我们同样可以用这种方式来取得整个对象实例的内存布局。因为这些东西在内存中都是连续分布的，我们只需要使用适当的地址偏移量，我们就可以获得整个内存对象的布局。\u003c/p\u003e\n\u003cp\u003e本篇文章中的例程或内存布局主要使用如下编译器和系统：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e\u003cstrong\u003e1）Windows XP 和 VC++ 2003\u003c/strong\u003e\u003cbr/\u003e\n\u003cstrong\u003e 2）Cygwin 和 G++ 3.4.4\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8D%95%E4%B8%80%E7%9A%84%E4%B8%80%E8%88%AC%E7%BB%A7%E6%89%BF\"\u003e\u003c/span\u003e单一的一般继承\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面，我们假设有如下所示的一个继承关系：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-12178\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/011.jpg\" alt=\"01\" width=\"177\" height=\"366\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/011.jpg 177w, https://coolshell.cn/wp-content/uploads/2014/12/011-145x300.jpg 145w, https://coolshell.cn/wp-content/uploads/2014/12/011-131x270.jpg 131w\" sizes=\"(max-width: 177px) 100vw, 177px\"/\u003e\u003c/p\u003e\n\u003cp\u003e请注意，在这个继承关系中，父类，子类，孙子类都有自己的一个成员变量。而了类覆盖了父类的f()方法，孙子类覆盖了子类的g_child()及其超类的f()。\u003c/p\u003e\n\u003cp\u003e我们的源程序如下所示：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eclass Parent {\npublic:\n    int iparent;\n    Parent ():iparent (10) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34; Parent::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g() { cout \u0026lt;\u0026lt; \u0026#34; Parent::g()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h() { cout \u0026lt;\u0026lt; \u0026#34; Parent::h()\u0026#34; \u0026lt;\u0026lt; endl; }\n\n};\n\nclass Child : public Parent {\npublic:\n    int ichild;\n    Child():ichild(100) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;Child::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g_child() { cout \u0026lt;\u0026lt; \u0026#34;Child::g_child()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h_child() { cout \u0026lt;\u0026lt; \u0026#34;Child::h_child()\u0026#34; \u0026lt;\u0026lt; endl; }\n};\n\nclass GrandChild : public Child{\npublic:\n    int igrandchild;\n    GrandChild():igrandchild(1000) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;GrandChild::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g_child() { cout \u0026lt;\u0026lt; \u0026#34;GrandChild::g_child()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h_grandchild() { cout \u0026lt;\u0026lt; \u0026#34;GrandChild::h_grandchild()\u0026#34; \u0026lt;\u0026lt; endl; }\n};\u003c/pre\u003e\n\u003cp\u003e我们使用以下程序作为测试程序：（下面程序中，我使用了一个int** pVtab 来作为遍历对象内存布局的指针，这样，我就可以方便地像使用数组一样来遍历所有的成员包括其虚函数表了，在后面的程序中，我也是用这样的方法的，请不必感到奇怪，）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003etypedef void(*Fun)(void);\n\nGrandChild gc;\n\nint** pVtab = (int**)\u0026amp;gc;\n\ncout \u0026lt;\u0026lt; \u0026#34;[0] GrandChild::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\nfor (int i=0; (Fun)pVtab[0][i]!=NULL; i++){\n    pFun = (Fun)pVtab[0][i];\n    cout \u0026lt;\u0026lt; \u0026#34;    [\u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34;] \u0026#34;;\n    pFun();\n}\ncout \u0026lt;\u0026lt; \u0026#34;[1] Parent.iparent = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[1] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[2] Child.ichild = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[2] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[3] GrandChild.igrandchild = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[3] \u0026lt;\u0026lt; endl;\u003c/pre\u003e\n\u003cp\u003e其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e[0] GrandChild::_vptr-\u0026gt;\n\u0026lt;pre\u0026gt;    [0] GrandChild::f()\n    [1] Parent::g()\n    [2] Parent::h()\n    [3] GrandChild::g_child()\n    [4] Child::h1()\n    [5] GrandChild::h_grandchild()\n[1] Parent.iparent = 10\n[2] Child.ichild = 100\n[3] GrandChild.igrandchild = 1000\u003c/pre\u003e\n\u003cp\u003e使用图片表示如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12180\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/021.jpg\" alt=\"02\" width=\"500\" height=\"237\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/021.jpg 500w, https://coolshell.cn/wp-content/uploads/2014/12/021-300x142.jpg 300w\" sizes=\"(max-width: 500px) 100vw, 500px\"/\u003e\u003c/p\u003e\n\u003cp\u003e可见以下几个方面：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）虚函数表在最前面的位置。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）成员变量根据其继承和声明顺序依次放在后面。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）在单一的继承中，被overwrite的虚函数在虚函数表中得到了更新。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF\"\u003e\u003c/span\u003e多重继承\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类只overwrite了父类的f()函数，而还有一个是自己的函数（我们这样做的目的是为了用g1()作为一个标记来标明子类的虚函数表）。而且每个类中都有一个自己的成员变量：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12181\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/031.jpg\" alt=\"03\" width=\"328\" height=\"265\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/031.jpg 328w, https://coolshell.cn/wp-content/uploads/2014/12/031-300x242.jpg 300w\" sizes=\"(max-width: 328px) 100vw, 328px\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们的类继承的源代码如下所示：父类的成员初始为10，20，30，子类的为100\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eclass Base1 {\npublic:\n    int ibase1;\n    Base1():ibase1(10) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;Base1::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g() { cout \u0026lt;\u0026lt; \u0026#34;Base1::g()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h() { cout \u0026lt;\u0026lt; \u0026#34;Base1::h()\u0026#34; \u0026lt;\u0026lt; endl; }\n\n};\n\nclass Base2 {\npublic:\n    int ibase2;\n    Base2():ibase2(20) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;Base2::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g() { cout \u0026lt;\u0026lt; \u0026#34;Base2::g()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h() { cout \u0026lt;\u0026lt; \u0026#34;Base2::h()\u0026#34; \u0026lt;\u0026lt; endl; }\n};\n\nclass Base3 {\npublic:\n    int ibase3;\n    Base3():ibase3(30) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;Base3::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g() { cout \u0026lt;\u0026lt; \u0026#34;Base3::g()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void h() { cout \u0026lt;\u0026lt; \u0026#34;Base3::h()\u0026#34; \u0026lt;\u0026lt; endl; }\n};\n\nclass Derive : public Base1, public Base2, public Base3 {\npublic:\n    int iderive;\n    Derive():iderive(100) {}\n    virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;Derive::f()\u0026#34; \u0026lt;\u0026lt; endl; }\n    virtual void g1() { cout \u0026lt;\u0026lt; \u0026#34;Derive::g1()\u0026#34; \u0026lt;\u0026lt; endl; }\n};\u003c/pre\u003e\n\u003cp\u003e我们通过下面的程序来查看子类实例的内存布局：下面程序中，注意我使用了一个s变量，其中用到了sizof(Base)来找下一个类的偏移量。（因为我声明的是int成员，所以是4个字节，所以没有对齐问题。关于内存的对齐问题，大家可以自行试验，我在这里就不多说了）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\" data-enlighter-highlight=\"27,45\"\u003etypedef void(*Fun)(void);\n\nDerive d;\n\nint** pVtab = (int**)\u0026amp;d;\n\ncout \u0026lt;\u0026lt; \u0026#34;[0] Base1::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[0][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;\npFun();\n\npFun = (Fun)pVtab[0][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;pFun();\n\npFun = (Fun)pVtab[0][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;pFun();\n\npFun = (Fun)pVtab[0][3];\ncout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[0][4];\ncout \u0026lt;\u0026lt; \u0026#34;     [4] \u0026#34;; cout\u0026lt;\u0026lt;pFun\u0026lt;\u0026lt;endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[1] Base1.ibase1 = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[1] \u0026lt;\u0026lt; endl;\n\nint s = sizeof(Base1)/4;\n\ncout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;] Base2::_vptr-\u0026gt;\u0026#34;\u0026lt;\u0026lt;endl;\npFun = (Fun)pVtab[s][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;; pFun();\n\nFun = (Fun)pVtab[s][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[s][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[s][3];\nout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;;\ncout\u0026lt;\u0026lt;pFun\u0026lt;\u0026lt;endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;\u0026lt;\u0026lt; s+1 \u0026lt;\u0026lt;\u0026#34;] Base2.ibase2 = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[s+1] \u0026lt;\u0026lt; endl;\n\ns = s + sizeof(Base2)/4;\n\ncout \u0026lt;\u0026lt; \u0026#34;[\u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;] Base3::_vptr-\u0026gt;\u0026#34;\u0026lt;\u0026lt;endl;\npFun = (Fun)pVtab[s][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[s][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[s][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;; pFun();\n\npFun = (Fun)pVtab[s][3];\ncout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;;\ncout\u0026lt;\u0026lt;pFun\u0026lt;\u0026lt;endl;\n\ns++;\ncout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;\u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#34;] Base3.ibase3 = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[s] \u0026lt;\u0026lt; endl;\ns++;\ncout \u0026lt;\u0026lt; \u0026#34;[\u0026#34;\u0026lt;\u0026lt; s \u0026lt;\u0026lt;\u0026#34;] Derive.iderive = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[s] \u0026lt;\u0026lt; endl;\u003c/pre\u003e\n\u003cp\u003e其运行结果如下所示：（在VC++ 2003和G++ 3.4.4下）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e[0] Base1::_vptr-\u0026gt;\n     [0] Derive::f()\n     [1] Base1::g()\n     [2] Base1::h()\n     [3] Driver::g1()\n     [4] 00000000      \u0026lt;== 注意：在GCC下，这里是1\n[1] Base1.ibase1 = 10\n[2] Base2::_vptr-\u0026gt;\n     [0] Derive::f()\n     [1] Base2::g()\n     [2] Base2::h()\n     [3] 00000000      \u0026lt;== 注意：在GCC下，这里是1\n[3] Base2.ibase2 = 20\n[4] Base3::_vptr-\u0026gt;\n     [0] Derive::f()\n     [1] Base3::g()\n     [2] Base3::h()\n     [3] 00000000\n[5] Base3.ibase3 = 30\n[6] Derive.iderive = 100\u003c/pre\u003e\n\u003cp\u003e使用图片表示是下面这个样子：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12182\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/041.jpg\" alt=\"04\" width=\"500\" height=\"287\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/041.jpg 500w, https://coolshell.cn/wp-content/uploads/2014/12/041-300x172.jpg 300w\" sizes=\"(max-width: 500px) 100vw, 500px\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看到：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）  每个父类都有自己的虚表。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）  子类的成员函数被放到了第一个父类的表中。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）  内存布局中，其父类布局依次按声明顺序排列。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）  每个父类的虚表中的f()函数都被overwrite成了子类的f()。这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%87%8D%E5%A4%8D%E7%BB%A7%E6%89%BF\"\u003e\u003c/span\u003e重复继承\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面我们再来看看，发生重复继承的情况。所谓重复继承，也就是某个基类被间接地重复继承了多次。\u003c/p\u003e\n\u003cp\u003e下图是一个继承图，我们重载了父类的f()函数。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12188\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/051.jpg\" alt=\"05\" width=\"253\" height=\"393\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/051.jpg 253w, https://coolshell.cn/wp-content/uploads/2014/12/051-193x300.jpg 193w\" sizes=\"(max-width: 253px) 100vw, 253px\"/\u003e\u003c/p\u003e\n\u003cp\u003e其类继承的源代码如下所示。其中，每个类都有两个变量，一个是整形（4字节），一个是字符（1字节），而且还有自己的虚函数，自己overwrite父类的虚函数。如子类D中，f()覆盖了超类的函数， f1() 和f2() 覆盖了其父类的虚函数，Df()为自己的虚函数。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eclass B\n{\n    public:\n        int ib;\n        char cb;\n    public:\n        B():ib(0),cb(\u0026#39;B\u0026#39;) {}\n\n        virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;B::f()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void Bf() { cout \u0026lt;\u0026lt; \u0026#34;B::Bf()\u0026#34; \u0026lt;\u0026lt; endl;}\n};\nclass B1 :  public B\n{\n    public:\n        int ib1;\n        char cb1;\n    public:\n        B1():ib1(11),cb1(\u0026#39;1\u0026#39;) {}\n\n        virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;B1::f()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void f1() { cout \u0026lt;\u0026lt; \u0026#34;B1::f1()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void Bf1() { cout \u0026lt;\u0026lt; \u0026#34;B1::Bf1()\u0026#34; \u0026lt;\u0026lt; endl;}\n\n};\nclass B2:  public B\n{\n    public:\n        int ib2;\n        char cb2;\n    public:\n        B2():ib2(12),cb2(\u0026#39;2\u0026#39;) {}\n\n        virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;B2::f()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void f2() { cout \u0026lt;\u0026lt; \u0026#34;B2::f2()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void Bf2() { cout \u0026lt;\u0026lt; \u0026#34;B2::Bf2()\u0026#34; \u0026lt;\u0026lt; endl;}\n\n};\n\nclass D : public B1, public B2\n{\n    public:\n        int id;\n        char cd;\n    public:\n        D():id(100),cd(\u0026#39;D\u0026#39;) {}\n\n        virtual void f() { cout \u0026lt;\u0026lt; \u0026#34;D::f()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void f1() { cout \u0026lt;\u0026lt; \u0026#34;D::f1()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void f2() { cout \u0026lt;\u0026lt; \u0026#34;D::f2()\u0026#34; \u0026lt;\u0026lt; endl;}\n        virtual void Df() { cout \u0026lt;\u0026lt; \u0026#34;D::Df()\u0026#34; \u0026lt;\u0026lt; endl;}\n\n};\u003c/pre\u003e\n\u003cp\u003e我们用来存取子类内存布局的代码如下所示：（在VC++ 2003和G++ 3.4.4下）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003etypedef void(*Fun)(void);\nint** pVtab = NULL;\nFun pFun = NULL;\n\nD d;\npVtab = (int**)\u0026amp;d;\ncout \u0026lt;\u0026lt; \u0026#34;[0] D::B1::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[0][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;    pFun();\npFun = (Fun)pVtab[0][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;    pFun();\npFun = (Fun)pVtab[0][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;    pFun();\npFun = (Fun)pVtab[0][3];\ncout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;;    pFun();\npFun = (Fun)pVtab[0][4];\ncout \u0026lt;\u0026lt; \u0026#34;     [4] \u0026#34;;    pFun();\npFun = (Fun)pVtab[0][5];\ncout \u0026lt;\u0026lt; \u0026#34;     [5] 0x\u0026#34; \u0026lt;\u0026lt; pFun \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[1] B::ib = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[1] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[2] B::cb = \u0026#34; \u0026lt;\u0026lt; (char)pVtab[2] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[3] B1::ib1 = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[3] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[4] B1::cb1 = \u0026#34; \u0026lt;\u0026lt; (char)pVtab[4] \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[5] D::B2::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[5][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;    pFun();\npFun = (Fun)pVtab[5][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;    pFun();\npFun = (Fun)pVtab[5][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;    pFun();\npFun = (Fun)pVtab[5][3];\ncout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;;    pFun();\npFun = (Fun)pVtab[5][4];\ncout \u0026lt;\u0026lt; \u0026#34;     [4] 0x\u0026#34; \u0026lt;\u0026lt; pFun \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[6] B::ib = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[6] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[7] B::cb = \u0026#34; \u0026lt;\u0026lt; (char)pVtab[7] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[8] B2::ib2 = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[8] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[9] B2::cb2 = \u0026#34; \u0026lt;\u0026lt; (char)pVtab[9] \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[10] D::id = \u0026#34; \u0026lt;\u0026lt; (int)pVtab[10] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[11] D::cd = \u0026#34; \u0026lt;\u0026lt; (char)pVtab[11] \u0026lt;\u0026lt; endl;\u003c/pre\u003e\n\u003cp\u003e程序运行结果如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12187\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/06.png\" alt=\"06\" width=\"573\" height=\"499\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/06.png 573w, https://coolshell.cn/wp-content/uploads/2014/12/06-300x261.png 300w\" sizes=\"(max-width: 573px) 100vw, 573px\"/\u003e\u003c/p\u003e\n\u003cp\u003e下面是对于子类实例中的虚函数表的图：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12186\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/061.jpg\" alt=\"06\" width=\"400\" height=\"305\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/061.jpg 400w, https://coolshell.cn/wp-content/uploads/2014/12/061-300x228.jpg 300w\" sizes=\"(max-width: 400px) 100vw, 400px\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看见，最顶端的父类B其成员变量存在于B1和B2中，并被D给继承下去了。而在D中，其有B1和B2的实例，于是B的成员在D的实例中存在两份，一份是B1继承而来的，另一份是B2继承而来的。所以，如果我们使用以下语句，则会产生二义性编译错误：\u003c/p\u003e\n\u003cp\u003eD d;\u003cbr/\u003e\nd.ib = 0; //二义性错误\u003cbr/\u003e\nd.B1::ib = 1; //正确\u003cbr/\u003e\nd.B2::ib = 2; //正确\u003c/p\u003e\n\u003cp\u003e注意，上面例程中的最后两条语句存取的是两个变量。虽然我们消除了二义性的编译错误，但B类在D中还是有两个实例，这种继承造成了数据的重复，我们叫这种继承为重复继承。重复的基类数据成员可能并不是我们想要的。所以，C++引入了虚基类的概念。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%92%BB%E7%9F%B3%E5%9E%8B%E5%A4%9A%E9%87%8D%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF\"\u003e\u003c/span\u003e钻石型多重虚拟继承\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e虚拟继承的出现就是为了解决重复继承中多个间接父类的问题的。钻石型的结构是其最经典的结构。也是我们在这里要讨论的结构：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12185\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/071.jpg\" alt=\"07\" width=\"253\" height=\"404\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/071.jpg 253w, https://coolshell.cn/wp-content/uploads/2014/12/071-187x300.jpg 187w\" sizes=\"(max-width: 253px) 100vw, 253px\"/\u003e\u003c/p\u003e\n\u003cp\u003e上述的“重复继承”只需要把B1和B2继承B的语法中加上virtual 关键，就成了虚拟继承，其继承图如下所示：\u003c/p\u003e\n\u003cp\u003e上图和前面的“重复继承”中的类的内部数据和接口都是完全一样的，只是我们采用了虚拟继承：其省略后的源码如下所示：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eclass B {……};\nclass B1 : virtual public B{……};\nclass B2: virtual public B{……};\nclass D : public B1, public B2{ …… };\u003c/pre\u003e\n\u003cp\u003e在查看D之前，我们先看一看单一虚拟继承的情况。下面是一段在VC++2003下的测试程序：（因为VC++和GCC的内存而局上有一些细节上的不同，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint** pVtab = NULL;\nFun pFun = NULL;\n\nB1 bb1;\n\npVtab = (int**)\u0026amp;bb1;\ncout \u0026lt;\u0026lt; \u0026#34;[0] B1::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[0][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;\npFun(); //B1::f1();\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;\npFun = (Fun)pVtab[0][1];\npFun(); //B1::bf1();\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;\ncout \u0026lt;\u0026lt; pVtab[0][2] \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[1] = 0x\u0026#34;;\ncout \u0026lt;\u0026lt; (int*)*((int*)(\u0026amp;bb1)+1) \u0026lt;\u0026lt;endl; //B1::ib1\ncout \u0026lt;\u0026lt; \u0026#34;[2] B1::ib1 = \u0026#34;;\ncout \u0026lt;\u0026lt; (int)*((int*)(\u0026amp;bb1)+2) \u0026lt;\u0026lt;endl; //B1::ib1\ncout \u0026lt;\u0026lt; \u0026#34;[3] B1::cb1 = \u0026#34;;\ncout \u0026lt;\u0026lt; (char)*((int*)(\u0026amp;bb1)+3) \u0026lt;\u0026lt; endl; //B1::cb1\n\ncout \u0026lt;\u0026lt; \u0026#34;[4] = 0x\u0026#34;;\ncout \u0026lt;\u0026lt; (int*)*((int*)(\u0026amp;bb1)+4) \u0026lt;\u0026lt; endl; //NULL\n\ncout \u0026lt;\u0026lt; \u0026#34;[5] B::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[5][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;\npFun(); //B1::f();\npFun = (Fun)pVtab[5][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;\npFun(); //B::Bf();\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;\ncout \u0026lt;\u0026lt; \u0026#34;0x\u0026#34; \u0026lt;\u0026lt; (Fun)pVtab[5][2] \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[6] B::ib = \u0026#34;;\ncout \u0026lt;\u0026lt; (int)*((int*)(\u0026amp;bb1)+6) \u0026lt;\u0026lt;endl; //B::ib\ncout \u0026lt;\u0026lt; \u0026#34;[7] B::cb = \u0026#34;;\n\u003c/pre\u003e\n\u003cp\u003e其运行结果如下（我结出了GCC的和VC++2003的对比）：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12184\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/070.png\" alt=\"070\" width=\"627\" height=\"308\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/070.png 627w, https://coolshell.cn/wp-content/uploads/2014/12/070-300x147.png 300w\" sizes=\"(max-width: 627px) 100vw, 627px\"/\u003e\u003c/p\u003e\n\u003cp\u003e这里，大家可以自己对比一下。关于细节上，我会在后面一并再说。\u003c/p\u003e\n\u003cp\u003e下面的测试程序是看子类D的内存布局，同样是VC++ 2003的（因为VC++和GCC的内存布局上有一些细节上的不同，而VC++的相对要清楚很多，所以这里只给出VC++的程序，GCC下的程序大家可以根据我给出的程序自己仿照着写一个去试一试）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eD d;\n\npVtab = (int**)\u0026amp;d;\ncout \u0026lt;\u0026lt; \u0026#34;[0] D::B1::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[0][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;    pFun(); //D::f1();\npFun = (Fun)pVtab[0][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;    pFun(); //B1::Bf1();\npFun = (Fun)pVtab[0][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;    pFun(); //D::Df();\npFun = (Fun)pVtab[0][3];\ncout \u0026lt;\u0026lt; \u0026#34;     [3] \u0026#34;;\ncout \u0026lt;\u0026lt; pFun \u0026lt;\u0026lt; endl;\n\n//cout \u0026lt;\u0026lt; pVtab[4][2] \u0026lt;\u0026lt; endl;\ncout \u0026lt;\u0026lt; \u0026#34;[1] = 0x\u0026#34;;\ncout \u0026lt;\u0026lt;  (int*)((\u0026amp;dd)+1) \u0026lt;\u0026lt;endl; //????\n\ncout \u0026lt;\u0026lt; \u0026#34;[2] B1::ib1 = \u0026#34;;\ncout \u0026lt;\u0026lt; *((int*)(\u0026amp;dd)+2) \u0026lt;\u0026lt;endl; //B1::ib1\ncout \u0026lt;\u0026lt; \u0026#34;[3] B1::cb1 = \u0026#34;;\ncout \u0026lt;\u0026lt; (char)*((int*)(\u0026amp;dd)+3) \u0026lt;\u0026lt; endl; //B1::cb1\n\n//---------------------\ncout \u0026lt;\u0026lt; \u0026#34;[4] D::B2::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[4][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;    pFun(); //D::f2();\npFun = (Fun)pVtab[4][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;    pFun(); //B2::Bf2();\npFun = (Fun)pVtab[4][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;\ncout \u0026lt;\u0026lt; pFun \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[5] = 0x\u0026#34;;\ncout \u0026lt;\u0026lt; *((int*)(\u0026amp;dd)+5) \u0026lt;\u0026lt; endl; // ???\n\ncout \u0026lt;\u0026lt; \u0026#34;[6] B2::ib2 = \u0026#34;;\ncout \u0026lt;\u0026lt; (int)*((int*)(\u0026amp;dd)+6) \u0026lt;\u0026lt;endl; //B2::ib2\ncout \u0026lt;\u0026lt; \u0026#34;[7] B2::cb2 = \u0026#34;;\ncout \u0026lt;\u0026lt; (char)*((int*)(\u0026amp;dd)+7) \u0026lt;\u0026lt; endl; //B2::cb2\n\ncout \u0026lt;\u0026lt; \u0026#34;[8] D::id = \u0026#34;;\ncout \u0026lt;\u0026lt; *((int*)(\u0026amp;dd)+8) \u0026lt;\u0026lt; endl; //D::id\ncout \u0026lt;\u0026lt; \u0026#34;[9] D::cd = \u0026#34;;\ncout \u0026lt;\u0026lt; (char)*((int*)(\u0026amp;dd)+9) \u0026lt;\u0026lt; endl;//D::cd\n\ncout \u0026lt;\u0026lt; \u0026#34;[10]  = 0x\u0026#34;;\ncout \u0026lt;\u0026lt; (int*)*((int*)(\u0026amp;dd)+10) \u0026lt;\u0026lt; endl;\n//---------------------\ncout \u0026lt;\u0026lt; \u0026#34;[11] D::B::_vptr-\u0026gt;\u0026#34; \u0026lt;\u0026lt; endl;\npFun = (Fun)pVtab[11][0];\ncout \u0026lt;\u0026lt; \u0026#34;     [0] \u0026#34;;    pFun(); //D::f();\npFun = (Fun)pVtab[11][1];\ncout \u0026lt;\u0026lt; \u0026#34;     [1] \u0026#34;;    pFun(); //B::Bf();\npFun = (Fun)pVtab[11][2];\ncout \u0026lt;\u0026lt; \u0026#34;     [2] \u0026#34;;\ncout \u0026lt;\u0026lt; pFun \u0026lt;\u0026lt; endl;\n\ncout \u0026lt;\u0026lt; \u0026#34;[12] B::ib = \u0026#34;;\ncout \u0026lt;\u0026lt; *((int*)(\u0026amp;dd)+12) \u0026lt;\u0026lt; endl; //B::ib\ncout \u0026lt;\u0026lt; \u0026#34;[13] B::cb = \u0026#34;;\ncout \u0026lt;\u0026lt; (char)*((int*)(\u0026amp;dd)+13) \u0026lt;\u0026lt;endl;//B::cb\u003c/pre\u003e\n\u003cp\u003e下面给出运行后的结果（分VC++和GCC两部份）\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-12183\" src=\"https://coolshell.cn/wp-content/uploads/2014/12/07.png\" alt=\"07\" width=\"630\" height=\"530\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/12/07.png 630w, https://coolshell.cn/wp-content/uploads/2014/12/07-300x252.png 300w\" sizes=\"(max-width: 630px) 100vw, 630px\"/\u003e\u003c/p\u003e\n\u003cp\u003e关于虚拟继承的运行结果我就不画图了（前面的作图已经让我产生了很严重的厌倦感，所以就偷个懒了，大家见谅了）\u003c/p\u003e\n\u003cp\u003e在上面的输出结果中，我用不同的颜色做了一些标明。我们可以看到如下的几点：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）无论是GCC还是VC++，除了一些细节上的不同，其大体上的对象布局是一样的。也就是说，先是B1（黄色），然后是B2（绿色），接着是D（灰色），而B这个超类（青蓝色）的实例都放在最后的位置。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）关于虚函数表，尤其是第一个虚表，GCC和VC++有很重大的不一样。但仔细看下来，还是VC++的虚表比较清晰和有逻辑性。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）VC++和GCC都把B这个超类放到了最后，而VC++有一个NULL分隔符把B和B1和B2的布局分开。GCC则没有。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e4）VC++中的内存布局有两个地址我有些不是很明白，在其中我用红色标出了。取其内容是-4。接道理来说，这个指针应该是指向B类实例的内存地址（这个做法就是为了保证重复的父类只有一个实例的技术）。但取值后却不是。这点我目前还并不太清楚，还向大家请教。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e5）GCC的内存布局中在B1和B2中则没有指向B的指针。这点可以理解，编译器可以通过计算B1和B2的size而得出B的偏移量。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%93%E6%9D%9F%E8%AF%AD\"\u003e\u003c/span\u003e结束语\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eC++这门语言是一门比较复杂的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要我们去了解他后面的内存对象。这样我们才能真正的了解C++，从而能够更好的使用C++这门最难的编程语言。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_title\"\u003eAPI设计原则 – Qt官网的设计实践总结\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg\" alt=\"Leetcode 编程训练\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_title\"\u003eLeetcode 编程训练\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif\" alt=\"State Threads 回调终结者\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_title\"\u003eState Threads 回调终结者\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg\" alt=\"C语言的整型溢出问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_title\"\u003eC语言的整型溢出问题\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-12176\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"c4020a2561\"\u003e\u003cimg id=\"rating_12176_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(12176, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-3ca566f7af4b527cd0c89a75-=\"\"/\u003e\u003cimg id=\"rating_12176_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(12176, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-3ca566f7af4b527cd0c89a75-=\"\"/\u003e\u003cimg id=\"rating_12176_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(12176, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-3ca566f7af4b527cd0c89a75-=\"\"/\u003e\u003cimg id=\"rating_12176_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(12176, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-3ca566f7af4b527cd0c89a75-=\"\"/\u003e\u003cimg id=\"rating_12176_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(12176, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-3ca566f7af4b527cd0c89a75-=\"\"/\u003e (\u003cstrong\u003e30\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.97\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_12176_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"C++ 对象的内存布局\"/\u003e\u003cmeta itemprop=\"headline\" content=\"C++ 对象的内存布局\"/\u003e\u003cmeta itemprop=\"description\" content=\"07年12月，我写了一篇《C++虚函数表解析》的文章，引起了大家的兴趣。有很多朋友对我的文章留了言，有鼓励我的，有批评我的，还有很多问问题的。我在这里一并对大家的留言表示感谢。这也是我为什么再写一篇续言的原因。因为，在上一篇文章中，我用了的示例都是非常简单的，主要是为了说明一些机理上的问题，也是为了图一些表达上方便和简单。不想，这篇文章成为了打开C++对象模型内存布局的一个引子，引发了大家对C++...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2008-10-15T09:32:16+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2014-12-04T10:19:21+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/12176.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/12176.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.97\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"30\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-12176-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2008-10-15T09:32:16+08:00",
  "Author": "陈皓"
}