{
  "Source": "coolshell.cn",
  "Title": "从一次经历谈 TIME_WAIT 的那些事",
  "Link": "https://coolshell.cn/articles/22263.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"cabf38fed9a9cd7f5b6d8345-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright\" src=\"https://coolshell.cn/wp-content/uploads/2022/07/wall_clock-300x167.jpeg\" alt=\"\" width=\"400\" height=\"222\"/\u003e今天来讲一讲TCP 的 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 的问题。这个问题尽人皆知，不过，这次遇到的是不太一样的场景，前两天也解决了，正好写篇文章，顺便把 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 的那些事都说一说。对了，这个场景，跟我开源的探活小工具 \u003ca href=\"https://github.com/megaease/easeprobe\"\u003eEaseProbe\u003c/a\u003e 有关，我先说说这个场景里的问题，然后，顺着这个场景跟大家好好说一下这个事。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF\" title=\"问题背景\"\u003e问题背景\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81_TIME_WAIT\" title=\"为什么要 TIME_WAIT\"\u003e为什么要 TIME_WAIT\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\" title=\"解决方案\"\u003e解决方案\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#Go_%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C\" title=\"Go 实际操作\"\u003eGo 实际操作\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E6%80%BB%E7%BB%93\" title=\"总结\"\u003e总结\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF\"\u003e\u003c/span\u003e问题背景\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e先说一下背景，\u003ca href=\"https://github.com/megaease/easeprobe\"\u003eEaseProbe\u003c/a\u003e 是一个轻量独立的用来探活服务健康状况的小工具，支持http/tcp/shell/ssh/tls/host以及各种中间件的探活，然后，直接发送通知到主流的IM上，如：Slack/Telegram/Discrod/Email/Team，包括国内的企业微信/钉钉/飞书， 非常好用，用过的人都说好 😏。\u003c/p\u003e\n\u003cp\u003e这个探活工具在每次探活的时候，必须要从头开始建立整个网络链接，也就是说，需要从头开始进行DNS查询，建立TCP链接，然后进行通信，再关闭链接。这里，我们不会设置 TCP 的 KeepAlive 重用链接，因为探活工具除了要探活所远端的服务，还要探活整个网络的情况，所以，每次探活都需要从新来过，这样才能捕捉得到整个链路的情况。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-22263\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e但是，这样不断的新建链接和关闭链接，根据TCP的状态机，我们知道这会导致在探测端这边出现的 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 的 TCP 链接，根据 TCP 协议的定义，这个 TIME_WAIT 需要等待 2倍的MSL 时间，TCP 链接都会被系统回收，在回收之前，这个链接会占用系统的资源，主要是两个资源，一个是文件描述符，这个还好，可以调整，另一个则是端口号，这个是没法调整的，因为作为发起请求的client来说，在对同一个IP上理论上你只有64K的端口号号可用（实际上系统默认只有近30K，从32,768 到 60,999 一共 60999+1-32768=28,232，你可以通过 \u003ccode\u003esysctl net.ipv4.ip_local_port_range\u003c/code\u003e 查看  ），如果 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 过多，会导致TCP无法建立链接，还会因为资源消耗太多导致整个程序甚至整个系统异常。\u003c/p\u003e\n\u003cp\u003e试想，如果我们以 10秒为周期探测10K的结点，如果TIME_WAIT的超时时间是120秒，那么在第60秒后，等着超时的 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 我们就有可能把某个IP的端口基本用完了，就算还行，系统也有些问题。（注意：我们不仅仅只是TCP，还有HTTP协议，所以，大家不要觉得TCP的四元组只要目标地址不一样就好了，一方面，我们探的是域名，需要访问DNS服务，所以，DNS服务一般是一台服务器，还有，因为HTTPS一般是探API，而且会有网关代理API，所以链接会到同一个网关上。另外就算还可以建出站连接，但是本地程序会因为端口耗尽无法bind了。所以，现实情况并不会像理论情况那样只要四元组不冲突，端口就不会耗尽）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81_TIME_WAIT\"\u003e\u003c/span\u003e为什么要 TIME_WAIT\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e那么，为什么TCP在 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 上要等待一个2MSL的时间？\u003ccode\u003e\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e以前写过篇比较宏观的《TCP的那些事》（\u003ca title=\"TCP 的那些事儿（上）\" href=\"https://coolshell.cn/articles/11564.html\" target=\"_blank\" rel=\"noopener\"\u003e上篇\u003c/a\u003e，\u003ca title=\"TCP 的那些事儿（下）\" href=\"https://coolshell.cn/articles/11609.html\" target=\"_blank\" rel=\"noopener\"\u003e下篇\u003c/a\u003e），这个访问在“上篇”里讲过，这里再说一次，TCP 断链接的时候，会有下面这个来来回回的过程。\u003c/p\u003e\n\u003cp\u003e我们来看主动断链接的最后一个状态 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 后就不需要等待对端回 ack了，而是进入了超时状态。这主要是因为，在网络上，如果要知道我们发出的数据被对方收到了，那我们就需要对方发来一个确认的Ack信息，那问题来了，对方怎么知道自己发出去的ack，被收到了？难道还要再ack一下，这样ack来ack回的，那什么谁也不要玩了……是的，这就是比较著名的【两将军问题】——两个将军需要在一个不稳定的信道上达成对敌攻击时间的协商，A向B派出信鸽，我们明早8点进攻，A怎么知道B收到了信？那需要B向A派出信鸽，ack说我收到了，明早8点开干。但是，B怎么知道A会收到自己的确认信？是不是还要A再确认一下？这样无穷无尽的确认导致这个问题是没有完美解的（我们在《\u003ca href=\"https://coolshell.cn/articles/10910.html#Two_Generals_Problem%EF%BC%88%E4%B8%A4%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%EF%BC%89\" target=\"_blank\" rel=\"noopener\"\u003e分布式事务\u003c/a\u003e》一文中说过这个问题，这里不再重述）\u003c/p\u003e\n\u003cp\u003e所以，我们只能等一个我们认为最大小时来解决两件个问题：\u003c/p\u003e\n\u003cp\u003e1） 为了 \u003cstrong\u003e防止来自一个连接的延迟段\u003c/strong\u003e被依赖于相同四元组（源地址、源端口、目标地址、目标端口）的稍后连接接受（被接受后，就会被马上断掉，TCP状态机紊乱）。虽然，可以通过指定 TCP 的 sequence number 一定范围内才能被接受。但这也只是让问题发生的概率低了一些，对于一个吞吐量大的的应用来说，依然能够出现问题，尤其是在具有大接收窗口的快速连接上。\u003ca title=\"RFC 1337：TCP 中的 TIME-WAIT 暗杀危险\" href=\"https://tools.ietf.org/html/rfc1337\"\u003eRFC 1337\u003c/a\u003e详细解释了当 \u003ccode\u003eTIME-WAIT\u003c/code\u003e状态不足时会发生什么。\u003csup id=\"fnref-rfc1337\"\u003e\u003c/sup\u003e\u003ccode\u003eTIME-WAIT\u003c/code\u003e以下是如果不缩短状态可以避免的示例：\u003c/p\u003e\n\u003cfigure id=\"attachment_22267\" aria-describedby=\"caption-attachment-22267\" style=\"width: 456px\" class=\"wp-caption aligncenter\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22267\" src=\"https://coolshell.cn/wp-content/uploads/2022/07/duplicate-segment.png\" alt=\"\" width=\"456\" height=\"467\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/07/duplicate-segment.png 800w, https://coolshell.cn/wp-content/uploads/2022/07/duplicate-segment-293x300.png 293w, https://coolshell.cn/wp-content/uploads/2022/07/duplicate-segment-768x787.png 768w, https://coolshell.cn/wp-content/uploads/2022/07/duplicate-segment-263x270.png 263w\" sizes=\"(max-width: 456px) 100vw, 456px\"/\u003e\u003cfigcaption id=\"caption-attachment-22267\" class=\"wp-caption-text\"\u003e由于缩短的 TIME-WAIT 状态，后续的 TCP 段已在不相关的连接中被接受（\u003ca href=\"https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux\" target=\"_blank\" rel=\"noopener\"\u003e来源\u003c/a\u003e）\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cp\u003e2）另一个目的是确保\u003cstrong\u003e远端已经关闭了连接\u003c/strong\u003e。当最后一个\u003cem\u003eACK\u003c/em\u003e​​ 丢失时，对端保持该\u003ccode\u003eLAST-ACK\u003c/code\u003e状态。\u003csup id=\"fnref-lastack\"\u003e\u003c/sup\u003e在没有\u003ccode\u003eTIME-WAIT\u003c/code\u003e状态的情况下，可以重新打开连接，而远程端仍然认为先前的连接有效。当它收到一个\u003cem\u003eSYN\u003c/em\u003e段（并且序列号匹配）时，它将以\u003cem\u003eRST\u003c/em\u003e应答，因为它不期望这样的段。新连接将因错误而中止：\u003c/p\u003e\n\u003cp\u003e \u003c/p\u003e\n\u003cfigure id=\"attachment_22268\" aria-describedby=\"caption-attachment-22268\" style=\"width: 559px\" class=\"wp-caption aligncenter\"\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"wp-image-22268\" src=\"https://coolshell.cn/wp-content/uploads/2022/07/last-ack.png\" alt=\"\" width=\"559\" height=\"375\" srcset=\"https://coolshell.cn/wp-content/uploads/2022/07/last-ack.png 783w, https://coolshell.cn/wp-content/uploads/2022/07/last-ack-300x201.png 300w, https://coolshell.cn/wp-content/uploads/2022/07/last-ack-768x515.png 768w, https://coolshell.cn/wp-content/uploads/2022/07/last-ack-403x270.png 403w\" sizes=\"(max-width: 559px) 100vw, 559px\"/\u003e\u003cfigcaption id=\"caption-attachment-22268\" class=\"wp-caption-text\"\u003e如果远端因为最后一个 ACK​​ 丢失而停留在 LAST-ACK 状态，则打开具有相同四元组的新连接将不起作用 （\u003ca href=\"https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux\" target=\"_blank\" rel=\"noopener\"\u003e来源\u003c/a\u003e）\u003c/figcaption\u003e\u003c/figure\u003e\n\u003cp\u003e\u003ccode\u003eTIME_WAIT\u003c/code\u003e 的这个超时时间的值如下所示：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 macOS 上是15秒， \u003ccode\u003esysctl net.inet.tcp | grep net.inet.tcp.msl\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在 Linux 上是 60秒 \u003ccode\u003ecat /proc/sys/net/ipv4/tcp_fin_timeout\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"\u003e\u003c/span\u003e解决方案\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e要解决这个问题，网上一般会有下面这些解法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e把这个超时间调小一些，这样就可以把TCP 的端口号回收的快一些。但是也不能太小，如果流量很大的话，TIME_WAIT一样会被耗尽。\u003c/li\u003e\n\u003cli\u003e设置上 \u003ccode\u003etcp_tw_reuse\u003c/code\u003e 。\u003ca title=\"RFC 1323：高性能 TCP 扩展\" href=\"https://tools.ietf.org/html/rfc1323\"\u003eRFC 1323\u003c/a\u003e提出了一组 TCP 扩展来提高高带宽路径的性能。除其他外，它定义了一个新的 TCP 选项，带有两个四字节\u003cstrong\u003e时间戳字段\u003c/strong\u003e。第一个是发送选项的 TCP 时间戳的当前值，而第二个是从远程主机接收到的最新时间戳。如果新时间戳严格大于为前一个连接记录的最新时间戳。Linux 将重用该状态下的现有 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 连接用于\u003cstrong\u003e出站的链接\u003c/strong\u003e。也就是说，\u003cstrong\u003e这个参数对于入站连接是没有任何用图的。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e设置上 \u003ccode\u003etcp_tw_recycle\u003c/code\u003e 。 这个参数同样依赖于时间戳选项，但会影响进站和出站链接。这个参数会影响NAT环境，也就是一个公司里的所有员工用一个IP地址访问外网的情况。在这种情况下，时间戳条件将禁止在这个公网IP后面的所有设备在一分钟内连接，因为它们不共享相同的时间戳时钟。毫无疑问，禁用此选项要好得多，因为它会导致 \u003cstrong\u003e难以检测\u003c/strong\u003e和\u003cstrong\u003e诊断\u003c/strong\u003e问题。（注：从 Linux 4.10 (commit \u003ca title=\"tcp：为每个连接随机化 tcp 时间戳偏移\" href=\"https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=95a22caee396cef0bb2ca8fafdd82966a49367bb\"\u003e95a22caee396\u003c/a\u003e ) 开始，Linux 将为每个连接随机化时间戳偏移量，从而使该选项完全失效，无论有无\u003cabbr title=\"网络地址解读\"\u003eNAT\u003c/abbr\u003e。它已从 Linux 4.12中完全删除）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于服务器来说，上述的三个访问都不能解决服务器的 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 过多的问题，真正解决问题的就是——\u003cstrong\u003e不作死就不会死，也就是说，服务器不要主动断链接，而设置上KeepAlive后，让客户端主动断链接，这样服务端只会有\u003ccode\u003eCLOSE_WAIT\u003c/code\u003e\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e但是对于用于建立出站连接的探活的 EaseProbe来说，设置上 \u003ccode\u003etcp_tw_reuse\u003c/code\u003e 就可以重用 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 了，但是这依然无法解决 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 过多的问题。\u003c/p\u003e\n\u003cp\u003e然后，过了几天后，我忽然想起来以前在《UNIX 网络编程》上有看到过一个Socket的参数，叫 \u003ccode data-enlighter-language=\"raw\" class=\"EnlighterJSRAW\"\u003e\u0026lt;code\u0026gt;SO_LINGER\u003c/code\u003e，我的编程生涯中从来没有使用过这个设置，这个参数主要是为了延尽关闭来用的，也就是说你应用调用 \u003ccode\u003eclose()\u003c/code\u003e函数时，如果还有数据没有发送完成，则需要等一个延时时间来让数据发完，但是，如果你把延时设置为 0  时，Socket就丢弃数据，并向对方发送一个 \u003ccode\u003eRST\u003c/code\u003e 来终止连接，因为走的是 RST 包，所以就不会有 \u003ccode\u003eTIME_WAIT\u003c/code\u003e 了。\u003c/p\u003e\n\u003cp\u003e这个东西在服务器端永远不要设置，不然，你的客户端就总是看到 TCP 链接错误 “connnection reset by peer”，但是这个参数对于 EaseProbe 的客户来说，简直是太完美了，当EaseProbe 探测完后，直接 reset connection， 即不会有功能上的问题，也不会影响服务器，更不会有烦人的 \u003ccode\u003e TIME_WAIT\u003c/code\u003e 问题。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Go_%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C\"\u003e\u003c/span\u003eGo 实际操作\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在 Golang的标准库代码里，\u003ccode\u003enet.TCPConn\u003c/code\u003e 有个方法 \u003ccode\u003eSetLinger()\u003c/code\u003e可以完成这个事，使用起来也比较简单：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003econn, _ := net.DialTimeout(\u0026#34;tcp\u0026#34;, t.Host, t.Timeout())\n\nif tcpCon, ok := conn.(*net.TCPConn); ok {\n    tcpCon.SetLinger(0)\n}\u003c/pre\u003e\n\u003cp\u003e你需要把一个 \u003ccode\u003enet.Conn\u003c/code\u003e  转型成 \u003ccode\u003enet.TCPConn\u003c/code\u003e，然后就可以调用方法了。\u003c/p\u003e\n\u003cp\u003e但是对于Golang 的标准库中的 HTTP 对象来说，就有点麻烦了，Golang的 http 库把底层的这边连接对象全都包装成私有变量了，你在外面根本获取不到。这篇《\u003ca href=\"https://iximiuz.com/en/posts/go-net-http-setsockopt-example/\" target=\"_blank\" rel=\"noopener\"\u003eHow to Set Go net/http Socket Options – setsockopt() example\u003c/a\u003e 》中给出了下面的方法：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003edialer := \u0026amp;net.Dialer{\n    Control: func(network, address string, conn syscall.RawConn) error {\n        var operr error\n        if err := conn.Control(func(fd uintptr) {\n            operr = syscall.SetsockoptInt(int(fd), unix.SOL_SOCKET, unix.TCP_QUICKACK, 1)\n        }); err != nil {\n            return err\n        }\n        return operr\n    },\n}\n\nclient := \u0026amp;http.Client{\n    Transport: \u0026amp;http.Transport{\n        DialContext: dialer.DialContext,\n    },\n}\u003c/pre\u003e\n\u003cp\u003e上面这个方法非常的低层，需要直接使用setsocketopt这样的系统调用，我其实，还是想使用 \u003ccode\u003eTCPConn.SetLinger(0)\u003c/code\u003e 来完成这个事，即然都被封装好了，最好还是别破坏封闭性碰底层的东西。\u003c/p\u003e\n\u003cp\u003e经过Golang http包的源码阅读和摸索，我使用了下面的方法：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eclient := \u0026amp;http.Client{\n    Timeout: h.Timeout(),\n    Transport: \u0026amp;http.Transport{\n      TLSClientConfig:   tls,\n      DisableKeepAlives: true,\n      DialContext: func(ctx context.Context, network, addr string) (net.Conn, error) {\n        d := net.Dialer{Timeout: h.Timeout()}\n        conn, err := d.DialContext(ctx, network, addr)\n        if err != nil {\n          return nil, err\n        }\n        tcpConn, ok := conn.(*net.TCPConn)\n        if ok {\n          tcpConn.SetLinger(0)\n          return tcpConn, nil\n        }\n        return conn, nil\n      },\n    },\n  }\u003c/pre\u003e\n\u003cp\u003e然后，我找来了全球 T0p 100W的域名，然后在AWS上开了一台服务器，用脚本生成了 TOP 10K 和 20K 的网站来以5s, 10s, 30s, 60s的间隔进行探活，搞到Cloudflare 的 1.1.1.1 DNS 时不时就把我拉黑，最后的测试结果也非常不错，根本 没有 TIME_WAIT 的链接，相关的测试方法、测试数据和测试报告可以参看：\u003ca href=\"https://github.com/megaease/easeprobe/blob/main/docs/Benchmark.md\" target=\"_blank\" rel=\"noopener\"\u003eBenchmark Report\u003c/a\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%80%BB%E7%BB%93\"\u003e\u003c/span\u003e总结\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是几点总结\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTIME_WAIT\u003c/code\u003e 是一个TCP 协议完整性的手段，虽然会有一定的副作用，但是这个设计是非常关键的，最好不要妥协掉。\u003c/li\u003e\n\u003cli\u003e永远不要使用  \u003ccode\u003etcp_tw_recycle\u003c/code\u003e ，这个参数是个巨龙，破坏力极大。\u003c/li\u003e\n\u003cli\u003e服务器端永远不要使用  \u003ccode\u003eSO_LINGER(0)\u003c/code\u003e，而且使用 \u003ccode\u003etcp_tw_reuse\u003c/code\u003e 对服务端意义不大，因为它只对出站流量有用。\u003c/li\u003e\n\u003cli\u003e在服务端上最好不要主动断链接，设置好KeepAlive，重用链接，让客户端主动断链接。\u003c/li\u003e\n\u003cli\u003e在客户端上可以使用 \u003ccode\u003etcp_tw_reuse\u003c/code\u003e  和 \u003ccode\u003eSO_LINGER(0)\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后强烈推荐阅读这篇文章 – \u003ca href=\"https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux\" target=\"_blank\" rel=\"noopener\"\u003eCoping with the TCP TIME-WAIT state on busy Linux servers\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11564.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/05/tin-can-phone-150x150.jpg\" alt=\"TCP 的那些事儿（上）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11564.html\" class=\"wp_rp_title\"\u003eTCP 的那些事儿（上）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/19840.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2019/10/HTTP-770x513-300x200-1-150x150.jpg\" alt=\"HTTP的前世今生\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/19840.html\" class=\"wp_rp_title\"\u003eHTTP的前世今生\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11609.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/05/xin_2001040422167711230318-150x150.jpg\" alt=\"TCP 的那些事儿（下）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11609.html\" class=\"wp_rp_title\"\u003eTCP 的那些事儿（下）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/9859.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/06/Alan-Cox-150x150.jpg\" alt=\"Alan Cox：单向链表中prev指针的妙用\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/9859.html\" class=\"wp_rp_title\"\u003eAlan Cox：单向链表中prev指针的妙用\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/7490.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2012/06/f1-150x150.jpg\" alt=\"性能调优攻略\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/7490.html\" class=\"wp_rp_title\"\u003e性能调优攻略\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/1484.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2009/09/tcp1-150x150.jpg\" alt=\"TCP网络关闭的状态变换时序图\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/1484.html\" class=\"wp_rp_title\"\u003eTCP网络关闭的状态变换时序图\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-22263\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"f453b75861\"\u003e\u003cimg id=\"rating_22263_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22263, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-cabf38fed9a9cd7f5b6d8345-=\"\"/\u003e\u003cimg id=\"rating_22263_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22263, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-cabf38fed9a9cd7f5b6d8345-=\"\"/\u003e\u003cimg id=\"rating_22263_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22263, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-cabf38fed9a9cd7f5b6d8345-=\"\"/\u003e\u003cimg id=\"rating_22263_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22263, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-cabf38fed9a9cd7f5b6d8345-=\"\"/\u003e\u003cimg id=\"rating_22263_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(22263, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-cabf38fed9a9cd7f5b6d8345-=\"\"/\u003e (\u003cstrong\u003e62\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.50\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_22263_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"从一次经历谈 TIME_WAIT 的那些事\"/\u003e\u003cmeta itemprop=\"headline\" content=\"从一次经历谈 TIME_WAIT 的那些事\"/\u003e\u003cmeta itemprop=\"description\" content=\"今天来讲一讲TCP 的 TIME_WAIT 的问题。这个问题尽人皆知，不过，这次遇到的是不太一样的场景，前两天也解决了，正好写篇文章，顺便把 TIME_WAIT 的那些事都说一说。对了，这个场景，跟我开源的探活小工具 EaseProbe 有关，我先说说这个场景里的问题，然后，顺着这个场景跟大家好好说一下这个事。\n\n问题背景\n\n先说一下背景，EaseProbe 是一个轻量独立的用来探活服务健康状况的...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2022-07-19T14:43:39+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2022-10-28T16:37:32+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/22263.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/22263.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.5\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"62\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-22263-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2022-07-19T14:43:39+08:00",
  "Author": "陈皓"
}