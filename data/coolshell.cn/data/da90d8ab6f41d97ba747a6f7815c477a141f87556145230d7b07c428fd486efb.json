{
  "Source": "coolshell.cn",
  "Title": "C语言的整型溢出问题",
  "Link": "https://coolshell.cn/articles/11466.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"6faac77eb6c5ecbde7f35a01-text/javascript\"\u003e\u003c/script\u003e整型溢出有点老生常谈了，bla, bla, bla… 但似乎没有引起多少人的重视。整型溢出会有可能导致缓冲区溢出，缓冲区溢出会导致各种黑客攻击，比如最近OpenSSL的heartbleed事件，就是一个buffer overread的事件。在这里写下这篇文章，希望大家都了解一下整型溢出，编译器的行为，以及如何防范，以写出更安全的代码。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA\" title=\"什么是整型溢出\"\u003e什么是整型溢出\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8D%B1%E5%AE%B3\" title=\"整型溢出的危害\"\u003e整型溢出的危害\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF\" title=\"示例一：整形溢出导致死循环\"\u003e示例一：整形溢出导致死循环\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B4%E5%BD%A2%E8%BD%AC%E5%9E%8B%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA\" title=\"示例二：整形转型时的溢出\"\u003e示例二：整形转型时的溢出\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\" title=\"示例三：分配内存\"\u003e示例三：分配内存\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E7%A4%BA%E4%BE%8B%E5%9B%9B%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\" title=\"示例四：缓冲区溢出导致安全问题\"\u003e示例四：缓冲区溢出导致安全问题\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E7%A4%BA%E4%BE%8B%E4%BA%94%EF%BC%9Asize_t_%E7%9A%84%E6%BA%A2%E5%87%BA\" title=\"示例五：size_t 的溢出\"\u003e示例五：size_t 的溢出\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA\" title=\"关于编译器的行为\"\u003e关于编译器的行为\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96\" title=\"编译器优化\"\u003e编译器优化\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E8%8A%B1%E7%B5%AE%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%A9%E8%9B%8B\" title=\"花絮：编译器的彩蛋\"\u003e花絮：编译器的彩蛋\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-11\" href=\"#%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8B%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA\" title=\"正确检测整型溢出\"\u003e正确检测整型溢出\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-12\" href=\"#%E4%BA%8C%E5%88%86%E5%8F%96%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%BA%A2%E5%87%BA\" title=\"二分取中搜索算法中的溢出\"\u003e二分取中搜索算法中的溢出\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-13\" href=\"#%E4%B8%8A%E6%BA%A2%E5%87%BA%E5%92%8C%E4%B8%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E6%A3%80%E6%9F%A5\" title=\"上溢出和下溢出的检查\"\u003e上溢出和下溢出的检查\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-14\" href=\"#%E5%85%B6%E5%AE%83\" title=\"其它\"\u003e其它\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA\"\u003e\u003c/span\u003e什么是整型溢出\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eC语言的整型问题相信大家并不陌生了。对于整型溢出，分为无符号整型溢出和有符号整型溢出。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对于unsigned整型溢出，C的规范是有定义的\u003c/strong\u003e——“溢出后的数会以2^(8*sizeof(type))作模运算”，也就是说，如果一个unsigned char（1字符，8bits）溢出了，会把溢出的值与256求模。例如：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eunsigned char x = 0xff;\nprintf(\u0026#34;%d\\n\u0026#34;, ++x);\u003c/pre\u003e\n\u003cp\u003e上面的代码会输出：0 （因为0xff + 1是256，与2^8求模后就是0）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e对于signed整型的溢出，C的规范定义是“undefined behavior”\u003c/strong\u003e，也就是说，编译器爱怎么实现就怎么实现。对于大多数编译器来说，算得啥就是啥。比如：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003esigned char x =0x7f; //注：0xff就是-1了，因为最高位是1也就是负数了\nprintf(\u0026#34;%d\\n\u0026#34;, ++x);\u003c/pre\u003e\n\u003cp\u003e上面的代码会输出：-128，因为0x7f + 0x01得到0x80，也就是二进制的1000 0000，符号位为1，负数，后面为全0，就是负的最小数，即-128。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11466\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e另外，千万别以为signed整型溢出就是负数，这个是不定的。比如：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003esigned char x = 0x7f;\nsigned char y = 0x05;\nsigned char r = x * y;\nprintf(\u0026#34;%d\\n\u0026#34;, r);\u003c/pre\u003e\n\u003cp\u003e上面的代码会输出：123\u003c/p\u003e\n\u003cp\u003e相信对于这些大家不会陌生了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E5%8D%B1%E5%AE%B3\"\u003e\u003c/span\u003e整型溢出的危害\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面说一下，整型溢出的危害。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E6%95%B4%E5%BD%A2%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF\"\u003e\u003c/span\u003e示例一：整形溢出导致死循环\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e ... ...\n... ...\nshort len = 0;\n... ...\nwhile(len\u0026lt; MAX_LEN) {\n    len += readFromInput(fd, buf);\n    buf += len;\n}\u003c/pre\u003e\n\u003cp\u003e上面这段代码可能是很多程序员都喜欢写的代码（我在很多代码里看到过多次），其中的MAX_LEN 可能会是个比较大的整型，比如32767，我们知道short是16bits，取值范围是-32768 到 32767 之间。但是，上面的while循环代码有可能会造成整型溢出，而len又是个有符号的整型，所以可能会成负数，导致不断地死循环。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E6%95%B4%E5%BD%A2%E8%BD%AC%E5%9E%8B%E6%97%B6%E7%9A%84%E6%BA%A2%E5%87%BA\"\u003e\u003c/span\u003e示例二：整形转型时的溢出\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint copy_something(char *buf, int len)\n{\n    #define MAX_LEN 256\n    char mybuf[MAX_LEN];\n     ... ...\n     ... ...\n\n     if(len \u0026gt; MAX_LEN){ // \u0026lt;---- [1]\n         return -1;\n     }\n\n     return memcpy(mybuf, buf, len);\n}\u003c/pre\u003e\n\u003cp\u003e上面这个例子中，还是[1]处的if语句，看上去没有会问题，但是len是个signed int，而memcpy则需一个size_t的len，也就是一个unsigned 类型。于是，len会被提升为unsigned，此时，如果我们给len传一个负数，会通过了if的检查，但在memcpy里会被提升为一个正数，于是我们的mybuf就是overflow了。这个会导致mybuf缓冲区后面的数据被重写。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98\"\u003e\u003c/span\u003e示例三：分配内存\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e关于整数溢出导致堆溢出的很典型的例子是，OpenSSH Challenge-Response SKEY/BSD_AUTH 远程缓冲区溢出漏洞。下面这段有问题的代码摘自OpenSSH的代码中的auth2-chall.c中的input_userauth_info_response() 函数:\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003enresp = packet_get_int();\nif (nresp \u0026gt; 0) {\n    response = xmalloc(nresp*sizeof(char*));\n    for (i = 0; i \u0026lt; nresp; i++)\n        response[i] = packet_get_string(NULL);\n}\u003c/pre\u003e\n\u003cp\u003e上面这个代码中，nresp是size_t类型（size_t一般就是unsigned int/long int），这个示例是一个解数据包的示例，一般来说，数据包中都会有一个len，然后后面是data。如果我们精心准备一个len，比如：1073741825（在32位系统上，指针占4个字节，unsigned int的最大值是0xffffffff，我们只要提供0xffffffff/4 的值——0x40000000，这里我们设置了0x4000000 + 1）， nresp就会读到这个值，然后nresp\u003cem\u003esizeof(char\u003c/em\u003e)就成了 1073741825 * 4，于是溢出，结果成为了 0x100000004，然后求模，得到4。于是，malloc(4)，于是后面的for循环1073741825 次，就可以干环事了（经过0x40000001的循环,用户的数据早已覆盖了xmalloc原先分配的4字节的空间以及后面的数据，包括程序代码，函数指针，于是就可以改写程序逻辑。关于更多的东西，你可以看一下这篇文章《\u003ca href=\"http://engj.org/index.php/ej/article/view/112/167\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eSurvey of Protections from Buffer-Overflow Attacks\u003c/a\u003e》）。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B%E5%9B%9B%EF%BC%9A%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%AF%BC%E8%87%B4%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98\"\u003e\u003c/span\u003e示例四：缓冲区溢出导致安全问题\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint func(char *buf1, unsigned int len1,\n         char *buf2, unsigned int len2 )\n{\n   char mybuf[256]; \n\n   if((len1 + len2) \u0026gt; 256){    //\u0026lt;--- [1]\n       return -1;\n   } \n\n   memcpy(mybuf, buf1, len1);\n   memcpy(mybuf + len1, buf2, len2); \n\n   do_some_stuff(mybuf); \n\n   return 0;\n}\u003c/pre\u003e\n\u003cp\u003e上面这个例子本来是想把buf1和buf2的内容copy到mybuf里，其中怕len1 + len2超过256 还做了判断，但是，如果len1+len2溢出了，根据unsigned的特性，其会与2^32求模，所以，基本上来说，上面代码中的[1]处有可能为假的。（注：通常来说，在这种情况下，如果你开启-O代码优化选项，那个if语句块就全部被和谐掉了——被编译器给删除了）比如，你可以测试一下 len1=0x104， len2 = 0xfffffffc 的情况。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A4%BA%E4%BE%8B%E4%BA%94%EF%BC%9Asize_t_%E7%9A%84%E6%BA%A2%E5%87%BA\"\u003e\u003c/span\u003e示例五：size_t 的溢出\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003efor (int i= strlen(s)-1;  i\u0026gt;=0; i--)  { ... }\u003c/pre\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003efor (int i=v.size()-1; i\u0026gt;=0; i--)  { ... }\u003c/pre\u003e\n\u003cp\u003e上面这两个示例是我们经常用的从尾部遍历一个数组的for循环。第一个是字符串，第二个是C++中的vector容器。strlen()和vector::size()返回的都是 size_t，size_t在32位系统下就是一个unsigned int。你想想，如果strlen(s)和v.size() 都是0呢？这个循环会成为个什么情况？于是strlen(s) – 1 和 v.size() – 1 都不会成为 -1，而是成为了 (unsigned int)(-1)，一个正的最大数。导致你的程序越界访问。\u003c/p\u003e\n\u003cp\u003e这样的例子有很多很多，这些整型溢出的问题如果在关键的地方，尤其是在搭配有用户输入的地方，如果被黑客利用了，就会导致很严重的安全问题。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B3%E4%BA%8E%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E8%A1%8C%E4%B8%BA\"\u003e\u003c/span\u003e关于编译器的行为\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在谈一下如何正确的检查整型溢出之前，我们还要来学习一下编译器的一些东西。请别怪我罗嗦。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BC%96%E8%AF%91%E5%99%A8%E4%BC%98%E5%8C%96\"\u003e\u003c/span\u003e编译器优化\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e如何检查整型溢出或是整型变量是否合法有时候是一件很麻烦的事情，就像上面的第四个例子一样，编译的优化参数-O/-O2/-O3基本上会假设你的程序不会有整形溢出。会把你的代码中检查溢出的代码给优化掉。\u003c/p\u003e\n\u003cp\u003e关于编译器的优化，在这里再举个例子，假设我们有下面的代码（又是一个相当相当常见的代码）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint len;\nchar* data;\n\nif (data + len \u0026lt; data){\n    printf(\u0026#34;invalid len\\n\u0026#34;);\n    exit(-1);\n}\n\u003c/pre\u003e\n\u003cp\u003e上面这段代码中，len 和 data 配套使用，我们害怕len的值是非法的，或是len溢出了，于是我们写下了if语句来检查。这段代码在-O的参数下正常。但是在-O2的编译选项下，整个if语句块被优化掉了。\u003c/p\u003e\n\u003cp\u003e你可以写个小程序，在gcc下编译（我的版本是4.4.7，记得加上-O2和-g参数），然后用gdb调试时，用disass /m命信输出汇编，你会看到下面的结果（你可以看到整个if语句块没有任何的汇编代码——直接被编译器和谐掉了）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e7 int len = 10;\n8 char* data = (char *)malloc(len);\n0x00000000004004d4 \u0026lt;+4\u0026gt;: mov $0xa,%edi\n0x00000000004004d9 \u0026lt;+9\u0026gt;: callq 0x4003b8 \u0026lt;malloc@plt\u0026gt;\n\n9\n10 if (data + len \u0026lt; data){\n11 printf(\u0026#34;invalid len\\n\u0026#34;);\n12 exit(-1);\n13 }\n14\n15 }\n0x00000000004004de \u0026lt;+14\u0026gt;: add $0x8,%rsp\n0x00000000004004e2 \u0026lt;+18\u0026gt;: retq\n\u003c/pre\u003e\n\u003cp\u003e对此，你需要把上面 char* 转型成 uintptr_t 或是 size_t，说白了也就是把char*转成unsigned的数据结构，if语句块就无法被优化了。如下所示：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eif ((uintptr_t)data + len \u0026lt; (uintptr_t)data){\n    ... ...\n}\u003c/pre\u003e\n\u003cp\u003e关于这个事，你可以看一下C99的规范说明《 \u003ca href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1124.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eISO/IEC 9899:1999 C specification\u003c/a\u003e 》第 §6.5.6 页，第8点，我截个图如下：（这段话的意思是定义了指针+/-一个整型的行为，如果越界了，则行为是undefined）\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" class=\"aligncenter size-full wp-image-11469\" src=\"https://coolshell.cn/wp-content/uploads/2014/04/c99.jpg\" alt=\"\" width=\"647\" height=\"310\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/04/c99.jpg 647w, https://coolshell.cn/wp-content/uploads/2014/04/c99-300x144.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/04/c99-564x270.jpg 564w\" sizes=\"(max-width: 647px) 100vw, 647px\"/\u003e\u003c/p\u003e\n\u003cp\u003e注意上面标红线的地方，说如果指针指在数组范围内没事，如果越界了就是undefined，也就是说这事交给编译器实现了，编译器想咋干咋干，那怕你想把其优化掉也可以。在这里要重点说一下，\u003cstrong\u003eC语言中的一个大恶魔—— Undefined! 这里都是“野兽出没”的地方，你一定要小心小心再小心\u003c/strong\u003e。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E8%8A%B1%E7%B5%AE%EF%BC%9A%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%BD%A9%E8%9B%8B\"\u003e\u003c/span\u003e花絮：编译器的彩蛋\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e上面说了所谓的undefined行为就全权交给编译器实现，gcc在1.17版本下对于undefined的行为还玩了个彩蛋（\u003ca href=\"https://en.wikipedia.org/wiki/Undefined_behavior#Compiler_easter_eggs\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e参看Wikipedia\u003c/a\u003e）。\u003c/p\u003e\n\u003cp\u003e下面gcc 1.17版本下的遭遇undefined行为时，gcc在unix发行版下玩的彩蛋的源代码。我们可以看到，它会去尝试去执行一些游戏\u003ca href=\"https://en.wikipedia.org/wiki/NetHack\"\u003eNetHack\u003c/a\u003e， \u003ca href=\"https://en.wikipedia.org/wiki/Rogue_%28computer_game%29\"\u003eRogue\u003c/a\u003e 或是Emacs的 \u003ca href=\"https://en.wikipedia.org/wiki/Tower_of_Hanoi#Applications\"\u003eTowers of Hanoi\u003c/a\u003e，如果找不到，就输出一条NB的报错。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eexecl(\u0026#34;/usr/games/hack\u0026#34;, \u0026#34;#pragma\u0026#34;, 0); // try to run the game NetHack\nexecl(\u0026#34;/usr/games/rogue\u0026#34;, \u0026#34;#pragma\u0026#34;, 0); // try to run the game Rogue\n// try to run the Tower\u0026#39;s of Hanoi simulation in Emacs.\nexecl(\u0026#34;/usr/new/emacs\u0026#34;, \u0026#34;-f\u0026#34;,\u0026#34;hanoi\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;-kill\u0026#34;,0);\nexecl(\u0026#34;/usr/local/emacs\u0026#34;,\u0026#34;-f\u0026#34;,\u0026#34;hanoi\u0026#34;,\u0026#34;9\u0026#34;,\u0026#34;-kill\u0026#34;,0); // same as above\nfatal(\u0026#34;You are in a maze of twisty compiler features, all different\u0026#34;);\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%AD%A3%E7%A1%AE%E6%A3%80%E6%B5%8B%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA\"\u003e\u003c/span\u003e正确检测整型溢出\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e在看过编译器的这些行为后，你应该会明白——“\u003cstrong\u003e在整型溢出之前，一定要做检查，不然，就太晚了\u003c/strong\u003e”。\u003c/p\u003e\n\u003cp\u003e我们来看一段代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e void foo(int m, int n)\n{\n    size_t s = m + n;\n    .......\n}\u003c/pre\u003e\n\u003cp\u003e上面这段代码有两个风险：\u003cstrong\u003e1）有符号转无符号\u003c/strong\u003e，\u003cstrong\u003e2）整型溢出\u003c/strong\u003e。这两个情况在前面的那些示例中你都应该看到了。\u003cstrong\u003e所以，你千万不要把任何检查的代码写在 s = m + n 这条语名后面，不然就太晚了\u003c/strong\u003e。undefined行为就会出现了——用句纯正的英文表达就是——“Dragon is here”——你什么也控制不住了。（注意：有些初学者也许会以为size_t是无符号的，而根据优先级 m 和 n 会被提升到unsigned int。其实不是这样的，m 和 n 还是signed int，m + n 的结果也是signed int，然后再把这个结果转成unsigned int 赋值给s）\u003c/p\u003e\n\u003cp\u003e比如，下面的代码是错的：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e void foo(int m, int n)\n{\n    size_t s = m + n;\n    if ( m\u0026gt;0 \u0026amp;\u0026amp; n\u0026gt;0 \u0026amp;\u0026amp; (SIZE_MAX - m \u0026lt; n) ){\n        //error handling...\n    }\n}\u003c/pre\u003e\n\u003cp\u003e上面的代码中，大家要注意 \u003cstrong\u003e(SIZE_MAX – m \u0026lt; n)\u003c/strong\u003e 这个判断，为什么不用m + n \u0026gt; SIZE_MAX呢？因为，如果 m + n 溢出后，就被截断了，所以表达式恒真，也就检测不出来了。另外，这个表达式中，m和n分别会被提升为unsigned。\u003c/p\u003e\n\u003cp\u003e但是上面的代码是错的，因为：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）检查的太晚了，if之前编译器的undefined行为就已经出来了（你不知道什么会发生）。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）就像前面说的一样，(SIZE_MAX – m \u0026lt; n) 可能会被编译器优化掉。\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）另外，SIZE_MAX是size_t的最大值，size_t在64位系统下是64位的，严谨点应该用INT_MAX或是UINT_MAX\u003c/p\u003e\n\u003cp\u003e 所以，正确的代码应该是下面这样：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e void foo(int m, int n)\n{\n    size_t s = 0;\n    if ( m\u0026gt;0 \u0026amp;\u0026amp; n\u0026gt;0 \u0026amp;\u0026amp; ( UINT_MAX - m \u0026lt; n ) ){\n        //error handling...\n        return;\n    }\n    s = (size_t)m + (size_t)n;\n}\u003c/pre\u003e\n\u003cp\u003e在《\u003ca href=\"https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e苹果安全编码规范\u003c/a\u003e》（PDF）中，第28页的代码中：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-11472\" src=\"https://coolshell.cn/wp-content/uploads/2014/04/apple_security_code.jpg\" alt=\"\" width=\"300\" height=\"94\"/\u003e\u003c/p\u003e\n\u003cp\u003e如果n和m都是signed int，那么这段代码是错的。正确的应该像上面的那个例子一样，至少要在n\u003cem\u003em时要把 n 和 m 给 cast 成 size_t。因为，n\u003c/em\u003em可能已经溢出了，已经undefined了，undefined的代码转成size_t已经没什么意义了。（如果m和n是unsigned int，也会溢出），上面的代码仅在m和n是size_t的时候才有效。\u003c/p\u003e\n\u003cp\u003e不管怎么说，《\u003ca href=\"https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e苹果安全编码规范\u003c/a\u003e》绝对值得你去读一读。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%BA%8C%E5%88%86%E5%8F%96%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B8%AD%E7%9A%84%E6%BA%A2%E5%87%BA\"\u003e\u003c/span\u003e二分取中搜索算法中的溢出\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e我们再来看一个二分取中搜索算法（binary search），大多数人都会写成下面这个样子：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint binary_search(int a[], int len, int key)\n{\n    int low = 0; \n    int high = len - 1; \n\n    while ( low\u0026lt;=high ) {\n        int mid = (low + high)/2;\n        if (a[mid] == key) {\n            return mid;\n        }\n        if (key \u0026lt; a[mid]) {\n            high = mid - 1;\n        }else{\n            low = mid + 1;\n        }\n    }\n    return -1;\n}\u003c/pre\u003e\n\u003cp\u003e上面这个代码中，你可能会有这样的想法：\u003c/p\u003e\n\u003cp\u003e1） 我们应该用size_t来做len, low, high, mid这些变量的类型。没错，应该是这样的。但是如果这样，你要小心第四行 int high = len -1; 如果len为0，那么就“high大发了”。\u003c/p\u003e\n\u003cp\u003e2） 无论你用不用size_t。我们在计算mid = (low+high)/2; 的时候，(low + high) 都可以溢出。正确的写法应该是：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint mid = low + (high - low)/2;\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%8A%E6%BA%A2%E5%87%BA%E5%92%8C%E4%B8%8B%E6%BA%A2%E5%87%BA%E7%9A%84%E6%A3%80%E6%9F%A5\"\u003e\u003c/span\u003e上溢出和下溢出的检查\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e前面的代码只判断了正数的上溢出overflow，没有判断负数的下溢出underflow。让们来看看怎么判断：\u003c/p\u003e\n\u003cp\u003e对于加法，还好。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e#include \u0026lt;limits.h\u0026gt;\n\nvoid f(signed int si_a, signed int si_b) {\n    signed int sum;\n    if (((si_b \u0026gt; 0) \u0026amp;\u0026amp; (si_a \u0026gt; (INT_MAX - si_b))) ||\n        ((si_b \u0026lt; 0) \u0026amp;\u0026amp; (si_a \u0026lt; (INT_MIN - si_b)))) {\n        /* Handle error */\n        return;\n    }\n    sum = si_a + si_b;\n}\u003c/pre\u003e\n\u003cp\u003e对于乘法，就会很复杂（下面的代码太夸张了）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003evoid func(signed int si_a, signed int si_b)\n{\n  signed int result;\n  if (si_a \u0026gt; 0) {  /* si_a is positive */\n    if (si_b \u0026gt; 0) {  /* si_a and si_b are positive */\n      if (si_a \u0026gt; (INT_MAX / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a positive, si_b nonpositive */\n      if (si_b \u0026lt; (INT_MIN / si_a)) {\n        /* Handle error */\n      }\n    } /* si_a positive, si_b nonpositive */\n  } else { /* si_a is nonpositive */\n    if (si_b \u0026gt; 0) { /* si_a is nonpositive, si_b is positive */\n      if (si_a \u0026lt; (INT_MIN / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a and si_b are nonpositive */\n      if ( (si_a != 0) \u0026amp;\u0026amp; (si_b \u0026lt; (INT_MAX / si_a))) {\n        /* Handle error */\n      }\n    } /* End if si_a and si_b are nonpositive */\n  } /* End if si_a is nonpositive */\n\n  result = si_a * si_b;\n}\u003c/pre\u003e\n\u003cp\u003e更多的防止在操作中整型溢出的安全代码可以参看《\u003ca href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure that operations on signed integers do not result in overflow\u003c/a\u003e》\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B6%E5%AE%83\"\u003e\u003c/span\u003e其它\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e对于C++来说，你应该使用STL中的numeric_limits::max() 来检查溢出。\u003c/p\u003e\n\u003cp\u003e另外，微软的SafeInt类是一个可以帮你远理上面这些很tricky的类，下载地址：\u003ca href=\"http://safeint.codeplex.com/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ehttp://safeint.codeplex.com/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e对于Java 来说，一种是用JDK 1.7中Math库下的safe打头的函数，如safeAdd()和safeMultiply()，另一种用更大尺寸的数据类型，最大可以到BigInteger。\u003c/p\u003e\n\u003cp\u003e可见，写一个安全的代码并不容易，尤其对于C/C++来说。对于黑客来说，他们只需要搜一下开源软件中代码有memcpy/strcpy之类的地方，然后看一看其周边的代码，是否可以通过用户的输入来影响，如果有的话，你就惨了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e参考\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://phrack.org/issues/60/10.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eBasic Integer Overflow\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.owasp.org/index.php/Integer_overflow\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eOWASP：Integer overflow\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.kb.cert.org/vuls/id/162289\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eC compilers may silently discard some wraparound checks\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/SecureCodingGuide.pdf\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eApple Secure Coding Guide\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eWikipedia: Undefined Behavior\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp id=\"title-text\" class=\"with-breadcrumbs\"\u003e\u003ca href=\"https://www.securecoding.cert.org/confluence/display/seccode/INT32-C.+Ensure+that+operations+on+signed+integers+do+not+result+in+overflow\"\u003eINT32-C. Ensure that operations on signed integers do not result in overflow\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e最后， 不好意思，这篇文章可能罗嗦了一些，大家见谅。\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21708.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2022/01/iStock-1175502114-150x150.png\" alt=\"网络数字身份认证术\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21708.html\" class=\"wp_rp_title\"\u003e网络数字身份认证术\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/19395.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2019/05/Authorization-360x200-1-150x150.png\" alt=\"HTTP API 认证授权术\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/19395.html\" class=\"wp_rp_title\"\u003eHTTP API 认证授权术\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18094.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/08/enable-https-banner-150x150.png\" alt=\"如何免费的让网站启用HTTPS\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18094.html\" class=\"wp_rp_title\"\u003e如何免费的让网站启用HTTPS\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_title\"\u003eAPI设计原则 – Qt官网的设计实践总结\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11466\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"a29379f221\"\u003e\u003cimg id=\"rating_11466_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11466, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6faac77eb6c5ecbde7f35a01-=\"\"/\u003e\u003cimg id=\"rating_11466_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11466, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6faac77eb6c5ecbde7f35a01-=\"\"/\u003e\u003cimg id=\"rating_11466_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11466, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6faac77eb6c5ecbde7f35a01-=\"\"/\u003e\u003cimg id=\"rating_11466_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11466, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6faac77eb6c5ecbde7f35a01-=\"\"/\u003e\u003cimg id=\"rating_11466_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11466, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-6faac77eb6c5ecbde7f35a01-=\"\"/\u003e (\u003cstrong\u003e48\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.27\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11466_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"C语言的整型溢出问题\"/\u003e\u003cmeta itemprop=\"headline\" content=\"C语言的整型溢出问题\"/\u003e\u003cmeta itemprop=\"description\" content=\"整型溢出有点老生常谈了，bla, bla, bla... 但似乎没有引起多少人的重视。整型溢出会有可能导致缓冲区溢出，缓冲区溢出会导致各种黑客攻击，比如最近OpenSSL的heartbleed事件，就是一个buffer overread的事件。在这里写下这篇文章，希望大家都了解一下整型溢出，编译器的行为，以及如何防范，以写出更安全的代码。\n\n什么是整型溢出\n\nC语言的整型问题相信大家并不陌生了。对...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-04-21T08:18:01+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-08T17:30:37+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11466.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11466.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.27\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"48\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11466-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-04-21T08:18:01+08:00",
  "Author": "陈皓"
}