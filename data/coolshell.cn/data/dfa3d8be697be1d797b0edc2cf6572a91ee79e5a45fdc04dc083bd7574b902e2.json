{
  "Source": "coolshell.cn",
  "Title": "C++模板”\u003e\u003e”编译问题与词法消歧设计",
  "Link": "https://coolshell.cn/articles/10449.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"b8aa0dc35c0ce405bf82274d-text/javascript\"\u003e\u003c/script\u003e\u003cstrong\u003e（感谢 \u003ca href=\"http://weibo.com/weidagang\" target=\"_blank\"\u003e@文艺复兴记\u003c/a\u003e（todd） 投递此文）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在编译理论中，通常将编译过程抽象为5个主要阶段：词法分析(Lexical Analysis)，语法分析(Parsing)，语义分析(Semantic Analysis)，优化(Optimization)，代码生成(Code Generation)。这5个阶段类似Unix管道模型，上一个阶段的输出作为下一个阶段的输入。其中，词法分析是根据输入源代码文本流，分割出词，识别类别，产生词法元素(Token)流，如：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"cpp\" class=\"EnlighterJSRAW\"\u003eint a = 10;\n\u003c/pre\u003e\n\u003cp\u003e​经过词法分析会得到[(Type, “int”), (Identifier, “a”), (AssignOperator, “=”), (IntLiteral, 10)]，在后续的语法分析阶段，就会根据这些词法元素匹配相应的语法规则。在我学习编译原理时，教科书中对于词法分析的介绍主要是基于正则表达式的，言下之意就是普通语言的词法规则是可以通过正则表达式描述的。比如，C语言的变量名规则是“包含字母、数字或下划线，并且以字母或下划线开头”，这就可以用正则表达式\u003ccode\u003e[a-zA-Z_][a-zA-Z0-9_]*\u003c/code\u003e表达。但是，在实践中我发现不管是主流语言，还是自己设计的DSL都大量存在不能简单通过正则表达式进行词法分析的例子。来看C++98的模版例子：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"cpp\" class=\"EnlighterJSRAW\"\u003emap\u0026lt;int, vector\u0026lt;int\u0026gt;\u0026gt;\n\u003c/pre\u003e\n\u003cp\u003e上面这段代码会被C++98编译器中报语法错误，原因在于它把“\u0026gt;\u0026gt;”识别成了位右移运算符而不是两个模版右括号，在C++98中必须在两个括号中间加空格，写成\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-10449\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre data-enlighter-language=\"cpp\" class=\"EnlighterJSRAW\"\u003emap\u0026lt;int, vector\u0026lt;int\u0026gt; \u0026gt;\n\u003c/pre\u003e\n\u003cp\u003e除此了C++模版，据我所知，经典的FORTRAN语言的语法规则更是大量存在词法歧义。\u003c/p\u003e\n\u003cp\u003e我认为从本质上讲，这类问题的根源在于词法分析的依据只是简单的词法规则，并不具备所有的语法信息，而词法歧义必须提升一层在语法规则中消除。所以，在我自己设计一些DSL的时候干脆就把词法分析和语法分析合二为一了，相当于让语法分析在字符层次上去进行，而不是经典的词法元素层次上，这就是所谓的\u003ca title=\"Scannerless Parsing\" href=\"https://en.wikipedia.org/wiki/Scannerless_parsing\"\u003eScannerless Parsing\u003c/a\u003e。采用这种方法的例子并不少见，TeX, Wiki, Makefile和Perl 6等语言的语法分析器都属此类。\u003c/p\u003e\n\u003cp\u003eScannerless Parsing方法弥补了词法规则无法消歧的问题，但是同时也破坏了词法和语法分析简单清晰的管道结构，总体上增加了实现和理解的复杂度。另外，像C++这样大型的语言，如果开始是有词法分析的，稍微碰到一个歧义就整个转成Scannerless Parsing未免也显得太夸张了。这个问题困扰了我很久，直到最近才找到了一个满意的解决方案。还是以上面”\u0026gt;\u0026gt;”为例，我们知道现在C++11已经允许不加空格了，那么C++11编译器是如何处理这个词法歧义的呢？答案是：词法分析阶段既然分析不好”\u0026gt;\u0026gt;”，干脆就不分析了，直接把”\u0026gt;” “\u0026gt;”交给语法分析器来分析，其他没有词法歧义的照旧。当我知道这个方案的时候不由得感叹：妙！理论上，词法分析是可以什么也不做的，全部把字符一一交给语法分析器也没有问题，所以，干脆让词法分析只做有把握的部分，解决不了的交给语法分析器，这样就既保留了管道结构，又解决了词法歧义。\u003c/p\u003e\n\u003cp\u003e下面我们再来看看C++11规范关于这个问题的定义：\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003e14.2 Names of template specializations [temp.names] ###\u003c/p\u003e\n\u003cp\u003eAfter name lookup (3.4) finds that a name is a template-name or that an operator-function-id or a literal-operator-id refers to a set of overloaded functions any member of which is a function template if this is followed by a \u0026lt;, the \u0026lt; is always taken as the delimiter of a template-argument-list and never as the less-than operator. When parsing a template-argument-list, the first non-nested \u0026gt; is taken as the ending delimiter rather than a greater-than operator. Similarly, the first non-nested \u0026gt;\u0026gt; is treated as two consecutive but distinct \u0026gt; tokens, the first of which is taken as the end of the template-argument-list and completes the template-id. [ Note: The second \u0026gt; token produced by this replacement rule may terminate an enclosing template-id construct or it may be part of a different construct (e.g. a cast).—end note ]\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e可见，在C++11中，词法分析器是把”\u0026gt;\u0026gt;”直接当成两个”\u0026gt;”传给了语法分析器，然后在语法分析中如果匹配了template-argument-lis语法，第一个”\u0026gt;”符号会被直接认为是模版结束符，而不是大于，也不是位移符号。根据这个定义，我构造了一个例子：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"cpp\" class=\"EnlighterJSRAW\"\u003etemplate\u0026lt;int N\u0026gt;\nclass Foo {\n};\n\nFoo\u0026lt;3\u0026gt;\u0026gt;1\u0026gt; foo;\n\u003c/pre\u003e\n\u003cp\u003e这个例子在C++98中是能正确编译的，”\u0026gt;\u0026gt;”被解释成了位移运算，但是它反而不能在C++11中编译了，因为根据规范第一个”\u0026gt;”被解释成了模版参数结束符。如果要在C++11中编译，需要显式地加上括号：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"cpp\" class=\"EnlighterJSRAW\"\u003eFoo\u0026lt;(3\u0026gt;\u0026gt;1)\u0026gt; foo;\n\u003c/pre\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/03/rust-social-wide-150x150.jpg\" alt=\"Rust语言的编程范式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/20845.html\" class=\"wp_rp_title\"\u003eRust语言的编程范式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/07/api-design-300x278-2-150x150.jpg\" alt=\"API设计原则 – Qt官网的设计实践总结\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18024.html\" class=\"wp_rp_title\"\u003eAPI设计原则 – Qt官网的设计实践总结\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/29.jpg\" alt=\"Leetcode 编程训练\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12052.html\" class=\"wp_rp_title\"\u003eLeetcode 编程训练\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/10/edsm-150x150.gif\" alt=\"State Threads 回调终结者\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/12012.html\" class=\"wp_rp_title\"\u003eState Threads 回调终结者\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2014/04/c99-150x150.jpg\" alt=\"C语言的整型溢出问题\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/11466.html\" class=\"wp_rp_title\"\u003eC语言的整型溢出问题\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-10449\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"ea04f1aa0b\"\u003e\u003cimg id=\"rating_10449_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(10449, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.8, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-b8aa0dc35c0ce405bf82274d-=\"\"/\u003e\u003cimg id=\"rating_10449_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(10449, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.8, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-b8aa0dc35c0ce405bf82274d-=\"\"/\u003e\u003cimg id=\"rating_10449_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(10449, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.8, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-b8aa0dc35c0ce405bf82274d-=\"\"/\u003e\u003cimg id=\"rating_10449_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(10449, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.8, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-b8aa0dc35c0ce405bf82274d-=\"\"/\u003e\u003cimg id=\"rating_10449_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(10449, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(3.8, 4, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-b8aa0dc35c0ce405bf82274d-=\"\"/\u003e (\u003cstrong\u003e25\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e3.84\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_10449_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"C++模板”\u0026gt;\u0026gt;”编译问题与词法消歧设计\"/\u003e\u003cmeta itemprop=\"headline\" content=\"C++模板”\u0026gt;\u0026gt;”编译问题与词法消歧设计\"/\u003e\u003cmeta itemprop=\"description\" content=\"（感谢 @文艺复兴记（todd） 投递此文）\n\n在编译理论中，通常将编译过程抽象为5个主要阶段：词法分析(Lexical Analysis)，语法分析(Parsing)，语义分析(Semantic Analysis)，优化(Optimization)，代码生成(Code Generation)。这5个阶段类似Unix管道模型，上一个阶段的输出作为下一个阶段的输入。其中，词法分析是根据输入源代码...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2013-10-02T18:47:36+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2013-10-09T17:07:46+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/10449.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"Todd\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/10449.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"3.84\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"25\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-10449-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2013-10-02T18:47:36+08:00",
  "Author": "Todd"
}