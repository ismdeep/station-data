{
  "Source": "coolshell.cn",
  "Title": "Docker基础技术：Linux Namespace（上）",
  "Link": "https://coolshell.cn/articles/17010.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"4da78b8591fb934453706d47-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-full wp-image-17085\" src=\"https://coolshell.cn/wp-content/uploads/2015/04/isolation.jpg\" alt=\"isolation\" width=\"359\" height=\"237\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/04/isolation.jpg 359w, https://coolshell.cn/wp-content/uploads/2015/04/isolation-300x198.jpg 300w\" sizes=\"(max-width: 359px) 100vw, 359px\"/\u003e时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New “Old Stuff”。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。\u003c/p\u003e\n\u003cp\u003e当然，文章的风格一定会尊重时下的“流行”——\u003cstrong\u003e我们再也没有整块整块的时间去看书去专研，而我们只有看微博微信那样的碎片时间\u003c/strong\u003e（那怕我们有整块的时间，也被那些在手机上的APP碎片化了）。所以，这些文章的风格必然坚持“马桶风格”（希望简单到占用你拉一泡屎就时间，而且你还不用动脑子，并能学到些东西）\u003c/p\u003e\n\u003cp\u003e废话少说，我们开始。先从Linux Namespace开始。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#_%E7%AE%80%E4%BB%8B\" title=\" 简介\"\u003e 简介\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\" title=\"clone()系统调用\"\u003eclone()系统调用\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#UTS_Namespace\" title=\"UTS Namespace\"\u003eUTS Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#IPC_Namespace\" title=\"IPC Namespace\"\u003eIPC Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#PID_Namespace\" title=\"PID Namespace\"\u003ePID Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Mount_Namespace\" title=\"Mount Namespace\"\u003eMount Namespace\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#Docker%E7%9A%84_Mount_Namespace\" title=\"Docker的 Mount Namespace\"\u003eDocker的 Mount Namespace\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"_%E7%AE%80%E4%BB%8B\"\u003e\u003c/span\u003e 简介\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eLinux Namespace是Linux提供的一种内核级别环境隔离的方法。不知道你是否还记得很早以前的Unix有一个叫chroot的系统调用（通过修改根目录把用户jail到一个特定目录下），chroot提供了一种简单的隔离模式：chroot内部的文件系统无法访问外部的内容。Linux Namespace在此基础上，提供了对UTS、IPC、mount、PID、network、User等的隔离机制。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-17010\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cp\u003e举个例子，我们都知道，Linux下的超级父亲进程的PID是1，所以，同chroot一样，如果我们可以把用户的进程空间jail到某个进程分支下，并像chroot那样让其下面的进程 看到的那个超级父进程的PID为1，于是就可以达到资源隔离的效果了（不同的PID namespace中的进程无法看到彼此）\u003c/p\u003e\n\u003cp\u003e\u003cb\u003eLinux Namespace 有如下种类\u003c/b\u003e，官方文档在这里《\u003ca href=\"http://lwn.net/Articles/531114/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eNamespace in Operation\u003c/a\u003e》\u003c/p\u003e\n\u003ctable width=\"100%\"\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e分类\u003c/th\u003e\n\u003cth\u003e系统调用参数\u003c/th\u003e\n\u003cth\u003e相关内核版本\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003eMount namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWNS\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/2001/0301/a/namespaces.php3\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux 2.4.19\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003eUTS namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWUTS\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/Articles/179345/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux 2.6.19\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003eIPC namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWIPC\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/Articles/187274/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux 2.6.19\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003ePID namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWPID\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/Articles/259217/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eLinux 2.6.24\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003eNetwork namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWNET\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/Articles/219794/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e始于Linux 2.6.24 完成于 Linux 2.6.29\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cb\u003eUser namespaces\u003c/b\u003e\u003c/td\u003e\n\u003ctd\u003eCLONE_NEWUSER\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"http://lwn.net/Articles/528078/\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e始于 Linux 2.6.23 完成于 Linux 3.8)\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e主要是三个系统调用\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003e\u003ccode\u003eclone\u003c/code\u003e\u003c/b\u003e\u003cb\u003e() \u003c/b\u003e– 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述参数达到隔离。\u003c/li\u003e\n\u003cli\u003e\u003cb\u003e\u003ccode\u003eunshare\u003c/code\u003e\u003c/b\u003e\u003cb\u003e() \u003c/b\u003e– 使某进程脱离某个namespace\u003c/li\u003e\n\u003cli\u003e\u003cb\u003e\u003ccode\u003esetns\u003c/code\u003e\u003c/b\u003e\u003cb\u003e() \u003c/b\u003e– 把某进程加入到某个namespace\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eunshare() 和 setns() 都比较简单，大家可以自己man，我这里不说了。\u003c/p\u003e\n\u003cp\u003e下面还是让我们来看一些示例（以下的测试程序最好在Linux 内核为3.8以上的版本中运行，我用的是ubuntu 14.04）。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"clone%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8\"\u003e\u003c/span\u003eclone()系统调用\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e首先，我们来看一下一个最简单的clone()系统调用的示例，（后面，我们的程序都会基于这个程序做修改）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e#define _GNU_SOURCE\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;sys/wait.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;sched.h\u0026gt;\n#include \u0026lt;signal.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\n/* 定义一个给 clone 用的栈，栈大小1M */\n#define STACK_SIZE (1024 * 1024)\nstatic char container_stack[STACK_SIZE];\n\nchar* const container_args[] = {\n    \u0026#34;/bin/bash\u0026#34;,\n    NULL\n};\n\nint container_main(void* arg)\n{\n    printf(\u0026#34;Container - inside the container!\\n\u0026#34;);\n    /* 直接执行一个shell，以便我们观察这个进程空间里的资源是否被隔离了 */\n    execv(container_args[0], container_args); \n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    printf(\u0026#34;Parent - start a container!\\n\u0026#34;);\n    /* 调用clone函数，其中传出一个函数，还有一个栈空间的（为什么传尾指针，因为栈是反着的） */\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, SIGCHLD, NULL);\n    /* 等待子进程结束 */\n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e从上面的程序，我们可以看到，这和pthread基本上是一样的玩法。但是，对于上面的程序，父子进程的进程空间是没有什么差别的，父进程能访问到的子进程也能。\u003c/p\u003e\n\u003cp\u003e下面， 让我们来看几个例子看看，Linux的Namespace是什么样的。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"UTS_Namespace\"\u003e\u003c/span\u003eUTS Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面的代码，我略去了上面那些头文件和数据结构的定义，只有最重要的部分。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"4,14\"\u003eint container_main(void* arg)\n{\n    printf(\u0026#34;Container - inside the container!\\n\u0026#34;);\n    sethostname(\u0026#34;container\u0026#34;,10); /* 设置hostname */\n    execv(container_args[0], container_args);\n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    printf(\u0026#34;Parent - start a container!\\n\u0026#34;);\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | SIGCHLD, NULL); /*启用CLONE_NEWUTS Namespace隔离 */\n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\u003c/pre\u003e\n\u003cpre\u003e运行上面的程序你会发现（需要root权限），子进程的hostname变成了 container。\u003c/pre\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ./uts\nParent - start a container!\nContainer - inside the container!\nroot@container:~# hostname\ncontainer\nroot@container:~# uname -n\ncontainer\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"IPC_Namespace\"\u003e\u003c/span\u003eIPC Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eIPC全称 Inter-Process Communication，是Unix/Linux下进程间通信的一种方式，IPC有共享内存、信号量、消息队列等方法。所以，为了隔离，我们也需要把IPC给隔离开来，这样，只有在同一个Namespace下的进程才能相互通信。如果你熟悉IPC的原理的话，你会知道，IPC需要有一个全局的ID，即然是全局的，那么就意味着我们的Namespace需要对这个ID隔离，不能让别的Namespace的进程看到。\u003c/p\u003e\n\u003cp\u003e要启动IPC隔离，我们只需要在调用clone时加上CLONE_NEWIPC参数就可以了。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003eint container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | CLONE_NEWIPC | SIGCHLD, NULL);\u003c/pre\u003e\n\u003cp\u003e首先，我们先创建一个IPC的Queue（如下所示，全局的Queue ID是0）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ ipcmk -Q \nMessage queue id: 0\n\nhchen@ubuntu:~$ ipcs -q\n------ Message Queues --------\nkey        msqid      owner      perms      used-bytes   messages    \n0xd0d56eb2 0          hchen      644        0            0\u003c/pre\u003e\n\u003cp\u003e如果我们运行没有CLONE_NEWIPC的程序，我们会看到，在子进程中还是能看到这个全启的IPC Queue。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ./uts \nParent - start a container!\nContainer - inside the container!\n\nroot@container:~# ipcs -q\n\n------ Message Queues --------\nkey        msqid      owner      perms      used-bytes   messages    \n0xd0d56eb2 0          hchen      644        0            0\u003c/pre\u003e\n\u003cp\u003e但是，如果我们运行加上了CLONE_NEWIPC的程序，我们就会下面的结果：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003eroot@ubuntu:~$ sudo./ipc\nParent - start a container!\nContainer - inside the container!\n\nroot@container:~/linux_namespace# ipcs -q\n\n------ Message Queues --------\nkey        msqid      owner      perms      used-bytes   messages\u003c/pre\u003e\n\u003cp\u003e我们可以看到IPC已经被隔离了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"PID_Namespace\"\u003e\u003c/span\u003ePID Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们继续修改上面的程序：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"4,16\"\u003eint container_main(void* arg)\n{\n    /* 查看子进程的PID，我们可以看到其输出子进程的 pid 为 1 */\n    printf(\u0026#34;Container [%5d] - inside the container!\\n\u0026#34;, getpid());\n    sethostname(\u0026#34;container\u0026#34;,10);\n    execv(container_args[0], container_args);\n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    printf(\u0026#34;Parent [%5d] - start a container!\\n\u0026#34;, getpid());\n    /*启用PID namespace - CLONE_NEWPID*/\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | CLONE_NEWPID | SIGCHLD, NULL); \n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e运行结果如下（我们可以看到，子进程的pid是1了）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ./pid\nParent [ 3474] - start a container!\nContainer [ 1] - inside the container!\nroot@container:~# echo $$\n1\u003c/pre\u003e\n\u003cp\u003e你可能会问，PID为1有个毛用啊？我们知道，在传统的UNIX系统中，PID为1的进程是init，地位非常特殊。他作为所有进程的父进程，有很多特权（比如：屏蔽信号等），另外，其还会为检查所有进程的状态，我们知道，如果某个子进程脱离了父进程（父进程没有wait它），那么init就会负责回收资源并结束这个子进程。所以，要做到进程空间的隔离，首先要创建出PID为1的进程，最好就像chroot那样，把子进程的PID在容器内变成1。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e但是，我们会发现，在子进程的shell里输入ps,top等命令，我们还是可以看得到所有进程\u003c/strong\u003e。说明并没有完全隔离。这是因为，像ps, top这些命令会去读/proc文件系统，所以，因为/proc文件系统在父进程和子进程都是一样的，所以这些命令显示的东西都是一样的。\u003c/p\u003e\n\u003cp\u003e所以，我们还需要对文件系统进行隔离。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Mount_Namespace\"\u003e\u003c/span\u003eMount Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面的例程中，我们在启用了mount namespace并在子进程中重新mount了/proc文件系统。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\" data-enlighter-highlight=\"6,17\"\u003eint container_main(void* arg)\n{\n    printf(\u0026#34;Container [%5d] - inside the container!\\n\u0026#34;, getpid());\n    sethostname(\u0026#34;container\u0026#34;,10);\n    /* 重新mount proc文件系统到 /proc下 */\n    system(\u0026#34;mount -t proc proc /proc\u0026#34;);\n    execv(container_args[0], container_args);\n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    printf(\u0026#34;Parent [%5d] - start a container!\\n\u0026#34;, getpid());\n    /* 启用Mount Namespace - 增加CLONE_NEWNS参数 */\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);\n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ./pid.mnt\nParent [ 3502] - start a container!\nContainer [    1] - inside the container!\nroot@container:~# ps -elf \nF S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD\n4 S root         1     0  0  80   0 -  6917 wait   19:55 pts/2    00:00:00 /bin/bash\n0 R root        14     1  0  80   0 -  5671 -      19:56 pts/2    00:00:00 ps -elf\n\u003c/pre\u003e\n\u003cp\u003e上面，我们可以看到只有两个进程 ，而且pid=1的进程是我们的/bin/bash。我们还可以看到/proc目录下也干净了很多：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003eroot@container:~# ls /proc\n1          dma          key-users   net            sysvipc\n16         driver       kmsg        pagetypeinfo   timer_list\nacpi       execdomains  kpagecount  partitions     timer_stats\nasound     fb           kpageflags  sched_debug    tty\nbuddyinfo  filesystems  loadavg     schedstat      uptime\nbus        fs           locks       scsi           version\ncgroups    interrupts   mdstat      self           version_signature\ncmdline    iomem        meminfo     slabinfo       vmallocinfo\nconsoles   ioports      misc        softirqs       vmstat\ncpuinfo    irq          modules     stat           zoneinfo\ncrypto     kallsyms     mounts      swaps\ndevices    kcore        mpt         sys\ndiskstats  keys         mtrr        sysrq-trigger\n\u003c/pre\u003e\n\u003cp\u003e下图，我们也可以看到在子进程中的top命令只看得到两个进程了。\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-17020\" src=\"https://coolshell.cn/wp-content/uploads/2015/04/mount.namespace.jpg\" alt=\"\" width=\"570\" height=\"300\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/04/mount.namespace.jpg 740w, https://coolshell.cn/wp-content/uploads/2015/04/mount.namespace-300x158.jpg 300w\" sizes=\"(max-width: 570px) 100vw, 570px\"/\u003e\u003c/p\u003e\n\u003cp\u003e这里，多说一下。在通过CLONE_NEWNS创建mount namespace后，父进程会把自己的文件结构复制给子进程中。而子进程中新的namespace中的所有mount操作都只影响自身的文件系统，而不对外界产生任何影响。这样可以做到比较严格地隔离。\u003c/p\u003e\n\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e你可能会问，我们是不是还有别的一些文件系统也需要这样mount? 是的。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Docker%E7%9A%84_Mount_Namespace\"\u003e\u003c/span\u003eDocker的 Mount Namespace\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面我将向演示一个“山寨镜像”，其模仿了Docker的Mount Namespace。\u003c/p\u003e\n\u003cp\u003e首先，我们需要一个rootfs，也就是我们需要把我们要做的镜像中的那些命令什么的copy到一个rootfs的目录下，我们模仿Linux构建如下的目录：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~/rootfs$ ls\nbin  dev  etc  home  lib  lib64  mnt  opt  proc  root  run  sbin  sys  tmp  usr  var\u003c/pre\u003e\n\u003cp\u003e然后，我们把一些我们需要的命令copy到 rootfs/bin目录中（sh命令必需要copy进去，不然我们无法 chroot ）\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~/rootfs$ ls ./bin ./usr/bin\n \n./bin:\nbash   chown  gzip      less  mount       netstat  rm     tabs  tee      top       tty\ncat    cp     hostname  ln    mountpoint  ping     sed    tac   test     touch     umount\nchgrp  echo   ip        ls    mv          ps       sh     tail  timeout  tr        uname\nchmod  grep   kill      more  nc          pwd      sleep  tar   toe      truncate  which\n\n./usr/bin:\nawk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs\n\u003c/pre\u003e\n\u003cp\u003e注：你可以使用ldd命令把这些命令相关的那些so文件copy到对应的目录：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~/rootfs/bin$ ldd bash\n  linux-vdso.so.1 =\u0026gt;  (0x00007fffd33fc000)\n  libtinfo.so.5 =\u0026gt; /lib/x86_64-linux-gnu/libtinfo.so.5 (0x00007f4bd42c2000)\n  libdl.so.2 =\u0026gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4bd40be000)\n  libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4bd3cf8000)\n  /lib64/ld-linux-x86-64.so.2 (0x00007f4bd4504000)\n\u003c/pre\u003e\n\u003cp\u003e下面是我的rootfs中的一些so文件：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~/rootfs$ ls ./lib64 ./lib/x86_64-linux-gnu/\n\n./lib64:\nld-linux-x86-64.so.2\n\n./lib/x86_64-linux-gnu/:\nlibacl.so.1      libmemusage.so         libnss_files-2.19.so    libpython3.4m.so.1\nlibacl.so.1.1.0  libmount.so.1          libnss_files.so.2       libpython3.4m.so.1.0\nlibattr.so.1     libmount.so.1.1.0      libnss_hesiod-2.19.so   libresolv-2.19.so\nlibblkid.so.1    libm.so.6              libnss_hesiod.so.2      libresolv.so.2\nlibc-2.19.so     libncurses.so.5        libnss_nis-2.19.so      libselinux.so.1\nlibcap.a         libncurses.so.5.9      libnss_nisplus-2.19.so  libtinfo.so.5\nlibcap.so        libncursesw.so.5       libnss_nisplus.so.2     libtinfo.so.5.9\nlibcap.so.2      libncursesw.so.5.9     libnss_nis.so.2         libutil-2.19.so\nlibcap.so.2.24   libnsl-2.19.so         libpcre.so.3            libutil.so.1\nlibc.so.6        libnsl.so.1            libprocps.so.3          libuuid.so.1\nlibdl-2.19.so    libnss_compat-2.19.so  libpthread-2.19.so      libz.so.1\nlibdl.so.2       libnss_compat.so.2     libpthread.so.0\nlibgpm.so.2      libnss_dns-2.19.so     libpython2.7.so.1\nlibm-2.19.so     libnss_dns.so.2        libpython2.7.so.1.0\n\u003c/pre\u003e\n\u003cp\u003e包括这些命令依赖的一些配置文件：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~/rootfs$ ls ./etc\nbash.bashrc  group  hostname  hosts  ld.so.cache  nsswitch.conf  passwd  profile  \nresolv.conf  shadow\n\u003c/pre\u003e\n\u003cp\u003e你现在会说，我靠，有些配置我希望是在容器起动时给他设置的，而不是hard code在镜像中的。比如：/etc/hosts，/etc/hostname，还有DNS的/etc/resolv.conf文件。好的。那我们在rootfs外面，我们再创建一个conf目录，把这些文件放到这个目录中。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ ls ./conf\nhostname     hosts     resolv.conf\u003c/pre\u003e\n\u003cp\u003e这样，我们的父进程就可以动态地设置容器需要的这些文件的配置， 然后再把他们mount进容器，这样，容器的镜像中的配置就比较灵活了。\u003c/p\u003e\n\u003cp\u003e好了，终于到了我们的程序。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"c\"\u003e#define _GNU_SOURCE\n#include \u003csys types.h=\"\"\u003e\n#include \u003csys wait.h=\"\"\u003e\n#include \u003csys mount.h=\"\"\u003e\n#include \u003cstdio.h\u003e\n#include \u003csched.h\u003e\n#include \u003csignal.h\u003e\n#include \u003cunistd.h\u003e\n\n#define STACK_SIZE (1024 * 1024)\n\nstatic char container_stack[STACK_SIZE];\nchar* const container_args[] = {\n    \u0026#34;/bin/bash\u0026#34;,\n    \u0026#34;-l\u0026#34;,\n    NULL\n};\n\nint container_main(void* arg)\n{\n    printf(\u0026#34;Container [%5d] - inside the container!\\n\u0026#34;, getpid());\n\n    //set hostname\n    sethostname(\u0026#34;container\u0026#34;,10);\n\n    //remount \u0026#34;/proc\u0026#34; to make sure the \u0026#34;top\u0026#34; and \u0026#34;ps\u0026#34; show container\u0026#39;s information\n    if (mount(\u0026#34;proc\u0026#34;, \u0026#34;rootfs/proc\u0026#34;, \u0026#34;proc\u0026#34;, 0, NULL) !=0 ) {\n        perror(\u0026#34;proc\u0026#34;);\n    }\n    if (mount(\u0026#34;sysfs\u0026#34;, \u0026#34;rootfs/sys\u0026#34;, \u0026#34;sysfs\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;sys\u0026#34;);\n    }\n    if (mount(\u0026#34;none\u0026#34;, \u0026#34;rootfs/tmp\u0026#34;, \u0026#34;tmpfs\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;tmp\u0026#34;);\n    }\n    if (mount(\u0026#34;udev\u0026#34;, \u0026#34;rootfs/dev\u0026#34;, \u0026#34;devtmpfs\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;dev\u0026#34;);\n    }\n    if (mount(\u0026#34;devpts\u0026#34;, \u0026#34;rootfs/dev/pts\u0026#34;, \u0026#34;devpts\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;dev/pts\u0026#34;);\n    }\n    if (mount(\u0026#34;shm\u0026#34;, \u0026#34;rootfs/dev/shm\u0026#34;, \u0026#34;tmpfs\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;dev/shm\u0026#34;);\n    }\n    if (mount(\u0026#34;tmpfs\u0026#34;, \u0026#34;rootfs/run\u0026#34;, \u0026#34;tmpfs\u0026#34;, 0, NULL)!=0) {\n        perror(\u0026#34;run\u0026#34;);\n    }\n    /* \n     * 模仿Docker的从外向容器里mount相关的配置文件 \n     * 你可以查看：/var/lib/docker/containers/\u003ccontainer_id\u003e/目录，\n     * 你会看到docker的这些文件的。\n     */\n    if (mount(\u0026#34;conf/hosts\u0026#34;, \u0026#34;rootfs/etc/hosts\u0026#34;, \u0026#34;none\u0026#34;, MS_BIND, NULL)!=0 ||\n          mount(\u0026#34;conf/hostname\u0026#34;, \u0026#34;rootfs/etc/hostname\u0026#34;, \u0026#34;none\u0026#34;, MS_BIND, NULL)!=0 ||\n          mount(\u0026#34;conf/resolv.conf\u0026#34;, \u0026#34;rootfs/etc/resolv.conf\u0026#34;, \u0026#34;none\u0026#34;, MS_BIND, NULL)!=0 ) {\n        perror(\u0026#34;conf\u0026#34;);\n    }\n    /* 模仿docker run命令中的 -v, --volume=[] 参数干的事 */\n    if (mount(\u0026#34;/tmp/t1\u0026#34;, \u0026#34;rootfs/mnt\u0026#34;, \u0026#34;none\u0026#34;, MS_BIND, NULL)!=0) {\n        perror(\u0026#34;mnt\u0026#34;);\n    }\n\n    /* chroot 隔离目录 */\n    if ( chdir(\u0026#34;./rootfs\u0026#34;) != 0 || chroot(\u0026#34;./\u0026#34;) != 0 ){\n        perror(\u0026#34;chdir/chroot\u0026#34;);\n    }\n\n    execv(container_args[0], container_args);\n    perror(\u0026#34;exec\u0026#34;);\n    printf(\u0026#34;Something\u0026#39;s wrong!\\n\u0026#34;);\n    return 1;\n}\n\nint main()\n{\n    printf(\u0026#34;Parent [%5d] - start a container!\\n\u0026#34;, getpid());\n    int container_pid = clone(container_main, container_stack+STACK_SIZE, \n            CLONE_NEWUTS | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | SIGCHLD, NULL);\n    waitpid(container_pid, NULL, 0);\n    printf(\u0026#34;Parent - container stopped!\\n\u0026#34;);\n    return 0;\n}\n\u003c/container_id\u003e\u003c/unistd.h\u003e\u003c/signal.h\u003e\u003c/sched.h\u003e\u003c/stdio.h\u003e\u003c/sys\u003e\u003c/sys\u003e\u003c/sys\u003e\u003c/pre\u003e\n\u003cp\u003esudo运行上面的程序，你会看到下面的挂载信息以及一个所谓的“镜像”：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003ehchen@ubuntu:~$ sudo ./mount \nParent [ 4517] - start a container!\nContainer [    1] - inside the container!\nroot@container:/# mount\nproc on /proc type proc (rw,relatime)\nsysfs on /sys type sysfs (rw,relatime)\nnone on /tmp type tmpfs (rw,relatime)\nudev on /dev type devtmpfs (rw,relatime,size=493976k,nr_inodes=123494,mode=755)\ndevpts on /dev/pts type devpts (rw,relatime,mode=600,ptmxmode=000)\ntmpfs on /run type tmpfs (rw,relatime)\n/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hosts type ext4 (rw,relatime,errors=remount-ro,data=ordered)\n/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/hostname type ext4 (rw,relatime,errors=remount-ro,data=ordered)\n/dev/disk/by-uuid/18086e3b-d805-4515-9e91-7efb2fe5c0e2 on /etc/resolv.conf type ext4 (rw,relatime,errors=remount-ro,data=ordered)\n\nroot@container:/# ls /bin /usr/bin\n/bin:\nbash   chmod  echo  hostname  less  more  mv   ping  rm   sleep  tail  test    top   truncate  uname\ncat    chown  grep  ip        ln    mount  nc   ps    sed  tabs   tar   timeout  touch  tty     which\nchgrp  cp     gzip  kill      ls    mountpoint  netstat  pwd   sh   tac    tee   toe    tr   umount\n\n/usr/bin:\nawk  env  groups  head  id  mesg  sort  strace  tail  top  uniq  vi  wc  xargs\n\u003c/pre\u003e\n\u003cp\u003e关于如何做一个chroot的目录，这里有个工具叫\u003ca href=\"https://wiki.ubuntu.com/DebootstrapChroot\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDebootstrapChroot\u003c/a\u003e，你可以顺着链接去看看（英文的哦）\u003c/p\u003e\n\u003cp\u003e接下来的事情，你可以自己玩了，我相信你的想像力 。：）\u003c/p\u003e\n\u003cp\u003e在下一篇，我将向你介绍User Namespace、Network Namespace以及Namespace的其它东西。\u003c/p\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e \u003ca title=\"Docker基础技术：Linux Namespace（下）\" href=\"https://coolshell.cn/articles/17029.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e \u0026lt;\u0026lt;\u0026lt;\u0026lt; Docker基础技术：Linux Namespace（下）\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e（上篇完，\u003ca title=\"Docker基础技术：Linux Namespace（下）\" href=\"https://coolshell.cn/articles/17029.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e请参看下篇\u003c/a\u003e）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/jail_cell-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（下）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（下）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1-150x150.png\" alt=\"记一次Kubernetes/Docker网络排障\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_title\"\u003e记一次Kubernetes/Docker网络排障\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/how_to_set_up_an_iSCSI_LUN_with_thin-150x150.jpg\" alt=\"Docker基础技术：DeviceMapper\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_title\"\u003eDocker基础技术：DeviceMapper\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw-150x150.png\" alt=\"Docker基础技术：AUFS\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_title\"\u003eDocker基础技术：AUFS\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/filter-150x150.png\" alt=\"Docker基础技术：Linux CGroup\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17049.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux CGroup\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF-150x150.jpeg\" alt=\"eBPF 介绍\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_title\"\u003eeBPF 介绍\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-17010\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"2ffec0e0cf\"\u003e\u003cimg id=\"rating_17010_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17010, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-4da78b8591fb934453706d47-=\"\"/\u003e\u003cimg id=\"rating_17010_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17010, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-4da78b8591fb934453706d47-=\"\"/\u003e\u003cimg id=\"rating_17010_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17010, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-4da78b8591fb934453706d47-=\"\"/\u003e\u003cimg id=\"rating_17010_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17010, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-4da78b8591fb934453706d47-=\"\"/\u003e\u003cimg id=\"rating_17010_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17010, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.5, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-4da78b8591fb934453706d47-=\"\"/\u003e (\u003cstrong\u003e114\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.54\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_17010_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Docker基础技术：Linux Namespace（上）\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Docker基础技术：Linux Namespace（上）\"/\u003e\u003cmeta itemprop=\"description\" content=\"时下最热的技术莫过于Docker了，很多人都觉得Docker是个新技术，其实不然，Docker除了其编程语言用go比较新外，其实它还真不是个新东西，也就是个新瓶装旧酒的东西，所谓的The New \u0026#34;Old Stuff\u0026#34;。Docker和Docker衍生的东西用到了很多很酷的技术，我会用几篇 文章来把这些技术给大家做个介绍，希望通过这些文章大家可以自己打造一个山寨版的docker。\n\n当然，文章的风格...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2015-04-16T10:20:08+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-07T11:55:29+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/17010.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/17010.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.54\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"114\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-17010-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2015-04-16T10:20:08+08:00",
  "Author": "陈皓"
}