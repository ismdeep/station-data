{
  "Source": "coolshell.cn",
  "Title": "Go编程模式：切片，接口，时间和性能",
  "Link": "https://coolshell.cn/articles/21128.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"e8a334ff929aca57020bb390-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright size-medium wp-image-21234\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.slices-300x169.png\" alt=\"\" width=\"300\" height=\"169\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.slices-300x169.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices-1024x578.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices-768x434.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices-1536x867.png 1536w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices-478x270.png 478w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices.png 1576w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e\u003c/p\u003e\n\u003cp\u003e在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。\u003c/p\u003e\n\u003csection class=\"post-series\"\u003e\u003ch3 class=\"post-series-title\"\u003e本文是全系列中第1 / 10篇：\u003ca href=\"https://coolshell.cn/articles/series/go%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f\"\u003eGo编程模式\u003c/a\u003e\u003c/h3\u003e\u003cul class=\"post-series-list\"\u003e\u003cli class=\"post-series-item-current post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003eGo编程模式：切片，接口，时间和性能\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\"\u003eGo 编程模式：错误处理\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003cli class=\"post-series-item\"\u003e\u003cspan class=\"post-series-item-title\"\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/span\u003e\u003c/li\u003e\u003c/ul\u003e\u003cnav class=\"post-series-nav\"\u003e\u003cspan class=\"post-series-nav-next\"\u003e\u003ca href=\"https://coolshell.cn/articles/21140.html\" rel=\"next\" title=\"Go 编程模式：错误处理\"\u003e下一篇文章\u003c/a\u003e »\u003c/span\u003e\u003c/nav\u003e\u003c/section\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#Slice\" title=\"Slice\"\u003eSlice\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83\" title=\"深度比较\"\u003e深度比较\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B\" title=\"接口编程\"\u003e接口编程\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5\" title=\"接口完整性检查\"\u003e接口完整性检查\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E6%97%B6%E9%97%B4\" title=\"时间\"\u003e时间\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E6%80%A7%E8%83%BD%E6%8F%90%E7%A4%BA\" title=\"性能提示\"\u003e性能提示\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\" title=\"参考文档\"\u003e参考文档\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Slice\"\u003e\u003c/span\u003eSlice\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype slice struct {\n    array unsafe.Pointer //指向存放数据的数组指针\n    len   int            //长度有多大\n    cap   int            //容量有多大\n}\u003c/pre\u003e\n\u003cp\u003e用图示来看，一个空的slice的表现如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter wp-image-21129 size-medium\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice1-300x190.png\" alt=\"\" width=\"300\" height=\"190\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/slice1-300x190.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/slice1-427x270.png 427w, https://coolshell.cn/wp-content/uploads/2020/12/slice1.png 466w\" sizes=\"(max-width: 300px) 100vw, 300px\"/\u003e 熟悉C/C++的同学一定会知道，在结构体里用数组指针的问题——数据会发生共享！下面我们来看一下slice的一些操作\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-21128\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efoo = make([]int, 5)\nfoo[3] = 42\nfoo[4] = 100\n\nbar  := foo[1:4]\nbar[1] = 99\u003c/pre\u003e\n\u003cp\u003e对于上面这段代码。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先先创建一个foo的slice，其中的长度和容量都是5\u003c/li\u003e\n\u003cli\u003e然后开始对foo所指向的数组中的索引为3和4的元素进行赋值\u003c/li\u003e\n\u003cli\u003e然后，对foo做切片后赋值给bar，再修改bar[1]\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-full wp-image-21130\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice2.png\" alt=\"\" width=\"818\" height=\"362\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/slice2.png 818w, https://coolshell.cn/wp-content/uploads/2020/12/slice2-300x133.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/slice2-768x340.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/slice2-604x267.png 604w\" sizes=\"(max-width: 818px) 100vw, 818px\"/\u003e\u003c/p\u003e\n\u003cp\u003e通过上图我们可以看到，因为foo和bar的内存是共享的，所以，foo和bar的对数组内容的修改都会影响到对方。\u003c/p\u003e\n\u003cp\u003e接下来，我们再来看一个数据操作 \u003ccode\u003eappend()\u003c/code\u003e 的示例\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003ea := make([]int, 32)\nb := a[1:16]\na = append(a, 1)\na[2] = 42\u003c/pre\u003e\n\u003cp\u003e上面这段代码中，把 \u003ccode\u003ea[1:16]\u003c/code\u003e 的切片赋给到了 \u003ccode\u003eb\u003c/code\u003e ，此时，\u003ccode\u003ea\u003c/code\u003e 和 \u003ccode\u003eb\u003c/code\u003e 的内存空间是共享的，然后，对 \u003ccode\u003ea\u003c/code\u003e做了一个 \u003ccode\u003eappend()\u003c/code\u003e的操作，这个操作会让 \u003ccode\u003ea\u003c/code\u003e 重新分享内存，导致 \u003ccode\u003ea\u003c/code\u003e 和 \u003ccode\u003eb\u003c/code\u003e 不再共享，如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-large wp-image-21326\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append-1024x513.png\" alt=\"\" width=\"640\" height=\"321\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append-1024x513.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append-300x150.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append-768x385.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append-539x270.png 539w, https://coolshell.cn/wp-content/uploads/2020/12/go.slices.append.png 1454w\" sizes=\"(max-width: 640px) 100vw, 640px\"/\u003e\u003c/p\u003e\n\u003cp\u003e从上图我们可以看以看到 \u003ccode\u003eappend()\u003c/code\u003e操作让 \u003ccode\u003ea\u003c/code\u003e 的容量变成了64，而长度是33。这里，需要重点注意一下——\u003cstrong\u003e\u003ccode\u003eappend()\u003c/code\u003e这个函数在 \u003ccode\u003ecap\u003c/code\u003e 不够用的时候就会重新分配内存以扩大容量，而如果够用的时候不不会重新分享内存！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们再看来看一个例子：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc main() {\n    path := []byte(\u0026#34;AAAA/BBBBBBBBB\u0026#34;)\n    sepIndex := bytes.IndexByte(path,\u0026#39;/’)\n\n    dir1 := path[:sepIndex]\n    dir2 := path[sepIndex+1:]\n\n    fmt.Println(\u0026#34;dir1 =\u0026gt;\u0026#34;,string(dir1)) //prints: dir1 =\u0026gt; AAAA\n    fmt.Println(\u0026#34;dir2 =\u0026gt;\u0026#34;,string(dir2)) //prints: dir2 =\u0026gt; BBBBBBBBB\n\n    dir1 = append(dir1,\u0026#34;suffix\u0026#34;...)\n\n    fmt.Println(\u0026#34;dir1 =\u0026gt;\u0026#34;,string(dir1)) //prints: dir1 =\u0026gt; AAAAsuffix\n    fmt.Println(\u0026#34;dir2 =\u0026gt;\u0026#34;,string(dir2)) //prints: dir2 =\u0026gt; uffixBBBB\n}\u003c/pre\u003e\n\u003cp\u003e上面这个例子中，\u003ccode\u003edir1\u003c/code\u003e 和 \u003ccode\u003edir2\u003c/code\u003e 共享内存，虽然 \u003ccode\u003edir1\u003c/code\u003e 有一个 \u003ccode\u003eappend()\u003c/code\u003e 操作，但是因为 cap 足够，于是数据扩展到了\u003ccode\u003edir2\u003c/code\u003e 的空间。下面是相关的图示（注意上图中 \u003ccode\u003edir1\u003c/code\u003e 和 \u003ccode\u003edir2\u003c/code\u003e 结构体中的 \u003ccode\u003ecap\u003c/code\u003e 和 \u003ccode\u003elen\u003c/code\u003e 的变化）\u003c/p\u003e\n\u003cp\u003e\u003cimg decoding=\"async\" loading=\"lazy\" class=\"aligncenter size-large wp-image-21328\" src=\"https://coolshell.cn/wp-content/uploads/2020/12/slice4-1024x740.png\" alt=\"\" width=\"640\" height=\"463\" srcset=\"https://coolshell.cn/wp-content/uploads/2020/12/slice4-1024x740.png 1024w, https://coolshell.cn/wp-content/uploads/2020/12/slice4-300x217.png 300w, https://coolshell.cn/wp-content/uploads/2020/12/slice4-768x555.png 768w, https://coolshell.cn/wp-content/uploads/2020/12/slice4-374x270.png 374w, https://coolshell.cn/wp-content/uploads/2020/12/slice4.png 1481w\" sizes=\"(max-width: 640px) 100vw, 640px\"/\u003e\u003c/p\u003e\n\u003cp\u003e如果要解决这个问题，我们只需要修改一行代码。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003edir1 := path[:sepIndex]\n\u003c/pre\u003e\n\u003cp\u003e修改为\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003edir1 := path[:sepIndex:sepIndex]\n\u003c/pre\u003e\n\u003cp\u003e新的代码使用了 Full Slice Expression，其最后一个参数叫“Limited Capacity”，于是，后续的 \u003ccode\u003eappend()\u003c/code\u003e 操作将会导致重新分配内存。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83\"\u003e\u003c/span\u003e深度比较\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e当我们复杂一个对象时，这个对象可以是内建数据类型，数组，结构体，map……我们在复制结构体的时候，当我们需要比较两个结构体中的数据是否相同时，我们需要使用深度比较，而不是只是简单地做浅度比较。这里需要使用到反射 \u003ccode\u003ereflect.DeepEqual()\u003c/code\u003e ，下面是几个示例\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003eimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;reflect\u0026#34;\n)\n\nfunc main() {\n\n    v1 := data{}\n    v2 := data{}\n    fmt.Println(\u0026#34;v1 == v2:\u0026#34;,reflect.DeepEqual(v1,v2))\n    //prints: v1 == v2: true\n\n    m1 := map[string]string{\u0026#34;one\u0026#34;: \u0026#34;a\u0026#34;,\u0026#34;two\u0026#34;: \u0026#34;b\u0026#34;}\n    m2 := map[string]string{\u0026#34;two\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;one\u0026#34;: \u0026#34;a\u0026#34;}\n    fmt.Println(\u0026#34;m1 == m2:\u0026#34;,reflect.DeepEqual(m1, m2))\n    //prints: m1 == m2: true\n\n    s1 := []int{1, 2, 3}\n    s2 := []int{1, 2, 3}\n    fmt.Println(\u0026#34;s1 == s2:\u0026#34;,reflect.DeepEqual(s1, s2))\n    //prints: s1 == s2: true\n}\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B\"\u003e\u003c/span\u003e接口编程\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面，我们来看段代码，其中是两个方法，它们都是要输出一个结构体，其中一个使用一个函数，另一个使用一个“成员函数”。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003efunc PrintPerson(p *Person) {\n    fmt.Printf(\u0026#34;Name=%s, Sexual=%s, Age=%d\\n\u0026#34;,\n  p.Name, p.Sexual, p.Age)\n}\n\nfunc (p *Person) Print() {\n    fmt.Printf(\u0026#34;Name=%s, Sexual=%s, Age=%d\\n\u0026#34;,\n  p.Name, p.Sexual, p.Age)\n}\n\nfunc main() {\n    var p = Person{\n        Name: \u0026#34;Hao Chen\u0026#34;,\n        Sexual: \u0026#34;Male\u0026#34;,\n        Age: 44,\n    }\n\n    PrintPerson(\u0026amp;p)\n    p.Print()\n}\u003c/pre\u003e\n\u003cp\u003e你更喜欢哪种方式呢？在 Go 语言中，使用“成员函数”的方式叫“Receiver”，这种方式是一种封装，因为 \u003ccode\u003ePrintPerson()\u003c/code\u003e本来就是和 \u003ccode\u003ePerson\u003c/code\u003e强耦合的，所以，理应放在一起。更重要的是，这种方式可以进行接口编程，对于接口编程来说，也就是一种抽象，主要是用在“多态”，这个技术，在《\u003ca href=\"https://coolshell.cn/articles/8460.html#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%A4%9A%E6%80%81\" target=\"_blank\" rel=\"noopener\"\u003eGo语言简介（上）：接口与多态\u003c/a\u003e》中已经讲过。在这里，我想讲另一个Go语言接口的编程模式。\u003c/p\u003e\n\u003cp\u003e首先，我们来看一下，有下面这段代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Country struct {\n    Name string\n}\n\ntype City struct {\n    Name string\n}\n\ntype Printable interface {\n    PrintStr()\n}\nfunc (c Country) PrintStr() {\n    fmt.Println(c.Name)\n}\nfunc (c City) PrintStr() {\n    fmt.Println(c.Name)\n}\n\nc1 := Country {\u0026#34;China\u0026#34;}\nc2 := City {\u0026#34;Beijing\u0026#34;}\nc1.PrintStr()\nc2.PrintStr()\u003c/pre\u003e\n\u003cp\u003e其中，我们可以看到，其使用了一个 \u003ccode\u003ePrintable\u003c/code\u003e 的接口，而 \u003ccode\u003eCountry\u003c/code\u003e 和 \u003ccode\u003eCity\u003c/code\u003e 都实现了接口方法 \u003ccode\u003ePrintStr()\u003c/code\u003e 而把自己输出。然而，这些代码都是一样的。能不能省掉呢？\u003c/p\u003e\n\u003cp\u003e我们可以使用“结构体嵌入”的方式来完成这个事，如下的代码所示，\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype WithName struct {\n    Name string\n}\n\ntype Country struct {\n    WithName\n}\n\ntype City struct {\n    WithName\n}\n\ntype Printable interface {\n    PrintStr()\n}\n\nfunc (w WithName) PrintStr() {\n    fmt.Println(w.Name)\n}\n\nc1 := Country {WithName{ \u0026#34;China\u0026#34;}}\nc2 := City { WithName{\u0026#34;Beijing\u0026#34;}}\nc1.PrintStr()\nc2.PrintStr()\u003c/pre\u003e\n\u003cp\u003e引入一个叫 \u003ccode\u003eWithName\u003c/code\u003e的结构体，然而，所带来的问题就是，在初始化的时候，变得有点乱。那么，我们有没有更好的方法？下面是另外一个解。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Country struct {\n    Name string\n}\n\ntype City struct {\n    Name string\n}\n\ntype Stringable interface {\n    ToString() string\n}\nfunc (c Country) ToString() string {\n    return \u0026#34;Country = \u0026#34; + c.Name\n}\nfunc (c City) ToString() string{\n    return \u0026#34;City = \u0026#34; + c.Name\n}\n\nfunc PrintStr(p Stringable) {\n    fmt.Println(p.ToString())\n}\n\nd1 := Country {\u0026#34;USA\u0026#34;}\nd2 := City{\u0026#34;Los Angeles\u0026#34;}\nPrintStr(d1)\nPrintStr(d2)\u003c/pre\u003e\n\u003cp\u003e上面这段代码，我们可以看到——\u003cstrong\u003e我们使用了一个叫\u003ccode\u003eStringable\u003c/code\u003e 的接口，我们用这个接口把“业务类型” \u003ccode\u003eCountry\u003c/code\u003e 和 \u003ccode\u003eCity\u003c/code\u003e 和“控制逻辑” \u003ccode\u003ePrint()\u003c/code\u003e 给解耦了。\u003c/strong\u003e于是，只要实现了\u003ccode\u003eStringable\u003c/code\u003e 接口，都可以传给 \u003ccode\u003ePrintStr()\u003c/code\u003e 来使用。\u003c/p\u003e\n\u003cp\u003e这种编程模式在Go 的标准库有很多的示例，最著名的就是 \u003ccode\u003eio.Read\u003c/code\u003e 和 \u003ccode\u003eioutil.ReadAll\u003c/code\u003e 的玩法，其中 \u003ccode\u003eio.Read\u003c/code\u003e 是一个接口，你需要实现他的一个 \u003ccode\u003eRead(p []byte) (n int, err error)\u003c/code\u003e 接口方法，只要满足这个规模，就可以被 \u003ccode\u003eioutil.ReadAll\u003c/code\u003e这个方法所使用。\u003cstrong\u003e这就是面向对象编程方法的黄金法则——“Program to an interface not an implementation”\u003c/strong\u003e\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%8E%A5%E5%8F%A3%E5%AE%8C%E6%95%B4%E6%80%A7%E6%A3%80%E6%9F%A5\"\u003e\u003c/span\u003e接口完整性检查\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e另外，我们可以看到，Go语言的编程器并没有严格检查一个对象是否实现了某接口所有的接口方法，如下面这个示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003etype Shape interface {\n    Sides() int\n    Area() int\n}\ntype Square struct {\n    len int\n}\nfunc (s* Square) Sides() int {\n    return 4\n}\nfunc main() {\n    s := Square{len: 5}\n    fmt.Printf(\u0026#34;%d\\n\u0026#34;,s.Sides())\n}\u003c/pre\u003e\n\u003cp\u003e我们可以看到 \u003ccode\u003eSquare\u003c/code\u003e 并没有实现 \u003ccode\u003eShape\u003c/code\u003e 接口的所有方法，程序虽然可以跑通，但是这样编程的方式并不严谨，如果我们需要强制实现接口的所有方法，那么我们应该怎么办呢？\u003c/p\u003e\n\u003cp\u003e在Go语言编程圈里有一个比较标准的作法：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\"\u003evar _ Shape = (*Square)(nil)\u003c/pre\u003e\n\u003cp\u003e声明一个 \u003ccode\u003e_\u003c/code\u003e 变量（没人用），其会把一个 \u003ccode\u003enil\u003c/code\u003e 的空指针，从 \u003ccode\u003eSquare\u003c/code\u003e 转成 \u003ccode\u003eShape\u003c/code\u003e，这样，如果没有实现完相关的接口方法，编译器就会报错：\u003c/p\u003e\n\u003cblockquote\u003e\u003cp\u003ecannot use (*Square)(nil) (type *Square) as type Shape in assignment: *Square does not implement Shape (missing Area method)\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这样就做到了个强验证的方法。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%97%B6%E9%97%B4\"\u003e\u003c/span\u003e时间\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e对于时间来说，这应该是编程中比较复杂的问题了，相信我，时间是一种非常复杂的事（比如《\u003ca title=\"你确信你了解时间吗？\" href=\"https://coolshell.cn/articles/5075.html\" target=\"_blank\" rel=\"noopener\"\u003e你确信你了解时间吗？\u003c/a\u003e》、《\u003ca title=\"关于闰秒\" href=\"https://coolshell.cn/articles/7804.html\"\u003e关于闰秒\u003c/a\u003e》等文章）。而且，时间有时区、格式、精度等等问题，其复杂度不是一般人能处理的。所以，一定要重用已有的时间处理，而不是自己干。\u003c/p\u003e\n\u003cp\u003e在 Go 语言中，你一定要使用 \u003ccode\u003etime.Time\u003c/code\u003e 和 \u003ccode\u003etime.Duration\u003c/code\u003e 两个类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在命令行上，\u003ccode\u003eflag\u003c/code\u003e 通过 \u003ccode\u003etime.ParseDuration\u003c/code\u003e 支持了 \u003ccode\u003etime.Duration\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eJSon 中的 \u003ccode\u003eencoding/json\u003c/code\u003e 中也可以把\u003ccode\u003etime.Time\u003c/code\u003e 编码成 \u003ca href=\"https://tools.ietf.org/html/rfc3339\" target=\"_blank\" rel=\"noopener\"\u003eRFC 3339\u003c/a\u003e 的格式\u003c/li\u003e\n\u003cli\u003e数据库使用的 \u003ccode\u003edatabase/sql\u003c/code\u003e 也支持把 \u003ccode\u003eDATATIME\u003c/code\u003e 或 \u003ccode\u003eTIMESTAMP\u003c/code\u003e 类型转成 \u003ccode\u003etime.Time\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eYAML你可以使用 \u003ccode\u003egopkg.in/yaml.v2\u003c/code\u003e 也支持 \u003ccode\u003etime.Time\u003c/code\u003e 、\u003ccode\u003etime.Duration\u003c/code\u003e 和 \u003ca href=\"https://tools.ietf.org/html/rfc3339\" target=\"_blank\" rel=\"noopener\"\u003eRFC 3339\u003c/a\u003e 格式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果你要和第三方交互，实在没有办法，也请使用 \u003ca href=\"https://tools.ietf.org/html/rfc3339\" target=\"_blank\" rel=\"noopener\"\u003eRFC 3339\u003c/a\u003e 的格式。\u003c/p\u003e\n\u003cp\u003e最后，如果你要做全球化跨时区的应用，你一定要把所有服务器和时间全部使用UTC时间。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%80%A7%E8%83%BD%E6%8F%90%E7%A4%BA\"\u003e\u003c/span\u003e性能提示\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eGo 语言是一个高性能的语言，但并不是说这样我们就不用关心性能了，我们还是需要关心的。下面是一个在编程方面和性能相关的提示。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果需要把数字转字符串，使用 \u003ccode\u003estrconv.Itoa()\u003c/code\u003e 会比 \u003ccode\u003efmt.Sprintf()\u003c/code\u003e 要快一倍左右\u003c/li\u003e\n\u003cli\u003e尽可能地避免把\u003ccode\u003eString\u003c/code\u003e转成\u003ccode\u003e[]Byte\u003c/code\u003e 。这个转换会导致性能下降。\u003c/li\u003e\n\u003cli\u003e如果在for-loop里对某个slice 使用 \u003ccode\u003eappend()\u003c/code\u003e请先把 slice的容量很扩充到位，这样可以避免内存重新分享以及系统自动按2的N次方幂进行扩展但又用不到，从而浪费内存。\u003c/li\u003e\n\u003cli\u003e使用\u003ccode\u003eStringBuffer\u003c/code\u003e 或是\u003ccode\u003eStringBuild\u003c/code\u003e 来拼接字符串，会比使用 \u003ccode\u003e+\u003c/code\u003e 或 \u003ccode\u003e+=\u003c/code\u003e 性能高三到四个数量级。\u003c/li\u003e\n\u003cli\u003e尽可能的使用并发的 go routine，然后使用 \u003ccode\u003esync.WaitGroup\u003c/code\u003e 来同步分片操作\u003c/li\u003e\n\u003cli\u003e避免在热代码中进行内存分配，这样会导致gc很忙。尽可能的使用 \u003ccode\u003esync.Pool\u003c/code\u003e 来重用对象。\u003c/li\u003e\n\u003cli\u003e使用 lock-free的操作，避免使用 mutex，尽可能使用 \u003ccode\u003esync/Atomic\u003c/code\u003e包。 （关于无锁编程的相关话题，可参看《\u003ca title=\"无锁队列的实现\" href=\"https://coolshell.cn/articles/8239.html\"\u003e无锁队列实现\u003c/a\u003e》或《\u003ca title=\"无锁HashMap的原理与实现\" href=\"https://coolshell.cn/articles/9703.html\"\u003e无锁Hashmap实现\u003c/a\u003e》）\u003c/li\u003e\n\u003cli\u003e使用 I/O缓冲，I/O是个非常非常慢的操作，使用 \u003ccode\u003ebufio.NewWrite()\u003c/code\u003e 和 \u003ccode\u003ebufio.NewReader()\u003c/code\u003e 可以带来更高的性能。\u003c/li\u003e\n\u003cli\u003e对于在for-loop里的固定的正则表达式，一定要使用 \u003ccode\u003eregexp.Compile()\u003c/code\u003e 编译正则表达式。性能会得升两个数量级。\u003c/li\u003e\n\u003cli\u003e如果你需要更高性能的协议，你要考虑使用 \u003ca href=\"https://github.com/golang/protobuf\" target=\"_blank\" rel=\"noopener\"\u003eprotobuf\u003c/a\u003e 或 \u003ca href=\"https://github.com/tinylib/msgp\" target=\"_blank\" rel=\"noopener\"\u003emsgp\u003c/a\u003e 而不是JSON，因为JSON的序列化和反序列化里使用了反射。\u003c/li\u003e\n\u003cli\u003e你在使用map的时候，使用整型的key会比字符串的要快，因为整型比较比字符串比较要快。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3\"\u003e\u003c/span\u003e参考文档\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e还有很多不错的技巧，下面的这些参考文档可以让你写出更好的Go的代码，必读！\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cb\u003eEffective\u003c/b\u003e \u003cb\u003eGo\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://golang.org/doc/effective_go.html\"\u003ehttps://golang.org/doc/effective_go.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eUber\u003c/b\u003e \u003cb\u003eGo\u003c/b\u003e \u003cb\u003eStyle\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://github.com/uber-go/guide/blob/master/style.md\"\u003ehttps://github.com/uber-go/guide/blob/master/style.md\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003e50 Shades of Go: Traps, Gotchas, and Common Mistakes for New Golang Devs\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\"\u003ehttp://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eGo\u003c/b\u003e \u003cb\u003eAdvice\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://github.com/cristaloleg/go-advice\"\u003ehttps://github.com/cristaloleg/go-advice\u003c/a\u003e\u003cb\u003e\u003c/b\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003ePractical Go Benchmarks\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://www.instana.com/blog/practical-golang-benchmarks/\"\u003ehttps://www.instana.com/blog/practical-golang-benchmarks/\u003c/a\u003e\u003cb\u003e\u003c/b\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eBenchmarks of Go serialization methods\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://github.com/alecthomas/go_serialization_benchmarks\"\u003ehttps://github.com/alecthomas/go_serialization_benchmarks\u003c/a\u003e\u003cb\u003e\u003c/b\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eDebugging\u003c/b\u003e \u003cb\u003eperformance\u003c/b\u003e \u003cb\u003eissues\u003c/b\u003e \u003cb\u003ein\u003c/b\u003e \u003cb\u003eGo\u003c/b\u003e \u003cb\u003eprograms\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://github.com/golang/go/wiki/Performance\"\u003ehttps://github.com/golang/go/wiki/Performance\u003c/a\u003e\u003cb\u003e\u003c/b\u003e\u003c/li\u003e\n\u003cli\u003e\u003cb\u003eGo\u003c/b\u003e \u003cb\u003ecode\u003c/b\u003e \u003cb\u003erefactoring:\u003c/b\u003e \u003cb\u003ethe\u003c/b\u003e \u003cb\u003e23x\u003c/b\u003e \u003cb\u003eperformance\u003c/b\u003e \u003cb\u003ehunt\u003cbr/\u003e\n\u003c/b\u003e\u003ca href=\"https://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7\"\u003ehttps://medium.com/@val_deleplace/go-code-refactoring-the-23x-performance-hunt-156746b522f7\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2021/09/go-generics-150x150.png\" alt=\"Go编程模式 ： 泛型编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21615.html\" class=\"wp_rp_title\"\u003eGo编程模式 ： 泛型编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.k8s-150x150.png\" alt=\"Go 编程模式：k8s Visitor 模式\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21263.html\" class=\"wp_rp_title\"\u003eGo 编程模式：k8s Visitor 模式\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.line_.-150x150.png\" alt=\"Go编程模式：Pipeline\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21228.html\" class=\"wp_rp_title\"\u003eGo编程模式：Pipeline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.pair_-150x150.png\" alt=\"Go编程模式：委托和反转控制\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21214.html\" class=\"wp_rp_title\"\u003eGo编程模式：委托和反转控制\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.generate-150x150.png\" alt=\"Go 编程模式：Go Generation\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21179.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Go Generation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-21128\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"d907f5606a\"\u003e\u003cimg id=\"rating_21128_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21128, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e8a334ff929aca57020bb390-=\"\"/\u003e\u003cimg id=\"rating_21128_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21128, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e8a334ff929aca57020bb390-=\"\"/\u003e\u003cimg id=\"rating_21128_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21128, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e8a334ff929aca57020bb390-=\"\"/\u003e\u003cimg id=\"rating_21128_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21128, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e8a334ff929aca57020bb390-=\"\"/\u003e\u003cimg id=\"rating_21128_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_half.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(21128, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.3, 5, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-e8a334ff929aca57020bb390-=\"\"/\u003e (\u003cstrong\u003e47\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.26\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_21128_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Go编程模式：切片，接口，时间和性能\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Go编程模式：切片，接口，时间和性能\"/\u003e\u003cmeta itemprop=\"description\" content=\"\n\n在本篇文章中，我会对Go语言编程模式的一些基本技术和要点，这样可以让你更容易掌握Go语言编程。其中，主要包括，数组切片的一些小坑，还有接口编程，以及时间和程序运行性能相关的话题。\n\n\n\nSlice\n\n首先，我们先来讨论一下Slice，中文翻译叫“切片”，这个东西在Go语言中不是数组，而是一个结构体，其定义如下：\n\ntype slice struct {\n    array unsafe.Poi...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2020-12-18T15:36:30+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2021-01-12T09:57:36+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/21128.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/21128.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.26\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"47\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-21128-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2020-12-18T15:36:30+08:00",
  "Author": "陈皓"
}