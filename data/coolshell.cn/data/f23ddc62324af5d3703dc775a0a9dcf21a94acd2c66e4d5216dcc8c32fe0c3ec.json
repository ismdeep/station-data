{
  "Source": "coolshell.cn",
  "Title": "Python修饰器的函数式编程",
  "Link": "https://coolshell.cn/articles/11265.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"5b84fd5b9aac2beaae110129-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" class=\"alignright wp-image-11300\" src=\"https://coolshell.cn/wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960.jpg\" alt=\"\" width=\"280\" height=\"233\" srcset=\"https://coolshell.cn/wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960.jpg 350w, https://coolshell.cn/wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960-300x249.jpg 300w, https://coolshell.cn/wp-content/uploads/2014/03/snake-hat-new-year-schedule-800x960-325x270.jpg 325w\" sizes=\"(max-width: 280px) 100vw, 280px\"/\u003ePython的修饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里去。但是OO的Decorator简直就是一场恶梦，不信你就去看看wikipedia上的词条（\u003ca href=\"https://en.wikipedia.org/wiki/Decorator_pattern\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eDecorator Pattern\u003c/a\u003e）里的UML图和那些代码，这就是我在《 \u003ca title=\"链接：从面向对象的设计模式看软件设计\" href=\"https://coolshell.cn/articles/8961.html\" rel=\"bookmark\"\u003e从面向对象的设计模式看软件设计\u003c/a\u003e》“餐后甜点”一节中说的，OO鼓励了——“厚重地胶合和复杂层次”，也是《 \u003ca title=\"链接：如此理解面向对象编程\" href=\"https://coolshell.cn/articles/8745.html\" rel=\"bookmark\"\u003e如此理解面向对象编程\u003c/a\u003e》中所说的“OO的狂热者们非常害怕处理数据”，Decorator Pattern搞出来的代码简直就是OO的反面教程。\u003c/p\u003e\n\u003cp\u003ePython 的 Decorator在使用上和Java/C#的Annotation很相似，就是在方法名前面加一个@XXX注解来为这个方法装饰一些东西。但是，Java/C#的Annotation也很让人望而却步，太TMD的复杂了，你要玩它，你需要了解一堆Annotation的类库文档，让人感觉就是在学另外一门语言。\u003c/p\u003e\n\u003cp\u003e而Python使用了一种相对于Decorator Pattern和Annotation来说非常优雅的方法，这种方法不需要你去掌握什么复杂的OO模型或是Annotation的各种类库规定，完全就是语言层面的玩法：一种函数式编程的技巧。如果你看过本站的《\u003ca href=\"https://coolshell.cn/articles/10822.html\"\u003e函数式编程\u003c/a\u003e》，你一定会为函数式编程的那种“描述你想干什么，而不是描述你要怎么去实现”的编程方式感到畅快。（如果你不了解函数式编程，那在读本文之前，还请你移步去看看《\u003ca href=\"https://coolshell.cn/articles/10822.html\"\u003e函数式编程\u003c/a\u003e》） 好了，我们先来点感性认识，看一个Python修饰器的Hello World的代码。\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-11265\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#Hello_World\" title=\"Hello World\"\u003eHello World\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#Decorator_%E7%9A%84%E6%9C%AC%E8%B4%A8\" title=\"Decorator 的本质\"\u003eDecorator 的本质\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%8A%E5%A4%9A%E4%B8%AADecrorator\" title=\"带参数及多个Decrorator\"\u003e带参数及多个Decrorator\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#class%E5%BC%8F%E7%9A%84_Decorator\" title=\"class式的 Decorator\"\u003eclass式的 Decorator\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#%E7%94%A8Decorator%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0\" title=\"用Decorator设置函数的调用参数\"\u003e用Decorator设置函数的调用参数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#Decorator%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8\" title=\"Decorator的副作用\"\u003eDecorator的副作用\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E4%B8%80%E4%BA%9Bdecorator%E7%9A%84%E7%A4%BA%E4%BE%8B\" title=\"一些decorator的示例\"\u003e一些decorator的示例\u003c/a\u003e\u003cul class=\"ez-toc-list-level-5\"\u003e\u003cli class=\"ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-8\" href=\"#%E7%BB%99%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%81%9A%E7%BC%93%E5%AD%98\" title=\"给函数调用做缓存\"\u003e给函数调用做缓存\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-9\" href=\"#Profiler%E7%9A%84%E4%BE%8B%E5%AD%90\" title=\"Profiler的例子\"\u003eProfiler的例子\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-10\" href=\"#%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\" title=\"注册回调函数\"\u003e注册回调函数\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-11\" href=\"#%E7%BB%99%E5%87%BD%E6%95%B0%E6%89%93%E6%97%A5%E5%BF%97\" title=\"给函数打日志\"\u003e给函数打日志\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-12\" href=\"#%E4%B8%80%E4%B8%AAMySQL%E7%9A%84Decorator\" title=\"一个MySQL的Decorator\"\u003e一个MySQL的Decorator\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-5\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-13\" href=\"#%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5\" title=\"线程异步\"\u003e线程异步\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-14\" href=\"#%E5%85%B6%E5%AE%83\" title=\"其它\"\u003e其它\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Hello_World\"\u003e\u003c/span\u003eHello World\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e下面是代码（文件名：hello.py）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"golang\" data-enlighter-highlight=\"1-6,8\"\u003edef hello(fn):\n    def wrapper():\n        print \u0026#34;hello, %s\u0026#34; % fn.__name__\n        fn()\n        print \u0026#34;goodby, %s\u0026#34; % fn.__name__\n    return wrapper\n\n@hello\ndef foo():\n    print \u0026#34;i am foo\u0026#34;\n\nfoo()\n\u003c/pre\u003e\n\u003cp\u003e当你运行代码，你会看到如下输出：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"shell\"\u003e[chenaho@chenhao-air]$ python hello.py\nhello, foo\ni am foo\ngoodby, foo\u003c/pre\u003e\n\u003cp\u003e你可以看到如下的东西：\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e1）函数foo前面有个@hello的“注解”，hello就是我们前面定义的函数hello\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e2）在hello函数中，其需要一个fn的参数（这就用来做回调的函数）\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003e3）hello函数中返回了一个inner函数wrapper，这个wrapper函数回调了传进来的fn，并在回调前后加了两条语句。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Decorator_%E7%9A%84%E6%9C%AC%E8%B4%A8\"\u003e\u003c/span\u003eDecorator 的本质\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e对于Python的这个@注解语法糖- Syntactic Sugar 来说，当你在用某个@decorator来修饰某个函数func时，如下所示:\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e@decorator\ndef func():\n    pass\n\u003c/pre\u003e\n\u003cp\u003e其解释器会解释成下面这样的语句：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efunc = decorator(func)\u003c/pre\u003e\n\u003cp\u003e尼玛，这不就是把一个函数当参数传到另一个函数中，然后再回调吗？是的，但是，我们需要注意，那里还有一个赋值语句，把decorator这个函数的返回值赋值回了原来的func。 根据《\u003ca href=\"https://coolshell.cn/articles/10822.html\" target=\"_blank\" rel=\"noopener noreferrer\"\u003e函数式编程\u003c/a\u003e》中的\u003cstrong\u003efirst class functions\u003c/strong\u003e中的定义的，你可以把函数当成变量来使用，所以，decorator必需得返回了一个函数出来给func，这就是所谓的\u003cstrong\u003ehigher order function \u003c/strong\u003e高阶函数，不然，后面当func()调用的时候就会出错。 就我们上面那个hello.py里的例子来说，\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e@hello\ndef foo():\n    print \u0026#34;i am foo\u0026#34;\n\u003c/pre\u003e\n\u003cp\u003e被解释成了：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e foo = hello(foo)\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e是的，这是一条语句，而且还被执行了。\u003c/strong\u003e你如果不信的话，你可以写这样的程序来试试看：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003edef fuck(fn):\n    print \u0026#34;fuck %s!\u0026#34; % fn.__name__[::-1].upper()\n\n@fuck\ndef wfg():\n    pass\n\u003c/pre\u003e\n\u003cp\u003e没了，就上面这段代码，没有调用wfg()的语句，你会发现， fuck函数被调用了，而且还很NB地输出了我们每个人的心声！\u003c/p\u003e\n\u003cp\u003e再回到我们hello.py的那个例子，我们可以看到，\u003cstrong\u003ehello(foo)返回了wrapper()函数，所以，foo其实变成了wrapper的一个变量，而后面的foo()执行其实变成了wrapper()\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e知道这点本质，当你看到有多个decorator或是带参数的decorator，你也就不会害怕了。\u003c/p\u003e\n\u003cp\u003e比如：多个decorator\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e@decorator_one\n@decorator_two\ndef func():\n    pass\u003c/pre\u003e\n\u003cp\u003e相当于：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efunc = decorator_one(decorator_two(func))\u003c/pre\u003e\n\u003cp\u003e比如：带参数的decorator：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003e@decorator(arg1, arg2)\ndef func():\n    pass\u003c/pre\u003e\n\u003cp\u003e相当于：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efunc = decorator(arg1,arg2)(func)\u003c/pre\u003e\n\u003cp\u003e这意味着decorator(arg1, arg2)这个函数需要返回一个“真正的decorator”。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%B8%A6%E5%8F%82%E6%95%B0%E5%8F%8A%E5%A4%9A%E4%B8%AADecrorator\"\u003e\u003c/span\u003e带参数及多个Decrorator\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们来看一个有点意义的例子（文件名：html.py）：\u003c/p\u003e\n\u003cp\u003e在上面这个例子中，我们可以看到：makeHtmlTag有两个参数。所以，\u003cstrong\u003e为了让 \u003cspan style=\"color: #000080;\"\u003ehello = makeHtmlTag(arg1, arg2)(hello)\u003c/span\u003e 成功，makeHtmlTag 必需返回一个decorator\u003c/strong\u003e（这就是为什么我们在makeHtmlTag中加入了real_decorator()的原因）\u003cstrong\u003e，这样一来，我们就可以进入到 decorator 的逻辑中去了\u003c/strong\u003e—— decorator得返回一个wrapper，wrapper里回调hello。\u003cstrong\u003e看似那个makeHtmlTag() 写得层层叠叠，但是，已经了解了本质的我们觉得写得很自然\u003c/strong\u003e。 你看，Python的Decorator就是这么简单，没有什么复杂的东西，你也不需要了解过多的东西，使用起来就是那么自然、体贴、干爽、透气，独有的速效凹道和完美的吸收轨迹，让你再也不用为每个月的那几天感到焦虑和不安，再加上贴心的护翼设计，量多也不用当心。对不起，我调皮了。 什么，你觉得上面那个带参数的Decorator的函数嵌套太多了，你受不了。好吧，没事，我们看看下面的方法。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"class%E5%BC%8F%E7%9A%84_Decorator\"\u003e\u003c/span\u003eclass式的 Decorator\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e首先，先得说一下，decorator的class方式，还是看个示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\" data-enlighter-highlight=\"3,7\"\u003eclass myDecorator(object):\n\n    def __init__(self, fn):\n        print \u0026#34;inside myDecorator.__init__()\u0026#34;\n        self.fn = fn\n\n    def __call__(self):\n        self.fn()\n        print \u0026#34;inside myDecorator.__call__()\u0026#34;\n\n@myDecorator\ndef aFunction():\n    print \u0026#34;inside aFunction()\u0026#34;\n\nprint \u0026#34;Finished decorating aFunction()\u0026#34;\n\naFunction()\n\n# 输出：\n# inside myDecorator.__init__()\n# Finished decorating aFunction()\n# inside aFunction()\n# inside myDecorator.__call__()\u003c/pre\u003e\n\u003cp\u003e上面这个示例展示了，用类的方式声明一个decorator。我们可以看到这个类中有两个成员：\u003cbr/\u003e\n1）一个是\u003cstrong\u003einit\u003c/strong\u003e()，这个方法是在我们给某个函数decorator时被调用，所以，需要有一个fn的参数，也就是被decorator的函数。\u003cbr/\u003e\n2）一个是\u003cstrong\u003ecall\u003c/strong\u003e()，这个方法是在我们调用被decorator函数时被调用的。\u003cbr/\u003e\n上面输出可以看到整个程序的执行顺序。\u003c/p\u003e\n\u003cp\u003e这看上去要比“函数式”的方式更易读一些。\u003c/p\u003e\n\u003cp\u003e下面，我们来看看用类的方式来重写上面的html.py的代码（文件名：html.py）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eclass makeHtmlTagClass(object):\n\n    def __init__(self, tag, css_class=\u0026#34;\u0026#34;):\n        self._tag = tag\n        self._css_class = \u0026#34; class=\u0026#39;{0}\u0026#39;\u0026#34;.format(css_class) \\\n                                       if css_class !=\u0026#34;\u0026#34; else \u0026#34;\u0026#34;\n\n    def __call__(self, fn):\n        def wrapped(*args, **kwargs):\n            return \u0026#34;\u0026lt;\u0026#34; + self._tag + self._css_class+\u0026#34;\u0026gt;\u0026#34;  \\\n                       + fn(*args, **kwargs) + \u0026#34;\u0026lt;/\u0026#34; + self._tag + \u0026#34;\u0026gt;\u0026#34;\n        return wrapped\n\n@makeHtmlTagClass(tag=\u0026#34;b\u0026#34;, css_class=\u0026#34;bold_css\u0026#34;)\n@makeHtmlTagClass(tag=\u0026#34;i\u0026#34;, css_class=\u0026#34;italic_css\u0026#34;)\ndef hello(name):\n    return \u0026#34;Hello, {}\u0026#34;.format(name)\n\nprint hello(\u0026#34;Hao Chen\u0026#34;)\n\u003c/pre\u003e\n\u003cp\u003e上面这段代码中，我们需要注意这几点：\u003cbr/\u003e\n1）如果decorator有参数的话，\u003cstrong\u003einit\u003c/strong\u003e() 成员就不能传入fn了，而fn是在\u003cstrong\u003ecall\u003c/strong\u003e的时候传入的。\u003cbr/\u003e\n2）这段代码还展示了 wrapped(*args, **kwargs) 这种方式来传递被decorator函数的参数。（其中：args是一个参数列表，kwargs是参数dict，具体的细节，请参考Python的文档或是\u003ca href=\"http://stackoverflow.com/questions/3394835/args-and-kwargs\" target=\"_blank\" rel=\"noopener noreferrer\"\u003eStackOverflow的这个问题\u003c/a\u003e，这里就不展开了）\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%94%A8Decorator%E8%AE%BE%E7%BD%AE%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%82%E6%95%B0\"\u003e\u003c/span\u003e用Decorator设置函数的调用参数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e你有三种方法可以干这个事：\u003c/p\u003e\n\u003cp\u003e第一种，通过 **kwargs，这种方法decorator会在kwargs中注入参数。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003edef decorate_A(function):\n    def wrap_function(*args, **kwargs):\n        kwargs[\u0026#39;str\u0026#39;] = \u0026#39;Hello!\u0026#39;\n        return function(*args, **kwargs)\n    return wrap_function\n\n@decorate_A\ndef print_message_A(*args, **kwargs):\n    print(kwargs[\u0026#39;str\u0026#39;])\n\nprint_message_A()\u003c/pre\u003e\n\u003cp\u003e第二种，约定好参数，直接修改参数\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003edef decorate_B(function):\n    def wrap_function(*args, **kwargs):\n        str = \u0026#39;Hello!\u0026#39;\n        return function(str, *args, **kwargs)\n    return wrap_function\n\n@decorate_B\ndef print_message_B(str, *args, **kwargs):\n    print(str)\n\nprint_message_B()\u003c/pre\u003e\n\u003cp\u003e第三种，通过 *args 注入\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003edef decorate_C(function):\n    def wrap_function(*args, **kwargs):\n        str = \u0026#39;Hello!\u0026#39;\n        #args.insert(1, str)\n        args = args +(str,)\n        return function(*args, **kwargs)\n    return wrap_function\n\nclass Printer:\n    @decorate_C\n    def print_message(self, str, *args, **kwargs):\n        print(str)\n\np = Printer()\np.print_message()\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"Decorator%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8\"\u003e\u003c/span\u003eDecorator的副作用\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e到这里，我相信你应该了解了整个Python的decorator的原理了。\u003c/p\u003e\n\u003cp\u003e相信你也会发现，被decorator的函数其实已经是另外一个函数了，对于最前面那个hello.py的例子来说，如果你查询一下foo.\u003cstrong\u003ename\u003c/strong\u003e的话，你会发现其输出的是“wrapper”，而不是我们期望的“foo”，这会给我们的程序埋一些坑。所以，Python的functool包中提供了一个叫wrap的decorator来消除这样的副作用。下面是我们新版本的 hello.py。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\" data-enlighter-highlight=\"1,3\"\u003efrom functools import wraps\ndef hello(fn):\n    @wraps(fn)\n    def wrapper():\n        print \u0026#34;hello, %s\u0026#34; % fn.__name__\n        fn()\n        print \u0026#34;goodby, %s\u0026#34; % fn.__name__\n    return wrapper\n\n@hello\ndef foo():\n    \u0026#39;\u0026#39;\u0026#39;foo help doc\u0026#39;\u0026#39;\u0026#39;\n    print \u0026#34;i am foo\u0026#34;\n    pass\n\nfoo()\nprint foo.__name__ #输出 foo\nprint foo.__doc__  #输出 foo help doc\n\u003c/pre\u003e\n\u003cp\u003e当然，即使是你用了functools的wraps，也不能完全消除这样的副作用。\u003c/p\u003e\n\u003cp\u003e来看下面这个示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efrom inspect import getmembers, getargspec\nfrom functools import wraps\n\ndef wraps_decorator(f):\n    @wraps(f)\n    def wraps_wrapper(*args, **kwargs):\n        return f(*args, **kwargs)\n    return wraps_wrapper\n\nclass SomeClass(object):\n    @wraps_decorator\n    def method(self, x, y):\n        pass\n\nobj = SomeClass()\nfor name, func in getmembers(obj, predicate=inspect.ismethod):\n    print \u0026#34;Member Name: %s\u0026#34; % name\n    print \u0026#34;Func Name: %s\u0026#34; % func.func_name\n    print \u0026#34;Args: %s\u0026#34; % getargspec(func)[0]\n\n# 输出：\n# Member Name: method\n# Func Name: method\n# Args: []\u003c/pre\u003e\n\u003cp\u003e你会发现，即使是你你用了functools的wraps，你在用getargspec时，参数也不见了。\u003c/p\u003e\n\u003cp\u003e要修正这一问，我们还得用Python的反射来解决，下面是相关的代码：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003edef get_true_argspec(method):\n    argspec = inspect.getargspec(method)\n    args = argspec[0]\n    if args and args[0] == \u0026#39;self\u0026#39;:\n        return argspec\n    if hasattr(method, \u0026#39;__func__\u0026#39;):\n        method = method.__func__\n    if not hasattr(method, \u0026#39;func_closure\u0026#39;) or method.func_closure is None:\n        raise Exception(\u0026#34;No closure for method.\u0026#34;)\n\n    method = method.func_closure[0].cell_contents\n    return get_true_argspec(method)\u003c/pre\u003e\n\u003cp\u003e当然，我相信大多数人的程序都不会去getargspec。所以，用functools的wraps应该够用了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%80%E4%BA%9Bdecorator%E7%9A%84%E7%A4%BA%E4%BE%8B\"\u003e\u003c/span\u003e一些decorator的示例\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e好了，现在我们来看一下各种decorator的例子：\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%99%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%81%9A%E7%BC%93%E5%AD%98\"\u003e\u003c/span\u003e给函数调用做缓存\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这个例实在是太经典了，整个网上都用这个例子做decorator的经典范例，因为太经典了，所以，我这篇文章也不能免俗。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efrom functools import wraps\ndef memo(fn):\n    cache = {}\n    miss = object()\n\n    @wraps(fn)\n    def wrapper(*args):\n        result = cache.get(args, miss)\n        if result is miss:\n            result = fn(*args)\n            cache[args] = result\n        return result\n\n    return wrapper\n\n@memo\ndef fib(n):\n    if n \u0026lt; 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n\u003c/pre\u003e\n\u003cp\u003e上面这个例子中，是一个斐波拉契数例的递归算法。我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。\u003c/p\u003e\n\u003cp\u003e而我们用decorator，在调用函数前查询一下缓存，如果没有才调用了，有了就从缓存中返回值。一下子，这个递归从二叉树式的递归成了线性的递归。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"Profiler%E7%9A%84%E4%BE%8B%E5%AD%90\"\u003e\u003c/span\u003eProfiler的例子\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e这个例子没什么高深的，就是实用一些。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eimport cProfile, pstats, StringIO\n\ndef profiler(func):\n    def wrapper(*args, **kwargs):\n        datafn = func.__name__ + \u0026#34;.profile\u0026#34; # Name the data file\n        prof = cProfile.Profile()\n        retval = prof.runcall(func, *args, **kwargs)\n        #prof.dump_stats(datafn)\n        s = StringIO.StringIO()\n        sortby = \u0026#39;cumulative\u0026#39;\n        ps = pstats.Stats(prof, stream=s).sort_stats(sortby)\n        ps.print_stats()\n        print s.getvalue()\n        return retval\n\n    return wrapper\n\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E6%B3%A8%E5%86%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0\"\u003e\u003c/span\u003e注册回调函数\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面这个示例展示了通过URL的路由来调用相关注册的函数示例：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eclass MyApp():\n    def __init__(self):\n        self.func_map = {}\n\n    def register(self, name):\n        def func_wrapper(func):\n            self.func_map[name] = func\n            return func\n        return func_wrapper\n\n    def call_method(self, name=None):\n        func = self.func_map.get(name, None)\n        if func is None:\n            raise Exception(\u0026#34;No function registered against - \u0026#34; + str(name))\n        return func()\n\napp = MyApp()\n\n@app.register(\u0026#39;/\u0026#39;)\ndef main_page_func():\n    return \u0026#34;This is the main page.\u0026#34;\n\n@app.register(\u0026#39;/next_page\u0026#39;)\ndef next_page_func():\n    return \u0026#34;This is the next page.\u0026#34;\n\nprint app.call_method(\u0026#39;/\u0026#39;)\nprint app.call_method(\u0026#39;/next_page\u0026#39;)\n\u003c/pre\u003e\n\u003cp\u003e注意：\u003cbr/\u003e\n1）上面这个示例中，用类的实例来做decorator。\u003cbr/\u003e\n2）decorator类中没有\u003cstrong\u003ecall\u003c/strong\u003e()，但是wrapper返回了原函数。所以，原函数没有发生任何变化。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BB%99%E5%87%BD%E6%95%B0%E6%89%93%E6%97%A5%E5%BF%97\"\u003e\u003c/span\u003e给函数打日志\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面这个示例演示了一个logger的decorator，这个decorator输出了函数名，参数，返回值，和运行时间。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efrom functools import wraps\ndef logger(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        ts = time.time()\n        result = fn(*args, **kwargs)\n        te = time.time()\n        print \u0026#34;function      = {0}\u0026#34;.format(fn.__name__)\n        print \u0026#34;    arguments = {0} {1}\u0026#34;.format(args, kwargs)\n        print \u0026#34;    return    = {0}\u0026#34;.format(result)\n        print \u0026#34;    time      = %.6f sec\u0026#34; % (te-ts)\n        return result\n    return wrapper\n\n@logger\ndef multipy(x, y):\n    return x * y\n\n@logger\ndef sum_num(n):\n    s = 0\n    for i in xrange(n+1):\n        s += i\n    return s\n\nprint multipy(2, 10)\nprint sum_num(100)\nprint sum_num(10000000)\u003c/pre\u003e\n\u003cp\u003e上面那个打日志还是有点粗糙，让我们看一个更好一点的（带log level参数的）：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eimport inspect\ndef get_line_number():\n    return inspect.currentframe().f_back.f_back.f_lineno\n\ndef logger(loglevel):\n    def log_decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            ts = time.time()\n            result = fn(*args, **kwargs)\n            te = time.time()\n            print \u0026#34;function   = \u0026#34; + fn.__name__,\n            print \u0026#34;    arguments = {0} {1}\u0026#34;.format(args, kwargs)\n            print \u0026#34;    return    = {0}\u0026#34;.format(result)\n            print \u0026#34;    time      = %.6f sec\u0026#34; % (te-ts)\n            if (loglevel == \u0026#39;debug\u0026#39;):\n                print \u0026#34;    called_from_line : \u0026#34; + str(get_line_number())\n            return result\n        return wrapper\n    return log_decorator\u003c/pre\u003e\n\u003cp\u003e但是，上面这个带log level参数的有两具不好的地方，\u003cbr/\u003e\n1） loglevel不是debug的时候，还是要计算函数调用的时间。\u003cbr/\u003e\n2） 不同level的要写在一起，不易读。\u003c/p\u003e\n\u003cp\u003e我们再接着改进：\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eimport inspect\n\ndef advance_logger(loglevel):\n\n    def get_line_number():\n        return inspect.currentframe().f_back.f_back.f_lineno\n\n    def _basic_log(fn, result, *args, **kwargs):\n        print \u0026#34;function   = \u0026#34; + fn.__name__,\n        print \u0026#34;    arguments = {0} {1}\u0026#34;.format(args, kwargs)\n        print \u0026#34;    return    = {0}\u0026#34;.format(result)\n\n    def info_log_decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            result = fn(*args, **kwargs)\n            _basic_log(fn, result, args, kwargs)\n        return wrapper\n\n    def debug_log_decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            ts = time.time()\n            result = fn(*args, **kwargs)\n            te = time.time()\n            _basic_log(fn, result, args, kwargs)\n            print \u0026#34;    time      = %.6f sec\u0026#34; % (te-ts)\n            print \u0026#34;    called_from_line : \u0026#34; + str(get_line_number())\n        return wrapper\n\n    if loglevel is \u0026#34;debug\u0026#34;:\n        return debug_log_decorator\n    else:\n        return info_log_decorator\n\u003c/pre\u003e\n\u003cp\u003e你可以看到两点，\u003cbr/\u003e\n1）我们分了两个log level，一个是info的，一个是debug的，然后我们在外尾根据不同的参数返回不同的decorator。\u003cbr/\u003e\n2）我们把info和debug中的相同的代码抽到了一个叫_basic_log的函数里，DRY原则。\u003c/p\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%80%E4%B8%AAMySQL%E7%9A%84Decorator\"\u003e\u003c/span\u003e一个MySQL的Decorator\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面这个decorator是我在工作中用到的代码，我简化了一下，把DB连接池的代码去掉了，这样能简单点，方便阅读。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003eimport umysql\nfrom functools import wraps\n\nclass Configuraion:\n    def __init__(self, env):\n        if env == \u0026#34;Prod\u0026#34;:\n            self.host    = \u0026#34;coolshell.cn\u0026#34;\n            self.port    = 3306\n            self.db      = \u0026#34;coolshell\u0026#34;\n            self.user    = \u0026#34;coolshell\u0026#34;\n            self.passwd  = \u0026#34;fuckgfw\u0026#34;\n        elif env == \u0026#34;Test\u0026#34;:\n            self.host   = \u0026#39;localhost\u0026#39;\n            self.port   = 3300\n            self.user   = \u0026#39;coolshell\u0026#39;\n            self.db     = \u0026#39;coolshell\u0026#39;\n            self.passwd = \u0026#39;fuckgfw\u0026#39;\n\ndef mysql(sql):\n\n    _conf = Configuraion(env=\u0026#34;Prod\u0026#34;)\n\n    def on_sql_error(err):\n        print err\n        sys.exit(-1)\n\n    def handle_sql_result(rs):\n        if rs.rows \u0026gt; 0:\n            fieldnames = [f[0] for f in rs.fields]\n            return [dict(zip(fieldnames, r)) for r in rs.rows]\n        else:\n            return []\n\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            mysqlconn = umysql.Connection()\n            mysqlconn.settimeout(5)\n            mysqlconn.connect(_conf.host, _conf.port, _conf.user, \\\n                              _conf.passwd, _conf.db, True, \u0026#39;utf8\u0026#39;)\n            try:\n                rs = mysqlconn.query(sql, {})\n            except umysql.Error as e:\n                on_sql_error(e)\n\n            data = handle_sql_result(rs)\n            kwargs[\u0026#34;data\u0026#34;] = data\n            result = fn(*args, **kwargs)\n            mysqlconn.close()\n            return result\n        return wrapper\n\n    return decorator\n\n@mysql(sql = \u0026#34;select * from coolshell\u0026#34; )\ndef get_coolshell(data):\n    ... ...\n    ... ..\n\u003c/pre\u003e\n\u003ch5\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%BA%BF%E7%A8%8B%E5%BC%82%E6%AD%A5\"\u003e\u003c/span\u003e线程异步\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h5\u003e\n\u003cp\u003e下面量个非常简单的异步执行的decorator，注意，异步处理并不简单，下面只是一个示例。\u003c/p\u003e\n\u003cpre class=\"EnlighterJSRAW\" data-enlighter-language=\"python\"\u003efrom threading import Thread\nfrom functools import wraps\n\ndef async(func):\n    @wraps(func)\n    def async_func(*args, **kwargs):\n        func_hl = Thread(target = func, args = args, kwargs = kwargs)\n        func_hl.start()\n        return func_hl\n\n    return async_func\n\nif __name__ == \u0026#39;__main__\u0026#39;:\n    from time import sleep\n\n    @async\n    def print_somedata():\n        print \u0026#39;starting print_somedata\u0026#39;\n        sleep(2)\n        print \u0026#39;print_somedata: 2 sec passed\u0026#39;\n        sleep(2)\n        print \u0026#39;print_somedata: 2 sec passed\u0026#39;\n        sleep(2)\n        print \u0026#39;finished print_somedata\u0026#39;\n\n    def main():\n        print_somedata()\n        print \u0026#39;back in main\u0026#39;\n        print_somedata()\n        print \u0026#39;back in main\u0026#39;\n\n    main()\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%85%B6%E5%AE%83\"\u003e\u003c/span\u003e其它\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e关于更多的示例，你可以参看： \u003ca href=\"https://wiki.python.org/moin/PythonDecoratorLibrary\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePython Decorator Library\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e关于Python Decroator的各种提案，可以参看：\u003ca href=\"https://wiki.python.org/moin/PythonDecoratorProposals\" target=\"_blank\" rel=\"noopener noreferrer\"\u003ePython Decorator Proposals\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（全文完）\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2017/06/go-hardhat-150x150.png\" alt=\"Go编程模式：修饰器\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17929.html\" class=\"wp_rp_title\"\u003eGo编程模式：修饰器\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/10822.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2013/12/yoda-lambda-150x150.png\" alt=\"函数式编程\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/10822.html\" class=\"wp_rp_title\"\u003e函数式编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.map_.reduce-150x150.png\" alt=\"Go编程模式：Map-Reduce\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21164.html\" class=\"wp_rp_title\"\u003eGo编程模式：Map-Reduce\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2020/12/go.options-150x150.png\" alt=\"Go 编程模式：Functional Options\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/21146.html\" class=\"wp_rp_title\"\u003eGo 编程模式：Functional Options\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/19612.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2019/07/1920px-Margaret_Hamilton_-_restoration-e1563697198766-1-150x150.jpg\" alt=\"50年前的登月程序和程序员有多硬核\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/19612.html\" class=\"wp_rp_title\"\u003e50年前的登月程序和程序员有多硬核\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/05/300x262-150x150.jpg\" alt=\"程序员练级攻略（2018)  与我的专栏\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18360.html\" class=\"wp_rp_title\"\u003e程序员练级攻略（2018) 与我的专栏\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-11265\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"9da0344b8e\"\u003e\u003cimg id=\"rating_11265_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11265, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5b84fd5b9aac2beaae110129-=\"\"/\u003e\u003cimg id=\"rating_11265_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11265, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5b84fd5b9aac2beaae110129-=\"\"/\u003e\u003cimg id=\"rating_11265_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11265, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5b84fd5b9aac2beaae110129-=\"\"/\u003e\u003cimg id=\"rating_11265_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11265, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5b84fd5b9aac2beaae110129-=\"\"/\u003e\u003cimg id=\"rating_11265_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(11265, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-5b84fd5b9aac2beaae110129-=\"\"/\u003e (\u003cstrong\u003e41\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.22\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_11265_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Python修饰器的函数式编程\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Python修饰器的函数式编程\"/\u003e\u003cmeta itemprop=\"description\" content=\"Python的修饰器的英文名叫Decorator，当你看到这个英文名的时候，你可能会把其跟Design Pattern里的Decorator搞混了，其实这是完全不同的两个东西。虽然好像，他们要干的事都很相似——都是想要对一个已有的模块做一些“修饰工作”，所谓修饰工作就是想给现有的模块加上一些小装饰（一些小功能，这些小功能可能好多模块都会用到），但又不让这个小装饰（小功能）侵入到原有的模块中的代码里...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2014-03-20T09:50:34+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2020-07-08T17:38:17+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/11265.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/11265.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.22\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"41\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-11265-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2014-03-20T09:50:34+08:00",
  "Author": "陈皓"
}