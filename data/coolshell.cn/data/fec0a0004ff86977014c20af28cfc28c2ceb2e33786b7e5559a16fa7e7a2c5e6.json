{
  "Source": "coolshell.cn",
  "Title": "Docker基础技术：Linux CGroup",
  "Link": "https://coolshell.cn/articles/17049.html",
  "Content": "\u003cdiv class=\"entry-content\"\u003e\n\u003cp\u003e\u003cscript async=\"\" src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3415450859608158\" crossorigin=\"anonymous\" type=\"0ab81aad6356cfe10903d8c4-text/javascript\"\u003e\u003c/script\u003e\u003cimg decoding=\"async\" src=\"https://coolshell.cn/wp-content/uploads/2015/04/filter.png\" alt=\"filter\" width=\"224\" height=\"225\" class=\"alignright size-full wp-image-17097\" srcset=\"https://coolshell.cn/wp-content/uploads/2015/04/filter.png 224w, https://coolshell.cn/wp-content/uploads/2015/04/filter-150x150.png 150w, https://coolshell.cn/wp-content/uploads/2015/04/filter-200x200.png 200w\" sizes=\"(max-width: 224px) 100vw, 224px\"/\u003e前面，我们介绍了\u003ca title=\"Docker基础技术：Linux Namespace\" href=\"https://coolshell.cn/articles/17010.html\" target=\"_blank\"\u003eLinux Namespace\u003c/a\u003e，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGroup出来了的原因。\u003c/p\u003e\n\u003cp\u003eLinux CGroup全称Linux Control Group， 是Linux内核的一个功能，用来限制，控制与分离一个进程组群的资源（如CPU、内存、磁盘输入输出等）。这个项目最早是由Google的工程师在2006年发起（主要是Paul Menage和Rohit Seth），最早的名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词太过广泛，为避免混乱，被重命名为cgroup，并且被合并到2.6.24版的内核中去。然后，其它开始了他的发展。\u003c/p\u003e\n\u003cp\u003eLinux CGroupCgroup 可​​​让​​​您​​​为​​​系​​​统​​​中​​​所​​​运​​​行​​​任​​​务​​​（进​​​程​​​）的​​​用​​​户​​​定​​​义​​​组​​​群​​​分​​​配​​​资​​​源​​​ — 比​​​如​​​ CPU 时​​​间​​​、​​​系​​​统​​​内​​​存​​​、​​​网​​​络​​​带​​​宽​​​或​​​者​​​这​​​些​​​资​​​源​​​的​​​组​​​合​​​。​​​您​​​可​​​以​​​监​​​控​​​您​​​配​​​置​​​的​​​ cgroup，拒​​​绝​​​ cgroup 访​​​问​​​某​​​些​​​资​​​源​​​，甚​​​至​​​在​​​运​​​行​​​的​​​系​​​统​​​中​​​动​​​态​​​配​​​置​​​您​​​的​​​ cgroup。\u003c/p\u003e\n\u003cp\u003e主要提供了如下功能：\u003c/p\u003e\n\u003cp\u003e\u003cspan id=\"more-17049\"\u003e\u003c/span\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eResource limitation\u003c/strong\u003e: 限制资源使用，比如内存使用上限以及文件系统的缓存限制。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePrioritization\u003c/strong\u003e: 优先级控制，比如：CPU利用和磁盘IO吞吐。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAccounting\u003c/strong\u003e: 一些审计或一些统计，主要目的是为了计费。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eControl\u003c/strong\u003e: 挂起进程，恢复执行进程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使​​​用​​​ cgroup，系​​​统​​​管​​​理​​​员​​​可​​​更​​​具​​​体​​​地​​​控​​​制​​​对​​​系​​​统​​​资​​​源​​​的​​​分​​​配​​​、​​​优​​​先​​​顺​​​序​​​、​​​拒​​​绝​​​、​​​管​​​理​​​和​​​监​​​控​​​。​​​可​​​更​​​好​​​地​​​根​​​据​​​任​​​务​​​和​​​用​​​户​​​分​​​配​​​硬​​​件​​​资​​​源​​​，提​​​高​​​总​​​体​​​效​​​率​​​。\u003c/p\u003e\n\u003cp\u003e在实践中，系统管理员一般会利用CGroup做下面这些事（有点像为某个虚拟机分配资源似的）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e隔离一个进程集合（比如：nginx的所有进程），并限制他们所消费的资源，比如绑定CPU的核。\u003c/li\u003e\n\u003cli\u003e为这组进程 分配其足够使用的内存\u003c/li\u003e\n\u003cli\u003e为这组进程分配相应的网络带宽和磁盘存储限制\u003c/li\u003e\n\u003cli\u003e限制访问某些设备（通过设置设备的白名单）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那么CGroup是怎么干的呢？我们先来点感性认识吧。\u003c/p\u003e\n\u003cp\u003e首先，Linux把CGroup这个事实现成了一个file system，你可以mount。在我的Ubuntu 14.04下，你输入以下命令你就可以看到cgroup已为你mount好了。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003ehchen@ubuntu:~$ mount -t cgroup\ncgroup on /sys/fs/cgroup/cpuset type cgroup (rw,relatime,cpuset)\ncgroup on /sys/fs/cgroup/cpu type cgroup (rw,relatime,cpu)\ncgroup on /sys/fs/cgroup/cpuacct type cgroup (rw,relatime,cpuacct)\ncgroup on /sys/fs/cgroup/memory type cgroup (rw,relatime,memory)\ncgroup on /sys/fs/cgroup/devices type cgroup (rw,relatime,devices)\ncgroup on /sys/fs/cgroup/freezer type cgroup (rw,relatime,freezer)\ncgroup on /sys/fs/cgroup/blkio type cgroup (rw,relatime,blkio)\ncgroup on /sys/fs/cgroup/net_prio type cgroup (rw,net_prio)\ncgroup on /sys/fs/cgroup/net_cls type cgroup (rw,net_cls)\ncgroup on /sys/fs/cgroup/perf_event type cgroup (rw,relatime,perf_event)\ncgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,relatime,hugetlb)\u003c/pre\u003e\n\u003cp\u003e或者使用lssubsys命令：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ lssubsys  -m\ncpuset /sys/fs/cgroup/cpuset\ncpu /sys/fs/cgroup/cpu\ncpuacct /sys/fs/cgroup/cpuacct\nmemory /sys/fs/cgroup/memory\ndevices /sys/fs/cgroup/devices\nfreezer /sys/fs/cgroup/freezer\nblkio /sys/fs/cgroup/blkio\nnet_cls /sys/fs/cgroup/net_cls\nnet_prio /sys/fs/cgroup/net_prio\nperf_event /sys/fs/cgroup/perf_event\nhugetlb /sys/fs/cgroup/hugetlb\u003c/pre\u003e\n\u003cp\u003e我们可以看到，在/sys/fs下有一个cgroup的目录，这个目录下还有很多子目录，比如： cpu，cpuset，memory，blkio……这些，这些都是cgroup的子系统。分别用于干不同的事的。\u003c/p\u003e\n\u003cp\u003e如果你没有看到上述的目录，你可以自己mount，下面给了一个示例：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003emkdir cgroup\nmount -t tmpfs cgroup_root ./cgroup\nmkdir cgroup/cpuset\nmount -t cgroup -ocpuset cpuset ./cgroup/cpuset/\nmkdir cgroup/cpu\nmount -t cgroup -ocpu cpu ./cgroup/cpu/\nmkdir cgroup/memory\nmount -t cgroup -omemory memory ./cgroup/memory/\u003c/pre\u003e\n\u003cp\u003e一旦mount成功，你就会看到这些目录下就有好文件了，比如，如下所示的cpu和cpuset的子系统：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003ehchen@ubuntu:~$ ls /sys/fs/cgroup/cpu /sys/fs/cgroup/cpuset/ \n/sys/fs/cgroup/cpu:\ncgroup.clone_children  cgroup.sane_behavior  cpu.shares         release_agent\ncgroup.event_control   cpu.cfs_period_us     cpu.stat           tasks\ncgroup.procs           cpu.cfs_quota_us      notify_on_release  user\n\n/sys/fs/cgroup/cpuset/:\ncgroup.clone_children  cpuset.mem_hardwall             cpuset.sched_load_balance\ncgroup.event_control   cpuset.memory_migrate           cpuset.sched_relax_domain_level\ncgroup.procs           cpuset.memory_pressure          notify_on_release\ncgroup.sane_behavior   cpuset.memory_pressure_enabled  release_agent\ncpuset.cpu_exclusive   cpuset.memory_spread_page       tasks\ncpuset.cpus            cpuset.memory_spread_slab       user\ncpuset.mem_exclusive   cpuset.mems\u003c/pre\u003e\n\u003cp\u003e你可以到/sys/fs/cgroup的各个子目录下去make个dir，你会发现，一旦你创建了一个子目录，这个子目录里又有很多文件了。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003ehchen@ubuntu:/sys/fs/cgroup/cpu$ sudo mkdir haoel\n[sudo] password for hchen: \nhchen@ubuntu:/sys/fs/cgroup/cpu$ ls ./haoel\ncgroup.clone_children  cgroup.procs       cpu.cfs_quota_us  cpu.stat           tasks\ncgroup.event_control   cpu.cfs_period_us  cpu.shares        notify_on_release\u003c/pre\u003e\n\u003cp\u003e好了，我们来看几个示例。\u003c/p\u003e\n\u003cdiv id=\"ez-toc-container\" class=\"ez-toc-v2_0_48 counter-hierarchy ez-toc-counter ez-toc-grey ez-toc-container-direction\"\u003e\n\u003cdiv class=\"ez-toc-title-container\"\u003e\n\u003cp class=\"ez-toc-title\"\u003e目录\u003c/p\u003e\n\u003cspan class=\"ez-toc-title-toggle\"\u003e\u003c/span\u003e\u003c/div\u003e\n\u003cnav\u003e\u003cul class=\"ez-toc-list ez-toc-list-level-1 \"\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-1\" href=\"#CPU_%E9%99%90%E5%88%B6\" title=\"CPU 限制\"\u003eCPU 限制\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-2\" href=\"#%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6\" title=\"内存使用限制\"\u003e内存使用限制\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-3\" href=\"#%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6\" title=\"磁盘I/O限制\"\u003e磁盘I/O限制\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-4\" href=\"#CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F\" title=\"CGroup的子系统\"\u003eCGroup的子系统\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-5\" href=\"#CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD\" title=\"CGroup的术语\"\u003eCGroup的术语\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-6\" href=\"#%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup\" title=\"下一代的CGroup\"\u003e下一代的CGroup\u003c/a\u003e\u003c/li\u003e\u003cli class=\"ez-toc-page-1 ez-toc-heading-level-4\"\u003e\u003ca class=\"ez-toc-link ez-toc-heading-7\" href=\"#%E5%8F%82%E8%80%83\" title=\"参考\"\u003e参考\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/nav\u003e\u003c/div\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CPU_%E9%99%90%E5%88%B6\"\u003e\u003c/span\u003eCPU 限制\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e假设，我们有一个非常吃CPU的程序，叫deadloop，其源码如下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003eint main(void)\n{\n    int i = 0;\n    for(;;) i++;\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e用sudo执行起来后，毫无疑问，CPU被干到了100%（下面是top命令的输出）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     \n 3529 root      20   0    4196    736    656 R 99.6  0.1   0:23.13 deadloop   \u003c/pre\u003e\n\u003cp\u003e然后，我们这前不是在/sys/fs/cgroup/cpu下创建了一个haoel的group。我们先设置一下这个group的cpu利用的限制：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003ehchen@ubuntu:~# cat /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us \n-1\nroot@ubuntu:~# echo 20000 \u0026gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us\u003c/pre\u003e\n\u003cp\u003e我们看到，这个进程的PID是3529，我们把这个进程加到这个cgroup中：\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e# echo 3529 \u0026gt;\u0026gt; /sys/fs/cgroup/cpu/haoel/tasks\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e然后，就会在top中看到CPU的利用立马下降成20%了。（前面我们设置的20000就是20%的意思）\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e  PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND     \n 3529 root      20   0    4196    736    656 R 19.9  0.1   8:06.11 deadloop    \u003c/pre\u003e\n\u003cp\u003e下面的代码是一个线程的示例：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#define _GNU_SOURCE         /* See feature_test_macros(7) */\n\n#include \u0026lt;pthread.h\u0026gt;\n#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;sys/stat.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n#include \u0026lt;sys/syscall.h\u0026gt;\n\n\nconst int NUM_THREADS = 5;\n\nvoid *thread_main(void *threadid)\n{\n    /* 把自己加入cgroup中（syscall(SYS_gettid)为得到线程的系统tid） */\n    char cmd[128];\n    sprintf(cmd, \u0026#34;echo %ld \u0026gt;\u0026gt; /sys/fs/cgroup/cpu/haoel/tasks\u0026#34;, syscall(SYS_gettid));\n    system(cmd); \n    sprintf(cmd, \u0026#34;echo %ld \u0026gt;\u0026gt; /sys/fs/cgroup/cpuset/haoel/tasks\u0026#34;, syscall(SYS_gettid));\n    system(cmd);\n\n    long tid;\n    tid = (long)threadid;\n    printf(\u0026#34;Hello World! It\u0026#39;s me, thread #%ld, pid #%ld!\\n\u0026#34;, tid, syscall(SYS_gettid));\n    \n    int a=0; \n    while(1) {\n        a++;\n    }\n    pthread_exit(NULL);\n}\nint main (int argc, char *argv[])\n{\n    int num_threads;\n    if (argc \u0026gt; 1){\n        num_threads = atoi(argv[1]);\n    }\n    if (num_threads\u0026lt;=0 || num_threads\u0026gt;=100){\n        num_threads = NUM_THREADS;\n    }\n\n    /* 设置CPU利用率为50% */\n    mkdir(\u0026#34;/sys/fs/cgroup/cpu/haoel\u0026#34;, 755);\n    system(\u0026#34;echo 50000 \u0026gt; /sys/fs/cgroup/cpu/haoel/cpu.cfs_quota_us\u0026#34;);\n\n    mkdir(\u0026#34;/sys/fs/cgroup/cpuset/haoel\u0026#34;, 755);\n    /* 限制CPU只能使用#2核和#3核 */\n    system(\u0026#34;echo \\\u0026#34;2,3\\\u0026#34; \u0026gt; /sys/fs/cgroup/cpuset/haoel/cpuset.cpus\u0026#34;);\n\n    pthread_t* threads = (pthread_t*) malloc (sizeof(pthread_t)*num_threads);\n    int rc;\n    long t;\n    for(t=0; t\u0026lt;num_threads; t++){\n        printf(\u0026#34;In main: creating thread %ld\\n\u0026#34;, t);\n        rc = pthread_create(\u0026amp;threads[t], NULL, thread_main, (void *)t);\n        if (rc){\n            printf(\u0026#34;ERROR; return code from pthread_create() is %d\\n\u0026#34;, rc);\n            exit(-1);\n        }\n    }\n\n    /* Last thing that main() should do */\n    pthread_exit(NULL);\n    free(threads);\n}\n\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E9%99%90%E5%88%B6\"\u003e\u003c/span\u003e内存使用限制\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们再来看一个限制内存的例子（下面的代码是个死循环，其它不断的分配内存，每次512个字节，每次休息一秒）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"c\" class=\"EnlighterJSRAW\"\u003e#include \u0026lt;stdio.h\u0026gt;\n#include \u0026lt;stdlib.h\u0026gt;\n#include \u0026lt;string.h\u0026gt;\n#include \u0026lt;sys/types.h\u0026gt;\n#include \u0026lt;unistd.h\u0026gt;\n\nint main(void)\n{\n    int size = 0;\n    int chunk_size = 512;\n    void *p = NULL;\n\n    while(1) {\n\n        if ((p = malloc(p, chunk_size)) == NULL) {\n            printf(\u0026#34;out of memory!!\\n\u0026#34;);\n            break;\n        }\n        memset(p, 1, chunk_size);\n        size += chunk_size;\n        printf(\u0026#34;[%d] - memory is allocated [%8d] bytes \\n\u0026#34;, getpid(), size);\n        sleep(1);\n    }\n    return 0;\n}\u003c/pre\u003e\n\u003cp\u003e然后，在我们另外一边：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e# 创建memory cgroup\n$ mkdir /sys/fs/cgroup/memory/haoel\n$ echo 64k \u0026gt; /sys/fs/cgroup/memory/haoel/memory.limit_in_bytes\n\n# 把上面的进程的pid加入这个cgroup\n$ echo [pid] \u0026gt; /sys/fs/cgroup/memory/haoel/tasks \u003c/pre\u003e\n\u003cp\u003e你会看到，一会上面的进程就会因为内存问题被kill掉了。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E7%A3%81%E7%9B%98IO%E9%99%90%E5%88%B6\"\u003e\u003c/span\u003e磁盘I/O限制\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e我们先看一下我们的硬盘IO，我们的模拟命令如下：（从/dev/sda1上读入数据，输出到/dev/null上）\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003esudo dd if=/dev/sda1 of=/dev/null\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们通过iotop命令我们可以看到相关的IO速度是55MB/s（虚拟机内）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO\u0026gt;    COMMAND          \n 8128 be/4 root       55.74 M/s    0.00 B/s  0.00 % 85.65 % dd if=/de~=/dev/null...\u003c/pre\u003e\n\u003cp\u003e然后，我们先创建一个blkio（块设备IO）的cgroup\u003c/p\u003e\n\u003cp\u003e\u003ccode data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003emkdir /sys/fs/cgroup/blkio/haoel\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e并把读IO限制到1MB/s，并把前面那个dd命令的pid放进去（注：8:0 是设备号，你可以通过ls -l /dev/sda1获得）：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003eroot@ubuntu:~# echo \u0026#39;8:0 1048576\u0026#39;  \u0026gt; /sys/fs/cgroup/blkio/haoel/blkio.throttle.read_bps_device \nroot@ubuntu:~# echo 8128 \u0026gt; /sys/fs/cgroup/blkio/haoel/tasks\u003c/pre\u003e\n\u003cp\u003e再用iotop命令，你马上就能看到读速度被限制到了1MB/s左右。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e  TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO\u0026gt;    COMMAND          \n 8128 be/4 root      973.20 K/s    0.00 B/s  0.00 % 94.41 % dd if=/de~=/dev/null...\u003c/pre\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CGroup%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F\"\u003e\u003c/span\u003eCGroup的子系统\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e好了，有了以上的感性认识我们来，我们来看看control group有哪些子系统：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eblkio — 这​​​个​​​子​​​系​​​统​​​为​​​块​​​设​​​备​​​设​​​定​​​输​​​入​​​/输​​​出​​​限​​​制​​​，比​​​如​​​物​​​理​​​设​​​备​​​（磁​​​盘​​​，固​​​态​​​硬​​​盘​​​，USB 等​​​等​​​）。\u003c/li\u003e\n\u003cli\u003ecpu — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​调​​​度​​​程​​​序​​​提​​​供​​​对​​​ CPU 的​​​ cgroup 任​​​务​​​访​​​问​​​。​​​\u003c/li\u003e\n\u003cli\u003ecpuacct — 这​​​个​​​子​​​系​​​统​​​自​​​动​​​生​​​成​​​ cgroup 中​​​任​​​务​​​所​​​使​​​用​​​的​​​ CPU 报​​​告​​​。​​​\u003c/li\u003e\n\u003cli\u003ecpuset — 这​​​个​​​子​​​系​​​统​​​为​​​ cgroup 中​​​的​​​任​​​务​​​分​​​配​​​独​​​立​​​ CPU（在​​​多​​​核​​​系​​​统​​​）和​​​内​​​存​​​节​​​点​​​。​​​\u003c/li\u003e\n\u003cli\u003edevices — 这​​​个​​​子​​​系​​​统​​​可​​​允​​​许​​​或​​​者​​​拒​​​绝​​​ cgroup 中​​​的​​​任​​​务​​​访​​​问​​​设​​​备​​​。​​​\u003c/li\u003e\n\u003cli\u003efreezer — 这​​​个​​​子​​​系​​​统​​​挂​​​起​​​或​​​者​​​恢​​​复​​​ cgroup 中​​​的​​​任​​​务​​​。​​​\u003c/li\u003e\n\u003cli\u003ememory — 这​​​个​​​子​​​系​​​统​​​设​​​定​​​ cgroup 中​​​任​​​务​​​使​​​用​​​的​​​内​​​存​​​限​​​制​​​，并​​​自​​​动​​​生​​​成​​​​​内​​​存​​​资​​​源使用​​​报​​​告​​​。​​​\u003c/li\u003e\n\u003cli\u003enet_cls — 这​​​个​​​子​​​系​​​统​​​使​​​用​​​等​​​级​​​识​​​别​​​符​​​（classid）标​​​记​​​网​​​络​​​数​​​据​​​包​​​，可​​​允​​​许​​​ Linux 流​​​量​​​控​​​制​​​程​​​序​​​（tc）识​​​别​​​从​​​具​​​体​​​ cgroup 中​​​生​​​成​​​的​​​数​​​据​​​包​​​。​​​\u003c/li\u003e\n\u003cli\u003enet_prio — 这个子系统用来设计网络流量的优先级\u003c/li\u003e\n\u003cli\u003ehugetlb — 这个子系统主要针对于HugeTLB系统进行限制，这是一个大页文件系统。\u003c/li\u003e\n\u003cp\u003e​​​\u003c/p\u003e\u003c/ul\u003e\n\u003cp\u003e注意，你可能在Ubuntu 14.04下看不到net_cls和net_prio这两个cgroup，你需要手动mount一下：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ sudo modprobe cls_cgroup\n$ sudo mkdir /sys/fs/cgroup/net_cls\n$ sudo mount -t cgroup -o net_cls none /sys/fs/cgroup/net_cls\n\n$ sudo modprobe netprio_cgroup\n$ sudo mkdir /sys/fs/cgroup/net_prio\n$ sudo mount -t cgroup -o net_prio none /sys/fs/cgroup/net_prio\u003c/pre\u003e\n\u003cp\u003e关于各个子系统的参数细节，以及更多的Linux CGroup的文档，你可以看看下面的文档：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.kernel.org/doc/Documentation/cgroups/\" target=\"_blank\"\u003eLinux Kernel的官方文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html#ch-Subsystems_and_Tunable_Parameters\" target=\"_blank\"\u003eRedhat的官方文档\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"CGroup%E7%9A%84%E6%9C%AF%E8%AF%AD\"\u003e\u003c/span\u003eCGroup的术语\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003eCGroup有下述术语：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e任务（Tasks）\u003c/strong\u003e：就是系统的一个进程。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e控制组（Control Group）\u003c/strong\u003e：一组按照某种标准划分的进程，比如官方文档中的Professor和Student，或是WWW和System之类的，其表示了某进程组。Cgroups中的资源控制都是以控制组为单位实现。一个进程可以加入到某个控制组。而资源的限制是定义在这个组上，就像上面示例中我用的haoel一样。简单点说，cgroup的呈现就是一个目录带一系列的可配置文件。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e层级（Hierarchy）\u003c/strong\u003e：控制组可以组织成hierarchical的形式，既一颗控制组的树（目录结构）。控制组树上的子节点继承父结点的属性。简单点说，hierarchy就是在一个或多个子系统上的cgroups目录树。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e子系统（Subsystem）\u003c/strong\u003e：一个子系统就是一个资源控制器，比如CPU子系统就是控制CPU时间分配的一个控制器。子系统必须附加到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。Cgroup的子系统可以有很多，也在不断增加中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E4%B8%8B%E4%B8%80%E4%BB%A3%E7%9A%84CGroup\"\u003e\u003c/span\u003e下一代的CGroup\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cp\u003e上面，我们可以看到，CGroup的一些常用方法和相关的术语。一般来说，这样的设计在一般情况下还是没什么问题的，除了操作上的用户体验不是很好，但基本满足我们的一般需求了。\u003c/p\u003e\n\u003cp\u003e不过，对此，有个叫Tejun Heo的同学非常不爽，他在Linux社区里\u003ca href=\"https://lwn.net/Articles/484254/\" target=\"_blank\"\u003e对cgroup吐了一把槽\u003c/a\u003e，还引发了内核组的各种讨论。\u003c/p\u003e\n\u003cp\u003e对于Tejun Heo同学来说，cgroup设计的相当糟糕。他给出了些例子，大意就是说，如果有多种层级关系，也就是说有多种对进程的分类方式，比如，我们可以按用户来分，分成Professor和Student，同时，也有按应用类似来分的，比如WWW和NFS等。那么，当一个进程即是Professor的，也是WWW的，那么就会出现多层级正交的情况，从而出现对进程上管理的混乱。另外，一个case是，如果有一个层级A绑定cpu，而层级B绑定memory，还有一个层级C绑定cputset，而有一些进程有的需要AB，有的需要AC，有的需要ABC，管理起来就相当不易。 \u003c/p\u003e\n\u003cp\u003e层级操作起来比较麻烦，而且如果层级变多，更不易于操作和管理，虽然那种方式很好实现，但是在使用上有很多的复杂度。你可以想像一个图书馆的图书分类问题，你可以有各种不同的分类，分类和图书就是一种多对多的关系。\u003c/p\u003e\n\u003cp\u003e所以，在Kernel 3.16后，引入了\u003ca href=\"http://lwn.net/Articles/601840/\" target=\"_blank\"\u003eunified hierarchy\u003c/a\u003e的新的设计，这个东西引入了一个叫\u003cstrong\u003e__DEVEL__sane_behavior\u003c/strong\u003e的特性（这个名字很明显意味目前还在开发试验阶段），它可以把所有子系统都挂载到根层级下，只有叶子节点可以存在tasks，非叶子节点只进行资源控制。\u003c/p\u003e\n\u003cp\u003e我们mount一下看看：\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e$ sudo mount -t cgroup -o __DEVEL__sane_behavior cgroup ./cgroup\n\n$ ls ./cgroup\ncgroup.controllers  cgroup.procs  cgroup.sane_behavior  cgroup.subtree_control \n\n$ cat ./cgroup/cgroup.controllers\ncpuset cpu cpuacct memory devices freezer net_cls blkio perf_event net_prio hugetlb\u003c/pre\u003e\n\u003cp\u003e我们可以看到有四个文件，然后，你在这里mkdir一个子目录，里面也会有这四个文件。\u003cstrong\u003e上级的cgroup.subtree_control控制下级的cgroup.controllers。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e举个例子：假设我们有以下的目录结构，b代表blkio，m代码memory，其中，A是root，包括所有的子系统（）。\u003c/p\u003e\n\u003cpre data-enlighter-language=\"shell\" class=\"EnlighterJSRAW\"\u003e# A(b,m) - B(b,m) - C (b)\n#               \\ - D (b) - E\n\n# 下面的命令中， +表示enable， -表示disable\n\n# 在B上的enable blkio\n# echo +blkio \u0026gt; A/cgroup.subtree_control\n\n# 在C和D上enable blkio \n# echo +blkio \u0026gt; A/B/cgroup.subtree_control\n\n# 在B上enable memory  \n# echo +memory \u0026gt; A/cgroup.subtree_control\u003c/pre\u003e\n\u003cp\u003e在上述的结构中，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ecgroup只有上线控制下级，无法传递到下下级。所以，C和D中没有memory的限制，E中没有blkio和memory的限制。而本层的cgroup.controllers文件是个只读的，其中的内容就看上级的subtree_control里有什么了。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e任何被配置过subtree_control的目录都不能绑定进程，根结点除外\u003c/strong\u003e。所以，A,C,D,E可以绑上进程，但是B不行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们可以看到，\u003cstrong\u003e这种方式干净的区分开了两个事，一个是进程的分组，一个是对分组的资源控制\u003c/strong\u003e（以前这两个事完全混在一起），在目录继承上增加了些限制，这样可以避免一些模棱两可的情况。\u003c/p\u003e\n\u003cp\u003e当然，这个事还在演化中，cgroup的这些问题这个事目前由cgroup的吐槽人Tejun Heo和华为的Li Zefan同学负责解决中。总之，这是一个系统管理上的问题，而且改变会影响很多东西，但一旦方案确定，老的cgroup方式将一去不复返。\u003c/p\u003e\n\u003ch4\u003e\u003cspan class=\"ez-toc-section\" id=\"%E5%8F%82%E8%80%83\"\u003e\u003c/span\u003e参考\u003cspan class=\"ez-toc-section-end\"\u003e\u003c/span\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.kernel.org/doc/Documentation/cgroups/\" target=\"_blank\"\u003eLinux Kernel Cgroup Documents\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html-single/Resource_Management_Guide/index.html\" target=\"_blank\"\u003eReahat Resource Management Guide\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://lwn.net/Articles/484251/\" target=\"_blank\"\u003eFixing control groups\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://lwn.net/Articles/601840/\" target=\"_blank\"\u003eThe unified control group hierarchy in 3.16\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://events.linuxfoundation.org/sites/events/files/slides/2014-KLF.pdf\" target=\"_blank\"\u003eCgroup v2(PDF)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（全文完）\u003cbr/\u003e\n\u003c/p\u003e\n\u003cdiv style=\"margin-top: 15px; font-size: 16px;color: #cc0000;\"\u003e\n\u003cp align=\"center\"\u003e\u003cstrong\u003e（转载本站文章请注明作者和出处 \u003ca href=\"https://coolshell.cn/\"\u003e酷 壳 – CoolShell\u003c/a\u003e ，请勿用于任何商业用途）\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e\n\u003cdiv class=\"wp_rp_wrap  wp_rp_vertical_m\" id=\"wp_rp_first\"\u003e\u003cdiv class=\"wp_rp_content\"\u003e\u003ch3 class=\"related_post_title\"\u003e相关文章\u003c/h3\u003e\u003cul class=\"related_post wp_rp\"\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2018/12/docker-networking-1-150x150.png\" alt=\"记一次Kubernetes/Docker网络排障\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/18654.html\" class=\"wp_rp_title\"\u003e记一次Kubernetes/Docker网络排障\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/how_to_set_up_an_iSCSI_LUN_with_thin-150x150.jpg\" alt=\"Docker基础技术：DeviceMapper\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17200.html\" class=\"wp_rp_title\"\u003eDocker基础技术：DeviceMapper\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/08/docker-filesystems-busyboxrw-150x150.png\" alt=\"Docker基础技术：AUFS\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17061.html\" class=\"wp_rp_title\"\u003eDocker基础技术：AUFS\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/isolation-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（上）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17010.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（上）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2015/04/jail_cell-150x150.jpg\" alt=\"Docker基础技术：Linux Namespace（下）\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/17029.html\" class=\"wp_rp_title\"\u003eDocker基础技术：Linux Namespace（下）\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_thumbnail\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/uploads/2022/12/eBPF-150x150.jpeg\" alt=\"eBPF 介绍\" width=\"150\" height=\"150\"/\u003e\u003c/a\u003e\u003ca href=\"https://coolshell.cn/articles/22320.html\" class=\"wp_rp_title\"\u003eeBPF 介绍\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cdiv id=\"post-ratings-17049\" class=\"post-ratings\" itemscope=\"\" itemtype=\"https://schema.org/Article\" data-nonce=\"37434a495b\"\u003e\u003cimg id=\"rating_17049_1\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"好烂啊\" title=\"好烂啊\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17049, 1, \u0026#39;好烂啊\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ab81aad6356cfe10903d8c4-=\"\"/\u003e\u003cimg id=\"rating_17049_2\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"有点差\" title=\"有点差\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17049, 2, \u0026#39;有点差\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ab81aad6356cfe10903d8c4-=\"\"/\u003e\u003cimg id=\"rating_17049_3\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"凑合看看\" title=\"凑合看看\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17049, 3, \u0026#39;凑合看看\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ab81aad6356cfe10903d8c4-=\"\"/\u003e\u003cimg id=\"rating_17049_4\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_on.gif\" alt=\"还不错\" title=\"还不错\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17049, 4, \u0026#39;还不错\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ab81aad6356cfe10903d8c4-=\"\"/\u003e\u003cimg id=\"rating_17049_5\" src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/stars_crystal/rating_off.gif\" alt=\"很精彩\" title=\"很精彩\" onmouseover=\"if (!window.__cfRLUnblockHandlers) return false; current_rating(17049, 5, \u0026#39;很精彩\u0026#39;);\" onmouseout=\"if (!window.__cfRLUnblockHandlers) return false; ratings_off(4.2, 0, 0);\" onclick=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" onkeypress=\"if (!window.__cfRLUnblockHandlers) return false; rate_post();\" style=\"cursor: pointer; border: 0px;\" data-cf-modified-0ab81aad6356cfe10903d8c4-=\"\"/\u003e (\u003cstrong\u003e68\u003c/strong\u003e 人打了分，平均分： \u003cstrong\u003e4.24\u003c/strong\u003e )\u003cbr/\u003e\u003cspan class=\"post-ratings-text\" id=\"ratings_17049_text\"\u003e\u003c/span\u003e\u003cmeta itemprop=\"name\" content=\"Docker基础技术：Linux CGroup\"/\u003e\u003cmeta itemprop=\"headline\" content=\"Docker基础技术：Linux CGroup\"/\u003e\u003cmeta itemprop=\"description\" content=\"前面，我们介绍了Linux Namespace，但是Namespace解决的问题主要是环境隔离的问题，这只是虚拟化中最最基础的一步，我们还需要解决对计算机资源使用上的隔离。也就是说，虽然你通过Namespace把我Jail到一个特定的环境中去了，但是我在其中的进程使用用CPU、内存、磁盘等这些计算资源其实还是可以随心所欲的。所以，我们希望对进程进行资源利用上的限制或控制。这就是Linux CGro...\"/\u003e\u003cmeta itemprop=\"datePublished\" content=\"2015-04-17T09:03:57+08:00\"/\u003e\u003cmeta itemprop=\"dateModified\" content=\"2015-04-17T11:51:03+08:00\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn/articles/17049.html\"/\u003e\u003cmeta itemprop=\"author\" content=\"陈皓\"/\u003e\u003cmeta itemprop=\"mainEntityOfPage\" content=\"https://coolshell.cn/articles/17049.html\"/\u003e\u003cdiv style=\"display: none;\" itemprop=\"publisher\" itemscope=\"\" itemtype=\"https://schema.org/Organization\"\u003e\u003cmeta itemprop=\"name\" content=\"酷 壳 - CoolShell\"/\u003e\u003cmeta itemprop=\"url\" content=\"https://coolshell.cn\"/\u003e\u003cdiv itemprop=\"logo\" itemscope=\"\" itemtype=\"https://schema.org/ImageObject\"\u003e\u003cmeta itemprop=\"url\" content=\"\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv style=\"display: none;\" itemprop=\"aggregateRating\" itemscope=\"\" itemtype=\"https://schema.org/AggregateRating\"\u003e\u003cmeta itemprop=\"bestRating\" content=\"5\"/\u003e\u003cmeta itemprop=\"worstRating\" content=\"1\"/\u003e\u003cmeta itemprop=\"ratingValue\" content=\"4.24\"/\u003e\u003cmeta itemprop=\"ratingCount\" content=\"68\"/\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv id=\"post-ratings-17049-loading\" class=\"post-ratings-loading\"\u003e\u003cimg src=\"https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif\" width=\"16\" height=\"16\" class=\"post-ratings-image\"/\u003eLoading...\u003c/div\u003e\n\u003c/div\u003e",
  "Date": "2015-04-17T09:03:57+08:00",
  "Author": "陈皓"
}