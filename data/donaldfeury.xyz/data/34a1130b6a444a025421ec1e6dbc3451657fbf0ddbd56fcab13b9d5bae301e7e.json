{
  "Source": "donaldfeury.xyz",
  "Title": "What are ORMs and When to Use Them",
  "Link": "https://donaldfeury.xyz/what-are-orms-and-when-to-use-them/",
  "Content": "\u003csection class=\"gh-content gh-canvas\"\u003e\n        \u003cp\u003eCheck out the video for some more elaboration on the topics below.\u003c/p\u003e\u003cfigure class=\"kg-card kg-embed-card\"\u003e\u003ciframe width=\"200\" height=\"113\" src=\"https://www.youtube.com/embed/dUyjlHm1r5A?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\u003c/figure\u003e\u003cp\u003eIf you liked it and want to know when I post more videos, be sure to \u003ca href=\"https://www.youtube.com/DonaldFeury?sub_confirmation=1\"\u003esubscribe\u003c/a\u003e\u003c/p\u003e\u003cp\u003eI\u0026#39;m about to do a few videos on some Go ORM packages and thought it wouldn\u0026#39;t hurt to do a dedicated segment on just talking about what ORMs are and why you should or shouldn\u0026#39;t use them.\u003c/p\u003e\u003ch2 id=\"what-does-orm-stand-for\"\u003eWhat does ORM stand for?\u003c/h2\u003e\u003cp\u003eORM stands for \u003cstrong\u003eObject Relation Mapping.\u003c/strong\u003e Typically this means communicating with a system using a language other than the native language is expects.\u003c/p\u003e\u003cp\u003eAn example of this would be a SQL database. A SQL database is expecting, well, a SQL query to interact with it, but what if we wanted to interact with it with something like a Golang program?\u003c/p\u003e\u003ch2 id=\"what-does-an-orm-do\"\u003eWhat does an ORM do?\u003c/h2\u003e\u003cp\u003eAn ORM library gives us the mechanism by which to perform \u003cstrong\u003eObject Relation Mapping.\u003c/strong\u003e This means we end up with structs or classes that \u003cem\u003erepresent\u003c/em\u003e something like a table in our database\u003c/p\u003e\u003cp\u003eIn Go, we would get something like this:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003euser := models.Users().ByID(1)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWhich would generate the following SQL query:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eSELECT * FROM Users WHERE id = 1;\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"pros-cons-of-orms\"\u003ePros \u0026amp; Cons of ORMs\u003c/h2\u003e\u003cp\u003ePros:\u003c/p\u003e\u003cul\u003e\u003cli\u003eMuch less time spent interacting with a database in your program\u003c/li\u003e\u003cli\u003eAbstracts away the database being used, which makes it easier to swap to another backend\u003c/li\u003e\u003cli\u003eIf you have weak SQL skills, the generated queries are at least as good as if you wrote them, if not more performant.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eCons:\u003c/p\u003e\u003cul\u003e\u003cli\u003eIf you need a very highly optimized query and you can write the said query, it may perform better than the generated ones.\u003c/li\u003e\u003cli\u003eThere is some amount of mental overhead related to learning an ORM library\u003c/li\u003e\u003cli\u003eMost ORMs require some amount of configuration\u003c/li\u003e\u003cli\u003eIt may not help you develop stronger database and/or SQL skills\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"what-kinds-of-orm-libraries-exist\"\u003eWhat kinds of ORM libraries exist?\u003c/h2\u003e\u003cp\u003eFrom my experience, there are two primary types of ORM libraries\u003c/p\u003e\u003ch3 id=\"code-first-orm\"\u003eCode-First ORM\u003c/h3\u003e\u003cp\u003eA code-first ORM uses the code written or generated by the user to generate the database schema and applies the schema to the database.\u003c/p\u003e\u003cp\u003eSome examples of code first ORMs:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://gorm.io/\"\u003eGorm\u003c/a\u003e (Go)\u003c/li\u003e\u003cli\u003eBasically every ORM in most used frameworks\u003c/li\u003e\u003cli\u003eEloquent (Laravel)\u003c/li\u003e\u003cli\u003eActiveRecord (RoR)\u003c/li\u003e\u003cli\u003eWhatever Django uses\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"schema-first-orm\"\u003eSchema-First ORM\u003c/h3\u003e\u003cp\u003eA schema first ORM reads the already defined schema from the database and generates from it, all the code necessary to interact with the database.\u003c/p\u003e\u003cp\u003eSome examples of schema first ORMs:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/volatiletech/sqlboiler\"\u003eSQLBoiler\u003c/a\u003e (Go)\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"when-to-choose-which\"\u003eWhen to choose which?\u003c/h3\u003e\u003cp\u003eCode-First ORM\u003c/p\u003e\u003cul\u003e\u003cli\u003eMost ORM libraries in my experience are code first, so a lot of choices\u003c/li\u003e\u003cli\u003eThese tend to do a lot, some code generation, acts as abstraction, and manages migrations (schema changes)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSchema First ORM\u003c/p\u003e\u003cul\u003e\u003cli\u003eNeed to get up and running quickly with an existing database (legacy data)\u003c/li\u003e\u003cli\u003eAlmost ALL of the code will be generated, vs just some being boilerplate like most code first ORMs I\u0026#39;ve used\u003c/li\u003e\u003cli\u003eYou prefer a more UNIX approach, as most schema first ORMs I\u0026#39;ve seen don\u0026#39;t handle migrations. You\u0026#39;ll need to use a separate tool or library to manage migrations.\u003c/li\u003e\u003c/ul\u003e\u003chr/\u003e\u003cp\u003eDid you find this information useful? If so, consider heading over to my \u003ca href=\"https://donaldfeury.xyz/donate/\"\u003edonation\u003c/a\u003e page and drop me some support.\u003c/p\u003e\u003cp\u003eWant to ask a question or just chat? Contact me \u003ca href=\"https://donaldfeury.xyz/contact\"\u003ehere\u003c/a\u003e\u003c/p\u003e\n    \u003c/section\u003e",
  "Date": "2021-06-27T19:12:37Z",
  "Author": "Donald Feury"
}