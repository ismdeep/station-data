{
  "Source": "donaldfeury.xyz",
  "Title": "Using Redis With Go",
  "Link": "https://donaldfeury.xyz/using-redis-with-go/",
  "Content": "\u003csection class=\"gh-content gh-canvas\"\u003e\n        \u003cp\u003eThe other day I was looking to see how difficult it would be to utilize Redis in a go program, not for a specific use case, just in general. Turns out, it\u0026#39;s pretty easy with the help of a few packages.\u003c/p\u003e\u003cp\u003eThe one I decided to use to get a feel for it was \u003ca href=\"https://github.com/gomodule/redigo\"\u003ethis\u003c/a\u003e package called redigo.\u003c/p\u003e\u003cfigure class=\"kg-card kg-embed-card\"\u003e\u003ciframe width=\"200\" height=\"113\" src=\"https://www.youtube.com/embed/jqI4g8_11eY?feature=oembed\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen=\"\"\u003e\u003c/iframe\u003e\u003c/figure\u003e\u003ch2 id=\"setup-your-project\"\u003eSetup your project\u003c/h2\u003e\u003cp\u003eIf you don\u0026#39;t have go modules initialized in your project, go ahead and do that.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ego mod init gitlab.com/dak425/golang-redis-example\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter modules are set up, we need to grab our Redis client package.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sh\"\u003ego get github.com/gomodule/redigo\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eNow we should be all ready to go (hah get it, go... I\u0026#39;ll stop now)\u003c/p\u003e\u003cfigure class=\"kg-card kg-image-card\"\u003e\u003cimg src=\"https://media.giphy.com/media/3XiQswSmbjBiU/giphy.gif\" class=\"kg-image\" alt=\"Me stopping\" loading=\"lazy\"/\u003e\u003c/figure\u003e\u003ch2 id=\"connecting-to-a-redis-instance\"\u003eConnecting to a Redis instance\u003c/h2\u003e\u003cp\u003eFirst, let\u0026#39;s connect to our Redis instance.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003econn, err := redis.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:6379\u0026#34;)\nif err != nil {\n  // Handle error\n}\ndefer conn.Close()\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe use the \u003ccode\u003eDial\u003c/code\u003e function to connect to the instance, passing in two arguments. The first is the protocol to use and the second is the address to the Redis instance you want to connect to.\u003c/p\u003e\u003cp\u003eOf course, handle errors as you deem necessary.\u003c/p\u003e\u003cp\u003eWe also add a deferred called to \u003ccode\u003econn.Close()\u003c/code\u003e to ensure our connection gets cleaned up when the program finishes.\u003c/p\u003e\u003ch2 id=\"running-redis-commands\"\u003eRunning Redis commands\u003c/h2\u003e\u003ch3 id=\"setting-a-value\"\u003eSetting a value\u003c/h3\u003e\u003cp\u003eThe redigo package doesn\u0026#39;t give us command-specific functions like \u003ccode\u003eHMSet\u003c/code\u003e or something like that. It simply gives us a method on our connection object called \u003ccode\u003eDo\u003c/code\u003e that allows us to build and send a Redis command.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003e_, err = conn.Do(\n  \u0026#34;HMSET\u0026#34;,\n  \u0026#34;podcast:1\u0026#34;,\n  \u0026#34;title\u0026#34;,\n  \u0026#34;Tech Over Tea\u0026#34;,\n  \u0026#34;creator\u0026#34;,\n  \u0026#34;Brodie Robertson\u0026#34;,\n  \u0026#34;category\u0026#34;,\n  \u0026#34;technology\u0026#34;,\n  \u0026#34;membership_fee\u0026#34;,\n  9.99,\n)\nif err != nil {\n  // Handle error\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eI\u0026#39;m building a Redis command to set multiple fields on a hash with the key of \u003ccode\u003epodcast:1\u003c/code\u003e\u003c/p\u003e\u003cp\u003eThe \u003ccode\u003eDo\u003c/code\u003e method returns a reply and an error. I wasn\u0026#39;t interested in the reply, only if there was a problem setting the hash fields for that key.\u003c/p\u003e\u003cblockquote\u003e\u003cstrong\u003eTech Over Tea\u003c/strong\u003e is an actual podcast done by a guy I\u0026#39;ve talked to named \u003cstrong\u003eBrodie Robertson\u003c/strong\u003e. He \u003cem\u003etries\u003c/em\u003e to mostly stay on tech centered subjects like Linux and crypto.\u003c/blockquote\u003e\u003cblockquote\u003eI went on it a few months ago, you can find the episode \u003ca href=\"https://www.youtube.com/watch?v=DzXLZpRS0xU\"\u003ehere\u003c/a\u003e\u003c/blockquote\u003e\u003cblockquote\u003eHe has his own channel where he showcases a bunch of neat little Linux programs and utilities. You can check it out \u003ca href=\"https://www.youtube.com/channel/UCld68syR8Wi-GY_n4CaoJGA\"\u003ehere\u003c/a\u003e\u003c/blockquote\u003e\u003ch3 id=\"reading-key-values\"\u003eReading key values\u003c/h3\u003e\u003cp\u003eNow that we have an entry in our Redis instance, let\u0026#39;s read some data back out of it.\u003c/p\u003e\u003cp\u003eFirst, let\u0026#39;s get a single field from our hash we just put in there.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003etitle, err := redis.String(conn.Do(\u0026#34;HGET\u0026#34;, \u0026#34;podcast:1\u0026#34;, \u0026#34;title\u0026#34;))\nif err != nil {\n  // handle error\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe\u0026#39;re using \u003ccode\u003eDo\u003c/code\u003e again to build and send a Redis command but you\u0026#39;ll notice it being wrapped in a method called \u003ccode\u003eString\u003c/code\u003e. The \u003ccode\u003eString\u003c/code\u003e method attempts to convert the Redis reply into a Go string. If it can\u0026#39;t, it will return an error that we can check.\u003c/p\u003e\u003cp\u003eNext, let\u0026#39;s grab ALL the entire hash.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003epodcastHash, err := redis.StringMap(conn.Do(\u0026#34;HGETALL\u0026#34;, \u0026#34;podcast:1\u0026#34;))\nif err != nil {\n  // handle error\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eWe use another of those type conversion functions called StringMap, which, if successful returns us a \u003ccode\u003emap[string]string\u003c/code\u003e that we can iterate over.\u003c/p\u003e\u003cp\u003eNow, that\u0026#39;s fine but you know what would be really nice? If we could unmarshal our Redis response into a struct we had defined. Turns out we can do that.\u003c/p\u003e\u003cp\u003eI have a podcast defined here for use.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype Podcast struct {\n  Title    string  `redis:\u0026#34;title\u0026#34;`\n  Creator  string  `redis:\u0026#34;creator\u0026#34;`\n  Category string  `redis:\u0026#34;category\u0026#34;`\n  Fee      float64 `redis:\u0026#34;membership_fee\u0026#34;`\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYou\u0026#39;ll notice we\u0026#39;ve given the struct properties a tag. This tag, not unlike the JSON tag, is used by certain packages to know how to unmarshal our Redis reply into our struct\u0026#39;s properties.\u003c/p\u003e\u003cp\u003eSo how do we unmarshal our reply into the struct using this package? Well, it is a two-step process. First, we use the \u003ccode\u003eValues\u003c/code\u003e function from the redigo package to convert our reply into a \u003ccode\u003e[]interface{}\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003evalues, err := redis.Values(conn.Do(\u0026#34;HGETALL\u0026#34;, \u0026#34;podcast:1\u0026#34;))\nif err != nil {\n  // handle error\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAfter we have our converted response, we create an instance of our struct and pass both the response and a pointer to our struct instance to a function called \u003ccode\u003eScanStruct\u003c/code\u003e.\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-go\"\u003evar podcast Podcast\nerr = redis.ScanStruct(reply, \u0026amp;podcast)\nif err != nil {\n  // handle error\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eAssuming no error occurred, if you print your struct using \u003ccode\u003ePrintf\u003c/code\u003e or other \u003ccode\u003efmt\u003c/code\u003e functions, you will see that the struct now has the values from our hash!\u003c/p\u003e\u003ch2 id=\"summary\"\u003eSummary\u003c/h2\u003e\u003cp\u003eNow you should be able to write and read data from your Redis instance with your go programs. There are some more advanced concepts you can look into regarding this package, such as connection pooling.\u003c/p\u003e\u003cp\u003eThank you for your time and be sure to check out my other Go articles on \u003ca href=\"https://donaldfeury.xyz/tag/go\"\u003ehere\u003c/a\u003e and my other videos on my \u003ca href=\"https://youtube.com/DonaldFeury?sub_confirmation=1\"\u003eYouTube\u003c/a\u003e.\u003c/p\u003e\u003chr/\u003e\u003cp\u003eDid you find this information useful? If so, consider heading over to my \u003ca href=\"https://donaldfeury.xyz/donate/\"\u003edonation\u003c/a\u003e page and drop me some support.\u003c/p\u003e\u003cp\u003eWant to ask a question or just chat? Contact me \u003ca href=\"https://donaldfeury.xyz/contact\"\u003ehere\u003c/a\u003e\u003c/p\u003e\n    \u003c/section\u003e",
  "Date": "2021-06-27T19:23:34Z",
  "Author": "Donald Feury"
}