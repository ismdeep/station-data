{
  "Source": "dunwu",
  "Title": "ForkJoin框架",
  "Link": "https://dunwu.github.io/blog/pages/edd121/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Java-Fork-Join-框架\"\u003e\u003ca href=\"#Java-Fork-Join-框架\" class=\"headerlink\" title=\"Java Fork Join 框架\"\u003e\u003c/a\u003eJava Fork Join 框架\u003c/h1\u003e\u003cp\u003e\u003cstrong\u003e对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"CompletableFuture\"\u003e\u003ca href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"\u003e\u003c/a\u003eCompletableFuture\u003c/h2\u003e\u003ch3 id=\"runAsync-和-supplyAsync-方法\"\u003e\u003ca href=\"#runAsync-和-supplyAsync-方法\" class=\"headerlink\" title=\"runAsync 和 supplyAsync 方法\"\u003e\u003c/a\u003erunAsync 和 supplyAsync 方法\u003c/h3\u003e\u003cp\u003eCompletableFuture 提供了四个静态方法来创建一个异步操作。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e CompletableFuture\u0026lt;Void\u0026gt; \u003cspan class=\"title function_\"\u003erunAsync\u003c/span\u003e\u003cspan class=\"params\"\u003e(Runnable runnable)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e CompletableFuture\u0026lt;Void\u0026gt; \u003cspan class=\"title function_\"\u003erunAsync\u003c/span\u003e\u003cspan class=\"params\"\u003e(Runnable runnable, Executor executor)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; \u003cspan class=\"title function_\"\u003esupplyAsync\u003c/span\u003e\u003cspan class=\"params\"\u003e(Supplier\u0026lt;U\u0026gt; supplier)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u0026lt;U\u0026gt; CompletableFuture\u0026lt;U\u0026gt; \u003cspan class=\"title function_\"\u003esupplyAsync\u003c/span\u003e\u003cspan class=\"params\"\u003e(Supplier\u0026lt;U\u0026gt; supplier, Executor executor)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e没有指定 Executor 的方法会使用 ForkJoinPool.commonPool() 作为它的线程池执行异步代码。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003erunAsync 方法不支持返回值。\u003c/li\u003e\n\u003cli\u003esupplyAsync 可以支持返回值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"CompletionStage\"\u003e\u003ca href=\"#CompletionStage\" class=\"headerlink\" title=\"CompletionStage\"\u003e\u003c/a\u003eCompletionStage\u003c/h2\u003e\u003cp\u003eCompletionStage 接口可以清晰地描述任务之间的时序关系，如\u003cstrong\u003e串行关系、并行关系、汇聚关系\u003c/strong\u003e等。\u003c/p\u003e\n\u003ch3 id=\"串行关系\"\u003e\u003ca href=\"#串行关系\" class=\"headerlink\" title=\"串行关系\"\u003e\u003c/a\u003e串行关系\u003c/h3\u003e\u003cp\u003eCompletionStage 接口里面描述串行关系，主要是 thenApply、thenAccept、thenRun 和 thenCompose 这四个系列的接口。\u003c/p\u003e\n\u003cp\u003ethenApply 系列函数里参数 fn 的类型是接口 \u003ccode\u003eFunction\u0026lt;T, R\u0026gt;\u003c/code\u003e，这个接口里与 CompletionStage 相关的方法是 \u003ccode\u003eR apply(T t)\u003c/code\u003e，这个方法既能接收参数也支持返回值，所以 thenApply 系列方法返回的是\u003ccode\u003eCompletionStage\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e而 thenAccept 系列方法里参数 consumer 的类型是接口 \u003ccode\u003eConsumer\u0026lt;T\u0026gt;\u003c/code\u003e，这个接口里与 CompletionStage 相关的方法是 \u003ccode\u003evoid accept(T t)\u003c/code\u003e，这个方法虽然支持参数，但却不支持回值，所以 thenAccept 系列方法返回的是\u003ccode\u003eCompletionStage\u0026lt;Void\u0026gt;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003ethenRun 系列方法里 action 的参数是 Runnable，所以 action 既不能接收参数也不支持返回值，所以 thenRun 系列方法返回的也是\u003ccode\u003eCompletionStage\u0026lt;Void\u0026gt;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这些方法里面 Async 代表的是异步执行 fn、consumer 或者 action。其中，需要你注意的是 thenCompose 系列方法，这个系列的方法会新创建出一个子流程，最终结果和 thenApply 系列是相同的。\u003c/p\u003e\n\u003ch3 id=\"描述-AND-汇聚关系\"\u003e\u003ca href=\"#描述-AND-汇聚关系\" class=\"headerlink\" title=\"描述 AND 汇聚关系\"\u003e\u003c/a\u003e描述 AND 汇聚关系\u003c/h3\u003e\u003cp\u003eCompletionStage 接口里面描述 AND 汇聚关系，主要是 thenCombine、thenAcceptBoth 和 runAfterBoth 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\u003c/p\u003e\n\u003cfigure class=\"highlight scss\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ethenCombine\u003c/span\u003e(other, fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ethenCombineAsync\u003c/span\u003e(other, fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;Void\u0026gt; \u003cspan class=\"built_in\"\u003ethenAcceptBoth\u003c/span\u003e(other, consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;Void\u0026gt; \u003cspan class=\"built_in\"\u003ethenAcceptBothAsync\u003c/span\u003e(other, consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;Void\u0026gt; \u003cspan class=\"built_in\"\u003erunAfterBoth\u003c/span\u003e(other, action);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;Void\u0026gt; \u003cspan class=\"built_in\"\u003erunAfterBothAsync\u003c/span\u003e(other, action);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"描述-OR-汇聚关系\"\u003e\u003ca href=\"#描述-OR-汇聚关系\" class=\"headerlink\" title=\"描述 OR 汇聚关系\"\u003e\u003c/a\u003e描述 OR 汇聚关系\u003c/h3\u003e\u003cp\u003eCompletionStage 接口里面描述 OR 汇聚关系，主要是 applyToEither、acceptEither 和 runAfterEither 系列的接口，这些接口的区别也是源自 fn、consumer、action 这三个核心参数不同。\u003c/p\u003e\n\u003cfigure class=\"highlight scss\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003eapplyToEither\u003c/span\u003e(other, fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003eapplyToEitherAsync\u003c/span\u003e(other, fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003eacceptEither\u003c/span\u003e(other, consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003eacceptEitherAsync\u003c/span\u003e(other, consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003erunAfterEither\u003c/span\u003e(other, action);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003erunAfterEitherAsync\u003c/span\u003e(other, action);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e下面的示例代码展示了如何使用 applyToEither() 方法来描述一个 OR 汇聚关系。\u003c/p\u003e\n\u003cfigure class=\"highlight livescript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletableFuture\u0026lt;\u003cspan class=\"built_in\"\u003eString\u003c/span\u003e\u0026gt; f1 =\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  CompletableFuture.supplyAsync\u003cspan class=\"function\"\u003e\u003cspan class=\"params\"\u003e(()-\u0026gt;{\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    int t = getRandom(\u003cspan class=\"number\"\u003e5\u003c/span\u003e, \u003cspan class=\"number\"\u003e10\u003c/span\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    sleep(t, TimeUnit.SECONDS);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"built_in\"\u003eString\u003c/span\u003e.valueOf(t);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e})\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003eCompletableFuture\u003c/span\u003e\u0026lt;\u003cspan class=\"title\"\u003eString\u003c/span\u003e\u0026gt; \u003cspan class=\"title\"\u003ef2\u003c/span\u003e =\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e  \u003cspan class=\"title\"\u003eCompletableFuture\u003c/span\u003e.\u003cspan class=\"title\"\u003esupplyAsync\u003c/span\u003e\u003cspan class=\"params\"\u003e(()-\u0026gt;{\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    int t = getRandom(\u003cspan class=\"number\"\u003e5\u003c/span\u003e, \u003cspan class=\"number\"\u003e10\u003c/span\u003e);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    sleep(t, TimeUnit.SECONDS);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"built_in\"\u003eString\u003c/span\u003e.valueOf(t);\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e})\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003eCompletableFuture\u003c/span\u003e\u0026lt;\u003cspan class=\"title\"\u003eString\u003c/span\u003e\u0026gt; \u003cspan class=\"title\"\u003ef3\u003c/span\u003e =\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e  \u003cspan class=\"title\"\u003ef1\u003c/span\u003e.\u003cspan class=\"title\"\u003eapplyToEither\u003c/span\u003e\u003cspan class=\"params\"\u003e(f2,s -\u0026gt; s)\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"title\"\u003eout\u003c/span\u003e.\u003cspan class=\"title\"\u003eprintln\u003c/span\u003e\u003cspan class=\"params\"\u003e(f3.join())\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"异常处理\"\u003e\u003ca href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"\u003e\u003c/a\u003e异常处理\u003c/h3\u003e\u003cp\u003e虽然上面我们提到的 fn、consumer、action 它们的核心方法都\u003cstrong\u003e不允许抛出可检查异常，但是却无法限制它们抛出运行时异常\u003c/strong\u003e，例如下面的代码，执行 \u003ccode\u003e7/0\u003c/code\u003e 就会出现除零错误这个运行时异常。非异步编程里面，我们可以使用 try{}catch{} 来捕获并处理异常，那在异步编程里面，异常该如何处理呢？\u003c/p\u003e\n\u003cfigure class=\"highlight livescript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletableFuture\u0026lt;Integer\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  f0 = CompletableFuture.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    .supplyAsync\u003cspan class=\"function\"\u003e\u003cspan class=\"params\"\u003e(()-\u0026gt;(\u003cspan class=\"number\"\u003e7\u003c/span\u003e/\u003cspan class=\"number\"\u003e0\u003c/span\u003e))\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e    .\u003cspan class=\"title\"\u003ethenApply\u003c/span\u003e\u003cspan class=\"params\"\u003e(r-\u0026gt;r*\u003cspan class=\"number\"\u003e10\u003c/span\u003e)\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"title\"\u003eout\u003c/span\u003e.\u003cspan class=\"title\"\u003eprintln\u003c/span\u003e\u003cspan class=\"params\"\u003e(f0.join())\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eCompletionStage 接口给我们提供的方案非常简单，比 try{}catch{}还要简单，下面是相关的方法，使用这些方法进行异常处理和串行操作是一样的，都支持链式编程方式。\u003c/p\u003e\n\u003cfigure class=\"highlight scss\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletionStage \u003cspan class=\"built_in\"\u003eexceptionally\u003c/span\u003e(fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ewhenComplete\u003c/span\u003e(consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ewhenCompleteAsync\u003c/span\u003e(consumer);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ehandle\u003c/span\u003e(fn);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCompletionStage\u0026lt;R\u0026gt; \u003cspan class=\"built_in\"\u003ehandleAsync\u003c/span\u003e(fn);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e下面的示例代码展示了如何使用 exceptionally() 方法来处理异常，exceptionally() 的使用非常类似于 try{}catch{}中的 catch{}，但是由于支持链式编程方式，所以相对更简单。既然有 try{}catch{}，那就一定还有 try{}finally{}，whenComplete() 和 handle() 系列方法就类似于 try{}finally{}中的 finally{}，无论是否发生异常都会执行 whenComplete() 中的回调函数 consumer 和 handle() 中的回调函数 fn。whenComplete() 和 handle() 的区别在于 whenComplete() 不支持返回结果，而 handle() 是支持返回结果的。\u003c/p\u003e\n\u003cfigure class=\"highlight livescript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eCompletableFuture\u0026lt;Integer\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  f0 = CompletableFuture\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    .supplyAsync\u003cspan class=\"function\"\u003e\u003cspan class=\"params\"\u003e(()-\u0026gt;\u003cspan class=\"number\"\u003e7\u003c/span\u003e/\u003cspan class=\"number\"\u003e0\u003c/span\u003e)\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e    .\u003cspan class=\"title\"\u003ethenApply\u003c/span\u003e\u003cspan class=\"params\"\u003e(r-\u0026gt;r*\u003cspan class=\"number\"\u003e10\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e    .\u003cspan class=\"title\"\u003eexceptionally\u003c/span\u003e\u003cspan class=\"params\"\u003e(e-\u0026gt;\u003cspan class=\"number\"\u003e0\u003c/span\u003e)\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003eSystem\u003c/span\u003e.\u003cspan class=\"title\"\u003eout\u003c/span\u003e.\u003cspan class=\"title\"\u003eprintln\u003c/span\u003e\u003cspan class=\"params\"\u003e(f0.join())\u003c/span\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"Fork-Join\"\u003e\u003ca href=\"#Fork-Join\" class=\"headerlink\" title=\"Fork/Join\"\u003e\u003c/a\u003eFork/Join\u003c/h2\u003e\u003cp\u003eFork/Join 是一个并行计算的框架，主要就是用来支持分治任务模型的，这个计算框架里的\u003cstrong\u003eFork 对应的是分治任务模型里的任务分解，Join 对应的是结果合并\u003c/strong\u003e。Fork/Join 计算框架主要包含两部分，一部分是\u003cstrong\u003e分治任务的线程池 ForkJoinPool\u003c/strong\u003e，另一部分是\u003cstrong\u003e分治任务 ForkJoinTask\u003c/strong\u003e。这两部分的关系类似于 ThreadPoolExecutor 和 Runnable 的关系，都可以理解为提交任务到线程池，只不过分治任务有自己独特类型 ForkJoinTask。\u003c/p\u003e\n\u003cp\u003eForkJoinTask 是一个抽象类，它的方法有很多，最核心的是 fork() 方法和 join() 方法，其中 fork() 方法会异步地执行一个子任务，而 join() 方法则会阻塞当前线程来等待子任务的执行结果。ForkJoinTask 有两个子类——RecursiveAction 和 RecursiveTask，通过名字你就应该能知道，它们都是用递归的方式来处理分治任务的。这两个子类都定义了抽象方法 compute()，不过区别是 RecursiveAction 定义的 compute() 没有返回值，而 RecursiveTask 定义的 compute() 方法是有返回值的。这两个子类也是抽象类，在使用的时候，需要你定义子类去扩展。\u003c/p\u003e\n\u003ch3 id=\"ForkJoinPool-工作原理\"\u003e\u003ca href=\"#ForkJoinPool-工作原理\" class=\"headerlink\" title=\"ForkJoinPool 工作原理\"\u003e\u003c/a\u003eForkJoinPool 工作原理\u003c/h3\u003e\u003cp\u003eFork/Join 并行计算的核心组件是 ForkJoinPool，所以下面我们就来简单介绍一下 ForkJoinPool 的工作原理。\u003c/p\u003e\n\u003cp\u003e通过专栏前面文章的学习，你应该已经知道 ThreadPoolExecutor 本质上是一个生产者 - 消费者模式的实现，内部有一个任务队列，这个任务队列是生产者和消费者通信的媒介；ThreadPoolExecutor 可以有多个工作线程，但是这些工作线程都共享一个任务队列。\u003c/p\u003e\n\u003cp\u003eForkJoinPool 本质上也是一个生产者 - 消费者的实现，但是更加智能，你可以参考下面的 ForkJoinPool 工作原理图来理解其原理。ThreadPoolExecutor 内部只有一个任务队列，而 ForkJoinPool 内部有多个任务队列，当我们通过 ForkJoinPool 的 invoke() 或者 submit() 方法提交任务时，ForkJoinPool 根据一定的路由规则把任务提交到一个任务队列中，如果任务在执行过程中会创建出子任务，那么子任务会提交到工作线程对应的任务队列中。\u003c/p\u003e\n\u003cp\u003e如果工作线程对应的任务队列空了，是不是就没活儿干了呢？不是的，ForkJoinPool 支持一种叫做“\u003cstrong\u003e任务窃取\u003c/strong\u003e”的机制，如果工作线程空闲了，那它可以“窃取”其他工作任务队列里的任务，例如下图中，线程 T2 对应的任务队列已经空了，它可以“窃取”线程 T1 对应的任务队列的任务。如此一来，所有的工作线程都不会闲下来了。\u003c/p\u003e\n\u003cp\u003eForkJoinPool 中的任务队列采用的是双端队列，工作线程正常获取任务和“窃取任务”分别是从任务队列不同的端消费，这样能避免很多不必要的数据竞争。我们这里介绍的仅仅是简化后的原理，ForkJoinPool 的实现远比我们这里介绍的复杂，如果你感兴趣，建议去看它的源码。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200703141326.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/10484692/\"\u003e《Java 并发编程实战》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/26591326/\"\u003e《Java 并发编程的艺术》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100023901\"\u003e《Java 并发编程实战》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.jianshu.com/p/6bac52527ca4\"\u003eCompletableFuture 使用详解\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-07-14T07:27:46Z",
  "Author": "钝悟 ◾ Dunwu"
}