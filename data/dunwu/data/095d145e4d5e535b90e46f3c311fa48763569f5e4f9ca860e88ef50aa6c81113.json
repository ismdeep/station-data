{
  "Source": "dunwu",
  "Title": "JavaWeb 面经",
  "Link": "https://dunwu.github.io/blog/pages/e175ce/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"JavaWeb-面经\"\u003e\u003ca href=\"#JavaWeb-面经\" class=\"headerlink\" title=\"JavaWeb 面经\"\u003e\u003c/a\u003eJavaWeb 面经\u003c/h1\u003e\u003ch2 id=\"Servlet\"\u003e\u003ca href=\"#Servlet\" class=\"headerlink\" title=\"Servlet\"\u003e\u003c/a\u003eServlet\u003c/h2\u003e\u003ch3 id=\"什么是-Servlet\"\u003e\u003ca href=\"#什么是-Servlet\" class=\"headerlink\" title=\"什么是 Servlet\"\u003e\u003c/a\u003e什么是 Servlet\u003c/h3\u003e\u003cp\u003eServlet（Server Applet），即小服务程序或服务连接器。Servlet 是 Java 编写的服务器端程序，具有独立于平台和协议的特性，主要功能在于交互式地浏览和生成数据，生成动态 Web 内容。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e狭义的 Servlet 是指 Java 实现的一个接口。\u003c/li\u003e\n\u003cli\u003e广义的 Servlet 是指任何实现了这个 Servlet 接口的类。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eServlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。\u003c/p\u003e\n\u003ch3 id=\"Servlet-和-CGI-的区别\"\u003e\u003ca href=\"#Servlet-和-CGI-的区别\" class=\"headerlink\" title=\"Servlet 和 CGI 的区别\"\u003e\u003c/a\u003eServlet 和 CGI 的区别\u003c/h3\u003e\u003cp\u003eServlet 技术出现之前，Web 主要使用 CGI 技术。它们的区别如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eServlet 是基于 Java 编写的，处于服务器进程中，他能够通过多线程方式运行 service() 方法，一个实例可以服务于多个请求，而且一般不会销毁；\u003c/li\u003e\n\u003cli\u003eCGI(Common Gateway Interface)，即通用网关接口。它会为每个请求产生新的进程，服务完成后销毁，所以效率上低于 Servlet。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Servlet-版本以及主要特性\"\u003e\u003ca href=\"#Servlet-版本以及主要特性\" class=\"headerlink\" title=\"Servlet 版本以及主要特性\"\u003e\u003c/a\u003eServlet 版本以及主要特性\u003c/h3\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e版本\u003c/th\u003e\n\u003cth\u003e日期\u003c/th\u003e\n\u003cth\u003eJAVA EE/JDK 版本\u003c/th\u003e\n\u003cth\u003e特性\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eServlet 4.0\u003c/td\u003e\n\u003ctd\u003e2017 年 10 月\u003c/td\u003e\n\u003ctd\u003eJavaEE 8\u003c/td\u003e\n\u003ctd\u003eHTTP2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 3.1\u003c/td\u003e\n\u003ctd\u003e2013 年 5 月\u003c/td\u003e\n\u003ctd\u003eJavaEE 7\u003c/td\u003e\n\u003ctd\u003e非阻塞 I/O，HTTP 协议升级机制\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 3.0\u003c/td\u003e\n\u003ctd\u003e2009 年 12 月\u003c/td\u003e\n\u003ctd\u003eJavaEE 6, JavaSE 6\u003c/td\u003e\n\u003ctd\u003e可插拔性，易于开发，异步 Servlet，安全性，文件上传\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.5\u003c/td\u003e\n\u003ctd\u003e2005 年 10 月\u003c/td\u003e\n\u003ctd\u003eJavaEE 5, JavaSE 5\u003c/td\u003e\n\u003ctd\u003e依赖 JavaSE 5，支持注解\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.4\u003c/td\u003e\n\u003ctd\u003e2003 年 11 月\u003c/td\u003e\n\u003ctd\u003eJ2EE 1.4, J2SE 1.3\u003c/td\u003e\n\u003ctd\u003eweb.xml 使用 XML Schema\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.3\u003c/td\u003e\n\u003ctd\u003e2001 年 8 月\u003c/td\u003e\n\u003ctd\u003eJ2EE 1.3, J2SE 1.2\u003c/td\u003e\n\u003ctd\u003eFilter\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.2\u003c/td\u003e\n\u003ctd\u003e1999 年 8 月\u003c/td\u003e\n\u003ctd\u003eJ2EE 1.2, J2SE 1.2\u003c/td\u003e\n\u003ctd\u003e成为 J2EE 标准\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.1\u003c/td\u003e\n\u003ctd\u003e1998 年 11 月\u003c/td\u003e\n\u003ctd\u003e未指定\u003c/td\u003e\n\u003ctd\u003eFirst official specification, added RequestDispatcher, ServletContext\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 2.0\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003eJDK 1.1\u003c/td\u003e\n\u003ctd\u003ePart of Java Servlet Development Kit 2.0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eServlet 1.0\u003c/td\u003e\n\u003ctd\u003e1997 年 6 月\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3 id=\"Servlet-和-JSP-的区别\"\u003e\u003ca href=\"#Servlet-和-JSP-的区别\" class=\"headerlink\" title=\"Servlet 和 JSP 的区别\"\u003e\u003c/a\u003eServlet 和 JSP 的区别\u003c/h3\u003e\u003col\u003e\n\u003cli\u003eServlet 是一个运行在服务器上的 Java 类,依靠服务器支持向浏览器传输数据。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eJSP 本质上就是 Servlet\u003c/strong\u003e，每次运行的时候 JSP 都会被编译成 .java 文件，然后再被编译成 .class 文件。\u003c/li\u003e\n\u003cli\u003e有了 JSP，Servlet 不再负责动态生成页面，转而去负责控制程序逻辑的作用，控制 JSP 与 JavaBean 之间的流转。\u003c/li\u003e\n\u003cli\u003eJSP 侧重于视图,而 Servlet 侧重于控制逻辑,在 MVC 架构模式中,JSP 适合充当视图 View,Servlet 适合充当控制器 Controller。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"简述-Servlet-生命周期\"\u003e\u003ca href=\"#简述-Servlet-生命周期\" class=\"headerlink\" title=\"简述 Servlet 生命周期\"\u003e\u003c/a\u003e简述 Servlet 生命周期\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"http://www.runoob.com/wp-content/uploads/2014/07/Servlet-LifeCycle.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003eServlet 生命周期如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e加载\u003c/strong\u003e - 第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。容器通过类加载器使用 Servlet 类对应的文件加载 servlet；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化\u003c/strong\u003e - Servlet 通过调用 \u003cstrong\u003einit ()\u003c/strong\u003e 方法进行初始化。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e服务\u003c/strong\u003e - Servlet 调用 \u003cstrong\u003eservice()\u003c/strong\u003e 方法来处理客户端的请求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e销毁\u003c/strong\u003e - Servlet 通过调用 \u003cstrong\u003edestroy()\u003c/strong\u003e 方法终止（结束）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e卸载\u003c/strong\u003e - Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"如何现实-servlet-的单线程模式\"\u003e\u003ca href=\"#如何现实-servlet-的单线程模式\" class=\"headerlink\" title=\"如何现实 servlet 的单线程模式\"\u003e\u003c/a\u003e如何现实 servlet 的单线程模式\u003c/h3\u003e\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u0026lt;%@ page isThreadSafe=\u003cspan class=\"string\"\u003e\u0026#34;false\u0026#34;\u003c/span\u003e %\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"Servlet-中如何获取用户提交的查询参数或者表单数据\"\u003e\u003ca href=\"#Servlet-中如何获取用户提交的查询参数或者表单数据\" class=\"headerlink\" title=\"Servlet 中如何获取用户提交的查询参数或者表单数据\"\u003e\u003c/a\u003eServlet 中如何获取用户提交的查询参数或者表单数据\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003eHttpServletRequest 的 getParameter() 方法。\u003c/li\u003e\n\u003cli\u003eHttpServletRequest 的 getParameterValues() 方法。\u003c/li\u003e\n\u003cli\u003eHttpServletRequest 的 getParameterMap() 方法。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"request-的主要方法\"\u003e\u003ca href=\"#request-的主要方法\" class=\"headerlink\" title=\"request 的主要方法\"\u003e\u003c/a\u003erequest 的主要方法\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003esetAttribute(String name,Object)：设置名字为 name 的 request 的参数值\u003c/li\u003e\n\u003cli\u003egetAttribute(String name)：返回由 name 指定的属性值\u003c/li\u003e\n\u003cli\u003egetAttributeNames()：返回 request 对象所有属性的名字集合，结果是一个枚举的实例\u003c/li\u003e\n\u003cli\u003egetCookies()：返回客户端的所有 Cookie 对象，结果是一个 Cookie 数组\u003c/li\u003e\n\u003cli\u003egetCharacterEncoding()：返回请求中的字符编码方式\u003c/li\u003e\n\u003cli\u003egetContentLength()：返回请求的 Body 的长度\u003c/li\u003e\n\u003cli\u003egetHeader(String name)：获得 HTTP 协议定义的文件头信息\u003c/li\u003e\n\u003cli\u003egetHeaders(String name)：返回指定名字的 request Header 的所有值，结果是一个枚举的实例\u003c/li\u003e\n\u003cli\u003egetHeaderNames()：返回所以 request Header 的名字，结果是一个枚举的实例\u003c/li\u003e\n\u003cli\u003egetInputStream()：返回请求的输入流，用于获得请求中的数据 getMethod()：获得客户端向服务器端传送数据的方法\u003c/li\u003e\n\u003cli\u003egetParameter(String name)：获得客户端传送给服务器端的有 name 指定的参数值\u003c/li\u003e\n\u003cli\u003egetParameterNames()：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例\u003c/li\u003e\n\u003cli\u003egetParameterValues(String name)：获得有 name 指定的参数的所有值\u003c/li\u003e\n\u003cli\u003egetProtocol()：获取客户端向服务器端传送数据所依据的协议名称\u003c/li\u003e\n\u003cli\u003egetQueryString()：获得查询字符串\u003c/li\u003e\n\u003cli\u003egetRequestURI()：获取发出请求字符串的客户端地址\u003c/li\u003e\n\u003cli\u003egetRemoteAddr()：获取客户端的 IP 地址\u003c/li\u003e\n\u003cli\u003egetRemoteHost()：获取客户端的名字\u003c/li\u003e\n\u003cli\u003egetSession([Boolean create])：返回和请求相关\u003c/li\u003e\n\u003cli\u003eSession getServerName()：获取服务器的名字\u003c/li\u003e\n\u003cli\u003egetServletPath()：获取客户端所请求的脚本文件的路径\u003c/li\u003e\n\u003cli\u003egetServerPort()：获取服务器的端口号\u003c/li\u003e\n\u003cli\u003eremoveAttribute(String name)：删除请求中的一个属性\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"JSP\"\u003e\u003ca href=\"#JSP\" class=\"headerlink\" title=\"JSP\"\u003e\u003c/a\u003eJSP\u003c/h2\u003e\u003ch3 id=\"JSP-的内置对象\"\u003e\u003ca href=\"#JSP-的内置对象\" class=\"headerlink\" title=\"JSP 的内置对象\"\u003e\u003c/a\u003eJSP 的内置对象\u003c/h3\u003e\u003col\u003e\n\u003cli\u003e\u003cstrong\u003erequest\u003c/strong\u003e：包含\u003cstrong\u003e客户端请求的信息\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eresponse\u003c/strong\u003e：包含\u003cstrong\u003e服务器传回客户端的响应信息\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esession\u003c/strong\u003e：主要用来\u003cstrong\u003e区分每个用户信息和会话状态\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epageContext\u003c/strong\u003e：管理\u003cstrong\u003e页面属性\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eapplication\u003c/strong\u003e：服务器启动时创建，服务器关闭时停止，\u003cstrong\u003e保存所有应用系统中的共有数据\u003c/strong\u003e，一个共享的内置对象（即一个容器中的多个用户共享一个 application 对象）；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eout\u003c/strong\u003e：向客户端\u003cstrong\u003e输出数据\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003econfig\u003c/strong\u003e：代码片段配置对象，用于\u003cstrong\u003e初始化 Servlet 的配置参数\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003epage\u003c/strong\u003e：指\u003cstrong\u003e网页本身\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eexception\u003c/strong\u003e：处理 JSP 文件执行时发生的错误和异常，只要在\u003cstrong\u003e错误页面\u003c/strong\u003e里才能使用。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"JSP-的作用域\"\u003e\u003ca href=\"#JSP-的作用域\" class=\"headerlink\" title=\"JSP 的作用域\"\u003e\u003c/a\u003eJSP 的作用域\u003c/h3\u003e\u003col\u003e\n\u003cli\u003e\u003cstrong\u003epage\u003c/strong\u003e：一个页面；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003erequest\u003c/strong\u003e：一次请求；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003esession\u003c/strong\u003e：一次会话；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eapplication\u003c/strong\u003e：服务器从启动到停止。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"JSP-中-7-个动作指令和作用\"\u003e\u003ca href=\"#JSP-中-7-个动作指令和作用\" class=\"headerlink\" title=\"JSP 中 7 个动作指令和作用\"\u003e\u003c/a\u003eJSP 中 7 个动作指令和作用\u003c/h3\u003e\u003col\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:forward\u003c/strong\u003e - 执行页面转向，把请求转发到下一个页面；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:param\u003c/strong\u003e - 用于传递参数，必须与其他支持参数的标签一起使用；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:include\u003c/strong\u003e - 用于\u003cstrong\u003e动态引入一个 JSP 页面\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:plugin\u003c/strong\u003e - 用于\u003cstrong\u003e下载 JavaBean 或 Applet 到客户端执行\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:useBean\u003c/strong\u003e - 寻求或者实例化一个 JavaBean；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:setProperty\u003c/strong\u003e - 设置 JavaBean 的属性值；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ejsp:getProperty\u003c/strong\u003e - 获取 JavaBean 的属性值。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"JSP-中动态-INCLUDE-和静态-INCLUDE-有什么区别\"\u003e\u003ca href=\"#JSP-中动态-INCLUDE-和静态-INCLUDE-有什么区别\" class=\"headerlink\" title=\"JSP 中动态 INCLUDE 和静态 INCLUDE 有什么区别\"\u003e\u003c/a\u003eJSP 中动态 INCLUDE 和静态 INCLUDE 有什么区别\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e静态 INCLUDE\u003c/strong\u003e：用 include 伪码实现，\u003cstrong\u003e不会检查所含文件的变化\u003c/strong\u003e，适用于包含\u003cstrong\u003e静态页面\u0026lt;%@ include file=”页面名称.html” %\u0026gt;\u003cstrong\u003e。\u003c/strong\u003e先合并再编译\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e动态 INCLUDE\u003c/strong\u003e：用 jsp:include 动作实现 \u003cstrong\u003e\u0026lt;jsp:include page=”页面名称 .jsp” flush=”true”\u0026gt;\u003c/strong\u003e 它总是\u003cstrong\u003e会检查文件中的变化\u003c/strong\u003e，适用于包含\u003cstrong\u003e动态页面\u003c/strong\u003e，并且可以\u003cstrong\u003e带参数\u003c/strong\u003e。\u003cstrong\u003e先编译再合并\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"原理\"\u003e\u003ca href=\"#原理\" class=\"headerlink\" title=\"原理\"\u003e\u003c/a\u003e原理\u003c/h2\u003e\u003ch3 id=\"请求转发-forward-和重定向-redirect-的区别\"\u003e\u003ca href=\"#请求转发-forward-和重定向-redirect-的区别\" class=\"headerlink\" title=\"请求转发(forward)和重定向(redirect)的区别\"\u003e\u003c/a\u003e请求转发(forward)和重定向(redirect)的区别\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e效率上\u003cul\u003e\n\u003cli\u003e转发（forward） \u0026gt; 重定向（redirect）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e显示上\u003cul\u003e\n\u003cli\u003e重定向（redirect）：显示新的 URL\u003c/li\u003e\n\u003cli\u003e转发（forward）：地址栏不变\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e数据上\u003cul\u003e\n\u003cli\u003e转发（forward）：可以共享 request 里面的数据\u003c/li\u003e\n\u003cli\u003e重定向（redirect）：不能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e请求次数\u003cul\u003e\n\u003cli\u003e重定向（redirect）是两次\u003c/li\u003e\n\u003cli\u003e转发（forward）是一次\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"get-请求和-post-请求的区别\"\u003e\u003ca href=\"#get-请求和-post-请求的区别\" class=\"headerlink\" title=\"get 请求和 post 请求的区别\"\u003e\u003c/a\u003eget 请求和 post 请求的区别\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://upload-images.jianshu.io/upload_images/7779232-5be5ae990207f9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/814/format/webp\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGET：\u003cul\u003e\n\u003cli\u003e从服务器上获取数据，一般不能使用在写操作接口\u003c/li\u003e\n\u003cli\u003e由 URL 所限制，GET 方式传输的数据大小有所限制，传送的数据量不超过 2KB\u003c/li\u003e\n\u003cli\u003e请求的数据会附加在 URL 之后，以？分隔 URL 和传输数据，多个参数用\u0026amp;连接\u003c/li\u003e\n\u003cli\u003e安全性差\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePOST:\u003cul\u003e\n\u003cli\u003e向服务器提交数据,一般处理写业务\u003c/li\u003e\n\u003cli\u003ePOST 方式传送的数据量比较大，一般被默认为没有限制\u003c/li\u003e\n\u003cli\u003e安全性高\u003c/li\u003e\n\u003cli\u003e请的求的数据内容放置在 HTML HEADER 中\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"用户在浏览器中输入-URL-之后，发什么了什么？写出请求和响应的流程\"\u003e\u003ca href=\"#用户在浏览器中输入-URL-之后，发什么了什么？写出请求和响应的流程\" class=\"headerlink\" title=\"用户在浏览器中输入 URL 之后，发什么了什么？写出请求和响应的流程\"\u003e\u003c/a\u003e用户在浏览器中输入 URL 之后，发什么了什么？写出请求和响应的流程\u003c/h3\u003e\u003col\u003e\n\u003cli\u003e域名解析\u003c/li\u003e\n\u003cli\u003eTCP 三次握手\u003c/li\u003e\n\u003cli\u003e浏览器向服务器发送 http 请求\u003c/li\u003e\n\u003cli\u003e浏览器发送请求头信息\u003c/li\u003e\n\u003cli\u003e服务器处理请求\u003c/li\u003e\n\u003cli\u003e服务器做出应答\u003c/li\u003e\n\u003cli\u003e服务器发送应答头信息\u003c/li\u003e\n\u003cli\u003e服务器发送数据\u003c/li\u003e\n\u003cli\u003eTCP 连接关闭\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"什么是-Web-Service\"\u003e\u003ca href=\"#什么是-Web-Service\" class=\"headerlink\" title=\"什么是 Web Service?\"\u003e\u003c/a\u003e什么是 Web Service?\u003c/h3\u003e\u003col\u003e\n\u003cli\u003eWebService 就是一个应用程序，它向外界暴露出一个能够通过 Web 进行调用的 API。\u003c/li\u003e\n\u003cli\u003e它是基于 HTTP 协议传输数据，这使得运行在不同机上的不同应用程序，无须借助附加的、专门的第三方 软件或硬件，就可以相互交换数据或集成。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"会话跟踪技术有哪些\"\u003e\u003ca href=\"#会话跟踪技术有哪些\" class=\"headerlink\" title=\"会话跟踪技术有哪些?\"\u003e\u003c/a\u003e会话跟踪技术有哪些?\u003c/h3\u003e\u003cp\u003e由于 HTTP 协议本身是无状态的，服务器为了区分不同的用户，就需要对用户会话进行跟踪，简单的说就是为用户进行登记，为用户分配唯一的 ID，下一次用户在请求中包含此 ID，服务器根据此判断到底是哪一个用户。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eURL 重写：在 URL 中添加会话信息作为请求的参数，或者将唯一的会话 ID 添加到 URL 结尾，以表示一个会话。设置表单隐藏域：将和会话跟踪相关的字段添加到隐藏域中，这些信息不会在浏览器显示，但是提交表单时会提交给服务器。\u003c/li\u003e\n\u003cli\u003ecookie：cookie 有两种：\u003cul\u003e\n\u003cli\u003e一种是基于窗口的，浏览器关闭后，cookie 就没有了；\u003c/li\u003e\n\u003cli\u003e另一种是将信息存储在一个临时文件中，并设置其有效路径和最大存活时间。当用户通过浏览器和服务器建立一次会话后，会话 ID 就会随相应信息储存在基于窗口的 cookie 中，那就意味着只要浏览器没有关闭，会话没有超时，下一次请求时这个会话 ID 又会提交给服务器，让服务器识别用户身份。\u003c/li\u003e\n\u003cli\u003e在使用 cookie 时要注意几点：\u003cul\u003e\n\u003cli\u003e首先不要在 cookie 中存放敏 感信息；\u003c/li\u003e\n\u003cli\u003e其次 cookie 存储的数据量有限（4k），不能将过多的内容存储 cookie 中；\u003c/li\u003e\n\u003cli\u003e再者浏览器通常只允许一个站点最多存放 20 个 cookie。\u003c/li\u003e\n\u003cli\u003e当然，和用户会话相关的其他信息（除了会话 ID）也可以存在 cookie 方便进行会话 跟踪;\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHttpSession：在所有会话跟踪技术中，HttpSession 对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的 HttpSession。可以通过 HttpServletRequest 对象的 getSession 方法获得 HttpSession，通过 HttpSession 的 setAttribute 方法可以将一个值放在 HttpSession 中，通过调用 HttpSession 对象的 getAttribute 方法，同时传入属性名就可以获取保存在 HttpSession 中的对象。\u003cul\u003e\n\u003cli\u003e与上面三种方式不同的是，HttpSession 放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的 Servlet 容器可以在内存将满时将 HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。\u003c/li\u003e\n\u003cli\u003e添加到 HttpSession 中 的值可以是任意 Java 对象，这个对象最好实现了 Serializable 接口，这样 Servlet 容器在必要的时候可以将其序列 化到文件中，否则在序列化时就会出现异常。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"响应结果状态码有哪些，并给出中文含义？\"\u003e\u003ca href=\"#响应结果状态码有哪些，并给出中文含义？\" class=\"headerlink\" title=\"响应结果状态码有哪些，并给出中文含义？\"\u003e\u003c/a\u003e响应结果状态码有哪些，并给出中文含义？\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e1**\u003c/code\u003e：信息性状态码\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e2**\u003c/code\u003e：成功状态码\u003cul\u003e\n\u003cli\u003e200：请求正常成功\u003c/li\u003e\n\u003cli\u003e204：指示请求成功但没有返回新信息\u003c/li\u003e\n\u003cli\u003e206：指示服务器已完成对资源的部分 GET 请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e3**\u003c/code\u003e：重定向状态码\u003cul\u003e\n\u003cli\u003e301：永久性重定向\u003c/li\u003e\n\u003cli\u003e302：临时性重定向\u003c/li\u003e\n\u003cli\u003e304：服务器端允许请求访问资源，但未满足条件\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e4**\u003c/code\u003e：客户端错误状态码\u003cul\u003e\n\u003cli\u003e400：请求报文中存在语法错误\u003c/li\u003e\n\u003cli\u003e401：发送的请求需要有通过 HTTP 认证的认证信息\u003c/li\u003e\n\u003cli\u003e403：对请求资源的访问被服务器拒绝了\u003c/li\u003e\n\u003cli\u003e404：服务器上无法找到请求的资源\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e5**\u003c/code\u003e：服务器错误状态码\u003cul\u003e\n\u003cli\u003e500：服务器端在执行请求时发生了错误\u003c/li\u003e\n\u003cli\u003e503：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"XML-文档定义有几种形式？它们之间有何本质区别？解析-XML-文档有哪几种方式？\"\u003e\u003ca href=\"#XML-文档定义有几种形式？它们之间有何本质区别？解析-XML-文档有哪几种方式？\" class=\"headerlink\" title=\"XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？\"\u003e\u003c/a\u003eXML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？\u003c/h3\u003e\u003cp\u003e（1）XML 文档有两种约束方式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDTD 约束\u003c/li\u003e\n\u003cli\u003eSchema 约束\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e（2）XML 文档区别：\u003cbr/\u003e1 DTD 不符合 XML 的语法结构，schema 符合 XML 的语法结构；\u003cbr/\u003e2 DTD 的约束扩展性比较差，XML 文档只能引入一个 DTD 的文件。schema 可以引入多个文件；\u003cbr/\u003e3 DTD 不支持名称空间（理解包结构），schema 支持名称空间；\u003cbr/\u003e4 DTD 支持数据比较少，schema 支持更多的数据类型；\u003c/p\u003e\n\u003cp\u003e（3）解析方式主要有三种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDOM 解析：\u003cul\u003e\n\u003cli\u003e（a）加载整个 xml 的文档到内存中，形成树状结构，生成对象；\u003c/li\u003e\n\u003cli\u003e（b）容易产生内存溢出；\u003c/li\u003e\n\u003cli\u003e（c）可以做增删改\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eSAX 解析\u003cul\u003e\n\u003cli\u003e（a）边读边解析；\u003c/li\u003e\n\u003cli\u003e（b）不可以做增删改\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eDOM4J 解析（hibernate 底层采用)\u003cul\u003e\n\u003cli\u003e（a）可让 SAX 解析也产生树状结构。\u003c/li\u003e\n\u003cli\u003e（b）主要 api 开发步骤：\u003cul\u003e\n\u003cli\u003e1）SAXReader.read(xxx.xml)代表解析 xml 的文档，返回对象是 Document；\u003c/li\u003e\n\u003cli\u003e2）Document.getRootElement(),返回的是文档的根节点，是 Element 对象；\u003c/li\u003e\n\u003cli\u003e3）Element:\u003cul\u003e\n\u003cli\u003e.element(…)– 获得指定名称第一个子元素。可以不指定名称;\u003c/li\u003e\n\u003cli\u003e.elements(…)– 获得指定名称的所有子元素。可以不指定名称;\u003c/li\u003e\n\u003cli\u003e.getText()– 获得当前元素的文本内容；\u003c/li\u003e\n\u003cli\u003e.elementText(…)– 获得指定名称子元素的文本值\u003c/li\u003e\n\u003cli\u003e.addElement()– 添加子节点\u003c/li\u003e\n\u003cli\u003e.setText()– 设置子标签内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e4）XMLWriter.write(“..”)– 写出\u003c/li\u003e\n\u003cli\u003e5）XMLWriter.close()– 关闭输出流\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/YM_IlY/article/details/81266959\"\u003ehttps://blog.csdn.net/YM_IlY/article/details/81266959\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.jianshu.com/p/f073dde56262\"\u003ehttps://www.jianshu.com/p/f073dde56262\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-02-07T15:04:47Z",
  "Author": "钝悟 ◾ Dunwu"
}