{
  "Source": "dunwu",
  "Title": "HBase 数据模型",
  "Link": "https://dunwu.github.io/blog/pages/c8cfeb/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"HBase-数据模型\"\u003e\u003ca href=\"#HBase-数据模型\" class=\"headerlink\" title=\"HBase 数据模型\"\u003e\u003c/a\u003eHBase 数据模型\u003c/h1\u003e\u003cp\u003eHBase 是一个面向 \u003ccode\u003e列\u003c/code\u003e 的数据库管理系统，这里更为确切的而说，HBase 是一个面向 \u003ccode\u003e列族\u003c/code\u003e 的数据库管理系统。表 schema 仅定义列族，表具有多个列族，每个列族可以包含任意数量的列，列由多个单元格（cell）组成，单元格可以存储多个版本的数据，多个版本数据以时间戳进行区分。\u003c/p\u003e\n\u003ch2 id=\"HBase-逻辑存储结构\"\u003e\u003ca href=\"#HBase-逻辑存储结构\" class=\"headerlink\" title=\"HBase 逻辑存储结构\"\u003e\u003c/a\u003eHBase 逻辑存储结构\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e**\u003ccode\u003eTable\u003c/code\u003e**：Table 由 Row 和 Column 组成。\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eRow\u003c/code\u003e**：Row 是列族（Column Family）的集合。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eRow Key\u003c/code\u003e\u003cstrong\u003e：\u003c/strong\u003e\u003ccode\u003eRow Key\u003c/code\u003e 是用来检索记录的主键\u003c/strong\u003e。\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eRow Key\u003c/code\u003e 是未解释的字节数组，所以理论上，任何数据都可以通过序列化表示成字符串或二进制，从而存为 HBase 的键值。\u003c/li\u003e\n\u003cli\u003e表中的行，是按照 \u003ccode\u003eRow Key\u003c/code\u003e 的字典序进行排序。这里需要注意以下两点：\u003cul\u003e\n\u003cli\u003e因为字典序对 Int 排序的结果是 1,10,100,11,12,13,14,15,16,17,18,19,2,20,21,…,9,91,92,93,94,95,96,97,98,99。如果你使用整型的字符串作为行键，那么为了保持整型的自然序，行键必须用 0 作左填充。\u003c/li\u003e\n\u003cli\u003e行的一次读写操作是原子性的 (不论一次读写多少列)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e所有对表的访问都要通过 Row Key，有以下三种方式：\u003cul\u003e\n\u003cli\u003e通过指定的 \u003ccode\u003eRow Key\u003c/code\u003e 进行访问；\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eRow Key\u003c/code\u003e 的 range 进行访问，即访问指定范围内的行；\u003c/li\u003e\n\u003cli\u003e进行全表扫描。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eColumn Family\u003c/code\u003e**：即列族。HBase 表中的每个列，都归属于某个列族。列族是表的 Schema 的一部分，所以列族需要在创建表时进行定义。\u003cul\u003e\n\u003cli\u003e一个表的列族必须作为表模式定义的一部分预先给出，但是新的列族成员可以随后按需加入。\u003c/li\u003e\n\u003cli\u003e同一个列族的所有成员具有相同的前缀，例如 \u003ccode\u003einfo:format\u003c/code\u003e，\u003ccode\u003einfo:geo\u003c/code\u003e 都属于 \u003ccode\u003einfo\u003c/code\u003e 这个列族。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eColumn Qualifier\u003c/code\u003e**：列限定符。可以理解为是具体的列名，例如 \u003ccode\u003einfo:format\u003c/code\u003e，\u003ccode\u003einfo:geo\u003c/code\u003e 都属于 \u003ccode\u003einfo\u003c/code\u003e 这个列族，它们的列限定符分别是 \u003ccode\u003eformat\u003c/code\u003e 和 \u003ccode\u003egeo\u003c/code\u003e。列族和列限定符之间始终以冒号分隔。需要注意的是列限定符不是表 Schema 的一部分，你可以在插入数据的过程中动态创建列。\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eColumn\u003c/code\u003e**：HBase 中的列由列族和列限定符组成，由 \u003ccode\u003e:\u003c/code\u003e(冒号) 进行分隔，即一个完整的列名应该表述为 \u003ccode\u003e列族名 ：列限定符\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ch2 id=\"Cell-：Cell-是行，列族和列限定符的组合，并包含值和时间戳。HBase-中通过-row-key-和-column-确定的为一个存储单元称为-Cell，你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是-HBase-中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。-Cell-由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为-HBase-插入-Cell-时的时间戳。Cell-的内容是未解释的字节数组。\"\u003e\u003ca href=\"#Cell-：Cell-是行，列族和列限定符的组合，并包含值和时间戳。HBase-中通过-row-key-和-column-确定的为一个存储单元称为-Cell，你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是-HBase-中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。-Cell-由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为-HBase-插入-Cell-时的时间戳。Cell-的内容是未解释的字节数组。\" class=\"headerlink\" title=\"**Cell**：Cell 是行，列族和列限定符的组合，并包含值和时间戳。HBase 中通过 row key 和 column 确定的为一个存储单元称为 Cell，你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是 HBase 中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。- Cell 由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为 HBase 插入 Cell 时的时间戳。Cell 的内容是未解释的字节数组。\"\u003e\u003c/a\u003e**\u003ccode\u003eCell\u003c/code\u003e**：\u003ccode\u003eCell\u003c/code\u003e 是行，列族和列限定符的组合，并包含值和时间戳。HBase 中通过 \u003ccode\u003erow key\u003c/code\u003e 和 \u003ccode\u003ecolumn\u003c/code\u003e 确定的为一个存储单元称为 \u003ccode\u003eCell\u003c/code\u003e，你可以等价理解为关系型数据库中由指定行和指定列确定的一个单元格，但不同的是 HBase 中的一个单元格是由多个版本的数据组成的，每个版本的数据用时间戳进行区分。\u003cbr/\u003e- \u003ccode\u003eCell\u003c/code\u003e 由行和列的坐标交叉决定，是有版本的。默认情况下，版本号是自动分配的，为 HBase 插入 \u003ccode\u003eCell\u003c/code\u003e 时的时间戳。\u003ccode\u003eCell\u003c/code\u003e 的内容是未解释的字节数组。\u003c/h2\u003e\u003c/li\u003e\n\u003cli\u003e**\u003ccode\u003eTimestamp\u003c/code\u003e**：\u003ccode\u003eCell\u003c/code\u003e 的版本通过时间戳来索引，时间戳的类型是 64 位整型，时间戳可以由 HBase 在数据写入时自动赋值，也可以由客户显式指定。每个 \u003ccode\u003eCell\u003c/code\u003e 中，不同版本的数据按照时间戳倒序排列，即最新的数据排在最前面。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/bigdata/hbase/1551164224778.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"HBase-物理存储结构\"\u003e\u003ca href=\"#HBase-物理存储结构\" class=\"headerlink\" title=\"HBase 物理存储结构\"\u003e\u003c/a\u003eHBase 物理存储结构\u003c/h2\u003e\u003cp\u003eHBase 自动将表水平划分成区域（Region）。每个 Region 由表中 Row 的子集构成。每个 Region 由它所属的表的起始范围来表示（包含的第一行和最后一行）。初始时，一个表只有一个 Region，随着 Region 膨胀，当超过一定阈值时，会在某行的边界上分裂成两个大小基本相同的新 Region。在第一次划分之前，所有加载的数据都放在原始 Region 所在的那台服务器上。随着表变大，Region 个数也会逐渐增加。Region 是在 HBase 集群上分布数据的最小单位。\u003c/p\u003e\n\u003ch2 id=\"HBase-数据模型示例\"\u003e\u003ca href=\"#HBase-数据模型示例\" class=\"headerlink\" title=\"HBase 数据模型示例\"\u003e\u003c/a\u003eHBase 数据模型示例\u003c/h2\u003e\u003cp\u003e下图为 HBase 中一张表的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRowKey 为行的唯一标识，所有行按照 RowKey 的字典序进行排序；\u003c/li\u003e\n\u003cli\u003e该表具有两个列族，分别是 personal 和 office;\u003c/li\u003e\n\u003cli\u003e其中列族 personal 拥有 name、city、phone 三个列，列族 office 拥有 tel、addres 两个列。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200601172926.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003e图片引用自 : HBase 是列式存储数据库吗\u003c/em\u003e \u003cem\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.iteblog.com/archives/2498.html\"\u003ehttps://www.iteblog.com/archives/2498.html\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"HBase-表特性\"\u003e\u003ca href=\"#HBase-表特性\" class=\"headerlink\" title=\"HBase 表特性\"\u003e\u003c/a\u003eHBase 表特性\u003c/h2\u003e\u003cp\u003eHbase 的表具有以下特点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e容量大\u003c/strong\u003e：一个表可以有数十亿行，上百万列；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e面向列\u003c/strong\u003e：数据是按照列存储，每一列都单独存放，数据即索引，在查询时可以只访问指定列的数据，有效地降低了系统的 I/O 负担；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e稀疏性\u003c/strong\u003e：空 (null) 列并不占用存储空间，表可以设计的非常稀疏 ；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据多版本\u003c/strong\u003e：每个单元中的数据可以有多个版本，按照时间戳排序，新的数据在最上面；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e存储类型\u003c/strong\u003e：所有数据的底层存储格式都是字节数组 (byte[])。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e官方\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://hbase.apache.org/\"\u003eHBase 官网\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://hbase.apache.org/book.html\"\u003eHBase 官方文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://abloz.com/hbase/book.html\"\u003eHBase 官方文档中文版\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e书籍\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/27600204/\"\u003eHadoop 权威指南\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文章\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf\"\u003eBigtable: A Distributed Storage System for Structured Data\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://mapr.com/blog/in-depth-look-hbase-architecture\"\u003eAn In-Depth Look at the HBase Architecture\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e教程\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/heibaiying/BigData-Notes\"\u003ehttps://github.com/heibaiying/BigData-Notes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cloudduggu.com/hbase/introduction/\"\u003ehttps://www.cloudduggu.com/hbase/introduction/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-03-16T07:58:10Z",
  "Author": "钝悟 ◾ Dunwu"
}