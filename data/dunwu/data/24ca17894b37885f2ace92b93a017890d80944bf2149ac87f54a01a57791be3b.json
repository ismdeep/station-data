{
  "Source": "dunwu",
  "Title": "《高并发系统设计 40 问》笔记",
  "Link": "https://dunwu.github.io/blog/pages/daf740/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"《高并发系统设计-40-问》笔记\"\u003e\u003ca href=\"#《高并发系统设计-40-问》笔记\" class=\"headerlink\" title=\"《高并发系统设计 40 问》笔记\"\u003e\u003c/a\u003e《高并发系统设计 40 问》笔记\u003c/h1\u003e\u003ch2 id=\"基础篇\"\u003e\u003ca href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"\u003e\u003c/a\u003e基础篇\u003c/h2\u003e\u003ch3 id=\"高并发系统：它的通用设计方法是什么？\"\u003e\u003ca href=\"#高并发系统：它的通用设计方法是什么？\" class=\"headerlink\" title=\"高并发系统：它的通用设计方法是什么？\"\u003e\u003c/a\u003e高并发系统：它的通用设计方法是什么？\u003c/h3\u003e\u003cp\u003e并发、异步、缓存\u003c/p\u003e\n\u003ch3 id=\"架构分层：我们为什么一定要这么做？\"\u003e\u003ca href=\"#架构分层：我们为什么一定要这么做？\" class=\"headerlink\" title=\"架构分层：我们为什么一定要这么做？\"\u003e\u003c/a\u003e架构分层：我们为什么一定要这么做？\u003c/h3\u003e\u003cp\u003e分层架构典型代表：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMVC（Model-View-Controller）\u003c/li\u003e\n\u003cli\u003e表现层、逻辑层和数据访问层\u003c/li\u003e\n\u003cli\u003eOSI 七层网络模型\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e分层的好处\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e分层的设计可以简化系统设计，让不同的人专注做某一层次的事情。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e再有，分层之后可以做到很高的复用。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e分层架构可以让我们更容易做横向扩展。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e分层架构的不足\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e增加了代码的复杂度\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"系统设计目标（一）：如何提升系统性能？\"\u003e\u003ca href=\"#系统设计目标（一）：如何提升系统性能？\" class=\"headerlink\" title=\"系统设计目标（一）：如何提升系统性能？\"\u003e\u003c/a\u003e系统设计目标（一）：如何提升系统性能？\u003c/h3\u003e\u003cp\u003e讲述了性能指标和性能量化方式。\u003c/p\u003e\n\u003ch3 id=\"系统设计目标（二）：系统怎样做到高可用？\"\u003e\u003ca href=\"#系统设计目标（二）：系统怎样做到高可用？\" class=\"headerlink\" title=\"系统设计目标（二）：系统怎样做到高可用？\"\u003e\u003c/a\u003e系统设计目标（二）：系统怎样做到高可用？\u003c/h3\u003e\u003cp\u003e故障转移\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e健康检查：心跳检测\u003c/li\u003e\n\u003cli\u003e选举：Paxos、Raft\u003c/li\u003e\n\u003cli\u003e负载均衡\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e流量控制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e超时与重试\u003c/li\u003e\n\u003cli\u003e限流\u003c/li\u003e\n\u003cli\u003e降级\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e系统运维\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e灰度发布\u003c/li\u003e\n\u003cli\u003e故障演练\u003c/li\u003e\n\u003cli\u003eCI/CD\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e多活架构\u003c/p\u003e\n\u003ch3 id=\"系统设计目标（三）：如何让系统易于扩展？\"\u003e\u003ca href=\"#系统设计目标（三）：如何让系统易于扩展？\" class=\"headerlink\" title=\"系统设计目标（三）：如何让系统易于扩展？\"\u003e\u003c/a\u003e系统设计目标（三）：如何让系统易于扩展？\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e拆分首先考虑的维度是业务维度\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e其次，当吞吐量达到单机瓶颈，针对存储做水平差费\u003c/p\u003e\n\u003ch2 id=\"数据库篇\"\u003e\u003ca href=\"#数据库篇\" class=\"headerlink\" title=\"数据库篇\"\u003e\u003c/a\u003e数据库篇\u003c/h2\u003e\u003ch4 id=\"池化技术：如何减少频繁创建数据库连接的性能损耗？\"\u003e\u003ca href=\"#池化技术：如何减少频繁创建数据库连接的性能损耗？\" class=\"headerlink\" title=\"池化技术：如何减少频繁创建数据库连接的性能损耗？\"\u003e\u003c/a\u003e池化技术：如何减少频繁创建数据库连接的性能损耗？\u003c/h4\u003e\u003cp\u003e池化技术解决频繁创建连接、创建对象的成本\u003c/p\u003e\n\u003ch3 id=\"数据库优化方案（一）：查询请求增加时，如何做主从分离？\"\u003e\u003ca href=\"#数据库优化方案（一）：查询请求增加时，如何做主从分离？\" class=\"headerlink\" title=\"数据库优化方案（一）：查询请求增加时，如何做主从分离？\"\u003e\u003c/a\u003e数据库优化方案（一）：查询请求增加时，如何做主从分离？\u003c/h3\u003e\u003cp\u003e读写分离：写入时只写主库，在读数据时只读从库。通常采用一主多从架构。\u003c/p\u003e\n\u003cp\u003e读写分离的问题：\u003cstrong\u003e主从同步的延迟\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e读写分离的关键：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主从复制\u003c/li\u003e\n\u003cli\u003e读写流量分发\u003c/li\u003e\n\u003cli\u003e代理：Cobar、Mycat\u003c/li\u003e\n\u003cli\u003e客户端：sharding-jdbc、TDDL\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"数据库优化方案（二）：写入数据量增加时，如何实现分库分表？\"\u003e\u003ca href=\"#数据库优化方案（二）：写入数据量增加时，如何实现分库分表？\" class=\"headerlink\" title=\"数据库优化方案（二）：写入数据量增加时，如何实现分库分表？\"\u003e\u003c/a\u003e数据库优化方案（二）：写入数据量增加时，如何实现分库分表？\u003c/h3\u003e\u003cp\u003e垂直拆分：从业务维度，将表分为不同的库\u003c/p\u003e\n\u003cp\u003e水平拆分：分区 key 是关键。应使用合理策略，分库分表。如：hash 取 mod 法、范围划分\u003c/p\u003e\n\u003ch3 id=\"发号器：如何保证分库分表后-ID-的全局唯一性？\"\u003e\u003ca href=\"#发号器：如何保证分库分表后-ID-的全局唯一性？\" class=\"headerlink\" title=\"发号器：如何保证分库分表后 ID 的全局唯一性？\"\u003e\u003c/a\u003e发号器：如何保证分库分表后 ID 的全局唯一性？\u003c/h3\u003e\u003cp\u003e分布式 ID：UUID、Snowflake 算法\u003c/p\u003e\n\u003ch3 id=\"NoSQL：在高并发场景下，数据库和-NoSQL-如何做到互补？\"\u003e\u003ca href=\"#NoSQL：在高并发场景下，数据库和-NoSQL-如何做到互补？\" class=\"headerlink\" title=\"NoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？\"\u003e\u003c/a\u003eNoSQL：在高并发场景下，数据库和 NoSQL 如何做到互补？\u003c/h3\u003e\u003cp\u003eLSM 树：牺牲了一定的读性能来换取写入数据的高性能，Hbase、Cassandra、LevelDB 都是用这种算法作为存储的引擎。\u003c/p\u003e\n\u003cp\u003e数据首先会写入到一个叫做 MemTable 的内存结构中，在 MemTable 中数据是按照写入的 Key 来排序的。为了防止 MemTable 里面的数据因为机器掉电或者重启而丢失，一般会通过写 Write Ahead Log 的方式将数据备份在磁盘上。\u003c/p\u003e\n\u003cp\u003eMemTable 在累积到一定规模时，它会被刷新生成一个新的文件，我们把这个文件叫做 SSTable（Sorted String Table）。当 SSTable 达到一定数量时，我们会将这些 SSTable 合并，减少文件的数量，因为 SSTable 都是有序的，所以合并的速度也很快。\u003c/p\u003e\n\u003cp\u003e当从 LSM 树里面读数据时，我们首先从 MemTable 中查找数据，如果数据没有找到，再从 SSTable 中查找数据。因为存储的数据都是有序的，所以查找的效率是很高的，只是因为数据被拆分成多个 SSTable，所以读取的效率会低于 B+ 树索引。\u003c/p\u003e\n\u003ch2 id=\"缓存篇\"\u003e\u003ca href=\"#缓存篇\" class=\"headerlink\" title=\"缓存篇\"\u003e\u003c/a\u003e缓存篇\u003c/h2\u003e\u003ch3 id=\"缓存：数据库成为瓶颈后，动态数据的查询要如何加速？\"\u003e\u003ca href=\"#缓存：数据库成为瓶颈后，动态数据的查询要如何加速？\" class=\"headerlink\" title=\"缓存：数据库成为瓶颈后，动态数据的查询要如何加速？\"\u003e\u003c/a\u003e缓存：数据库成为瓶颈后，动态数据的查询要如何加速？\u003c/h3\u003e\u003cp\u003e缓存分类：静态缓存、进程内缓存、分布式缓存\u003c/p\u003e\n\u003ch3 id=\"缓存的使用姿势（一）：如何选择缓存的读写策略？\"\u003e\u003ca href=\"#缓存的使用姿势（一）：如何选择缓存的读写策略？\" class=\"headerlink\" title=\"缓存的使用姿势（一）：如何选择缓存的读写策略？\"\u003e\u003c/a\u003e缓存的使用姿势（一）：如何选择缓存的读写策略？\u003c/h3\u003e\u003ch3 id=\"Cache-Aside（旁路缓存）策略\"\u003e\u003ca href=\"#Cache-Aside（旁路缓存）策略\" class=\"headerlink\" title=\"Cache Aside（旁路缓存）策略\"\u003e\u003c/a\u003eCache Aside（旁路缓存）策略\u003c/h3\u003e\u003cp\u003e先写表，再写缓存，可能会导致缓存和数据库数据不一致\u003c/p\u003e\n\u003cp\u003e更新表，删除缓存 key；读数据时，从表中读取。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e读策略的步骤\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e从缓存中读取数据；\u003c/li\u003e\n\u003cli\u003e如果缓存命中，则直接返回数据；\u003c/li\u003e\n\u003cli\u003e如果缓存不命中，则从数据库中查询数据；\u003c/li\u003e\n\u003cli\u003e查询到数据后，将数据写入到缓存中，并且返回给用户。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e写策略的步骤\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更新数据库中的记录；\u003c/li\u003e\n\u003cli\u003e删除缓存记录。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCache Aside 理论上还是有较小概率导致数据不一致。\u003c/p\u003e\n\u003cp\u003eCache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；\u003c/li\u003e\n\u003cli\u003e另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快地过期，对业务的影响也是可以接受。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"Read-Write-Through（读穿-写穿）策略\"\u003e\u003ca href=\"#Read-Write-Through（读穿-写穿）策略\" class=\"headerlink\" title=\"Read/Write Through（读穿 / 写穿）策略\"\u003e\u003c/a\u003eRead/Write Through（读穿 / 写穿）策略\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20210808210155.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"Write-Back（写回）策略\"\u003e\u003ca href=\"#Write-Back（写回）策略\" class=\"headerlink\" title=\"Write Back（写回）策略\"\u003e\u003c/a\u003eWrite Back（写回）策略\u003c/h3\u003e\u003cp\u003e核心思想是在写入数据时只写入缓存，并且把缓存块儿标记为“脏”的。而脏块儿只有被再次使用时才会将其中的数据写入到后端存储中。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20210808210420.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20210808210511.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e这种策略不能被应用到我们常用的数据库和缓存的场景中，它是计算机体系结构中的设计，比如我们在向磁盘中写数据时采用的就是这种策略。\u003c/p\u003e\n\u003cp\u003e但因为缓存一般使用内存，而内存是非持久化的，所以一旦缓存机器掉电，就会造成原本缓存中的脏块儿数据丢失。所以你会发现系统在掉电之后，之前写入的文件会有部分丢失，就是因为 Page Cache 还没有来得及刷盘造成的。\u003c/p\u003e\n\u003ch3 id=\"缓存的使用姿势（二）：缓存如何做到高可用？\"\u003e\u003ca href=\"#缓存的使用姿势（二）：缓存如何做到高可用？\" class=\"headerlink\" title=\"缓存的使用姿势（二）：缓存如何做到高可用？\"\u003e\u003c/a\u003e缓存的使用姿势（二）：缓存如何做到高可用？\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e分布式缓存的高可用方案\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户端方案：在客户端配置多个缓存的节点，通过缓存写入和读取算法策略来实现分布式，从而提高缓存的可用性。\u003c/li\u003e\n\u003cli\u003e代理层方案：客户端所有的写入和读取的请求都通过代理层，而代理层中会内置高可用策略，帮助提升缓存系统的高可用。\u003c/li\u003e\n\u003cli\u003e服务度方案：Redis Sentinel 方案\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"缓存的使用姿势（三）：缓存穿透了怎么办？\"\u003e\u003ca href=\"#缓存的使用姿势（三）：缓存穿透了怎么办？\" class=\"headerlink\" title=\"缓存的使用姿势（三）：缓存穿透了怎么办？\"\u003e\u003c/a\u003e缓存的使用姿势（三）：缓存穿透了怎么办？\u003c/h3\u003e\u003cp\u003e缓存穿透解決方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e保存 null 值\u003c/li\u003e\n\u003cli\u003e布隆过滤器\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"消息队列篇\"\u003e\u003ca href=\"#消息队列篇\" class=\"headerlink\" title=\"消息队列篇\"\u003e\u003c/a\u003e消息队列篇\u003c/h2\u003e\u003ch3 id=\"消息队列：秒杀时如何处理每秒上万次的下单请求？\"\u003e\u003ca href=\"#消息队列：秒杀时如何处理每秒上万次的下单请求？\" class=\"headerlink\" title=\"消息队列：秒杀时如何处理每秒上万次的下单请求？\"\u003e\u003c/a\u003e消息队列：秒杀时如何处理每秒上万次的下单请求？\u003c/h3\u003e\u003cp\u003e削峰、异步处理、系统解耦\u003c/p\u003e\n\u003ch3 id=\"消息投递：如何保证消息仅仅被消费一次？\"\u003e\u003ca href=\"#消息投递：如何保证消息仅仅被消费一次？\" class=\"headerlink\" title=\"消息投递：如何保证消息仅仅被消费一次？\"\u003e\u003c/a\u003e消息投递：如何保证消息仅仅被消费一次？\u003c/h3\u003e\u003ch3 id=\"系统架构：每秒-1-万次请求的系统要做服务化拆分吗？\"\u003e\u003ca href=\"#系统架构：每秒-1-万次请求的系统要做服务化拆分吗？\" class=\"headerlink\" title=\"系统架构：每秒 1 万次请求的系统要做服务化拆分吗？\"\u003e\u003c/a\u003e系统架构：每秒 1 万次请求的系统要做服务化拆分吗？\u003c/h3\u003e\u003cp\u003e系统中，使用的资源出现扩展性问题，尤其是数据库的连接数出现瓶颈；\u003c/p\u003e\n\u003cp\u003e大团队共同维护一套代码，带来研发效率的降低，和研发成本的提升；\u003c/p\u003e\n\u003cp\u003e系统部署成本越来越高。\u003c/p\u003e\n\u003ch3 id=\"微服务架构：微服务化后，系统架构要如何改造？\"\u003e\u003ca href=\"#微服务架构：微服务化后，系统架构要如何改造？\" class=\"headerlink\" title=\"微服务架构：微服务化后，系统架构要如何改造？\"\u003e\u003c/a\u003e微服务架构：微服务化后，系统架构要如何改造？\u003c/h3\u003e\u003cp\u003e服务拆分时要遵循哪些原则？\u003c/p\u003e\n\u003cp\u003e服务的边界如何确定？服务的粒度是怎样呢？\u003c/p\u003e\n\u003cp\u003e在服务化之后，会遇到哪些问题呢？我们又将如何来解决？\u003c/p\u003e\n\u003ch2 id=\"分布式服务篇\"\u003e\u003ca href=\"#分布式服务篇\" class=\"headerlink\" title=\"分布式服务篇\"\u003e\u003c/a\u003e分布式服务篇\u003c/h2\u003e\u003ch2 id=\"维护篇\"\u003e\u003ca href=\"#维护篇\" class=\"headerlink\" title=\"维护篇\"\u003e\u003c/a\u003e维护篇\u003c/h2\u003e\u003ch3 id=\"给系统加上眼睛：服务端监控要怎么做？\"\u003e\u003ca href=\"#给系统加上眼睛：服务端监控要怎么做？\" class=\"headerlink\" title=\"给系统加上眼睛：服务端监控要怎么做？\"\u003e\u003c/a\u003e给系统加上眼睛：服务端监控要怎么做？\u003c/h3\u003e\u003cp\u003eCPU、内存、磁盘、网络\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e道路千万条，监控第一条，监控不到位，领导两行泪\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e监控指标\u003c/p\u003e\n\u003cp\u003e采集方式\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAgent\u003c/li\u003e\n\u003cli\u003e埋点\u003c/li\u003e\n\u003cli\u003e日志\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e处理和展示\u003c/p\u003e\n\u003ch3 id=\"应用性能管理：用户的使用体验应该如何监控？\"\u003e\u003ca href=\"#应用性能管理：用户的使用体验应该如何监控？\" class=\"headerlink\" title=\"应用性能管理：用户的使用体验应该如何监控？\"\u003e\u003c/a\u003e应用性能管理：用户的使用体验应该如何监控？\u003c/h3\u003e\u003ch3 id=\"压力测试：怎样设计全链路压力测试平台？\"\u003e\u003ca href=\"#压力测试：怎样设计全链路压力测试平台？\" class=\"headerlink\" title=\"压力测试：怎样设计全链路压力测试平台？\"\u003e\u003c/a\u003e压力测试：怎样设计全链路压力测试平台？\u003c/h3\u003e\u003ch3 id=\"配置管理：成千上万的配置项要如何管理？\"\u003e\u003ca href=\"#配置管理：成千上万的配置项要如何管理？\" class=\"headerlink\" title=\"配置管理：成千上万的配置项要如何管理？\"\u003e\u003c/a\u003e配置管理：成千上万的配置项要如何管理？\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e配置存储是分级的，有公共配置，有个性的配置，一般个性配置会覆盖公共配置，这样可以减少存储配置项的数量；\u003c/li\u003e\n\u003cli\u003e配置中心可以提供配置变更通知的功能，可以实现配置的热更新；\u003c/li\u003e\n\u003cli\u003e配置中心关注的性能指标中，可用性的优先级是高于性能的，一般我们会要求配置中心的可用性达到 99.999%，甚至会是 99.9999%。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"实战篇\"\u003e\u003ca href=\"#实战篇\" class=\"headerlink\" title=\"实战篇\"\u003e\u003c/a\u003e实战篇\u003c/h2\u003e\n    \u003c/div\u003e",
  "Date": "2021-08-05T15:42:00Z",
  "Author": "钝悟 ◾ Dunwu"
}