{
  "Source": "dunwu",
  "Title": "JVM 类加载",
  "Link": "https://dunwu.github.io/blog/pages/17aad9/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"JVM-类加载\"\u003e\u003ca href=\"#JVM-类加载\" class=\"headerlink\" title=\"JVM 类加载\"\u003e\u003c/a\u003eJVM 类加载\u003c/h1\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200617145849.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"类加载机制\"\u003e\u003ca href=\"#类加载机制\" class=\"headerlink\" title=\"类加载机制\"\u003e\u003c/a\u003e类加载机制\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003e类是在运行期间动态加载的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e类的加载指的是将类的 \u003ccode\u003e.class\u003c/code\u003e 文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个\u003ccode\u003ejava.lang.Class\u003c/code\u003e对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的\u003ccode\u003eClass\u003c/code\u003e对象，\u003ccode\u003eClass\u003c/code\u003e对象封装了类在方法区内的数据结构，并且向 Java 程序员提供了访问方法区内的数据结构的接口。\u003c/p\u003e\n\u003cp\u003e类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM 规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class 文件缺失或存在错误，类加载器必须在程序首次主动使用该类时才报告错误（LinkageError 错误）如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误\u003c/p\u003e\n\u003ch2 id=\"类的生命周期\"\u003e\u003ca href=\"#类的生命周期\" class=\"headerlink\" title=\"类的生命周期\"\u003e\u003c/a\u003e类的生命周期\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200617115110.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003eJava 类的完整生命周期包括以下几个阶段：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e加载（Loading）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e链接（Linking）\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e验证（Verification）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e准备（Preparation）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e解析（Resolution）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化（Initialization）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e使用（Using）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e卸载（Unloading）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而\u003cstrong\u003e解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。\u003c/p\u003e\n\u003ch3 id=\"（一）加载\"\u003e\u003ca href=\"#（一）加载\" class=\"headerlink\" title=\"（一）加载\"\u003e\u003c/a\u003e（一）加载\u003c/h3\u003e\u003cp\u003e加载是类加载的一个阶段，注意不要混淆。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e加载，是指查找字节流，并且据此创建类的过程\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e加载过程完成以下三件事：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e通过一个类的全限定名来获取定义此类的二进制字节流。\u003c/li\u003e\n\u003cli\u003e将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。\u003c/li\u003e\n\u003cli\u003e在内存中生成一个代表这个类的 \u003ccode\u003eClass\u003c/code\u003e 对象，作为方法区这个类的各种数据的访问入口。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中二进制字节流可以从以下方式中获取：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e从 ZIP 包读取，这很常见，最终成为日后 JAR、EAR、WAR 格式的基础。\u003c/li\u003e\n\u003cli\u003e从网络中获取，这种场景最典型的应用是 Applet。\u003c/li\u003e\n\u003cli\u003e运行时计算生成，这种场景使用得最多得就是动态代理技术，在 \u003ccode\u003ejava.lang.reflect.Proxy\u003c/code\u003e 中，就是用了 \u003ccode\u003eProxyGenerator.generateProxyClass\u003c/code\u003e 的代理类的二进制字节流。\u003c/li\u003e\n\u003cli\u003e由其他文件生成，典型场景是 JSP 应用，即由 JSP 文件生成对应的 Class 类。\u003c/li\u003e\n\u003cli\u003e从数据库读取，这种场景相对少见，例如有些中间件服务器（如 SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。\u003cbr/\u003e…\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e更详细内容会在 \u003ca href=\"#3-classloader\"\u003e3. ClassLoader\u003c/a\u003e 介绍。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"（二）验证\"\u003e\u003ca href=\"#（二）验证\" class=\"headerlink\" title=\"（二）验证\"\u003e\u003c/a\u003e（二）验证\u003c/h3\u003e\u003cp\u003e验证是链接阶段的第一步。\u003cstrong\u003e验证的目标是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求\u003c/strong\u003e，并且不会危害虚拟机自身的安全。\u003c/p\u003e\n\u003cp\u003e验证阶段大致会完成 4 个阶段的检验动作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e文件格式验证\u003c/strong\u003e - 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e元数据验证\u003c/strong\u003e - 对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e字节码验证\u003c/strong\u003e - 通过数据流和控制流分析，确保程序语义是合法、符合逻辑的。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e符号引用验证\u003c/strong\u003e - 发生在虚拟机将符号引用转换为直接引用的时候，对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 \u003ccode\u003e-Xverifynone\u003c/code\u003e 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。\u003c/p\u003e\n\u003ch3 id=\"（三）准备\"\u003e\u003ca href=\"#（三）准备\" class=\"headerlink\" title=\"（三）准备\"\u003e\u003c/a\u003e（三）准备\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e类变量是被 static 修饰的变量，准备阶段为 static 变量在方法区分配内存并初始化为默认值，使用的是方法区的内存。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在 Java 堆中。（实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次）\u003c/p\u003e\n\u003cp\u003e初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003evalue\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e123\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如果类变量是常量，那么会按照表达式来进行初始化，而不是赋值为 0。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003evalue\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e123\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e准备阶段有以下几点需要注意：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。\u003c/li\u003e\n\u003cli\u003e这里所设置的初始值通常情况下是数据类型默认的零值（如 \u003ccode\u003e0\u003c/code\u003e、\u003ccode\u003e0L\u003c/code\u003e、\u003ccode\u003enull\u003c/code\u003e、\u003ccode\u003efalse\u003c/code\u003e 等），而不是被在 Java 代码中被显式地赋予的值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e假设一个类变量的定义为：\u003ccode\u003epublic static int value = 3\u003c/code\u003e；\u003c/p\u003e\n\u003cp\u003e那么变量 value 在准备阶段过后的初始值为 0，而不是 3，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 3 的\u003ccode\u003epublic static\u003c/code\u003e指令是在程序编译后，存放于类构造器\u003ccode\u003e（）\u003c/code\u003e方法之中的，所以把 value 赋值为 3 的动作将在初始化阶段才会执行。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里还需要注意如下几点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。\u003c/li\u003e\n\u003cli\u003e对于同时被 static 和 final 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 final 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。\u003c/li\u003e\n\u003cli\u003e对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。\u003c/li\u003e\n\u003cli\u003e如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e如果类字段的字段属性表中存在\u003ccode\u003eConstantValue\u003c/code\u003e属性，即同时被 final 和 static 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e假设上面的类变量 value 被定义为： \u003ccode\u003epublic static final int value = 3\u003c/code\u003e；\u003c/p\u003e\n\u003cp\u003e编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据\u003ccode\u003eConstantValue\u003c/code\u003e的设置将 value 赋值为 3。我们可以理解为 static final 常量在编译期就将其结果放入了调用它的类的常量池中\u003c/p\u003e\n\u003ch3 id=\"（四）解析\"\u003e\u003ca href=\"#（四）解析\" class=\"headerlink\" title=\"（四）解析\"\u003e\u003c/a\u003e（四）解析\u003c/h3\u003e\u003cp\u003e在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。\u003c/p\u003e\n\u003cp\u003e举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解析阶段目标是将常量池的符号引用替换为直接引用的过程\u003c/strong\u003e。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e符号引用（Symbolic References）\u003c/strong\u003e - 符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e直接引用（Direct Reference）\u003c/strong\u003e - 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"（五）初始化\"\u003e\u003ca href=\"#（五）初始化\" class=\"headerlink\" title=\"（五）初始化\"\u003e\u003c/a\u003e（五）初始化\u003c/h3\u003e\u003cp\u003e在 Java 代码中，如果要初始化一个静态字段，可以在声明时直接赋值，也可以在静态代码块中对其赋值。\u003c/p\u003e\n\u003cp\u003e如果直接赋值的静态字段被 \u003ccode\u003efinal\u003c/code\u003e 所修饰，并且它的类型是基本类型或字符串时，那么该字段便会被 Java 编译器标记成常量值（ConstantValue），其初始化直接由 Java 虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被 Java 编译器置于同一方法中，并把它命名为 \u003ccode\u003e\u0026lt; clinit \u0026gt;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e初始化阶段才真正开始执行类中的定义的 Java 程序代码。初始化，\u003cstrong\u003e为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4 id=\"类初始化方式\"\u003e\u003ca href=\"#类初始化方式\" class=\"headerlink\" title=\"类初始化方式\"\u003e\u003c/a\u003e类初始化方式\u003c/h4\u003e\u003cul\u003e\n\u003cli\u003e声明类变量时指定初始值\u003c/li\u003e\n\u003cli\u003e使用静态代码块为类变量指定初始值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"类初始化步骤\"\u003e\u003ca href=\"#类初始化步骤\" class=\"headerlink\" title=\"类初始化步骤\"\u003e\u003c/a\u003e类初始化步骤\u003c/h4\u003e\u003col\u003e\n\u003cli\u003e如果类还没有被加载和链接，开始加载该类。\u003c/li\u003e\n\u003cli\u003e如果该类的直接父类还没有被初始化，先初始化其父类。\u003c/li\u003e\n\u003cli\u003e如果该类有初始化语句，则依次执行这些初始化语句。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"类初始化时机\"\u003e\u003ca href=\"#类初始化时机\" class=\"headerlink\" title=\"类初始化时机\"\u003e\u003c/a\u003e类初始化时机\u003c/h4\u003e\u003cp\u003e只有主动引用类的时候才会导致类的初始化。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e（1）主动引用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e类的主动引用包括以下六种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e创建类的实例\u003c/strong\u003e - 也就是 \u003ccode\u003enew\u003c/code\u003e 对象\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e访问静态变量\u003c/strong\u003e - 访问某个类或接口的静态变量，或者对该静态变量赋值\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e访问静态方法\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e反射\u003c/strong\u003e - 如\u003ccode\u003eClass.forName(“com.shengsiyuan.Test”)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e初始化子类\u003c/strong\u003e - 初始化某个类的子类，则其父类也会被初始化\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e启动类\u003c/strong\u003e - Java 虚拟机启动时被标明为启动类的类（\u003ccode\u003eJava Test\u003c/code\u003e），直接使用\u003ccode\u003ejava.exe\u003c/code\u003e命令来运行某个主类\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e（2）被动引用\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e通过子类引用父类的静态字段，不会导致子类初始化\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eSystem.out.println(SubClass.value); \u003cspan class=\"comment\"\u003e// value 字段在 SuperClass 中定义\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e通过数组定义来引用类，不会触发此类的初始化\u003c/strong\u003e。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 \u003ccode\u003eObject\u003c/code\u003e 的子类，其中包含了数组的属性和方法。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eSuperClass[] sca = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSuperClass\u003c/span\u003e[\u003cspan class=\"number\"\u003e10\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发\u003cstrong\u003e定义常量的类的初始化\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eSystem.out.println(ConstClass.HELLOWORLD);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"类初始化细节\"\u003e\u003ca href=\"#类初始化细节\" class=\"headerlink\" title=\"类初始化细节\"\u003e\u003c/a\u003e类初始化细节\u003c/h4\u003e\u003cp\u003e类初始化 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法的细节：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{} 块）中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eTest\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;                \u003cspan class=\"comment\"\u003e// 给变量赋值可以正常编译通过\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        System.out.print(i);  \u003cspan class=\"comment\"\u003e// 这句编译器会提示“非法向前引用”\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003ei\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e与类的构造函数（或者说实例构造器 \u003ccode\u003e\u0026lt;init\u0026gt;()\u003c/code\u003e）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法运行之前，父类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法已经执行结束。因此虚拟机中第一个执行 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法的类肯定为 \u003ccode\u003ejava.lang.Object\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e由于父类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法先执行，也就意味着父类中定义的静态语句块要优于子类的变量赋值操作。例如以下代码：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eParent\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003eA\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        A = \u003cspan class=\"number\"\u003e2\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSub\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eParent\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003eB\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e A;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e     System.out.println(Sub.B);  \u003cspan class=\"comment\"\u003e// 输出结果是父类中的静态变量 A 的值，也就是 2。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法。但接口与类不同的是，执行接口的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法不需要先执行父接口的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e虚拟机会保证一个类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法，其它线程都会阻塞等待，直到活动线程执行 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法完毕。如果在一个类的 \u003ccode\u003e\u0026lt;clinit\u0026gt;()\u003c/code\u003e 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ClassLoader\"\u003e\u003ca href=\"#ClassLoader\" class=\"headerlink\" title=\"ClassLoader\"\u003e\u003c/a\u003eClassLoader\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eClassLoader\u003c/code\u003e 即类加载器，负责将类加载到 JVM。在 Java 虚拟机外部实现，以便让应用程序自己决定如何去获取所需要的类。\u003c/p\u003e\n\u003cp\u003eJVM 加载 \u003ccode\u003eclass\u003c/code\u003e 文件到内存有两种方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e隐式加载 - JVM 自动加载需要的类到内存中。\u003c/li\u003e\n\u003cli\u003e显示加载 - 通过使用 \u003ccode\u003eClassLoader\u003c/code\u003e 来加载一个类到内存中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"类与类加载器\"\u003e\u003ca href=\"#类与类加载器\" class=\"headerlink\" title=\"类与类加载器\"\u003e\u003c/a\u003e类与类加载器\u003c/h3\u003e\u003cp\u003e如何判断两个类是否相等：类本身相等，并且使用同一个类加载器进行加载。这是因为\u003cstrong\u003e每一个 \u003ccode\u003eClassLoader\u003c/code\u003e 都拥有一个独立的类名称空间\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这里的相等，包括类的 \u003ccode\u003eClass\u003c/code\u003e 对象的 \u003ccode\u003eequals()\u003c/code\u003e 方法、\u003ccode\u003eisAssignableFrom()\u003c/code\u003e 方法、\u003ccode\u003eisInstance()\u003c/code\u003e 方法的返回结果为 true，也包括使用 \u003ccode\u003einstanceof\u003c/code\u003e 关键字做对象所属关系判定结果为 true。\u003c/p\u003e\n\u003ch3 id=\"类加载器分类\"\u003e\u003ca href=\"#类加载器分类\" class=\"headerlink\" title=\"类加载器分类\"\u003e\u003c/a\u003e类加载器分类\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200617115936.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"Bootstrap-ClassLoader\"\u003e\u003ca href=\"#Bootstrap-ClassLoader\" class=\"headerlink\" title=\"Bootstrap ClassLoader\"\u003e\u003c/a\u003eBootstrap ClassLoader\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e ，即启动类加载器 ，\u003cstrong\u003e负责加载 JVM 自身工作所需要的类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e 会将存放在 \u003ccode\u003e\u0026lt;JAVA_HOME\u0026gt;\\lib\u003c/code\u003e 目录中的，或者被 \u003ccode\u003e-Xbootclasspath\u003c/code\u003e 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e 是由 C++ 实现的，它完全由 JVM 自己控制的，启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 \u003ccode\u003enull\u003c/code\u003e 代替即可。\u003c/p\u003e\n\u003ch4 id=\"ExtClassLoader\"\u003e\u003ca href=\"#ExtClassLoader\" class=\"headerlink\" title=\"ExtClassLoader\"\u003e\u003c/a\u003eExtClassLoader\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eExtClassLoader\u003c/code\u003e，即扩展类加载器，这个类加载器是由 \u003ccode\u003eExtClassLoader(sun.misc.Launcher\\$ExtClassLoader)\u003c/code\u003e实现的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eExtClassLoader\u003c/code\u003e 负责将 \u003ccode\u003e\u0026lt;JAVA_HOME\u0026gt;\\lib\\ext\u003c/code\u003e 或者被 \u003ccode\u003ejava.ext.dir\u003c/code\u003e 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4 id=\"AppClassLoader\"\u003e\u003ca href=\"#AppClassLoader\" class=\"headerlink\" title=\"AppClassLoader\"\u003e\u003c/a\u003eAppClassLoader\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eAppClassLoader\u003c/code\u003e，即应用程序类加载器，这个类加载器是由 \u003ccode\u003eAppClassLoader(sun.misc.Launcher\\$AppClassLoader)\u003c/code\u003e 实现的。由于这个类加载器是 \u003ccode\u003eClassLoader\u003c/code\u003e 中的 \u003ccode\u003egetSystemClassLoader()\u003c/code\u003e 方法的返回值，因此一般称为系统类加载器。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eAppClassLoader\u003c/code\u003e 负责加载用户类路径（即 \u003ccode\u003eclasspath\u003c/code\u003e）上所指定的类库\u003c/strong\u003e，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\u003c/p\u003e\n\u003ch4 id=\"自定义类加载器\"\u003e\u003ca href=\"#自定义类加载器\" class=\"headerlink\" title=\"自定义类加载器\"\u003e\u003c/a\u003e自定义类加载器\u003c/h4\u003e\u003cp\u003e自定义类加载器可以做到如下几点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在执行非置信代码之前，自动验证数字签名。\u003c/li\u003e\n\u003cli\u003e动态地创建符合用户特定需要的定制化构建类。\u003c/li\u003e\n\u003cli\u003e从特定的场所取得 java class，例如数据库中和网络中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e假设，我们需要自定义一个名为 \u003ccode\u003eFileSystemClassLoader\u003c/code\u003e 的类加载器，继承自 \u003ccode\u003ejava.lang.ClassLoader\u003c/code\u003e，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（\u003ccode\u003e.class\u003c/code\u003e 文件），然后读取该文件内容，最后通过 \u003ccode\u003edefineClass()\u003c/code\u003e 方法来把这些字节代码转换成 \u003ccode\u003ejava.lang.Class\u003c/code\u003e 类的实例。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ejava.lang.ClassLoader\u003c/code\u003e 类的方法 \u003ccode\u003eloadClass()\u003c/code\u003e 实现了双亲委派模型的逻辑，因此自定义类加载器一般不去覆写它，而是通过覆写 \u003ccode\u003efindClass()\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eClassLoader\u003c/code\u003e 常用的场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e容器 - 典型应用：Servlet 容器（如：Tomcat、Jetty）、udf （Mysql、Hive）等。加载解压 jar 包或 war 包后，加载其 Class 到指定的类加载器中运行（通常需要考虑空间隔离）。\u003c/li\u003e\n\u003cli\u003e热部署、热插拔 - 应用启动后，动态获得某个类信息，然后加载到 JVM 中工作。很多著名的容器软件、框架（如：Spring 等），都使用 \u003ccode\u003eClassLoader\u003c/code\u003e 来实现自身的热部署。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e【示例】自定义一个类加载器\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFileSystemClassLoader\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassLoader\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e String rootDir;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003eFileSystemClassLoader\u003c/span\u003e\u003cspan class=\"params\"\u003e(String rootDir)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.rootDir = rootDir;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e Class\u0026lt;?\u0026gt; findClass(String name) \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e ClassNotFoundException {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003ebyte\u003c/span\u003e[] classData = getClassData(name);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (classData == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassNotFoundException\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e defineClass(name, classData, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, classData.length);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"type\"\u003ebyte\u003c/span\u003e[] getClassData(String className) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003epath\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e classNameToPath(className);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003eInputStream\u003c/span\u003e \u003cspan class=\"variable\"\u003eins\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFileInputStream\u003c/span\u003e(path);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003eByteArrayOutputStream\u003c/span\u003e \u003cspan class=\"variable\"\u003ebaos\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eByteArrayOutputStream\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003ebufferSize\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e4096\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003ebyte\u003c/span\u003e[] buffer = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003ebyte\u003c/span\u003e[bufferSize];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003eint\u003c/span\u003e bytesNumRead;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e ((bytesNumRead = ins.read(buffer)) != -\u003cspan class=\"number\"\u003e1\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                baos.write(buffer, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, bytesNumRead);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e baos.toByteArray();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (IOException e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            e.printStackTrace();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e String \u003cspan class=\"title function_\"\u003eclassNameToPath\u003c/span\u003e\u003cspan class=\"params\"\u003e(String className)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e rootDir + File.separatorChar\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                + className.replace(\u003cspan class=\"string\"\u003e\u0026#39;.\u0026#39;\u003c/span\u003e, File.separatorChar) + \u003cspan class=\"string\"\u003e\u0026#34;.class\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"双亲委派\"\u003e\u003ca href=\"#双亲委派\" class=\"headerlink\" title=\"双亲委派\"\u003e\u003c/a\u003e双亲委派\u003c/h3\u003e\u003cp\u003e理解双亲委派之前，先让我们看一个示例。\u003c/p\u003e\n\u003cp\u003e【示例】寻找类加载示例\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eClassLoader\u003c/span\u003e \u003cspan class=\"variable\"\u003eloader\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e Thread.currentThread().getContextClassLoader();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    System.out.println(loader);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    System.out.println(loader.getParent());\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    System.out.println(loader.getParent().getParent());\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003c/p\u003e\n\u003cfigure class=\"highlight autoit\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003esun.misc.Launcher$AppClassLoader\u003cspan class=\"symbol\"\u003e@18b4aac2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esun.misc.Launcher$ExtClassLoader\u003cspan class=\"symbol\"\u003e@19e1023e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"literal\"\u003enull\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e从上面的结果可以看出，并没有获取到 \u003ccode\u003eExtClassLoader\u003c/code\u003e 的父 Loader，原因是 \u003ccode\u003eBootstrap Loader\u003c/code\u003e（引导类加载器）是用 C 语言实现的，找不到一个确定的返回父 Loader 的方式，于是就返回 null。\u003c/p\u003e\n\u003cp\u003e下图展示的类加载器之间的层次关系，称为类加载器的\u003cstrong\u003e双亲委派模型（Parents Delegation Model）\u003c/strong\u003e。\u003cstrong\u003e该模型要求除了顶层的 Bootstrap ClassLoader 外，其余的类加载器都应有自己的父类加载器\u003c/strong\u003e。\u003cstrong\u003e这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现\u003c/strong\u003e。\u003c/p\u003e\n\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/jvm/jmm-类加载-双亲委派.png\" width=\"500\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003e\u003cstrong\u003e（1）工作过程\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e一个类加载器首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试加载\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e（2）好处\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系\u003c/strong\u003e，从而使得基础类得到统一：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e系统类防止内存中出现多份同样的字节码\u003c/li\u003e\n\u003cli\u003e保证 Java 程序安全稳定运行\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例如： \u003ccode\u003ejava.lang.Object\u003c/code\u003e 存放在 rt.jar 中，如果编写另外一个 \u003ccode\u003ejava.lang.Object\u003c/code\u003e 的类并放到 \u003ccode\u003eclasspath\u003c/code\u003e 中，程序可以编译通过。因为双亲委派模型的存在，所以在 rt.jar 中的 \u003ccode\u003eObject\u003c/code\u003e 比在 \u003ccode\u003eclasspath\u003c/code\u003e 中的 \u003ccode\u003eObject\u003c/code\u003e 优先级更高，因为 rt.jar 中的 \u003ccode\u003eObject\u003c/code\u003e 使用的是启动类加载器，而 \u003ccode\u003eclasspath\u003c/code\u003e 中的 \u003ccode\u003eObject\u003c/code\u003e 使用的是应用程序类加载器。正因为 rt.jar 中的 \u003ccode\u003eObject\u003c/code\u003e 优先级更高，因为程序中所有的 \u003ccode\u003eObject\u003c/code\u003e 都是这个 \u003ccode\u003eObject\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e（3）实现\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e以下是抽象类 \u003ccode\u003ejava.lang.ClassLoader\u003c/code\u003e 的代码片段，其中的 \u003ccode\u003eloadClass()\u003c/code\u003e 方法运行过程如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e41\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e42\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassLoader\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// The parent class loader for delegation\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e ClassLoader parent;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e Class\u0026lt;?\u0026gt; loadClass(String name) \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e ClassNotFoundException {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e loadClass(name, \u003cspan class=\"literal\"\u003efalse\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e Class\u0026lt;?\u0026gt; loadClass(String name, \u003cspan class=\"type\"\u003eboolean\u003c/span\u003e resolve) \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e ClassNotFoundException {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (getClassLoadingLock(name)) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"comment\"\u003e// 首先判断该类型是否已经被加载\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            Class\u0026lt;?\u0026gt; c = findLoadedClass(name);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"comment\"\u003e// 如果没有被加载，就委托给父类加载或者委派给启动类加载器加载\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (parent != \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        \u003cspan class=\"comment\"\u003e// 如果存在父类加载器，就委派给父类加载器加载\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        c = parent.loadClass(name, \u003cspan class=\"literal\"\u003efalse\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    } \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        \u003cspan class=\"comment\"\u003e// 如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        c = findBootstrapClassOrNull(name);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (ClassNotFoundException e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 如果父类加载器加载失败，会抛出 ClassNotFoundException\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (c == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    c = findClass(name);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (resolve) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                resolveClass(c);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e c;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e Class\u0026lt;?\u0026gt; findClass(String name) \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e ClassNotFoundException {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassNotFoundException\u003c/span\u003e(name);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e【说明】\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先检查类是否已经加载过，如果没有则让父类加载器去加载。\u003c/li\u003e\n\u003cli\u003e当父类加载器加载失败时抛出 \u003ccode\u003eClassNotFoundException\u003c/code\u003e，此时尝试自己去加载。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"ClassLoader-参数\"\u003e\u003ca href=\"#ClassLoader-参数\" class=\"headerlink\" title=\"ClassLoader 参数\"\u003e\u003c/a\u003eClassLoader 参数\u003c/h3\u003e\u003cp\u003e在生产环境上启动 java 应用时，通常会指定一些 \u003ccode\u003eClassLoader\u003c/code\u003e 参数，以加载应用所需要的 lib：\u003c/p\u003e\n\u003cfigure class=\"highlight shell\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ejava -jar xxx.jar -classpath lib/*\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eClassLoader\u003c/code\u003e 相关参数选项：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e参数选项\u003c/th\u003e\n\u003cth\u003eClassLoader 类型\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xbootclasspath\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 \u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e 搜索路径。【不常用】\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xbootclasspath/a\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e把路径添加到已存在的 \u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e 搜索路径后面。【常用】\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Xbootclasspath/p\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e把路径添加到已存在的 \u003ccode\u003eBootstrap ClassLoader\u003c/code\u003e 搜索路径前面。【不常用】\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Djava.ext.dirs\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eExtClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 \u003ccode\u003eExtClassLoader\u003c/code\u003e 搜索路径。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e-Djava.class.path\u003c/code\u003e 或 \u003ccode\u003e-cp\u003c/code\u003e 或 \u003ccode\u003e-classpath\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eAppClassLoader\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e设置 \u003ccode\u003eAppClassLoader\u003c/code\u003e 搜索路径。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"类的加载\"\u003e\u003ca href=\"#类的加载\" class=\"headerlink\" title=\"类的加载\"\u003e\u003c/a\u003e类的加载\u003c/h2\u003e\u003ch3 id=\"类加载方式\"\u003e\u003ca href=\"#类加载方式\" class=\"headerlink\" title=\"类加载方式\"\u003e\u003c/a\u003e类加载方式\u003c/h3\u003e\u003cp\u003e类加载有三种方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e命令行启动应用时候由 JVM 初始化加载\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eClass.forName()\u003c/code\u003e 方法动态加载\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eClassLoader.loadClass()\u003c/code\u003e 方法动态加载\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eClass.forName()\u003c/code\u003e 和 \u003ccode\u003eClassLoader.loadClass()\u003c/code\u003e 区别\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eClass.forName()\u003c/code\u003e 将类的 \u003ccode\u003e.class\u003c/code\u003e 文件加载到 jvm 中之外，还会对类进行解释，执行类中的 \u003ccode\u003estatic\u003c/code\u003e 块；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClassLoader.loadClass()\u003c/code\u003e 只干一件事情，就是将 \u003ccode\u003e.class\u003c/code\u003e 文件加载到 jvm 中，不会执行 \u003ccode\u003estatic\u003c/code\u003e 中的内容，只有在 \u003ccode\u003enewInstance\u003c/code\u003e 才会去执行 \u003ccode\u003estatic\u003c/code\u003e 块。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eClass.forName(name, initialize, loader)\u003c/code\u003e 带参函数也可控制是否加载 \u003ccode\u003estatic\u003c/code\u003e 块。并且只有调用了 \u003ccode\u003enewInstance()\u003c/code\u003e 方法采用调用构造函数，创建类的对象 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"加载类错误\"\u003e\u003ca href=\"#加载类错误\" class=\"headerlink\" title=\"加载类错误\"\u003e\u003c/a\u003e加载类错误\u003c/h3\u003e\u003ch4 id=\"ClassNotFoundException\"\u003e\u003ca href=\"#ClassNotFoundException\" class=\"headerlink\" title=\"ClassNotFoundException\"\u003e\u003c/a\u003eClassNotFoundException\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eClassNotFoundException\u003c/code\u003e 异常出镜率极高。**\u003ccode\u003eClassNotFoundException\u003c/code\u003e 表示当前 \u003ccode\u003eclasspath\u003c/code\u003e 下找不到指定类**。\u003c/p\u003e\n\u003cp\u003e常见问题原因：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e调用 \u003ccode\u003eClass\u003c/code\u003e 的 \u003ccode\u003eforName()\u003c/code\u003e 方法，未找到类。\u003c/li\u003e\n\u003cli\u003e调用 \u003ccode\u003eClassLoader\u003c/code\u003e 中的 \u003ccode\u003eloadClass()\u003c/code\u003e 方法，未找到类。\u003c/li\u003e\n\u003cli\u003e调用 \u003ccode\u003eClassLoader\u003c/code\u003e 中的 \u003ccode\u003efindSystemClass()\u003c/code\u003e 方法，未找到类。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e【示例】执行以下代码，会抛出 \u003ccode\u003eClassNotFoundException\u003c/code\u003e 异常：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassNotFoundExceptionDemo\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            Class.forName(\u003cspan class=\"string\"\u003e\u0026#34;NotFound\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (ClassNotFoundException e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            e.printStackTrace();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e解决方法：检查 \u003ccode\u003eclasspath\u003c/code\u003e 下有没有相应的 class 文件。\u003c/p\u003e\n\u003ch4 id=\"NoClassDefFoundError\"\u003e\u003ca href=\"#NoClassDefFoundError\" class=\"headerlink\" title=\"NoClassDefFoundError\"\u003e\u003c/a\u003eNoClassDefFoundError\u003c/h4\u003e\u003cp\u003e常见问题原因：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e类依赖的 Class 或者 jar 不存在。\u003c/li\u003e\n\u003cli\u003e类文件存在，但是存在不同的域中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e解决方法：现代 Java 项目，一般使用 \u003ccode\u003emaven\u003c/code\u003e、\u003ccode\u003egradle\u003c/code\u003e 等构建工具管理项目，仔细检查找不到的类所在的 jar 包是否已添加为依赖。\u003c/p\u003e\n\u003ch4 id=\"UnsatisfiedLinkError\"\u003e\u003ca href=\"#UnsatisfiedLinkError\" class=\"headerlink\" title=\"UnsatisfiedLinkError\"\u003e\u003c/a\u003eUnsatisfiedLinkError\u003c/h4\u003e\u003cp\u003e这个异常倒不是很常见，但是出错的话，通常是在 JVM 启动的时候如果一不小心将在 JVM 中的某个 lib 删除了，可能就会报这个错误了。\u003c/p\u003e\n\u003cp\u003e【示例】执行以下代码，会抛出 \u003ccode\u003eUnsatisfiedLinkError\u003c/code\u003e 错误。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eUnsatisfiedLinkErrorDemo\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003enative\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003enativeMethod\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        System.loadLibrary(\u003cspan class=\"string\"\u003e\u0026#34;NoLib\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eUnsatisfiedLinkErrorDemo\u003c/span\u003e().nativeMethod();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e【输出】\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ejava.lang.UnsatisfiedLinkError: no NoLib in java.library.path\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tat java.lang.ClassLoader.loadLibrary(ClassLoader.java:\u003cspan class=\"number\"\u003e1867\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tat java.lang.Runtime.loadLibrary0(Runtime.java:\u003cspan class=\"number\"\u003e870\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tat java.lang.System.loadLibrary(System.java:\u003cspan class=\"number\"\u003e1122\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tat io.github.dunwu.javacore.jvm.classloader.exception.UnsatisfiedLinkErrorDemo.\u0026lt;clinit\u0026gt;(UnsatisfiedLinkErrorDemo.java:\u003cspan class=\"number\"\u003e12\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"ClassCastException\"\u003e\u003ca href=\"#ClassCastException\" class=\"headerlink\" title=\"ClassCastException\"\u003e\u003c/a\u003eClassCastException\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eClassCastException\u003c/code\u003e 异常通常是在程序中强制类型转换失败时出现。\u003c/p\u003e\n\u003cp\u003e【示例】执行以下代码，会抛出 \u003ccode\u003eClassCastException\u003c/code\u003e 异常。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eClassCastExceptionDemo\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eObject\u003c/span\u003e \u003cspan class=\"variable\"\u003eobj\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eObject\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eEmptyClass\u003c/span\u003e \u003cspan class=\"variable\"\u003enewObj\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e (EmptyClass) obj;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eEmptyClass\u003c/span\u003e {}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e【输出】\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eException in thread \u003cspan class=\"string\"\u003e\u0026#34;main\u0026#34;\u003c/span\u003e java.lang.ClassCastException: java.lang.Object cannot be cast to io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo$EmptyClass\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tat io.github.dunwu.javacore.jvm.classloader.exception.ClassCastExceptionDemo.main(ClassCastExceptionDemo.java:\u003cspan class=\"number\"\u003e11\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/34907497/\"\u003e《深入理解 Java 虚拟机》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100010301\"\u003e深入拆解 Java 虚拟机\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5e479c2cf265da575f4e65e4\"\u003e一篇图文彻底弄懂类加载器与双亲委派机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.ityouknow.com/jvm/2017/08/19/class-loading-principle.html\"\u003eJvm 系列(一):Java 类的加载机制\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-06-17T07:06:46Z",
  "Author": "钝悟 ◾ Dunwu"
}