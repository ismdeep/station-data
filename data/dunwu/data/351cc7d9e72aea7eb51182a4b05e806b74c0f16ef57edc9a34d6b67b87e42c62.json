{
  "Source": "dunwu",
  "Title": "Redis 事务",
  "Link": "https://dunwu.github.io/blog/pages/476a09/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Redis-事务\"\u003e\u003ca href=\"#Redis-事务\" class=\"headerlink\" title=\"Redis 事务\"\u003e\u003c/a\u003eRedis 事务\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eRedis 仅支持“非严格”的事务\u003c/strong\u003e。所谓“非严格”是指：Redis 事务保证“全部执行命令”；但是，Redis 事务“不支持回滚”。\u003c/p\u003e\n\u003cp\u003e关键词：\u003ccode\u003e事务\u003c/code\u003e、\u003ccode\u003eACID\u003c/code\u003e、\u003ccode\u003eMULTI\u003c/code\u003e、\u003ccode\u003eEXEC\u003c/code\u003e、\u003ccode\u003eDISCARD\u003c/code\u003e、\u003ccode\u003eWATCH\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Redis-事务简介\"\u003e\u003ca href=\"#Redis-事务简介\" class=\"headerlink\" title=\"Redis 事务简介\"\u003e\u003c/a\u003eRedis 事务简介\u003c/h2\u003e\u003ch3 id=\"什么是-ACID\"\u003e\u003ca href=\"#什么是-ACID\" class=\"headerlink\" title=\"什么是 ACID\"\u003e\u003c/a\u003e什么是 ACID\u003c/h3\u003e\u003cp\u003eACID 是数据库事务正确执行的四个基本要素。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e原子性（Atomicity）\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e事务被视为不可分割的最小单元，事务中的所有操作\u003cstrong\u003e要么全部提交成功，要么全部失败回滚\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e一致性（Consistency）\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e数据库在事务执行前后都保持一致性状态。\u003c/li\u003e\n\u003cli\u003e在一致性状态下，所有事务对一个数据的读取结果都是相同的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e隔离性（Isolation）\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e一个事务所做的修改在最终提交以前，对其它事务是不可见的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e持久性（Durability）\u003c/strong\u003e\u003cul\u003e\n\u003cli\u003e一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。\u003c/li\u003e\n\u003cli\u003e可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e只有满足一致性，事务的执行结果才是正确的。\u003c/li\u003e\n\u003cli\u003e在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。\u003c/li\u003e\n\u003cli\u003e在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。\u003c/li\u003e\n\u003cli\u003e事务满足持久化是为了能应对系统崩溃的情况。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/database/RDB/%E6%95%B0%E6%8D%AE%E5%BA%93ACID.png\" alt=\"ACID\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"Redis-事务的特性\"\u003e\u003ca href=\"#Redis-事务的特性\" class=\"headerlink\" title=\"Redis 事务的特性\"\u003e\u003c/a\u003eRedis 事务的特性\u003c/h3\u003e\u003cp\u003eRedis 的事务总是支持 ACID 中的原子性、一致性和隔离性， 当服务器运行在 AOF 持久化模式下， 并且 \u003ccode\u003eappendfsync\u003c/code\u003e 选项的值为 \u003ccode\u003ealways\u003c/code\u003e 时， 事务也具有持久性。\u003c/p\u003e\n\u003cp\u003e但需要注意的是：\u003cstrong\u003eRedis 仅支持“非严格”的事务\u003c/strong\u003e。这里的“非严格”，其实指的是 Redis 事务只能部分保证 ACID 中的原子性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRedis 事务保证全部执行命令\u003c/strong\u003e - Redis 事务中的多个命令会被打包到事务队列中，然后按先进先出（FIFO）的顺序执行。事务在执行过程中不会被中断，当事务队列中的所有命令都被执行完毕之后，事务才会结束。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRedis 事务不支持回滚\u003c/strong\u003e - 如果命令执行失败不会回滚，而是会继续执行下去。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRedis 官方的\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/docs/interact/transactions/\"\u003e事务特性文档\u003c/a\u003e给出的不支持回滚的理由是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRedis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。\u003c/li\u003e\n\u003cli\u003e因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"Redis-事务应用\"\u003e\u003ca href=\"#Redis-事务应用\" class=\"headerlink\" title=\"Redis 事务应用\"\u003e\u003c/a\u003eRedis 事务应用\u003c/h2\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/multi\"\u003e\u003ccode\u003eMULTI\u003c/code\u003e\u003c/a\u003e、\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/exec\"\u003e\u003ccode\u003eEXEC\u003c/code\u003e\u003c/a\u003e、\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/discard\"\u003e\u003ccode\u003eDISCARD\u003c/code\u003e\u003c/a\u003e 和 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/watch\"\u003e\u003ccode\u003eWATCH\u003c/code\u003e\u003c/a\u003e 是 Redis 事务相关的命令。\u003c/p\u003e\n\u003cp\u003e事务可以一次执行多个命令， 并且有以下两个重要的保证：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。\u003c/li\u003e\n\u003cli\u003e事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"MULTI\"\u003e\u003ca href=\"#MULTI\" class=\"headerlink\" title=\"MULTI\"\u003e\u003c/a\u003eMULTI\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/multi\"\u003e\u003ccode\u003eMULTI\u003c/code\u003e\u003c/a\u003e 命令用于开启一个事务，它总是返回 OK 。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMULTI\u003c/code\u003e 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。\u003c/p\u003e\n\u003cp\u003e以下是一个事务例子， 它原子地增加了 \u003ccode\u003efoo\u003c/code\u003e 和 \u003ccode\u003ebar\u003c/code\u003e 两个键的值：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u0026gt; MULTI\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eOK\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; INCR foo\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eQUEUED\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; INCR bar\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eQUEUED\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; EXEC\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"number\"\u003e1\u003c/span\u003e) (integer) \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"number\"\u003e2\u003c/span\u003e) (integer) \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"EXEC\"\u003e\u003ca href=\"#EXEC\" class=\"headerlink\" title=\"EXEC\"\u003e\u003c/a\u003eEXEC\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/exec\"\u003e\u003ccode\u003eEXEC\u003c/code\u003e\u003c/a\u003e 命令负责触发并执行事务中的所有命令。\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果客户端在使用 \u003ccode\u003eMULTI\u003c/code\u003e 开启了一个事务之后，却因为断线而没有成功执行 \u003ccode\u003eEXEC\u003c/code\u003e ，那么事务中的所有命令都不会被执行。\u003c/li\u003e\n\u003cli\u003e另一方面，如果客户端成功在开启事务之后执行 \u003ccode\u003eEXEC\u003c/code\u003e ，那么事务中的所有命令都会被执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eMULTI\u003c/code\u003e 和 \u003ccode\u003eEXEC\u003c/code\u003e 中的操作将会一次性发送给服务器，而不是一条一条发送，这种方式称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。\u003c/p\u003e\n\u003ch3 id=\"DISCARD\"\u003e\u003ca href=\"#DISCARD\" class=\"headerlink\" title=\"DISCARD\"\u003e\u003c/a\u003eDISCARD\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e当执行 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/discard\"\u003e\u003ccode\u003eDISCARD\u003c/code\u003e\u003c/a\u003e 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e示例：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u0026gt; SET foo \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eOK\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; MULTI\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eOK\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; INCR foo\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eQUEUED\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; DISCARD\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eOK\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; GET foo\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e\u0026#34;1\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"WATCH\"\u003e\u003ca href=\"#WATCH\" class=\"headerlink\" title=\"WATCH\"\u003e\u003c/a\u003eWATCH\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://redis.io/commands/watch\"\u003e\u003ccode\u003eWATCH\u003c/code\u003e\u003c/a\u003e 命令可以为 Redis 事务提供 check-and-set （CAS）行为。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e被 \u003ccode\u003eWATCH\u003c/code\u003e 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 \u003ccode\u003eEXEC\u003c/code\u003e 执行之前被修改了， 那么整个事务都会被取消， \u003ccode\u003eEXEC\u003c/code\u003e 返回 \u003ccode\u003enil-reply\u003c/code\u003e 来表示事务已经失败。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eWATCH mykey\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eval = GET mykey\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eval = val + \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMULTI\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eSET mykey $val\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eEXEC\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e使用上面的代码， 如果在 \u003ccode\u003eWATCH\u003c/code\u003e 执行之后， \u003ccode\u003eEXEC\u003c/code\u003e 执行之前， 有其他客户端修改了 \u003ccode\u003emykey\u003c/code\u003e 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。\u003c/p\u003e\n\u003cp\u003e这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eWATCH\u003c/code\u003e 使得 \u003ccode\u003eEXEC\u003c/code\u003e 命令需要有条件地执行：事务只能在所有被监视键都没有被修改的前提下执行，如果这个前提不能满足的话，事务就不会被执行。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eWATCH\u003c/code\u003e 命令可以被调用多次。对键的监视从 \u003ccode\u003eWATCH\u003c/code\u003e 执行之后开始生效，直到调用 \u003ccode\u003eEXEC\u003c/code\u003e 为止。\u003c/p\u003e\n\u003cp\u003e用户还可以在单个 \u003ccode\u003eWATCH\u003c/code\u003e 命令中监视任意多个键，例如：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eredis\u0026gt; WATCH key1 key2 key3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eOK\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"取消-WATCH-的场景\"\u003e\u003ca href=\"#取消-WATCH-的场景\" class=\"headerlink\" title=\"取消 WATCH 的场景\"\u003e\u003c/a\u003e取消 WATCH 的场景\u003c/h4\u003e\u003cp\u003e当 \u003ccode\u003eEXEC\u003c/code\u003e 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。\u003c/p\u003e\n\u003cp\u003e使用无参数的 \u003ccode\u003eUNWATCH\u003c/code\u003e 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 \u003ccode\u003eUNWATCH\u003c/code\u003e 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。\u003c/p\u003e\n\u003ch4 id=\"使用-WATCH-创建原子操作\"\u003e\u003ca href=\"#使用-WATCH-创建原子操作\" class=\"headerlink\" title=\"使用 WATCH 创建原子操作\"\u003e\u003c/a\u003e使用 WATCH 创建原子操作\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eWATCH\u003c/code\u003e 可以用于创建 Redis 没有内置的原子操作。\u003c/p\u003e\n\u003cp\u003e举个例子，以下代码实现了原创的 \u003ccode\u003eZPOP\u003c/code\u003e 命令，它可以原子地弹出有序集合中分值（\u003ccode\u003escore\u003c/code\u003e）最小的元素：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eWATCH zset\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eelement = ZRANGE zset \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMULTI\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eZREM zset element\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eEXEC\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://item.jd.com/11486101.html\"\u003e《Redis 设计与实现》\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-01-30T13:48:57Z",
  "Author": "钝悟 ◾ Dunwu"
}