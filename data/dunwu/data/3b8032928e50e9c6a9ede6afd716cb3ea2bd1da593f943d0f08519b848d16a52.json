{
  "Source": "dunwu",
  "Title": "Redis 脚本",
  "Link": "https://dunwu.github.io/blog/pages/30456b/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Redis-脚本\"\u003e\u003ca href=\"#Redis-脚本\" class=\"headerlink\" title=\"Redis 脚本\"\u003e\u003c/a\u003eRedis 脚本\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003eRedis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。\u003c/p\u003e\n\u003cp\u003e关键词：\u003ccode\u003eLua\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"为什么使用-Lua\"\u003e\u003ca href=\"#为什么使用-Lua\" class=\"headerlink\" title=\"为什么使用 Lua\"\u003e\u003c/a\u003e为什么使用 Lua\u003c/h2\u003e\u003cp\u003eLua 是一种轻量小巧的脚本语言，用标准 C 语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。\u003c/p\u003e\n\u003cp\u003e在 Redis 中，执行单一命令是原子性操作，所以不会出现并发问题。但有的业务场景下，需要执行多个命令，同时确保不出现并发问题，这就需要用到 Lua 脚本了。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRedis 执行 Lua 是原子操作\u003c/strong\u003e。因为 Redis 使用串行化的方式来执行 Redis 命令， 所以在任何特定时间里， 最多都只会有一个脚本能够被放进 Lua 环境里面运行， 因此， 整个 Redis 服务器只需要创建一个 Lua 环境即可。\u003c/p\u003e\n\u003cp\u003e由于，Redis 执行 Lua 具有原子性，所以常被用于需要原子性执行多命令的场景。\u003c/p\u003e\n\u003ch2 id=\"Redis-脚本命令\"\u003e\u003ca href=\"#Redis-脚本命令\" class=\"headerlink\" title=\"Redis 脚本命令\"\u003e\u003c/a\u003eRedis 脚本命令\u003c/h2\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e命令\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eEVAL\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eEVAL\u003c/code\u003e 命令为客户端输入的脚本在 Lua 环境中定义一个函数， 并通过调用这个函数来执行脚本。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eEVALSHA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eEVALSHA\u003c/code\u003e 命令通过直接调用 Lua 环境中已定义的函数来执行脚本。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_FLUSH\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_FLUSH\u003c/code\u003e 命令会清空服务器 \u003ccode\u003elua_scripts\u003c/code\u003e 字典中保存的脚本， 并重置 Lua 环境。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_EXISTS\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_EXISTS\u003c/code\u003e 命令接受一个或多个 SHA1 校验和为参数， 并通过检查 \u003ccode\u003elua_scripts\u003c/code\u003e 字典来确认校验和对应的脚本是否存在。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_LOAD\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_LOAD\u003c/code\u003e 命令接受一个 Lua 脚本为参数， 为该脚本在 Lua 环境中创建函数， 并将脚本保存到 \u003ccode\u003elua_scripts\u003c/code\u003e 字典中。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_KILL\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eSCRIPT_KILL\u003c/code\u003e 命令用于停止正在执行的脚本。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"Redis-执行-Lua-的工作流程\"\u003e\u003ca href=\"#Redis-执行-Lua-的工作流程\" class=\"headerlink\" title=\"Redis 执行 Lua 的工作流程\"\u003e\u003c/a\u003eRedis 执行 Lua 的工作流程\u003c/h2\u003e\u003cp\u003e为了在 Redis 服务器中执行 Lua 脚本， Redis 在服务器内嵌了一个 Lua 环境（environment）， 并对这个 Lua 环境进行了一系列修改， 从而确保这个 Lua 环境可以满足 Redis 服务器的需要。\u003c/p\u003e\n\u003cp\u003eRedis 服务器创建并修改 Lua 环境的整个过程由以下步骤组成：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建一个基础的 Lua 环境， 之后的所有修改都是针对这个环境进行的。\u003c/li\u003e\n\u003cli\u003e载入多个函数库到 Lua 环境里面， 让 Lua 脚本可以使用这些函数库来进行数据操作。\u003c/li\u003e\n\u003cli\u003e创建全局表格 \u003ccode\u003eredis\u003c/code\u003e ， 这个表格包含了对 Redis 进行操作的函数， 比如用于在 Lua 脚本中执行 Redis 命令的 \u003ccode\u003eredis.call\u003c/code\u003e 函数。\u003c/li\u003e\n\u003cli\u003e使用 Redis 自制的随机函数来替换 Lua 原有的带有副作用的随机函数， 从而避免在脚本中引入副作用。\u003c/li\u003e\n\u003cli\u003e创建排序辅助函数， Lua 环境使用这个辅佐函数来对一部分 Redis 命令的结果进行排序， 从而消除这些命令的不确定性。\u003c/li\u003e\n\u003cli\u003e创建 \u003ccode\u003eredis.pcall\u003c/code\u003e 函数的错误报告辅助函数， 这个函数可以提供更详细的出错信息。\u003c/li\u003e\n\u003cli\u003e对 Lua 环境里面的全局环境进行保护， 防止用户在执行 Lua 脚本的过程中， 将额外的全局变量添加到了 Lua 环境里面。\u003c/li\u003e\n\u003cli\u003e将完成修改的 Lua 环境保存到服务器状态的 \u003ccode\u003elua\u003c/code\u003e 属性里面， 等待执行服务器传来的 Lua 脚本。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"Redis-执行-Lua-的要点\"\u003e\u003ca href=\"#Redis-执行-Lua-的要点\" class=\"headerlink\" title=\"Redis 执行 Lua 的要点\"\u003e\u003c/a\u003eRedis 执行 Lua 的要点\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eRedis 服务器专门使用一个伪客户端来执行 Lua 脚本中包含的 Redis 命令。\u003c/li\u003e\n\u003cli\u003eRedis 使用脚本字典来保存所有被 \u003ccode\u003eEVAL\u003c/code\u003e 命令执行过， 或者被 \u003ccode\u003eSCRIPT_LOAD\u003c/code\u003e 命令载入过的 Lua 脚本， 这些脚本可以用于实现 \u003ccode\u003eSCRIPT_EXISTS\u003c/code\u003e 命令， 以及实现脚本复制功能。\u003c/li\u003e\n\u003cli\u003e服务器在执行脚本之前， 会为 Lua 环境设置一个超时处理钩子， 当脚本出现超时运行情况时， 客户端可以通过向服务器发送 \u003ccode\u003eSCRIPT_KILL\u003c/code\u003e 命令来让钩子停止正在执行的脚本， 或者发送 \u003ccode\u003eSHUTDOWN nosave\u003c/code\u003e 命令来让钩子关闭整个服务器。\u003c/li\u003e\n\u003cli\u003e主服务器复制 \u003ccode\u003eEVAL\u003c/code\u003e 、 \u003ccode\u003eSCRIPT_FLUSH\u003c/code\u003e 、 \u003ccode\u003eSCRIPT_LOAD\u003c/code\u003e 三个命令的方法和复制普通 Redis 命令一样 —— 只要将相同的命令传播给从服务器就可以了。\u003c/li\u003e\n\u003cli\u003e主服务器在复制 \u003ccode\u003eEVALSHA\u003c/code\u003e 命令时， 必须确保所有从服务器都已经载入了 \u003ccode\u003eEVALSHA\u003c/code\u003e 命令指定的 SHA1 校验和所对应的 Lua 脚本， 如果不能确保这一点的话， 主服务器会将 \u003ccode\u003eEVALSHA\u003c/code\u003e 命令转换成等效的 \u003ccode\u003eEVAL\u003c/code\u003e 命令， 并通过传播 \u003ccode\u003eEVAL\u003c/code\u003e 命令来获得相同的脚本执行效果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://item.jd.com/11486101.html\"\u003e《Redis 设计与实现》\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-01-30T13:48:57Z",
  "Author": "钝悟 ◾ Dunwu"
}