{
  "Source": "dunwu",
  "Title": "Flink 事件驱动",
  "Link": "https://dunwu.github.io/blog/pages/692bd7/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Flink-事件驱动\"\u003e\u003ca href=\"#Flink-事件驱动\" class=\"headerlink\" title=\"Flink 事件驱动\"\u003e\u003c/a\u003eFlink 事件驱动\u003c/h1\u003e\u003ch2 id=\"处理函数（Process-Functions）\"\u003e\u003ca href=\"#处理函数（Process-Functions）\" class=\"headerlink\" title=\"处理函数（Process Functions）\"\u003e\u003c/a\u003e处理函数（Process Functions）\u003c/h2\u003e\u003ch3 id=\"简介\"\u003e\u003ca href=\"#简介\" class=\"headerlink\" title=\"简介\"\u003e\u003c/a\u003e简介\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eProcessFunction\u003c/code\u003e 将事件处理与 Timer，State 结合在一起，使其成为流处理应用的强大构建模块。 这是使用 Flink 创建事件驱动应用程序的基础。它和 \u003ccode\u003eRichFlatMapFunction\u003c/code\u003e 十分相似， 但是增加了 Timer。\u003c/p\u003e\n\u003ch3 id=\"示例\"\u003e\u003ca href=\"#示例\" class=\"headerlink\" title=\"示例\"\u003e\u003c/a\u003e示例\u003c/h3\u003e\u003cp\u003e如果你已经体验了 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/learn-flink/streaming_analytics/\"\u003e流式分析训练\u003c/a\u003e 的\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/learn-flink/streaming_analytics/#hands-on\"\u003e动手实践\u003c/a\u003e， 你应该记得，它是采用 \u003ccode\u003eTumblingEventTimeWindow\u003c/code\u003e 来计算每个小时内每个司机的小费总和， 像下面的示例这样：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 计算每个司机每小时的小费总和\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDataStream\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; hourlyTips = fares\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .keyBy((TaxiFare fare) -\u0026gt; fare.driverId)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .window(TumblingEventTimeWindows.of(Time.hours(\u003cspan class=\"number\"\u003e1\u003c/span\u003e)))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .process(\u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAddTips\u003c/span\u003e());\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e使用 \u003ccode\u003eKeyedProcessFunction\u003c/code\u003e 去实现相同的操作更加直接且更有学习意义。 让我们开始用以下代码替换上面的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 计算每个司机每小时的小费总和\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDataStream\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; hourlyTips = fares\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .keyBy((TaxiFare fare) -\u0026gt; fare.driverId)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .process(\u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003ePseudoWindow\u003c/span\u003e(Time.hours(\u003cspan class=\"number\"\u003e1\u003c/span\u003e)));\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这个代码片段中，一个名为 \u003ccode\u003ePseudoWindow\u003c/code\u003e 的 \u003ccode\u003eKeyedProcessFunction\u003c/code\u003e 被应用于 KeyedStream， 其结果是一个 \u003ccode\u003eDataStream\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt;\u003c/code\u003e （与使用 Flink 内置时间窗口的实现生成的流相同）。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ePseudoWindow\u003c/code\u003e 的总体轮廓示意如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 在时长跨度为一小时的窗口中计算每个司机的小费总和。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 司机ID作为 key。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003ePseudoWindow\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"title class_\"\u003eKeyedProcessFunction\u003c/span\u003e\u0026lt;Long, TaxiFare, Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e durationMsec;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003ePseudoWindow\u003c/span\u003e\u003cspan class=\"params\"\u003e(Time duration)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.durationMsec = duration.toMilliseconds();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 在初始化期间调用一次。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eopen\u003c/span\u003e\u003cspan class=\"params\"\u003e(Configuration conf)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        . . .\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 每个票价事件（TaxiFare-Event）输入（到达）时调用，以处理输入的票价事件。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eprocessElement\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e            TaxiFare fare,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e            Context ctx,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e            Collector\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; out)\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e Exception {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        . . .\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 当当前水印（watermark）表明窗口现在需要完成的时候调用。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eonTimer\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003elong\u003c/span\u003e timestamp,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e            OnTimerContext context,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e            Collector\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; out)\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e Exception {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        . . .\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意事项：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有几种类型的 ProcessFunctions – 不仅包括 \u003ccode\u003eKeyedProcessFunction\u003c/code\u003e，还包括 \u003ccode\u003eCoProcessFunctions\u003c/code\u003e、\u003ccode\u003eBroadcastProcessFunctions\u003c/code\u003e 等.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eKeyedProcessFunction\u003c/code\u003e 是一种 \u003ccode\u003eRichFunction\u003c/code\u003e。作为 \u003ccode\u003eRichFunction\u003c/code\u003e，它可以访问使用 Managed Keyed State 所需的 \u003ccode\u003eopen\u003c/code\u003e 和 \u003ccode\u003egetRuntimeContext\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e有两个回调方法须要实现： \u003ccode\u003eprocessElement\u003c/code\u003e 和 \u003ccode\u003eonTimer\u003c/code\u003e。每个输入事件都会调用 \u003ccode\u003eprocessElement\u003c/code\u003e 方法； 当计时器触发时调用 \u003ccode\u003eonTimer\u003c/code\u003e。它们可以是基于事件时间（event time）的 timer，也可以是基于处理时间（processing time）的 timer。 除此之外，\u003ccode\u003eprocessElement\u003c/code\u003e 和 \u003ccode\u003eonTimer\u003c/code\u003e 都提供了一个上下文对象，该对象可用于与 \u003ccode\u003eTimerService\u003c/code\u003e 交互。 这两个回调还传递了一个可用于发出结果的 \u003ccode\u003eCollector\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"open-方法\"\u003e\u003ca href=\"#open-方法\" class=\"headerlink\" title=\"open() 方法\"\u003e\u003c/a\u003e\u003ccode\u003eopen()\u003c/code\u003e 方法\u003c/h4\u003e\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 每个窗口都持有托管的 Keyed state 的入口，并且根据窗口的结束时间执行 keyed 策略。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 每个司机都有一个单独的MapState对象。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003etransient\u003c/span\u003e MapState\u0026lt;Long, Float\u0026gt; sumOfTips;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eopen\u003c/span\u003e\u003cspan class=\"params\"\u003e(Configuration conf)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    MapStateDescriptor\u0026lt;Long, Float\u0026gt; sumDesc =\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eMapStateDescriptor\u003c/span\u003e\u0026lt;\u0026gt;(\u003cspan class=\"string\"\u003e\u0026#34;sumOfTips\u0026#34;\u003c/span\u003e, Long.class, Float.class);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    sumOfTips = getRuntimeContext().getMapState(sumDesc);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e由于票价事件（fare-event）可能会乱序到达，有时需要在计算输出前一个小时结果前，处理下一个小时的事件。 这样能够保证“乱序造成的延迟数据”得到正确处理（放到前一个小时中）。 实际上，如果 Watermark 延迟比窗口长度长得多，则可能有多个窗口同时打开，而不仅仅是两个。 此实现通过使用 \u003ccode\u003eMapState\u003c/code\u003e 来支持处理这一点，该 \u003ccode\u003eMapState\u003c/code\u003e 将每个窗口的结束时间戳映射到该窗口的小费总和。\u003c/p\u003e\n\u003ch4 id=\"processElement-方法\"\u003e\u003ca href=\"#processElement-方法\" class=\"headerlink\" title=\"processElement() 方法\"\u003e\u003c/a\u003e\u003ccode\u003eprocessElement()\u003c/code\u003e 方法\u003c/h4\u003e\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eprocessElement\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        TaxiFare fare,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        Context ctx,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        Collector\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; out)\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e Exception {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003elong\u003c/span\u003e \u003cspan class=\"variable\"\u003eeventTime\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e fare.getEventTime();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eTimerService\u003c/span\u003e \u003cspan class=\"variable\"\u003etimerService\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e ctx.timerService();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (eventTime \u0026lt;= timerService.currentWatermark()) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 事件延迟；其对应的窗口已经触发。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    } \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 将 eventTime 向上取值并将结果赋值到包含当前事件的窗口的末尾时间点。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003elong\u003c/span\u003e \u003cspan class=\"variable\"\u003eendOfWindow\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e (eventTime - (eventTime % durationMsec) + durationMsec - \u003cspan class=\"number\"\u003e1\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 在窗口完成时将启用回调\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        timerService.registerEventTimeTimer(endOfWindow);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 将此票价的小费添加到该窗口的总计中。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eFloat\u003c/span\u003e \u003cspan class=\"variable\"\u003esum\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e sumOfTips.get(endOfWindow);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (sum == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            sum = \u003cspan class=\"number\"\u003e0.0F\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        sum += fare.tip;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        sumOfTips.put(endOfWindow, sum);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e需要考虑的事项：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e延迟的事件怎么处理？watermark 后面的事件（即延迟的）正在被删除。 如果你想做一些比这更高级的操作，可以考虑使用旁路输出（Side outputs），这将在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/docs/learn-flink/event_driven/#side-outputs\"\u003e下一节\u003c/a\u003e中解释。\u003c/li\u003e\n\u003cli\u003e本例使用一个 \u003ccode\u003eMapState\u003c/code\u003e，其中 keys 是时间戳（timestamp），并为同一时间戳设置一个 Timer。 这是一种常见的模式；它使得在 Timer 触发时查找相关信息变得简单高效。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"onTimer-方法\"\u003e\u003ca href=\"#onTimer-方法\" class=\"headerlink\" title=\"onTimer() 方法\"\u003e\u003c/a\u003e\u003ccode\u003eonTimer()\u003c/code\u003e 方法\u003c/h4\u003e\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eonTimer\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        \u003cspan class=\"type\"\u003elong\u003c/span\u003e timestamp,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        OnTimerContext context,\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e        Collector\u0026lt;Tuple3\u0026lt;Long, Long, Float\u0026gt;\u0026gt; out)\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e Exception {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003elong\u003c/span\u003e \u003cspan class=\"variable\"\u003edriverId\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e context.getCurrentKey();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 查找刚结束的一小时结果。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eFloat\u003c/span\u003e \u003cspan class=\"variable\"\u003esumOfTips\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.sumOfTips.get(timestamp);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    Tuple3\u0026lt;Long, Long, Float\u0026gt; result = Tuple3.of(driverId, timestamp, sumOfTips);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    out.collect(result);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.sumOfTips.remove(timestamp);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e传递给 \u003ccode\u003eonTimer\u003c/code\u003e 的 \u003ccode\u003eOnTimerContext context\u003c/code\u003e 可用于确定当前 key。\u003c/li\u003e\n\u003cli\u003e我们的 pseudo-windows 在当前 Watermark 到达每小时结束时触发，此时调用 \u003ccode\u003eonTimer\u003c/code\u003e。 这个 \u003ccode\u003eonTimer\u003c/code\u003e 方法从 \u003ccode\u003esumOfTips\u003c/code\u003e 中删除相关的条目，这样做的效果是不可能容纳延迟的事件。 这相当于在使用 Flink 的时间窗口时将 allowedLateness 设置为零。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"性能考虑\"\u003e\u003ca href=\"#性能考虑\" class=\"headerlink\" title=\"性能考虑\"\u003e\u003c/a\u003e性能考虑\u003c/h3\u003e\u003cp\u003eFlink 提供了为 RocksDB 优化的 \u003ccode\u003eMapState\u003c/code\u003e 和 \u003ccode\u003eListState\u003c/code\u003e 类型。 相对于 \u003ccode\u003eValueState\u003c/code\u003e，更建议使用 \u003ccode\u003eMapState\u003c/code\u003e 和 \u003ccode\u003eListState\u003c/code\u003e，因为使用 RocksDBStateBackend 的情况下， \u003ccode\u003eMapState\u003c/code\u003e 和 \u003ccode\u003eListState\u003c/code\u003e 比 \u003ccode\u003eValueState\u003c/code\u003e 性能更好。 RocksDBStateBackend 可以附加到 \u003ccode\u003eListState\u003c/code\u003e，而无需进行（反）序列化， 对于 \u003ccode\u003eMapState\u003c/code\u003e，每个 key/value 都是一个单独的 RocksDB 对象，因此可以有效地访问和更新 \u003ccode\u003eMapState\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"旁路输出（Side-Outputs）\"\u003e\u003ca href=\"#旁路输出（Side-Outputs）\" class=\"headerlink\" title=\"旁路输出（Side Outputs）\"\u003e\u003c/a\u003e旁路输出（Side Outputs）\u003c/h2\u003e\u003ch3 id=\"简介-1\"\u003e\u003ca href=\"#简介-1\" class=\"headerlink\" title=\"简介\"\u003e\u003c/a\u003e简介\u003c/h3\u003e\u003cp\u003e有几个很好的理由希望从 Flink 算子获得多个输出流，如下报告条目：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异常情况（exceptions）\u003c/li\u003e\n\u003cli\u003e格式错误的事件（malformed events）\u003c/li\u003e\n\u003cli\u003e延迟的事件（late events）\u003c/li\u003e\n\u003cli\u003eoperator 告警（operational alerts），如与外部服务的连接超时\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e旁路输出（Side outputs）是一种方便的方法。除了错误报告之外，旁路输出也是实现流的 n 路分割的好方法。\u003c/p\u003e\n\u003ch3 id=\"示例-1\"\u003e\u003ca href=\"#示例-1\" class=\"headerlink\" title=\"示例\"\u003e\u003c/a\u003e示例\u003c/h3\u003e\u003cp\u003e现在你可以对上一节中忽略的延迟事件执行某些操作。\u003c/p\u003e\n\u003cp\u003eSide output channel 与 \u003ccode\u003eOutputTag\u0026lt;T\u0026gt;\u003c/code\u003e 相关联。这些标记拥有自己的名称，并与对应 DataStream 类型一致。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e OutputTag\u0026lt;TaxiFare\u0026gt; lateFares = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eOutputTag\u003c/span\u003e\u0026lt;TaxiFare\u0026gt;(\u003cspan class=\"string\"\u003e\u0026#34;lateFares\u0026#34;\u003c/span\u003e) {};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e上面显示的是一个静态 \u003ccode\u003eOutputTag\u0026lt;TaxiFare\u0026gt;\u003c/code\u003e ，当在 \u003ccode\u003ePseudoWindow\u003c/code\u003e 的 \u003ccode\u003eprocessElement\u003c/code\u003e 方法中发出延迟事件时，可以引用它：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (eventTime \u0026lt;= timerService.currentWatermark()) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 事件延迟，其对应的窗口已经触发。\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ctx.output(lateFares, fare);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e} \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    . . .\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e以及当在作业的 \u003ccode\u003emain\u003c/code\u003e 中从该旁路输出访问流时：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 计算每个司机每小时的小费总和\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eSingleOutputStreamOperator\u003c/span\u003e \u003cspan class=\"variable\"\u003ehourlyTips\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e fares\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .keyBy((TaxiFare fare) -\u0026gt; fare.driverId)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        .process(\u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003ePseudoWindow\u003c/span\u003e(Time.hours(\u003cspan class=\"number\"\u003e1\u003c/span\u003e)));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ehourlyTips.getSideOutput(lateFares).print();\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e或者，可以使用两个同名的 OutputTag 来引用同一个旁路输出，但如果这样做，它们必须具有相同的类型。\u003c/p\u003e\n\u003ch2 id=\"结语\"\u003e\u003ca href=\"#结语\" class=\"headerlink\" title=\"结语\"\u003e\u003c/a\u003e结语\u003c/h2\u003e\u003cp\u003e在本例中，你已经了解了如何使用 \u003ccode\u003eProcessFunction\u003c/code\u003e 重新实现一个简单的时间窗口。 当然，如果 Flink 内置的窗口 API 能够满足你的开发需求，那么一定要优先使用它。 但如果你发现自己在考虑用 Flink 的窗口做些错综复杂的事情，不要害怕自己动手。\u003c/p\u003e\n\u003cp\u003e此外，\u003ccode\u003eProcessFunctions\u003c/code\u003e 对于计算分析之外的许多其他用例也很有用。 下面的实践练习提供了一个完全不同的例子。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eProcessFunctions\u003c/code\u003e 的另一个常见用例是清理过时 State。如果你回想一下 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/apache/flink-training/blob/release-1.14//rides-and-fares\"\u003eRides and Fares Exercise \u003c/a\u003e， 其中使用 \u003ccode\u003eRichCoFlatMapFunction\u003c/code\u003e 来计算简单 Join，那么示例方案假设 TaxiRides 和 TaxiFares 两个事件是严格匹配为一个有效 数据对（必须同时出现）并且每一组这样的有效数据对都和一个唯一的 \u003ccode\u003erideId\u003c/code\u003e 严格对应。如果数据对中的某个 TaxiRides 事件（TaxiFares 事件） 丢失，则同一 \u003ccode\u003erideId\u003c/code\u003e 对应的另一个出现的 TaxiFares 事件（TaxiRides 事件）对应的 State 则永远不会被清理掉。 所以这里可以使用 \u003ccode\u003eKeyedCoProcessFunction\u003c/code\u003e 的实现代替它（\u003ccode\u003eRichCoFlatMapFunction\u003c/code\u003e），并且可以使用计时器来检测和清除任何过时 的 State。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://nightlies.apache.org/flink/flink-docs-release-1.14/zh/\"\u003eFlink 官方文档\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-02-17T14:28:55Z",
  "Author": "钝悟 ◾ Dunwu"
}