{
  "Source": "dunwu",
  "Title": "跳表",
  "Link": "https://dunwu.github.io/blog/pages/42aedd/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"跳表\"\u003e\u003ca href=\"#跳表\" class=\"headerlink\" title=\"跳表\"\u003e\u003c/a\u003e跳表\u003c/h1\u003e\u003ch2 id=\"什么是跳表\"\u003e\u003ca href=\"#什么是跳表\" class=\"headerlink\" title=\"什么是跳表\"\u003e\u003c/a\u003e什么是跳表\u003c/h2\u003e\u003cp\u003e对于一个有序数组，可以使用高效的二分查找法，其时间复杂度为 \u003ccode\u003eO(log n)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e但是，即使是有序的链表，也只能使用低效的顺序查找，其时间复杂度为 \u003ccode\u003eO(n)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323113532.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e如何提高链表的查找效率呢？\u003c/p\u003e\n\u003cp\u003e我们可以对链表加一层索引。具体来说，可以每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作\u003cstrong\u003e索引\u003c/strong\u003e或\u003cstrong\u003e索引层\u003c/strong\u003e。索引节点中通过一个 down 指针，指向下一级结点。通过这样的改造，就可以支持类似二分查找的算法。我们把改造之后的数据结构叫作\u003cstrong\u003e跳表\u003c/strong\u003e（Skip list）。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155309.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e随着数据的不断增长，一级索引层也变得越来越长。此时，我们可以为一级索引再增加一层索引层：二级索引层。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155346.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e随着数据的膨胀，当二级索引层也变得很长时，我们可以继续为其添加新的索引层。\u003cstrong\u003e这种链表加多级索引的结构，就是跳表\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323114408.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"跳表的时间复杂度\"\u003e\u003ca href=\"#跳表的时间复杂度\" class=\"headerlink\" title=\"跳表的时间复杂度\"\u003e\u003c/a\u003e跳表的时间复杂度\u003c/h3\u003e\u003cp\u003e在一个具有多级索引的跳表中，第一级索引的结点个数大约就是 \u003ccode\u003en/2\u003c/code\u003e，第二级索引的结点个数大约就是 \u003ccode\u003en/4\u003c/code\u003e，第三级索引的结点个数大约就是 \u003ccode\u003en/8\u003c/code\u003e，依次类推，也就是说，第 \u003ccode\u003ek\u003c/code\u003e 级索引的结点个数是第 \u003ccode\u003ek-1\u003c/code\u003e 级索引的结点个数的 \u003ccode\u003e1/2\u003c/code\u003e，那第 k 级索引结点的个数就是 \u003ccode\u003en/(2k)\u003c/code\u003e。所以**跳表查询数据的时间复杂度就是 \u003ccode\u003eO(logn)\u003c/code\u003e**。\u003c/p\u003e\n\u003ch3 id=\"跳表的空间复杂度\"\u003e\u003ca href=\"#跳表的空间复杂度\" class=\"headerlink\" title=\"跳表的空间复杂度\"\u003e\u003c/a\u003e跳表的空间复杂度\u003c/h3\u003e\u003cp\u003e比起单纯的单链表，跳表需要存储多级索引，肯定要消耗更多的存储空间。\u003c/p\u003e\n\u003cp\u003e假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。\u003c/p\u003e\n\u003cfigure class=\"highlight excel\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e索引节点数 = \u003cspan class=\"built_in\"\u003en\u003c/span\u003e/\u003cspan class=\"number\"\u003e2\u003c/span\u003e + \u003cspan class=\"built_in\"\u003en\u003c/span\u003e/\u003cspan class=\"number\"\u003e4\u003c/span\u003e + \u003cspan class=\"built_in\"\u003en\u003c/span\u003e/\u003cspan class=\"number\"\u003e8\u003c/span\u003e … + \u003cspan class=\"number\"\u003e8\u003c/span\u003e + \u003cspan class=\"number\"\u003e4\u003c/span\u003e + \u003cspan class=\"number\"\u003e2\u003c/span\u003e = \u003cspan class=\"built_in\"\u003en\u003c/span\u003e-\u003cspan class=\"number\"\u003e2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e所以，跳表的空间复杂度是 \u003ccode\u003eO(n)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e跳表的存储空间其实还有压缩空间。比如，我们增加索引节点的范围，由“每两个节点抽一个上级索引节点”改为“每五个节点抽一个上级索引节点”，可以显著节省存储空间。\u003c/p\u003e\n\u003cp\u003e实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。\u003c/p\u003e\n\u003ch2 id=\"跳表的操作\"\u003e\u003ca href=\"#跳表的操作\" class=\"headerlink\" title=\"跳表的操作\"\u003e\u003c/a\u003e跳表的操作\u003c/h2\u003e\u003cp\u003e跳表是一种各方面性能都比较优秀的\u003cstrong\u003e动态数据结构\u003c/strong\u003e，可以支持快速的插入、删除、查找操作，写起来也不复杂，甚至可以替代\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91\"\u003e红黑树\u003c/a\u003e（Red-black tree）。\u003c/p\u003e\n\u003ch3 id=\"高效的动态插入和删除\"\u003e\u003ca href=\"#高效的动态插入和删除\" class=\"headerlink\" title=\"高效的动态插入和删除\"\u003e\u003c/a\u003e高效的动态插入和删除\u003c/h3\u003e\u003cp\u003e跳表不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 \u003ccode\u003eO(logn)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323155933.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e插入操作\u003c/strong\u003e：对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的的时间复杂度是 \u003ccode\u003eO(log n)\u003c/code\u003e，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 \u003ccode\u003eO(log n)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e删除操作\u003c/strong\u003e：如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"跳表索引动态更新\"\u003e\u003ca href=\"#跳表索引动态更新\" class=\"headerlink\" title=\"跳表索引动态更新\"\u003e\u003c/a\u003e跳表索引动态更新\u003c/h3\u003e\u003cp\u003e当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20220323161942.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e如红黑树、AVL 树这样的平衡二叉树，是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过随机函数来维护前面提到的“平衡性”。\u003c/p\u003e\n\u003cp\u003e当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？可以通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。\u003c/p\u003e\n\u003ch2 id=\"为什么需要跳表\"\u003e\u003ca href=\"#为什么需要跳表\" class=\"headerlink\" title=\"为什么需要跳表\"\u003e\u003c/a\u003e为什么需要跳表\u003c/h2\u003e\u003cp\u003e跳表是一种动态数据结构，支持快速的插入、删除、查找操作，时间复杂度都是 \u003ccode\u003eO(logn)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e跳表的空间复杂度是 \u003ccode\u003eO(n)\u003c/code\u003e。不过，跳表的实现非常灵活，可以通过改变索引构建策略，有效平衡执行效率和内存消耗。虽然跳表的代码实现并不简单，但是作为一种动态数据结构，比起红黑树来说，实现要简单多了。所以很多时候，我们为了代码的简单、易读，比起红黑树，我们更倾向用跳表。\u003c/p\u003e\n\u003ch2 id=\"跳表的应用场景\"\u003e\u003ca href=\"#跳表的应用场景\" class=\"headerlink\" title=\"跳表的应用场景\"\u003e\u003c/a\u003e跳表的应用场景\u003c/h2\u003e\u003cp\u003e经典实现：Redis 的 Sorted Set、JDK 的 \u003ccode\u003eConcurrentSkipListMap\u003c/code\u003e 和 \u003ccode\u003eConcurrentSkipListSet\u003c/code\u003e 都是基于跳表实现。\u003c/p\u003e\n\u003cp\u003e为什么 Redis 要用跳表来实现有序集合，而不是红黑树？\u003c/p\u003e\n\u003cp\u003eRedis 中的有序集合支持的核心操作主要有下面这几个：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e插入一个数据；\u003c/li\u003e\n\u003cli\u003e删除一个数据；\u003c/li\u003e\n\u003cli\u003e查找一个数据；\u003c/li\u003e\n\u003cli\u003e按照区间查找数据（比如查找值在 [100, 356] 之间的数据）；\u003c/li\u003e\n\u003cli\u003e迭代输出有序序列。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100017301\"\u003e数据结构与算法之美\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-10-23T01:21:13Z",
  "Author": "钝悟 ◾ Dunwu"
}