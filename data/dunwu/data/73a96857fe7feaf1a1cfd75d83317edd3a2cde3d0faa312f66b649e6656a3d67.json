{
  "Source": "dunwu",
  "Title": "Java 容器之 Set",
  "Link": "https://dunwu.github.io/blog/pages/794c6b/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Java-容器之-Set\"\u003e\u003ca href=\"#Java-容器之-Set\" class=\"headerlink\" title=\"Java 容器之 Set\"\u003e\u003c/a\u003eJava 容器之 Set\u003c/h1\u003e\u003ch2 id=\"Set-简介\"\u003e\u003ca href=\"#Set-简介\" class=\"headerlink\" title=\"Set 简介\"\u003e\u003c/a\u003eSet 简介\u003c/h2\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/Set-diagrams.png\" width=\"400\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003eSet 家族成员简介：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eSet\u003c/code\u003e 继承了 \u003ccode\u003eCollection\u003c/code\u003e 的接口。实际上 \u003ccode\u003eSet\u003c/code\u003e 就是 \u003ccode\u003eCollection\u003c/code\u003e，只是行为略有不同：\u003ccode\u003eSet\u003c/code\u003e 集合不允许有重复元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSortedSet\u003c/code\u003e 继承了 \u003ccode\u003eSet\u003c/code\u003e 的接口。\u003ccode\u003eSortedSet\u003c/code\u003e 中的内容是排序的唯一值，排序的方法是通过比较器(Comparator)。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eNavigableSet\u003c/code\u003e 继承了 \u003ccode\u003eSortedSet\u003c/code\u003e 的接口。它提供了丰富的查找方法：如”获取大于/等于某值的元素”、“获取小于/等于某值的元素”等等。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAbstractSet\u003c/code\u003e 是一个抽象类，它继承于 \u003ccode\u003eAbstractCollection\u003c/code\u003e，\u003ccode\u003eAbstractCollection\u003c/code\u003e 实现了 Set 中的绝大部分方法，为实现 \u003ccode\u003eSet\u003c/code\u003e 的实例类提供了便利。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 类依赖于 \u003ccode\u003eHashMap\u003c/code\u003e，它实际上是通过 \u003ccode\u003eHashMap\u003c/code\u003e 实现的。\u003ccode\u003eHashSet\u003c/code\u003e 中的元素是无序的、散列的。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 类依赖于 \u003ccode\u003eTreeMap\u003c/code\u003e，它实际上是通过 \u003ccode\u003eTreeMap\u003c/code\u003e 实现的。\u003ccode\u003eTreeSet\u003c/code\u003e 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 Set。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 是按插入顺序排序的 Set。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 是只能存放 Emum 枚举类型的 Set。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Set-接口\"\u003e\u003ca href=\"#Set-接口\" class=\"headerlink\" title=\"Set 接口\"\u003e\u003c/a\u003eSet 接口\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eSet\u003c/code\u003e 继承了 \u003ccode\u003eCollection\u003c/code\u003e 的接口。实际上，\u003ccode\u003eSet\u003c/code\u003e 就是 \u003ccode\u003eCollection\u003c/code\u003e，二者提供的方法完全相同。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSet\u003c/code\u003e 接口定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSet\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCollection\u003c/span\u003e\u0026lt;E\u0026gt; {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"SortedSet-接口\"\u003e\u003ca href=\"#SortedSet-接口\" class=\"headerlink\" title=\"SortedSet 接口\"\u003e\u003c/a\u003eSortedSet 接口\u003c/h3\u003e\u003cp\u003e继承了 \u003ccode\u003eSet\u003c/code\u003e 的接口。\u003ccode\u003eSortedSet\u003c/code\u003e 中的内容是排序的唯一值，排序的方法是通过比较器(Comparator)。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSortedSet\u003c/code\u003e 接口定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSortedSet\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSet\u003c/span\u003e\u0026lt;E\u0026gt; {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eSortedSet\u003c/code\u003e 接口新扩展的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecomparator\u003c/code\u003e - 返回 Comparator\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esubSet\u003c/code\u003e - 返回指定区间的子集\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheadSet\u003c/code\u003e - 返回小于指定元素的子集\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etailSet\u003c/code\u003e - 返回大于指定元素的子集\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efirst\u003c/code\u003e - 返回第一个元素\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elast\u003c/code\u003e - 返回最后一个元素\u003c/li\u003e\n\u003cli\u003espliterator\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"NavigableSet-接口\"\u003e\u003ca href=\"#NavigableSet-接口\" class=\"headerlink\" title=\"NavigableSet 接口\"\u003e\u003c/a\u003eNavigableSet 接口\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eNavigableSet\u003c/code\u003e 继承了 \u003ccode\u003eSortedSet\u003c/code\u003e。它提供了丰富的查找方法。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eNavigableSet\u003c/code\u003e 接口定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"title class_\"\u003eNavigableSet\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSortedSet\u003c/span\u003e\u0026lt;E\u0026gt; {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eNavigableSet\u003c/code\u003e 接口新扩展的方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elower - 返回小于指定值的元素中最接近的元素\u003c/li\u003e\n\u003cli\u003ehigher - 返回大于指定值的元素中最接近的元素\u003c/li\u003e\n\u003cli\u003efloor - 返回小于或等于指定值的元素中最接近的元素\u003c/li\u003e\n\u003cli\u003eceiling - 返回大于或等于指定值的元素中最接近的元素\u003c/li\u003e\n\u003cli\u003epollFirst - 检索并移除第一个（最小的）元素\u003c/li\u003e\n\u003cli\u003epollLast - 检索并移除最后一个（最大的）元素\u003c/li\u003e\n\u003cli\u003edescendingSet - 返回反序排列的 Set\u003c/li\u003e\n\u003cli\u003edescendingIterator - 返回反序排列的 Set 的迭代器\u003c/li\u003e\n\u003cli\u003esubSet - 返回指定区间的子集\u003c/li\u003e\n\u003cli\u003eheadSet - 返回小于指定元素的子集\u003c/li\u003e\n\u003cli\u003etailSet - 返回大于指定元素的子集\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"AbstractSet-抽象类\"\u003e\u003ca href=\"#AbstractSet-抽象类\" class=\"headerlink\" title=\"AbstractSet 抽象类\"\u003e\u003c/a\u003eAbstractSet 抽象类\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eAbstractSet\u003c/code\u003e 类提供 \u003ccode\u003eSet\u003c/code\u003e 接口的核心实现，以最大限度地减少实现 \u003ccode\u003eSet\u003c/code\u003e 接口所需的工作。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eAbstractSet\u003c/code\u003e 抽象类定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAbstractSet\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAbstractCollection\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSet\u003c/span\u003e\u0026lt;E\u0026gt; {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事实上，主要的实现已经在 \u003ccode\u003eAbstractCollection\u003c/code\u003e 中完成。\u003c/p\u003e\n\u003ch2 id=\"HashSet-类\"\u003e\u003ca href=\"#HashSet-类\" class=\"headerlink\" title=\"HashSet 类\"\u003e\u003c/a\u003eHashSet 类\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eHashSet\u003c/code\u003e 类依赖于 \u003ccode\u003eHashMap\u003c/code\u003e，它实际上是通过 \u003ccode\u003eHashMap\u003c/code\u003e 实现的。\u003ccode\u003eHashSet\u003c/code\u003e 中的元素是无序的、散列的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eHashSet\u003c/code\u003e 类定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eHashSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAbstractSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSet\u003c/span\u003e\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"HashSet-要点\"\u003e\u003ca href=\"#HashSet-要点\" class=\"headerlink\" title=\"HashSet 要点\"\u003e\u003c/a\u003eHashSet 要点\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 通过继承 \u003ccode\u003eAbstractSet\u003c/code\u003e 实现了 \u003ccode\u003eSet\u003c/code\u003e 接口中的骨干方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 实现了 \u003ccode\u003eCloneable\u003c/code\u003e，所以支持克隆。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 实现了 \u003ccode\u003eSerializable\u003c/code\u003e，所以支持序列化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 中存储的元素是无序的。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 允许 null 值的元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 不是线程安全的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"HashSet-原理\"\u003e\u003ca href=\"#HashSet-原理\" class=\"headerlink\" title=\"HashSet 原理\"\u003e\u003c/a\u003eHashSet 原理\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eHashSet\u003c/code\u003e 是基于 \u003ccode\u003eHashMap\u003c/code\u003e 实现的。\u003c/strong\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// HashSet 的核心，通过维护一个 HashMap 实体来实现 HashSet 方法\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003etransient\u003c/span\u003e HashMap\u0026lt;E,Object\u0026gt; map;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eObject\u003c/span\u003e \u003cspan class=\"variable\"\u003ePRESENT\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eObject\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 中维护了一个 \u003ccode\u003eHashMap\u003c/code\u003e 对象 map，\u003ccode\u003eHashSet\u003c/code\u003e 的重要方法，如 \u003ccode\u003eadd\u003c/code\u003e、\u003ccode\u003eremove\u003c/code\u003e、\u003ccode\u003eiterator\u003c/code\u003e、\u003ccode\u003eclear\u003c/code\u003e、\u003ccode\u003esize\u003c/code\u003e 等都是围绕 map 实现的。\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eHashSet\u003c/code\u003e 类中通过定义 \u003ccode\u003ewriteObject()\u003c/code\u003e 和 \u003ccode\u003ereadObject()\u003c/code\u003e 方法确定了其序列化和反序列化的机制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ePRESENT 是用于关联 map 中当前操作元素的一个虚拟值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"TreeSet-类\"\u003e\u003ca href=\"#TreeSet-类\" class=\"headerlink\" title=\"TreeSet 类\"\u003e\u003c/a\u003eTreeSet 类\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 类依赖于 \u003ccode\u003eTreeMap\u003c/code\u003e，它实际上是通过 \u003ccode\u003eTreeMap\u003c/code\u003e 实现的。\u003ccode\u003eTreeSet\u003c/code\u003e 中的元素是有序的，它是按自然排序或者用户指定比较器排序的 Set。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 类定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eTreeSet\u003c/span\u003e\u0026lt;E\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAbstractSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eNavigableSet\u003c/span\u003e\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"TreeSet-要点\"\u003e\u003ca href=\"#TreeSet-要点\" class=\"headerlink\" title=\"TreeSet 要点\"\u003e\u003c/a\u003eTreeSet 要点\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 通过继承 \u003ccode\u003eAbstractSet\u003c/code\u003e 实现了 \u003ccode\u003eNavigableSet\u003c/code\u003e 接口中的骨干方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 实现了 \u003ccode\u003eCloneable\u003c/code\u003e，所以支持克隆。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 实现了 \u003ccode\u003eSerializable\u003c/code\u003e，所以支持序列化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 中存储的元素是有序的。排序规则是自然顺序或比较器（\u003ccode\u003eComparator\u003c/code\u003e）中提供的顺序规则。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 不是线程安全的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"TreeSet-源码\"\u003e\u003ca href=\"#TreeSet-源码\" class=\"headerlink\" title=\"TreeSet 源码\"\u003e\u003c/a\u003eTreeSet 源码\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eTreeSet 是基于 TreeMap 实现的。\u003c/strong\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// TreeSet 的核心，通过维护一个 NavigableMap 实体来实现 TreeSet 方法\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003etransient\u003c/span\u003e NavigableMap\u0026lt;E,Object\u0026gt; m;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// PRESENT 是用于关联 map 中当前操作元素的一个虚拟值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eObject\u003c/span\u003e \u003cspan class=\"variable\"\u003ePRESENT\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eObject\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eTreeSet\u003c/code\u003e 中维护了一个 \u003ccode\u003eNavigableMap\u003c/code\u003e 对象 map（实际上是一个 TreeMap 实例），\u003ccode\u003eTreeSet\u003c/code\u003e 的重要方法，如 \u003ccode\u003eadd\u003c/code\u003e、\u003ccode\u003eremove\u003c/code\u003e、\u003ccode\u003eiterator\u003c/code\u003e、\u003ccode\u003eclear\u003c/code\u003e、\u003ccode\u003esize\u003c/code\u003e 等都是围绕 map 实现的。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ePRESENT\u003c/code\u003e 是用于关联 \u003ccode\u003emap\u003c/code\u003e 中当前操作元素的一个虚拟值。\u003ccode\u003eTreeSet\u003c/code\u003e 中的元素都被当成 \u003ccode\u003eTreeMap\u003c/code\u003e 的 key 存储，而 value 都填的是 \u003ccode\u003ePRESENT\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"LinkedHashSet-类\"\u003e\u003ca href=\"#LinkedHashSet-类\" class=\"headerlink\" title=\"LinkedHashSet 类\"\u003e\u003c/a\u003eLinkedHashSet 类\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 是按插入顺序排序的 Set。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 类定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eLinkedHashSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eHashSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSet\u003c/span\u003e\u0026lt;E\u0026gt;, Cloneable, java.io.Serializable {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"LinkedHashSet-要点\"\u003e\u003ca href=\"#LinkedHashSet-要点\" class=\"headerlink\" title=\"LinkedHashSet 要点\"\u003e\u003c/a\u003eLinkedHashSet 要点\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 通过继承 \u003ccode\u003eHashSet\u003c/code\u003e 实现了 \u003ccode\u003eSet\u003c/code\u003e 接口中的骨干方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 实现了 \u003ccode\u003eCloneable\u003c/code\u003e，所以支持克隆。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 实现了 \u003ccode\u003eSerializable\u003c/code\u003e，所以支持序列化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 中存储的元素是按照插入顺序保存的。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 不是线程安全的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"LinkedHashSet-原理\"\u003e\u003ca href=\"#LinkedHashSet-原理\" class=\"headerlink\" title=\"LinkedHashSet 原理\"\u003e\u003c/a\u003eLinkedHashSet 原理\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eLinkedHashSet\u003c/code\u003e 有三个构造方法，无一例外，都是调用父类 \u003ccode\u003eHashSet\u003c/code\u003e 的构造方法。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003eLinkedHashSet\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e initialCapacity, \u003cspan class=\"type\"\u003efloat\u003c/span\u003e loadFactor)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003esuper\u003c/span\u003e(initialCapacity, loadFactor, \u003cspan class=\"literal\"\u003etrue\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003eLinkedHashSet\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e initialCapacity)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003esuper\u003c/span\u003e(initialCapacity, \u003cspan class=\"number\"\u003e.75f\u003c/span\u003e, \u003cspan class=\"literal\"\u003etrue\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003eLinkedHashSet\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003esuper\u003c/span\u003e(\u003cspan class=\"number\"\u003e16\u003c/span\u003e, \u003cspan class=\"number\"\u003e.75f\u003c/span\u003e, \u003cspan class=\"literal\"\u003etrue\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e需要强调的是：\u003cstrong\u003eLinkedHashSet 构造方法实际上调用的是父类 HashSet 的非 public 构造方法。\u003c/strong\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eHashSet(\u003cspan class=\"type\"\u003eint\u003c/span\u003e initialCapacity, \u003cspan class=\"type\"\u003efloat\u003c/span\u003e loadFactor, \u003cspan class=\"type\"\u003eboolean\u003c/span\u003e dummy) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    map = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eLinkedHashMap\u003c/span\u003e\u0026lt;\u0026gt;(initialCapacity, loadFactor);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不同于 \u003ccode\u003eHashSet\u003c/code\u003e \u003ccode\u003epublic\u003c/code\u003e 构造方法中初始化的 \u003ccode\u003eHashMap\u003c/code\u003e 实例，这个构造方法中，初始化了 \u003ccode\u003eLinkedHashMap\u003c/code\u003e 实例。\u003c/p\u003e\n\u003cp\u003e也就是说，实际上，\u003ccode\u003eLinkedHashSet\u003c/code\u003e 维护了一个双链表。由双链表的特性可以知道，它是按照元素的插入顺序保存的。所以，这就是 \u003ccode\u003eLinkedHashSet\u003c/code\u003e 中存储的元素是按照插入顺序保存的原理。\u003c/p\u003e\n\u003ch2 id=\"EnumSet-类\"\u003e\u003ca href=\"#EnumSet-类\" class=\"headerlink\" title=\"EnumSet 类\"\u003e\u003c/a\u003eEnumSet 类\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 类定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eabstract\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eEnumSet\u003c/span\u003e\u0026lt;E \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eEnum\u003c/span\u003e\u0026lt;E\u0026gt;\u0026gt; \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eAbstractSet\u003c/span\u003e\u0026lt;E\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCloneable\u003c/span\u003e, java.io.Serializable {}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"EnumSet-要点\"\u003e\u003ca href=\"#EnumSet-要点\" class=\"headerlink\" title=\"EnumSet 要点\"\u003e\u003c/a\u003eEnumSet 要点\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 继承了 \u003ccode\u003eAbstractSet\u003c/code\u003e，所以有 \u003ccode\u003eSet\u003c/code\u003e 接口中的骨干方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 实现了 \u003ccode\u003eCloneable\u003c/code\u003e，所以支持克隆。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 实现了 \u003ccode\u003eSerializable\u003c/code\u003e，所以支持序列化。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 通过 \u003ccode\u003e\u0026lt;E extends Enum\u0026lt;E\u0026gt;\u0026gt;\u003c/code\u003e 限定了存储元素必须是枚举值。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 没有构造方法，只能通过类中的 \u003ccode\u003estatic\u003c/code\u003e 方法来创建 \u003ccode\u003eEnumSet\u003c/code\u003e 对象。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 是有序的。以枚举值在 \u003ccode\u003eEnumSet\u003c/code\u003e 类中的定义顺序来决定集合元素的顺序。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eEnumSet\u003c/code\u003e 不是线程安全的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"要点总结\"\u003e\u003ca href=\"#要点总结\" class=\"headerlink\" title=\"要点总结\"\u003e\u003c/a\u003e要点总结\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200221190717.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://item.jd.com/10058164.html\"\u003eJava 编程思想（Thinking in java）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-12-29T13:49:58Z",
  "Author": "钝悟 ◾ Dunwu"
}