{
  "Source": "dunwu",
  "Title": "Java 容器之 Stream",
  "Link": "https://dunwu.github.io/blog/pages/529fad/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Java-容器之-Stream\"\u003e\u003ca href=\"#Java-容器之-Stream\" class=\"headerlink\" title=\"Java 容器之 Stream\"\u003e\u003c/a\u003eJava 容器之 Stream\u003c/h1\u003e\u003ch2 id=\"Stream-简介\"\u003e\u003ca href=\"#Stream-简介\" class=\"headerlink\" title=\"Stream 简介\"\u003e\u003c/a\u003eStream 简介\u003c/h2\u003e\u003cp\u003e在 Java8 中，\u003ccode\u003eCollection\u003c/code\u003e 新增了两个流方法，分别是 \u003ccode\u003estream()\u003c/code\u003e 和 \u003ccode\u003eparallelStream()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStream\u003c/code\u003e 相当于高级版的 \u003ccode\u003eIterator\u003c/code\u003e，他可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。\u003c/p\u003e\n\u003ch2 id=\"Stream-操作分类\"\u003e\u003ca href=\"#Stream-操作分类\" class=\"headerlink\" title=\"Stream 操作分类\"\u003e\u003c/a\u003eStream 操作分类\u003c/h2\u003e\u003cp\u003e官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。\u003c/p\u003e\n\u003cp\u003e中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。\u003c/p\u003e\n\u003cp\u003e终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。\u003c/p\u003e\n\u003ch2 id=\"Stream-源码实现\"\u003e\u003ca href=\"#Stream-源码实现\" class=\"headerlink\" title=\"Stream 源码实现\"\u003e\u003c/a\u003eStream 源码实现\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201205174140.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBaseStream\u003c/code\u003e 和 \u003ccode\u003eStream\u003c/code\u003e 是最顶层的接口类。\u003ccode\u003eBaseStream\u003c/code\u003e 主要定义了流的基本接口方法，例如，spliterator、isParallel 等；\u003ccode\u003eStream\u003c/code\u003e 则定义了一些流的常用操作方法，例如，map、filter 等。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSink\u003c/code\u003e 接口是定义每个 \u003ccode\u003eStream\u003c/code\u003e 操作之间关系的协议，他包含 \u003ccode\u003ebegin()\u003c/code\u003e、\u003ccode\u003eend()\u003c/code\u003e、\u003ccode\u003ecancellationRequested()\u003c/code\u003e、\u003ccode\u003eaccpt()\u003c/code\u003e 四个方法。\u003ccode\u003eReferencePipeline\u003c/code\u003e 最终会将整个 \u003ccode\u003eStream\u003c/code\u003e 流操作组装成一个调用链，而这条调用链上的各个 \u003ccode\u003eStream\u003c/code\u003e 操作的上下关系就是通过 \u003ccode\u003eSink\u003c/code\u003e 接口协议来定义实现的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eReferencePipeline\u003c/code\u003e 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 \u003ccode\u003eHead\u003c/code\u003e、\u003ccode\u003eStatelessOp\u003c/code\u003e、\u003ccode\u003eStatefulOp\u003c/code\u003e 三个内部类，实现了 \u003ccode\u003eBaseStream\u003c/code\u003e 与 \u003ccode\u003eStream\u003c/code\u003e 的接口方法。Head 类主要用来定义数据源操作，在初次调用 names.stream() 方法时，会加载 Head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作 StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表；当我们调用终结操作时，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。\u003c/p\u003e\n\u003ch2 id=\"Stream-并行处理\"\u003e\u003ca href=\"#Stream-并行处理\" class=\"headerlink\" title=\"Stream 并行处理\"\u003e\u003c/a\u003eStream 并行处理\u003c/h2\u003e\u003cp\u003eStream 处理数据的方式有两种，串行处理和并行处理。\u003c/p\u003e\n\u003ch2 id=\"4-参考资料\"\u003e\u003ca href=\"#4-参考资料\" class=\"headerlink\" title=\"4. 参考资料\"\u003e\u003c/a\u003e4. 参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://item.jd.com/10058164.html\"\u003eJava 编程思想（第 4 版）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-12-05T10:30:22Z",
  "Author": "钝悟 ◾ Dunwu"
}