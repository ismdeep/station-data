{
  "Source": "dunwu",
  "Title": "Java 进程内缓存",
  "Link": "https://dunwu.github.io/blog/pages/59f078/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Java-进程内缓存\"\u003e\u003ca href=\"#Java-进程内缓存\" class=\"headerlink\" title=\"Java 进程内缓存\"\u003e\u003c/a\u003eJava 进程内缓存\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003e关键词：ConcurrentHashMap、LRUHashMap、Guava Cache、Caffeine、Ehcache\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"一、ConcurrentHashMap\"\u003e\u003ca href=\"#一、ConcurrentHashMap\" class=\"headerlink\" title=\"一、ConcurrentHashMap\"\u003e\u003c/a\u003e一、ConcurrentHashMap\u003c/h2\u003e\u003cp\u003e最简单的进程内缓存可以通过 JDK 自带的 \u003ccode\u003eHashMap\u003c/code\u003e 或 \u003ccode\u003eConcurrentHashMap\u003c/code\u003e 实现。\u003c/p\u003e\n\u003cp\u003e适用场景：\u003cstrong\u003e不需要淘汰的缓存数据\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e缺点：无法进行缓存淘汰，内存会无限制的增长。\u003c/p\u003e\n\u003ch2 id=\"二、LRUHashMap\"\u003e\u003ca href=\"#二、LRUHashMap\" class=\"headerlink\" title=\"二、LRUHashMap\"\u003e\u003c/a\u003e二、LRUHashMap\u003c/h2\u003e\u003cp\u003e可以通过**继承 \u003ccode\u003eLinkedHashMap\u003c/code\u003e 来实现一个简单的 \u003ccode\u003eLRUHashMap\u003c/code\u003e**，即可完成一个简单的 \u003cstrong\u003eLRU （最近最少使用）\u003c/strong\u003e算法。\u003c/p\u003e\n\u003cp\u003e缺点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e锁竞争严重，性能比较低。\u003c/li\u003e\n\u003cli\u003e不支持过期时间\u003c/li\u003e\n\u003cli\u003e不支持自动刷新\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e【示例】LRUHashMap 的简单实现\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e41\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e42\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e43\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e44\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e45\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e46\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e47\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eLRUCache\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eLinkedHashMap\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e max;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e Object lock;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"title function_\"\u003eLRUCache\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e max)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e//无需扩容\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003esuper\u003c/span\u003e((\u003cspan class=\"type\"\u003eint\u003c/span\u003e) (max * \u003cspan class=\"number\"\u003e1.4f\u003c/span\u003e), \u003cspan class=\"number\"\u003e0.75f\u003c/span\u003e, \u003cspan class=\"literal\"\u003etrue\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.max = max;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.lock = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eObject\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e/**\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e     * 重写LinkedHashMap的removeEldestEntry方法即可 在Put的时候判断，如果为true，就会删除最老的\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e     *\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e     * \u003cspan class=\"doctag\"\u003e@param\u003c/span\u003e eldest\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e     * \u003cspan class=\"doctag\"\u003e@return\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e     */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"title function_\"\u003eremoveEldestEntry\u003c/span\u003e\u003cspan class=\"params\"\u003e(Map.Entry eldest)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e size() \u0026gt; max;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e Object \u003cspan class=\"title function_\"\u003egetValue\u003c/span\u003e\u003cspan class=\"params\"\u003e(Object key)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (lock) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e get(key);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eputValue\u003c/span\u003e\u003cspan class=\"params\"\u003e(Object key, Object value)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (lock) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            put(key, value);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"title function_\"\u003eremoveValue\u003c/span\u003e\u003cspan class=\"params\"\u003e(Object key)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (lock) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e remove(key) != \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"title function_\"\u003eremoveAll\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        clear();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003etrue\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"三、Guava-Cache\"\u003e\u003ca href=\"#三、Guava-Cache\" class=\"headerlink\" title=\"三、Guava Cache\"\u003e\u003c/a\u003e三、Guava Cache\u003c/h2\u003e\u003cp\u003eGuava Cache 解决了 \u003ccode\u003eLRUHashMap\u003c/code\u003e 中的几个缺点。\u003c/p\u003e\n\u003cp\u003eGuava Cache 提供了\u003cstrong\u003e基于容量，时间和引用的缓存回收方式\u003c/strong\u003e。基于容量的方式内部实现采用 LRU 算法，基于引用回收很好的利用了 Java 虚拟机的垃圾回收机制。\u003c/p\u003e\n\u003cp\u003e其中的缓存构造器 CacheBuilder 采用构建者模式提供了设置好各种参数的缓存对象。缓存核心类 LocalCache 里面的内部类 Segment 与 jdk1.7 及以前的 \u003ccode\u003eConcurrentHashMap\u003c/code\u003e 非常相似，分段加锁，减少锁竞争，并且都继承于 \u003ccode\u003eReetrantLock\u003c/code\u003e，还有六个队列，以实现丰富的本地缓存方案。Guava Cache 对于过期的 Entry 并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。\u003c/p\u003e\n\u003cp\u003e直接通过查询，判断其是否满足刷新条件，进行刷新。\u003c/p\u003e\n\u003ch3 id=\"Guava-Cache-缓存回收\"\u003e\u003ca href=\"#Guava-Cache-缓存回收\" class=\"headerlink\" title=\"Guava Cache 缓存回收\"\u003e\u003c/a\u003eGuava Cache 缓存回收\u003c/h3\u003e\u003cp\u003eGuava Cache 提供了三种基本的缓存回收方式。\u003c/p\u003e\n\u003ch3 id=\"基于容量回收\"\u003e\u003ca href=\"#基于容量回收\" class=\"headerlink\" title=\"基于容量回收\"\u003e\u003c/a\u003e基于容量回收\u003c/h3\u003e\u003cp\u003e\u003ccode\u003emaximumSize(long)\u003c/code\u003e：当缓存中的元素数量超过指定值时触发回收。\u003c/p\u003e\n\u003ch3 id=\"基于定时回收\"\u003e\u003ca href=\"#基于定时回收\" class=\"headerlink\" title=\"基于定时回收\"\u003e\u003c/a\u003e基于定时回收\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexpireAfterAccess(long, TimeUnit)\u003c/code\u003e：缓存项在给定时间内没有被读/写访问，则回收。请注意这种缓存的回收顺序和基于大小回收一样。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eexpireAfterWrite(long, TimeUnit)\u003c/code\u003e：缓存项在给定时间内没有被写访问（创建或覆盖），则回收。如果认为缓存数据总是在固定时候后变得陈旧不可用，这种回收方式是可取的。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如下文所讨论，定时回收周期性地在写操作中执行，偶尔在读操作中执行。\u003c/p\u003e\n\u003ch3 id=\"基于引用回收\"\u003e\u003ca href=\"#基于引用回收\" class=\"headerlink\" title=\"基于引用回收\"\u003e\u003c/a\u003e基于引用回收\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eCacheBuilder.weakKeys()\u003c/code\u003e：使用弱引用存储键。当键没有其它（强或软）引用时，缓存项可以被垃圾回收。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCacheBuilder.weakValues()\u003c/code\u003e：使用弱引用存储值。当值没有其它（强或软）引用时，缓存项可以被垃圾回收。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCacheBuilder.softValues()\u003c/code\u003e：使用软引用存储值。软引用只有在响应内存需要时，才按照全局最近最少使用的顺序回收。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Guava-Cache-核心-API\"\u003e\u003ca href=\"#Guava-Cache-核心-API\" class=\"headerlink\" title=\"Guava Cache 核心 API\"\u003e\u003c/a\u003eGuava Cache 核心 API\u003c/h3\u003e\u003ch4 id=\"CacheBuilder\"\u003e\u003ca href=\"#CacheBuilder\" class=\"headerlink\" title=\"CacheBuilder\"\u003e\u003c/a\u003eCacheBuilder\u003c/h4\u003e\u003cp\u003e缓存构建器。构建缓存的入口，指定缓存配置参数并初始化本地缓存。\u003cbr/\u003e主要采用 builder 的模式，CacheBuilder 的每一个方法都返回这个 CacheBuilder 知道 build 方法的调用。\u003cbr/\u003e注意 build 方法有重载，带有参数的为构建一个具有数据加载功能的缓存，不带参数的构建一个没有数据加载功能的缓存。\u003c/p\u003e\n\u003ch4 id=\"LocalManualCache\"\u003e\u003ca href=\"#LocalManualCache\" class=\"headerlink\" title=\"LocalManualCache\"\u003e\u003c/a\u003eLocalManualCache\u003c/h4\u003e\u003cp\u003e作为 LocalCache 的一个内部类，在构造方法里面会把 LocalCache 类型的变量传入，并且调用方法时都直接或者间接调用 LocalCache 里面的方法。\u003c/p\u003e\n\u003ch4 id=\"LocalLoadingCache\"\u003e\u003ca href=\"#LocalLoadingCache\" class=\"headerlink\" title=\"LocalLoadingCache\"\u003e\u003c/a\u003eLocalLoadingCache\u003c/h4\u003e\u003cp\u003e可以看到该类继承了 LocalManualCache 并实现接口 LoadingCache。\u003cbr/\u003e覆盖了 get，getUnchecked 等方法。\u003c/p\u003e\n\u003ch4 id=\"LocalCache\"\u003e\u003ca href=\"#LocalCache\" class=\"headerlink\" title=\"LocalCache\"\u003e\u003c/a\u003eLocalCache\u003c/h4\u003e\u003cp\u003eGuava Cache 中的核心类，重点了解。\u003c/p\u003e\n\u003cp\u003eLocalCache 的数据结构与 ConcurrentHashMap 很相似，都由多个 segment 组成，且各 segment 相对独立，互不影响，所以能支持并行操作。每个 segment 由一个 table 和若干队列组成。缓存数据存储在 table 中，其类型为 AtomicReferenceArray。\u003c/p\u003e\n\u003ch2 id=\"四、Caffeine\"\u003e\u003ca href=\"#四、Caffeine\" class=\"headerlink\" title=\"四、Caffeine\"\u003e\u003c/a\u003e四、Caffeine\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/ben-manes/caffeine\"\u003ecaffeine\u003c/a\u003e 是一个使用 JDK8 改进 Guava 缓存的高性能缓存库。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eCaffeine 实现了 W-TinyLFU(\u003cstrong\u003eLFU\u003c/strong\u003e + \u003cstrong\u003eLRU\u003c/strong\u003e 算法的变种)，其\u003cstrong\u003e命中率和读写吞吐量大大优于 Guava Cache\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e其实现原理较复杂，可以参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5b7593496fb9a009b62904fa#comment\"\u003e你应该知道的缓存进化史\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"五、Ehcache\"\u003e\u003ca href=\"#五、Ehcache\" class=\"headerlink\" title=\"五、Ehcache\"\u003e\u003c/a\u003e五、Ehcache\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003e参考：\u003ca href=\"04.Ehcache.md\"\u003eEhcache\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"六、进程内缓存对比\"\u003e\u003ca href=\"#六、进程内缓存对比\" class=\"headerlink\" title=\"六、进程内缓存对比\"\u003e\u003c/a\u003e六、进程内缓存对比\u003c/h2\u003e\u003cp\u003e常用进程内缓存技术对比：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e比较项\u003c/th\u003e\n\u003cth\u003eConcurrentHashMap\u003c/th\u003e\n\u003cth\u003eLRUMap\u003c/th\u003e\n\u003cth\u003eEhcache\u003c/th\u003e\n\u003cth\u003eGuava Cache\u003c/th\u003e\n\u003cth\u003eCaffeine\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e读写性能\u003c/td\u003e\n\u003ctd\u003e很好，分段锁\u003c/td\u003e\n\u003ctd\u003e一般，全局加锁\u003c/td\u003e\n\u003ctd\u003e好\u003c/td\u003e\n\u003ctd\u003e好，需要做淘汰操作\u003c/td\u003e\n\u003ctd\u003e很好\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e淘汰算法\u003c/td\u003e\n\u003ctd\u003e无\u003c/td\u003e\n\u003ctd\u003eLRU，一般\u003c/td\u003e\n\u003ctd\u003e支持多种淘汰算法,LRU,LFU,FIFO\u003c/td\u003e\n\u003ctd\u003eLRU，一般\u003c/td\u003e\n\u003ctd\u003eW-TinyLFU, 很好\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e功能丰富程度\u003c/td\u003e\n\u003ctd\u003e功能比较简单\u003c/td\u003e\n\u003ctd\u003e功能比较单一\u003c/td\u003e\n\u003ctd\u003e功能很丰富\u003c/td\u003e\n\u003ctd\u003e功能很丰富，支持刷新和虚引用等\u003c/td\u003e\n\u003ctd\u003e功能和 Guava Cache 类似\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e工具大小\u003c/td\u003e\n\u003ctd\u003ejdk 自带类，很小\u003c/td\u003e\n\u003ctd\u003e基于 LinkedHashMap，较小\u003c/td\u003e\n\u003ctd\u003e很大，最新版本 1.4MB\u003c/td\u003e\n\u003ctd\u003e是 Guava 工具类中的一个小部分，较小\u003c/td\u003e\n\u003ctd\u003e一般，最新版本 644KB\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否持久化\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e是否支持集群\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e是\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003ctd\u003e否\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eConcurrentHashMap\u003c/code\u003e\u003c/strong\u003e - 比较适合缓存比较固定不变的元素，且缓存的数量较小的。虽然从上面表格中比起来有点逊色，但是其由于是 JDK 自带的类，在各种框架中依然有大量的使用，比如我们可以用来缓存我们反射的 Method，Field 等等；也可以缓存一些链接，防止其重复建立。在 Caffeine 中也是使用的 \u003ccode\u003eConcurrentHashMap\u003c/code\u003e 来存储元素。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eLRUMap\u003c/code\u003e\u003c/strong\u003e - 如果不想引入第三方包，又想使用淘汰算法淘汰数据，可以使用这个。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eEhcache\u003c/code\u003e\u003c/strong\u003e - 由于其 jar 包很大，较重量级。对于需要持久化和集群的一些功能的，可以选择 Ehcache。需要注意的是，虽然 Ehcache 也支持分布式缓存，但是由于其节点间通信方式为 rmi，表现不如 Redis，所以一般不建议用它来作为分布式缓存。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eGuava Cache\u003c/code\u003e\u003c/strong\u003e - Guava 这个 jar 包在很多 Java 应用程序中都有大量的引入，所以很多时候其实是直接用就好了，并且其本身是轻量级的而且功能较为丰富，在不了解 Caffeine 的情况下可以选择 Guava Cache。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eCaffeine\u003c/code\u003e\u003c/strong\u003e - 其在命中率，读写性能上都比 Guava Cache 好很多，并且其 API 和 Guava cache 基本一致，甚至会多一点。在真实环境中使用 Caffeine，取得过不错的效果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总结一下：**如果不需要淘汰算法则选择 \u003ccode\u003eConcurrentHashMap\u003c/code\u003e，如果需要淘汰算法和一些丰富的 API，推荐选择 \u003ccode\u003eCaffeine\u003c/code\u003e**。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/ben-manes/caffeine\"\u003ecaffeine github\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5b8df63c6fb9a019e04ebaf4\"\u003e深入解密来自未来的缓存-Caffeine\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.jianshu.com/p/9a80c662dac4\"\u003eCaffeine 缓存\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://wizardforcel.gitbooks.io/guava-tutorial/content/1.html\"\u003eGoogle Guava 官方教程（中文版）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.jianshu.com/p/38bd5f1cf2f2\"\u003eGoogle Guava Cache 全解析\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.ibm.com/zh/articles/os-cn-spring-cache/\"\u003e注释驱动的 Spring cache 缓存介绍\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-02-17T14:34:30Z",
  "Author": "钝悟 ◾ Dunwu"
}