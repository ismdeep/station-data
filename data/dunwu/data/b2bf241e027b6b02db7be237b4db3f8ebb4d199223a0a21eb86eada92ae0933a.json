{
  "Source": "dunwu",
  "Title": "Tomcat 快速入门",
  "Link": "https://dunwu.github.io/blog/pages/4a4c02/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Tomcat-快速入门\"\u003e\u003ca href=\"#Tomcat-快速入门\" class=\"headerlink\" title=\"Tomcat 快速入门\"\u003e\u003c/a\u003eTomcat 快速入门\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003e🎁 版本说明\u003c/p\u003e\n\u003cp\u003e当前最新版本：Tomcat 8.5.24\u003c/p\u003e\n\u003cp\u003e环境要求：JDK7+\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"1-Tomcat-简介\"\u003e\u003ca href=\"#1-Tomcat-简介\" class=\"headerlink\" title=\"1. Tomcat 简介\"\u003e\u003c/a\u003e1. Tomcat 简介\u003c/h2\u003e\u003ch3 id=\"1-1-Tomcat-是什么\"\u003e\u003ca href=\"#1-1-Tomcat-是什么\" class=\"headerlink\" title=\"1.1. Tomcat 是什么\"\u003e\u003c/a\u003e1.1. Tomcat 是什么\u003c/h3\u003e\u003cp\u003eTomcat 是由 Apache 开发的一个 Servlet 容器，实现了对 Servlet 和 JSP 的支持，并提供了作为 Web 服务器的一些特有功能，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。\u003c/p\u003e\n\u003cp\u003e由于 Tomcat 本身也内含了一个 HTTP 服务器，它也可以被视作一个单独的 Web 服务器。但是，不能将 Tomcat 和 Apache HTTP 服务器混淆，Apache HTTP 服务器是一个用 C 语言实现的 HTTP Web 服务器；这两个 HTTP web server 不是捆绑在一起的。Tomcat 包含了一个配置管理工具，也可以通过编辑 XML 格式的配置文件来进行配置。\u003c/p\u003e\n\u003ch3 id=\"1-2-Tomcat-重要目录\"\u003e\u003ca href=\"#1-2-Tomcat-重要目录\" class=\"headerlink\" title=\"1.2. Tomcat 重要目录\"\u003e\u003c/a\u003e1.2. Tomcat 重要目录\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e/bin\u003c/strong\u003e - Tomcat 脚本存放目录（如启动、关闭脚本）。 \u003ccode\u003e*.sh\u003c/code\u003e 文件用于 Unix 系统； \u003ccode\u003e*.bat\u003c/code\u003e 文件用于 Windows 系统。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e/conf\u003c/strong\u003e - Tomcat 配置文件目录。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e/logs\u003c/strong\u003e - Tomcat 默认日志目录。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e/webapps\u003c/strong\u003e - webapp 运行的目录。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"1-3-web-工程发布目录结构\"\u003e\u003ca href=\"#1-3-web-工程发布目录结构\" class=\"headerlink\" title=\"1.3. web 工程发布目录结构\"\u003e\u003c/a\u003e1.3. web 工程发布目录结构\u003c/h3\u003e\u003cp\u003e一般 web 项目路径结构\u003c/p\u003e\n\u003cfigure class=\"highlight gherkin\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e|\u003cspan class=\"string\"\u003e-- webapp                         # 站点根目录\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- META-INF                   # META-INF 目录\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   `-- MANIFEST.MF            # 配置清单文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- WEB-INF                    # WEB-INF 目录\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- classes                # class文件目录\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- *.class            # 程序需要的 class 文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e   `-- *.xml              # 程序需要的 xml 文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- lib                    # 库文件夹\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   \u003c/span\u003e|\u003cspan class=\"string\"\u003e   `-- *.jar              # 程序需要的 jar 包\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e   `-- web.xml                # Web应用程序的部署描述文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- \u0026lt;userdir\u0026gt;                  # 自定义的目录\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u003c/span\u003e|\u003cspan class=\"string\"\u003e-- \u0026lt;userfiles\u0026gt;                # 自定义的资源文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003ewebapp\u003c/code\u003e：工程发布文件夹。其实每个 war 包都可以视为 webapp 的压缩包。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eMETA-INF\u003c/code\u003e：META-INF 目录用于存放工程自身相关的一些信息，元文件信息，通常由开发工具，环境自动生成。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003eWEB-INF\u003c/code\u003e：Java web 应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e/WEB-INF/classes\u003c/code\u003e：存放程序所需要的所有 Java class 文件。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e/WEB-INF/lib\u003c/code\u003e：存放程序所需要的所有 jar 文件。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003ccode\u003e/WEB-INF/web.xml\u003c/code\u003e：web 应用的部署配置文件。它是工程中最重要的配置文件，它描述了 servlet 和组成应用的其它组件，以及应用初始化参数、安全管理约束等。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"1-4-Tomcat-功能\"\u003e\u003ca href=\"#1-4-Tomcat-功能\" class=\"headerlink\" title=\"1.4. Tomcat 功能\"\u003e\u003c/a\u003e1.4. Tomcat 功能\u003c/h3\u003e\u003cp\u003eTomcat 支持的 I/O 模型有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNIO：非阻塞 I/O，采用 Java NIO 类库实现。\u003c/li\u003e\n\u003cli\u003eNIO2：异步 I/O，采用 JDK 7 最新的 NIO2 类库实现。\u003c/li\u003e\n\u003cli\u003eAPR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTomcat 支持的应用层协议有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP/1.1：这是大部分 Web 应用采用的访问协议。\u003c/li\u003e\n\u003cli\u003eAJP：用于和 Web 服务器集成（如 Apache）。\u003c/li\u003e\n\u003cli\u003eHTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2-Tomcat-入门\"\u003e\u003ca href=\"#2-Tomcat-入门\" class=\"headerlink\" title=\"2. Tomcat 入门\"\u003e\u003c/a\u003e2. Tomcat 入门\u003c/h2\u003e\u003ch3 id=\"2-1-安装\"\u003e\u003ca href=\"#2-1-安装\" class=\"headerlink\" title=\"2.1. 安装\"\u003e\u003c/a\u003e2.1. 安装\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e前提条件\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eTomcat 8.5 要求 JDK 版本为 1.7 以上。\u003c/p\u003e\n\u003cp\u003e进入 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://tomcat.apache.org/download-80.cgi\"\u003eTomcat 官方下载地址\u003c/a\u003e 选择合适版本下载，并解压到本地。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eWindows\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e添加环境变量 \u003ccode\u003eCATALINA_HOME\u003c/code\u003e ，值为 Tomcat 的安装路径。\u003c/p\u003e\n\u003cp\u003e进入安装目录下的 bin 目录，运行 startup.bat 文件，启动 Tomcat\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLinux / Unix\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e下面的示例以 8.5.24 版本为例，包含了下载、解压、启动操作。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 下载解压到本地\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ewget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etar -zxf apache-tomcat-8.5.24.tar.gz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 启动 Tomcat\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e./apache-tomcat-8.5.24/bin/startup.sh\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e启动后，访问 \u003ccode\u003ehttp://localhost:8080\u003c/code\u003e ，可以看到 Tomcat 安装成功的测试页面。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"2-2-配置\"\u003e\u003ca href=\"#2-2-配置\" class=\"headerlink\" title=\"2.2. 配置\"\u003e\u003c/a\u003e2.2. 配置\u003c/h3\u003e\u003cp\u003e本节将列举一些重要、常见的配置项。详细的 Tomcat8 配置可以参考 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://tomcat.apache.org/tomcat-8.5-doc/config/index.html\"\u003eTomcat 8 配置官方参考文档\u003c/a\u003e 。\u003c/p\u003e\n\u003ch4 id=\"2-2-1-Server\"\u003e\u003ca href=\"#2-2-1-Server\" class=\"headerlink\" title=\"2.2.1. Server\"\u003e\u003c/a\u003e2.2.1. Server\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eServer 元素表示整个 Catalina servlet 容器。\u003c/p\u003e\n\u003cp\u003e因此，它必须是 \u003ccode\u003econf/server.xml\u003c/code\u003e 配置文件中的根元素。它的属性代表了整个 servlet 容器的特性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eclassName\u003c/td\u003e\n\u003ctd\u003e这个类必须实现 org.apache.catalina.Server 接口。\u003c/td\u003e\n\u003ctd\u003e默认 org.apache.catalina.core.StandardServer\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eaddress\u003c/td\u003e\n\u003ctd\u003e服务器等待关机命令的 TCP / IP 地址。如果没有指定地址，则使用 localhost。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eport\u003c/td\u003e\n\u003ctd\u003e服务器等待关机命令的 TCP / IP 端口号。设置为-1 以禁用关闭端口。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eshutdown\u003c/td\u003e\n\u003ctd\u003e必须通过 TCP / IP 连接接收到指定端口号的命令字符串，以关闭 Tomcat。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"2-2-2-Service\"\u003e\u003ca href=\"#2-2-2-Service\" class=\"headerlink\" title=\"2.2.2. Service\"\u003e\u003c/a\u003e2.2.2. Service\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eService 元素表示一个或多个连接器组件的组合，这些组件共享一个用于处理传入请求的引擎组件。Server 中可以有多个 Service。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eclassName\u003c/td\u003e\n\u003ctd\u003e这个类必须实现\u003ccode\u003eorg.apache.catalina.Service\u003c/code\u003e接口。\u003c/td\u003e\n\u003ctd\u003e默认 \u003ccode\u003eorg.apache.catalina.core.StandardService\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ename\u003c/td\u003e\n\u003ctd\u003e此服务的显示名称，如果您使用标准 Catalina 组件，将包含在日志消息中。与特定服务器关联的每个服务的名称必须是唯一的。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e\u003cstrong\u003e实例 - \u003ccode\u003econf/server.xml\u003c/code\u003e 配置文件示例\u003c/strong\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e\u0026lt;?xml version=\u003cspan class=\"string\"\u003e\u0026#34;1.0\u0026#34;\u003c/span\u003e encoding=\u003cspan class=\"string\"\u003e\u0026#34;UTF-8\u0026#34;\u003c/span\u003e?\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eServer\u003c/span\u003e \u003cspan class=\"attr\"\u003eport\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;8080\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eshutdown\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;SHUTDOWN\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eService\u003c/span\u003e \u003cspan class=\"attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;xxx\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eService\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eServer\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"2-2-3-Executor\"\u003e\u003ca href=\"#2-2-3-Executor\" class=\"headerlink\" title=\"2.2.3. Executor\"\u003e\u003c/a\u003e2.2.3. Executor\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eExecutor 表示可以在 Tomcat 中的组件之间共享的线程池。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eclassName\u003c/td\u003e\n\u003ctd\u003e这个类必须实现\u003ccode\u003eorg.apache.catalina.Executor\u003c/code\u003e接口。\u003c/td\u003e\n\u003ctd\u003e默认 \u003ccode\u003eorg.apache.catalina.core.StandardThreadExecutor\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ename\u003c/td\u003e\n\u003ctd\u003e线程池名称。\u003c/td\u003e\n\u003ctd\u003e要求唯一, 供 Connector 元素的 executor 属性使用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003enamePrefix\u003c/td\u003e\n\u003ctd\u003e线程名称前缀。\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emaxThreads\u003c/td\u003e\n\u003ctd\u003e最大活跃线程数。\u003c/td\u003e\n\u003ctd\u003e默认 200\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eminSpareThreads\u003c/td\u003e\n\u003ctd\u003e最小活跃线程数。\u003c/td\u003e\n\u003ctd\u003e默认 25\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emaxIdleTime\u003c/td\u003e\n\u003ctd\u003e当前活跃线程大于 minSpareThreads 时,空闲线程关闭的等待最大时间。\u003c/td\u003e\n\u003ctd\u003e默认 60000ms\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emaxQueueSize\u003c/td\u003e\n\u003ctd\u003e线程池满情况下的请求排队大小。\u003c/td\u003e\n\u003ctd\u003e默认 Integer.MAX_VALUE\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eService\u003c/span\u003e \u003cspan class=\"attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;xxx\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eExecutor\u003c/span\u003e \u003cspan class=\"attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;tomcatThreadPool\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003enamePrefix\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;catalina-exec-\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003emaxThreads\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;300\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eminSpareThreads\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;25\u0026#34;\u003c/span\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eService\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"2-2-4-Connector\"\u003e\u003ca href=\"#2-2-4-Connector\" class=\"headerlink\" title=\"2.2.4. Connector\"\u003e\u003c/a\u003e2.2.4. Connector\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eConnector 代表连接组件。Tomcat 支持三种协议：HTTP/1.1、HTTP/2.0、AJP。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003easyncTimeout\u003c/td\u003e\n\u003ctd\u003eServlet3.0 规范中的异步请求超时\u003c/td\u003e\n\u003ctd\u003e默认 30s\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eport\u003c/td\u003e\n\u003ctd\u003e请求连接的 TCP Port\u003c/td\u003e\n\u003ctd\u003e设置为 0,则会随机选取一个未占用的端口号\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eprotocol\u003c/td\u003e\n\u003ctd\u003e协议. 一般情况下设置为 HTTP/1.1,这种情况下连接模型会在 NIO 和 APR/native 中自动根据配置选择\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eURIEncoding\u003c/td\u003e\n\u003ctd\u003e对 URI 的编码方式.\u003c/td\u003e\n\u003ctd\u003e如果设置系统变量 org.apache.catalina.STRICT_SERVLET_COMPLIANCE 为 true,使用 ISO-8859-1 编码;如果未设置此系统变量且未设置此属性, 使用 UTF-8 编码\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003euseBodyEncodingForURI\u003c/td\u003e\n\u003ctd\u003e是否采用指定的 contentType 而不是 URIEncoding 来编码 URI 中的请求参数\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e以下属性在标准的 Connector(NIO, NIO2 和 APR/native)中有效:\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eacceptCount\u003c/td\u003e\n\u003ctd\u003e当最大请求连接 maxConnections 满时的最大排队大小\u003c/td\u003e\n\u003ctd\u003e默认 100,注意此属性和 Executor 中属性 maxQueueSize 的区别.这个指的是请求连接满时的堆栈大小,Executor 的 maxQueueSize 指的是处理线程满时的堆栈大小\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003econnectionTimeout\u003c/td\u003e\n\u003ctd\u003e请求连接超时\u003c/td\u003e\n\u003ctd\u003e默认 60000ms\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eexecutor\u003c/td\u003e\n\u003ctd\u003e指定配置的线程池名称\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ekeepAliveTimeout\u003c/td\u003e\n\u003ctd\u003ekeeAlive 超时时间\u003c/td\u003e\n\u003ctd\u003e默认值为 connectionTimeout 配置值.-1 表示不超时\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emaxConnections\u003c/td\u003e\n\u003ctd\u003e最大连接数\u003c/td\u003e\n\u003ctd\u003e连接满时后续连接放入最大为 acceptCount 的队列中. 对 NIO 和 NIO2 连接,默认值为 10000;对 APR/native,默认值为 8192\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003emaxThreads\u003c/td\u003e\n\u003ctd\u003e如果指定了 Executor, 此属性忽略;否则为 Connector 创建的内部线程池最大值\u003c/td\u003e\n\u003ctd\u003e默认 200\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eminSpareThreads\u003c/td\u003e\n\u003ctd\u003e如果指定了 Executor, 此属性忽略;否则为 Connector 创建线程池的最小活跃线程数\u003c/td\u003e\n\u003ctd\u003e默认 10\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eprocessorCache\u003c/td\u003e\n\u003ctd\u003e协议处理器缓存 Processor 对象的大小\u003c/td\u003e\n\u003ctd\u003e-1 表示不限制.当不使用 servlet3.0 的异步处理情况下: 如果配置 Executor,配置为 Executor 的 maxThreads;否则配置为 Connnector 的 maxThreads. 如果使用 Serlvet3.0 异步处理, 取 maxThreads 和 maxConnections 的最大值\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"2-2-5-Context\"\u003e\u003ca href=\"#2-2-5-Context\" class=\"headerlink\" title=\"2.2.5. Context\"\u003e\u003c/a\u003e2.2.5. Context\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eContext 元素表示一个 Web 应用程序，它在特定的虚拟主机中运行。每个 Web 应用程序都基于 Web 应用程序存档（WAR）文件，或者包含相应的解包内容的相应目录，如 Servlet 规范中所述。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ealtDDName\u003c/td\u003e\n\u003ctd\u003eweb.xml 部署描述符路径\u003c/td\u003e\n\u003ctd\u003e默认 /WEB-INF/web.xml\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003edocBase\u003c/td\u003e\n\u003ctd\u003eContext 的 Root 路径\u003c/td\u003e\n\u003ctd\u003e和 Host 的 appBase 相结合, 可确定 web 应用的实际目录\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003efailCtxIfServletStartFails\u003c/td\u003e\n\u003ctd\u003e同 Host 中的 failCtxIfServletStartFails, 只对当前 Context 有效\u003c/td\u003e\n\u003ctd\u003e默认为 false\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003elogEffectiveWebXml\u003c/td\u003e\n\u003ctd\u003e是否日志打印 web.xml 内容(web.xml 由默认的 web.xml 和应用中的 web.xml 组成)\u003c/td\u003e\n\u003ctd\u003e默认为 false\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003epath\u003c/td\u003e\n\u003ctd\u003eweb 应用的 context path\u003c/td\u003e\n\u003ctd\u003e如果为根路径,则配置为空字符串(“”), 不能不配置\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eprivileged\u003c/td\u003e\n\u003ctd\u003e是否使用 Tomcat 提供的 manager servlet\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ereloadable\u003c/td\u003e\n\u003ctd\u003e/WEB-INF/classes/ 和/WEB-INF/lib/ 目录中 class 文件发生变化是否自动重新加载\u003c/td\u003e\n\u003ctd\u003e默认为 false\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eswallowOutput\u003c/td\u003e\n\u003ctd\u003etrue 情况下, System.out 和 System.err 输出将被定向到 web 应用日志中\u003c/td\u003e\n\u003ctd\u003e默认为 false\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"2-2-6-Engine\"\u003e\u003ca href=\"#2-2-6-Engine\" class=\"headerlink\" title=\"2.2.6. Engine\"\u003e\u003c/a\u003e2.2.6. Engine\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eEngine 元素表示与特定的 Catalina 服务相关联的整个请求处理机器。它接收并处理来自一个或多个连接器的所有请求，并将完成的响应返回给连接器，以便最终传输回客户端。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003edefaultHost\u003c/td\u003e\n\u003ctd\u003e默认主机名，用于标识将处理指向此服务器上主机名称但未在此配置文件中配置的请求的主机。\u003c/td\u003e\n\u003ctd\u003e这个名字必须匹配其中一个嵌套的主机元素的名字属性。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ename\u003c/td\u003e\n\u003ctd\u003e此引擎的逻辑名称，用于日志和错误消息。\u003c/td\u003e\n\u003ctd\u003e在同一服务器中使用多个服务元素时，每个引擎必须分配一个唯一的名称。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"2-2-7-Host\"\u003e\u003ca href=\"#2-2-7-Host\" class=\"headerlink\" title=\"2.2.7. Host\"\u003e\u003c/a\u003e2.2.7. Host\u003c/h4\u003e\u003cblockquote\u003e\n\u003cp\u003eHost 元素表示一个虚拟主机，它是一个服务器的网络名称（如“\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.mycompany.com”)与运行/\"\u003ewww.mycompany.com”）与运行\u003c/a\u003e Tomcat 的特定服务器的关联。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e属性表\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e备注\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003ename\u003c/td\u003e\n\u003ctd\u003e名称\u003c/td\u003e\n\u003ctd\u003e用于日志输出\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eappBase\u003c/td\u003e\n\u003ctd\u003e虚拟主机对应的应用基础路径\u003c/td\u003e\n\u003ctd\u003e可以是个绝对路径, 或${CATALINA_BASE}相对路径\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003exmlBase\u003c/td\u003e\n\u003ctd\u003e虚拟主机 XML 基础路径,里面应该有 Context xml 配置文件\u003c/td\u003e\n\u003ctd\u003e可以是个绝对路径, 或${CATALINA_BASE}相对路径\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ecreateDirs\u003c/td\u003e\n\u003ctd\u003e当 appBase 和 xmlBase 不存在时,是否创建目录\u003c/td\u003e\n\u003ctd\u003e默认为 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eautoDeploy\u003c/td\u003e\n\u003ctd\u003e是否周期性的检查 appBase 和 xmlBase 并 deploy web 应用和 context 描述符\u003c/td\u003e\n\u003ctd\u003e默认为 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003edeployIgnore\u003c/td\u003e\n\u003ctd\u003e忽略 deploy 的正则\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003edeployOnStartup\u003c/td\u003e\n\u003ctd\u003eTomcat 启动时是否自动 deploy\u003c/td\u003e\n\u003ctd\u003e默认为 true\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003efailCtxIfServletStartFails\u003c/td\u003e\n\u003ctd\u003e配置为 true 情况下,任何 load-on-startup \u0026gt;=0 的 servlet 启动失败,则其对应的 Contxt 也启动失败\u003c/td\u003e\n\u003ctd\u003e默认为 false\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"2-2-8-Cluster\"\u003e\u003ca href=\"#2-2-8-Cluster\" class=\"headerlink\" title=\"2.2.8. Cluster\"\u003e\u003c/a\u003e2.2.8. Cluster\u003c/h4\u003e\u003cp\u003e由于在实际开发中，我从未用过 Tomcat 集群配置，所以没研究。\u003c/p\u003e\n\u003ch3 id=\"2-3-启动\"\u003e\u003ca href=\"#2-3-启动\" class=\"headerlink\" title=\"2.3. 启动\"\u003e\u003c/a\u003e2.3. 启动\u003c/h3\u003e\u003ch4 id=\"2-3-1-部署方式\"\u003e\u003ca href=\"#2-3-1-部署方式\" class=\"headerlink\" title=\"2.3.1. 部署方式\"\u003e\u003c/a\u003e2.3.1. 部署方式\u003c/h4\u003e\u003cp\u003e这种方式要求本地必须安装 Tomcat 。\u003c/p\u003e\n\u003cp\u003e将打包好的 war 包放在 Tomcat 安装目录下的 \u003ccode\u003ewebapps\u003c/code\u003e 目录下，然后在 bin 目录下执行 \u003ccode\u003estartup.bat\u003c/code\u003e 或 \u003ccode\u003estartup.sh\u003c/code\u003e ，Tomcat 会自动解压 \u003ccode\u003ewebapps\u003c/code\u003e 目录下的 war 包。\u003c/p\u003e\n\u003cp\u003e成功后，可以访问 \u003ccode\u003ehttp://localhost:8080/xxx\u003c/code\u003e （xxx 是 war 包文件名）。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e以上步骤是最简单的示例。步骤中的 war 包解压路径、启动端口以及一些更多的功能都可以修改配置文件来定制 （主要是 \u003ccode\u003eserver.xml\u003c/code\u003e 或 \u003ccode\u003econtext.xml\u003c/code\u003e 文件）。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"2-3-2-嵌入式\"\u003e\u003ca href=\"#2-3-2-嵌入式\" class=\"headerlink\" title=\"2.3.2. 嵌入式\"\u003e\u003c/a\u003e2.3.2. 嵌入式\u003c/h4\u003e\u003ch5 id=\"2-3-2-1-API-方式\"\u003e\u003ca href=\"#2-3-2-1-API-方式\" class=\"headerlink\" title=\"2.3.2.1. API 方式\"\u003e\u003c/a\u003e2.3.2.1. API 方式\u003c/h5\u003e\u003cp\u003e在 pom.xml 中添加依赖\u003c/p\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eorg.apache.tomcat.embed\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003etomcat-embed-core\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e8.5.24\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003edependency\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e添加 SimpleEmbedTomcatServer.java 文件，内容如下：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e java.util.Optional;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e org.apache.catalina.startup.Tomcat;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSimpleTomcatServer\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"variable\"\u003ePORT\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e8080\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003eCONTEXT_PATH\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;/javatool-server\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e Exception {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 设定 profile\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        Optional\u0026lt;String\u0026gt; profile = Optional.ofNullable(System.getProperty(\u003cspan class=\"string\"\u003e\u0026#34;spring.profiles.active\u0026#34;\u003c/span\u003e));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        System.setProperty(\u003cspan class=\"string\"\u003e\u0026#34;spring.profiles.active\u0026#34;\u003c/span\u003e, profile.orElse(\u003cspan class=\"string\"\u003e\u0026#34;develop\u0026#34;\u003c/span\u003e));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eTomcat\u003c/span\u003e \u003cspan class=\"variable\"\u003etomcat\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eTomcat\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        tomcat.setPort(PORT);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        tomcat.getHost().setAppBase(\u003cspan class=\"string\"\u003e\u0026#34;.\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        tomcat.addWebapp(CONTEXT_PATH, getAbsolutePath() + \u003cspan class=\"string\"\u003e\u0026#34;src/main/webapp\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        tomcat.start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        tomcat.getServer().await();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e String \u003cspan class=\"title function_\"\u003egetAbsolutePath\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003epath\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003efolderPath\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e SimpleEmbedTomcatServer.class.getProtectionDomain().getCodeSource().getLocation().getPath()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                .substring(\u003cspan class=\"number\"\u003e1\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (folderPath.indexOf(\u003cspan class=\"string\"\u003e\u0026#34;target\u0026#34;\u003c/span\u003e) \u0026gt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            path = folderPath.substring(\u003cspan class=\"number\"\u003e0\u003c/span\u003e, folderPath.indexOf(\u003cspan class=\"string\"\u003e\u0026#34;target\u0026#34;\u003c/span\u003e));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e path;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e成功后，可以访问 \u003ccode\u003ehttp://localhost:8080/javatool-server\u003c/code\u003e 。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e本示例是使用 \u003ccode\u003eorg.apache.tomcat.embed\u003c/code\u003e 启动嵌入式 Tomcat 的最简示例。\u003c/p\u003e\n\u003cp\u003e这个示例中使用的是 Tomcat 默认的配置，但通常，我们需要对 Tomcat 配置进行一些定制和调优。为了加载配置文件，启动类就要稍微再复杂一些。这里不想再贴代码，有兴趣的同学可以参考：\u003c/p\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server\"\u003e\u003cstrong\u003e示例项目\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch5 id=\"2-3-2-2-使用-maven-插件启动（不推荐）\"\u003e\u003ca href=\"#2-3-2-2-使用-maven-插件启动（不推荐）\" class=\"headerlink\" title=\"2.3.2.2. 使用 maven 插件启动（不推荐）\"\u003e\u003c/a\u003e2.3.2.2. 使用 maven 插件启动（不推荐）\u003c/h5\u003e\u003cp\u003e不推荐理由：这种方式启动 maven 虽然最简单，但是有一个很大的问题是，真的很久很久没发布新版本了（最新版本发布时间：2013-11-11）。且貌似只能找到 Tomcat6 、Tomcat7 插件。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用方法\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e在 pom.xml 中引入插件\u003c/p\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eplugin\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003eorg.apache.tomcat.maven\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003egroupId\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003etomcat7-maven-plugin\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eartifactId\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e2.2\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eversion\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003econfiguration\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eport\u003c/span\u003e\u0026gt;\u003c/span\u003e8080\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eport\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003epath\u003c/span\u003e\u0026gt;\u003c/span\u003e/${project.artifactId}\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003epath\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003euriEncoding\u003c/span\u003e\u0026gt;\u003c/span\u003eUTF-8\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003euriEncoding\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003econfiguration\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eplugin\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e运行 \u003ccode\u003emvn tomcat7:run\u003c/code\u003e 命令，启动 Tomcat。\u003c/p\u003e\n\u003cp\u003e成功后，可以访问 \u003ccode\u003ehttp://localhost:8080/xxx\u003c/code\u003e （xxx 是 ${project.artifactId} 指定的项目名）。\u003c/p\u003e\n\u003ch4 id=\"2-3-3-IDE-插件\"\u003e\u003ca href=\"#2-3-3-IDE-插件\" class=\"headerlink\" title=\"2.3.3. IDE 插件\"\u003e\u003c/a\u003e2.3.3. IDE 插件\u003c/h4\u003e\u003cp\u003e常见 Java IDE 一般都有对 Tomcat 的支持。\u003c/p\u003e\n\u003cp\u003e以 Intellij IDEA 为例，提供了 \u003cstrong\u003eTomcat and TomEE Integration\u003c/strong\u003e 插件（一般默认会安装）。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e使用步骤\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e点击 Run/Debug Configurations \u0026gt; New Tomcat Server \u0026gt; local ，打开 Tomcat 配置页面。\u003c/li\u003e\n\u003cli\u003e点击 Confiure… 按钮，设置 Tomcat 安装路径。\u003c/li\u003e\n\u003cli\u003e点击 Deployment 标签页，设置要启动的应用。\u003c/li\u003e\n\u003cli\u003e设置启动应用的端口、JVM 参数、启动浏览器等。\u003c/li\u003e\n\u003cli\u003e成功后，可以访问 \u003ccode\u003ehttp://localhost:8080/\u003c/code\u003e（当然，你也可以在 url 中设置上下文名称）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/tomcat-intellij-run-config.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e说明\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e个人认为这个插件不如 Eclipse 的 Tomcat 插件好用，Eclipse 的 Tomcat 插件支持对 Tomcat xml 配置文件进行配置。而这里，你只能自己去 Tomcat 安装路径下修改配置文件。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e文中的嵌入式启动示例可以参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/JavaStack/tree/master/codes/javatool/server\"\u003e\u003cstrong\u003e我的示例项目\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"3-Tomcat-架构\"\u003e\u003ca href=\"#3-Tomcat-架构\" class=\"headerlink\" title=\"3. Tomcat 架构\"\u003e\u003c/a\u003e3. Tomcat 架构\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201113193431.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003eTomcat 要实现 2 个核心功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e处理 Socket 连接\u003c/strong\u003e，负责网络字节流与 Request 和 Response 对象的转化。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e加载和管理 Servlet\u003c/strong\u003e，以及\u003cstrong\u003e处理具体的 Request 请求\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为此，Tomcat 设计了两个核心组件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e连接器（Connector）\u003c/strong\u003e：负责和外部通信\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e容器（Container）\u003c/strong\u003e：负责内部处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-1-Service\"\u003e\u003ca href=\"#3-1-Service\" class=\"headerlink\" title=\"3.1. Service\"\u003e\u003c/a\u003e3.1. Service\u003c/h3\u003e\u003cp\u003eTomcat 支持的 I/O 模型有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNIO：非阻塞 I/O，采用 Java NIO 类库实现。\u003c/li\u003e\n\u003cli\u003eNIO2：异步 I/O，采用 JDK 7 最新的 NIO2 类库实现。\u003c/li\u003e\n\u003cli\u003eAPR：采用 Apache 可移植运行库实现，是 C/C++ 编写的本地库。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTomcat 支持的应用层协议有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP/1.1：这是大部分 Web 应用采用的访问协议。\u003c/li\u003e\n\u003cli\u003eAJP：用于和 Web 服务器集成（如 Apache）。\u003c/li\u003e\n\u003cli\u003eHTTP/2：HTTP 2.0 大幅度的提升了 Web 性能。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTomcat 支持多种 I/O 模型和应用层协议。为了实现这点，一个容器可能对接多个连接器。但是，单独的连接器或容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作 Service 组件。Tomcat 内可能有多个 Service，通过在 Tomcat 中配置多个 Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201111093124.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e一个 Tomcat 实例有一个或多个 Service；一个 Service 有多个 Connector 和 Container\u003c/strong\u003e。Connector 和 Container 之间通过标准的 ServletRequest 和 ServletResponse 通信。\u003c/p\u003e\n\u003ch3 id=\"3-2-连接器\"\u003e\u003ca href=\"#3-2-连接器\" class=\"headerlink\" title=\"3.2. 连接器\"\u003e\u003c/a\u003e3.2. 连接器\u003c/h3\u003e\u003cp\u003e连接器对 Servlet 容器屏蔽了协议及 I/O 模型等的区别，无论是 HTTP 还是 AJP，在容器中获取到的都是一个标准的 ServletRequest 对象。\u003c/p\u003e\n\u003cp\u003e连接器的主要功能是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e网络通信\u003c/li\u003e\n\u003cli\u003e应用层协议解析\u003c/li\u003e\n\u003cli\u003eTomcat Request/Response 与 ServletRequest/ServletResponse 的转化\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTomcat 设计了 3 个组件来实现这 3 个功能，分别是 \u003cstrong\u003e\u003ccode\u003eEndPoint\u003c/code\u003e\u003cstrong\u003e、\u003c/strong\u003e\u003ccode\u003eProcessor\u003c/code\u003e\u003c/strong\u003e 和 **\u003ccode\u003eAdapter\u003c/code\u003e**。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201111101440.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e组件间通过抽象接口交互。这样做还有一个好处是\u003cstrong\u003e封装变化。\u003c/strong\u003e这是面向对象设计的精髓，将系统中经常变化的部分和稳定的部分隔离，有助于增加复用性，并降低系统耦合度。网络通信的 I/O 模型是变化的，可能是非阻塞 I/O、异步 I/O 或者 APR。应用层协议也是变化的，可能是 HTTP、HTTPS、AJP。浏览器端发送的请求信息也是变化的。但是整体的处理逻辑是不变的，EndPoint 负责提供字节流给 Processor，Processor 负责提供 Tomcat Request 对象给 Adapter，Adapter 负责提供 ServletRequest 对象给容器。\u003c/p\u003e\n\u003cp\u003e如果要支持新的 I/O 方案、新的应用层协议，只需要实现相关的具体子类，上层通用的处理逻辑是不变的。由于 I/O 模型和应用层协议可以自由组合，比如 NIO + HTTP 或者 NIO2 + AJP。Tomcat 的设计者将网络通信和应用层协议解析放在一起考虑，设计了一个叫 ProtocolHandler 的接口来封装这两种变化点。各种协议和通信模型的组合有相应的具体实现类。比如：Http11NioProtocol 和 AjpNioProtocol。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201027091819.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"3-2-1-ProtocolHandler-组件\"\u003e\u003ca href=\"#3-2-1-ProtocolHandler-组件\" class=\"headerlink\" title=\"3.2.1. ProtocolHandler 组件\"\u003e\u003c/a\u003e3.2.1. ProtocolHandler 组件\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e连接器用 ProtocolHandler 接口来封装通信协议和 I/O 模型的差异\u003c/strong\u003e。ProtocolHandler 内部又分为 EndPoint 和 Processor 模块，EndPoint 负责底层 Socket 通信，Proccesor 负责应用层协议解析。\u003c/p\u003e\n\u003ch5 id=\"3-2-1-1-EndPoint\"\u003e\u003ca href=\"#3-2-1-1-EndPoint\" class=\"headerlink\" title=\"3.2.1.1. EndPoint\"\u003e\u003c/a\u003e3.2.1.1. EndPoint\u003c/h5\u003e\u003cp\u003eEndPoint 是通信端点，即通信监听的接口，是具体的 Socket 接收和发送处理器，是对传输层的抽象，因此 EndPoint 是用来实现 TCP/IP 协议的。\u003c/p\u003e\n\u003cp\u003eEndPoint 是一个接口，对应的抽象实现类是 AbstractEndpoint，而 AbstractEndpoint 的具体子类，比如在 NioEndpoint 和 Nio2Endpoint 中，有两个重要的子组件：Acceptor 和 SocketProcessor。\u003c/p\u003e\n\u003cp\u003e其中 Acceptor 用于监听 Socket 连接请求。SocketProcessor 用于处理接收到的 Socket 请求，它实现 Runnable 接口，在 Run 方法里调用协议处理组件 Processor 进行处理。为了提高处理能力，SocketProcessor 被提交到线程池来执行。而这个线程池叫作执行器（Executor)。\u003c/p\u003e\n\u003ch5 id=\"3-2-1-2-Processor\"\u003e\u003ca href=\"#3-2-1-2-Processor\" class=\"headerlink\" title=\"3.2.1.2. Processor\"\u003e\u003c/a\u003e3.2.1.2. Processor\u003c/h5\u003e\u003cp\u003e如果说 EndPoint 是用来实现 TCP/IP 协议的，那么 Processor 用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象。\u003c/p\u003e\n\u003cp\u003eProcessor 是一个接口，定义了请求的处理等方法。它的抽象实现类 AbstractProcessor 对一些协议共有的属性进行封装，没有对方法进行实现。具体的实现有 AJPProcessor、HTTP11Processor 等，这些具体实现类实现了特定协议的解析方法和请求处理方式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201113185929.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e从图中我们看到，EndPoint 接收到 Socket 连接后，生成一个 SocketProcessor 任务提交到线程池去处理，SocketProcessor 的 Run 方法会调用 Processor 组件去解析应用层协议，Processor 通过解析生成 Request 对象后，会调用 Adapter 的 Service 方法。\u003c/p\u003e\n\u003ch4 id=\"3-2-2-Adapter\"\u003e\u003ca href=\"#3-2-2-Adapter\" class=\"headerlink\" title=\"3.2.2. Adapter\"\u003e\u003c/a\u003e3.2.2. Adapter\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e连接器通过适配器 Adapter 调用容器\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat 定义了自己的 Request 类来适配这些请求信息。\u003c/p\u003e\n\u003cp\u003eProtocolHandler 接口负责解析请求并生成 Tomcat Request 类。但是这个 Request 对象不是标准的 ServletRequest，也就意味着，不能用 Tomcat Request 作为参数来调用容器。Tomcat 的解决方案是引入 CoyoteAdapter，这是适配器模式的经典运用，连接器调用 CoyoteAdapter 的 Sevice 方法，传入的是 Tomcat Request 对象，CoyoteAdapter 负责将 Tomcat Request 转成 ServletRequest，再调用容器的 Service 方法。\u003c/p\u003e\n\u003ch3 id=\"3-3-容器\"\u003e\u003ca href=\"#3-3-容器\" class=\"headerlink\" title=\"3.3. 容器\"\u003e\u003c/a\u003e3.3. 容器\u003c/h3\u003e\u003cp\u003eTomcat 设计了 4 种容器，分别是 Engine、Host、Context 和 Wrapper。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eEngine\u003c/strong\u003e - Servlet 的顶层容器，包含一 个或多个 Host 子容器；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eHost\u003c/strong\u003e - 虚拟主机，负责 web 应用的部署和 Context 的创建；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eContext\u003c/strong\u003e - Web 应用上下文，包含多个 Wrapper，负责 web 配置的解析、管理所有的 Web 资源；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWrapper\u003c/strong\u003e - 最底层的容器，是对 Servlet 的封装，负责 Servlet 实例的创 建、执行和销毁。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"3-3-1-请求分发-Servlet-过程\"\u003e\u003ca href=\"#3-3-1-请求分发-Servlet-过程\" class=\"headerlink\" title=\"3.3.1. 请求分发 Servlet 过程\"\u003e\u003c/a\u003e3.3.1. 请求分发 Servlet 过程\u003c/h4\u003e\u003cp\u003eTomcat 是怎么确定请求是由哪个 Wrapper 容器里的 Servlet 来处理的呢？答案是，Tomcat 是用 Mapper 组件来完成这个任务的。\u003c/p\u003e\n\u003cp\u003e举例来说，假如有一个网购系统，有面向网站管理人员的后台管理系统，还有面向终端客户的在线购物系统。这两个系统跑在同一个 Tomcat 上，为了隔离它们的访问域名，配置了两个虚拟域名：\u003ccode\u003emanage.shopping.com\u003c/code\u003e和\u003ccode\u003euser.shopping.com\u003c/code\u003e，网站管理人员通过\u003ccode\u003emanage.shopping.com\u003c/code\u003e域名访问 Tomcat 去管理用户和商品，而用户管理和商品管理是两个单独的 Web 应用。终端客户通过\u003ccode\u003euser.shopping.com\u003c/code\u003e域名去搜索商品和下订单，搜索功能和订单管理也是两个独立的 Web 应用。如下所示，演示了 url 应声 Servlet 的处理流程。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201113192022.jpg\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e假如有用户访问一个 URL，比如图中的\u003ccode\u003ehttp://user.shopping.com:8080/order/buy\u003c/code\u003e，Tomcat 如何将这个 URL 定位到一个 Servlet 呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e首先，根据协议和端口号选定 Service 和 Engine。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e然后，根据域名选定 Host。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e之后，根据 URL 路径找到 Context 组件。\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e最后，根据 URL 路径找到 Wrapper（Servlet）。\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这个路由分发过程具体是怎么实现的呢？答案是使用 Pipeline-Valve 管道。\u003c/p\u003e\n\u003ch4 id=\"3-3-2-Pipeline-Value\"\u003e\u003ca href=\"#3-3-2-Pipeline-Value\" class=\"headerlink\" title=\"3.3.2. Pipeline-Value\"\u003e\u003c/a\u003e3.3.2. Pipeline-Value\u003c/h4\u003e\u003cp\u003ePipeline 可以理解为现实中的管道，Valve 为管道中的阀门，Request 和 Response 对象在管道中经过各个阀门的处理和控制。\u003c/p\u003e\n\u003cp\u003ePipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。Valve 表示一个处理点，比如权限认证和记录日志。\u003c/p\u003e\n\u003cp\u003e先来了解一下 Valve 和 Pipeline 接口的设计：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Pipeline%E4%B8%8EValve.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e每一个容器都有一个 Pipeline 对象，只要触发这个 Pipeline 的第一个 Valve，这个容器里 Pipeline 中的 Valve 就都会被调用到。但是，不同容器的 Pipeline 是怎么链式触发的呢，比如 Engine 中 Pipeline 需要调用下层容器 Host 中的 Pipeline。\u003c/li\u003e\n\u003cli\u003e这是因为 Pipeline 中还有个 getBasic 方法。这个 BasicValve 处于 Valve 链表的末端，它是 Pipeline 中必不可少的一个 Valve，负责调用下层容器的 Pipeline 里的第一个 Valve。\u003c/li\u003e\n\u003cli\u003ePipeline 中有 addValve 方法。Pipeline 中维护了 Valve 链表，Valve 可以插入到 Pipeline 中，对请求做某些处理。我们还发现 Pipeline 中没有 invoke 方法，因为整个调用链的触发是 Valve 来完成的，Valve 完成自己的处理后，调用 \u003ccode\u003egetNext.invoke()\u003c/code\u003e 来触发下一个 Valve 调用。\u003c/li\u003e\n\u003cli\u003eValve 中主要的三个方法：\u003ccode\u003esetNext\u003c/code\u003e、\u003ccode\u003egetNext\u003c/code\u003e、\u003ccode\u003einvoke\u003c/code\u003e。Valve 之间的关系是单向链式结构，本身 \u003ccode\u003einvoke\u003c/code\u003e 方法中会调用下一个 Valve 的 \u003ccode\u003einvoke\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e各层容器对应的 basic valve 分别是 \u003ccode\u003eStandardEngineValve\u003c/code\u003e、\u003ccode\u003eStandardHostValve\u003c/code\u003e、 \u003ccode\u003eStandardContextValve\u003c/code\u003e、\u003ccode\u003eStandardWrapperValve\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e由于 Valve 是一个处理点，因此 invoke 方法就是来处理请求的。注意到 Valve 中有 getNext 和 setNext 方法，因此我们大概可以猜到有一个链表将 Valve 链起来了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e整个调用过程由连接器中的 Adapter 触发的，它会调用 Engine 的第一个 Valve：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003econnector.getService().getContainer().getPipeline().getFirst().invoke(request, response);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"4-Tomcat-生命周期\"\u003e\u003ca href=\"#4-Tomcat-生命周期\" class=\"headerlink\" title=\"4. Tomcat 生命周期\"\u003e\u003c/a\u003e4. Tomcat 生命周期\u003c/h2\u003e\u003ch3 id=\"4-1-Tomcat-的启动过程\"\u003e\u003ca href=\"#4-1-Tomcat-的启动过程\" class=\"headerlink\" title=\"4.1. Tomcat 的启动过程\"\u003e\u003c/a\u003e4.1. Tomcat 的启动过程\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201118145455.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eTomcat 是一个 Java 程序，它的运行从执行 \u003ccode\u003estartup.sh\u003c/code\u003e 脚本开始。\u003ccode\u003estartup.sh\u003c/code\u003e 会启动一个 JVM 来运行 Tomcat 的启动类 \u003ccode\u003eBootstrap\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eBootstrap\u003c/code\u003e 会初始化 Tomcat 的类加载器并实例化 \u003ccode\u003eCatalina\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCatalina\u003c/code\u003e 会通过 Digester 解析 \u003ccode\u003eserver.xml\u003c/code\u003e，根据其中的配置信息来创建相应组件，并调用 \u003ccode\u003eServer\u003c/code\u003e 的 \u003ccode\u003estart\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eServer\u003c/code\u003e 负责管理 \u003ccode\u003eService\u003c/code\u003e 组件，它会调用 \u003ccode\u003eService\u003c/code\u003e 的 \u003ccode\u003estart\u003c/code\u003e 方法。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eService\u003c/code\u003e 负责管理 \u003ccode\u003eConnector\u003c/code\u003e 和顶层容器 \u003ccode\u003eEngine\u003c/code\u003e，它会调用 \u003ccode\u003eConnector\u003c/code\u003e 和 \u003ccode\u003eEngine\u003c/code\u003e 的 \u003ccode\u003estart\u003c/code\u003e 方法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch4 id=\"4-1-1-Catalina-组件\"\u003e\u003ca href=\"#4-1-1-Catalina-组件\" class=\"headerlink\" title=\"4.1.1. Catalina 组件\"\u003e\u003c/a\u003e4.1.1. Catalina 组件\u003c/h4\u003e\u003cp\u003eCatalina 的职责就是解析 server.xml 配置，并据此实例化 Server。接下来，调用 Server 组件的 init 方法和 start 方法，将 Tomcat 启动起来。\u003c/p\u003e\n\u003cp\u003eCatalina 还需要处理各种“异常”情况，比如当我们通过“Ctrl + C”关闭 Tomcat 时，Tomcat 将如何优雅的停止并且清理资源呢？因此 Catalina 在 JVM 中注册一个“关闭钩子”。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003estart\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//1. 如果持有的 Server 实例为空，就解析 server.xml 创建出来\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (getServer() == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        load();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//2. 如果创建失败，报错退出\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (getServer() == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        log.fatal(sm.getString(\u003cspan class=\"string\"\u003e\u0026#34;catalina.noServer\u0026#34;\u003c/span\u003e));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//3. 启动 Server\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        getServer().start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (LifecycleException e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 创建并注册关闭钩子\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (useShutdownHook) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (shutdownHook == \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            shutdownHook = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCatalinaShutdownHook\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        Runtime.getRuntime().addShutdownHook(shutdownHook);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 用 await 方法监听停止请求\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (await) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        await();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        stop();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e为什么需要关闭钩子？\u003c/p\u003e\n\u003cp\u003e如果我们需要在 JVM 关闭时做一些清理工作，比如将缓存数据刷到磁盘上，或者清理一些临时文件，可以向 JVM 注册一个“关闭钩子”。“关闭钩子”其实就是一个线程，JVM 在停止之前会尝试执行这个线程的 \u003ccode\u003erun\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cp\u003eTomcat 的“关闭钩子”—— \u003ccode\u003eCatalinaShutdownHook\u003c/code\u003e 做了些什么呢？\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCatalinaShutdownHook\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eThread\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003erun\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (getServer() != \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                Catalina.\u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e.stop();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (Throwable ex) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e           ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eTomcat 的“关闭钩子”实际上就执行了 \u003ccode\u003eServer\u003c/code\u003e 的 \u003ccode\u003estop\u003c/code\u003e 方法，\u003ccode\u003eServer\u003c/code\u003e 的 \u003ccode\u003estop\u003c/code\u003e 方法会释放和清理所有的资源。\u003c/p\u003e\n\u003ch4 id=\"4-1-2-Server-组件\"\u003e\u003ca href=\"#4-1-2-Server-组件\" class=\"headerlink\" title=\"4.1.2. Server 组件\"\u003e\u003c/a\u003e4.1.2. Server 组件\u003c/h4\u003e\u003cp\u003eServer 组件的具体实现类是 StandardServer，Server 继承了 LifeCycleBase，它的生命周期被统一管理，并且它的子组件是 Service，因此它还需要管理 Service 的生命周期，也就是说在启动时调用 Service 组件的启动方法，在停止时调用它们的停止方法。Server 在内部维护了若干 Service 组件，它是以数组来保存的。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e@Override\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eaddService\u003c/span\u003e\u003cspan class=\"params\"\u003e(Service service)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    service.setServer(\u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (servicesLock) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 创建一个长度 +1 的新数组\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        Service results[] = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eService\u003c/span\u003e[services.length + \u003cspan class=\"number\"\u003e1\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 将老的数据复制过去\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        System.arraycopy(services, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, results, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, services.length);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        results[services.length] = service;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        services = results;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 启动 Service 组件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (getState().isAvailable()) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                service.start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            } \u003cspan class=\"keyword\"\u003ecatch\u003c/span\u003e (LifecycleException e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"comment\"\u003e// Ignore\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 触发监听事件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        support.firePropertyChange(\u003cspan class=\"string\"\u003e\u0026#34;service\u0026#34;\u003c/span\u003e, \u003cspan class=\"literal\"\u003enull\u003c/span\u003e, service);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eServer 并没有一开始就分配一个很长的数组，而是在添加的过程中动态地扩展数组长度，当添加一个新的 Service 实例时，会创建一个新数组并把原来数组内容复制到新数组，这样做的目的其实是为了节省内存空间。\u003c/p\u003e\n\u003cp\u003e除此之外，Server 组件还有一个重要的任务是启动一个 Socket 来监听停止端口，这就是为什么你能通过 shutdown 命令来关闭 Tomcat。不知道你留意到没有，上面 Caralina 的启动方法的最后一行代码就是调用了 Server 的 await 方法。\u003c/p\u003e\n\u003cp\u003e在 await 方法里会创建一个 Socket 监听 8005 端口，并在一个死循环里接收 Socket 上的连接请求，如果有新的连接到来就建立连接，然后从 Socket 中读取数据；如果读到的数据是停止命令“SHUTDOWN”，就退出循环，进入 stop 流程。\u003c/p\u003e\n\u003ch4 id=\"4-1-3-Service-组件\"\u003e\u003ca href=\"#4-1-3-Service-组件\" class=\"headerlink\" title=\"4.1.3. Service 组件\"\u003e\u003c/a\u003e4.1.3. Service 组件\u003c/h4\u003e\u003cp\u003eService 组件的具体实现类是 StandardService。\u003c/p\u003e\n\u003cp\u003e【源码】StandardService 源码定义\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eStandardService\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title class_\"\u003eLifecycleBase\u003c/span\u003e \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003eService\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 名字\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003ename\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//Server 实例\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"type\"\u003eServer\u003c/span\u003e \u003cspan class=\"variable\"\u003eserver\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 连接器数组\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e Connector connectors[] = \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eConnector\u003c/span\u003e[\u003cspan class=\"number\"\u003e0\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eObject\u003c/span\u003e \u003cspan class=\"variable\"\u003econnectorsLock\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eObject\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 对应的 Engine 容器\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"type\"\u003eEngine\u003c/span\u003e \u003cspan class=\"variable\"\u003eengine\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"literal\"\u003enull\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 映射器及其监听器\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eMapper\u003c/span\u003e \u003cspan class=\"variable\"\u003emapper\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eMapper\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003eMapperListener\u003c/span\u003e \u003cspan class=\"variable\"\u003emapperListener\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eMapperListener\u003c/span\u003e(\u003cspan class=\"built_in\"\u003ethis\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eStandardService 继承了 LifecycleBase 抽象类。\u003c/p\u003e\n\u003cp\u003eStandardService 维护了一个 MapperListener 用于支持 Tomcat 热部署。当 Web 应用的部署发生变化时，Mapper 中的映射信息也要跟着变化，MapperListener 就是一个监听器，它监听容器的变化，并把信息更新到 Mapper 中，这是典型的观察者模式。\u003c/p\u003e\n\u003cp\u003e作为“管理”角色的组件，最重要的是维护其他组件的生命周期。此外在启动各种组件时，要注意它们的依赖关系，也就是说，要注意启动的顺序。\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003estartInternal\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethrows\u003c/span\u003e LifecycleException {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//1. 触发启动监听器\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    setState(LifecycleState.STARTING);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//2. 先启动 Engine，Engine 会启动它子容器\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (engine != \u003cspan class=\"literal\"\u003enull\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (engine) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            engine.start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//3. 再启动 Mapper 监听器\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    mapperListener.start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//4. 最后启动连接器，连接器会启动它子组件，比如 Endpoint\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003esynchronized\u003c/span\u003e (connectorsLock) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (Connector connector: connectors) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (connector.getState() != LifecycleState.FAILED) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                connector.start();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e从启动方法可以看到，Service 先启动了 Engine 组件，再启动 Mapper 监听器，最后才是启动连接器。这很好理解，因为内层组件启动好了才能对外提供服务，才能启动外层的连接器组件。而 Mapper 也依赖容器组件，容器组件启动好了才能监听它们的变化，因此 Mapper 和 MapperListener 在容器组件之后启动。组件停止的顺序跟启动顺序正好相反的，也是基于它们的依赖关系。\u003c/p\u003e\n\u003ch4 id=\"4-1-4-Engine-组件\"\u003e\u003ca href=\"#4-1-4-Engine-组件\" class=\"headerlink\" title=\"4.1.4. Engine 组件\"\u003e\u003c/a\u003e4.1.4. Engine 组件\u003c/h4\u003e\u003cp\u003eEngine 本质是一个容器，因此它继承了 ContainerBase 基类，并且实现了 Engine 接口。\u003c/p\u003e\n\u003ch3 id=\"4-2-Web-应用的部署方式\"\u003e\u003ca href=\"#4-2-Web-应用的部署方式\" class=\"headerlink\" title=\"4.2. Web 应用的部署方式\"\u003e\u003c/a\u003e4.2. Web 应用的部署方式\u003c/h3\u003e\u003cp\u003e注：catalina.home：安装目录;catalina.base：工作目录;默认值 user.dir\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eServer.xml 配置 Host 元素，指定 appBase 属性，默认$catalina.base/webapps/\u003c/li\u003e\n\u003cli\u003eServer.xml 配置 Context 元素，指定 docBase，元素，指定 web 应用的路径\u003c/li\u003e\n\u003cli\u003e自定义配置：在$catalina.base/EngineName/HostName/XXX.xml 配置 Context 元素\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHostConfig 监听了 StandardHost 容器的事件，在 start 方法中解析上述配置文件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e扫描 appbase 路径下的所有文件夹和 war 包，解析各个应用的 META-INF/context.xml，并 创建 StandardContext，并将 Context 加入到 Host 的子容器中。\u003c/li\u003e\n\u003cli\u003e解析$catalina.base/EngineName/HostName/下的所有 Context 配置，找到相应 web 应 用的位置，解析各个应用的 META-INF/context.xml，并创建 StandardContext，并将 Context 加入到 Host 的子容器中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHostConfig 并没有实际解析 Context.xml，而是在 ContextConfig 中进行的。\u003c/li\u003e\n\u003cli\u003eHostConfig 中会定期检查 watched 资源文件(context.xml 配置文件)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eContextConfig 解析 context.xml 顺序：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先解析全局的配置 config/context.xml\u003c/li\u003e\n\u003cli\u003e然后解析 Host 的默认配置 EngineName/HostName/context.xml.default\u003c/li\u003e\n\u003cli\u003e最后解析应用的 META-INF/context.xml\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eContextConfig 解析 web.xml 顺序：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先解析全局的配置 config/web.xml\u003c/li\u003e\n\u003cli\u003e然后解析 Host 的默认配置 EngineName/HostName/web.xml.default 接着解析应用的 MEB-INF/web.xml\u003c/li\u003e\n\u003cli\u003e扫描应用 WEB-INF/lib/下的 jar 文件，解析其中的 META-INF/web-fragment.xml 最后合并 xml 封装成 WebXml，并设置 Context\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e注：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e扫描 web 应用和 jar 中的注解(Filter、Listener、Servlet)就是上述步骤中进行的。\u003c/li\u003e\n\u003cli\u003e容器的定期执行：backgroundProcess，由 ContainerBase 来实现的，并且只有在顶层容器 中才会开启线程。(backgroundProcessorDelay=10 标志位来控制)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-3-LifeCycle\"\u003e\u003ca href=\"#4-3-LifeCycle\" class=\"headerlink\" title=\"4.3. LifeCycle\"\u003e\u003c/a\u003e4.3. LifeCycle\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20201118105012.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"4-3-1-请求处理过程\"\u003e\u003ca href=\"#4-3-1-请求处理过程\" class=\"headerlink\" title=\"4.3.1. 请求处理过程\"\u003e\u003c/a\u003e4.3.1. 请求处理过程\u003c/h4\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/请求处理过程.png\" width=\"600\"/\u003e\n\u003c/div\u003e\n\n\u003col\u003e\n\u003cli\u003e根据 server.xml 配置的指定的 connector 以及端口监听 http、或者 ajp 请求\u003c/li\u003e\n\u003cli\u003e请求到来时建立连接,解析请求参数,创建 Request 和 Response 对象,调用顶层容器 pipeline 的 invoke 方法\u003c/li\u003e\n\u003cli\u003e容器之间层层调用,最终调用业务 servlet 的 service 方法\u003c/li\u003e\n\u003cli\u003eConnector 将 response 流中的数据写到 socket 中\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"4-4-Connector-流程\"\u003e\u003ca href=\"#4-4-Connector-流程\" class=\"headerlink\" title=\"4.4. Connector 流程\"\u003e\u003c/a\u003e4.4. Connector 流程\u003c/h3\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/connector.png\" width=\"600\"/\u003e\n\u003c/div\u003e\n\n\u003ch4 id=\"4-4-1-阻塞-IO\"\u003e\u003ca href=\"#4-4-1-阻塞-IO\" class=\"headerlink\" title=\"4.4.1. 阻塞 IO\"\u003e\u003c/a\u003e4.4.1. 阻塞 IO\u003c/h4\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/阻塞IO.png\" width=\"600\"/\u003e\n\u003c/div\u003e\n\n\u003ch4 id=\"4-4-2-非阻塞-IO\"\u003e\u003ca href=\"#4-4-2-非阻塞-IO\" class=\"headerlink\" title=\"4.4.2. 非阻塞 IO\"\u003e\u003c/a\u003e4.4.2. 非阻塞 IO\u003c/h4\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/非阻塞IO.png\" width=\"600\"/\u003e\n\u003c/div\u003e\n\n\u003ch4 id=\"4-4-3-IO-多路复用\"\u003e\u003ca href=\"#4-4-3-IO-多路复用\" class=\"headerlink\" title=\"4.4.3. IO 多路复用\"\u003e\u003c/a\u003e4.4.3. IO 多路复用\u003c/h4\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/IO多路复用.png\" width=\"600\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003e阻塞与非阻塞的区别在于进行读操作和写操作的系统调用时，如果此时内核态没有数据可读或者没有缓冲空间可写时，是否阻塞。\u003c/p\u003e\n\u003cp\u003eIO 多路复用的好处在于可同时监听多个 socket 的可读和可写事件，这样就能使得应用可以同时监听多个 socket，释放了应用线程资源。\u003c/p\u003e\n\u003ch4 id=\"4-4-4-Tomcat-各类-Connector-对比\"\u003e\u003ca href=\"#4-4-4-Tomcat-各类-Connector-对比\" class=\"headerlink\" title=\"4.4.4. Tomcat 各类 Connector 对比\"\u003e\u003c/a\u003e4.4.4. Tomcat 各类 Connector 对比\u003c/h4\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/Tomcat各类Connector对比.jpg\" width=\"500\"/\u003e\n\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003eJIO：用 java.io 编写的 TCP 模块，阻塞 IO\u003c/li\u003e\n\u003cli\u003eNIO：用 java.nio 编写的 TCP 模块，非阻塞 IO，（IO 多路复用）\u003c/li\u003e\n\u003cli\u003eAPR：全称 Apache Portable Runtime，使用 JNI 的方式来进行读取文件以及进行网络传输\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eApache Portable Runtime 是一个高度可移植的库，它是 Apache HTTP Server 2.x 的核心。 APR 具有许多用途，包括访问高级 IO 功能（如 sendfile，epoll 和 OpenSSL），操作系统级功能（随机数生成，系统状态等）和本地进程处理（共享内存，NT 管道和 Unix 套接字）。\u003c/p\u003e\n\u003cp\u003e表格中字段含义说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSupport Polling - 是否支持基于 IO 多路复用的 socket 事件轮询\u003c/li\u003e\n\u003cli\u003ePolling Size - 轮询的最大连接数\u003c/li\u003e\n\u003cli\u003eWait for next Request - 在等待下一个请求时，处理线程是否释放，BIO 是没有释放的，所以在 keep-alive=true 的情况下处理的并发连接数有限\u003c/li\u003e\n\u003cli\u003eRead Request Headers - 由于 request header 数据较少，可以由容器提前解析完毕，不需要阻塞\u003c/li\u003e\n\u003cli\u003eRead Request Body - 读取 request body 的数据是应用业务逻辑的事情，同时 Servlet 的限制，是需要阻塞读取的\u003c/li\u003e\n\u003cli\u003eWrite Response - 跟读取 request body 的逻辑类似，同样需要阻塞写\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNIO 处理相关类\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/NIO处理相关类.jpg\" width=\"500\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003ePoller 线程从 EventQueue 获取 PollerEvent，并执行 PollerEvent 的 run 方法，调用 Selector 的 select 方法，如果有可读的 Socket 则创建 Http11NioProcessor，放入到线程池中执行；\u003c/p\u003e\n\u003cp\u003eCoyoteAdapter 是 Connector 到 Container 的适配器，Http11NioProcessor 调用其提供的 service 方法，内部创建 Request 和 Response 对象，并调用最顶层容器的 Pipeline 中的第一个 Valve 的 invoke 方法\u003c/p\u003e\n\u003cp\u003eMapper 主要处理 http url 到 servlet 的映射规则的解析，对外提供 map 方法\u003c/p\u003e\n\u003ch3 id=\"4-5-Comet\"\u003e\u003ca href=\"#4-5-Comet\" class=\"headerlink\" title=\"4.5. Comet\"\u003e\u003c/a\u003e4.5. Comet\u003c/h3\u003e\u003cp\u003eComet 是一种用于 web 的推送技术，能使服务器实时地将更新的信息传送到客户端，而无须客户端发出请求\u003cbr/\u003e在 WebSocket 出来之前，如果不适用 comet，只能通过浏览器端轮询 Server 来模拟实现服务器端推送。\u003cbr/\u003eComet 支持 servlet 异步处理 IO，当连接上数据可读时触发事件，并异步写数据(阻塞)\u003c/p\u003e\n\u003cp\u003eTomcat 要实现 Comet，只需继承 HttpServlet 同时，实现 CometProcessor 接口\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBegin：新的请求连接接入调用，可进行与 Request 和 Response 相关的对象初始化操作，并保存 response 对象，用于后续写入数据\u003c/li\u003e\n\u003cli\u003eRead：请求连接有数据可读时调用\u003c/li\u003e\n\u003cli\u003eEnd：当数据可用时，如果读取到文件结束或者 response 被关闭时则被调用\u003c/li\u003e\n\u003cli\u003eError：在连接上发生异常时调用，数据读取异常、连接断开、处理异常、socket 超时\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRead：在 post 请求有数据，但在 begin 事件中没有处理，则会调用 read，如果 read 没有读取数据，在会触发 Error 回调，关闭 socket\u003c/li\u003e\n\u003cli\u003eEnd：当 socket 超时，并且 response 被关闭时也会调用；server 被关闭时调用\u003c/li\u003e\n\u003cli\u003eError：除了 socket 超时不会关闭 socket，其他都会关闭 socket\u003c/li\u003e\n\u003cli\u003eEnd 和 Error 时间触发时应关闭当前 comet 会话，即调用 CometEvent 的 close 方法\u003cbr/\u003eNote：在事件触发时要做好线程安全的操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"4-6-异步-Servlet\"\u003e\u003ca href=\"#4-6-异步-Servlet\" class=\"headerlink\" title=\"4.6. 异步 Servlet\"\u003e\u003c/a\u003e4.6. 异步 Servlet\u003c/h3\u003e\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/传统Servlet处理流程.png\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003e传统流程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先，Servlet 接收到请求之后，request 数据解析；\u003c/li\u003e\n\u003cli\u003e接着，调用业务接口的某些方法，以完成业务处理；\u003c/li\u003e\n\u003cli\u003e最后，根据处理的结果提交响应，Servlet 线程结束\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv align=\"center\"\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/cs/java/javaweb/tools/tomcat/异步Servlet处理流程.png\"/\u003e\n\u003c/div\u003e\n\n\u003cp\u003e异步处理流程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户端发送一个请求\u003c/li\u003e\n\u003cli\u003eServlet 容器分配一个线程来处理容器中的一个 servlet\u003c/li\u003e\n\u003cli\u003eservlet 调用 request.startAsync()，保存 AsyncContext, 然后返回\u003c/li\u003e\n\u003cli\u003e任何方式存在的容器线程都将退出，但是 response 仍然保持开放\u003c/li\u003e\n\u003cli\u003e业务线程使用保存的 AsyncContext 来完成响应（线程池）\u003c/li\u003e\n\u003cli\u003e客户端收到响应\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eServlet 线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时 Servlet 还没有生成响应数据，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用）\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e为什么 web 应用中支持异步？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e推出异步，主要是针对那些比较耗时的请求：比如一次缓慢的数据库查询，一次外部 REST API 调用, 或者是其他一些 I/O 密集型操作。这种耗时的请求会很快的耗光 Servlet 容器的线程池，继而影响可扩展性。\u003c/p\u003e\n\u003cp\u003eNote：从客户端的角度来看，request 仍然像任何其他的 HTTP 的 request-response 交互一样，只是耗费了更长的时间而已\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e异步事件监听\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eonStartAsync：Request 调用 startAsync 方法时触发\u003c/li\u003e\n\u003cli\u003eonComplete：syncContext 调用 complete 方法时触发\u003c/li\u003e\n\u003cli\u003eonError：处理请求的过程出现异常时触发\u003c/li\u003e\n\u003cli\u003eonTimeout：socket 超时触发\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote :\u003cbr/\u003eonError/ onTimeout 触发后，会紧接着回调 onComplete\u003cbr/\u003eonComplete 执行后，就不可再操作 request 和 response\u003c/p\u003e\n\u003ch2 id=\"5-参考资料\"\u003e\u003ca href=\"#5-参考资料\" class=\"headerlink\" title=\"5. 参考资料\"\u003e\u003c/a\u003e5. 参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e官方\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://tomcat.apache.org/\"\u003eTomcat 官方网站\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://wiki.apache.org/tomcat/FrontPage\"\u003eTomcat Wiki\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://tomee.apache.org/\"\u003eTomee 官方网站\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e文章\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/basic_app_embedded_tomcat/basic_app-tomcat-embedded.html\"\u003eCreating a Web App with Bootstrap and Tomcat Embedded\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/58eb5fdda0bb9f00692a78fc\"\u003eTomcat 组成与工作原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/index.html\"\u003eTomcat 工作原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/index.html?ca=drs-\"\u003eTomcat 设计模式分析\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-02-17T14:34:30Z",
  "Author": "钝悟 ◾ Dunwu"
}