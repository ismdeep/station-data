{
  "Source": "dunwu",
  "Title": "深入理解 Java String 类型",
  "Link": "https://dunwu.github.io/blog/pages/bc583c/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"深入理解-Java-String-类型\"\u003e\u003ca href=\"#深入理解-Java-String-类型\" class=\"headerlink\" title=\"深入理解 Java String 类型\"\u003e\u003c/a\u003e深入理解 Java String 类型\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003eString 类型可能是 Java 中应用最频繁的引用类型，但它的性能问题却常常被忽略。高效的使用字符串，可以提升系统的整体性能。当然，要做到高效使用字符串，需要深入了解其特性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"String-的不可变性\"\u003e\u003ca href=\"#String-的不可变性\" class=\"headerlink\" title=\"String 的不可变性\"\u003e\u003c/a\u003eString 的不可变性\u003c/h2\u003e\u003cp\u003e我们先来看下 \u003ccode\u003eString\u003c/code\u003e 的定义：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eString\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eimplements\u003c/span\u003e \u003cspan class=\"title class_\"\u003ejava\u003c/span\u003e.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e/** The value is used for character storage. */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"type\"\u003echar\u003c/span\u003e value[];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e 类被 \u003ccode\u003efinal\u003c/code\u003e 关键字修饰，表示\u003cstrong\u003e不可继承 \u003ccode\u003eString\u003c/code\u003e 类\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e 类的数据存储于 \u003ccode\u003echar[]\u003c/code\u003e 数组，这个数组被 \u003ccode\u003efinal\u003c/code\u003e 关键字修饰，表示 \u003cstrong\u003e\u003ccode\u003eString\u003c/code\u003e 对象不可被更改\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e为什么 Java 要这样设计？\u003c/p\u003e\n\u003cp\u003e（1）\u003cstrong\u003e保证 String 对象安全性\u003c/strong\u003e。避免 String 被篡改。\u003c/p\u003e\n\u003cp\u003e（2）\u003cstrong\u003e保证 hash 值不会频繁变更\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e（3）\u003cstrong\u003e可以实现字符串常量池\u003c/strong\u003e。通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 \u003ccode\u003eString str=\u0026#34;abc\u0026#34;;\u003c/code\u003e 另一种是字符串变量通过 new 形式的创建，如 \u003ccode\u003eString str = new String(\u0026#34;abc\u0026#34;)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eString str = new String(\u0026#34;abc\u0026#34;)\u003c/code\u003e 这种方式，首先在编译类文件时，\u003ccode\u003e\u0026#34;abc\u0026#34;\u003c/code\u003e 常量字符串将会放入到常量结构中，在类加载时，\u003ccode\u003e\u0026#34;abc\u0026#34;\u003c/code\u003e 将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 \u003ccode\u003eString\u003c/code\u003e 的构造函数，同时引用常量池中的 \u003ccode\u003e\u0026#34;abc\u0026#34;\u003c/code\u003e 字符串，在堆内存中创建一个 \u003ccode\u003eString\u003c/code\u003e 对象；最后，str 将引用 \u003ccode\u003eString\u003c/code\u003e 对象。\u003c/p\u003e\n\u003ch2 id=\"String-的性能考量\"\u003e\u003ca href=\"#String-的性能考量\" class=\"headerlink\" title=\"String 的性能考量\"\u003e\u003c/a\u003eString 的性能考量\u003c/h2\u003e\u003ch3 id=\"字符串拼接\"\u003e\u003ca href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"\u003e\u003c/a\u003e字符串拼接\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e字符串常量的拼接，编译器会将其优化为一个常量字符串\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e【示例】字符串常量拼接\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// 本行代码在 class 文件中，会被编译器直接优化为：\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// String str = \u0026#34;abc\u0026#34;;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003estr\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e + \u003cspan class=\"string\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e + \u003cspan class=\"string\"\u003e\u0026#34;c\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    System.out.println(\u003cspan class=\"string\"\u003e\u0026#34;str = \u0026#34;\u003c/span\u003e + str);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cstrong\u003e字符串变量的拼接，编译器会优化成 \u003ccode\u003eStringBuilder\u003c/code\u003e 的方式\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e【示例】字符串变量的拼接\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(String[] args)\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eString\u003c/span\u003e \u003cspan class=\"variable\"\u003estr\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e i=\u003cspan class=\"number\"\u003e0\u003c/span\u003e; i\u0026lt;\u003cspan class=\"number\"\u003e1000\u003c/span\u003e; i++) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// 本行代码会被编译器优化为：\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e// str = (new StringBuilder(String.valueOf(str))).append(i).toString();\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        str = str + i;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e但是，每次循环都会生成一个新的 \u003ccode\u003eStringBuilder\u003c/code\u003e 实例，同样也会降低系统的性能。\u003c/p\u003e\n\u003cp\u003e字符串拼接的正确方案：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果需要使用\u003cstrong\u003e字符串拼接，应该优先考虑 \u003ccode\u003eStringBuilder\u003c/code\u003e 的 \u003ccode\u003eappend\u003c/code\u003e 方法替代使用 \u003ccode\u003e+\u003c/code\u003e 号\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e如果在并发编程中，\u003ccode\u003eString\u003c/code\u003e 对象的拼接涉及到线程安全，可以使用 \u003ccode\u003eStringBuffer\u003c/code\u003e。但是要注意，由于 \u003ccode\u003eStringBuffer\u003c/code\u003e 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 \u003ccode\u003eStringBuilder\u003c/code\u003e 差一些。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"字符串分割\"\u003e\u003ca href=\"#字符串分割\" class=\"headerlink\" title=\"字符串分割\"\u003e\u003c/a\u003e字符串分割\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eString\u003c/code\u003e 的 \u003ccode\u003esplit()\u003c/code\u003e 方法使用正则表达式实现其强大的分割功能\u003c/strong\u003e。而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。\u003c/p\u003e\n\u003cp\u003e所以，应该慎重使用 \u003ccode\u003esplit()\u003c/code\u003e 方法，\u003cstrong\u003e可以考虑用 \u003ccode\u003eString.indexOf()\u003c/code\u003e 方法代替 \u003ccode\u003esplit()\u003c/code\u003e 方法完成字符串的分割\u003c/strong\u003e。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。\u003c/p\u003e\n\u003ch3 id=\"String-intern\"\u003e\u003ca href=\"#String-intern\" class=\"headerlink\" title=\"String.intern\"\u003e\u003c/a\u003eString.intern\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e在每次赋值的时候使用 \u003ccode\u003eString\u003c/code\u003e 的 \u003ccode\u003eintern\u003c/code\u003e 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。\u003c/p\u003e\n\u003cp\u003e如果调用 \u003ccode\u003eintern\u003c/code\u003e 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。\u003c/p\u003e\n\u003cp\u003e【示例】\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSharedLocation\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e String city;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e String region;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e String countryCode;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eSharedLocation\u003c/span\u003e \u003cspan class=\"variable\"\u003esharedLocation\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"title class_\"\u003eSharedLocation\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esharedLocation.setCity(messageInfo.getCity().intern());\t\tsharedLocation.setCountryCode(messageInfo.getRegion().intern());\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esharedLocation.setRegion(messageInfo.getCountryCode().intern());\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e使用 \u003ccode\u003eintern\u003c/code\u003e 方法需要注意：一定要结合实际场景。因为常量池的实现是类似于一个 HashTable 的实现方式，HashTable 存储的数据越大，遍历的时间复杂度就会增加。如果数据过大，会增加整个字符串常量池的负担。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"String、StringBuffer、StringBuilder-有什么区别\"\u003e\u003ca href=\"#String、StringBuffer、StringBuilder-有什么区别\" class=\"headerlink\" title=\"String、StringBuffer、StringBuilder 有什么区别\"\u003e\u003c/a\u003eString、StringBuffer、StringBuilder 有什么区别\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eString\u003c/code\u003e 是 Java 语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。它是典型的 \u003ccode\u003eImmutable\u003c/code\u003e 类，被声明成为 \u003ccode\u003efinal class\u003c/code\u003e，所有属性也都是 \u003ccode\u003efinal\u003c/code\u003e 的。也由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 \u003ccode\u003eString\u003c/code\u003e 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStringBuffer\u003c/code\u003e 是为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 \u003ccode\u003eappend\u003c/code\u003e 或者 \u003ccode\u003eadd\u003c/code\u003e 方法，把字符串添加到已有序列的末尾或者指定位置。\u003ccode\u003eStringBuffer\u003c/code\u003e 是一个\u003cstrong\u003e线程安全的\u003c/strong\u003e可修改字符序列。\u003ccode\u003eStringBuffer\u003c/code\u003e 的线程安全是通过在各种修改数据的方法上用 \u003ccode\u003esynchronized\u003c/code\u003e 关键字修饰实现的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStringBuilder\u003c/code\u003e 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去掉了线程安全的部分，有效减小了开销，是绝大部分情况下进行字符串拼接的首选。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eStringBuffer\u003c/code\u003e 和 \u003ccode\u003eStringBuilder\u003c/code\u003e 底层都是利用可修改的（char，JDK 9 以后是 byte）数组，二者都继承了 \u003ccode\u003eAbstractStringBuilder\u003c/code\u003e，里面包含了基本操作，区别仅在于最终的方法是否加了 \u003ccode\u003esynchronized\u003c/code\u003e。构建时初始字符串长度加 16（这意味着，如果没有构建对象时输入最初的字符串，那么初始值就是 16）。我们如果确定拼接会发生非常多次，而且大概是可预计的，那么就可以指定合适的大小，避免很多次扩容的开销。扩容会产生多重开销，因为要抛弃原有数组，创建新的（可以简单认为是倍数）数组，还要进行 \u003ccode\u003earraycopy\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e**除非有线程安全的需要，不然一般都使用 \u003ccode\u003eStringBuilder\u003c/code\u003e**。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/2130190/\"\u003e《Java 编程思想（Thinking in java）》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/26880667/\"\u003e《Java 核心技术 卷 I 基础知识》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100028001\"\u003e《Java 性能调优实战》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/82\"\u003e《Java 核心技术面试精讲》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/59cd71835188255d3448faf6\"\u003eJava 基本数据类型和引用类型\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/dolphin0520/p/3780005.html\"\u003e深入剖析 Java 中的装箱和拆箱\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-12-25T10:43:11Z",
  "Author": "钝悟 ◾ Dunwu"
}