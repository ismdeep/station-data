{
  "Source": "dunwu",
  "Title": "JVM GUI 工具",
  "Link": "https://dunwu.github.io/blog/pages/43a8e5/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"JVM-GUI-工具\"\u003e\u003ca href=\"#JVM-GUI-工具\" class=\"headerlink\" title=\"JVM GUI 工具\"\u003e\u003c/a\u003eJVM GUI 工具\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003eJava 程序员免不了故障排查工作，所以经常需要使用一些 JVM 工具。\u003c/p\u003e\n\u003cp\u003e本文系统性的介绍一下常用的 JVM GUI 工具。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"jconsole\"\u003e\u003ca href=\"#jconsole\" class=\"headerlink\" title=\"jconsole\"\u003e\u003c/a\u003ejconsole\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003ejconsole 是 JDK 自带的 GUI 工具。\u003cstrong\u003ejconsole(Java Monitoring and Management Console) 是一种基于 JMX 的可视化监视与管理工具\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003ejconsole 的管理功能是针对 JMX MBean 进行管理，由于 MBean 可以使用代码、中间件服务器的管理控制台或所有符合 JMX 规范的软件进行访问。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e注意：使用 jconsole 的前提是 Java 应用开启 JMX。\u003c/p\u003e\n\u003ch3 id=\"开启-JMX\"\u003e\u003ca href=\"#开启-JMX\" class=\"headerlink\" title=\"开启 JMX\"\u003e\u003c/a\u003e开启 JMX\u003c/h3\u003e\u003cp\u003eJava 应用开启 JMX 后，可以使用 \u003ccode\u003ejconsole\u003c/code\u003e 或 \u003ccode\u003ejvisualvm\u003c/code\u003e 进行监控 Java 程序的基本信息和运行情况。\u003c/p\u003e\n\u003cp\u003e开启方法是，在 java 指令后，添加以下参数：\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e-Dcom.sun.management.jmxremote=\u003cspan class=\"literal\"\u003etrue\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-Dcom.sun.management.jmxremote.ssl=\u003cspan class=\"literal\"\u003efalse\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-Dcom.sun.management.jmxremote.authenticate=\u003cspan class=\"literal\"\u003efalse\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-Djava.rmi.server.hostname=\u003cspan class=\"number\"\u003e127.0\u003c/span\u003e\u003cspan class=\"number\"\u003e.0\u003c/span\u003e\u003cspan class=\"number\"\u003e.1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-Dcom.sun.management.jmxremote.port=\u003cspan class=\"number\"\u003e18888\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-Djava.rmi.server.hostname\u003c/code\u003e - 指定 Java 程序运行的服务器\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-Dcom.sun.management.jmxremote.port\u003c/code\u003e - 指定 JMX 服务监听端口\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"连接-jconsole\"\u003e\u003ca href=\"#连接-jconsole\" class=\"headerlink\" title=\"连接 jconsole\"\u003e\u003c/a\u003e连接 jconsole\u003c/h3\u003e\u003cp\u003e如果是本地 Java 进程，jconsole 可以直接绑定连接。\u003c/p\u003e\n\u003cp\u003e如果是远程 Java 进程，需要连接 Java 进程的 JMX 端口。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://docs.oracle.com/javase/8/docs/technotes/guides/management/figures/connectadv.gif\" alt=\"Connecting to a JMX Agent Using the JMX Service URL\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"jconsole-界面\"\u003e\u003ca href=\"#jconsole-界面\" class=\"headerlink\" title=\"jconsole 界面\"\u003e\u003c/a\u003ejconsole 界面\u003c/h3\u003e\u003cp\u003e进入 jconsole 应用后，可以看到以下 tab 页面。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e概述\u003c/code\u003e - 显示有关 Java VM 和监视值的概述信息。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e内存\u003c/code\u003e - 显示有关内存使用的信息。内存页相当于可视化的 \u003ccode\u003ejstat\u003c/code\u003e 命令。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e线程\u003c/code\u003e - 显示有关线程使用的信息。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e类\u003c/code\u003e - 显示有关类加载的信息。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eVM 摘要\u003c/code\u003e - 显示有关 Java VM 的信息。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eMBean\u003c/code\u003e - 显示有关 MBean 的信息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730151422.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"jvisualvm\"\u003e\u003ca href=\"#jvisualvm\" class=\"headerlink\" title=\"jvisualvm\"\u003e\u003c/a\u003ejvisualvm\u003c/h2\u003e\u003cblockquote\u003e\n\u003cp\u003ejvisualvm 是 JDK 自带的 GUI 工具。\u003cstrong\u003ejvisualvm(All-In-One Java Troubleshooting Tool) 是多合一故障处理工具\u003c/strong\u003e。它支持运行监视、故障处理、性能分析等功能。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e个人觉得 jvisualvm 比 jconsole 好用。\u003c/p\u003e\n\u003ch3 id=\"jvisualvm-概述页面\"\u003e\u003ca href=\"#jvisualvm-概述页面\" class=\"headerlink\" title=\"jvisualvm 概述页面\"\u003e\u003c/a\u003ejvisualvm 概述页面\u003c/h3\u003e\u003cp\u003ejvisualvm 概述页面可以查看当前 Java 进程的基本信息，如：JDK 版本、Java 进程、JVM 参数等。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730150147.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"jvisualvm-监控页面\"\u003e\u003ca href=\"#jvisualvm-监控页面\" class=\"headerlink\" title=\"jvisualvm 监控页面\"\u003e\u003c/a\u003ejvisualvm 监控页面\u003c/h3\u003e\u003cp\u003e在 jvisualvm 监控页面，可以看到 Java 进程的 CPU、内存、类加载、线程的实时变化。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730150254.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"jvisualvm-线程页面\"\u003e\u003ca href=\"#jvisualvm-线程页面\" class=\"headerlink\" title=\"jvisualvm 线程页面\"\u003e\u003c/a\u003ejvisualvm 线程页面\u003c/h3\u003e\u003cp\u003ejvisualvm 线程页面展示了当前的线程状态。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730150416.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003ejvisualvm 还可以生成线程 Dump 文件，帮助进一步分析线程栈信息。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730150830.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"jvisualvm-抽样器页面\"\u003e\u003ca href=\"#jvisualvm-抽样器页面\" class=\"headerlink\" title=\"jvisualvm 抽样器页面\"\u003e\u003c/a\u003ejvisualvm 抽样器页面\u003c/h3\u003e\u003cp\u003ejvisualvm 可以对 CPU、内存进行抽样，帮助我们进行性能分析。\u003c/p\u003e\n\u003ch2 id=\"MAT\"\u003e\u003ca href=\"#MAT\" class=\"headerlink\" title=\"MAT\"\u003e\u003c/a\u003eMAT\u003c/h2\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.eclipse.org/mat/\"\u003eMAT\u003c/a\u003e 即 Eclipse Memory Analyzer Tool 的缩写。\u003c/p\u003e\n\u003cp\u003eMAT 本身也能够获取堆的二进制快照。该功能将借助 \u003ccode\u003ejps\u003c/code\u003e 列出当前正在运行的 Java 进程，以供选择并获取快照。由于 \u003ccode\u003ejps\u003c/code\u003e 会将自己列入其中，因此你会在列表中发现一个已经结束运行的 \u003ccode\u003ejps\u003c/code\u003e 进程。\u003c/p\u003e\n\u003cp\u003eMAT 可以独立安装（\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.eclipse.org/mat/downloads.php\"\u003e官方下载地址\u003c/a\u003e），也可以作为 Eclipse IDE 的插件安装。\u003c/p\u003e\n\u003ch3 id=\"MAT-配置\"\u003e\u003ca href=\"#MAT-配置\" class=\"headerlink\" title=\"MAT 配置\"\u003e\u003c/a\u003eMAT 配置\u003c/h3\u003e\u003cp\u003eMAT 解压后，安装目录下有个 \u003ccode\u003eMemoryAnalyzer.ini\u003c/code\u003e 文件。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eMemoryAnalyzer.ini\u003c/code\u003e 中有个重要的参数 \u003ccode\u003eXmx\u003c/code\u003e 表示最大内存，默认为：\u003ccode\u003e-vmargs -Xmx1024m\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e如果试图用 MAT 导入的 dump 文件超过 1024 M，会报错：\u003c/p\u003e\n\u003cfigure class=\"highlight shell\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eAn internal error occurred during: \u0026#34;Parsing heap dump from XXX\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此时，可以适当调整 \u003ccode\u003eXmx\u003c/code\u003e 大小。如果设置的 \u003ccode\u003eXmx\u003c/code\u003e 数值过大，本机内存不足以支撑，启动 MAT 会报错：\u003c/p\u003e\n\u003cfigure class=\"highlight livecodeserver\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eFailed \u003cspan class=\"built_in\"\u003eto\u003c/span\u003e \u003cspan class=\"built_in\"\u003ecreate\u003c/span\u003e \u003cspan class=\"keyword\"\u003ethe\u003c/span\u003e Java Virtual Machine\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"MAT-分析\"\u003e\u003ca href=\"#MAT-分析\" class=\"headerlink\" title=\"MAT 分析\"\u003e\u003c/a\u003eMAT 分析\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200308092746.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e点击 Leak Suspects 可以进入内存泄漏页面。\u003c/p\u003e\n\u003cp\u003e（1）首先，可以查看饼图了解内存的整体消耗情况\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200308150556.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e（2）缩小范围，寻找问题疑似点\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://img-blog.csdn.net/20160223202154818\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e可以点击进入详情页面，在详情页面 Shortest Paths To the Accumulation Point 表示 GC root 到内存消耗聚集点的最短路径，如果某个内存消耗聚集点有路径到达 GC root，则该内存消耗聚集点不会被当做垃圾被回收。\u003c/p\u003e\n\u003cp\u003e为了找到内存泄露，我获取了两个堆转储文件，两个文件获取时间间隔是一天（因为内存只是小幅度增长，短时间很难发现问题）。对比两个文件的对象，通过对比后的结果可以很方便定位内存泄露。\u003c/p\u003e\n\u003cp\u003eMAT 同时打开两个堆转储文件，分别打开 Histogram，如下图。在下图中方框 1 按钮用于对比两个 Histogram，对比后在方框 2 处选择 Group By package，然后对比各对象的变化。不难发现 heap3.hprof 比 heap6.hprof 少了 64 个 eventInfo 对象，如果对代码比较熟悉的话想必这样一个结果是能够给程序员一定的启示的。而我也是根据这个启示差找到了最终内存泄露的位置。\u003cbr/\u003e\u003cimg src=\"https://img-blog.csdn.net/20160223203226362\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"JProfile\"\u003e\u003ca href=\"#JProfile\" class=\"headerlink\" title=\"JProfile\"\u003e\u003c/a\u003eJProfile\u003c/h2\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.ej-technologies.com/products/jprofiler/overview.html\"\u003eJProfiler\u003c/a\u003e 是一款性能分析工具。\u003c/p\u003e\n\u003cp\u003e由于它是收费的，所以我本人使用较少。但是，它确实功能强大，且方便使用，还可以和 Intellij Idea 集成。\u003c/p\u003e\n\u003ch2 id=\"Arthas\"\u003e\u003ca href=\"#Arthas\" class=\"headerlink\" title=\"Arthas\"\u003e\u003c/a\u003eArthas\u003c/h2\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/alibaba/arthas\"\u003eArthas\u003c/a\u003e 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。\u003c/p\u003e\n\u003cp\u003eArthas 支持 JDK 6+，支持 Linux/Mac/Windows，采用命令行交互模式，同时提供丰富的 \u003ccode\u003eTab\u003c/code\u003e 自动补全功能，进一步方便进行问题的定位和诊断。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200730145030.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"Arthas-基础命令\"\u003e\u003ca href=\"#Arthas-基础命令\" class=\"headerlink\" title=\"Arthas 基础命令\"\u003e\u003c/a\u003eArthas 基础命令\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003ehelp——查看命令帮助信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/cat.html\"\u003ecat\u003c/a\u003e——打印文件内容，和 linux 里的 cat 命令类似\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/echo.html\"\u003eecho\u003c/a\u003e–打印参数，和 linux 里的 echo 命令类似\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/grep.html\"\u003egrep\u003c/a\u003e——匹配查找，和 linux 里的 grep 命令类似\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/tee.html\"\u003etee\u003c/a\u003e——复制标准输入到标准输出和指定的文件，和 linux 里的 tee 命令类似\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/pwd.html\"\u003epwd\u003c/a\u003e——返回当前的工作目录，和 linux 命令类似\u003c/li\u003e\n\u003cli\u003ecls——清空当前屏幕区域\u003c/li\u003e\n\u003cli\u003esession——查看当前会话的信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/reset.html\"\u003ereset\u003c/a\u003e——重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭时会重置所有增强过的类\u003c/li\u003e\n\u003cli\u003eversion——输出当前目标 Java 进程所加载的 Arthas 版本号\u003c/li\u003e\n\u003cli\u003ehistory——打印命令历史\u003c/li\u003e\n\u003cli\u003equit——退出当前 Arthas 客户端，其他 Arthas 客户端不受影响\u003c/li\u003e\n\u003cli\u003estop——关闭 Arthas 服务端，所有 Arthas 客户端全部退出\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/keymap.html\"\u003ekeymap\u003c/a\u003e——Arthas 快捷键列表及自定义快捷键\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Arthas-jvm-相关命令\"\u003e\u003ca href=\"#Arthas-jvm-相关命令\" class=\"headerlink\" title=\"Arthas jvm 相关命令\"\u003e\u003c/a\u003eArthas jvm 相关命令\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/dashboard.html\"\u003edashboard\u003c/a\u003e——当前系统的实时数据面板\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/thread.html\"\u003ethread\u003c/a\u003e——查看当前 JVM 的线程堆栈信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/jvm.html\"\u003ejvm\u003c/a\u003e——查看当前 JVM 的信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/sysprop.html\"\u003esysprop\u003c/a\u003e——查看和修改 JVM 的系统属性\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/sysenv.html\"\u003esysenv\u003c/a\u003e——查看 JVM 的环境变量\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/vmoption.html\"\u003evmoption\u003c/a\u003e——查看和修改 JVM 里诊断相关的 option\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/perfcounter.html\"\u003eperfcounter\u003c/a\u003e——查看当前 JVM 的 Perf Counter 信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/logger.html\"\u003elogger\u003c/a\u003e——查看和修改 logger\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/getstatic.html\"\u003egetstatic\u003c/a\u003e——查看类的静态属性\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/ognl.html\"\u003eognl\u003c/a\u003e——执行 ognl 表达式\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/mbean.html\"\u003embean\u003c/a\u003e——查看 Mbean 的信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/heapdump.html\"\u003eheapdump\u003c/a\u003e——dump java heap, 类似 jmap 命令的 heap dump 功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Arthas-class-classloader-相关命令\"\u003e\u003ca href=\"#Arthas-class-classloader-相关命令\" class=\"headerlink\" title=\"Arthas class/classloader 相关命令\"\u003e\u003c/a\u003eArthas class/classloader 相关命令\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/sc.html\"\u003esc\u003c/a\u003e——查看 JVM 已加载的类信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/sm.html\"\u003esm\u003c/a\u003e——查看已加载类的方法信息\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/jad.html\"\u003ejad\u003c/a\u003e——反编译指定已加载类的源码\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/mc.html\"\u003emc\u003c/a\u003e——内存编译器，内存编译\u003ccode\u003e.java\u003c/code\u003e文件为\u003ccode\u003e.class\u003c/code\u003e文件\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/redefine.html\"\u003eredefine\u003c/a\u003e——加载外部的\u003ccode\u003e.class\u003c/code\u003e文件，redefine 到 JVM 里\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/dump.html\"\u003edump\u003c/a\u003e——dump 已加载类的 byte code 到特定目录\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/classloader.html\"\u003eclassloader\u003c/a\u003e——查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Arthas-monitor-watch-trace-相关命令\"\u003e\u003ca href=\"#Arthas-monitor-watch-trace-相关命令\" class=\"headerlink\" title=\"Arthas monitor/watch/trace 相关命令\"\u003e\u003c/a\u003eArthas monitor/watch/trace 相关命令\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003e请注意，这些命令，都通过字节码增强技术来实现的，会在指定类的方法中插入一些切面来实现数据统计和观测，因此在线上、预发使用时，请尽量明确需要观测的类、方法以及条件，诊断结束要执行 \u003ccode\u003estop\u003c/code\u003e 或将增强过的类执行 \u003ccode\u003ereset\u003c/code\u003e 命令。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/monitor.html\"\u003emonitor\u003c/a\u003e——方法执行监控\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/watch.html\"\u003ewatch\u003c/a\u003e——方法执行数据观测\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/trace.html\"\u003etrace\u003c/a\u003e——方法内部调用路径，并输出方法路径上的每个节点上耗时\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/stack.html\"\u003estack\u003c/a\u003e——输出当前方法被调用的调用路径\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://alibaba.github.io/arthas/tt.html\"\u003ett\u003c/a\u003e——方法执行数据的时空隧道，记录下指定方法每次调用的入参和返回信息，并能对这些不同的时间下调用进行观测\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/34907497/\"\u003e《深入理解 Java 虚拟机》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100028001\"\u003e《Java 性能调优实战》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/management/jconsole.html\"\u003ejconsole 官方文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/kongzhongqijing/articles/3621441.html\"\u003ejconsole 工具使用\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/visualvm/index.html\"\u003ejvisualvm 官方文档\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/a19881029/article/details/8432368\"\u003eJava jvisualvm 简要说明\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/wanghuiqi2008/article/details/50724676\"\u003e利用内存分析工具（Memory Analyzer Tool，MAT）分析 java 项目内存泄露\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-07-30T09:56:33Z",
  "Author": "钝悟 ◾ Dunwu"
}