{
  "Source": "dunwu",
  "Title": "Mysql 锁",
  "Link": "https://dunwu.github.io/blog/pages/f1f151/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Mysql-锁\"\u003e\u003ca href=\"#Mysql-锁\" class=\"headerlink\" title=\"Mysql 锁\"\u003e\u003c/a\u003eMysql 锁\u003c/h1\u003e\u003cblockquote\u003e\n\u003cp\u003e不同存储引擎对于锁的支持粒度是不同的，由于 InnoDB 是 Mysql 的默认存储引擎，所以本文以 InnoDB 对于锁的支持进行阐述。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/202310162345947.png\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"锁的分类\"\u003e\u003ca href=\"#锁的分类\" class=\"headerlink\" title=\"锁的分类\"\u003e\u003c/a\u003e锁的分类\u003c/h2\u003e\u003cp\u003e为了解决并发一致性问题，Mysql 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。\u003c/p\u003e\n\u003ch3 id=\"独享锁和共享锁\"\u003e\u003ca href=\"#独享锁和共享锁\" class=\"headerlink\" title=\"独享锁和共享锁\"\u003e\u003c/a\u003e独享锁和共享锁\u003c/h3\u003e\u003cp\u003eInnoDB 实现标准行级锁定，根据是否独享资源，可以把锁分为两类：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e独享锁（Exclusive）\u003c/strong\u003e，简写为 X 锁，又称为“\u003cstrong\u003e写锁\u003c/strong\u003e”、“\u003cstrong\u003e排它锁\u003c/strong\u003e”。\u003cul\u003e\n\u003cli\u003e独享锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。\u003c/li\u003e\n\u003cli\u003e使用方式：\u003ccode\u003eSELECT ... FOR UPDATE;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e共享锁（Shared）\u003c/strong\u003e，简写为 S 锁，又称为“\u003cstrong\u003e读锁\u003c/strong\u003e”。\u003cul\u003e\n\u003cli\u003e共享锁锁定的资源可以被其他用户读取，但不能修改。在进行 \u003ccode\u003eSELECT\u003c/code\u003e 的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。\u003c/li\u003e\n\u003cli\u003e使用方式：\u003ccode\u003eSELECT ... LOCK IN SHARE MODE;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e为什么要引入读写锁机制？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e实际上，读写锁是一种通用的锁机制，并非 Mysql 的专利。在很多软件领域，都存在读写锁机制。\u003c/p\u003e\n\u003cp\u003e因为读操作本身是线程安全的，而一般业务往往又是读多写少的情况。因此，如果对读操作进行互斥，是不必要的，并且会大大降低并发访问效率。正式为了应对这种问题，产生了读写锁机制。\u003c/p\u003e\n\u003cp\u003e读写锁的特点是：\u003cstrong\u003e读读不互斥\u003c/strong\u003e、\u003cstrong\u003e读写互斥\u003c/strong\u003e、\u003cstrong\u003e写写互斥\u003c/strong\u003e。简言之：\u003cstrong\u003e只要存在写锁，其他事务就不能做任何操作\u003c/strong\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"悲观锁和乐观锁\"\u003e\u003ca href=\"#悲观锁和乐观锁\" class=\"headerlink\" title=\"悲观锁和乐观锁\"\u003e\u003c/a\u003e悲观锁和乐观锁\u003c/h3\u003e\u003cp\u003e基于加锁方式分类，Mysql 可以分为悲观锁和乐观锁。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e悲观锁\u003c/strong\u003e - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作\u003cul\u003e\n\u003cli\u003e在查询完数据的时候就把事务锁起来，直到提交事务（\u003ccode\u003eCOMMIT\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e实现方式：\u003cstrong\u003e使用数据库中的锁机制\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e乐观锁\u003c/strong\u003e - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。\u003cul\u003e\n\u003cli\u003e实现方式：\u003cstrong\u003e更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e为什么要引入乐观锁？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能\u003c/strong\u003e。那么，为了提高并发度，能不能尽量不加锁呢？\u003c/p\u003e\n\u003cp\u003e乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e乐观锁的\u003cstrong\u003e优点\u003c/strong\u003e是：减少锁竞争，提高并发度。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e乐观锁的\u003cstrong\u003e缺点\u003c/strong\u003e是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存在 ABA 问题\u003c/strong\u003e。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了\u003c/li\u003e\n\u003cli\u003e如果乐观锁所检查的数据存在大量锁竞争，会由于\u003cstrong\u003e不断循环重试，产生大量的 CPU 开销\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e【示例】Mysql 乐观锁示例\u003c/p\u003e\n\u003cp\u003e假设，order 表中有一个字段 status，表示订单状态：status 为 1 代表订单未支付；status 为 2 代表订单已支付。现在，要将 id 为 1 的订单状态置为已支付，则操作如下：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eselect\u003c/span\u003e status, version \u003cspan class=\"keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"keyword\"\u003eorder\u003c/span\u003e \u003cspan class=\"keyword\"\u003ewhere\u003c/span\u003e id\u003cspan class=\"operator\"\u003e=\u003c/span\u003e#{id}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eupdate\u003c/span\u003e \u003cspan class=\"keyword\"\u003eorder\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eset\u003c/span\u003e status\u003cspan class=\"operator\"\u003e=\u003c/span\u003e\u003cspan class=\"number\"\u003e2\u003c/span\u003e, version\u003cspan class=\"operator\"\u003e=\u003c/span\u003eversion\u003cspan class=\"operator\"\u003e+\u003c/span\u003e\u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003ewhere\u003c/span\u003e id\u003cspan class=\"operator\"\u003e=\u003c/span\u003e#{id} \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e version\u003cspan class=\"operator\"\u003e=\u003c/span\u003e#{version};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e乐观锁更多详情可以参考：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/laoyeye/p/8097684.html\"\u003e使用 mysql 乐观锁解决并发问题\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"全局锁、表级锁、行级锁\"\u003e\u003ca href=\"#全局锁、表级锁、行级锁\" class=\"headerlink\" title=\"全局锁、表级锁、行级锁\"\u003e\u003c/a\u003e全局锁、表级锁、行级锁\u003c/h3\u003e\u003cp\u003e前文提到了，\u003cstrong\u003e锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能\u003c/strong\u003e。在不得不加锁的情况下，显然，加锁的范围越小，锁竞争的发生频率就越小，系统的并发程度就越高。但是，加锁也需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销，\u003cstrong\u003e锁粒度越小，系统的锁操作开销就越大\u003c/strong\u003e。因此，在选择锁粒度时，也需要在锁开销和并发程度之间做一个权衡。\u003c/p\u003e\n\u003cp\u003e根据加锁的范围，MySQL 的锁大致可以分为：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e全局锁\u003c/strong\u003e - \u003cstrong\u003e“全局锁”会锁定整个数据库\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e表级锁（table lock）\u003c/strong\u003e - \u003cstrong\u003e“表级锁”锁定整张表\u003c/strong\u003e。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。表级锁有：\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e表锁\u003c/strong\u003e - 表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。表锁一般是在数据库引擎不支持行锁的时候才会被用到的。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e元数据锁（MDL）\u003c/strong\u003e - MDL 不需要显式使用，在访问一个表的时候会被自动加上。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e意向锁（Intention Lock）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e自增锁（AUTO-INC）\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e行级锁（row lock）\u003c/strong\u003e - \u003cstrong\u003e“行级锁”锁定指定的行记录\u003c/strong\u003e。这样其它线程还是可以对同一个表中的其它行记录进行操作。行级锁有：\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e记录锁（Record Lock）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e间隙锁（Gap Lock）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e临键锁（Next-Key Lock）\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e插入意向锁\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以上各种加锁粒度，在不同存储引擎中的支持情况并不相同。如：InnoDB 支持全局锁、表级锁、行级锁；而 MyISAM 只支持全局锁、表级锁。\u003c/p\u003e\n\u003cp\u003e每个层级的锁数量是有限制的，因为锁会占用内存空间，锁空间的大小是有限的。当某个层级的锁数量超过了这个层级的阈值时，就会进行锁升级。锁升级就是用更大粒度的锁替代多个更小粒度的锁，比如 InnoDB 中行锁升级为表锁，这样做的好处是占用的锁空间降低了，但同时数据的并发度也下降了。\u003c/p\u003e\n\u003ch2 id=\"全局锁\"\u003e\u003ca href=\"#全局锁\" class=\"headerlink\" title=\"全局锁\"\u003e\u003c/a\u003e全局锁\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e“全局锁”会锁定整个数据库\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e要给整个数据库加全局锁，可以执行以下命令：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eflush tables \u003cspan class=\"keyword\"\u003ewith\u003c/span\u003e read lock\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e执行命名后，整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。\u003c/p\u003e\n\u003cp\u003e如果要释放全局锁，可以执行以下命令：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eunlock tables\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此外，在客户端断开的时候会自动释放锁。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e全局锁的典型使用场景是，做全库逻辑备份。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 \u003ccode\u003e–single-transaction\u003c/code\u003e 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。对于全部是 InnoDB 引擎的库，建议选择使用 \u003ccode\u003e–single-transaction\u003c/code\u003e 参数，对应用会更友好。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。\u003c/p\u003e\n\u003ch2 id=\"表级锁\"\u003e\u003ca href=\"#表级锁\" class=\"headerlink\" title=\"表级锁\"\u003e\u003c/a\u003e表级锁\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e“表级锁”会锁定整张表\u003c/strong\u003e。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。\u003c/p\u003e\n\u003ch3 id=\"表锁\"\u003e\u003ca href=\"#表锁\" class=\"headerlink\" title=\"表锁\"\u003e\u003c/a\u003e表锁\u003c/h3\u003e\u003cp\u003e表锁就是对数据表进行锁定，锁定粒度很大，同时发生锁冲突的概率也会较高，数据访问的并发度低。不过好处在于对锁的使用开销小，加锁会很快。\u003c/p\u003e\n\u003cp\u003e**表锁的语法是 \u003ccode\u003elock tables … read/write\u003c/code\u003e**，示例如下：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e 为 xxx 表加 MDL 读锁\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elock tables xxx read;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e 为 xxx 表加 MDL 写锁\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elock tables xxx write;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e与 FTWRL 类似，可以用 \u003ccode\u003eunlock tables\u003c/code\u003e 主动释放锁，也可以在客户端断开的时候自动释放。\u003c/p\u003e\n\u003cp\u003e表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现应用程序里有 \u003ccode\u003elock tables\u003c/code\u003e 这样的语句，需要追查一下，比较可能的情况是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；\u003c/li\u003e\n\u003cli\u003e要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 \u003ccode\u003elock tables\u003c/code\u003e 和 \u003ccode\u003eunlock tables\u003c/code\u003e 改成 \u003ccode\u003ebegin\u003c/code\u003e 和 \u003ccode\u003ecommit\u003c/code\u003e，问题就解决了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"元数据锁（MDL）\"\u003e\u003ca href=\"#元数据锁（MDL）\" class=\"headerlink\" title=\"元数据锁（MDL）\"\u003e\u003c/a\u003e元数据锁（MDL）\u003c/h3\u003e\u003cp\u003e元数据锁，英文为 metadata lock，缩写为 MDL。MySQL 5.5 版本中引入了 MDL。MDL 的作用是，保证读写的正确性。\u003cstrong\u003eMDL 不需要显式使用，在访问一个表的时候会被自动加上\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对一个表做“\u003cstrong\u003e增删改查\u003c/strong\u003e”操作的时候，加 \u003cstrong\u003eMDL 读锁\u003c/strong\u003e。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。\u003c/li\u003e\n\u003cli\u003e对一个表做“\u003cstrong\u003e结构变更\u003c/strong\u003e”操作的时候，加 \u003cstrong\u003eMDL 写锁\u003c/strong\u003e。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eMDL 会直到事务提交才释放\u003c/strong\u003e。在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。\u003c/p\u003e\n\u003cp\u003e如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那么在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 \u003ccode\u003eSELECT\u003c/code\u003e 语句，此时就先对该表加上 MDL 读锁；\u003c/li\u003e\n\u003cli\u003e然后，线程 B 也执行了同样的 \u003ccode\u003eSELECT\u003c/code\u003e 语句，此时并不会阻塞，因为“读读”并不冲突；\u003c/li\u003e\n\u003cli\u003e接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e那么在线程 C 阻塞后，后续有对该表的 SELECT 语句，就都会被阻塞。如果此时有大量该表的 SELECT 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这是因为申请 MDL 锁的操作会形成一个队列，队列中\u003cstrong\u003e写锁获取优先级高于读锁\u003c/strong\u003e，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。\u003c/p\u003e\n\u003cp\u003e所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。\u003c/p\u003e\n\u003ch3 id=\"意向锁（Intention-Lock）\"\u003e\u003ca href=\"#意向锁（Intention-Lock）\" class=\"headerlink\" title=\"意向锁（Intention Lock）\"\u003e\u003c/a\u003e意向锁（Intention Lock）\u003c/h3\u003e\u003cp\u003eInnoDB 支持不同粒度的锁定，允许行锁和表锁共存。当存在表级锁和行级锁的情况下，必须先申请意向锁，再获取行级锁。意向锁是表级锁，表示事务稍后需要对表中的行使用哪种类型的锁（共享或独享）。意向锁是 InnoDB 自动添加的，不需要用户干预。\u003c/p\u003e\n\u003cp\u003e意向锁有两种类型：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e意向共享锁（\u003ccode\u003eIS\u003c/code\u003e）\u003c/strong\u003e - 表示事务有意向对表中的行设置共享锁（\u003ccode\u003eS\u003c/code\u003e）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e\u003cstrong\u003e意向独享锁（\u003ccode\u003eIX\u003c/code\u003e）\u003c/strong\u003e - 表示事务有意向对表中的行设置独享锁（\u003ccode\u003eX\u003c/code\u003e）。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e比如 \u003ccode\u003eSELECT ... FOR SHARE\u003c/code\u003e 设置 \u003ccode\u003eIS\u003c/code\u003e 锁， \u003ccode\u003eSELECT ... FOR UPDATE\u003c/code\u003e 设置 \u003ccode\u003eIX\u003c/code\u003e 锁。\u003c/p\u003e\n\u003cp\u003e意向锁的规则如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个事务在获得某个数据行的共享锁（\u003ccode\u003eS\u003c/code\u003e）之前，必须先获得表的意向共享锁（\u003ccode\u003eIS\u003c/code\u003e）或者更强的锁；\u003c/li\u003e\n\u003cli\u003e一个事务在获得某个数据行的独享锁（\u003ccode\u003eX\u003c/code\u003e）之前，必须先获得表的意向独享锁（\u003ccode\u003eIX\u003c/code\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e也就是，当执行插入、更新、删除操作，需要先对表加上 \u003ccode\u003eIX\u003c/code\u003e 锁，然后对该记录加 \u003ccode\u003eX\u003c/code\u003e 锁。而快照读（普通的 \u003ccode\u003eSELECT\u003c/code\u003e）是不会加行级锁的，快照读是利用 MVCC 实现一致性读，是无锁的。\u003c/p\u003e\n\u003cp\u003e不过，\u003ccode\u003eSELECT\u003c/code\u003e 也是可以对记录加共享锁和独享锁的，具体方式如下：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e 先在表上加上 \u003cspan class=\"keyword\"\u003eIS\u003c/span\u003e 锁，然后对读取的记录加 S 锁\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eselect\u003c/span\u003e ... lock \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e share mode;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e\u003cspan class=\"operator\"\u003e/\u003c/span\u003e 当前读：先在表上加上 IX 锁，然后对读取的记录加 X 锁\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eselect\u003c/span\u003e ... \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"keyword\"\u003eupdate\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cstrong\u003e意向共享锁和意向独享锁是表级锁，不会和行级的共享锁和独享锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（\u003ccode\u003elock tables ... read\u003c/code\u003e）和独享表锁（\u003ccode\u003elock tables ... write\u003c/code\u003e）发生冲突\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e如果申请的锁与现有锁兼容，则锁申请成功；反之，则锁申请失败。锁申请失败的情况下，申请锁的事务会一直等待，直到存在冲突的锁被释放。如果存在与申请的锁相冲突的锁，并且该锁迟迟得不到释放，就会导致死锁。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e为什么要引入意向锁？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e如果没有意向锁，那么加独享表锁时，就需要遍历表里所有记录，查看是否有记录存在独享锁，这样效率会很低。\u003c/p\u003e\n\u003cp\u003e有了意向锁，在对记录加独享锁前，会先加上表级别的意向独享锁。此时，如果需要加独享表锁，可以直接查该表是否有意向独享锁：如果有，就意味着表里已经有记录被加了独享锁。这样一来，就不用去遍历表里的记录了。\u003c/p\u003e\n\u003cp\u003e综上所述，\u003cstrong\u003e意向锁的目的是为了快速判断表里是否有记录被加锁\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"自增锁（AUTO-INC）\"\u003e\u003ca href=\"#自增锁（AUTO-INC）\" class=\"headerlink\" title=\"自增锁（AUTO-INC）\"\u003e\u003c/a\u003e自增锁（AUTO-INC）\u003c/h3\u003e\u003cp\u003e表里的主键通常都会设置成自增的，这是通过对主键字段声明 \u003ccode\u003eAUTO_INCREMENT\u003c/code\u003e 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 \u003cstrong\u003eAUTO-INC 锁\u003c/strong\u003e实现的。\u003c/p\u003e\n\u003cp\u003eAUTO-INC 锁是特殊的表级锁，锁\u003cstrong\u003e不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e在插入数据时，会加一个表级别的 AUTO-INC 锁\u003c/strong\u003e，然后为被 \u003ccode\u003eAUTO_INCREMENT\u003c/code\u003e 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。\u003c/p\u003e\n\u003cp\u003e一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 \u003ccode\u003eAUTO_INCREMENT\u003c/code\u003e 修饰的字段的值是连续递增的。但是，AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。\u003c/p\u003e\n\u003cp\u003e因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种\u003cstrong\u003e轻量级的锁\u003c/strong\u003e来实现自增。一样也是在插入数据的时候，会为被 \u003ccode\u003eAUTO_INCREMENT\u003c/code\u003e 修饰的字段加上轻量级锁，\u003cstrong\u003e然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eInnoDB 存储引擎提供了个 \u003ccode\u003einnodb_autoinc_lock_mode\u003c/code\u003e 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当 \u003ccode\u003einnodb_autoinc_lock_mode = 0\u003c/code\u003e，就采用 AUTO-INC 锁，语句执行结束后才释放锁；\u003c/li\u003e\n\u003cli\u003e当 \u003ccode\u003einnodb_autoinc_lock_mode = 2\u003c/code\u003e，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。\u003c/li\u003e\n\u003cli\u003e当 \u003ccode\u003einnodb_autoinc_lock_mode = 1\u003c/code\u003e：\u003cul\u003e\n\u003cli\u003e普通 \u003ccode\u003einsert\u003c/code\u003e 语句，自增锁在申请之后就马上释放；\u003c/li\u003e\n\u003cli\u003e类似 \u003ccode\u003einsert … select\u003c/code\u003e 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以上模式中，\u003ccode\u003einnodb_autoinc_lock_mode = 2\u003c/code\u003e 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在“主从复制的场景”中会发生\u003cstrong\u003e数据不一致的问题\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"行锁\"\u003e\u003ca href=\"#行锁\" class=\"headerlink\" title=\"行锁\"\u003e\u003c/a\u003e行锁\u003c/h2\u003e\u003cp\u003eMySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。\u003c/p\u003e\n\u003cp\u003e在 InnoDB 引擎中，\u003cstrong\u003e行锁是通过给索引上的索引项加锁来实现的\u003c/strong\u003e。\u003cstrong\u003e如果没有索引，\u003ccode\u003eInnoDB\u003c/code\u003e 将会通过隐藏的聚簇索引来对记录加锁\u003c/strong\u003e。此外，在 InnoDB 引擎中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。因此，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。\u003c/p\u003e\n\u003cp\u003e行锁的具体实现算法有三种：Record Lock、Gap Lock 以及 Next-Key Lock。\u003c/p\u003e\n\u003ch3 id=\"记录锁（Record-Lock）\"\u003e\u003ca href=\"#记录锁（Record-Lock）\" class=\"headerlink\" title=\"记录锁（Record Lock）\"\u003e\u003c/a\u003e记录锁（Record Lock）\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e记录锁（Record Lock）锁定一个记录上的索引，而不是记录本身\u003c/strong\u003e。例如，执行 \u003ccode\u003eSELECT value FROM t WHERE value BETWEEN 10 and 20 FOR UPDATE;\u003c/code\u003e 后，会禁止任何其他事务插入、更新或删除 \u003ccode\u003et.value \u003c/code\u003e 值在 10 到 20 范围之内的数据，因为该范围内的所有现有值之间的间隙已被锁定。\u003c/p\u003e\n\u003cp\u003e记录锁始终锁定索引记录，即使表定义为没有索引。如果表没有设置索引，InnoDB 会自动创建一个隐藏的聚簇索引并使用该索引进行记录锁定。\u003c/p\u003e\n\u003cp\u003eRecord Lock 是有 S 锁和 X 锁之分的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;\u003c/li\u003e\n\u003cli\u003e当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e【示例】记录锁示例\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：测试环境的事务隔离级别为可重复级别\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e初始化数据\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 创建表\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eDROP\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e IF \u003cspan class=\"keyword\"\u003eEXISTS\u003c/span\u003e `t`;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e `t` (\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`id` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eNULL\u003c/span\u003e AUTO_INCREMENT,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eDEFAULT\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003ePRIMARY\u003c/span\u003e KEY (`id`)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tENGINE \u003cspan class=\"operator\"\u003e=\u003c/span\u003e InnoDB\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003eDEFAULT\u003c/span\u003e CHARSET \u003cspan class=\"operator\"\u003e=\u003c/span\u003e `utf8`;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 分别插入 id 为 1、10、20 的数据\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e1\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e10\u003c/span\u003e, \u003cspan class=\"number\"\u003e10\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e20\u003c/span\u003e, \u003cspan class=\"number\"\u003e20\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务一、添加 X 型记录锁\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 开启事务\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eBEGIN\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 对 id 为 1 的记录添加 X 型记录锁\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"operator\"\u003e*\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFOR\u003c/span\u003e \u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 延迟 20 秒执行后续语句，保持锁定状态\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e SLEEP(\u003cspan class=\"number\"\u003e20\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 释放锁\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eCOMMIT\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务二、被锁定的行记录无法修改\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 修改 id = 10 的行记录，正常执行\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eSET\u003c/span\u003e `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e10\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 修改 id = 1 的行记录，由于 id = 1 被 X 型记录锁锁定，直到事务一释放锁，方能执行\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eSET\u003c/span\u003e `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"间隙锁（Gap-Lock）\"\u003e\u003ca href=\"#间隙锁（Gap-Lock）\" class=\"headerlink\" title=\"间隙锁（Gap Lock）\"\u003e\u003c/a\u003e间隙锁（Gap Lock）\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e间隙锁（Gap Lock）锁定索引之间的间隙，但是不包含索引本身\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，它们彼此不冲突，不同事务可以在间隙上持有冲突锁，并不存在互斥关系。例如，事务 A 可以在某个间隙上持有 S 型间隙锁，而事务 B 在同一间隙上持有 X 型间隙锁。允许存在冲突间隙锁的原因是：如果从索引中清除记录，则必须合并不同事务在该记录上持有的间隙锁。\u003c/p\u003e\n\u003cp\u003e间隙锁只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。如果将事务隔离级别更改为 读已提交，则间隙锁定对搜索和索引扫描禁用，并且仅用于外键约束检查和重复键检查。\u003c/p\u003e\n\u003cp\u003e在 MySQL 中，间隙锁默认是开启的，即 \u003ccode\u003einnodb_locks_unsafe_for_binlog\u003c/code\u003e 参数值是 \u003ccode\u003edisable\u003c/code\u003e 的，且 MySQL 中默认的是 RR 事务隔离级别。\u003c/p\u003e\n\u003cp\u003e【示例】间隙锁示例\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e注：测试环境的事务隔离级别为可重复级别\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e初始化数据\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 创建表\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eDROP\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e IF \u003cspan class=\"keyword\"\u003eEXISTS\u003c/span\u003e `t`;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e `t` (\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`id` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eNULL\u003c/span\u003e AUTO_INCREMENT,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eDEFAULT\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003ePRIMARY\u003c/span\u003e KEY (`id`)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\tENGINE \u003cspan class=\"operator\"\u003e=\u003c/span\u003e InnoDB\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t\u003cspan class=\"keyword\"\u003eDEFAULT\u003c/span\u003e CHARSET \u003cspan class=\"operator\"\u003e=\u003c/span\u003e `utf8`;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 分别插入 id 为 1、10、20 的数据\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e1\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e10\u003c/span\u003e, \u003cspan class=\"number\"\u003e10\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e20\u003c/span\u003e, \u003cspan class=\"number\"\u003e20\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务一、添加间隙锁\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 开启事务\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eBEGIN\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 对 id 为 1 的记录添加间隙锁\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"operator\"\u003e*\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"keyword\"\u003eBETWEEN\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e \u003cspan class=\"keyword\"\u003eAND\u003c/span\u003e \u003cspan class=\"number\"\u003e10\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFOR\u003c/span\u003e \u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 延迟 20 秒执行后续语句，保持锁定状态\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e SLEEP(\u003cspan class=\"number\"\u003e20\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 释放锁\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eCOMMIT\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务二、被锁定范围内的行记录无法修改\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 插入 id 为 1 到 10 范围之外的数据，正常执行\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e15\u003c/span\u003e, \u003cspan class=\"number\"\u003e15\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 更新 id 为 1 到 10 范围之外的数据，正常执行\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eSET\u003c/span\u003e `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e20\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 插入 id 为 1 到 10 范围之内的数据，被阻塞\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `t`(`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e5\u003c/span\u003e, \u003cspan class=\"number\"\u003e5\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 更新 id 为 1 到 10 范围之内的数据，被阻塞\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eSET\u003c/span\u003e `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e `t` \u003cspan class=\"keyword\"\u003eSET\u003c/span\u003e `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e `id` \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e10\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"临键锁（Next-Key-Lock）\"\u003e\u003ca href=\"#临键锁（Next-Key-Lock）\" class=\"headerlink\" title=\"临键锁（Next-Key Lock）\"\u003e\u003c/a\u003e临键锁（Next-Key Lock）\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e临键锁（Next-Key Lock）是记录锁和间隙锁的结合\u003c/strong\u003e，不仅锁定一个记录上的索引，也锁定索引之间的间隙（它锁定一个前开后闭区间）。\u003c/p\u003e\n\u003cp\u003e假设索引包含值 10、11、13 和 20，那么该索引可能的 Next-Key Lock 涵盖以下区间：\u003c/p\u003e\n\u003cfigure class=\"highlight clojure\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"name\"\u003e\u003cspan class=\"built_in\"\u003e-\u003c/span\u003e\u003c/span\u003e∞\u003cspan class=\"punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"number\"\u003e10\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e\u003cspan class=\"punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"number\"\u003e11\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"number\"\u003e11\u003c/span\u003e\u003cspan class=\"punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"number\"\u003e13\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"number\"\u003e13\u003c/span\u003e\u003cspan class=\"punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"number\"\u003e20\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"number\"\u003e20\u003c/span\u003e\u003cspan class=\"punctuation\"\u003e,\u003c/span\u003e +∞)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e所以，Next-Key Lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。MVCC 不能解决幻读问题，\u003cstrong\u003eNext-Key 锁就是为了解决幻读问题而提出的\u003c/strong\u003e。在可重复读（\u003ccode\u003eREPEATABLE READ\u003c/code\u003e）隔离级别下，使用\u003cstrong\u003eMVCC + Next-Key 锁\u003c/strong\u003e可以解决幻读问题。\u003c/p\u003e\n\u003cp\u003e只有可重复读、串行化隔离级别下的特定操作才会取得间隙锁或 Next-Key Lock。在 \u003ccode\u003eSelect\u003c/code\u003e、\u003ccode\u003eUpdate\u003c/code\u003e 和 \u003ccode\u003eDelete\u003c/code\u003e 时，除了基于唯一索引的查询之外，其它索引查询时都会获取间隙锁或 Next-Key Lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用间隙锁或 Next-Key Lock。\u003c/p\u003e\n\u003cp\u003e索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 \u003ccode\u003eUPDATE\u003c/code\u003e、\u003ccode\u003eDELETE\u003c/code\u003e 操作时，MySQL 不仅锁定 \u003ccode\u003eWHERE\u003c/code\u003e 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 Next-Key Lock。\u003c/p\u003e\n\u003ch3 id=\"插入意向锁\"\u003e\u003ca href=\"#插入意向锁\" class=\"headerlink\" title=\"插入意向锁\"\u003e\u003c/a\u003e插入意向锁\u003c/h3\u003e\u003cp\u003e插入意向锁不是意向锁，而是一种特殊的间隙锁。当一个事务试图插入一条记录时，需要判断插入位置是否已被其他事务加了间隙锁（临键锁（Next-Key Lock 也包含间隙锁）。如果有的话，插入操作就会发生\u003cstrong\u003e阻塞\u003c/strong\u003e，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻）；在此期间，会生成一个\u003cstrong\u003e插入意向锁\u003c/strong\u003e，表明有事务想在某个区间插入新记录，但是现在处于等待状态。\u003c/p\u003e\n\u003cp\u003e假设存在值为 4 和 7 的索引记录。分别尝试插入值 5 和 6 的单独事务在获得插入行上的排他锁之前，每个事务都使用插入意向锁锁定 4 和 7 之间的间隙，但不要互相阻塞，因为行不冲突。\u003c/p\u003e\n\u003cp\u003e【示例】获取插入意向锁\u003c/p\u003e\n\u003cp\u003e初始化数据\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e child (id \u003cspan class=\"type\"\u003eint\u003c/span\u003e(\u003cspan class=\"number\"\u003e11\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eNULL\u003c/span\u003e, \u003cspan class=\"keyword\"\u003ePRIMARY\u003c/span\u003e KEY(id)) ENGINE\u003cspan class=\"operator\"\u003e=\u003c/span\u003eInnoDB;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e child (id) \u003cspan class=\"keyword\"\u003evalues\u003c/span\u003e (\u003cspan class=\"number\"\u003e90\u003c/span\u003e),(\u003cspan class=\"number\"\u003e102\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务 A 对 id 大于 100 的索引记录设置独享锁。独享锁包括了 id=102 之前的间隙锁：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eBEGIN\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"operator\"\u003e*\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e child \u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e id \u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"number\"\u003e100\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFOR\u003c/span\u003e \u003cspan class=\"keyword\"\u003eUPDATE\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e+\u003c/span\u003e\u003cspan class=\"comment\"\u003e-----+\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e|\u003c/span\u003e id  \u003cspan class=\"operator\"\u003e|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e+\u003c/span\u003e\u003cspan class=\"comment\"\u003e-----+\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e|\u003c/span\u003e \u003cspan class=\"number\"\u003e102\u003c/span\u003e \u003cspan class=\"operator\"\u003e|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"operator\"\u003e+\u003c/span\u003e\u003cspan class=\"comment\"\u003e-----+\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e事务 B 将记录插入到间隙中。事务在等待获取独享锁时获取插入意向锁。\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eBEGIN\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emysql\u003cspan class=\"operator\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e child (id) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e101\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"死锁\"\u003e\u003ca href=\"#死锁\" class=\"headerlink\" title=\"死锁\"\u003e\u003c/a\u003e死锁\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e“死锁”是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e产生死锁的场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e多个事务同时锁定同一个资源时，也会产生死锁。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"死锁示例\"\u003e\u003ca href=\"#死锁示例\" class=\"headerlink\" title=\"死锁示例\"\u003e\u003c/a\u003e死锁示例\u003c/h3\u003e\u003cp\u003e（1）数据初始化\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 创建表 test\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eCREATE\u003c/span\u003e \u003cspan class=\"keyword\"\u003eTABLE\u003c/span\u003e `test` (\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`id` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) UNSIGNED \u003cspan class=\"keyword\"\u003ePRIMARY\u003c/span\u003e KEY AUTO_INCREMENT,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\t`\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e` \u003cspan class=\"type\"\u003eINT\u003c/span\u003e(\u003cspan class=\"number\"\u003e10\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eNOT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eNULL\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e-- 数据初始化\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `test` (`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e1\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `test` (`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e2\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `test` (`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e3\u003c/span\u003e, \u003cspan class=\"number\"\u003e3\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e（2）两个事务严格按下表顺序执行，产生死锁\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e事务 A\u003c/th\u003e\n\u003cth\u003e事务 B\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eBEGIN;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eBEGIN;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e– 查询 value = 4 的记录\u003cbr/\u003e\u003ccode\u003eSELECT * FROM test WHERE value = 4 FOR UPDATE;\u003c/code\u003e\u003cbr/\u003e– 结果为空\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e– 查询 value = 5 的记录\u003cbr/\u003e\u003ccode\u003eSELECT * FROM test WHERE value = 5 FOR UPDATE;\u003c/code\u003e\u003cbr/\u003e– 结果为空\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eINSERT INTO test (id, value) VALUES (4, 4);\u003c/code\u003e\u003cbr/\u003e– 锁等待中\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eINSERT INTO test (id, value) VALUES (5, 5);\u003c/code\u003e\u003cbr/\u003e– 锁等待中\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e– 由于死锁无法执行到此步骤\u003cbr/\u003e\u003ccode\u003eCOMMIT;\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e– 由于死锁无法执行到此步骤\u003cbr/\u003e\u003ccode\u003eCOMMIT;\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3 id=\"死锁是如何产生的\"\u003e\u003ca href=\"#死锁是如何产生的\" class=\"headerlink\" title=\"死锁是如何产生的\"\u003e\u003c/a\u003e死锁是如何产生的\u003c/h3\u003e\u003cp\u003e行锁的具体实现算法有三种：Record Lock、Gap Lock 以及 Next-Key Lock。Record Lock 是专门对索引项加锁；Gap Lock 是对索引项之间的间隙加锁；Next-Key Lock 则是前面两种的组合，对索引项以其之间的间隙加锁。\u003c/p\u003e\n\u003cp\u003e只有在可重复读或以上隔离级别下的特定操作才会取得 Gap Lock 或 Next-Key Lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 Gap Lock 或 Next-Key Lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 Gap Lock 或 Next-Key Lock。\u003c/p\u003e\n\u003cp\u003e在 MySQL 中，Gap Lock 默认是开启的，即 \u003ccode\u003einnodb_locks_unsafe_for_binlog\u003c/code\u003e 参数值是 \u003ccode\u003edisable\u003c/code\u003e 的，且 MySQL 中默认的是可重复读事务隔离级别。\u003c/p\u003e\n\u003cp\u003e当我们执行以下查询 SQL 时，由于 \u003ccode\u003evalue\u003c/code\u003e 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 Gap Lock，这里的 gap 范围是 (4,+∞）。\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e \u003cspan class=\"operator\"\u003e*\u003c/span\u003e \u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e test \u003cspan class=\"keyword\"\u003ewhere\u003c/span\u003e \u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e4\u003c/span\u003e \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e \u003cspan class=\"keyword\"\u003eupdate\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e执行查询 SQL 语句获取的 Gap Lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 Gap Lock 是冲突的，所以当其它事务持有该间隙的 Gap Lock 时，需要等待其它事务释放 Gap Lock 之后，才能获取到插入意向锁。\u003c/p\u003e\n\u003cp\u003e以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eINSERT\u003c/span\u003e \u003cspan class=\"keyword\"\u003eINTO\u003c/span\u003e `test` (`id`, `\u003cspan class=\"keyword\"\u003evalue\u003c/span\u003e`) \u003cspan class=\"keyword\"\u003eVALUES\u003c/span\u003e (\u003cspan class=\"number\"\u003e5\u003c/span\u003e, \u003cspan class=\"number\"\u003e5\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200630153139.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e另一个死锁场景\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eInnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154606.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e出现死锁的步骤：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154619.png\" alt=\"img\"/\u003e\u003c/p\u003e\n\u003cp\u003e综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。\u003c/p\u003e\n\u003ch3 id=\"避免死锁\"\u003e\u003ca href=\"#避免死锁\" class=\"headerlink\" title=\"避免死锁\"\u003e\u003c/a\u003e避免死锁\u003c/h3\u003e\u003cp\u003e死锁的四个必要条件：\u003cstrong\u003e互斥、占有且等待、不可强占用、循环等待\u003c/strong\u003e。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e更新表时，\u003cstrong\u003e尽量使用主键更新\u003c/strong\u003e，减少冲突；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e避免长事务\u003c/strong\u003e，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e设置合理的锁等待超时参数\u003c/strong\u003e，我们可以通过 \u003ccode\u003einnodb_lock_wait_timeout\u003c/code\u003e 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。\u003c/li\u003e\n\u003cli\u003e在编程中\u003cstrong\u003e尽量按照固定的顺序来处理数据库记录\u003c/strong\u003e，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；\u003c/li\u003e\n\u003cli\u003e在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；\u003c/li\u003e\n\u003cli\u003e还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"解决死锁\"\u003e\u003ca href=\"#解决死锁\" class=\"headerlink\" title=\"解决死锁\"\u003e\u003c/a\u003e解决死锁\u003c/h3\u003e\u003cp\u003e当出现死锁以后，有两种策略：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e设置事务等待锁的超时时间\u003c/strong\u003e。这个超时时间可以通过参数 \u003ccode\u003einnodb_lock_wait_timeout\u003c/code\u003e 来设置。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e开启死锁检测\u003c/strong\u003e，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 \u003ccode\u003einnodb_deadlock_detect\u003c/code\u003e 设置为 \u003ccode\u003eon\u003c/code\u003e，表示开启这个逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在 InnoDB 中，\u003ccode\u003einnodb_lock_wait_timeout\u003c/code\u003e 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。\u003c/p\u003e\n\u003cp\u003e所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 \u003ccode\u003einnodb_deadlock_detect\u003c/code\u003e 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：\u003cstrong\u003e将持有最少行级排它锁的事务进行回滚\u003c/strong\u003e。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://book.douban.com/subject/23008813/\"\u003e《高性能 MySQL》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/139\"\u003eMySQL 实战 45 讲\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/column/intro/100028001\"\u003e《Java 性能调优实战》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html\"\u003eMysql 官方文档之 InnoDB Locking\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md\"\u003e数据库系统原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5b55b842f265da0f9e589e79\"\u003e数据库两大神器【索引和锁】\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/laoyeye/p/8097684.html\"\u003e使用 mysql 乐观锁解决并发问题\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-09-06T23:54:19Z",
  "Author": "钝悟 ◾ Dunwu"
}