{
  "Source": "dunwu",
  "Title": "Http 缓存",
  "Link": "https://dunwu.github.io/blog/pages/30abaa/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Http-缓存\"\u003e\u003ca href=\"#Http-缓存\" class=\"headerlink\" title=\"Http 缓存\"\u003e\u003c/a\u003eHttp 缓存\u003c/h1\u003e\u003cp\u003eHTTP 缓存分为 2 种，一种是强缓存，另一种是协商缓存。主要作用是可以加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。\u003c/p\u003e\n\u003ch2 id=\"Http-强缓存\"\u003e\u003ca href=\"#Http-强缓存\" class=\"headerlink\" title=\"Http 强缓存\"\u003e\u003c/a\u003eHttp 强缓存\u003c/h2\u003e\u003cp\u003e不需要发送请求到服务端，直接读取浏览器本地缓存，在 Chrome 的 Network 中显示的 HTTP 状态码是 200 ，在 Chrome 中，强缓存又分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，存放的位置是由浏览器控制的。是否强缓存由 \u003ccode\u003eExpires\u003c/code\u003e、\u003ccode\u003eCache-Control\u003c/code\u003e 和 \u003ccode\u003ePragma\u003c/code\u003e 3 个 Header 属性共同来控制。\u003c/p\u003e\n\u003ch3 id=\"Expires\"\u003e\u003ca href=\"#Expires\" class=\"headerlink\" title=\"Expires\"\u003e\u003c/a\u003eExpires\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eExpires\u003c/code\u003e 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。\u003c/p\u003e\n\u003ch3 id=\"Cache-Control\"\u003e\u003ca href=\"#Cache-Control\" class=\"headerlink\" title=\"Cache-Control\"\u003e\u003c/a\u003eCache-Control\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eCache-Control\u003c/code\u003e 是 HTTP/1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emax-age\u003c/code\u003e：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eno-cache\u003c/code\u003e：不使用强缓存，需要与服务器验证缓存是否新鲜\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eno-store\u003c/code\u003e：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprivate\u003c/code\u003e：专用于个人的缓存，中间代理、CDN 等不能缓存此响应\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epublic\u003c/code\u003e：响应可以被中间代理、CDN 等缓存\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emust-revalidate\u003c/code\u003e：在缓存过期前可以使用，过期后必须向服务器验证\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"Pragma\"\u003e\u003ca href=\"#Pragma\" class=\"headerlink\" title=\"Pragma\"\u003e\u003c/a\u003ePragma\u003c/h3\u003e\u003cp\u003e\u003ccode\u003ePragma\u003c/code\u003e 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致，不使用强缓存，需要与服务器验证缓存是否新鲜，在 3 个头部属性中的优先级最高。\u003c/p\u003e\n\u003ch2 id=\"协商缓存\"\u003e\u003ca href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"\u003e\u003c/a\u003e协商缓存\u003c/h2\u003e\u003cp\u003e当浏览器的强缓存失效的时候或者请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。\u003c/p\u003e\n\u003ch3 id=\"ETag-If-None-Match\"\u003e\u003ca href=\"#ETag-If-None-Match\" class=\"headerlink\" title=\"ETag/If-None-Match\"\u003e\u003c/a\u003eETag/If-None-Match\u003c/h3\u003e\u003cp\u003eEtag： 服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）\u003c/p\u003e\n\u003cp\u003eIf-None-Match： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现 If-None-Match 则与被请求资源的唯一标识进行对比。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不同，说明资源被改动过，则响应整个资源内容，返回状态码 200。\u003c/li\u003e\n\u003cli\u003e相同，说明资源无心修改，则响应 header，浏览器直接从缓存中获取数据信息。返回状态码 304.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e但是实际应用中由于 Etag 的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用 Etag 了。\u003c/p\u003e\n\u003ch3 id=\"Last-Modified-If-Modified-Since\"\u003e\u003ca href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified/If-Modified-Since\"\u003e\u003c/a\u003eLast-Modified/If-Modified-Since\u003c/h3\u003e\u003cp\u003eLast-Modified： 服务器在响应请求时，会告诉浏览器资源的最后修改时间。\u003c/p\u003e\n\u003cp\u003eif-Modified-Since: 浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有 if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回 304 和响应报文头，浏览器只需要从缓存中获取信息即可。 从字面上看，就是说：从某个时间节点算起，是否文件被修改了\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK\u003c/li\u003e\n\u003cli\u003e如果没有被修改：那么只需传输响应 header，服务器返回：304 Not Modified\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eif-Unmodified-Since: 从字面上看, 就是说: 从某个时间点算起, 是否文件没有被修改\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果没有被修改:则开始`继续’传送文件: 服务器返回: 200 OK\u003c/li\u003e\n\u003cli\u003e如果文件被修改:则不传输,服务器返回: 412 Precondition failed (预处理错误)\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这两个的区别是一个是修改了才下载一个是没修改才下载。 Last-Modified 说好却也不是特别好，因为如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1 推出了 Etag。\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5eb7f811f265da7bbc7cc5bd\"\u003e图解 HTTP 缓存\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5a1d4e546fb9a0450f21af23\"\u003eHTTP—-HTTP 缓存机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://juejin.im/post/5a6c87c46fb9a01ca560b4d7\"\u003e缓存详解\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-02-17T14:34:30Z",
  "Author": "钝悟 ◾ Dunwu"
}