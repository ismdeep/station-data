{
  "Source": "dunwu",
  "Title": "Spring Bean",
  "Link": "https://dunwu.github.io/blog/pages/68097d/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\u003ch1 id=\"Spring-Bean\"\u003e\u003ca href=\"#Spring-Bean\" class=\"headerlink\" title=\"Spring Bean\"\u003e\u003c/a\u003eSpring Bean\u003c/h1\u003e\u003cp\u003e在 Spring 中，构成应用程序主体由 Spring IoC 容器管理的对象称为 Bean。\u003cstrong\u003eBean 是由 Spring IoC 容器实例化、装配和管理的对象\u003c/strong\u003e。 Bean 以及它们之间的依赖关系反映在容器使用的配置元数据中。\u003c/p\u003e\n\u003ch2 id=\"Spring-Bean-定义\"\u003e\u003ca href=\"#Spring-Bean-定义\" class=\"headerlink\" title=\"Spring Bean 定义\"\u003e\u003c/a\u003eSpring Bean 定义\u003c/h2\u003e\u003ch3 id=\"BeanDefinition\"\u003e\u003ca href=\"#BeanDefinition\" class=\"headerlink\" title=\"BeanDefinition\"\u003e\u003c/a\u003eBeanDefinition\u003c/h3\u003e\u003cp\u003eSpring IoC 容器本身，并不能识别配置的元数据。为此，要将这些配置信息转为 Spring 能识别的格式——\u003ccode\u003eBeanDefinition\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003eBeanDefinition\u003c/code\u003e 是 Spring 中定义 Bean 的配置元信息接口\u003c/strong\u003e，它包含：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBean 类名\u003c/li\u003e\n\u003cli\u003eBean 行为配置元素，如：作用域、自动绑定的模式、生命周期回调等\u003c/li\u003e\n\u003cli\u003e其他 Bean 引用，也可称为合作者（Collaborators）或依赖（Dependencies）\u003c/li\u003e\n\u003cli\u003e配置设置，如 Bean 属性（Properties）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"BeanDefinition-元信息\"\u003e\u003ca href=\"#BeanDefinition-元信息\" class=\"headerlink\" title=\"BeanDefinition 元信息\"\u003e\u003c/a\u003eBeanDefinition 元信息\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eBeanDefinition\u003c/code\u003e 元信息如下：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e属性（Property）\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-class\"\u003eClass\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e全类名，必须是具体类，不能用抽象类或接口\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-beanname\"\u003eName\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 的名称或者 ID\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes\"\u003eScope\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 的作用域（如：\u003ccode\u003esingleton\u003c/code\u003e、\u003ccode\u003eprototype\u003c/code\u003e 等）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators\"\u003eConstructor arguments\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 构造器参数（用于依赖注入）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators\"\u003eProperties\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 属性设置（用于依赖注入）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire\"\u003eAutowiring mode\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 自动绑定模式（如：通过名称 byName）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lazy-init\"\u003eLazy initialization mode\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 延迟初始化模式（延迟和非延迟）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean\"\u003eInitialization method\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 初始化回调方法名称\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-disposablebean\"\u003eDestruction method\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003eBean 销毁回调方法名称\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch4 id=\"BeanDefinition-构建\"\u003e\u003ca href=\"#BeanDefinition-构建\" class=\"headerlink\" title=\"BeanDefinition 构建\"\u003e\u003c/a\u003eBeanDefinition 构建\u003c/h4\u003e\u003cp\u003eBeanDefinition 构建方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e通过 \u003ccode\u003eBeanDefinitionBuilder\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e通过 \u003ccode\u003eAbstractBeanDefinition\u003c/code\u003e 以及派生类\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💻 Spring Bean 定义示例源码：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanDefinitionTests.java\"\u003eBeanDefinitionTests\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"Spring-Bean-命名\"\u003e\u003ca href=\"#Spring-Bean-命名\" class=\"headerlink\" title=\"Spring Bean 命名\"\u003e\u003c/a\u003eSpring Bean 命名\u003c/h3\u003e\u003ch4 id=\"Spring-Bean-命名规则\"\u003e\u003ca href=\"#Spring-Bean-命名规则\" class=\"headerlink\" title=\"Spring Bean 命名规则\"\u003e\u003c/a\u003eSpring Bean 命名规则\u003c/h4\u003e\u003cp\u003e每个 Bean 拥有一个或多个标识符（identifiers），这些标识符在 Bean 所在的容器必须是唯一的。通常，一个 Bean 仅有一个标识符，如果需要额外的，可考虑使用别名（Alias）来扩充。\u003c/p\u003e\n\u003cp\u003e在基于 XML 的配置元信息中，开发人员\u003cstrong\u003e可以使用 \u003ccode\u003eid\u003c/code\u003e 属性、\u003ccode\u003ename\u003c/code\u003e 属性或来指定 Bean 标识符\u003c/strong\u003e。通常，Bean 的标识符由字母组成，允许出现特殊字符。如果要想引入 Bean 的别名的话，可在 \u003ccode\u003ename\u003c/code\u003e 属性使用半角逗号（“,”）或分号（“;”) 来间隔。\u003c/p\u003e\n\u003cp\u003eSpring 中，\u003cstrong\u003e为 Bean 指定 \u003ccode\u003eid\u003c/code\u003e 和 \u003ccode\u003ename\u003c/code\u003e 属性不是必须的\u003c/strong\u003e。如果不指定，Spring 会自动为 Bean 分配一个唯一的名称。尽管 Bean 的命名没有限制，不过\u003cstrong\u003e官方建议采用驼峰命名法来命名 Bean\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4 id=\"Spring-Bean-命名生成器\"\u003e\u003ca href=\"#Spring-Bean-命名生成器\" class=\"headerlink\" title=\"Spring Bean 命名生成器\"\u003e\u003c/a\u003eSpring Bean 命名生成器\u003c/h4\u003e\u003cp\u003eSpring 提供了两种 Spring Bean 命名生成器：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDefaultBeanNameGenerator\u003c/code\u003e：默认通用 \u003ccode\u003eBeanNameGenerator\u003c/code\u003e 实现。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eAnnotationBeanNameGenerator\u003c/code\u003e：基于注解扫描的 \u003ccode\u003eBeanNameGenerator\u003c/code\u003e 实现。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003einterface\u003c/span\u003e \u003cspan class=\"title class_\"\u003eBeanNameGenerator\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   String \u003cspan class=\"title function_\"\u003egenerateBeanName\u003c/span\u003e\u003cspan class=\"params\"\u003e(BeanDefinition definition, BeanDefinitionRegistry registry)\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"Spring-Bean-别名\"\u003e\u003ca href=\"#Spring-Bean-别名\" class=\"headerlink\" title=\"Spring Bean 别名\"\u003e\u003c/a\u003eSpring Bean 别名\u003c/h4\u003e\u003cp\u003eSpring 支持通过 \u003ccode\u003e\u0026lt;alias\u0026gt;\u003c/code\u003e 属性为 Bean 设置别名。\u003c/p\u003e\n\u003cp\u003eBean 别名（Alias）的作用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e复用现有的 \u003ccode\u003eBeanDefinition\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e更具有场景化的命名方法，比如：\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemA-dataSource\u0026#34;/\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;alias name=\u0026#34;myApp-dataSource\u0026#34; alias=\u0026#34;subsystemB-dataSource\u0026#34;/\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003ebean\u003c/span\u003e \u003cspan class=\"attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;user\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;io.github.dunwu.spring.core.bean.entity.person.User\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"comment\"\u003e\u0026lt;!-- 属性略 --\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003ebean\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003ealias\u003c/span\u003e \u003cspan class=\"attr\"\u003ename\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;user\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003ealias\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;aliasUser\u0026#34;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"Spring-Bean-生命周期\"\u003e\u003ca href=\"#Spring-Bean-生命周期\" class=\"headerlink\" title=\"Spring Bean 生命周期\"\u003e\u003c/a\u003eSpring Bean 生命周期\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/dunwu/images/master/snap/20211201102734.png\"/\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003eSpring 对 Bean 进行实例化（相当于 new XXX()）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eSpring 将值和引用注入到 Bean 对应的属性中\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eBeanNameAware\u003c/code\u003e 接口，Spring 将 Bean 的 ID 传递给 \u003ccode\u003esetBeanName\u003c/code\u003e 方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e作用是通过 Bean 的引用来获得 Bean ID，一般业务中是很少有用到 Bean 的 ID 的\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eBeanFactoryAware\u003c/code\u003e 接口，Spring 将调用 \u003ccode\u003esetBeanDactory\u003c/code\u003e 方法，并把 \u003ccode\u003eBeanFactory\u003c/code\u003e 容器实例作为参数传入。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e作用是获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eApplicationContextAware\u003c/code\u003e 接口，Spring 容器将调用 \u003ccode\u003esetApplicationContext\u003c/code\u003e 方法，把应用上下文作为参数传入\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e作用与 \u003ccode\u003eBeanFactory\u003c/code\u003e 类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用 \u003ccode\u003esetApplicationContext\u003c/code\u003e 方法时会把它自己作为 \u003ccode\u003esetApplicationContext\u003c/code\u003e 的参数传入，而 Spring 容器在调用 \u003ccode\u003esetBeanFactory\u003c/code\u003e 前需要使用者自己指定（注入）\u003ccode\u003esetBeanFactory\u003c/code\u003e 里的参数 \u003ccode\u003eBeanFactory\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eBeanPostProcess\u003c/code\u003e 接口，Spring 将调用 \u003ccode\u003epostProcessBeforeInitialization\u003c/code\u003e 方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e作用是在 Bean 实例创建成功后对其进行增强处理，如对 Bean 进行修改，增加某个功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eInitializingBean\u003c/code\u003e 接口，Spring 将调用 \u003ccode\u003eafterPropertiesSet\u003c/code\u003e 方法，作用与在配置文件中对 Bean 使用 \u003ccode\u003einit-method\u003c/code\u003e 声明初始化的作用一样，都是在 Bean 的全部属性设置成功后执行的初始化方法。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eBeanPostProcess\u003c/code\u003e 接口，Spring 将调用 \u003ccode\u003epostProcessAfterInitialization\u003c/code\u003e 方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003epostProcessBeforeInitialization\u003c/code\u003e 是在 Bean 初始化前执行的，而 \u003ccode\u003epostProcessAfterInitialization\u003c/code\u003e 是在 Bean 初始化后执行的\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e经过以上的工作后，Bean 将一直驻留在应用上下文中给应用使用，直到应用上下文被销毁\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e如果 Bean 实现了 \u003ccode\u003eDispostbleBean\u003c/code\u003e 接口，Spring 将调用它的 \u003ccode\u003edestory\u003c/code\u003e 方法，作用与在配置文件中对 Bean 使用 \u003ccode\u003edestory-method\u003c/code\u003e 属性的作用一样，都是在 Bean 实例销毁前执行的方法。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"Spring-Bean-注册\"\u003e\u003ca href=\"#Spring-Bean-注册\" class=\"headerlink\" title=\"Spring Bean 注册\"\u003e\u003c/a\u003eSpring Bean 注册\u003c/h2\u003e\u003cp\u003e注册 Spring Bean 实际上是将 \u003ccode\u003eBeanDefinition\u003c/code\u003e 注册到 IoC 容器中。\u003c/p\u003e\n\u003ch3 id=\"XML-配置元信息\"\u003e\u003ca href=\"#XML-配置元信息\" class=\"headerlink\" title=\"XML 配置元信息\"\u003e\u003c/a\u003eXML 配置元信息\u003c/h3\u003e\u003cp\u003eSpring 的传统配置方式。在 \u003ccode\u003e\u0026lt;bean\u0026gt;\u003c/code\u003e 标签中配置元数据内容。\u003c/p\u003e\n\u003cp\u003e缺点是当 JavaBean 过多时，产生的配置文件足以让你眼花缭乱。\u003c/p\u003e\n\u003ch3 id=\"注解配置元信息\"\u003e\u003ca href=\"#注解配置元信息\" class=\"headerlink\" title=\"注解配置元信息\"\u003e\u003c/a\u003e注解配置元信息\u003c/h3\u003e\u003cp\u003e使用 \u003ccode\u003e@Bean\u003c/code\u003e、\u003ccode\u003e@Component\u003c/code\u003e、\u003ccode\u003e@Import\u003c/code\u003e 注解注册 Spring Bean。\u003c/p\u003e\n\u003ch3 id=\"Java-API-配置元信息\"\u003e\u003ca href=\"#Java-API-配置元信息\" class=\"headerlink\" title=\"Java API 配置元信息\"\u003e\u003c/a\u003eJava API 配置元信息\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e命名方式：\u003ccode\u003eBeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e非命名方式：\u003ccode\u003eBeanDefinitionReaderUtils#registerWithGeneratedName(AbstractBeanDefinition,BeanDefinitionRegistry)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e配置类方式：\u003ccode\u003eAnnotatedBeanDefinitionReader#register(Class...)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💻 Spring Bean 注册示例源码：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanRegistryTests.java\"\u003eBeanRegistryTests\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Spring-Bean-实例化\"\u003e\u003ca href=\"#Spring-Bean-实例化\" class=\"headerlink\" title=\"Spring Bean 实例化\"\u003e\u003c/a\u003eSpring Bean 实例化\u003c/h2\u003e\u003cp\u003eSpring Bean 实例化方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e常规方式\u003cul\u003e\n\u003cli\u003e通过构造器（配置元信息：XML、Java 注解和 Java API）\u003c/li\u003e\n\u003cli\u003e通过静态方法（配置元信息：XML、Java 注解和 Java API）\u003c/li\u003e\n\u003cli\u003e通过 Bean 工厂方法（配置元信息：XML、Java 注解和 Java API）\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eFactoryBean\u003c/code\u003e（配置元信息：XML、Java 注解和 Java API）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e特殊方式\u003cul\u003e\n\u003cli\u003e通过 \u003ccode\u003eServiceLoaderFactoryBean\u003c/code\u003e（配置元信息：XML、Java 注解和 Java API ）\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eAutowireCapableBeanFactory#createBean(java.lang.Class, int, boolean)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e通过 \u003ccode\u003eBeanDefinitionRegistry#registerBeanDefinition(String,BeanDefinition)\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💻 Spring Bean 实例化示例源码：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInstantiationTests.java\"\u003eBeanInstantiationTests\u003c/a\u003e、\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInstantiationSpecialTests.java\"\u003eBeanInstantiationSpecialTests\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Spring-Bean-初始化和销毁\"\u003e\u003ca href=\"#Spring-Bean-初始化和销毁\" class=\"headerlink\" title=\"Spring Bean 初始化和销毁\"\u003e\u003c/a\u003eSpring Bean 初始化和销毁\u003c/h2\u003e\u003cp\u003eSpring Bean 初始化和销毁的方式有以下几种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cp\u003e使用 \u003ccode\u003e@PostConstruct\u003c/code\u003e 和 \u003ccode\u003e@PreDestroy\u003c/code\u003e 注解分别指定相应的初始化方法和销毁方法。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e实现 \u003ccode\u003eInitializingBean\u003c/code\u003e 接口的 \u003ccode\u003eafterPropertiesSet()\u003c/code\u003e 方法来编写初始化方法；实现 \u003ccode\u003eDisposableBean\u003c/code\u003e 接口的 \u003ccode\u003edestroy()\u003c/code\u003e 方法来编写销毁方法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eInitializingBean\u003c/code\u003e 接口包含一个 \u003ccode\u003eafterPropertiesSet\u003c/code\u003e 方法，可以通过实现该接口，然后在这个方法中编写初始化逻辑。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDisposableBean\u003c/code\u003e接口包含一个 \u003ccode\u003edestory\u003c/code\u003e 方法，可以通过实现该接口，然后在这个方法中编写销毁逻辑。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e自定义初始化方法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eXML 配置：\u003ccode\u003e\u0026lt;bean init-method=\u0026#34;init\u0026#34; destroy=\u0026#34;destroy\u0026#34; ... /\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eJava 注解：\u003ccode\u003e@Bean(initMethod = \u0026#34;init\u0026#34;, destroyMethod = \u0026#34;destroy\u0026#34;)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eJava API：\u003ccode\u003eAbstractBeanDefinition#setInitMethodName(String)\u003c/code\u003e 和 \u003ccode\u003eAbstractBeanDefinition#setDestroyMethodName(String)\u003c/code\u003e 分别定义初始化和销毁方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e注意：如果同时存在，执行顺序会按照序列执行。\u003c/p\u003e\n\u003cp\u003eBean 的延迟初始化\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003exml 方式：\u003ccode\u003e\u0026lt;bean lazy-init=\u0026#34;true\u0026#34; ... /\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e注解方式：\u003ccode\u003e@Lazy\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSpring 提供了一个 \u003ccode\u003eBeanPostProcessor\u003c/code\u003e 接口，提供了两个方法 \u003ccode\u003epostProcessBeforeInitialization\u003c/code\u003e 和 \u003ccode\u003epostProcessAfterInitialization\u003c/code\u003e。其中\u003ccode\u003epostProcessBeforeInitialization\u003c/code\u003e 在组件的初始化方法调用之前执行，\u003ccode\u003epostProcessAfterInitialization\u003c/code\u003e 在组件的初始化方法调用之后执行。它们都包含两个入参：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebean\u003c/code\u003e：当前组件对象；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebeanName\u003c/code\u003e：当前组件在容器中的名称。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e💻 Spring Bean 初始化和销毁示例源码：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/dunwu/spring-tutorial/blob/master/codes/core/spring-core-ioc/src/test/java/io/github/dunwu/spring/core/bean/BeanInitDestroyTests.java\"\u003eBeanInitDestroyTests\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"Spring-Bean-垃圾回收\"\u003e\u003ca href=\"#Spring-Bean-垃圾回收\" class=\"headerlink\" title=\"Spring Bean 垃圾回收\"\u003e\u003c/a\u003eSpring Bean 垃圾回收\u003c/h2\u003e\u003cp\u003eSpring Bean 垃圾回收步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e关闭 Spring 容器（应用上下文）\u003c/li\u003e\n\u003cli\u003e执行 GC\u003c/li\u003e\n\u003cli\u003eSpring Bean 覆盖的 \u003ccode\u003efinalize()\u003c/code\u003e 方法被回调\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"Spring-Bean-作用范围\"\u003e\u003ca href=\"#Spring-Bean-作用范围\" class=\"headerlink\" title=\"Spring Bean 作用范围\"\u003e\u003c/a\u003eSpring Bean 作用范围\u003c/h2\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth align=\"left\"\u003eScope\u003c/th\u003e\n\u003cth align=\"left\"\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton\"\u003esingleton\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003e(Default) Scopes a single bean definition to a single object instance for each Spring IoC container.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-prototype\"\u003eprototype\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eScopes a single bean definition to any number of object instances.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-request\"\u003erequest\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eScopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring \u003ccode\u003eApplicationContext\u003c/code\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-session\"\u003esession\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eScopes a single bean definition to the lifecycle of an HTTP \u003ccode\u003eSession\u003c/code\u003e. Only valid in the context of a web-aware Spring \u003ccode\u003eApplicationContext\u003c/code\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-application\"\u003eapplication\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eScopes a single bean definition to the lifecycle of a \u003ccode\u003eServletContext\u003c/code\u003e. Only valid in the context of a web-aware Spring \u003ccode\u003eApplicationContext\u003c/code\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd align=\"left\"\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#websocket-stomp-websocket-scope\"\u003ewebsocket\u003c/a\u003e\u003c/td\u003e\n\u003ctd align=\"left\"\u003eScopes a single bean definition to the lifecycle of a \u003ccode\u003eWebSocket\u003c/code\u003e. Only valid in the context of a web-aware Spring \u003ccode\u003eApplicationContext\u003c/code\u003e.\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans\"\u003eSpring 官方文档之 Core Technologies\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://time.geekbang.org/course/intro/265\"\u003e《小马哥讲 Spring 核心编程思想》\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-12-10T11:15:42Z",
  "Author": "钝悟 ◾ Dunwu"
}