{
  "Source": "go.dev",
  "Title": "go fmt your code",
  "Link": "https://go.dev/blog/gofmt",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/gofmt\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003ego fmt your code\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      23 January 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/cmd/gofmt/\"\u003eGofmt\u003c/a\u003e is a tool that automatically formats Go source code.\u003c/p\u003e\n\u003cp\u003eGofmt’d code is:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eeasier to \u003cstrong\u003ewrite\u003c/strong\u003e: never worry about minor formatting concerns while hacking away,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eeasier to \u003cstrong\u003eread\u003c/strong\u003e: when all code looks the same you need not mentally convert\nothers’ formatting style into something you can understand.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eeasier to \u003cstrong\u003emaintain\u003c/strong\u003e: mechanical changes to the source don’t cause unrelated\nchanges to the file’s formatting;\ndiffs show only the real changes.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003euncontroversial\u003c/strong\u003e: never have a debate about spacing or brace position ever again!\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"format-your-code\"\u003eFormat your code\u003c/h2\u003e\n\u003cp\u003eWe recently conducted a survey of Go packages in the wild and found that\nabout 70% of them are formatted according to gofmt’s rules.\nThis was more than expected - and thanks to everyone who uses gofmt - but\nit would be great to close the gap.\u003c/p\u003e\n\u003cp\u003eTo format your code, you can use the gofmt tool directly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egofmt -w yourcode.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr you can use the “\u003ca href=\"/cmd/go/#hdr-Gofmt__reformat__package_sources\"\u003ego fmt\u003c/a\u003e” command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego fmt path/to/your/package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo help keep your code in the canonical style,\nthe Go repository contains hooks for editors and version control systems\nthat make it easy to run gofmt on your code.\u003c/p\u003e\n\u003cp\u003eFor Vim users, the \u003ca href=\"https://github.com/fatih/vim-go\" rel=\"noreferrer\" target=\"_blank\"\u003eVim plugin for Go\u003c/a\u003e\nincludes the :Fmt command that runs gofmt on the current buffer.\u003c/p\u003e\n\u003cp\u003eFor emacs users, \u003ca href=\"https://github.com/dominikh/go-mode.el\" rel=\"noreferrer\" target=\"_blank\"\u003ego-mode.el\u003c/a\u003e\nprovides a gofmt-before-save hook that can be installed by adding this line\nto your .emacs file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(add-hook \u0026#39;before-save-hook #\u0026#39;gofmt-before-save)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor Eclipse or Sublime Text users, the \u003ca href=\"https://github.com/GoClipse/goclipse\" rel=\"noreferrer\" target=\"_blank\"\u003eGoClipse\u003c/a\u003e\nand \u003ca href=\"https://github.com/DisposaBoy/GoSublime\" rel=\"noreferrer\" target=\"_blank\"\u003eGoSublime\u003c/a\u003e projects add\na gofmt facility to those editors.\u003c/p\u003e\n\u003cp\u003eAnd for Git aficionados, the \u003ca href=\"https://github.com/golang/go/blob/release-branch.go1.1/misc/git/pre-commit\" rel=\"noreferrer\" target=\"_blank\"\u003emisc/git/pre-commit script\u003c/a\u003e\nis a pre-commit hook that prevents incorrectly-formatted Go code from being committed.\nIf you use Mercurial, the \u003ca href=\"https://bitbucket.org/fhs/hgstyle/overview\" rel=\"noreferrer\" target=\"_blank\"\u003ehgstyle plugin\u003c/a\u003e\nprovides a gofmt pre-commit hook.\u003c/p\u003e\n\u003ch2 id=\"mechanical-source-transformation\"\u003eMechanical source transformation\u003c/h2\u003e\n\u003cp\u003eOne of the greatest virtues of machine-formatted code is that it can be\ntransformed mechanically without generating unrelated formatting noise in the diffs.\nMechanical transformation is invaluable when working with large code bases,\nas it is both more comprehensive and less error prone than making wide-sweeping changes by hand.\nIndeed, when working at scale (like we do at Google) it often isn’t practical\nto make these kinds of changes manually.\u003c/p\u003e\n\u003cp\u003eThe easiest way to mechanically manipulate Go code is with gofmt’s -r flag.\nThe flag specifies a rewrite rule of the form\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epattern -\u0026gt; replacement\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere both pattern and replacement are valid Go expressions.\nIn the pattern, single-character lowercase identifiers serve as wildcards\nmatching arbitrary sub-expressions,\nand those expressions are substituted for the same identifiers in the replacement.\u003c/p\u003e\n\u003cp\u003eFor example, this\u003ca href=\"/cl/7038051\"\u003e recent change\u003c/a\u003e to the\nGo core rewrote some uses of \u003ca href=\"/pkg/bytes/#Compare\"\u003ebytes.Compare\u003c/a\u003e\nto use the more efficient \u003ca href=\"/pkg/bytes/#Equal\"\u003ebytes.Equal\u003c/a\u003e.\nThe contributor made the change using just two gofmt invocations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egofmt -r \u0026#39;bytes.Compare(a, b) == 0 -\u0026gt; bytes.Equal(a, b)\u0026#39;\ngofmt -r \u0026#39;bytes.Compare(a, b) != 0 -\u0026gt; !bytes.Equal(a, b)\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGofmt also enables \u003ca href=\"/cmd/fix/\"\u003egofix\u003c/a\u003e,\nwhich can make arbitrarily complex source transformations.\nGofix was an invaluable tool during the early days when we regularly made\nbreaking changes to the language and libraries.\nFor example, before Go 1 the built-in error interface didn’t exist and the\nconvention was to use the os.Error type.\nWhen we \u003ca href=\"/doc/go1.html#errors\"\u003eintroduced error\u003c/a\u003e,\nwe provided a gofix module that rewrote all references to os.Error and its\nassociated helper functions to use error and the new \u003ca href=\"/pkg/errors/\"\u003eerrors package\u003c/a\u003e.\nIt would have been daunting to attempt by hand,\nbut with the code in a standard format it was relatively easy to prepare,\nexecute, and review this change which touched almost all Go code in existence.\u003c/p\u003e\n\u003cp\u003eFor more about gofix, see \u003ca href=\"/blog/introducing-gofix\"\u003ethis article\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-01-23T00:00:00Z",
  "Author": "Andrew Gerrand"
}