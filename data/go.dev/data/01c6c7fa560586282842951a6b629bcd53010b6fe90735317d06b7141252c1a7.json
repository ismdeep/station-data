{
  "Source": "go.dev",
  "Title": "Introducing Gofix",
  "Link": "https://go.dev/blog/introducing-gofix",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/introducing-gofix\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eIntroducing Gofix\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      15 April 2011\n      \u003c/p\u003e\n      \n      \u003cp\u003eThe next Go release will include significant API changes in several fundamental Go packages.\nCode that \u003ca href=\"http://codereview.appspot.com/4239076\" rel=\"noreferrer\" target=\"_blank\"\u003eimplements an HTTP server handler\u003c/a\u003e,\n\u003ca href=\"http://codereview.appspot.com/4244055\" rel=\"noreferrer\" target=\"_blank\"\u003ecalls \u003ccode\u003enet.Dial\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"http://codereview.appspot.com/4357052\" rel=\"noreferrer\" target=\"_blank\"\u003ecalls \u003ccode\u003eos.Open\u003c/code\u003e\u003c/a\u003e,\nor \u003ca href=\"http://codereview.appspot.com/4281055\" rel=\"noreferrer\" target=\"_blank\"\u003euses the reflect package\u003c/a\u003e will\nnot build unless it is updated to use the new APIs.\nNow that our releases are \u003ca href=\"/blog/go-becomes-more-stable\"\u003emore stable and less frequent\u003c/a\u003e,\nthis will be a common situation.\nEach of these API changes happened in a different weekly snapshot and might\nhave been manageable on its own;\ntogether, however, they represent a significant amount of manual effort\nto update existing code.\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/cmd/fix/\"\u003eGofix\u003c/a\u003e is a new tool that reduces the amount\nof effort it takes to update existing code.\nIt reads a program from a source file, looks for uses of old APIs,\nrewrites them to use the current API, and writes the program back to the file.\nNot all API changes preserve all the functionality of an old API,\nso gofix cannot always do a perfect job.\nWhen gofix cannot rewrite a use of an old API,\nit prints a warning giving the file name and line number of the use,\nso that a developer can examine and rewrite the code.\nGofix takes care of the easy, repetitive,\ntedious changes, so that a developer can focus on the ones that truly merit attention.\u003c/p\u003e\n\u003cp\u003eEach time we make a significant API change we’ll add code to gofix to\ntake care of the conversion,\nas much as mechanically possible.\nWhen you update to a new Go release and your code no longer builds,\njust run gofix on your source directory.\u003c/p\u003e\n\u003cp\u003eYou can extend gofix to support changes to your own APIs.\nThe gofix program is a simple driver around plugins called fixes that each\nhandle a particular API change.\nRight now, writing a new fix requires doing some scanning and rewriting\nof the go/ast syntax tree,\nusually in proportion to how complex the API changes are.\nIf you want to explore, the \u003ca href=\"https://go.googlesource.com/go/+/go1/src/cmd/fix/netdial.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003enetdialFix\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://go.googlesource.com/go/+/go1/src/cmd/fix/osopen.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eosopenFix\u003c/code\u003e\u003c/a\u003e,\n\u003ca href=\"https://go.googlesource.com/go/+/go1/src/cmd/fix/httpserver.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ehttpserverFix\u003c/code\u003e\u003c/a\u003e,\nand \u003ca href=\"https://go.googlesource.com/go/+/go1/src/cmd/fix/reflect.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ereflectFix\u003c/code\u003e\u003c/a\u003e\nare all illustrative examples,\nin increasing order of complexity.\u003c/p\u003e\n\u003cp\u003eWe write Go code too, of course, and our code is just as affected by these\nAPI changes as yours.\nTypically, we write the gofix support at the same time as the API change\nand then use gofix to rewrite the uses in the main source tree.\nWe use gofix to update other Go code bases and our personal projects.\nWe even use gofix to update Google’s internal source tree when it is time\nto build against a new Go release.\u003c/p\u003e\n\u003cp\u003eAs an example, gofix can rewrite code like \u003ca href=\"http://codereview.appspot.com/4353043/diff/10001/src/pkg/fmt/print.go#newcode657\" rel=\"noreferrer\" target=\"_blank\"\u003ethis snippet from \u003ccode\u003efmt/print.go\u003c/code\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eswitch f := value.(type) {\ncase *reflect.BoolValue:\n    p.fmtBool(f.Get(), verb, field)\ncase *reflect.IntValue:\n    p.fmtInt64(f.Get(), verb, field)\n// ...\ncase reflect.ArrayOrSliceValue:\n    // Byte slices are special.\n    if f.Type().(reflect.ArrayOrSliceType).Elem().Kind() == reflect.Uint8 {\n        // ...\n    }\n// ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eto adapt it to the new reflect API:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eswitch f := value; f.Kind() {\ncase reflect.Bool:\n    p.fmtBool(f.Bool(), verb, field)\ncase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n    p.fmtInt64(f.Int(), verb, field)\n// ...\ncase reflect.Array, reflect.Slice:\n    // Byte slices are special.\n    if f.Type().Elem().Kind() == reflect.Uint8 {\n        // ...\n    }\n// ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNearly every line above changed in some small way.\nThe changes involved in the rewrite are extensive but nearly entirely mechanical,\njust the kind of thing that computers are great at doing.\u003c/p\u003e\n\u003cp\u003eGofix is possible because Go has support in its standard libraries for \u003ca href=\"/pkg/go/parser\"\u003eparsing Go source files into syntax trees\u003c/a\u003e\nand also for \u003ca href=\"/pkg/go/printer\"\u003eprinting those syntax trees back to Go source code\u003c/a\u003e.\nImportantly, the Go printing library prints a program in the official format\n(typically enforced via the gofmt tool),\nallowing gofix to make mechanical changes to Go programs without causing\nspurious formatting changes.\nIn fact, one of the key motivations for creating gofmt—perhaps second\nonly to avoiding debates about where a particular brace belongs—was to\nsimplify the creation of tools that rewrite Go programs, as gofix does.\u003c/p\u003e\n\u003cp\u003eGofix has already made itself indispensable.\nIn particular, the recent reflect changes would have been unpalatable without\nautomated conversion,\nand the reflect API badly needed to be redone.\nGofix gives us the ability to fix mistakes or completely rethink package\nAPIs without worrying about the cost of converting existing code.\nWe hope you find gofix as useful and convenient as we have.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-04-15T00:00:00Z",
  "Author": "Russ Cox"
}