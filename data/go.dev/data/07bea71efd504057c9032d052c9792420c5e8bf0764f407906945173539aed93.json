{
  "Source": "go.dev",
  "Title": "Why Generics?",
  "Link": "https://go.dev/blog/why-generics",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/why-generics\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eWhy Generics?\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Ian Lance Taylor\u003cbr/\u003e\n      31 July 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is the blog post version of my talk last week at Gophercon 2019.\u003c/p\u003e\n\u003cdiv class=\"iframe\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/WzgLqE-3IhY?rel=0\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" mozallowfullscreen=\"\" webkitallowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003cp\u003eThis article is about what it would mean to add generics to Go, and\nwhy I think we should do it.\nI’ll also touch on an update to a possible design for\nadding generics to Go.\u003c/p\u003e\n\u003cp\u003eGo was released on November 10, 2009.\nLess than 24 hours later we saw the\n\u003ca href=\"https://groups.google.com/d/msg/golang-nuts/70-pdwUUrbI/onMsQspcljcJ\" rel=\"noreferrer\" target=\"_blank\"\u003efirst comment about generics\u003c/a\u003e.\n(That comment also mentions exceptions, which we added to the\nlanguage, in the form of \u003ccode\u003epanic\u003c/code\u003e and \u003ccode\u003erecover\u003c/code\u003e, in early 2010.)\u003c/p\u003e\n\u003cp\u003eIn three years of Go surveys, lack of generics has always been listed\nas one of the top three problems to fix in the language.\u003c/p\u003e\n\u003ch2 id=\"why-generics\"\u003eWhy generics?\u003c/h2\u003e\n\u003cp\u003eBut what does it mean to add generics, and why would we want it?\u003c/p\u003e\n\u003cp\u003eTo paraphrase\n\u003ca href=\"https://www.dagstuhl.de/en/program/calendar/semhp/?semnr=98171\" rel=\"noreferrer\" target=\"_blank\"\u003eJazayeri, et al\u003c/a\u003e:\ngeneric programming enables the representation of functions and data\nstructures in a generic form, with types factored out.\u003c/p\u003e\n\u003cp\u003eWhat does that mean?\u003c/p\u003e\n\u003cp\u003eFor a simple example, let’s assume we want to reverse the elements in\na slice.\nIt’s not something that many programs need to do, but it’s\nnot all that unusual.\u003c/p\u003e\n\u003cp\u003eLet’s say it’s a slice of int.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReverseInts(s []int) {\n    first := 0\n    last := len(s)\n    for first \u0026lt; last {\n        s[first], s[last] = s[last], s[first]\n        first++\n        last--\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePretty simple, but even for a simple function like that you’d want to\nwrite a few test cases.\nIn fact, when I did, I found a bug.\nI’m sure many readers have spotted it already.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReverseInts(s []int) {\n    first := 0\n    last := len(s) - 1\n    for first \u0026lt; last {\n        s[first], s[last] = s[last], s[first]\n        first++\n        last--\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe need to subtract 1 when we set the variable last.\u003c/p\u003e\n\u003cp\u003eNow let’s reverse a slice of string.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReverseStrings(s []string) {\n    first := 0\n    last := len(s) - 1\n    for first \u0026lt; last {\n        s[first], s[last] = s[last], s[first]\n        first++\n        last--\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you compare \u003ccode\u003eReverseInts\u003c/code\u003e and \u003ccode\u003eReverseStrings\u003c/code\u003e, you’ll see that the\ntwo functions are exactly the same, except for the type of the parameter.\nI don’t think any reader is surprised by that.\u003c/p\u003e\n\u003cp\u003eWhat some people new to Go find surprising is that there is no way to\nwrite a simple \u003ccode\u003eReverse\u003c/code\u003e function that works for a slice of any type.\u003c/p\u003e\n\u003cp\u003eMost other languages do let you write that kind of function.\u003c/p\u003e\n\u003cp\u003eIn a dynamically typed language like Python or JavaScript you can\nsimply write the function, without bothering to specify the element\ntype.  This doesn’t work in Go because Go is statically typed, and\nrequires you to write down the exact type of the slice and the type of\nthe slice elements.\u003c/p\u003e\n\u003cp\u003eMost other statically typed languages, like C++ or Java or Rust or\nSwift, support generics to address exactly this kind of issue.\u003c/p\u003e\n\u003ch2 id=\"go-generic-programming-today\"\u003eGo generic programming today\u003c/h2\u003e\n\u003cp\u003eSo how do people write this kind of code in Go?\u003c/p\u003e\n\u003cp\u003eIn Go you can write a single function that works for different slice\ntypes by using an interface type, and defining a method on the slice\ntypes you want to pass in.\nThat is how the standard library’s \u003ccode\u003esort.Sort\u003c/code\u003e function works.\u003c/p\u003e\n\u003cp\u003eIn other words, interface types in Go are a form of generic\nprogramming.\nThey let us capture the common aspects of different types and express\nthem as methods.\nWe can then write functions that use those interface types, and those\nfunctions will work for any type that implements those methods.\u003c/p\u003e\n\u003cp\u003eBut this approach falls short of what we want.\nWith interfaces you have to write the methods yourself.\nIt’s awkward to have to define a named type with a couple of methods\njust to reverse a slice.\nAnd the methods you write are exactly the same for each slice type, so\nin a sense we’ve just moved and condensed the duplicate code, we\nhaven’t eliminated it.\nAlthough interfaces are a form of generics, they don’t give us\neverything we want from generics.\u003c/p\u003e\n\u003cp\u003eA different way of using interfaces for generics, which could get around\nthe need to write the methods yourself, would be to have the language\ndefine methods for some kinds of types.\nThat isn’t something the language supports today, but, for example,\nthe language could define that every slice type has an Index method\nthat returns an element.\nBut in order to use that method in practice it would have to return an\nempty interface type, and then we lose all the benefits of static\ntyping.\nMore subtly, there would be no way to define a generic function that\ntakes two different slices with the same element type, or that takes a\nmap of one element type and returns a slice of the same element type.\nGo is a statically typed language because that makes it easier to\nwrite large programs; we don’t want to lose the benefits of static\ntyping in order to gain the benefits of generics.\u003c/p\u003e\n\u003cp\u003eAnother approach would be to write a generic \u003ccode\u003eReverse\u003c/code\u003e function using\nthe reflect package, but that is so awkward to write and slow to run\nthat few people do that.\nThat approach also requires explicit type assertions and has no static\ntype checking.\u003c/p\u003e\n\u003cp\u003eOr, you could write a code generator that takes a type and generates a\n\u003ccode\u003eReverse\u003c/code\u003e function for slices of that type.\nThere are several code generators out there that do just that.\nBut this adds another step to every package that needs \u003ccode\u003eReverse\u003c/code\u003e,\nit complicates the build because all the different copies have to be\ncompiled, and fixing a bug in the master source requires re-generating\nall the instances, some of which may be in different projects\nentirely.\u003c/p\u003e\n\u003cp\u003eAll these approaches are awkward enough that I think most\npeople who have to reverse a slice in Go just write the function for\nthe specific slice type that they need.\nThen they’ll need to write test cases for the function, to make sure\nthey didn’t make a simple mistake like the one I made initially.\nAnd they’ll need to run those tests routinely.\u003c/p\u003e\n\u003cp\u003eHowever we do it, it means a lot of extra work just for a function that\nlooks exactly the same except for the element type.\nIt’s not that it can’t be done.\nIt clearly can be done, and Go programmers are doing it.\nIt’s just that there ought to be a better way.\u003c/p\u003e\n\u003cp\u003eFor a statically typed language like Go, that better way is generics.\nWhat I wrote earlier is that generic programming enables the\nrepresentation of functions and data structures in a generic form,\nwith types factored out.\nThat’s exactly what we want here.\u003c/p\u003e\n\u003ch2 id=\"what-generics-can-bring-to-go\"\u003eWhat generics can bring to Go\u003c/h2\u003e\n\u003cp\u003eThe first and most important thing we want from generics in Go is to\nbe able to write functions like \u003ccode\u003eReverse\u003c/code\u003e without caring about the\nelement type of the slice.\nWe want to factor out that element type.\nThen we can write the function once, write the tests once, put them in\na go-gettable package, and call them whenever we want.\u003c/p\u003e\n\u003cp\u003eEven better, since this is an open source world, someone else can\nwrite \u003ccode\u003eReverse\u003c/code\u003e once, and we can use their implementation.\u003c/p\u003e\n\u003cp\u003eAt this point I should say that “generics” can mean a lot of different\nthings.\nIn this article, what I mean by “generics” is what I just described.\nIn particular, I don’t mean templates as found in the C++ language,\nwhich support quite a bit more than what I’ve written here.\u003c/p\u003e\n\u003cp\u003eI went through \u003ccode\u003eReverse\u003c/code\u003e in detail, but there are many other functions\nthat we could write generically, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFind smallest/largest element in slice\u003c/li\u003e\n\u003cli\u003eFind average/standard deviation of slice\u003c/li\u003e\n\u003cli\u003eCompute union/intersection of maps\u003c/li\u003e\n\u003cli\u003eFind shortest path in node/edge graph\u003c/li\u003e\n\u003cli\u003eApply transformation function to slice/map, returning new slice/map\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese examples are available in most other languages.\nIn fact, I wrote this list by glancing at the C++ standard template\nlibrary.\u003c/p\u003e\n\u003cp\u003eThere are also examples that are specific to Go with its strong\nsupport for concurrency.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRead from a channel with a timeout\u003c/li\u003e\n\u003cli\u003eCombine two channels into a single channel\u003c/li\u003e\n\u003cli\u003eCall a list of functions in parallel, returning a slice of results\u003c/li\u003e\n\u003cli\u003eCall a list of functions, using a Context, return the result of the first function to finish, canceling and cleaning up extra goroutines\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI’ve seen all of these functions written out many times with different\ntypes.\nIt’s not hard to write them in Go.\nBut it would be nice to be able to reuse an efficient and debugged\nimplementation that works for any value type.\u003c/p\u003e\n\u003cp\u003eTo be clear, these are just examples.\nThere are many more general purpose functions that could be written\nmore easily and safely using generics.\u003c/p\u003e\n\u003cp\u003eAlso, as I wrote earlier, it’s not just functions.\nIt’s also data structures.\u003c/p\u003e\n\u003cp\u003eGo has two general purpose generic data structures built into the\nlanguage: slices and maps.\nSlices and maps can hold values of any data type, with static type\nchecking for values stored and retrieved.\nThe values are stored as themselves, not as interface types.\nThat is, when I have a \u003ccode\u003e[]int\u003c/code\u003e, the slice holds ints directly, not\nints converted to an interface type.\u003c/p\u003e\n\u003cp\u003eSlices and maps are the most useful generic data structures, but they\naren’t the only ones.\nHere are some other examples.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSets\u003c/li\u003e\n\u003cli\u003eSelf-balancing trees, with efficient insertion and traversal in sorted order\u003c/li\u003e\n\u003cli\u003eMultimaps, with multiple instances of a key\u003c/li\u003e\n\u003cli\u003eConcurrent hash maps, supporting parallel insertions and lookups with no single lock\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIf we can write generic types, we can define new data structures, like\nthese, that have the same type-checking advantages as slices and maps:\nthe compiler can statically type-check the types of the values that\nthey hold, and the values can be stored as themselves, not as\ninterface types.\u003c/p\u003e\n\u003cp\u003eIt should also be possible to take algorithms like the ones mentioned\nearlier and apply them to generic data structures.\u003c/p\u003e\n\u003cp\u003eThese examples should all be just like \u003ccode\u003eReverse\u003c/code\u003e: generic functions\nand data structures written once, in a package, and reused whenever\nthey are needed.\nThey should work like slices and maps, in that they shouldn’t store\nvalues of empty interface type, but should store specific types, and\nthose types should be checked at compile time.\u003c/p\u003e\n\u003cp\u003eSo that’s what Go can gain from generics.\nGenerics can give us powerful building blocks that let us share code\nand build programs more easily.\u003c/p\u003e\n\u003cp\u003eI hope I’ve explained why this is worth looking into.\u003c/p\u003e\n\u003ch2 id=\"benefits-and-costs\"\u003eBenefits and costs\u003c/h2\u003e\n\u003cp\u003eBut generics don’t come from the\n\u003ca href=\"https://mainlynorfolk.info/folk/songs/bigrockcandymountain.html\" rel=\"noreferrer\" target=\"_blank\"\u003eBig Rock Candy Mountain\u003c/a\u003e,\nthe land where the sun shines every day over the\n\u003ca href=\"http://www.lat-long.com/Latitude-Longitude-773297-Montana-Lemonade_Springs.html\" rel=\"noreferrer\" target=\"_blank\"\u003elemonade springs\u003c/a\u003e.\nEvery language change has a cost.\nThere’s no doubt that adding generics to Go will make the language\nmore complicated.\nAs with any change to the language, we need to talk about maximizing\nthe benefit and minimizing the cost.\u003c/p\u003e\n\u003cp\u003eIn Go, we’ve aimed to reduce complexity through independent, orthogonal\nlanguage features that can be combined freely.\nWe reduce complexity by making the individual features simple, and we\nmaximize the benefit of the features by permitting their free\ncombination.\nWe want to do the same with generics.\u003c/p\u003e\n\u003cp\u003eTo make this more concrete I’m going to list a few guidelines we\nshould follow.\u003c/p\u003e\n\u003ch3 id=\"minimize-new-concepts\"\u003eMinimize new concepts\u003c/h3\u003e\n\u003cp\u003eWe should add as few new concepts to the language as possible.\nThat means a minimum of new syntax and a minimum of new keywords and\nother names.\u003c/p\u003e\n\u003ch3 id=\"complexity-falls-on-the-writer-of-generic-code-not-the-user\"\u003eComplexity falls on the writer of generic code, not the user\u003c/h3\u003e\n\u003cp\u003eAs much as possible the complexity should fall on the programmer\nwriting the generic package.\nWe don’t want the user of the package to have to worry about generics.\nThis means that it should be possible to call generic functions in a\nnatural way, and it means that any errors in using a generic package\nshould be reported in a way that is easy to understand and to fix.\nIt should also be easy to debug calls into generic code.\u003c/p\u003e\n\u003ch3 id=\"writer-and-user-can-work-independently\"\u003eWriter and user can work independently\u003c/h3\u003e\n\u003cp\u003eSimilarly, we should make it easy to separate the concerns of the\nwriter of the generic code and its user, so that they can develop their\ncode independently.\nThey shouldn’t have to worry about what the other is doing, any more\nthan the writer and caller of a normal function in different packages\nhave to worry.\nThis sounds obvious, but it’s not true of generics in every other\nprogramming language.\u003c/p\u003e\n\u003ch3 id=\"short-build-times-fast-execution-times\"\u003eShort build times, fast execution times\u003c/h3\u003e\n\u003cp\u003eNaturally, as much as possible, we want to keep the short build times\nand fast execution time that Go gives us today.\nGenerics tend to introduce a tradeoff between fast builds and fast\nexecution.\nAs much as possible, we want both.\u003c/p\u003e\n\u003ch3 id=\"preserve-clarity-and-simplicity-of-go\"\u003ePreserve clarity and simplicity of Go\u003c/h3\u003e\n\u003cp\u003eMost importantly, Go today is a simple language.\nGo programs are usually clear and easy to understand.\nA major part of our long process of exploring this space has been\ntrying to understand how to add generics while preserving that clarity\nand simplicity.\nWe need to find mechanisms that fit well into the existing language,\nwithout turning it into something quite different.\u003c/p\u003e\n\u003cp\u003eThese guidelines should apply to any generics implementation in Go.\nThat’s the most important message I want to leave you with today:\n\u003cstrong\u003egenerics can bring a significant benefit to the language, but they are only worth doing if Go still feels like Go\u003c/strong\u003e.\u003c/p\u003e\n\u003ch2 id=\"draft-design\"\u003eDraft design\u003c/h2\u003e\n\u003cp\u003eFortunately, I think it can be done.\nTo finish up this article I’m going to shift from discussing why we\nwant generics, and what the requirements on them are, to briefly\ndiscuss a design for how we think we can add them to the language.\u003c/p\u003e\n\u003cp\u003eNote added January 2022: This blog post was written in 2019 and does\nnot describe the version of generics that was finally adopted.\nFor updated information please see the description of type parameters in\n\u003ca href=\"/ref/spec\"\u003ethe language spec\u003c/a\u003e and\n\u003ca href=\"/design/43651-type-parameters\"\u003ethe generics design document\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAt this year’s Gophercon Robert Griesemer and I published\n\u003ca href=\"https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md\" rel=\"noreferrer\" target=\"_blank\"\u003ea design draft\u003c/a\u003e\nfor adding generics to Go.\nSee the draft for full details.\nI’ll go over some of the main points here.\u003c/p\u003e\n\u003cp\u003eHere is the generic Reverse function in this design.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Reverse (type Element) (s []Element) {\n    first := 0\n    last := len(s) - 1\n    for first \u0026lt; last {\n        s[first], s[last] = s[last], s[first]\n        first++\n        last--\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll notice that the body of the function is exactly the same.\nOnly the signature has changed.\u003c/p\u003e\n\u003cp\u003eThe element type of the slice has been factored out.\nIt’s now named \u003ccode\u003eElement\u003c/code\u003e and has become what we call a\n\u003cem\u003etype parameter\u003c/em\u003e.\nInstead of being part of the type of the slice parameter, it’s now a\nseparate, additional, type parameter.\u003c/p\u003e\n\u003cp\u003eTo call a function with a type parameter, in the general case you pass\na type argument, which is like any other argument except that it’s a\ntype.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReverseAndPrint(s []int) {\n    Reverse(int)(s)\n    fmt.Println(s)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat is the \u003ccode\u003e(int)\u003c/code\u003e seen after \u003ccode\u003eReverse\u003c/code\u003e in this example.\u003c/p\u003e\n\u003cp\u003eFortunately, in most cases, including this one, the compiler can\ndeduce the type argument from the types of the regular arguments, and\nyou don’t need to mention the type argument at all.\u003c/p\u003e\n\u003cp\u003eCalling a generic function just looks like calling any other function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReverseAndPrint(s []int) {\n    Reverse(s)\n    fmt.Println(s)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn other words, although the generic \u003ccode\u003eReverse\u003c/code\u003e function is slightly\nmore complex than \u003ccode\u003eReverseInts\u003c/code\u003e and \u003ccode\u003eReverseStrings\u003c/code\u003e, that complexity\nfalls on the writer of the function, not the caller.\u003c/p\u003e\n\u003ch3 id=\"contracts\"\u003eContracts\u003c/h3\u003e\n\u003cp\u003eSince Go is a statically typed language, we have to talk about the\ntype of a type parameter.\nThis \u003cem\u003emeta-type\u003c/em\u003e tells the compiler what sorts of type arguments are\npermitted when calling a generic function, and what sorts of\noperations the generic function can do with values of the type\nparameter.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eReverse\u003c/code\u003e function can work with slices of any type.\nThe only thing it does with values of type \u003ccode\u003eElement\u003c/code\u003e is assignment,\nwhich works with any type in Go.\nFor this kind of generic function, which is a very common case, we\ndon’t need to say anything special about the type parameter.\u003c/p\u003e\n\u003cp\u003eLet’s take a quick look at a different function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc IndexByte (type T Sequence) (s T, b byte) int {\n    for i := 0; i \u0026lt; len(s); i++ {\n        if s[i] == b {\n            return i\n        }\n    }\n    return -1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCurrently both the bytes package and the strings package in the\nstandard library have an \u003ccode\u003eIndexByte\u003c/code\u003e function.\nThis function returns the index of \u003ccode\u003eb\u003c/code\u003e in the sequence \u003ccode\u003es\u003c/code\u003e, where \u003ccode\u003es\u003c/code\u003e\nis either a \u003ccode\u003estring\u003c/code\u003e or a \u003ccode\u003e[]byte\u003c/code\u003e.\nWe could use this single generic function to replace the two functions\nin the bytes and strings packages.\nIn practice we may not bother doing that, but this is a useful simple\nexample.\u003c/p\u003e\n\u003cp\u003eHere we need to know that the type parameter \u003ccode\u003eT\u003c/code\u003e acts like a \u003ccode\u003estring\u003c/code\u003e\nor a \u003ccode\u003e[]byte\u003c/code\u003e.\nWe can call \u003ccode\u003elen\u003c/code\u003e on it, and we can index to it, and we can compare\nthe result of the index operation to a byte value.\u003c/p\u003e\n\u003cp\u003eTo let this compile, the type parameter \u003ccode\u003eT\u003c/code\u003e itself needs a type.\nIt’s a meta-type, but because we sometimes need to describe multiple\nrelated types, and because it describes a relationship between the\nimplementation of the generic function and its callers, we actually\ncall the type of \u003ccode\u003eT\u003c/code\u003e a contract.\nHere the contract is named \u003ccode\u003eSequence\u003c/code\u003e.\nIt appears after the list of type parameters.\u003c/p\u003e\n\u003cp\u003eThis is how the Sequence contract is defined for this example.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econtract Sequence(T) {\n    T string, []byte\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s pretty simple, since this is a simple example: the type parameter\n\u003ccode\u003eT\u003c/code\u003e can be either \u003ccode\u003estring\u003c/code\u003e or \u003ccode\u003e[]byte\u003c/code\u003e.\nHere \u003ccode\u003econtract\u003c/code\u003e may be a new keyword, or a special identifier\nrecognized in package scope; see the design draft for details.\u003c/p\u003e\n\u003cp\u003eAnybody who remembers \u003ca href=\"https://github.com/golang/proposal/blob/4a530dae40977758e47b78fae349d8e5f86a6c0a/design/go2draft-contracts.md\" rel=\"noreferrer\" target=\"_blank\"\u003ethe design we presented at Gophercon 2018\u003c/a\u003e\nwill see that this way of writing a contract is a lot simpler.\nWe got a lot of feedback on that earlier design that contracts were\ntoo complicated, and we’ve tried to take that into account.\nThe new contracts are much simpler to write, and to read, and to\nunderstand.\u003c/p\u003e\n\u003cp\u003eThey let you specify the underlying type of a type parameter, and/or\nlist the methods of a type parameter.\nThey also let you describe the relationship between different type\nparameters.\u003c/p\u003e\n\u003ch3 id=\"contracts-with-methods\"\u003eContracts with methods\u003c/h3\u003e\n\u003cp\u003eHere is another simple example, of a function that uses the String\nmethod to return a \u003ccode\u003e[]string\u003c/code\u003e of the string representation of all the\nelements in \u003ccode\u003es\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ToStrings (type E Stringer) (s []E) []string {\n    r := make([]string, len(s))\n    for i, v := range s {\n        r[i] = v.String()\n    }\n    return r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s pretty straightforward: walk through the slice, call the \u003ccode\u003eString\u003c/code\u003e\nmethod on each element, and return a slice of the resulting strings.\u003c/p\u003e\n\u003cp\u003eThis function requires that the element type implement the \u003ccode\u003eString\u003c/code\u003e\nmethod.\nThe Stringer contract ensures that.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econtract Stringer(T) {\n    T String() string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe contract simply says that \u003ccode\u003eT\u003c/code\u003e has to implement the \u003ccode\u003eString\u003c/code\u003e\nmethod.\u003c/p\u003e\n\u003cp\u003eYou may notice that this contract looks like the \u003ccode\u003efmt.Stringer\u003c/code\u003e\ninterface, so it’s worth pointing out that the argument of the\n\u003ccode\u003eToStrings\u003c/code\u003e function is not a slice of \u003ccode\u003efmt.Stringer\u003c/code\u003e.\nIt’s a slice of some element type, where the element type implements\n\u003ccode\u003efmt.Stringer\u003c/code\u003e.\nThe memory representation of a slice of the element type and a slice\nof \u003ccode\u003efmt\u003c/code\u003e.Stringer are normally different, and Go does not support\ndirect conversions between them.\nSo this is worth writing, even though \u003ccode\u003efmt.Stringer\u003c/code\u003e exists.\u003c/p\u003e\n\u003ch3 id=\"contracts-with-multiple-types\"\u003eContracts with multiple types\u003c/h3\u003e\n\u003cp\u003eHere is an example of a contract with multiple type parameters.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Graph (type Node, Edge G) struct { ... }\n\ncontract G(Node, Edge) {\n    Node Edges() []Edge\n    Edge Nodes() (from Node, to Node)\n}\n\nfunc New (type Node, Edge G) (nodes []Node) *Graph(Node, Edge) {\n    ...\n}\n\nfunc (g *Graph(Node, Edge)) ShortestPath(from, to Node) []Edge {\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere we’re describing a graph, built from nodes and edges.\nWe’re not requiring a particular data structure for the graph.\nInstead, we’re saying that the \u003ccode\u003eNode\u003c/code\u003e type has to have an \u003ccode\u003eEdges\u003c/code\u003e\nmethod that returns the list of edges that connect to the \u003ccode\u003eNode\u003c/code\u003e.\nAnd the \u003ccode\u003eEdge\u003c/code\u003e type has to have a \u003ccode\u003eNodes\u003c/code\u003e method that returns the two\n\u003ccode\u003eNodes\u003c/code\u003e that the \u003ccode\u003eEdge\u003c/code\u003e connects.\u003c/p\u003e\n\u003cp\u003eI’ve skipped the implementation, but this shows the signature of a\n\u003ccode\u003eNew\u003c/code\u003e function that returns a \u003ccode\u003eGraph\u003c/code\u003e, and the signature of a\n\u003ccode\u003eShortestPath\u003c/code\u003e method on \u003ccode\u003eGraph\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe important takeaway here is that a contract isn’t just about a\nsingle type.  It can describe the relationships between two or more\ntypes.\u003c/p\u003e\n\u003ch3 id=\"ordered-types\"\u003eOrdered types\u003c/h3\u003e\n\u003cp\u003eOne surprisingly common complaint about Go is that it doesn’t have a\n\u003ccode\u003eMin\u003c/code\u003e function.\nOr, for that matter, a \u003ccode\u003eMax\u003c/code\u003e function.\nThat’s because a useful \u003ccode\u003eMin\u003c/code\u003e function should work for any ordered\ntype, which means that it has to be generic.\u003c/p\u003e\n\u003cp\u003eWhile \u003ccode\u003eMin\u003c/code\u003e is pretty trivial to write yourself, any useful generics\nimplementation should let us add it to the standard library.\nThis is what it looks like with our design.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Min (type T Ordered) (a, b T) T {\n    if a \u0026lt; b {\n        return a\n    }\n    return b\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eOrdered\u003c/code\u003e contract says that the type T has to be an ordered type,\nwhich means that it supports operators like less than, greater than,\nand so forth.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econtract Ordered(T) {\n    T int, int8, int16, int32, int64,\n        uint, uint8, uint16, uint32, uint64, uintptr,\n        float32, float64,\n        string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eOrdered\u003c/code\u003e contract is just a list of all the ordered types that\nare defined by the language.\nThis contract accepts any of the listed types, or any named type whose\nunderlying type is one of those types.\nBasically, any type you can use with the less than operator.\u003c/p\u003e\n\u003cp\u003eIt turns out that it’s much easier to simply enumerate the types that\nsupport the less than operator than it is to invent a new notation\nthat works for all operators.\nAfter all, in Go, only built-in types support operators.\u003c/p\u003e\n\u003cp\u003eThis same approach can be used for any operator, or more generally\nto write a contract for any generic function intended to work with\nbuiltin types.\nIt lets the writer of the generic function specify clearly the set of\ntypes the function is expected to be used with.\nIt lets the caller of the generic function clearly see whether the\nfunction is applicable for the types being used.\u003c/p\u003e\n\u003cp\u003eIn practice this contract would probably go into the standard library,\nand so really the \u003ccode\u003eMin\u003c/code\u003e function (which will probably also be in the\nstandard library somewhere) will look like this.\nHere we’re just referring to the contract \u003ccode\u003eOrdered\u003c/code\u003e defined in the\ncontracts package.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Min (type T contracts.Ordered) (a, b T) T {\n    if a \u0026lt; b {\n        return a\n    }\n    return b\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"generic-data-structures\"\u003eGeneric data structures\u003c/h3\u003e\n\u003cp\u003eFinally, let’s look at a simple generic data structure, a binary\ntree.  In this example the tree has a comparison function, so there\nare no requirements on the element type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Tree (type E) struct {\n    root    *node(E)\n    compare func(E, E) int\n}\n\ntype node (type E) struct {\n    val         E\n    left, right *node(E)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is how to create a new binary tree.\nThe comparison function is passed to the \u003ccode\u003eNew\u003c/code\u003e function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc New (type E) (cmp func(E, E) int) *Tree(E) {\n    return \u0026amp;Tree(E){compare: cmp}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn unexported method returns a pointer either to the slot holding v,\nor to the location in the tree where it should go.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (t *Tree(E)) find(v E) **node(E) {\n    pn := \u0026amp;t.root\n    for *pn != nil {\n        switch cmp := t.compare(v, (*pn).val); {\n        case cmp \u0026lt; 0:\n            pn = \u0026amp;(*pn).left\n        case cmp \u0026gt; 0:\n            pn = \u0026amp;(*pn).right\n        default:\n            return pn\n        }\n    }\n    return pn\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe details here don’t really matter, especially since I haven’t\ntested this code.\nI’m just trying to show what it looks like to write a simple generic\ndata structure.\u003c/p\u003e\n\u003cp\u003eThis is the code for testing whether the tree contains a value.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (t *Tree(E)) Contains(v E) bool {\n    return *t.find(e) != nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is the code for inserting a new value.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (t *Tree(E)) Insert(v E) bool {\n    pn := t.find(v)\n    if *pn != nil {\n        return false\n    }\n    *pn = \u0026amp;node(E){val: v}\n    return true\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the type \u003ccode\u003enode\u003c/code\u003e has a type argument \u003ccode\u003eE\u003c/code\u003e.\nThis is what it looks like to write a generic data structure.\nAs you can see, it looks like writing ordinary Go code, except that\nsome type arguments are sprinkled in here and there.\u003c/p\u003e\n\u003cp\u003eUsing the tree is pretty simple.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar intTree = tree.New(func(a, b int) int { return a - b })\n\nfunc InsertAndCheck(v int) {\n    intTree.Insert(v)\n    if !intTree.Contains(v) {\n        log.Fatalf(\u0026#34;%d not found after insertion\u0026#34;, v)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s as it should be.\nIt’s a bit harder to write a generic data structure, because you often\nhave to explicitly write out type arguments for supporting types, but\nas much as possible using one is no different from using an ordinary\nnon-generic data structure.\u003c/p\u003e\n\u003ch3 id=\"next-steps\"\u003eNext steps\u003c/h3\u003e\n\u003cp\u003eWe are working on actual implementations to allow us to experiment\nwith this design.\nIt’s important to be able to try out the design in practice, to make\nsure that we can write the kinds of programs we want to write.\nIt hasn’t gone as fast as we’d hoped, but we’ll send out more detail\non these implementations as they become available.\u003c/p\u003e\n\u003cp\u003eRobert Griesemer has written a\n\u003ca href=\"/cl/187317\"\u003epreliminary CL\u003c/a\u003e\nthat modifies the go/types package.\nThis permits testing whether code using generics and contracts can\ntype check.\nIt’s incomplete right now, but it mostly works for a single package,\nand we’ll keep working on it.\u003c/p\u003e\n\u003cp\u003eWhat we’d like people to do with this and future implementations is to\ntry writing and using generic code and see what happens.\nWe want to make sure that people can write the code they need, and\nthat they can use it as expected.\nOf course not everything is going to work at first, and as we explore\nthis space we may have to change things.\nAnd, to be clear, we’re much more interested in feedback on the\nsemantics than on details of the syntax.\u003c/p\u003e\n\u003cp\u003eI’d like to thank everyone who commented on the earlier design, and\neveryone who has discussed what generics can look like in Go.\nWe’ve read all of the comments, and we greatly appreciate the work\nthat people have put into this.\nWe would not be where we are today without that work.\u003c/p\u003e\n\u003cp\u003eOur goal is to arrive at a design that makes it possible to write the\nkinds of generic code I’ve discussed today, without making the\nlanguage too complex to use or making it not feel like Go anymore.\nWe hope that this design is a step toward that goal, and we expect to\ncontinue to adjust it as we learn, from our experiences and yours,\nwhat works and what doesn’t.\nIf we do reach that goal, then we’ll have something that we can\npropose for future versions of Go.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-07-31T00:00:00Z",
  "Author": "Ian Lance Taylor"
}