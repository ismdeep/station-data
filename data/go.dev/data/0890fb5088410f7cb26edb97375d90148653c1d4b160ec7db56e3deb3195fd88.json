{
  "Source": "go.dev",
  "Title": "Keeping Your Modules Compatible",
  "Link": "https://go.dev/blog/module-compatibility",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/module-compatibility\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eKeeping Your Modules Compatible\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jean de Klerk and Jonathan Amsterdam\u003cbr/\u003e\n      7 July 2020\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis post is part 5 in a series.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePart 1 — \u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 2 — \u003ca href=\"/blog/migrating-to-go-modules\"\u003eMigrating To Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 3 — \u003ca href=\"/blog/publishing-go-modules\"\u003ePublishing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 4 — \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePart 5 — Keeping Your Modules Compatible\u003c/strong\u003e (this post)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For documentation on developing modules, see\n\u003ca href=\"/doc/modules/developing\"\u003eDeveloping and publishing modules\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eYour modules will evolve over time as you add new features, change behaviors, and reconsider parts of the module’s public surface. As discussed in \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e, breaking changes to a v1+ module must happen as part of a major version bump (or by adopting a new module path).\u003c/p\u003e\n\u003cp\u003eHowever, releasing a new major version is hard on your users. They have to find the new version, learn a new API, and change their code. And some users may never update, meaning you have to maintain two versions for your code forever. So it is usually better to change your existing package in a compatible way.\u003c/p\u003e\n\u003cp\u003eIn this post, we’ll explore some techniques for introducing non-breaking changes. The common theme is: add, don’t change or remove. We’ll also talk about how to design your API for compatibility from the outset.\u003c/p\u003e\n\u003ch2 id=\"adding-to-a-function\"\u003eAdding to a function\u003c/h2\u003e\n\u003cp\u003eOften, breaking changes come in the form of new arguments to a function. We’ll describe some ways to deal with this sort of change, but first let’s look at a technique that doesn’t work.\u003c/p\u003e\n\u003cp\u003eWhen adding new arguments with sensible defaults, it’s tempting to add them as a variadic parameter. To extend the function\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Run(name string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewith an additional \u003ccode\u003esize\u003c/code\u003e argument which defaults to zero, one might propose\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Run(name string, size ...int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eon the grounds that all existing call sites will continue to work. While that is true, other uses of \u003ccode\u003eRun\u003c/code\u003e could break, like this one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage mypkg\nvar runner func(string) = yourpkg.Run\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe original \u003ccode\u003eRun\u003c/code\u003e function works here because its type is \u003ccode\u003efunc(string)\u003c/code\u003e, but the new \u003ccode\u003eRun\u003c/code\u003e function’s type is \u003ccode\u003efunc(string, ...int)\u003c/code\u003e, so the assignment fails at compile time.\u003c/p\u003e\n\u003cp\u003eThis example illustrates that call compatibility is not enough for backward compatibility. There is, in fact, no backward-compatible change you can make to a function’s signature.\u003c/p\u003e\n\u003cp\u003eInstead of changing a function’s signature, add a new function. As an example, after the \u003ccode\u003econtext\u003c/code\u003e package was introduced, it became common practice to pass a \u003ccode\u003econtext.Context\u003c/code\u003e as the first argument to a function. However, stable APIs could not change an exported function to accept a \u003ccode\u003econtext.Context\u003c/code\u003e because it would break all uses of that function.\u003c/p\u003e\n\u003cp\u003eInstead, new functions were added. For example, the \u003ccode\u003edatabase/sql\u003c/code\u003e package’s \u003ccode\u003eQuery\u003c/code\u003e method’s signature was (and still is)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (db *DB) Query(query string, args ...interface{}) (*Rows, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen the \u003ccode\u003econtext\u003c/code\u003e package was created, the Go team added a new method to \u003ccode\u003edatabase/sql\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo avoid copying code, the old method calls the new one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (db *DB) Query(query string, args ...interface{}) (*Rows, error) {\n    return db.QueryContext(context.Background(), query, args...)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdding a method allows users to migrate to the new API at their own pace. Since the methods read similarly and sort together, and \u003ccode\u003eContext\u003c/code\u003e is in the name of the new method, this extension of the \u003ccode\u003edatabase/sql\u003c/code\u003e API did not degrade readability or comprehension of the package.\u003c/p\u003e\n\u003cp\u003eIf you anticipate that a function may need more arguments in the future, you can plan ahead by making optional arguments a part of the function’s signature. The simplest way to do that is to add a single struct argument, as the \u003ca href=\"https://pkg.go.dev/crypto/tls?tab=doc#Dial\" rel=\"noreferrer\" target=\"_blank\"\u003ecrypto/tls.Dial\u003c/a\u003e function does:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Dial(network, addr string, config *Config) (*Conn, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe TLS handshake conducted by \u003ccode\u003eDial\u003c/code\u003e requires a network and address, but it has many other parameters with reasonable defaults. Passing a \u003ccode\u003enil\u003c/code\u003e for \u003ccode\u003econfig\u003c/code\u003e uses those defaults; passing a \u003ccode\u003eConfig\u003c/code\u003e struct with some fields set will override the defaults for those fields. In the future, adding a new TLS configuration parameter only requires a new field on the \u003ccode\u003eConfig\u003c/code\u003e struct, a change that is backward-compatible (almost always—see “Maintaining struct compatibility” below).\u003c/p\u003e\n\u003cp\u003eSometimes the techniques of adding a new function and adding options can be combined by making the options struct a method receiver. Consider the evolution of the \u003ccode\u003enet\u003c/code\u003e package’s ability to listen at a network address. Prior to Go 1.11, the \u003ccode\u003enet\u003c/code\u003e package provided only a \u003ccode\u003eListen\u003c/code\u003e function with the signature\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Listen(network, address string) (Listener, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor Go 1.11, two features were added to \u003ccode\u003enet\u003c/code\u003e listening: passing a context, and allowing the caller to provide a “control function” to adjust the raw connection after creation but before binding. The result could have been a new function that took a context, network, address and control function. Instead, the package authors added a  \u003ca href=\"https://pkg.go.dev/net@go1.11?tab=doc#ListenConfig\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eListenConfig\u003c/code\u003e\u003c/a\u003e struct in anticipation that more options might be needed someday. And rather than define a new top-level function with a cumbersome name, they added a \u003ccode\u003eListen\u003c/code\u003e method to \u003ccode\u003eListenConfig\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype ListenConfig struct {\n    Control func(network, address string, c syscall.RawConn) error\n}\n\nfunc (*ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnother way to provide new options in the future is the “Option types” pattern, where options are passed as variadic arguments, and each option is a function that changes the state of the value being constructed. They are described in more detail by Rob Pike’s post \u003ca href=\"https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html\" rel=\"noreferrer\" target=\"_blank\"\u003eSelf-referential functions and the design of options\u003c/a\u003e. One widely used example is \u003ca href=\"https://pkg.go.dev/google.golang.org/grpc?tab=doc\" rel=\"noreferrer\" target=\"_blank\"\u003egoogle.golang.org/grpc\u003c/a\u003e’s \u003ca href=\"https://pkg.go.dev/google.golang.org/grpc?tab=doc#DialOption\" rel=\"noreferrer\" target=\"_blank\"\u003eDialOption\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eOption types fulfill the same role as struct options in function arguments: they are an extensible way to pass behavior-modifying configuration. Deciding which to choose is largely a matter of style. Consider this simple usage of gRPC’s \u003ccode\u003eDialOption\u003c/code\u003e option type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egrpc.Dial(\u0026#34;some-target\u0026#34;,\n  grpc.WithAuthority(\u0026#34;some-authority\u0026#34;),\n  grpc.WithMaxDelay(time.Second),\n  grpc.WithBlock())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis could also have been implemented as a struct option:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003enotgrpc.Dial(\u0026#34;some-target\u0026#34;, \u0026amp;notgrpc.Options{\n  Authority: \u0026#34;some-authority\u0026#34;,\n  MaxDelay:  time.Second,\n  Block:     true,\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctional options have some downsides: they require writing the package name before the option for each call; they increase the size of the package namespace; and it’s unclear what the behavior should be if the same option is provided twice. On the other hand, functions which take option structs require a parameter which might almost always be \u003ccode\u003enil\u003c/code\u003e, which some find unattractive. And when a type’s zero value has a valid meaning, it is clumsy to specify that the option should have its default value, typically requiring a pointer or an additional boolean field.\u003c/p\u003e\n\u003cp\u003eEither one is a reasonable choice for ensuring future extensibility of your module’s public API.\u003c/p\u003e\n\u003ch2 id=\"working-with-interfaces\"\u003eWorking with interfaces\u003c/h2\u003e\n\u003cp\u003eSometimes, new features require changes to publicly-exposed interfaces: for example, an interface needs to be extended with new methods. Directly adding to an interface is a breaking change, though—how, then, can we support new methods on a publicly-exposed interface?\u003c/p\u003e\n\u003cp\u003eThe basic idea is to define a new interface with the new method, and then wherever the old interface is used, dynamically check whether the provided type is the older type or the newer type.\u003c/p\u003e\n\u003cp\u003eLet’s illustrate this with an example from the \u003ca href=\"https://pkg.go.dev/archive/tar?tab=doc\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003earchive/tar\u003c/code\u003e\u003c/a\u003e package. \u003ca href=\"https://pkg.go.dev/archive/tar?tab=doc#NewReader\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003etar.NewReader\u003c/code\u003e\u003c/a\u003e accepts an \u003ccode\u003eio.Reader\u003c/code\u003e, but over time the Go team realized that it would be more efficient to skip from one file header to the next if you could call \u003ca href=\"https://pkg.go.dev/io?tab=doc#Seeker\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSeek\u003c/code\u003e\u003c/a\u003e. But, they could not add a \u003ccode\u003eSeek\u003c/code\u003e method to \u003ccode\u003eio.Reader\u003c/code\u003e: that would break all implementers of \u003ccode\u003eio.Reader\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnother ruled-out option was to change \u003ccode\u003etar.NewReader\u003c/code\u003e to accept \u003ca href=\"https://pkg.go.dev/io?tab=doc#ReadSeeker\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eio.ReadSeeker\u003c/code\u003e\u003c/a\u003e rather than \u003ccode\u003eio.Reader\u003c/code\u003e, since it supports both \u003ccode\u003eio.Reader\u003c/code\u003e methods and \u003ccode\u003eSeek\u003c/code\u003e (by way of \u003ccode\u003eio.Seeker\u003c/code\u003e). But, as we saw above, changing a function signature is also a breaking change.\u003c/p\u003e\n\u003cp\u003eSo, they decided to keep \u003ccode\u003etar.NewReader\u003c/code\u003e signature unchanged, but type check for (and support) \u003ccode\u003eio.Seeker\u003c/code\u003e in \u003ccode\u003etar.Reader\u003c/code\u003e methods:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage tar\n\ntype Reader struct {\n  r io.Reader\n}\n\nfunc NewReader(r io.Reader) *Reader {\n  return \u0026amp;Reader{r: r}\n}\n\nfunc (r *Reader) Read(b []byte) (int, error) {\n  if rs, ok := r.r.(io.Seeker); ok {\n    // Use more efficient rs.Seek.\n  }\n  // Use less efficient r.r.Read.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(See \u003ca href=\"https://github.com/golang/go/blob/60f78765022a59725121d3b800268adffe78bde3/src/archive/tar/reader.go#L837\" rel=\"noreferrer\" target=\"_blank\"\u003ereader.go\u003c/a\u003e for the actual code.)\u003c/p\u003e\n\u003cp\u003eWhen you run into a case where you want to add a method to an existing interface, you may be able to follow this strategy. Start by creating a new interface with your new method, or identify an existing interface with the new method. Next, identify the relevant functions that need to support it, type check for the second interface, and add code that uses it.\u003c/p\u003e\n\u003cp\u003eThis strategy only works when the old interface without the new method can still be supported, limiting the future extensibility of your module.\u003c/p\u003e\n\u003cp\u003eWhere possible, it is better to avoid this class of problem entirely. When designing constructors, for example, prefer to return concrete types. Working with concrete types allows you to add methods in the future without breaking users, unlike interfaces. That property allows your module to be extended more easily in the future.\u003c/p\u003e\n\u003cp\u003eTip: if you do need to use an interface but don’t intend for users to implement it, you can add an unexported method. This prevents types defined outside your package from satisfying your interface without embedding, freeing you to add methods later without breaking user implementations. For example, see \u003ca href=\"https://github.com/golang/go/blob/83b181c68bf332ac7948f145f33d128377a09c42/src/testing/testing.go#L564-L567\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003etesting.TB\u003c/code\u003e’s \u003ccode\u003eprivate()\u003c/code\u003e function\u003c/a\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// TB is the interface common to T and B.\ntype TB interface {\n    Error(args ...interface{})\n    Errorf(format string, args ...interface{})\n    // ...\n\n    // A private method to prevent users implementing the\n    // interface and so future additions to it will not\n    // violate Go 1 compatibility.\n    private()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis topic is also explored in more detail in Jonathan Amsterdam’s “Detecting Incompatible API Changes” talk (\u003ca href=\"https://www.youtube.com/watch?v=JhdL5AkH-AQ\" rel=\"noreferrer\" target=\"_blank\"\u003evideo\u003c/a\u003e, \u003ca href=\"https://github.com/gophercon/2019-talks/blob/master/JonathanAmsterdam-DetectingIncompatibleAPIChanges/slides.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003eslides\u003c/a\u003e).\u003c/p\u003e\n\u003ch2 id=\"add-configuration-methods\"\u003eAdd configuration methods\u003c/h2\u003e\n\u003cp\u003eSo far we’ve talked about overt breaking changes, where changing a type or a function would cause users’ code to stop compiling. However, behavior changes can also break users, even if user code continues to compile. For example, many users expect \u003ca href=\"https://pkg.go.dev/encoding/json?tab=doc#Decoder\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ejson.Decoder\u003c/code\u003e\u003c/a\u003e to ignore fields in the JSON that are not in the argument struct. When the Go team wanted to return an error in that case, they had to be careful. Doing so without an opt-in mechanism would mean that the many users relying on those methods might start receiving errors where they hadn’t before.\u003c/p\u003e\n\u003cp\u003eSo, rather than changing the behavior for all users, they added a configuration method to the \u003ccode\u003eDecoder\u003c/code\u003e struct: \u003ca href=\"https://pkg.go.dev/encoding/json?tab=doc#Decoder.DisallowUnknownFields\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eDecoder.DisallowUnknownFields\u003c/code\u003e\u003c/a\u003e. Calling this method opts a user in to the new behavior, but not doing so preserves the old behavior for existing users.\u003c/p\u003e\n\u003ch2 id=\"maintaining-struct-compatibility\"\u003eMaintaining struct compatibility\u003c/h2\u003e\n\u003cp\u003eWe saw above that any change to a function’s signature is a breaking change. The situation is much better with structs. If you have an exported struct type, you can almost always add a field or remove an unexported field without breaking compatibility. When adding a field, make sure that its zero value is meaningful and preserves the old behavior, so that existing code that doesn’t set the field continues to work.\u003c/p\u003e\n\u003cp\u003eRecall that the authors of the \u003ccode\u003enet\u003c/code\u003e package added \u003ccode\u003eListenConfig\u003c/code\u003e in Go 1.11 because they thought more options might be forthcoming. Turns out they were right. In Go 1.13, the \u003ca href=\"https://pkg.go.dev/net@go1.13?tab=doc#ListenConfig\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eKeepAlive\u003c/code\u003e field\u003c/a\u003e was added to allow for disabling keep-alive or changing its period. The default value of zero preserves the original behavior of enabling keep-alive with a default period.\u003c/p\u003e\n\u003cp\u003eThere is one subtle way a new field can break user code unexpectedly. If all the field types in a struct are comparable—meaning values of those types can be compared with \u003ccode\u003e==\u003c/code\u003e and \u003ccode\u003e!=\u003c/code\u003e and used as a map key—then the overall struct type is comparable too. In this case, adding a new field of uncomparable type will make the overall struct type non-comparable, breaking any code that compares values of that struct type.\u003c/p\u003e\n\u003cp\u003eTo keep a struct comparable, don’t add non-comparable fields to it. You can write a test for that, or rely on the upcoming \u003ca href=\"https://pkg.go.dev/golang.org/x/exp/cmd/gorelease?tab=doc\" rel=\"noreferrer\" target=\"_blank\"\u003egorelease\u003c/a\u003e tool to catch it.\u003c/p\u003e\n\u003cp\u003eTo prevent comparison in the first place, make sure the struct has a non-comparable field. It may have one already—no slice, map or function type is comparable—but if not, one can be added like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Point struct {\n        _ [0]func()\n        X int\n        Y int\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003efunc()\u003c/code\u003e type is not comparable, and the zero-length array takes up no space. We can define a type to clarify our intent:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype doNotCompare [0]func()\n\ntype Point struct {\n        doNotCompare\n        X int\n        Y int\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eShould you use \u003ccode\u003edoNotCompare\u003c/code\u003e in your structs? If you’ve defined the struct to be used as a pointer—that is, it has pointer methods and perhaps a \u003ccode\u003eNewXXX\u003c/code\u003e constructor function that returns a pointer—then adding a \u003ccode\u003edoNotCompare\u003c/code\u003e field is probably overkill. Users of a pointer type understand that each value of the type is distinct: that if they want to compare two values, they should compare the pointers.\u003c/p\u003e\n\u003cp\u003eIf you are defining a struct intended to be used as a value directly, like our \u003ccode\u003ePoint\u003c/code\u003e example, then quite often you want it to be comparable. In the uncommon case that you have a value struct that you don’t want compared, then adding a \u003ccode\u003edoNotCompare\u003c/code\u003e field will give you the freedom to change the struct later without having to worry about breaking comparisons. On the downside, the type won’t be usable as a map key.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWhen planning an API from scratch, consider carefully how extensible the API will be to new changes in the future. And when you do need to add new features, remember the rule: add, don’t change or remove, keeping in mind the exceptions—interfaces, function arguments, and return values can’t be added in backwards-compatible ways.\u003c/p\u003e\n\u003cp\u003eIf you need to dramatically change an API, or if an API begins to lose its focus as more features are added, then it may be time for a new major version. But most of the time, making a backwards-compatible change is easy and avoids causing pain for your users.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-07-07T00:00:00Z",
  "Author": "Jean de Klerk and Jonathan Amsterdam"
}