{
  "Source": "go.dev",
  "Title": "Perfectly Reproducible, Verified Go Toolchains",
  "Link": "https://go.dev/blog/rebuild",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/rebuild\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003ePerfectly Reproducible, Verified Go Toolchains\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      28 August 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eOne of the key benefits of open-source software is that anyone can read\nthe source code and inspect what it does.\nAnd yet most software, even open-source software,\nis downloaded in the form of compiled binaries,\nwhich are much more difficult to inspect.\nIf an attacker wanted to run a \u003ca href=\"https://cloud.google.com/software-supply-chain-security/docs/attack-vectors\" rel=\"noreferrer\" target=\"_blank\"\u003esupply chain attack\u003c/a\u003e\non an open-source project,\nthe least visible way would be to replace the binaries being served while\nleaving the source code unmodified.\u003c/p\u003e\n\u003cp\u003eThe best way to address this kind of attack is to make open-source software\nbuilds \u003cem\u003ereproducible\u003c/em\u003e,\nmeaning that a build that starts with the same sources produces the same\noutputs every time it runs.\nThat way, anyone can verify that posted binaries are free of hidden changes\nby building from authentic sources and checking that the rebuilt binaries\nare bit-for-bit identical to the posted binaries.\nThat approach proves the binaries have no backdoors or other changes not\npresent in the source code,\nwithout having to disassemble or look inside them at all.\nSince anyone can verify the binaries, independent groups can easily detect\nand report supply chain attacks.\u003c/p\u003e\n\u003cp\u003eAs supply chain security becomes more important,\nso do reproducible builds, because they provide a simple way to verify the\nposted binaries for open-source projects.\u003c/p\u003e\n\u003cp\u003eGo 1.21.0 is the first Go toolchain with perfectly reproducible builds.\nEarlier toolchains were possible to reproduce,\nbut only with significant effort, and probably no one did:\nthey just trusted that the binaries posted on \u003ca href=\"/dl/\"\u003ego.dev/dl\u003c/a\u003e were the correct ones.\nNow it’s easy to “trust but verify.”\u003c/p\u003e\n\u003cp\u003eThis post explains what goes into making builds reproducible,\nexamines the many changes we had to make to Go to make Go toolchains reproducible,\nand then demonstrates one of the benefits of reproducibility by verifying\nthe Ubuntu package for Go 1.21.0.\u003c/p\u003e\n\u003ch2 id=\"how\"\u003eMaking a Build Reproducible\u003c/h2\u003e\n\u003cp\u003eComputers are generally deterministic, so you might think all builds would\nbe equally reproducible.\nThat’s only true from a certain point of view.\nLet’s call a piece of information a \u003cem\u003erelevant input\u003c/em\u003e when the output of\na build can change depending on that input.\nA build is reproducible if it can be repeated with all the same relevant inputs.\nUnfortunately, lots of build tools turn out to incorporate inputs that we\nwould usually not realize are relevant and that might be difficult to recreate\nor provide as input.\nLet’s call an input an \u003cem\u003eunintentional input\u003c/em\u003e when it turns out to be relevant\nbut we didn’t mean it to be.\u003c/p\u003e\n\u003cp\u003eThe most common unintentional input in build systems is the current time.\nIf a build writes an executable to disk, the file system records the current\ntime as the executable’s modification time.\nIf the build then packages that file using a tool like “tar” or “zip”,\nthe modification time is written into the archive.\nWe certainly didn’t want our build to change based on the current time, but it does.\nSo the current time turns out to be an unintentional input to the build.\nWorse, most programs don’t let you provide the current time as an input,\nso there is no way to repeat this build.\nTo fix this, we might set the time stamps on created files to Unix time\n0 or to a specific time read from one of the build’s source files.\nThat way, the current time is no longer a relevant input to the build.\u003c/p\u003e\n\u003cp\u003eCommon relevant inputs to a build include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ethe specific version of the source code to build;\u003c/li\u003e\n\u003cli\u003ethe specific versions of dependencies that will be included in the build;\u003c/li\u003e\n\u003cli\u003ethe operating system running the build, which may affect path names in the resulting binaries;\u003c/li\u003e\n\u003cli\u003ethe architecture of the CPU on the build system,\nwhich may affect which optimizations the compiler uses or the layout of certain data structures;\u003c/li\u003e\n\u003cli\u003ethe compiler version being used, as well as compiler options passed to it, which affect how the code is compiled;\u003c/li\u003e\n\u003cli\u003ethe name of the directory containing the source code, which may appear in debug information;\u003c/li\u003e\n\u003cli\u003ethe user name, group name, uid, and gid of the account running the build, which may appear in file metadata in an archive;\u003c/li\u003e\n\u003cli\u003eand many more.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo have a reproducible build, every relevant input must be configurable in the build,\nand then the binaries must be posted alongside an explicit configuration\nlisting every relevant input.\nIf you’ve done that, you have a reproducible build. Congratulations!\u003c/p\u003e\n\u003cp\u003eWe’re not done, though. If the binaries can only be reproduced if you\nfirst find a computer with the right architecture,\ninstall a specific operating system version,\ncompiler version, put the source code in the right directory,\nset your user identity correctly, and so on,\nthat may be too much work in practice for anyone to bother.\u003c/p\u003e\n\u003cp\u003eWe want builds to be not just reproducible but \u003cem\u003eeasy to reproduce\u003c/em\u003e.\nTo do that, we need to identify relevant inputs and then,\ninstead of documenting them, eliminate them.\nThe build obviously has to depend on the source code being built,\nbut everything else can be eliminated.\nWhen a build’s only relevant input is its source code,\nlet’s call that \u003cem\u003eperfectly reproducible\u003c/em\u003e.\u003c/p\u003e\n\u003ch2 id=\"go\"\u003ePerfectly Reproducible Builds for Go\u003c/h2\u003e\n\u003cp\u003eAs of Go 1.21, the Go toolchain is perfectly reproducible:\nits only relevant input is the source code for that build.\nWe can build a specific toolchain (say, Go for Linux/x86-64) on a Linux/x86-64 host,\nor a Windows/ARM64 host, or a FreeBSD/386 host,\nor any other host that supports Go, and we can use any Go bootstrap compiler,\nincluding bootstrapping all the way back to Go 1.4’s C implementation,\nand we can vary any other details.\nNone of that changes the toolchains that are built.\nIf we start with the same toolchain source code,\nwe will get the exact same toolchain binaries out.\u003c/p\u003e\n\u003cp\u003eThis perfect reproducibility is the culmination of efforts dating back originally to Go 1.10,\nalthough most of the effort was concentrated in Go 1.20 and Go 1.21.\nThis section highlights some of the most interesting relevant inputs that we eliminated.\u003c/p\u003e\n\u003ch3 id=\"go110\"\u003eReproducibility in Go 1.10\u003c/h3\u003e\n\u003cp\u003eGo 1.10 introduced a content-aware build cache that decides whether targets\nare up-to-date based on a fingerprint of the build inputs instead of file modification times.\nBecause the toolchain itself is one of those build inputs,\nand because Go is written in Go, the \u003ca href=\"/s/go15bootstrap\"\u003ebootstrap process\u003c/a\u003e\nwould only converge if the toolchain build on a single machine was reproducible.\nThe overall toolchain build looks like this:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"rebuild/bootstrap.png\" srcset=\"rebuild/bootstrap.png 1x, rebuild/bootstrap@2x.png 2x\" width=\"515\" height=\"177\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eWe start by building the sources for the current Go toolchain using an earlier Go version,\nthe bootstrap toolchain (Go 1.10 used Go 1.4, written in C;\nGo 1.21 uses Go 1.17).\nThat produces “toolchain1”, which we use to build everything again,\nproducing “toolchain2”, which we use to build everything again,\nproducing “toolchain3”.\u003c/p\u003e\n\u003cp\u003eToolchain1 and toolchain2 have been built from the same sources but with\ndifferent Go implementations (compilers and libraries),\nso their binaries are certain to be different.\nHowever, if both Go implementations are non-buggy,\ncorrect implementations, toolchain1 and toolchain2 should behave exactly the same.\nIn particular, when presented with the Go 1.X sources,\ntoolchain1’s output (toolchain2) and toolchain2’s output (toolchain3)\nshould be identical,\nmeaning toolchain2 and toolchain3 should be identical.\u003c/p\u003e\n\u003cp\u003eAt least, that’s the idea. Making that true in practice required removing a couple unintentional inputs:\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRandomness.\u003c/strong\u003e Map iteration and running work in multiple goroutines serialized\nwith locks both introduce randomness in the order that results may be generated.\nThis randomness can make the toolchain produce one of several different\npossible outputs each time it runs.\nTo make the build reproducible, we had to find each of these and sort the\nrelevant list of items before using it to generate output.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBootstrap Libraries.\u003c/strong\u003e Any library used by the compiler that can choose\nfrom multiple different correct outputs might change its output from one\nGo version to the next.\nIf that library output change causes a compiler output change,\nthen toolchain1 and toolchain2 will not be semantically identical,\nand toolchain2 and toolchain3 will not be bit-for-bit identical.\u003c/p\u003e\n\u003cp\u003eThe canonical example is the \u003ca href=\"/pkg/sort/\"\u003e\u003ccode\u003esort\u003c/code\u003e\u003c/a\u003e package,\nwhich can place elements that compare equal in \u003ca href=\"/blog/compat#output\"\u003eany order it likes\u003c/a\u003e.\nA register allocator might sort to prioritize commonly used variables,\nand the linker sorts symbols in the data section by size.\nTo completely eliminate any effect from the sorting algorithm,\nthe comparison function used must never report two distinct elements as equal.\nIn practice, this invariant turned out to be too onerous to impose on every\nuse of sort in the toolchain,\nso instead we arranged to copy the Go 1.X \u003ccode\u003esort\u003c/code\u003e package into the source\ntree that is presented to the bootstrap compiler.\nThat way, the compiler uses the same sort algorithm when using the bootstrap\ntoolchain as it does when built with itself.\u003c/p\u003e\n\u003cp\u003eAnother package we had to copy was \u003ca href=\"/pkg/compress/zlib/\"\u003e\u003ccode\u003ecompress/zlib\u003c/code\u003e\u003c/a\u003e,\nbecause the linker writes compressed debug information,\nand optimizations to compression libraries can change the exact output.\nOver time, we’ve \u003ca href=\"https://go.googlesource.com/go/+/go1.21.0/src/cmd/dist/buildtool.go#55\" rel=\"noreferrer\" target=\"_blank\"\u003eadded other packages to that list too\u003c/a\u003e.\nThis approach has the added benefit of allowing the Go 1.X compiler to use\nnew APIs added to those packages immediately,\nat the cost that those packages must be written to compile with older versions of Go.\u003c/p\u003e\n\u003ch3 id=\"go120\"\u003eReproducibility in Go 1.20\u003c/h3\u003e\n\u003cp\u003eWork on Go 1.20 prepared for both easy reproducible builds and \u003ca href=\"toolchain\"\u003etoolchain management\u003c/a\u003e\nby removing two more relevant inputs from the toolchain build.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHost C toolchain.\u003c/strong\u003e Some Go packages, most notably \u003ccode\u003enet\u003c/code\u003e,\ndefault to \u003ca href=\"cgo\"\u003eusing \u003ccode\u003ecgo\u003c/code\u003e\u003c/a\u003e on most operating systems.\nIn some cases, such as macOS and Windows,\ninvoking system DLLs using \u003ccode\u003ecgo\u003c/code\u003e is the only reliable way to resolve host names.\nWhen we use \u003ccode\u003ecgo\u003c/code\u003e, though, we invoke the host C toolchain (meaning a specific\nC compiler and C library),\nand different toolchains have different compilation algorithms and library code,\nproducing different outputs.\nThe build graph for a \u003ccode\u003ecgo\u003c/code\u003e package looks like:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"rebuild/cgo.png\" srcset=\"rebuild/cgo.png 1x, rebuild/cgo@2x.png 2x\" width=\"441\" height=\"344\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe host C toolchain is therefore a relevant input to the pre-compiled \u003ccode\u003enet.a\u003c/code\u003e\nthat ships with the toolchain.\nFor Go 1.20, we decided to fix this by removing \u003ccode\u003enet.a\u003c/code\u003e from the toolchain.\nThat is, Go 1.20 stopped shipping pre-compiled packages to seed the build cache with.\nNow, the first time a program uses package \u003ccode\u003enet\u003c/code\u003e,\nthe Go toolchain compiles it using the local system’s C toolchain and caches that result.\nIn addition to removing a relevant input from toolchain builds and making\ntoolchain downloads smaller,\nnot shipping pre-compiled packages also makes toolchain downloads more portable.\nIf we build package \u003ccode\u003enet\u003c/code\u003e on one system with one C toolchain and then compile\nother parts of the program on a different system with a different C toolchain,\nin general there is no guarantee that the two parts can be linked together.\u003c/p\u003e\n\u003cp\u003eOne reason we shipped the pre-compiled \u003ccode\u003enet\u003c/code\u003e package in the first place\nwas to allow building programs that used package net even on systems without\na C toolchain installed.\nIf there’s no pre-compiled package, what happens on those systems? The\nanswer varies by operating system,\nbut in all cases we arranged for the Go toolchain to continue to work well\nfor building pure Go programs without a host C toolchain.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eOn macOS, we rewrote package net using the underlying mechanisms that cgo would use,\nwithout any actual C code.\nThis avoids invoking the host C toolchain but still emits a binary that\nrefers to the required system DLLs.\nThis approach is only possible because every Mac has the same dynamic libraries installed.\nMaking the non-cgo macOS package net use the system DLLs also meant that\ncross-compiled macOS executables now use the system DLLs for network access,\nresolving a long-standing feature request.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOn Windows, package net already made direct use of DLLs without C code, so nothing needed to be changed.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eOn Unix systems, we cannot assume a specific DLL interface to network code,\nbut the pure Go version works fine for systems that use typical IP and DNS setups.\nAlso, it is much easier to install a C toolchain on Unix systems than it\nis on macOS and especially Windows.\nWe changed the \u003ccode\u003ego\u003c/code\u003e command to enable or disable \u003ccode\u003ecgo\u003c/code\u003e automatically based\non whether the system has a C toolchain installed.\nUnix systems without a C toolchain fall back to the pure Go version of package net,\nand in the rare cases where that’s not good enough,\nthey can install a C toolchain.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHaving dropped the pre-compiled packages,\nthe only part of the Go toolchain that still depended on the host C toolchain\nwas binaries built using package net,\nspecifically the \u003ccode\u003ego\u003c/code\u003e command.\nWith the macOS improvements, it was now viable to build those commands with \u003ccode\u003ecgo\u003c/code\u003e disabled,\ncompletely removing the host C toolchain as an input,\nbut we left that final step for Go 1.21.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHost dynamic linker.\u003c/strong\u003e When programs use \u003ccode\u003ecgo\u003c/code\u003e on a system using dynamically linked C libraries,\nthe resulting binaries contain the path to the system’s dynamic linker,\nsomething like \u003ccode\u003e/lib64/ld-linux-x86-64.so.2\u003c/code\u003e.\nIf the path is wrong, the binaries don’t run.\nTypically each operating system/architecture combination has a single correct\nanswer for this path.\nUnfortunately, musl-based Linuxes like Alpine Linux use a different dynamic\nlinker than glibc-based Linuxes like Ubuntu.\nTo make Go run at all on Alpine Linux, in Go bootstrap process looked like this:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"rebuild/linker1.png\" srcset=\"rebuild/linker1.png 1x, rebuild/linker1@2x.png 2x\" width=\"480\" height=\"209\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe bootstrap program cmd/dist inspected the local system’s dynamic linker\nand wrote that value into a new source file compiled along with the rest\nof the linker sources,\neffectively hard-coding that default into the linker itself.\nThen when the linker built a program from a set of compiled packages,\nit used that default.\nThe result is that a Go toolchain built on Alpine is different from a toolchain built on Ubuntu:\nthe host configuration is a relevant input to the toolchain build.\nThis is a reproducibility problem but also a portability problem:\na Go toolchain built on Alpine doesn’t build working binaries or even\nrun on Ubuntu, and vice versa.\u003c/p\u003e\n\u003cp\u003eFor Go 1.20, we took a step toward fixing the reproducibility problem by\nchanging the linker to consult the host configuration when it is running,\ninstead of having a default hard-coded at toolchain build time:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"rebuild/linker2.png\" srcset=\"rebuild/linker2.png 1x, rebuild/linker2@2x.png 2x\" width=\"450\" height=\"175\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThis fixed the portability of the linker binary on Alpine Linux,\nalthough not the overall toolchain, since the \u003ccode\u003ego\u003c/code\u003e command still used package\n\u003ccode\u003enet\u003c/code\u003e and therefore \u003ccode\u003ecgo\u003c/code\u003e and therefore had a dynamic linker reference in its own binary.\nJust as in the previous section, compiling the \u003ccode\u003ego\u003c/code\u003e command without \u003ccode\u003ecgo\u003c/code\u003e\nenabled would fix this,\nbut we left that change for Go 1.21.\n(We didn’t feel there was enough time left in the Go 1.20 cycle to test\nsuch that change properly.)\u003c/p\u003e\n\u003ch3 id=\"go121\"\u003eReproducibility in Go 1.21\u003c/h3\u003e\n\u003cp\u003eFor Go 1.21, the goal of perfect reproducibility was in sight,\nand we took care of the remaining, mostly small,\nrelevant inputs that remained.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHost C toolchain and dynamic linker.\u003c/strong\u003e As discussed above,\nGo 1.20 took important steps toward removing the host C toolchain and dynamic\nlinker as relevant inputs.\nGo 1.21 completed the removal of these relevant inputs by building the toolchain\nwith \u003ccode\u003ecgo\u003c/code\u003e disabled.\nThis improved portability of the toolchain too:\nGo 1.21 is the first Go release where the standard Go toolchain runs unmodified\non Alpine Linux systems.\u003c/p\u003e\n\u003cp\u003eRemoving these relevant inputs made it possible to cross-compile a Go toolchain\nfrom a different system without any loss in functionality.\nThat in turn improved the supply chain security of the Go toolchain:\nwe can now build Go toolchains for all target systems using a trusted Linux/x86-64 system,\ninstead of needing to arrange a separate trusted system for each target.\nAs a result, Go 1.21 is the first release to include posted binaries for\nall systems at \u003ca href=\"/dl/\"\u003ego.dev/dl/\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSource directory.\u003c/strong\u003e Go programs include full paths in the runtime and debugging metadata,\nso that when a program crashes or is run in a debugger,\nstack traces include the full path to the source file,\nnot just the name of the file in an unspecified directory.\nUnfortunately, including the full path makes the directory where the source\ncode is stored a relevant input to the build.\nTo fix this, Go 1.21 changed the release toolchain builds to install commands\nlike the compiler using \u003ccode\u003ego install -trimpath\u003c/code\u003e,\nwhich replaces the source directory with the module path of the code.\nIf a released compiler crashes, the stack trace will print paths like \u003ccode\u003ecmd/compile/main.go\u003c/code\u003e\ninstead of \u003ccode\u003e/home/user/go/src/cmd/compile/main.go\u003c/code\u003e.\nSince the full paths would refer to a directory on a different machine anyway,\nthis rewrite is no loss.\nOn the other hand, for non-release builds,\nwe keep the full path, so that when developers working on the compiler itself cause it to crash,\nIDEs and other tools reading those crashes can easily find the correct source file.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHost operating system.\u003c/strong\u003e Paths on Windows systems are backslash-separated,\nlike \u003ccode\u003ecmd\\compile\\main.go\u003c/code\u003e.\nOther systems use forward slashes, like \u003ccode\u003ecmd/compile/main.go\u003c/code\u003e.\nAlthough earlier versions of Go had normalized most of these paths to use forward slashes,\none inconsistency had crept back in, causing slightly different toolchain builds on Windows.\nWe found and fixed the bug.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHost architecture.\u003c/strong\u003e Go runs on a variety of ARM systems and can emit\ncode using a software library for floating-point math (SWFP) or using hardware\nfloating-point instructions (HWFP).\nToolchains defaulting to one mode or the other will necessarily differ.\nLike we saw with the dynamic linker earlier,\nthe Go bootstrap process inspected the build system to make sure that the\nresulting toolchain worked on that system.\nFor historical reasons, the rule was “assume SWFP unless the build is\nrunning on an ARM system with floating-point hardware”,\nwith cross-compiled toolchains assuming SWFP.\nThe vast majority of ARM systems today do have floating-point hardware,\nso this introduced an unnecessary difference between natively compiled and\ncross-compiled toolchains,\nand as a further wrinkle, Windows ARM builds always assumed HWFP,\nmaking the decision operating system-dependent.\nWe changed the rule to be “assume HWFP unless the build is running on\nan ARM system without floating-point hardware”.\nThis way, cross-compilation and builds on modern ARM systems produce identical toolchains.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePackaging logic.\u003c/strong\u003e All the code to create the actual toolchain archives\nwe post for download lived in a separate Git repository,\ngolang.org/x/build, and the exact details of how archives get packaged does change over time.\nIf you wanted to reproduce those archives,\nyou needed to have the right version of that repository.\nWe removed this relevant input by moving the code to package the archives\ninto the main Go source tree, as \u003ccode\u003ecmd/distpack\u003c/code\u003e.\nAs of Go 1.21, if you have the sources for a given version of Go,\nyou also have the sources for packaging the archives.\nThe golang.org/x/build repository is no longer a relevant input.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUser IDs.\u003c/strong\u003e The tar archives we posted for download were built from a\ndistribution written to the file system,\nand using \u003ca href=\"/pkg/archive/tar/#FileInfoHeader\"\u003e\u003ccode\u003etar.FileInfoHeader\u003c/code\u003e\u003c/a\u003e copies\nthe user and group IDs from the file system into the tar file,\nmaking the user running the build a relevant input.\nWe changed the archiving code to clear these.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCurrent time.\u003c/strong\u003e Like with user IDs, the tar and zip archives we posted\nfor download had been built by copying the file system modification times into the archives,\nmaking the current time a relevant input.\nWe could have cleared the time, but we thought it would look surprising\nand possibly even break some tools to use the Unix or MS-DOS zero time.\nInstead, we changed the go/VERSION file stored in the repository to add\nthe time associated with that version:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go1.21.0/VERSION\ngo1.21.0\ntime 2023-08-04T20:14:06Z\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe packagers now copy the time from the VERSION file when writing files to archives,\ninstead of copying the local file’s modification times.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCryptographic signing keys.\u003c/strong\u003e The Go toolchain for macOS won’t run on\nend-user systems unless we sign the binaries with an Apple-approved signing key.\nWe use an internal system to get them signed with Google’s signing key,\nand obviously we cannot share that secret key in order to allow others to\nreproduce the signed binaries.\nInstead, we wrote a verifier that can check whether two binaries are identical\nexcept for their signatures.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eOS-specific packagers.\u003c/strong\u003e We use the Xcode tools \u003ccode\u003epkgbuild\u003c/code\u003e and \u003ccode\u003eproductbuild\u003c/code\u003e\nto create the downloadable macOS PKG installer,\nand we use WiX to create the downloadable Windows MSI installer.\nWe don’t want verifiers to need the same exact versions of those tools,\nso we took the same approach as for the cryptographic signing keys,\nwriting a verifier that can look inside the packages and check that the\ntoolchain files are exactly as expected.\u003c/p\u003e\n\u003ch2 id=\"verify\"\u003eVerifying the Go Toolchains\u003c/h2\u003e\n\u003cp\u003eIt’s not enough to make Go toolchains reproducible once.\nWe want to make sure they stay reproducible,\nand we want to make sure others can reproduce them easily.\u003c/p\u003e\n\u003cp\u003eTo keep ourselves honest, we now build all Go distributions on both a trusted\nLinux/x86-64 system and a Windows/x86-64 system.\nExcept for the architecture, the two systems have almost nothing in common.\nThe two systems must produce bit-for-bit identical archives or else we do\nnot proceed with the release.\u003c/p\u003e\n\u003cp\u003eTo allow others to verify that we’re honest,\nwe’ve written and published a verifier,\n\u003ca href=\"https://pkg.go.dev/golang.org/x/build/cmd/gorebuild\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/build/cmd/gorebuild\u003c/code\u003e\u003c/a\u003e.\nThat program will start with the source code in our Git repository and rebuild the\ncurrent Go versions, checking that they match the archives posted on \u003ca href=\"/dl/\"\u003ego.dev/dl\u003c/a\u003e.\nMost archives are required to match bit-for-bit.\nAs mentioned above, there are three exceptions where a more relaxed check is used:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eThe macOS tar.gz file is expected to differ,\nbut then the verifier compares the contents inside.\nThe rebuilt and posted copies must contain the same files,\nand all the files must match exactly, except for executable binaries.\nExecutable binaries must match exactly after stripping code signatures.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe macOS PKG installer is not rebuilt. Instead,\nthe verifier reads the files inside the PKG installer and checks that they\nmatch the macOS tar.gz exactly,\nagain after code signature stripping.\nIn the long term, the PKG creation is trivial enough that it could potentially\nbe added to cmd/distpack,\nbut the verifier would still have to parse the PKG file to run the signature-ignoring\ncode executable comparison.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe Windows MSI installer is not rebuilt.\nInstead, the verifier invokes the Linux program \u003ccode\u003emsiextract\u003c/code\u003e to extract\nthe files inside and check that they match the rebuilt Windows zip file exactly.\nIn the long term, perhaps the MSI creation could be added to cmd/distpack,\nand then the verifier could use a bit-for-bit MSI comparison.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe run \u003ccode\u003egorebuild\u003c/code\u003e nightly, posting the results at \u003ca href=\"/rebuild\"\u003ego.dev/rebuild\u003c/a\u003e,\nand of course anyone else can run it too.\u003c/p\u003e\n\u003ch2 id=\"ubuntu\"\u003eVerifying Ubuntu’s Go Toolchain\u003c/h2\u003e\n\u003cp\u003eThe Go toolchain’s easily reproducible builds should mean that the binaries\nin the toolchains posted on go.dev match the binaries included in other packaging systems,\neven when those packagers build from source.\nEven if the packagers have compiled with different configurations or other changes,\nthe easily reproducible builds should still make it easy to reproduce their binaries.\nTo demonstrate this, let’s reproduce the Ubuntu \u003ccode\u003egolang-1.21\u003c/code\u003e package\nversion \u003ccode\u003e1.21.0-1\u003c/code\u003e for Linux/x86-64.\u003c/p\u003e\n\u003cp\u003eTo start, we need to download and extract the Ubuntu packages,\nwhich are \u003ca href=\"https://linux.die.net/man/1/ar\" rel=\"noreferrer\" target=\"_blank\"\u003ear(1) archives\u003c/a\u003e containing zstd-compressed tar archives:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir deb\n$ cd deb\n$ curl -LO http://mirrors.kernel.org/ubuntu/pool/main/g/golang-1.21/golang-1.21-src_1.21.0-1_all.deb\n$ ar xv golang-1.21-src_1.21.0-1_all.deb\nx - debian-binary\nx - control.tar.zst\nx - data.tar.zst\n$ unzstd \u0026lt; data.tar.zst | tar xv\n...\nx ./usr/share/go-1.21/src/archive/tar/common.go\nx ./usr/share/go-1.21/src/archive/tar/example_test.go\nx ./usr/share/go-1.21/src/archive/tar/format.go\nx ./usr/share/go-1.21/src/archive/tar/fuzz_test.go\n...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat was the source archive. Now the amd64 binary archive:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ rm -f debian-binary *.zst\n$ curl -LO http://mirrors.kernel.org/ubuntu/pool/main/g/golang-1.21/golang-1.21-go_1.21.0-1_amd64.deb\n$ ar xv golang-1.21-src_1.21.0-1_all.deb\nx - debian-binary\nx - control.tar.zst\nx - data.tar.zst\n$ unzstd \u0026lt; data.tar.zst | tar xv | grep -v \u0026#39;/$\u0026#39;\n...\nx ./usr/lib/go-1.21/bin/go\nx ./usr/lib/go-1.21/bin/gofmt\nx ./usr/lib/go-1.21/go.env\nx ./usr/lib/go-1.21/pkg/tool/linux_amd64/addr2line\nx ./usr/lib/go-1.21/pkg/tool/linux_amd64/asm\nx ./usr/lib/go-1.21/pkg/tool/linux_amd64/buildid\n...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUbuntu splits the normal Go tree into two halves,\nin /usr/share/go-1.21 and /usr/lib/go-1.21.\nLet’s put them back together:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir go-ubuntu\n$ cp -R usr/share/go-1.21/* usr/lib/go-1.21/* go-ubuntu\ncp: cannot overwrite directory go-ubuntu/api with non-directory usr/lib/go-1.21/api\ncp: cannot overwrite directory go-ubuntu/misc with non-directory usr/lib/go-1.21/misc\ncp: cannot overwrite directory go-ubuntu/pkg/include with non-directory usr/lib/go-1.21/pkg/include\ncp: cannot overwrite directory go-ubuntu/src with non-directory usr/lib/go-1.21/src\ncp: cannot overwrite directory go-ubuntu/test with non-directory usr/lib/go-1.21/test\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe errors are complaining about copying symlinks, which we can ignore.\u003c/p\u003e\n\u003cp\u003eNow we need to download and extract the upstream Go sources:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ curl -LO https://go.googlesource.com/go/+archive/refs/tags/go1.21.0.tar.gz\n$ mkdir go-clean\n$ cd go-clean\n$ curl -L https://go.googlesource.com/go/+archive/refs/tags/go1.21.0.tar.gz | tar xzv\n...\nx src/archive/tar/common.go\nx src/archive/tar/example_test.go\nx src/archive/tar/format.go\nx src/archive/tar/fuzz_test.go\n...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo skip some trial and error, it turns out that Ubuntu builds Go with \u003ccode\u003eGO386=softfloat\u003c/code\u003e,\nwhich forces the use of software floating point when compiling for 32-bit x86,\nand strips (removes symbol tables from) the resulting ELF binaries.\nLet’s start with a \u003ccode\u003eGO386=softfloat\u003c/code\u003e build:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd src\n$ GOOS=linux GO386=softfloat ./make.bash -distpack\nBuilding Go cmd/dist using /Users/rsc/sdk/go1.17.13. (go1.17.13 darwin/amd64)\nBuilding Go toolchain1 using /Users/rsc/sdk/go1.17.13.\nBuilding Go bootstrap cmd/go (go_bootstrap) using Go toolchain1.\nBuilding Go toolchain2 using go_bootstrap and Go toolchain1.\nBuilding Go toolchain3 using go_bootstrap and Go toolchain2.\nBuilding commands for host, darwin/amd64.\nBuilding packages and commands for target, linux/amd64.\nPackaging archives for linux/amd64.\ndistpack: 818d46ede85682dd go1.21.0.src.tar.gz\ndistpack: 4fcd8651d084a03d go1.21.0.linux-amd64.tar.gz\ndistpack: eab8ed80024f444f v0.0.1-go1.21.0.linux-amd64.zip\ndistpack: 58528cce1848ddf4 v0.0.1-go1.21.0.linux-amd64.mod\ndistpack: d8da1f27296edea4 v0.0.1-go1.21.0.linux-amd64.info\n---\nInstalled Go for linux/amd64 in /Users/rsc/deb/go-clean\nInstalled commands in /Users/rsc/deb/go-clean/bin\n*** You need to add /Users/rsc/deb/go-clean/bin to your PATH.\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat left the standard package in \u003ccode\u003epkg/distpack/go1.21.0.linux-amd64.tar.gz\u003c/code\u003e.\nLet’s unpack it and strip the binaries to match Ubuntu:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd ../..\n$ tar xzvf go-clean/pkg/distpack/go1.21.0.linux-amd64.tar.gz\nx go/CONTRIBUTING.md\nx go/LICENSE\nx go/PATENTS\nx go/README.md\nx go/SECURITY.md\nx go/VERSION\n...\n$ elfstrip go/bin/* go/pkg/tool/linux_amd64/*\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we can diff the Go toolchain we’ve created on our Mac with the Go toolchain that Ubuntu ships:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ diff -r go go-ubuntu\nOnly in go: CONTRIBUTING.md\nOnly in go: LICENSE\nOnly in go: PATENTS\nOnly in go: README.md\nOnly in go: SECURITY.md\nOnly in go: codereview.cfg\nOnly in go: doc\nOnly in go: lib\nBinary files go/misc/chrome/gophertool/gopher.png and go-ubuntu/misc/chrome/gophertool/gopher.png differ\nOnly in go-ubuntu/pkg/tool/linux_amd64: dist\nOnly in go-ubuntu/pkg/tool/linux_amd64: distpack\nOnly in go/src: all.rc\nOnly in go/src: clean.rc\nOnly in go/src: make.rc\nOnly in go/src: run.rc\ndiff -r go/src/syscall/mksyscall.pl go-ubuntu/src/syscall/mksyscall.pl\n1c1\n\u0026lt; #!/usr/bin/env perl\n---\n\u0026gt; #! /usr/bin/perl\n...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ve successfully reproduced the Ubuntu package’s executables and identified\nthe complete set of changes that remain:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVarious metadata and supporting files have been deleted.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003egopher.png\u003c/code\u003e file has been modified. On closer inspection the two are\nidentical except for an embedded timestamp that Ubuntu has updated.\nPerhaps Ubuntu’s packaging scripts recompressed the png with a tool that\nrewrites the timestamp even when it cannot improve on the existing compression.\u003c/li\u003e\n\u003cli\u003eThe binaries \u003ccode\u003edist\u003c/code\u003e and \u003ccode\u003edistpack\u003c/code\u003e, which are built during bootstrap but\nnot included in standard archives,\nhave been included in the Ubuntu package.\u003c/li\u003e\n\u003cli\u003eThe Plan 9 build scripts (\u003ccode\u003e*.rc\u003c/code\u003e) have been deleted, although the Windows build scripts (\u003ccode\u003e*.bat\u003c/code\u003e) remain.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emksyscall.pl\u003c/code\u003e and seven other Perl scripts not shown have had their headers changed.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNote in particular that we’ve reconstructed the toolchain binaries bit-for-bit:\nthey do not show up in the diff at all.\nThat is, we proved that the Ubuntu Go binaries correspond exactly to the\nupstream Go sources.\u003c/p\u003e\n\u003cp\u003eEven better, we proved this without using any Ubuntu software at all:\nthese commands were run on a Mac, and \u003ca href=\"https://github.com/rsc/tmp/blob/master/unzstd/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eunzstd\u003c/code\u003e\u003c/a\u003e\nand \u003ca href=\"https://github.com/rsc/tmp/blob/master/elfstrip/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eelfstrip\u003c/code\u003e\u003c/a\u003e are short Go programs.\nA sophisticated attacker might insert malicious code into an Ubuntu package\nby changing the package-creation tools.\nIf they did, reproducing the Go Ubuntu package from clean sources using\nthose malicious tools would still produce bit-for-bit identical copies of\nthe malicious packages.\nThis attack would be invisible to that kind of rebuild,\nmuch like \u003ca href=\"https://dl.acm.org/doi/10.1145/358198.358210\" rel=\"noreferrer\" target=\"_blank\"\u003eKen Thompson’s compiler attack\u003c/a\u003e.\nVerifying the Ubuntu packages using no Ubuntu software at all is a much\nstronger check.\nGo’s perfectly reproducible builds, which don’t depend on unindented\ndetails like the host operating system,\nhost architecture, and host C toolchain, are what make this stronger check possible.\u003c/p\u003e\n\u003cp\u003e(As an aside for the historical record, Ken Thompson told me once that his\nattack was in fact detected,\nbecause the compiler build stopped being reproducible.\nIt had a bug: a string constant in the backdoor added to the compiler was\nimperfectly handled and grew by a single NUL byte each time the compiler compiled itself.\nEventually someone noticed the non-reproducible build and tried to find the cause by compiling to assembly.\nThe compiler’s backdoor did not reproduce itself into assembly output at all,\nso assembling that output removed the backdoor.)\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eReproducible builds are an important tool for strengthening the open-source supply chain.\nFrameworks like \u003ca href=\"https://slsa.dev/\" rel=\"noreferrer\" target=\"_blank\"\u003eSLSA\u003c/a\u003e focus on provenance and a software\nchain of custody that can be used to inform decisions about trust.\nReproducible builds complement that approach by providing a way to verify\nthat the trust is well-placed.\u003c/p\u003e\n\u003cp\u003ePerfect reproducibility (when the source files are the build’s only relevant\ninput) is only possible for programs that build themselves,\nlike compiler toolchains.\nIt is a lofty but worthwhile goal precisely because self-hosting compiler\ntoolchains are otherwise quite difficult to verify.\nGo’s perfect reproducibility means that,\nassuming packagers don’t modify the source code,\nevery repackaging of Go 1.21.0 for Linux/x86-64 (substitute your favorite\nsystem) in any form should be distributing exactly the same binaries,\neven when they all build from source.\nWe’ve seen that this is not quite true for Ubuntu Linux,\nbut perfect reproducibility still lets us reproduce the Ubuntu packaging\nusing a very different, non-Ubuntu system.\u003c/p\u003e\n\u003cp\u003eIdeally all open source software distributed in binary form would have easy-to-reproduce builds.\nIn practice, as we’ve seen in this post,\nit is very easy for unintended inputs to leak into builds.\nFor Go programs that don’t need \u003ccode\u003ecgo\u003c/code\u003e, a reproducible build is as simple\nas compiling with \u003ccode\u003eCGO_ENABLED=0 go build -trimpath\u003c/code\u003e.\nDisabling \u003ccode\u003ecgo\u003c/code\u003e removes the host C toolchain as a relevant input,\nand \u003ccode\u003e-trimpath\u003c/code\u003e removes the current directory.\nIf your program does need \u003ccode\u003ecgo\u003c/code\u003e, you need to arrange for a specific host\nC toolchain version before running \u003ccode\u003ego build\u003c/code\u003e,\nsuch as by running the build in a specific virtual machine or container image.\u003c/p\u003e\n\u003cp\u003eMoving beyond Go, the \u003ca href=\"https://reproducible-builds.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eReproducible Builds\u003c/a\u003e\nproject aims to improve reproducibility of all open source and is a good\nstarting point for more information about making your own software builds reproducible.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-08-28T00:00:00Z",
  "Author": "Russ Cox"
}