{
  "Source": "go.dev",
  "Title": "C? Go? Cgo!",
  "Link": "https://go.dev/blog/cgo",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/cgo\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eC? Go? Cgo!\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      17 March 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eCgo lets Go packages call C code. Given a Go source file written with some special features,\ncgo outputs Go and C files that can be combined into a single Go package.\u003c/p\u003e\n\u003cp\u003eTo lead with an example, here’s a Go package that provides two functions -\n\u003ccode\u003eRandom\u003c/code\u003e and \u003ccode\u003eSeed\u003c/code\u003e - that wrap C’s \u003ccode\u003erandom\u003c/code\u003e and \u003ccode\u003esrandom\u003c/code\u003e functions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage rand\n\n/*\n#include \u0026lt;stdlib.h\u0026gt;\n*/\nimport \u0026#34;C\u0026#34;\n\nfunc Random() int {\n    return int(C.random())\n}\n\nfunc Seed(i int) {\n    C.srandom(C.uint(i))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s look at what’s happening here, starting with the import statement.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003erand\u003c/code\u003e package imports \u003ccode\u003e\u0026#34;C\u0026#34;\u003c/code\u003e, but you’ll find there’s no such package\nin the standard Go library.\nThat’s because \u003ccode\u003eC\u003c/code\u003e is a “pseudo-package”,\na special name interpreted by cgo as a reference to C’s name space.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003erand\u003c/code\u003e package contains four references to the \u003ccode\u003eC\u003c/code\u003e package:\nthe calls to \u003ccode\u003eC.random\u003c/code\u003e and \u003ccode\u003eC.srandom\u003c/code\u003e, the conversion \u003ccode\u003eC.uint(i)\u003c/code\u003e,\nand the \u003ccode\u003eimport\u003c/code\u003e statement.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eRandom\u003c/code\u003e function calls the standard C library’s \u003ccode\u003erandom\u003c/code\u003e function and returns the result.\nIn C, \u003ccode\u003erandom\u003c/code\u003e returns a value of the C type \u003ccode\u003elong\u003c/code\u003e,\nwhich cgo represents as the type \u003ccode\u003eC.long\u003c/code\u003e.\nIt must be converted to a Go type before it can be used by Go code outside this package,\nusing an ordinary Go type conversion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Random() int {\n    return int(C.random())\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s an equivalent function that uses a temporary variable to illustrate the type conversion more explicitly:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Random() int {\n    var r C.long = C.random()\n    return int(r)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eSeed\u003c/code\u003e function does the reverse, in a way.\nIt takes a regular Go \u003ccode\u003eint\u003c/code\u003e, converts it to the C \u003ccode\u003eunsigned int\u003c/code\u003e type,\nand passes it to the C function \u003ccode\u003esrandom\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Seed(i int) {\n    C.srandom(C.uint(i))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that cgo knows the \u003ccode\u003eunsigned int\u003c/code\u003e type as \u003ccode\u003eC.uint\u003c/code\u003e;\nsee the \u003ca href=\"/cmd/cgo\"\u003ecgo documentation\u003c/a\u003e for a complete\nlist of these numeric type names.\u003c/p\u003e\n\u003cp\u003eThe one detail of this example we haven’t examined yet is the comment above the \u003ccode\u003eimport\u003c/code\u003e statement.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/*\n#include \u0026lt;stdlib.h\u0026gt;\n*/\nimport \u0026#34;C\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCgo recognizes this comment.  Any lines starting with \u003ccode\u003e#cgo\u003c/code\u003e followed by\na space character are removed;\nthese become directives for cgo.\nThe remaining lines are used as a header when compiling the C parts of the package.\nIn this case those lines are just a single \u003ccode\u003e#include\u003c/code\u003e statement,\nbut they can be almost any C code.\nThe \u003ccode\u003e#cgo\u003c/code\u003e directives are used to provide flags for the compiler and linker\nwhen building the C parts of the package.\u003c/p\u003e\n\u003cp\u003eThere is a limitation: if your program uses any \u003ccode\u003e//export\u003c/code\u003e directives,\nthen the C code in the comment may only include declarations (\u003ccode\u003eextern int f();\u003c/code\u003e),\nnot definitions (\u003ccode\u003eint f() { return 1; }\u003c/code\u003e).\nYou can use \u003ccode\u003e//export\u003c/code\u003e directives to make Go functions accessible to C code.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e#cgo\u003c/code\u003e and \u003ccode\u003e//export\u003c/code\u003e directives are documented in the \u003ca href=\"/cmd/cgo/\"\u003ecgo documentation\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"strings-and-things\"\u003eStrings and things\u003c/h2\u003e\n\u003cp\u003eUnlike Go, C doesn’t have an explicit string type. Strings in C are represented by a zero-terminated array of chars.\u003c/p\u003e\n\u003cp\u003eConversion between Go and C strings is done with the \u003ccode\u003eC.CString\u003c/code\u003e,\n\u003ccode\u003eC.GoString\u003c/code\u003e, and \u003ccode\u003eC.GoStringN\u003c/code\u003e functions.\nThese conversions make a copy of the string data.\u003c/p\u003e\n\u003cp\u003eThis next example implements a \u003ccode\u003ePrint\u003c/code\u003e function that writes a string to\nstandard output using C’s \u003ccode\u003efputs\u003c/code\u003e function from the \u003ccode\u003estdio\u003c/code\u003e library:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage print\n\n// #include \u0026lt;stdio.h\u0026gt;\n// #include \u0026lt;stdlib.h\u0026gt;\nimport \u0026#34;C\u0026#34;\nimport \u0026#34;unsafe\u0026#34;\n\nfunc Print(s string) {\n    cs := C.CString(s)\n    C.fputs(cs, (*C.FILE)(C.stdout))\n    C.free(unsafe.Pointer(cs))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMemory allocations made by C code are not known to Go’s memory manager.\nWhen you create a C string with \u003ccode\u003eC.CString\u003c/code\u003e (or any C memory allocation)\nyou must remember to free the memory when you’re done with it by calling \u003ccode\u003eC.free\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe call to \u003ccode\u003eC.CString\u003c/code\u003e returns a pointer to the start of the char array,\nso before the function exits we convert it to an \u003ca href=\"/pkg/unsafe/#Pointer\"\u003e\u003ccode\u003eunsafe.Pointer\u003c/code\u003e\u003c/a\u003e\nand release the memory allocation with \u003ccode\u003eC.free\u003c/code\u003e.\nA common idiom in cgo programs is to \u003ca href=\"/doc/articles/defer_panic_recover.html\"\u003e\u003ccode\u003edefer\u003c/code\u003e\u003c/a\u003e\nthe free immediately after allocating (especially when the code that follows\nis more complex than a single function call),\nas in this rewrite of \u003ccode\u003ePrint\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Print(s string) {\n    cs := C.CString(s)\n    defer C.free(unsafe.Pointer(cs))\n    C.fputs(cs, (*C.FILE)(C.stdout))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"building-cgo-packages\"\u003eBuilding cgo packages\u003c/h2\u003e\n\u003cp\u003eTo build cgo packages, just use \u003ca href=\"/cmd/go/#hdr-Compile_packages_and_dependencies\"\u003e\u003ccode\u003ego build\u003c/code\u003e\u003c/a\u003e\nor \u003ca href=\"/cmd/go/#hdr-Compile_and_install_packages_and_dependencies\"\u003e\u003ccode\u003ego install\u003c/code\u003e\u003c/a\u003e as usual.\nThe go tool recognizes the special \u003ccode\u003e\u0026#34;C\u0026#34;\u003c/code\u003e import and automatically uses cgo for those files.\u003c/p\u003e\n\u003ch2 id=\"more-cgo-resources\"\u003eMore cgo resources\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"/cmd/cgo/\"\u003ecgo command\u003c/a\u003e documentation has more\ndetail about the C pseudo-package and the build process.\nThe \u003ca href=\"/misc/cgo/\"\u003ecgo examples\u003c/a\u003e in the Go tree demonstrate\nmore advanced concepts.\u003c/p\u003e\n\u003cp\u003eFinally, if you’re curious as to how all this works internally,\ntake a look at the introductory comment of the runtime package’s \u003ca href=\"/src/runtime/cgocall.go\"\u003ecgocall.go\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-03-17T00:00:00Z",
  "Author": "Andrew Gerrand"
}