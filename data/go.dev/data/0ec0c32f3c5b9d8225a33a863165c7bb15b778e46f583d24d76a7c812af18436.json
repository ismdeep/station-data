{
  "Source": "go.dev",
  "Title": "Introducing the Go Race Detector",
  "Link": "https://go.dev/blog/race-detector",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/race-detector\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eIntroducing the Go Race Detector\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Dmitry Vyukov and Andrew Gerrand\u003cbr/\u003e\n      26 June 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"http://en.wikipedia.org/wiki/Race_condition\" rel=\"noreferrer\" target=\"_blank\"\u003eRace conditions\u003c/a\u003e are among the\nmost insidious and elusive programming errors. They typically cause erratic and\nmysterious failures, often long after the code has been deployed to production.\nWhile Go’s concurrency mechanisms make it easy to write clean concurrent code,\nthey don’t prevent race conditions. Care, diligence, and testing are required.\nAnd tools can help.\u003c/p\u003e\n\u003cp\u003eWe’re happy to announce that Go 1.1 includes a\n\u003ca href=\"/doc/articles/race_detector.html\"\u003erace detector\u003c/a\u003e,\na new tool for finding race conditions in Go code.\nIt is currently available for Linux, OS X, and Windows systems\nwith 64-bit x86 processors.\u003c/p\u003e\n\u003cp\u003eThe race detector is based on the C/C++\n\u003ca href=\"https://github.com/google/sanitizers\" rel=\"noreferrer\" target=\"_blank\"\u003eThreadSanitizer runtime library\u003c/a\u003e,\nwhich has been used to detect many errors in Google’s internal code base and in\n\u003ca href=\"http://www.chromium.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eChromium\u003c/a\u003e.\nThe technology was integrated with Go in September 2012; since then it has detected\n\u003ca href=\"https://github.com/golang/go/issues?utf8=%E2%9C%93\u0026amp;q=ThreadSanitizer\" rel=\"noreferrer\" target=\"_blank\"\u003e42 races\u003c/a\u003e\nin the standard library. It is now part of our continuous build process,\nwhere it continues to catch race conditions as they arise.\u003c/p\u003e\n\u003ch2 id=\"how-it-works\"\u003eHow it works\u003c/h2\u003e\n\u003cp\u003eThe race detector is integrated with the go tool chain. When the\n\u003ccode\u003e-race\u003c/code\u003e command-line flag is set, the compiler instruments all memory accesses\nwith code that records when and how the memory was accessed, while the runtime\nlibrary watches for unsynchronized accesses to shared variables.\nWhen such “racy” behavior is detected, a warning is printed.\n(See \u003ca href=\"https://github.com/google/sanitizers/wiki/ThreadSanitizerAlgorithm\" rel=\"noreferrer\" target=\"_blank\"\u003ethis article\u003c/a\u003e\nfor the details of the algorithm.)\u003c/p\u003e\n\u003cp\u003eBecause of its design, the race detector can detect race conditions only when\nthey are actually triggered by running code, which means it’s important to run\nrace-enabled binaries under realistic workloads.\nHowever, race-enabled binaries can use ten times the CPU and memory, so it is\nimpractical to enable the race detector all the time.\nOne way out of this dilemma is to run some tests with the race detector\nenabled. Load tests and integration tests are good candidates, since they tend\nto exercise concurrent parts of the code.\nAnother approach using production workloads is to deploy a single race-enabled\ninstance within a pool of running servers.\u003c/p\u003e\n\u003ch2 id=\"using-the-race-detector\"\u003eUsing the race detector\u003c/h2\u003e\n\u003cp\u003eThe race detector is fully integrated with the Go tool chain.\nTo build your code with the race detector enabled, just add the\n\u003ccode\u003e-race\u003c/code\u003e flag to the command line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test -race mypkg    // test the package\n$ go run -race mysrc.go  // compile and run the program\n$ go build -race mycmd   // build the command\n$ go install -race mypkg // install the package\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo try out the race detector for yourself, copy this example program into \u003ccode\u003eracy.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    done := make(chan bool)\n    m := make(map[string]string)\n    m[\u0026#34;name\u0026#34;] = \u0026#34;world\u0026#34;\n    go func() {\n        m[\u0026#34;name\u0026#34;] = \u0026#34;data race\u0026#34;\n        done \u0026lt;- true\n    }()\n    fmt.Println(\u0026#34;Hello,\u0026#34;, m[\u0026#34;name\u0026#34;])\n    \u0026lt;-done\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen run it with the race detector enabled:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go run -race racy.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"examples\"\u003eExamples\u003c/h2\u003e\n\u003cp\u003eHere are two examples of real issues caught by the race detector.\u003c/p\u003e\n\u003ch3 id=\"example-1-timerreset\"\u003eExample 1: Timer.Reset\u003c/h3\u003e\n\u003cp\u003eThe first example is a simplified version of an actual bug found by the race\ndetector. It uses a timer to print a message after a random duration between 0\nand 1 second. It does so repeatedly for five seconds.\nIt uses \u003ca href=\"/pkg/time/#AfterFunc\"\u003e\u003ccode\u003etime.AfterFunc\u003c/code\u003e\u003c/a\u003e to create a\n\u003ca href=\"/pkg/time/#Timer\"\u003e\u003ccode\u003eTimer\u003c/code\u003e\u003c/a\u003e for the first message and then\nuses the \u003ca href=\"/pkg/time/#Timer.Reset\"\u003e\u003ccode\u003eReset\u003c/code\u003e\u003c/a\u003e method to\nschedule the next message, re-using the \u003ccode\u003eTimer\u003c/code\u003e each time.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;math/rand\u0026#34;\n    \u0026#34;time\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e\u003cspan class=\"number\"\u003e10  \u003c/span\u003efunc main() {\n\u003cspan class=\"number\"\u003e11  \u003c/span\u003e    start := time.Now()\n\u003cspan class=\"number\"\u003e12  \u003c/span\u003e    var t *time.Timer\n\u003cspan class=\"number\"\u003e13  \u003c/span\u003e    t = time.AfterFunc(randomDuration(), func() {\n\u003cspan class=\"number\"\u003e14  \u003c/span\u003e        fmt.Println(time.Now().Sub(start))\n\u003cspan class=\"number\"\u003e15  \u003c/span\u003e        t.Reset(randomDuration())\n\u003cspan class=\"number\"\u003e16  \u003c/span\u003e    })\n\u003cspan class=\"number\"\u003e17  \u003c/span\u003e    time.Sleep(5 * time.Second)\n\u003cspan class=\"number\"\u003e18  \u003c/span\u003e}\n\u003cspan class=\"number\"\u003e19  \u003c/span\u003e\n\u003cspan class=\"number\"\u003e20  \u003c/span\u003efunc randomDuration() time.Duration {\n\u003cspan class=\"number\"\u003e21  \u003c/span\u003e    return time.Duration(rand.Int63n(1e9))\n\u003cspan class=\"number\"\u003e22  \u003c/span\u003e}\n\u003cspan class=\"number\"\u003e23  \u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThis looks like reasonable code, but under certain circumstances it fails in a surprising way:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epanic: runtime error: invalid memory address or nil pointer dereference\n[signal 0xb code=0x1 addr=0x8 pc=0x41e38a]\n\ngoroutine 4 [running]:\ntime.stopTimer(0x8, 0x12fe6b35d9472d96)\n    src/pkg/runtime/ztime_linux_amd64.c:35 +0x25\ntime.(*Timer).Reset(0x0, 0x4e5904f, 0x1)\n    src/pkg/time/sleep.go:81 +0x42\nmain.func·001()\n    race.go:14 +0xe3\ncreated by time.goFunc\n    src/pkg/time/sleep.go:122 +0x48\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat’s going on here? Running the program with the race detector enabled is more illuminating:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e==================\nWARNING: DATA RACE\nRead by goroutine 5:\n  main.func·001()\n     race.go:16 +0x169\n\nPrevious write by goroutine 1:\n  main.main()\n      race.go:14 +0x174\n\nGoroutine 5 (running) created at:\n  time.goFunc()\n      src/pkg/time/sleep.go:122 +0x56\n  timerproc()\n     src/pkg/runtime/ztime_linux_amd64.c:181 +0x189\n==================\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe race detector shows the problem: an unsynchronized read and write of the\nvariable \u003ccode\u003et\u003c/code\u003e from different goroutines. If the initial timer duration is very\nsmall, the timer function may fire before the main goroutine has assigned a\nvalue to \u003ccode\u003et\u003c/code\u003e and so the call to \u003ccode\u003et.Reset\u003c/code\u003e is made with a nil \u003ccode\u003et\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo fix the race condition we change the code to read and write the variable\n\u003ccode\u003et\u003c/code\u003e only from the main goroutine:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;math/rand\u0026#34;\n    \u0026#34;time\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e\u003cspan class=\"number\"\u003e10  \u003c/span\u003efunc main() {\n\u003cspan class=\"number\"\u003e11  \u003c/span\u003e    start := time.Now()\n\u003cspan class=\"number\"\u003e12  \u003c/span\u003e    reset := make(chan bool)\n\u003cspan class=\"number\"\u003e13  \u003c/span\u003e    var t *time.Timer\n\u003cspan class=\"number\"\u003e14  \u003c/span\u003e    t = time.AfterFunc(randomDuration(), func() {\n\u003cspan class=\"number\"\u003e15  \u003c/span\u003e        fmt.Println(time.Now().Sub(start))\n\u003cspan class=\"number\"\u003e16  \u003c/span\u003e        reset \u0026lt;- true\n\u003cspan class=\"number\"\u003e17  \u003c/span\u003e    })\n\u003cspan class=\"number\"\u003e18  \u003c/span\u003e    for time.Since(start) \u0026lt; 5*time.Second {\n\u003cspan class=\"number\"\u003e19  \u003c/span\u003e        \u0026lt;-reset\n\u003cspan class=\"number\"\u003e20  \u003c/span\u003e        t.Reset(randomDuration())\n\u003cspan class=\"number\"\u003e21  \u003c/span\u003e    }\n\u003cspan class=\"number\"\u003e22  \u003c/span\u003e}\n\u003cspan class=\"number\"\u003e23  \u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\nfunc randomDuration() time.Duration {\n    return time.Duration(rand.Int63n(1e9))\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHere the main goroutine is wholly responsible for setting and resetting the\n\u003ccode\u003eTimer\u003c/code\u003e \u003ccode\u003et\u003c/code\u003e and a new reset channel communicates the need to reset the timer in\na thread-safe way.\u003c/p\u003e\n\u003cp\u003eA simpler but less efficient approach is to\n\u003ca href=\"/play/p/kuWTrY0pS4\"\u003eavoid reusing timers\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"example-2-ioutildiscard\"\u003eExample 2: ioutil.Discard\u003c/h3\u003e\n\u003cp\u003eThe second example is more subtle.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eioutil\u003c/code\u003e package’s\n\u003ca href=\"/pkg/io/ioutil/#Discard\"\u003e\u003ccode\u003eDiscard\u003c/code\u003e\u003c/a\u003e object implements\n\u003ca href=\"/pkg/io/#Writer\"\u003e\u003ccode\u003eio.Writer\u003c/code\u003e\u003c/a\u003e,\nbut discards all the data written to it.\nThink of it like \u003ccode\u003e/dev/null\u003c/code\u003e: a place to send data that you need to read but\ndon’t want to store.\nIt is commonly used with \u003ca href=\"/pkg/io/#Copy\"\u003e\u003ccode\u003eio.Copy\u003c/code\u003e\u003c/a\u003e\nto drain a reader, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eio.Copy(ioutil.Discard, reader)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBack in July 2011 the Go team noticed that using \u003ccode\u003eDiscard\u003c/code\u003e in this way was\ninefficient: the \u003ccode\u003eCopy\u003c/code\u003e function allocates an internal 32 kB buffer each time it\nis called, but when used with \u003ccode\u003eDiscard\u003c/code\u003e the buffer is unnecessary since we’re\njust throwing the read data away.\nWe thought that this idiomatic use of \u003ccode\u003eCopy\u003c/code\u003e and \u003ccode\u003eDiscard\u003c/code\u003e should not be so costly.\u003c/p\u003e\n\u003cp\u003eThe fix was simple.\nIf the given \u003ccode\u003eWriter\u003c/code\u003e implements a \u003ccode\u003eReadFrom\u003c/code\u003e method, a \u003ccode\u003eCopy\u003c/code\u003e call like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eio.Copy(writer, reader)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eis delegated to this potentially more efficient call:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ewriter.ReadFrom(reader)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe\n\u003ca href=\"/cl/4817041\"\u003eadded a ReadFrom method\u003c/a\u003e\nto Discard’s underlying type, which has an internal buffer that is shared\nbetween all its users.\nWe knew this was theoretically a race condition, but since all writes to the\nbuffer should be thrown away we didn’t think it was important.\u003c/p\u003e\n\u003cp\u003eWhen the race detector was implemented it immediately\n\u003ca href=\"/issue/3970\"\u003eflagged this code\u003c/a\u003e as racy.\nAgain, we considered that the code might be problematic, but decided that the\nrace condition wasn’t “real”.\nTo avoid the “false positive” in our build we implemented\n\u003ca href=\"/cl/6624059\"\u003ea non-racy version\u003c/a\u003e\nthat is enabled only when the race detector is running.\u003c/p\u003e\n\u003cp\u003eBut a few months later \u003ca href=\"https://bradfitz.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eBrad\u003c/a\u003e encountered a\n\u003ca href=\"/issue/4589\"\u003efrustrating and strange bug\u003c/a\u003e.\nAfter a few days of debugging, he narrowed it down to a real race condition\ncaused by \u003ccode\u003eioutil.Discard\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere is the known-racy code in \u003ccode\u003eio/ioutil\u003c/code\u003e, where \u003ccode\u003eDiscard\u003c/code\u003e is a\n\u003ccode\u003edevNull\u003c/code\u003e that shares a single buffer between all of its users.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003evar blackHole [4096]byte \u003cspan class=\"comment\"\u003e// shared buffer\u003c/span\u003e\n\nfunc (devNull) ReadFrom(r io.Reader) (n int64, err error) {\n    readSize := 0\n    for {\n        readSize, err = r.Read(blackHole[:])\n        n += int64(readSize)\n        if err != nil {\n            if err == io.EOF {\n                return n, nil\n            }\n            return\n        }\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eBrad’s program includes a \u003ccode\u003etrackDigestReader\u003c/code\u003e type, which wraps an \u003ccode\u003eio.Reader\u003c/code\u003e\nand records the hash digest of what it reads.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype trackDigestReader struct {\n    r io.Reader\n    h hash.Hash\n}\n\nfunc (t trackDigestReader) Read(p []byte) (n int, err error) {\n    n, err = t.r.Read(p)\n    t.h.Write(p[:n])\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor example, it could be used to compute the SHA-1 hash of a file while reading it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etdr := trackDigestReader{r: file, h: sha1.New()}\nio.Copy(writer, tdr)\nfmt.Printf(\u0026#34;File hash: %x\u0026#34;, tdr.h.Sum(nil))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn some cases there would be nowhere to write the data—but still a need to hash\nthe file—and so \u003ccode\u003eDiscard\u003c/code\u003e would be used:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eio.Copy(ioutil.Discard, tdr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut in this case the \u003ccode\u003eblackHole\u003c/code\u003e buffer isn’t just a black hole; it is a\nlegitimate place to store the data between reading it from the source\n\u003ccode\u003eio.Reader\u003c/code\u003e and writing it to the \u003ccode\u003ehash.Hash\u003c/code\u003e.\nWith multiple goroutines hashing files simultaneously, each sharing the same\n\u003ccode\u003eblackHole\u003c/code\u003e buffer, the race condition manifested itself by corrupting the data\nbetween reading and hashing.\nNo errors or panics occurred, but the hashes were wrong. Nasty!\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (t trackDigestReader) Read(p []byte) (n int, err error) {\n    // the buffer p is blackHole\n    n, err = t.r.Read(p)\n    // p may be corrupted by another goroutine here,\n    // between the Read above and the Write below\n    t.h.Write(p[:n])\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe bug was finally\n\u003ca href=\"/cl/7011047\"\u003efixed\u003c/a\u003e\nby giving a unique buffer to each use of \u003ccode\u003eioutil.Discard\u003c/code\u003e, eliminating the race\ncondition on the shared buffer.\u003c/p\u003e\n\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\n\u003cp\u003eThe race detector is a powerful tool for checking the correctness of concurrent\nprograms. It will not issue false positives, so take its warnings seriously.\nBut it is only as good as your tests; you must make sure they thoroughly\nexercise the concurrent properties of your code so that the race detector can\ndo its job.\u003c/p\u003e\n\u003cp\u003eWhat are you waiting for? Run \u003ccode\u003e\u0026#34;go test -race\u0026#34;\u003c/code\u003e on your code today!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-06-26T00:00:00Z",
  "Author": "Dmitry Vyukov and Andrew Gerrand"
}