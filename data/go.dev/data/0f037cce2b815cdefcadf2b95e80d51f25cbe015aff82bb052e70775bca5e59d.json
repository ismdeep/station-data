{
  "Source": "go.dev",
  "Title": "Gobs of data",
  "Link": "https://go.dev/blog/gob",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/gob\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGobs of data\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      24 March 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eTo transmit a data structure across a network or to store it in a file,\nit must be encoded and then decoded again.\nThere are many encodings available, of course:\n\u003ca href=\"http://www.json.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eJSON\u003c/a\u003e, \u003ca href=\"http://www.w3.org/XML/\" rel=\"noreferrer\" target=\"_blank\"\u003eXML\u003c/a\u003e,\nGoogle’s \u003ca href=\"http://code.google.com/p/protobuf\" rel=\"noreferrer\" target=\"_blank\"\u003eprotocol buffers\u003c/a\u003e, and more.\nAnd now there’s another, provided by Go’s \u003ca href=\"/pkg/encoding/gob/\"\u003egob\u003c/a\u003e package.\u003c/p\u003e\n\u003cp\u003eWhy define a new encoding? It’s a lot of work and redundant at that.\nWhy not just use one of the existing formats? Well,\nfor one thing, we do!\nGo has \u003ca href=\"/pkg/\"\u003epackages\u003c/a\u003e supporting all the encodings\njust mentioned (the \u003ca href=\"http://github.com/golang/protobuf\" rel=\"noreferrer\" target=\"_blank\"\u003eprotocol buffer package\u003c/a\u003e\nis in a separate repository but it’s one of the most frequently downloaded).\nAnd for many purposes, including communicating with tools and systems written in other languages,\nthey’re the right choice.\u003c/p\u003e\n\u003cp\u003eBut for a Go-specific environment, such as communicating between two servers written in Go,\nthere’s an opportunity to build something much easier to use and possibly more efficient.\u003c/p\u003e\n\u003cp\u003eGobs work with the language in a way that an externally-defined,\nlanguage-independent encoding cannot.\nAt the same time, there are lessons to be learned from the existing systems.\u003c/p\u003e\n\u003ch2 id=\"goals\"\u003eGoals\u003c/h2\u003e\n\u003cp\u003eThe gob package was designed with a number of goals in mind.\u003c/p\u003e\n\u003cp\u003eFirst, and most obvious, it had to be very easy to use.\nFirst, because Go has reflection, there is no need for a separate interface\ndefinition language or “protocol compiler”.\nThe data structure itself is all the package should need to figure out how\nto encode and decode it.\nOn the other hand, this approach means that gobs will never work as well\nwith other languages, but that’s OK:\ngobs are unashamedly Go-centric.\u003c/p\u003e\n\u003cp\u003eEfficiency is also important. Textual representations,\nexemplified by XML and JSON, are too slow to put at the center of an efficient\ncommunications network.\nA binary encoding is necessary.\u003c/p\u003e\n\u003cp\u003eGob streams must be self-describing. Each gob stream,\nread from the beginning, contains sufficient information that the entire\nstream can be parsed by an agent that knows nothing a priori about its contents.\nThis property means that you will always be able to decode a gob stream stored in a file,\neven long after you’ve forgotten what data it represents.\u003c/p\u003e\n\u003cp\u003eThere were also some things to learn from our experiences with Google protocol buffers.\u003c/p\u003e\n\u003ch2 id=\"protocol-buffer-misfeatures\"\u003eProtocol buffer misfeatures\u003c/h2\u003e\n\u003cp\u003eProtocol buffers had a major effect on the design of gobs,\nbut have three features that were deliberately avoided.\n(Leaving aside the property that protocol buffers aren’t self-describing:\nif you don’t know the data definition used to encode a protocol buffer,\nyou might not be able to parse it.)\u003c/p\u003e\n\u003cp\u003eFirst, protocol buffers only work on the data type we call a struct in Go.\nYou can’t encode an integer or array at the top level,\nonly a struct with fields inside it.\nThat seems a pointless restriction, at least in Go.\nIf all you want to send is an array of integers,\nwhy should you have to put it into a struct first?\u003c/p\u003e\n\u003cp\u003eNext, a protocol buffer definition may specify that fields \u003ccode\u003eT.x\u003c/code\u003e and \u003ccode\u003eT.y\u003c/code\u003e\nare required to be present whenever a value of type \u003ccode\u003eT\u003c/code\u003e is encoded or decoded.\nAlthough such required fields may seem like a good idea,\nthey are costly to implement because the codec must maintain a separate\ndata structure while encoding and decoding,\nto be able to report when required fields are missing.\nThey’re also a maintenance problem. Over time,\none may want to modify the data definition to remove a required field,\nbut that may cause existing clients of the data to crash.\nIt’s better not to have them in the encoding at all.\n(Protocol buffers also have optional fields.\nBut if we don’t have required fields, all fields are optional and that’s that.\nThere will be more to say about optional fields a little later.)\u003c/p\u003e\n\u003cp\u003eThe third protocol buffer misfeature is default values.\nIf a protocol buffer omits the value for a “defaulted” field,\nthen the decoded structure behaves as if the field were set to that value.\nThis idea works nicely when you have getter and setter methods to control\naccess to the field,\nbut is harder to handle cleanly when the container is just a plain idiomatic struct.\nRequired fields are also tricky to implement:\nwhere does one define the default values,\nwhat types do they have (is text UTF-8? uninterpreted bytes? how many bits\nin a float?) and despite the apparent simplicity,\nthere were a number of complications in their design and implementation\nfor protocol buffers.\nWe decided to leave them out of gobs and fall back to Go’s trivial but effective defaulting rule:\nunless you set something otherwise, it has the “zero value” for that type -\nand it doesn’t need to be transmitted.\u003c/p\u003e\n\u003cp\u003eSo gobs end up looking like a sort of generalized, simplified protocol buffer. How do they work?\u003c/p\u003e\n\u003ch2 id=\"values\"\u003eValues\u003c/h2\u003e\n\u003cp\u003eThe encoded gob data isn’t about types like \u003ccode\u003eint8\u003c/code\u003e and \u003ccode\u003euint16\u003c/code\u003e.\nInstead, somewhat analogous to constants in Go,\nits integer values are abstract, sizeless numbers,\neither signed or unsigned.\nWhen you encode an \u003ccode\u003eint8\u003c/code\u003e, its value is transmitted as an unsized,\nvariable-length integer.\nWhen you encode an \u003ccode\u003eint64\u003c/code\u003e, its value is also transmitted as an unsized,\nvariable-length integer.\n(Signed and unsigned are treated distinctly,\nbut the same unsized-ness applies to unsigned values too.) If both have the value 7,\nthe bits sent on the wire will be identical.\nWhen the receiver decodes that value, it puts it into the receiver’s variable,\nwhich may be of arbitrary integer type.\nThus an encoder may send a 7 that came from an \u003ccode\u003eint8\u003c/code\u003e,\nbut the receiver may store it in an \u003ccode\u003eint64\u003c/code\u003e.\nThis is fine: the value is an integer and as a long as it fits, everything works.\n(If it doesn’t fit, an error results.) This decoupling from the size of\nthe variable gives some flexibility to the encoding:\nwe can expand the type of the integer variable as the software evolves,\nbut still be able to decode old data.\u003c/p\u003e\n\u003cp\u003eThis flexibility also applies to pointers.\nBefore transmission, all pointers are flattened.\nValues of type \u003ccode\u003eint8\u003c/code\u003e, \u003ccode\u003e*int8\u003c/code\u003e, \u003ccode\u003e**int8\u003c/code\u003e,\n\u003ccode\u003e****int8\u003c/code\u003e, etc. are all transmitted as an integer value,\nwhich may then be stored in \u003ccode\u003eint\u003c/code\u003e of any size,\nor \u003ccode\u003e*int\u003c/code\u003e, or \u003ccode\u003e******int\u003c/code\u003e, etc.\nAgain, this allows for flexibility.\u003c/p\u003e\n\u003cp\u003eFlexibility also happens because, when decoding a struct,\nonly those fields that are sent by the encoder are stored in the destination. Given the value\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype T struct{ X, Y, Z int } // Only exported fields are encoded and decoded.\nvar t = T{X: 7, Y: 0, Z: 8}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe encoding of \u003ccode\u003et\u003c/code\u003e sends only the 7 and 8.\nBecause it’s zero, the value of \u003ccode\u003eY\u003c/code\u003e isn’t even sent;\nthere’s no need to send a zero value.\u003c/p\u003e\n\u003cp\u003eThe receiver could instead decode the value into this structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype U struct{ X, Y *int8 } // Note: pointers to int8s\nvar u U\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand acquire a value of \u003ccode\u003eu\u003c/code\u003e with only \u003ccode\u003eX\u003c/code\u003e set (to the address of an \u003ccode\u003eint8\u003c/code\u003e variable set to 7);\nthe \u003ccode\u003eZ\u003c/code\u003e field is ignored - where would you put it? When decoding structs,\nfields are matched by name and compatible type,\nand only fields that exist in both are affected.\nThis simple approach finesses the “optional field” problem:\nas the type \u003ccode\u003eT\u003c/code\u003e evolves by adding fields,\nout of date receivers will still function with the part of the type they recognize.\nThus gobs provide the important result of optional fields - extensibility -\nwithout any additional mechanism or notation.\u003c/p\u003e\n\u003cp\u003eFrom integers we can build all the other types:\nbytes, strings, arrays, slices, maps, even floats.\nFloating-point values are represented by their IEEE 754 floating-point bit pattern,\nstored as an integer, which works fine as long as you know their type, which we always do.\nBy the way, that integer is sent in byte-reversed order because common values\nof floating-point numbers,\nsuch as small integers, have a lot of zeros at the low end that we can avoid transmitting.\u003c/p\u003e\n\u003cp\u003eOne nice feature of gobs that Go makes possible is that they allow you to\ndefine your own encoding by having your type satisfy the \u003ca href=\"/pkg/encoding/gob/#GobEncoder\"\u003eGobEncoder\u003c/a\u003e\nand \u003ca href=\"/pkg/encoding/gob/#GobDecoder\"\u003eGobDecoder\u003c/a\u003e interfaces,\nin a manner analogous to the \u003ca href=\"/pkg/encoding/json/\"\u003eJSON\u003c/a\u003e\npackage’s \u003ca href=\"/pkg/encoding/json/#Marshaler\"\u003eMarshaler\u003c/a\u003e\nand \u003ca href=\"/pkg/encoding/json/#Unmarshaler\"\u003eUnmarshaler\u003c/a\u003e and\nalso to the \u003ca href=\"/pkg/fmt/#Stringer\"\u003eStringer\u003c/a\u003e interface\nfrom \u003ca href=\"/pkg/fmt/\"\u003epackage fmt\u003c/a\u003e.\nThis facility makes it possible to represent special features,\nenforce constraints, or hide secrets when you transmit data.\nSee the \u003ca href=\"/pkg/encoding/gob/\"\u003edocumentation\u003c/a\u003e for details.\u003c/p\u003e\n\u003ch2 id=\"types-on-the-wire\"\u003eTypes on the wire\u003c/h2\u003e\n\u003cp\u003eThe first time you send a given type, the gob package includes in the data\nstream a description of that type.\nIn fact, what happens is that the encoder is used to encode,\nin the standard gob encoding format, an internal struct that describes the\ntype and gives it a unique number.\n(Basic types, plus the layout of the type description structure,\nare predefined by the software for bootstrapping.) After the type is described,\nit can be referenced by its type number.\u003c/p\u003e\n\u003cp\u003eThus when we send our first type \u003ccode\u003eT\u003c/code\u003e, the gob encoder sends a description\nof \u003ccode\u003eT\u003c/code\u003e and tags it with a type number, say 127.\nAll values, including the first, are then prefixed by that number,\nso a stream of \u003ccode\u003eT\u003c/code\u003e values looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(\u0026#34;define type id\u0026#34; 127, definition of type T)(127, T value)(127, T value), ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese type numbers make it possible to describe recursive types and send\nvalues of those types.\nThus gobs can encode types such as trees:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Node struct {\n    Value       int\n    Left, Right *Node\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(It’s an exercise for the reader to discover how the zero-defaulting rule makes this work,\neven though gobs don’t represent pointers.)\u003c/p\u003e\n\u003cp\u003eWith the type information, a gob stream is fully self-describing except\nfor the set of bootstrap types,\nwhich is a well-defined starting point.\u003c/p\u003e\n\u003ch2 id=\"compiling-a-machine\"\u003eCompiling a machine\u003c/h2\u003e\n\u003cp\u003eThe first time you encode a value of a given type,\nthe gob package builds a little interpreted machine specific to that data type.\nIt uses reflection on the type to construct that machine,\nbut once the machine is built it does not depend on reflection.\nThe machine uses package unsafe and some trickery to convert the data into\nthe encoded bytes at high speed.\nIt could use reflection and avoid unsafe,\nbut would be significantly slower.\n(A similar high-speed approach is taken by the protocol buffer support for Go,\nwhose design was influenced by the implementation of gobs.) Subsequent values\nof the same type use the already-compiled machine,\nso they can be encoded right away.\u003c/p\u003e\n\u003cp\u003e[Update: As of Go 1.4, package unsafe is no longer use by the gob package, with a modest performance drop.]\u003c/p\u003e\n\u003cp\u003eDecoding is similar but harder. When you decode a value,\nthe gob package holds a byte slice representing a value of a given encoder-defined type to decode,\nplus a Go value into which to decode it.\nThe gob package builds a machine for that pair:\nthe gob type sent on the wire crossed with the Go type provided for decoding.\nOnce that decoding machine is built, though,\nit’s again a reflectionless engine that uses unsafe methods to get maximum speed.\u003c/p\u003e\n\u003ch2 id=\"use\"\u003eUse\u003c/h2\u003e\n\u003cp\u003eThere’s a lot going on under the hood, but the result is an efficient,\neasy-to-use encoding system for transmitting data.\nHere’s a complete example showing differing encoded and decoded types.\nNote how easy it is to send and receive values;\nall you need to do is present values and variables to the \u003ca href=\"/pkg/encoding/gob/\"\u003egob package\u003c/a\u003e\nand it does all the work.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;bytes\u0026#34;\n    \u0026#34;encoding/gob\u0026#34;\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;log\u0026#34;\n)\n\ntype P struct {\n    X, Y, Z int\n    Name    string\n}\n\ntype Q struct {\n    X, Y *int32\n    Name string\n}\n\nfunc main() {\n    // Initialize the encoder and decoder.  Normally enc and dec would be\n    // bound to network connections and the encoder and decoder would\n    // run in different processes.\n    var network bytes.Buffer        // Stand-in for a network connection\n    enc := gob.NewEncoder(\u0026amp;network) // Will write to network.\n    dec := gob.NewDecoder(\u0026amp;network) // Will read from network.\n    // Encode (send) the value.\n    err := enc.Encode(P{3, 4, 5, \u0026#34;Pythagoras\u0026#34;})\n    if err != nil {\n        log.Fatal(\u0026#34;encode error:\u0026#34;, err)\n    }\n    // Decode (receive) the value.\n    var q Q\n    err = dec.Decode(\u0026amp;q)\n    if err != nil {\n        log.Fatal(\u0026#34;decode error:\u0026#34;, err)\n    }\n    fmt.Printf(\u0026#34;%q: {%d,%d}\\n\u0026#34;, q.Name, *q.X, *q.Y)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can compile and run this example code in the \u003ca href=\"/play/p/_-OJV-rwMq\"\u003eGo Playground\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/net/rpc/\"\u003erpc package\u003c/a\u003e builds on gobs to turn\nthis encode/decode automation into transport for method calls across the network.\nThat’s a subject for another article.\u003c/p\u003e\n\u003ch2 id=\"details\"\u003eDetails\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/encoding/gob/\"\u003egob package documentation\u003c/a\u003e,\nespecially the file \u003ca href=\"/src/pkg/encoding/gob/doc.go\"\u003edoc.go\u003c/a\u003e,\nexpands on many of the details described here and includes a full worked\nexample showing how the encoding represents data.\nIf you are interested in the innards of the gob implementation,\nthat’s a good place to start.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-03-24T00:00:00Z",
  "Author": "Rob Pike"
}