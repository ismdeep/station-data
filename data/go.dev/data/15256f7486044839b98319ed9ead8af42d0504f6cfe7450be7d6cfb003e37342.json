{
  "Source": "go.dev",
  "Title": "Using Go Modules",
  "Link": "https://go.dev/blog/using-go-modules",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/using-go-modules\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eUsing Go Modules\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Tyler Bui-Palsulich and Eno Compton\u003cbr/\u003e\n      19 March 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis post is part 1 in a series.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePart 1 — Using Go Modules\u003c/strong\u003e (this post)\u003c/li\u003e\n\u003cli\u003ePart 2 — \u003ca href=\"/blog/migrating-to-go-modules\"\u003eMigrating To Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 3 — \u003ca href=\"/blog/publishing-go-modules\"\u003ePublishing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 4 — \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 5 — \u003ca href=\"/blog/module-compatibility\"\u003eKeeping Your Modules Compatible\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For documentation on managing dependencies with modules, see\n\u003ca href=\"/doc/modules/managing-dependencies\"\u003eManaging dependencies\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGo 1.11 and 1.12 include preliminary\n\u003ca href=\"/doc/go1.11#modules\"\u003esupport for modules\u003c/a\u003e,\nGo’s\n\u003ca href=\"/blog/versioning-proposal\"\u003enew dependency management system\u003c/a\u003e\nthat makes dependency version information explicit\nand easier to manage.\nThis blog post is an introduction to the basic operations needed\nto get started using modules.\u003c/p\u003e\n\u003cp\u003eA module is a collection of\n\u003ca href=\"/ref/spec#Packages\"\u003eGo packages\u003c/a\u003e\nstored in a file tree with a \u003ccode\u003ego.mod\u003c/code\u003e file at its root.\nThe \u003ccode\u003ego.mod\u003c/code\u003e file defines the module’s \u003cem\u003emodule path\u003c/em\u003e,\nwhich is also the import path used for the root directory,\nand its \u003cem\u003edependency requirements\u003c/em\u003e,\nwhich are the other modules needed for a successful build.\nEach dependency requirement is\nwritten as a module path and a specific\n\u003ca href=\"http://semver.org/\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic version\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAs of Go 1.11, the go command enables the use of modules\nwhen the current directory or any parent directory has a \u003ccode\u003ego.mod\u003c/code\u003e,\nprovided the directory is \u003cem\u003eoutside\u003c/em\u003e \u003ccode\u003e$GOPATH/src\u003c/code\u003e.\n(Inside \u003ccode\u003e$GOPATH/src\u003c/code\u003e, for compatibility, the go command\nstill runs in the old GOPATH mode, even if a \u003ccode\u003ego.mod\u003c/code\u003e is found.\nSee the\n\u003ca href=\"/cmd/go/#hdr-Preliminary_module_support\"\u003ego command documentation\u003c/a\u003e\nfor details.)\nStarting in Go 1.13, module mode will be the default for all development.\u003c/p\u003e\n\u003cp\u003eThis post walks through a sequence of common operations\nthat arise when developing Go code with modules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCreating a new module.\u003c/li\u003e\n\u003cli\u003eAdding a dependency.\u003c/li\u003e\n\u003cli\u003eUpgrading dependencies.\u003c/li\u003e\n\u003cli\u003eAdding a dependency on a new major version.\u003c/li\u003e\n\u003cli\u003eUpgrading a dependency to a new major version.\u003c/li\u003e\n\u003cli\u003eRemoving unused dependencies.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"creating-a-new-module\"\u003eCreating a new module\u003c/h2\u003e\n\u003cp\u003eLet’s create a new module.\u003c/p\u003e\n\u003cp\u003eCreate a new, empty directory somewhere outside \u003ccode\u003e$GOPATH/src\u003c/code\u003e,\n\u003ccode\u003ecd\u003c/code\u003e into that directory, and then create a new source file, \u003ccode\u003ehello.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nfunc Hello() string {\n    return \u0026#34;Hello, world.\u0026#34;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s write a test, too, in \u003ccode\u003ehello_test.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nimport \u0026#34;testing\u0026#34;\n\nfunc TestHello(t *testing.T) {\n    want := \u0026#34;Hello, world.\u0026#34;\n    if got := Hello(); got != want {\n        t.Errorf(\u0026#34;Hello() = %q, want %q\u0026#34;, got, want)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, the directory contains a package, but not a module,\nbecause there is no \u003ccode\u003ego.mod\u003c/code\u003e file.\nIf we were working in \u003ccode\u003e/home/gopher/hello\u003c/code\u003e and ran \u003ccode\u003ego test\u003c/code\u003e now,\nwe’d see:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test\nPASS\nok      _/home/gopher/hello 0.020s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe last line summarizes the overall package test.\nBecause we are working outside \u003ccode\u003e$GOPATH\u003c/code\u003e\nand also outside any module,\nthe \u003ccode\u003ego\u003c/code\u003e command knows no import path for\nthe current directory and makes up a fake one based\non the directory name: \u003ccode\u003e_/home/gopher/hello\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet’s make the current directory the root of a module\nby using \u003ccode\u003ego mod init\u003c/code\u003e and then try \u003ccode\u003ego test\u003c/code\u003e again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod init example.com/hello\ngo: creating new go.mod: module example.com/hello\n$ go test\nPASS\nok      example.com/hello   0.020s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCongratulations! You’ve written and tested your first module.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego mod init\u003c/code\u003e command wrote a \u003ccode\u003ego.mod\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ego.mod\u003c/code\u003e file only appears in the root of the module.\nPackages in subdirectories have import paths consisting of\nthe module path plus the path to the subdirectory.\nFor example, if we created a subdirectory \u003ccode\u003eworld\u003c/code\u003e,\nwe would not need to (nor want to) run \u003ccode\u003ego mod init\u003c/code\u003e there.\nThe package would automatically be recognized as part of the\n\u003ccode\u003eexample.com/hello\u003c/code\u003e module, with import path\n\u003ccode\u003eexample.com/hello/world\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"adding-a-dependency\"\u003eAdding a dependency\u003c/h2\u003e\n\u003cp\u003eThe primary motivation for Go modules was to improve the\nexperience of using (that is, adding a dependency on)\ncode written by other developers.\u003c/p\u003e\n\u003cp\u003eLet’s update our \u003ccode\u003ehello.go\u003c/code\u003e to import \u003ccode\u003ersc.io/quote\u003c/code\u003e\nand use it to implement \u003ccode\u003eHello\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nimport \u0026#34;rsc.io/quote\u0026#34;\n\nfunc Hello() string {\n    return quote.Hello()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow let’s run the test again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test\ngo: finding rsc.io/quote v1.5.2\ngo: downloading rsc.io/quote v1.5.2\ngo: extracting rsc.io/quote v1.5.2\ngo: finding rsc.io/sampler v1.3.0\ngo: finding golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\ngo: downloading rsc.io/sampler v1.3.0\ngo: extracting rsc.io/sampler v1.3.0\ngo: downloading golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\ngo: extracting golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\nPASS\nok      example.com/hello   0.023s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e command resolves imports by using the specific\ndependency module versions listed in \u003ccode\u003ego.mod\u003c/code\u003e.\nWhen it encounters an \u003ccode\u003eimport\u003c/code\u003e of a package not provided\nby any module in \u003ccode\u003ego.mod\u003c/code\u003e, the \u003ccode\u003ego\u003c/code\u003e command automatically\nlooks up the module containing that package and adds it to\n\u003ccode\u003ego.mod\u003c/code\u003e, using the latest version.\n(“Latest” is defined as the\nlatest tagged stable (non-\u003ca href=\"https://semver.org/#spec-item-9\" rel=\"noreferrer\" target=\"_blank\"\u003eprerelease\u003c/a\u003e) version,\nor else the latest tagged prerelease version,\nor else the latest untagged version.)\nIn our example, \u003ccode\u003ego test\u003c/code\u003e resolved the new import \u003ccode\u003ersc.io/quote\u003c/code\u003e\nto the module \u003ccode\u003ersc.io/quote v1.5.2\u003c/code\u003e.\nIt also downloaded two dependencies used by \u003ccode\u003ersc.io/quote\u003c/code\u003e,\nnamely \u003ccode\u003ersc.io/sampler\u003c/code\u003e and \u003ccode\u003egolang.org/x/text\u003c/code\u003e.\nOnly direct dependencies are recorded in the \u003ccode\u003ego.mod\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n\nrequire rsc.io/quote v1.5.2\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA second \u003ccode\u003ego test\u003c/code\u003e command will not repeat this work,\nsince the \u003ccode\u003ego.mod\u003c/code\u003e is now up-to-date and the downloaded\nmodules are cached locally (in \u003ccode\u003e$GOPATH/pkg/mod\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test\nPASS\nok      example.com/hello   0.020s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that while the \u003ccode\u003ego\u003c/code\u003e command makes adding a new dependency\nquick and easy, it is not without cost.\nYour module now literally \u003cem\u003edepends\u003c/em\u003e on the new dependency\nin critical areas such as correctness, security, and proper licensing,\njust to name a few.\nFor more considerations, see Russ Cox’s blog post,\n“\u003ca href=\"https://research.swtch.com/deps\" rel=\"noreferrer\" target=\"_blank\"\u003eOur Software Dependency Problem\u003c/a\u003e.”\u003c/p\u003e\n\u003cp\u003eAs we saw above, adding one direct dependency often\nbrings in other indirect dependencies too.\nThe command \u003ccode\u003ego list -m all\u003c/code\u003e lists the current module\nand all its dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m all\nexample.com/hello\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c\nrsc.io/quote v1.5.2\nrsc.io/sampler v1.3.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the \u003ccode\u003ego list\u003c/code\u003e output, the current module,\nalso known as the \u003cem\u003emain module\u003c/em\u003e,\nis always the first line,\nfollowed by dependencies sorted by module path.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egolang.org/x/text\u003c/code\u003e version \u003ccode\u003ev0.0.0-20170915032832-14c0d48ead0c\u003c/code\u003e\nis an example of a\n\u003ca href=\"/cmd/go/#hdr-Pseudo_versions\"\u003epseudo-version\u003c/a\u003e,\nwhich is the \u003ccode\u003ego\u003c/code\u003e command’s version syntax\nfor a specific untagged commit.\u003c/p\u003e\n\u003cp\u003eIn addition to \u003ccode\u003ego.mod\u003c/code\u003e, the \u003ccode\u003ego\u003c/code\u003e command\nmaintains a file named \u003ccode\u003ego.sum\u003c/code\u003e containing\nthe expected \u003ca href=\"/cmd/go/#hdr-Module_downloading_and_verification\"\u003ecryptographic hashes\u003c/a\u003e of the content of specific module versions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go.sum\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZO...\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:Nq...\nrsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3...\nrsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPX...\nrsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/Q...\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e command uses the \u003ccode\u003ego.sum\u003c/code\u003e file to ensure that\nfuture downloads of these modules retrieve the same bits\nas the first download,\nto ensure the modules your project depends on\ndo not change unexpectedly,\nwhether for malicious, accidental, or other reasons.\nBoth \u003ccode\u003ego.mod\u003c/code\u003e and \u003ccode\u003ego.sum\u003c/code\u003e should be checked into version control.\u003c/p\u003e\n\u003ch2 id=\"upgrading-dependencies\"\u003eUpgrading dependencies\u003c/h2\u003e\n\u003cp\u003eWith Go modules, versions are referenced with semantic version tags.\nA semantic version has three parts: major, minor, and patch.\nFor example, for \u003ccode\u003ev0.1.2\u003c/code\u003e, the major version is 0, the minor version is 1,\nand the patch version is 2.\nLet’s walk through a couple minor version upgrades.\nIn the next section, we’ll consider a major version upgrade.\u003c/p\u003e\n\u003cp\u003eFrom the output of \u003ccode\u003ego list -m all\u003c/code\u003e,\nwe can see we’re using an untagged version of \u003ccode\u003egolang.org/x/text\u003c/code\u003e.\nLet’s upgrade to the latest tagged version and test that everything still works:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get golang.org/x/text\ngo: finding golang.org/x/text v0.3.0\ngo: downloading golang.org/x/text v0.3.0\ngo: extracting golang.org/x/text v0.3.0\n$ go test\nPASS\nok      example.com/hello   0.013s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWoohoo! Everything passes.\nLet’s take another look at \u003ccode\u003ego list -m all\u003c/code\u003e and the \u003ccode\u003ego.mod\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m all\nexample.com/hello\ngolang.org/x/text v0.3.0\nrsc.io/quote v1.5.2\nrsc.io/sampler v1.3.0\n$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n\nrequire (\n    golang.org/x/text v0.3.0 // indirect\n    rsc.io/quote v1.5.2\n)\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003egolang.org/x/text\u003c/code\u003e package has been upgraded to the latest tagged version (\u003ccode\u003ev0.3.0\u003c/code\u003e).\nThe \u003ccode\u003ego.mod\u003c/code\u003e file has been updated to specify \u003ccode\u003ev0.3.0\u003c/code\u003e too.\nThe \u003ccode\u003eindirect\u003c/code\u003e comment indicates a dependency is not used directly\nby this module, only indirectly by other module dependencies.\nSee \u003ccode\u003ego help modules\u003c/code\u003e for details.\u003c/p\u003e\n\u003cp\u003eNow let’s try upgrading the \u003ccode\u003ersc.io/sampler\u003c/code\u003e minor version.\nStart the same way, by running \u003ccode\u003ego get\u003c/code\u003e and running tests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get rsc.io/sampler\ngo: finding rsc.io/sampler v1.99.99\ngo: downloading rsc.io/sampler v1.99.99\ngo: extracting rsc.io/sampler v1.99.99\n$ go test\n--- FAIL: TestHello (0.00s)\n    hello_test.go:8: Hello() = \u0026#34;99 bottles of beer on the wall, 99 bottles of beer, ...\u0026#34;, want \u0026#34;Hello, world.\u0026#34;\nFAIL\nexit status 1\nFAIL    example.com/hello   0.014s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUh, oh! The test failure shows that the\nlatest version of \u003ccode\u003ersc.io/sampler\u003c/code\u003e is incompatible with our usage.\nLet’s list the available tagged versions of that module:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m -versions rsc.io/sampler\nrsc.io/sampler v1.0.0 v1.2.0 v1.2.1 v1.3.0 v1.3.1 v1.99.99\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe had been using v1.3.0; v1.99.99 is clearly no good.\nMaybe we can try using v1.3.1 instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get rsc.io/sampler@v1.3.1\ngo: finding rsc.io/sampler v1.3.1\ngo: downloading rsc.io/sampler v1.3.1\ngo: extracting rsc.io/sampler v1.3.1\n$ go test\nPASS\nok      example.com/hello   0.022s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the explicit \u003ccode\u003e@v1.3.1\u003c/code\u003e in the \u003ccode\u003ego get\u003c/code\u003e argument.\nIn general each argument passed to \u003ccode\u003ego get\u003c/code\u003e can take\nan explicit version; the default is \u003ccode\u003e@latest\u003c/code\u003e,\nwhich resolves to the latest version as defined earlier.\u003c/p\u003e\n\u003ch2 id=\"adding-a-dependency-on-a-new-major-version\"\u003eAdding a dependency on a new major version\u003c/h2\u003e\n\u003cp\u003eLet’s add a new function to our package:\n\u003ccode\u003efunc Proverb\u003c/code\u003e returns a Go concurrency proverb,\nby calling \u003ccode\u003equote.Concurrency\u003c/code\u003e, which is provided by\nthe module \u003ccode\u003ersc.io/quote/v3\u003c/code\u003e.\nFirst we update \u003ccode\u003ehello.go\u003c/code\u003e to add the new function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nimport (\n    \u0026#34;rsc.io/quote\u0026#34;\n    quoteV3 \u0026#34;rsc.io/quote/v3\u0026#34;\n)\n\nfunc Hello() string {\n    return quote.Hello()\n}\n\nfunc Proverb() string {\n    return quoteV3.Concurrency()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen we add a test to \u003ccode\u003ehello_test.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestProverb(t *testing.T) {\n    want := \u0026#34;Concurrency is not parallelism.\u0026#34;\n    if got := Proverb(); got != want {\n        t.Errorf(\u0026#34;Proverb() = %q, want %q\u0026#34;, got, want)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen we can test our code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test\ngo: finding rsc.io/quote/v3 v3.1.0\ngo: downloading rsc.io/quote/v3 v3.1.0\ngo: extracting rsc.io/quote/v3 v3.1.0\nPASS\nok      example.com/hello   0.024s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that our module now depends on both \u003ccode\u003ersc.io/quote\u003c/code\u003e and \u003ccode\u003ersc.io/quote/v3\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m rsc.io/q...\nrsc.io/quote v1.5.2\nrsc.io/quote/v3 v3.1.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach different major version (\u003ccode\u003ev1\u003c/code\u003e, \u003ccode\u003ev2\u003c/code\u003e, and so on) of a Go module\nuses a different module path: starting at \u003ccode\u003ev2\u003c/code\u003e, the path must end in the major version.\nIn the example, \u003ccode\u003ev3\u003c/code\u003e of \u003ccode\u003ersc.io/quote\u003c/code\u003e is no longer \u003ccode\u003ersc.io/quote\u003c/code\u003e: instead,\nit is identified by the module path \u003ccode\u003ersc.io/quote/v3\u003c/code\u003e.\nThis convention is called\n\u003ca href=\"https://research.swtch.com/vgo-import\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic import versioning\u003c/a\u003e,\nand it gives incompatible packages (those with different major versions)\ndifferent names.\nIn contrast, \u003ccode\u003ev1.6.0\u003c/code\u003e of \u003ccode\u003ersc.io/quote\u003c/code\u003e should be backwards-compatible\nwith \u003ccode\u003ev1.5.2\u003c/code\u003e, so it reuses the name \u003ccode\u003ersc.io/quote\u003c/code\u003e.\n(In the previous section, \u003ccode\u003ersc.io/sampler\u003c/code\u003e \u003ccode\u003ev1.99.99\u003c/code\u003e\n\u003cem\u003eshould\u003c/em\u003e have been backwards-compatible\nwith \u003ccode\u003ersc.io/sampler\u003c/code\u003e \u003ccode\u003ev1.3.0\u003c/code\u003e, but bugs or incorrect client assumptions about\nmodule behavior can both happen.)\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e command allows a build to include at most one version of\nany particular module path, meaning at most one of each major\nversion: one \u003ccode\u003ersc.io/quote\u003c/code\u003e, one \u003ccode\u003ersc.io/quote/v2\u003c/code\u003e, one \u003ccode\u003ersc.io/quote/v3\u003c/code\u003e,\nand so on.\nThis gives module authors a clear rule about possible duplication\nof a single module path: it is impossible for a program to build with both\n\u003ccode\u003ersc.io/quote v1.5.2\u003c/code\u003e and \u003ccode\u003ersc.io/quote v1.6.0\u003c/code\u003e.\nAt the same time, allowing different major versions of a module\n(because they have different paths)\ngives module consumers the ability to\nupgrade to a new major version incrementally.\nIn this example, we wanted to use \u003ccode\u003equote.Concurrency\u003c/code\u003e from \u003ccode\u003ersc/quote/v3 v3.1.0\u003c/code\u003e\nbut are not yet ready to migrate our uses of \u003ccode\u003ersc.io/quote v1.5.2\u003c/code\u003e.\nThe ability to migrate incrementally\nis especially important in a large program or codebase.\u003c/p\u003e\n\u003ch2 id=\"upgrading-a-dependency-to-a-new-major-version\"\u003eUpgrading a dependency to a new major version\u003c/h2\u003e\n\u003cp\u003eLet’s complete our conversion from using \u003ccode\u003ersc.io/quote\u003c/code\u003e to using only \u003ccode\u003ersc.io/quote/v3\u003c/code\u003e.\nBecause of the major version change, we should expect that some APIs may have\nbeen removed, renamed, or otherwise changed in incompatible ways.\nReading the docs, we can see that \u003ccode\u003eHello\u003c/code\u003e has become \u003ccode\u003eHelloV3\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go doc rsc.io/quote/v3\npackage quote // import \u0026#34;rsc.io/quote/v3\u0026#34;\n\nPackage quote collects pithy sayings.\n\nfunc Concurrency() string\nfunc GlassV3() string\nfunc GoV3() string\nfunc HelloV3() string\nfunc OptV3() string\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can update our use of \u003ccode\u003equote.Hello()\u003c/code\u003e in \u003ccode\u003ehello.go\u003c/code\u003e to use \u003ccode\u003equoteV3.HelloV3()\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nimport quoteV3 \u0026#34;rsc.io/quote/v3\u0026#34;\n\nfunc Hello() string {\n    return quoteV3.HelloV3()\n}\n\nfunc Proverb() string {\n    return quoteV3.Concurrency()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd then at this point, there’s no need for the renamed import anymore,\nso we can undo that:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage hello\n\nimport \u0026#34;rsc.io/quote/v3\u0026#34;\n\nfunc Hello() string {\n    return quote.HelloV3()\n}\n\nfunc Proverb() string {\n    return quote.Concurrency()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s re-run the tests to make sure everything is working:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test\nPASS\nok      example.com/hello       0.014s\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"removing-unused-dependencies\"\u003eRemoving unused dependencies\u003c/h2\u003e\n\u003cp\u003eWe’ve removed all our uses of \u003ccode\u003ersc.io/quote\u003c/code\u003e,\nbut it still shows up in \u003ccode\u003ego list -m all\u003c/code\u003e and in our \u003ccode\u003ego.mod\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m all\nexample.com/hello\ngolang.org/x/text v0.3.0\nrsc.io/quote v1.5.2\nrsc.io/quote/v3 v3.1.0\nrsc.io/sampler v1.3.1\n$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n\nrequire (\n    golang.org/x/text v0.3.0 // indirect\n    rsc.io/quote v1.5.2\n    rsc.io/quote/v3 v3.0.0\n    rsc.io/sampler v1.3.1 // indirect\n)\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhy? Because building a single package, like with \u003ccode\u003ego build\u003c/code\u003e or \u003ccode\u003ego test\u003c/code\u003e,\ncan easily tell when something is missing and needs to be added,\nbut not when something can safely be removed.\nRemoving a dependency can only be done after\nchecking all packages in a module,\nand all possible build tag combinations for those packages.\nAn ordinary build command does not load this information,\nand so it cannot safely remove dependencies.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego mod tidy\u003c/code\u003e command cleans up these unused dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod tidy\n$ go list -m all\nexample.com/hello\ngolang.org/x/text v0.3.0\nrsc.io/quote/v3 v3.1.0\nrsc.io/sampler v1.3.1\n$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n\nrequire (\n    golang.org/x/text v0.3.0 // indirect\n    rsc.io/quote/v3 v3.1.0\n    rsc.io/sampler v1.3.1 // indirect\n)\n\n$ go test\nPASS\nok      example.com/hello   0.020s\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eGo modules are the future of dependency management in Go.\nModule functionality is now available in all supported Go versions\n(that is, in Go 1.11 and Go 1.12).\u003c/p\u003e\n\u003cp\u003eThis post introduced these workflows using Go modules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ego mod init\u003c/code\u003e creates a new module, initializing the \u003ccode\u003ego.mod\u003c/code\u003e file that describes it.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ego build\u003c/code\u003e, \u003ccode\u003ego test\u003c/code\u003e, and other package-building commands add new dependencies to \u003ccode\u003ego.mod\u003c/code\u003e as needed.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ego list -m all\u003c/code\u003e prints the current module’s dependencies.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ego get\u003c/code\u003e changes the required version of a dependency (or adds a new dependency).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ego mod tidy\u003c/code\u003e removes unused dependencies.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe encourage you to start using modules in your local development\nand to add \u003ccode\u003ego.mod\u003c/code\u003e and \u003ccode\u003ego.sum\u003c/code\u003e files to your projects.\nTo provide feedback and help shape the future of dependency management in Go,\nplease send us\n\u003ca href=\"/issue/new\"\u003ebug reports\u003c/a\u003e or \u003ca href=\"/wiki/ExperienceReports\"\u003eexperience reports\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThanks for all your feedback and help improving modules.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-03-19T00:00:00Z",
  "Author": "Tyler Bui-Palsulich and Eno Compton"
}