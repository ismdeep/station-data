{
  "Source": "go.dev",
  "Title": "Command PATH security in Go",
  "Link": "https://go.dev/blog/path-security",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/path-security\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eCommand PATH security in Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      19 January 2021\n      \u003c/p\u003e\n      \n      \u003cp\u003eToday’s \u003ca href=\"/s/go-security-release-jan-2021\"\u003eGo security release\u003c/a\u003e\nfixes an issue involving PATH lookups in untrusted directories\nthat can lead to remote execution during the \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e command.\nWe expect people to have questions about what exactly this means\nand whether they might have issues in their own programs.\nThis post details the bug, the fixes we have applied,\nhow to decide whether your own programs are vulnerable to similar problems,\nand what you can do if they are.\u003c/p\u003e\n\u003ch2 id=\"go-command--remote-execution\"\u003eGo command \u0026amp; remote execution\u003c/h2\u003e\n\u003cp\u003eOne of the design goals for the \u003ccode\u003ego\u003c/code\u003e command is that most commands – including\n\u003ccode\u003ego\u003c/code\u003e \u003ccode\u003ebuild\u003c/code\u003e, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003edoc\u003c/code\u003e, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003einstall\u003c/code\u003e, and \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003elist\u003c/code\u003e – do not run\narbitrary code downloaded from the internet.\nThere are a few obvious exceptions:\nclearly \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003erun\u003c/code\u003e, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003etest\u003c/code\u003e, and \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e \u003cem\u003edo\u003c/em\u003e run arbitrary code – that’s their job.\nBut the others must not, for a variety of reasons including reproducible builds and security.\nSo when \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e can be tricked into executing arbitrary code, we consider that a security bug.\u003c/p\u003e\n\u003cp\u003eIf \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e must not run arbitrary code, then unfortunately that means\nall the programs it invokes, such as compilers and version control systems, are also inside the security perimeter.\nFor example, we’ve had issues in the past in which clever use of obscure compiler features\nor remote execution bugs in version control systems became remote execution bugs in Go.\n(On that note, Go 1.16 aims to improve the situation by introducing a GOVCS setting\nthat allows configuration of exactly which version control systems are allowed and when.)\u003c/p\u003e\n\u003cp\u003eToday’s bug, however, was entirely our fault, not a bug or obscure feature of \u003ccode\u003egcc\u003c/code\u003e or \u003ccode\u003egit\u003c/code\u003e.\nThe bug involves how Go and other programs find other executables,\nso we need to spend a little time looking at that before we can get to the details.\u003c/p\u003e\n\u003ch2 id=\"commands-and-paths-and-go\"\u003eCommands and PATHs and Go\u003c/h2\u003e\n\u003cp\u003eAll operating systems have a concept of an executable path\n(\u003ccode\u003e$PATH\u003c/code\u003e on Unix, \u003ccode\u003e%PATH%\u003c/code\u003e on Windows; for simplicity, we’ll just use the term PATH),\nwhich is a list of directories.\nWhen you type a command into a shell prompt,\nthe shell looks in each of the listed directories,\nin turn, for an executable with the name you typed.\nIt runs the first one it finds, or it prints a message like “command not found.”\u003c/p\u003e\n\u003cp\u003eOn Unix, this idea first appeared in Seventh Edition Unix’s Bourne shell (1979). The manual explained:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe shell parameter \u003ccode\u003e$PATH\u003c/code\u003e defines the search path for the directory containing the command.\nEach alternative directory name is separated by a colon (\u003ccode\u003e:\u003c/code\u003e).\nThe default path is \u003ccode\u003e:/bin:/usr/bin\u003c/code\u003e.\nIf the command name contains a / then the search path is not used.\nOtherwise, each directory in the path is searched for an executable file.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNote the default: the current directory (denoted here by an empty string,\nbut let’s call it “dot”)\nis listed ahead of \u003ccode\u003e/bin\u003c/code\u003e and \u003ccode\u003e/usr/bin\u003c/code\u003e.\nMS-DOS and then Windows chose to hard-code that behavior:\non those systems, dot is always searched first,\nautomatically, before considering any directories listed in \u003ccode\u003e%PATH%\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAs Grampp and Morris pointed out in their\nclassic paper “\u003ca href=\"https://people.engr.ncsu.edu/gjin2/Classes/246/Spring2019/Security.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003eUNIX Operating System Security\u003c/a\u003e” (1984),\nplacing dot ahead of system directories in the PATH\nmeans that if you \u003ccode\u003ecd\u003c/code\u003e into a directory and run \u003ccode\u003els\u003c/code\u003e,\nyou might get a malicious copy from that directory\ninstead of the system utility.\nAnd if you can trick a system administrator to run \u003ccode\u003els\u003c/code\u003e in your home directory\nwhile logged in as \u003ccode\u003eroot\u003c/code\u003e, then you can run any code you want.\nBecause of this problem and others like it,\nessentially all modern Unix distributions set a new user’s default PATH\nto exclude dot.\nBut Windows systems continue to search dot first, no matter what PATH says.\u003c/p\u003e\n\u003cp\u003eFor example, when you type the command\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego version\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eon a typically-configured Unix,\nthe shell runs a \u003ccode\u003ego\u003c/code\u003e executable from a system directory in your PATH.\nBut when you type that command on Windows,\n\u003ccode\u003ecmd.exe\u003c/code\u003e checks dot first.\nIf \u003ccode\u003e.\\go.exe\u003c/code\u003e (or \u003ccode\u003e.\\go.bat\u003c/code\u003e or many other choices) exists,\n\u003ccode\u003ecmd.exe\u003c/code\u003e runs that executable, not one from your PATH.\u003c/p\u003e\n\u003cp\u003eFor Go, PATH searches are handled by \u003ca href=\"https://pkg.go.dev/os/exec#LookPath\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eexec.LookPath\u003c/code\u003e\u003c/a\u003e,\ncalled automatically by\n\u003ca href=\"https://pkg.go.dev/os/exec#Command\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eexec.Command\u003c/code\u003e\u003c/a\u003e.\nAnd to fit well into the host system, Go’s \u003ccode\u003eexec.LookPath\u003c/code\u003e\nimplements the Unix rules on Unix and the Windows rules on Windows.\nFor example, this command\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eout, err := exec.Command(\u0026#34;go\u0026#34;, \u0026#34;version\u0026#34;).CombinedOutput()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebehaves the same as typing \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eversion\u003c/code\u003e into the operating system shell.\nOn Windows, it runs \u003ccode\u003e.\\go.exe\u003c/code\u003e when that exists.\u003c/p\u003e\n\u003cp\u003e(It is worth noting that Windows PowerShell changed this behavior,\ndropping the implicit search of dot, but \u003ccode\u003ecmd.exe\u003c/code\u003e and the\nWindows C library \u003ca href=\"https://docs.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-searchpatha\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSearchPath function\u003c/code\u003e\u003c/a\u003e\ncontinue to behave as they always have.\nGo continues to match \u003ccode\u003ecmd.exe\u003c/code\u003e.)\u003c/p\u003e\n\u003ch2 id=\"the-bug\"\u003eThe Bug\u003c/h2\u003e\n\u003cp\u003eWhen \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e downloads and builds a package that contains\n\u003ccode\u003eimport\u003c/code\u003e \u003ccode\u003e\u0026#34;C\u0026#34;\u003c/code\u003e, it runs a program called \u003ccode\u003ecgo\u003c/code\u003e to prepare the Go\nequivalent of the relevant C code.\nThe \u003ccode\u003ego\u003c/code\u003e command runs \u003ccode\u003ecgo\u003c/code\u003e in the directory containing the package sources.\nOnce \u003ccode\u003ecgo\u003c/code\u003e has generated its Go output files,\nthe \u003ccode\u003ego\u003c/code\u003e command itself invokes the Go compiler\non the generated Go files\nand the host C compiler (\u003ccode\u003egcc\u003c/code\u003e or \u003ccode\u003eclang\u003c/code\u003e)\nto build any C sources included with the package.\nAll this works well.\nBut where does the \u003ccode\u003ego\u003c/code\u003e command find the host C compiler?\nIt looks in the PATH, of course. Luckily, while it runs the C compiler\nin the package source directory, it does the PATH lookup\nfrom the original directory where the \u003ccode\u003ego\u003c/code\u003e command was invoked:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd := exec.Command(\u0026#34;gcc\u0026#34;, \u0026#34;file.c\u0026#34;)\ncmd.Dir = \u0026#34;badpkg\u0026#34;\ncmd.Run()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSo even if \u003ccode\u003ebadpkg\\gcc.exe\u003c/code\u003e exists on a Windows system,\nthis code snippet will not find it.\nThe lookup that happens in \u003ccode\u003eexec.Command\u003c/code\u003e does not know\nabout the \u003ccode\u003ebadpkg\u003c/code\u003e directory.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e command uses similar code to invoke \u003ccode\u003ecgo\u003c/code\u003e,\nand in that case there’s not even a path lookup,\nbecause \u003ccode\u003ecgo\u003c/code\u003e always comes from GOROOT:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecmd := exec.Command(GOROOT+\u0026#34;/pkg/tool/\u0026#34;+GOOS_GOARCH+\u0026#34;/cgo\u0026#34;, \u0026#34;file.go\u0026#34;)\ncmd.Dir = \u0026#34;badpkg\u0026#34;\ncmd.Run()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is even safer than the previous snippet:\nthere’s no chance of running any bad \u003ccode\u003ecgo.exe\u003c/code\u003e that may exist.\u003c/p\u003e\n\u003cp\u003eBut it turns out that cgo itself also invokes the host C compiler,\non some temporary files it creates, meaning it executes this code itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// running in cgo in badpkg dir\ncmd := exec.Command(\u0026#34;gcc\u0026#34;, \u0026#34;tmpfile.c\u0026#34;)\ncmd.Run()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, because cgo itself is running in \u003ccode\u003ebadpkg\u003c/code\u003e,\nnot in the directory where the \u003ccode\u003ego\u003c/code\u003e command was run,\nit will run \u003ccode\u003ebadpkg\\gcc.exe\u003c/code\u003e if that file exists,\ninstead of finding the system \u003ccode\u003egcc\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo an attacker can create a malicious package that uses cgo and\nincludes a \u003ccode\u003egcc.exe\u003c/code\u003e, and then any Windows user\nthat runs \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e to download and build the attacker’s package\nwill run the attacker-supplied \u003ccode\u003egcc.exe\u003c/code\u003e in preference to any\n\u003ccode\u003egcc\u003c/code\u003e in the system path.\u003c/p\u003e\n\u003cp\u003eUnix systems avoid the problem first because dot is typically not\nin the PATH and second because module unpacking does not\nset execute bits on the files it writes.\nBut Unix users who have dot ahead of system directories\nin their PATH and are using GOPATH mode would be as susceptible\nas Windows users.\n(If that describes you, today is a good day to remove dot from your path\nand to start using Go modules.)\u003c/p\u003e\n\u003cp\u003e(Thanks to \u003ca href=\"https://twitter.com/ryotkak\" rel=\"noreferrer\" target=\"_blank\"\u003eRyotaK\u003c/a\u003e for \u003ca href=\"/security\"\u003ereporting this issue\u003c/a\u003e to us.)\u003c/p\u003e\n\u003ch2 id=\"the-fixes\"\u003eThe Fixes\u003c/h2\u003e\n\u003cp\u003eIt’s obviously unacceptable for the \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e command to download\nand run a malicious \u003ccode\u003egcc.exe\u003c/code\u003e.\nBut what’s the actual mistake that allows that?\nAnd then what’s the fix?\u003c/p\u003e\n\u003cp\u003eOne possible answer is that the mistake is that \u003ccode\u003ecgo\u003c/code\u003e does the search for the host C compiler\nin the untrusted source directory instead of in the directory where the \u003ccode\u003ego\u003c/code\u003e command\nwas invoked.\nIf that’s the mistake,\nthen the fix is to change the \u003ccode\u003ego\u003c/code\u003e command to pass \u003ccode\u003ecgo\u003c/code\u003e the full path to the\nhost C compiler, so that \u003ccode\u003ecgo\u003c/code\u003e need not do a PATH lookup in\nto the untrusted directory.\u003c/p\u003e\n\u003cp\u003eAnother possible answer is that the mistake is to look in dot\nduring PATH lookups, whether happens automatically on Windows\nor because of an explicit PATH entry on a Unix system.\nA user may want to look in dot to find a command they typed\nin a console or shell window,\nbut it’s unlikely they also want to look there to find a subprocess of a subprocess\nof a typed command.\nIf that’s the mistake,\nthen the fix is to change the \u003ccode\u003ecgo\u003c/code\u003e command not to look in dot during a PATH lookup.\u003c/p\u003e\n\u003cp\u003eWe decided both were mistakes, so we applied both fixes.\nThe \u003ccode\u003ego\u003c/code\u003e command now passes the full host C compiler path to \u003ccode\u003ecgo\u003c/code\u003e.\nOn top of that, \u003ccode\u003ecgo\u003c/code\u003e, \u003ccode\u003ego\u003c/code\u003e, and every other command in the Go distribution\nnow use a variant of the \u003ccode\u003eos/exec\u003c/code\u003e package that reports an error if it would\nhave previously used an executable from dot.\nThe packages \u003ccode\u003ego/build\u003c/code\u003e and \u003ccode\u003ego/import\u003c/code\u003e use the same policy for\ntheir invocation of the \u003ccode\u003ego\u003c/code\u003e command and other tools.\nThis should shut the door on any similar security problems that may be lurking.\u003c/p\u003e\n\u003cp\u003eOut of an abundance of caution, we also made a similar fix in\ncommands like \u003ccode\u003egoimports\u003c/code\u003e and \u003ccode\u003egopls\u003c/code\u003e,\nas well as the libraries\n\u003ccode\u003egolang.org/x/tools/go/analysis\u003c/code\u003e\nand\n\u003ccode\u003egolang.org/x/tools/go/packages\u003c/code\u003e,\nwhich invoke the \u003ccode\u003ego\u003c/code\u003e command as a subprocess.\nIf you run these programs in untrusted directories –\nfor example, if you \u003ccode\u003egit\u003c/code\u003e \u003ccode\u003echeckout\u003c/code\u003e untrusted repositories\nand \u003ccode\u003ecd\u003c/code\u003e into them and then run programs like these,\nand you use Windows or use Unix with dot in your PATH –\nthen you should update your copies of these commands too.\nIf the only untrusted directories on your computer\nare the ones in the module cache managed by \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e,\nthen you only need the new Go release.\u003c/p\u003e\n\u003cp\u003eAfter updating to the new Go release, you can update to the latest \u003ccode\u003egopls\u003c/code\u003e by using:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGO111MODULE=on \\\ngo get golang.org/x/tools/gopls@v0.6.4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand you can update to the latest \u003ccode\u003egoimports\u003c/code\u003e or other tools by using:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGO111MODULE=on \\\ngo get golang.org/x/tools/cmd/goimports@v0.1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can update programs that depend on \u003ccode\u003egolang.org/x/tools/go/packages\u003c/code\u003e,\neven before their authors do,\nby adding an explicit upgrade of the dependency during \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGO111MODULE=on \\\ngo get example.com/cmd/thecmd golang.org/x/tools@v0.1.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor programs that use \u003ccode\u003ego/build\u003c/code\u003e, it is sufficient for you to recompile them\nusing the updated Go release.\u003c/p\u003e\n\u003cp\u003eAgain, you only need to update these other programs if you\nare a Windows user or a Unix user with dot in the PATH\n\u003cem\u003eand\u003c/em\u003e you run these programs in source directories you do not trust\nthat may contain malicious programs.\u003c/p\u003e\n\u003ch2 id=\"are-your-own-programs-affected\"\u003eAre your own programs affected?\u003c/h2\u003e\n\u003cp\u003eIf you use \u003ccode\u003eexec.LookPath\u003c/code\u003e or \u003ccode\u003eexec.Command\u003c/code\u003e in your own programs,\nyou only need to be concerned if you (or your users) run your program\nin a directory with untrusted contents.\nIf so, then a subprocess could be started using an executable\nfrom dot instead of from a system directory.\n(Again, using an executable from dot happens always on Windows\nand only with uncommon PATH settings on Unix.)\u003c/p\u003e\n\u003cp\u003eIf you are concerned, then we’ve published the more restricted variant\nof \u003ccode\u003eos/exec\u003c/code\u003e as \u003ca href=\"https://pkg.go.dev/golang.org/x/sys/execabs\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/sys/execabs\u003c/code\u003e\u003c/a\u003e.\nYou can use it in your program by simply replacing\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026#34;os/exec\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewith\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport exec \u0026#34;golang.org/x/sys/execabs\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand recompiling.\u003c/p\u003e\n\u003ch2 id=\"securing-osexec-by-default\"\u003eSecuring os/exec by default\u003c/h2\u003e\n\u003cp\u003eWe have been discussing on\n\u003ca href=\"/issue/38736\"\u003egolang.org/issue/38736\u003c/a\u003e\nwhether the Windows behavior of always preferring the current directory\nin PATH lookups (during \u003ccode\u003eexec.Command\u003c/code\u003e and \u003ccode\u003eexec.LookPath\u003c/code\u003e)\nshould be changed.\nThe argument in favor of the change is that it closes the kinds of\nsecurity problems discussed in this blog post.\nA supporting argument is that although the Windows \u003ccode\u003eSearchPath\u003c/code\u003e API\nand \u003ccode\u003ecmd.exe\u003c/code\u003e still always search the current directory,\nPowerShell, the successor to \u003ccode\u003ecmd.exe\u003c/code\u003e, does not,\nan apparent recognition that the original behavior was a mistake.\nThe argument against the change is that it could break existing Windows\nprograms that intend to find programs in the current directory.\nWe don’t know how many such programs exist,\nbut they would get unexplained failures if the PATH lookups\nstarted skipping the current directory entirely.\u003c/p\u003e\n\u003cp\u003eThe approach we have taken in \u003ccode\u003egolang.org/x/sys/execabs\u003c/code\u003e may\nbe a reasonable middle ground.\nIt finds the result of the old PATH lookup and then returns a\nclear error rather than use a result from the current directory.\nThe error returned from \u003ccode\u003eexec.Command(\u0026#34;prog\u0026#34;)\u003c/code\u003e when \u003ccode\u003eprog.exe\u003c/code\u003e exists looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprog resolves to executable in current directory (.\\prog.exe)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor programs that do change behavior, this error should make very clear what has happened.\nPrograms that intend to run a program from the current directory can use\n\u003ccode\u003eexec.Command(\u0026#34;./prog\u0026#34;)\u003c/code\u003e instead (that syntax works on all systems, even Windows).\u003c/p\u003e\n\u003cp\u003eWe have filed this idea as a new proposal, \u003ca href=\"/issue/43724\"\u003egolang.org/issue/43724\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-01-19T00:00:00Z",
  "Author": "Russ Cox"
}