{
  "Source": "go.dev",
  "Title": "A new Go API for Protocol Buffers",
  "Link": "https://go.dev/blog/protobuf-apiv2",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/protobuf-apiv2\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eA new Go API for Protocol Buffers\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Joe Tsai, Damien Neil,  and Herbie Ong\u003cbr/\u003e\n      2 March 2020\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWe are pleased to announce the release of a major revision of the Go API for\n\u003ca href=\"https://developers.google.com/protocol-buffers\" rel=\"noreferrer\" target=\"_blank\"\u003eprotocol buffers\u003c/a\u003e,\nGoogle’s language-neutral data interchange format.\u003c/p\u003e\n\u003ch2 id=\"motivations-for-a-new-api\"\u003eMotivations for a new API\u003c/h2\u003e\n\u003cp\u003eThe first protocol buffer bindings for Go were\n\u003ca href=\"/blog/third-party-libraries-goprotobuf-and\"\u003eannounced by Rob Pike\u003c/a\u003e\nin March of 2010. Go 1 would not be released for another two years.\u003c/p\u003e\n\u003cp\u003eIn the decade since that first release, the package has grown and\ndeveloped along with Go. Its users’ requirements have grown too.\u003c/p\u003e\n\u003cp\u003eMany people want to write programs that use reflection to examine protocol\nbuffer messages. The\n\u003ca href=\"https://pkg.go.dev/reflect\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ereflect\u003c/code\u003e\u003c/a\u003e\npackage provides a view of Go types and\nvalues, but omits information from the protocol buffer type system. For\nexample, we might want to write a function that traverses a log entry and\nclears any field annotated as containing sensitive data. The annotations\nare not part of the Go type system.\u003c/p\u003e\n\u003cp\u003eAnother common desire is to use data structures other than the ones\ngenerated by the protocol buffer compiler, such as a dynamic message type\ncapable of representing messages whose type is not known at compile time.\u003c/p\u003e\n\u003cp\u003eWe also observed that a frequent source of problems was that the\n\u003ca href=\"https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#Message\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.Message\u003c/code\u003e\u003c/a\u003e\ninterface, which identifies values of generated message types, does very\nlittle to describe the behavior of those types. When users create types\nthat implement that interface (often inadvertently by embedding a message\nin another struct) and pass values of those types to functions expecting\na generated message value, programs crash or behave unpredictably.\u003c/p\u003e\n\u003cp\u003eAll three of these problems have a common cause, and a common solution:\nThe \u003ccode\u003eMessage\u003c/code\u003e interface should fully specify the behavior of a message,\nand functions operating on \u003ccode\u003eMessage\u003c/code\u003e values should freely accept any\ntype that correctly implements the interface.\u003c/p\u003e\n\u003cp\u003eSince it is not possible to change the existing definition of the\n\u003ccode\u003eMessage\u003c/code\u003e type while keeping the package API compatible, we decided that\nit was time to begin work on a new, incompatible major version of the\nprotobuf module.\u003c/p\u003e\n\u003cp\u003eToday, we’re pleased to release that new module. We hope you like it.\u003c/p\u003e\n\u003ch2 id=\"reflection\"\u003eReflection\u003c/h2\u003e\n\u003cp\u003eReflection is the flagship feature of the new implementation. Similar\nto how the \u003ccode\u003ereflect\u003c/code\u003e package provides a view of Go types and values, the\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf/reflect/protoreflect\u003c/code\u003e\u003c/a\u003e\npackage provides a view of values according to the protocol buffer\ntype system.\u003c/p\u003e\n\u003cp\u003eA complete description of the \u003ccode\u003eprotoreflect\u003c/code\u003e package would run too long\nfor this post, but let’s look at how we might write the log-scrubbing\nfunction we mentioned previously.\u003c/p\u003e\n\u003cp\u003eFirst, we’ll write a \u003ccode\u003e.proto\u003c/code\u003e file defining an extension of the\n\u003ca href=\"https://github.com/protocolbuffers/protobuf/blob/b96241b1b716781f5bc4dc25e1ebb0003dfaba6a/src/google/protobuf/descriptor.proto#L509\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.protobuf.FieldOptions\u003c/code\u003e\u003c/a\u003e\ntype so we can annotate fields as containing\nsensitive information or not.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esyntax = \u0026#34;proto3\u0026#34;;\nimport \u0026#34;google/protobuf/descriptor.proto\u0026#34;;\npackage golang.example.policy;\nextend google.protobuf.FieldOptions {\n    bool non_sensitive = 50000;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can use this option to mark certain fields as non-sensitive.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emessage MyMessage {\n    string public_name = 1 [(golang.example.policy.non_sensitive) = true];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, we will write a Go function which accepts an arbitrary message\nvalue and removes all the sensitive fields.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Redact clears every sensitive field in pb.\nfunc Redact(pb proto.Message) {\n   // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function accepts a\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#Message\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.Message\u003c/code\u003e\u003c/a\u003e,\nan interface type implemented by all generated message types. This type\nis an alias for one defined in the \u003ccode\u003eprotoreflect\u003c/code\u003e package:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype ProtoMessage interface{\n    ProtoReflect() Message\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo avoid filling up the namespace of generated\nmessages, the interface contains only a single method returning a\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotoreflect.Message\u003c/code\u003e\u003c/a\u003e,\nwhich provides access to the message contents.\u003c/p\u003e\n\u003cp\u003e(Why an alias? Because \u003ccode\u003eprotoreflect.Message\u003c/code\u003e has a corresponding\nmethod returning the original \u003ccode\u003eproto.Message\u003c/code\u003e, and we need to avoid an\nimport cycle between the two packages.)\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Message.Range\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotoreflect.Message.Range\u003c/code\u003e\u003c/a\u003e\nmethod calls a function for every populated field in a message.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em := pb.ProtoReflect()\nm.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {\n    // ...\n    return true\n})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe range function is called with a\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#FieldDescriptor\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotoreflect.FieldDescriptor\u003c/code\u003e\u003c/a\u003e\ndescribing the protocol buffer type of the field, and a\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Value\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotoreflect.Value\u003c/code\u003e\u003c/a\u003e\ncontaining the field value.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/reflect/protoreflect?tab=doc#Descriptor.Options\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eprotoreflect.FieldDescriptor.Options\u003c/code\u003e\u003c/a\u003e\nmethod returns the field options as a \u003ccode\u003egoogle.protobuf.FieldOptions\u003c/code\u003e\nmessage.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eopts := fd.Options().(*descriptorpb.FieldOptions)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Why the type assertion? Since the generated \u003ccode\u003edescriptorpb\u003c/code\u003e package\ndepends on \u003ccode\u003eprotoreflect\u003c/code\u003e, the \u003ccode\u003eprotoreflect\u003c/code\u003e package can’t return the\nconcrete options type without causing an import cycle.)\u003c/p\u003e\n\u003cp\u003eWe can then check the options to see the value of our extension boolean:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif proto.GetExtension(opts, policypb.E_NonSensitive).(bool) {\n    return true // don\u0026#39;t redact non-sensitive fields\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that we are looking at the field \u003cem\u003edescriptor\u003c/em\u003e here, not the field\n\u003cem\u003evalue\u003c/em\u003e. The information we’re interested in lies in the protocol\nbuffer type system, not the Go one.\u003c/p\u003e\n\u003cp\u003eThis is also an example of an area where we\nhave simplified the \u003ccode\u003eproto\u003c/code\u003e package API. The original\n\u003ca href=\"https://pkg.go.dev/github.com/golang/protobuf/proto?tab=doc#GetExtension\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.GetExtension\u003c/code\u003e\u003c/a\u003e\nreturned both a value and an error. The new\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/proto?tab=doc#GetExtension\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eproto.GetExtension\u003c/code\u003e\u003c/a\u003e\nreturns just a value, returning the default value for the field if it is\nnot present. Extension decoding errors are reported at \u003ccode\u003eUnmarshal\u003c/code\u003e time.\u003c/p\u003e\n\u003cp\u003eOnce we have identified a field that needs redaction, clearing it is simple:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em.Clear(fd)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePutting all the above together, our complete redaction function is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Redact clears every sensitive field in pb.\nfunc Redact(pb proto.Message) {\n    m := pb.ProtoReflect()\n    m.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {\n        opts := fd.Options().(*descriptorpb.FieldOptions)\n        if proto.GetExtension(opts, policypb.E_NonSensitive).(bool) {\n            return true\n        }\n        m.Clear(fd)\n        return true\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA more complete implementation might recursively descend into\nmessage-valued fields. We hope that this simple example gives a\ntaste of protocol buffer reflection and its uses.\u003c/p\u003e\n\u003ch2 id=\"versions\"\u003eVersions\u003c/h2\u003e\n\u003cp\u003eWe call the original version of Go protocol buffers APIv1, and the\nnew one APIv2. Because APIv2 is not backwards compatible with APIv1,\nwe need to use different module paths for each.\u003c/p\u003e\n\u003cp\u003e(These API versions are not the same as the versions of the protocol\nbuffer language: \u003ccode\u003eproto1\u003c/code\u003e, \u003ccode\u003eproto2\u003c/code\u003e, and \u003ccode\u003eproto3\u003c/code\u003e. APIv1 and APIv2\nare concrete implementations in Go that both support the \u003ccode\u003eproto2\u003c/code\u003e and\n\u003ccode\u003eproto3\u003c/code\u003e language versions.)\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/github.com/golang/protobuf?tab=overview\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egithub.com/golang/protobuf\u003c/code\u003e\u003c/a\u003e\nmodule is APIv1.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf?tab=overview\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf\u003c/code\u003e\u003c/a\u003e\nmodule is APIv2. We have taken advantage of the need to change the\nimport path to switch to one that is not tied to a specific hosting\nprovider. (We considered \u003ccode\u003egoogle.golang.org/protobuf/v2\u003c/code\u003e, to make it\nclear that this is the second major version of the API, but settled on\nthe shorter path as being the better choice in the long term.)\u003c/p\u003e\n\u003cp\u003eWe know that not all users will move to a new major version of a package\nat the same rate. Some will switch quickly; others may remain on the old\nversion indefinitely. Even within a single program, some parts may use\none API while others use another. It is essential, therefore, that we\ncontinue to support programs that use APIv1.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egithub.com/golang/protobuf@v1.3.4\u003c/code\u003e is the most recent pre-APIv2 version of APIv1.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egithub.com/golang/protobuf@v1.4.0\u003c/code\u003e is a version of APIv1 implemented in terms of APIv2.\nThe API is the same, but the underlying implementation is backed by the new one.\nThis version contains functions to convert between the APIv1 and APIv2 \u003ccode\u003eproto.Message\u003c/code\u003e\ninterfaces to ease the transition between the two.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003egoogle.golang.org/protobuf@v1.20.0\u003c/code\u003e is APIv2.\nThis module depends upon \u003ccode\u003egithub.com/golang/protobuf@v1.4.0\u003c/code\u003e,\nso any program which uses APIv2 will automatically pick a version of APIv1\nwhich integrates with it.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e(Why start at version \u003ccode\u003ev1.20.0\u003c/code\u003e? To provide clarity.\nWe do not anticipate APIv1 to ever reach \u003ccode\u003ev1.20.0\u003c/code\u003e,\nso the version number alone should be enough to unambiguously differentiate\nbetween APIv1 and APIv2.)\u003c/p\u003e\n\u003cp\u003eWe intend to maintain support for APIv1 indefinitely.\u003c/p\u003e\n\u003cp\u003eThis organization ensures that any given program will use only a single\nprotocol buffer implementation, regardless of which API version it uses.\nIt permits programs to adopt the new API gradually, or not at all, while\nstill gaining the advantages of the new implementation. The principle of\nminimum version selection means that programs may remain on the old\nimplementation until the maintainers choose to update to the new one\n(either directly, or by updating a dependency).\u003c/p\u003e\n\u003ch2 id=\"additional-features-of-note\"\u003eAdditional features of note\u003c/h2\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/encoding/protojson\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf/encoding/protojson\u003c/code\u003e\u003c/a\u003e\npackage converts protocol buffer messages to and from JSON using the\n\u003ca href=\"https://developers.google.com/protocol-buffers/docs/proto3#json\" rel=\"noreferrer\" target=\"_blank\"\u003ecanonical JSON mapping\u003c/a\u003e,\nand fixes a number of issues with the old \u003ccode\u003ejsonpb\u003c/code\u003e package\nthat were difficult to change without causing problems for existing users.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/types/dynamicpb\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf/types/dynamicpb\u003c/code\u003e\u003c/a\u003e\npackage provides an implementation of \u003ccode\u003eproto.Message\u003c/code\u003e for messages whose\nprotocol buffer type is derived at runtime.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf/testing/protocmp\u003c/code\u003e\u003c/a\u003e\npackage provides functions to compare protocol buffer messages with the\n\u003ca href=\"https://pkg.go.dev/github.com/google/go-cmp/cmp\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egithub.com/google/cmp\u003c/code\u003e\u003c/a\u003e\npackage.\u003c/p\u003e\n\u003cp\u003eThe\n\u003ca href=\"https://pkg.go.dev/google.golang.org/protobuf/compiler/protogen?tab=doc\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egoogle.golang.org/protobuf/compiler/protogen\u003c/code\u003e\u003c/a\u003e\npackage provides support for writing protocol compiler plugins.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003egoogle.golang.org/protobuf\u003c/code\u003e module is a major overhaul of\nGo’s support for protocol buffers, providing first-class support\nfor reflection, custom message implementations, and a cleaned up API\nsurface. We intend to maintain the previous API indefinitely as a wrapper\nof the new one, allowing users to adopt the new API incrementally at\ntheir own pace.\u003c/p\u003e\n\u003cp\u003eOur goal in this update is to improve upon the benefits of the old\nAPI while addressing its shortcomings. As we completed each component of\nthe new implementation, we put it into use within Google’s codebase. This\nincremental rollout has given us confidence in both the usability of the new\nAPI and the performance and correctness of the new implementation. We believe\nit is production ready.\u003c/p\u003e\n\u003cp\u003eWe are excited about this release and hope that it will serve the Go\necosystem for the next ten years and beyond!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-03-02T00:00:00Z",
  "Author": "Joe Tsai, Damien Neil,  and Herbie Ong"
}