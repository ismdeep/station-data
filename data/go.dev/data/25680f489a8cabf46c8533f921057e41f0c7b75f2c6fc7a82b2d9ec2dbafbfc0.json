{
  "Source": "go.dev",
  "Title": "JSON and Go",
  "Link": "https://go.dev/blog/json",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/json\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eJSON and Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      25 January 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eJSON (JavaScript Object Notation) is a simple data interchange format.\nSyntactically it resembles the objects and lists of JavaScript.\nIt is most commonly used for communication between web back-ends and JavaScript\nprograms running in the browser,\nbut it is used in many other places, too.\nIts home page, \u003ca href=\"http://json.org\" rel=\"noreferrer\" target=\"_blank\"\u003ejson.org\u003c/a\u003e,\nprovides a wonderfully clear and concise definition of the standard.\u003c/p\u003e\n\u003cp\u003eWith the \u003ca href=\"/pkg/encoding/json/\"\u003ejson package\u003c/a\u003e it’s a\nsnap to read and write JSON data from your Go programs.\u003c/p\u003e\n\u003ch2 id=\"encoding\"\u003eEncoding\u003c/h2\u003e\n\u003cp\u003eTo encode JSON data we use the \u003ca href=\"/pkg/encoding/json/#Marshal\"\u003e\u003ccode\u003eMarshal\u003c/code\u003e\u003c/a\u003e function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Marshal(v interface{}) ([]byte, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGiven the Go data structure, \u003ccode\u003eMessage\u003c/code\u003e,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Message struct {\n    Name string\n    Body string\n    Time int64\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand an instance of \u003ccode\u003eMessage\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em := Message{\u0026#34;Alice\u0026#34;, \u0026#34;Hello\u0026#34;, 1294706395881547000}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe can marshal a JSON-encoded version of m using \u003ccode\u003ejson.Marshal\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb, err := json.Marshal(m)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf all is well, \u003ccode\u003eerr\u003c/code\u003e will be \u003ccode\u003enil\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e will be a \u003ccode\u003e[]byte\u003c/code\u003e containing this JSON data:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb == []byte(`{\u0026#34;Name\u0026#34;:\u0026#34;Alice\u0026#34;,\u0026#34;Body\u0026#34;:\u0026#34;Hello\u0026#34;,\u0026#34;Time\u0026#34;:1294706395881547000}`)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly data structures that can be represented as valid JSON will be encoded:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eJSON objects only support strings as keys;\nto encode a Go map type it must be of the form \u003ccode\u003emap[string]T\u003c/code\u003e (where \u003ccode\u003eT\u003c/code\u003e\nis any Go type supported by the json package).\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChannel, complex, and function types cannot be encoded.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eCyclic data structures are not supported; they will cause \u003ccode\u003eMarshal\u003c/code\u003e to go into an infinite loop.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePointers will be encoded as the values they point to (or ’null’ if the pointer is \u003ccode\u003enil\u003c/code\u003e).\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe json package only accesses the exported fields of struct types (those\nthat begin with an uppercase letter).\nTherefore only the exported fields of a struct will be present in the JSON output.\u003c/p\u003e\n\u003ch2 id=\"decoding\"\u003eDecoding\u003c/h2\u003e\n\u003cp\u003eTo decode JSON data we use the \u003ca href=\"/pkg/encoding/json/#Unmarshal\"\u003e\u003ccode\u003eUnmarshal\u003c/code\u003e\u003c/a\u003e function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Unmarshal(data []byte, v interface{}) error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe must first create a place where the decoded data will be stored\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar m Message\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand call \u003ccode\u003ejson.Unmarshal\u003c/code\u003e, passing it a \u003ccode\u003e[]byte\u003c/code\u003e of JSON data and a pointer to \u003ccode\u003em\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eerr := json.Unmarshal(b, \u0026amp;m)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003eb\u003c/code\u003e contains valid JSON that fits in \u003ccode\u003em\u003c/code\u003e,\nafter the call \u003ccode\u003eerr\u003c/code\u003e will be \u003ccode\u003enil\u003c/code\u003e and the data from \u003ccode\u003eb\u003c/code\u003e will have been\nstored in the struct \u003ccode\u003em\u003c/code\u003e,\nas if by an assignment like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em = Message{\n    Name: \u0026#34;Alice\u0026#34;,\n    Body: \u0026#34;Hello\u0026#34;,\n    Time: 1294706395881547000,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHow does \u003ccode\u003eUnmarshal\u003c/code\u003e identify the fields in which to store the decoded data?\nFor a given JSON key \u003ccode\u003e\u0026#34;Foo\u0026#34;\u003c/code\u003e,\n\u003ccode\u003eUnmarshal\u003c/code\u003e will look through the destination struct’s fields to find (in\norder of preference):\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAn exported field with a tag of \u003ccode\u003e\u0026#34;Foo\u0026#34;\u003c/code\u003e (see the \u003ca href=\"/ref/spec#Struct_types\"\u003eGo spec\u003c/a\u003e\nfor more on struct tags),\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAn exported field named \u003ccode\u003e\u0026#34;Foo\u0026#34;\u003c/code\u003e, or\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAn exported field named \u003ccode\u003e\u0026#34;FOO\u0026#34;\u003c/code\u003e or \u003ccode\u003e\u0026#34;FoO\u0026#34;\u003c/code\u003e or some other case-insensitive match of \u003ccode\u003e\u0026#34;Foo\u0026#34;\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWhat happens when the structure of the JSON data doesn’t exactly match the Go type?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := []byte(`{\u0026#34;Name\u0026#34;:\u0026#34;Bob\u0026#34;,\u0026#34;Food\u0026#34;:\u0026#34;Pickle\u0026#34;}`)\nvar m Message\nerr := json.Unmarshal(b, \u0026amp;m)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eUnmarshal\u003c/code\u003e will decode only the fields that it can find in the destination type.\nIn this case, only the Name field of m will be populated,\nand the Food field will be ignored.\nThis behavior is particularly useful when you wish to pick only a few specific\nfields out of a large JSON blob.\nIt also means that any unexported fields in the destination struct will\nbe unaffected by \u003ccode\u003eUnmarshal\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBut what if you don’t know the structure of your JSON data beforehand?\u003c/p\u003e\n\u003ch2 id=\"generic-json-with-interface\"\u003eGeneric JSON with interface\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003einterface{}\u003c/code\u003e (empty interface) type describes an interface with zero methods.\nEvery Go type implements at least zero methods and therefore satisfies the empty interface.\u003c/p\u003e\n\u003cp\u003eThe empty interface serves as a general container type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar i interface{}\ni = \u0026#34;a string\u0026#34;\ni = 2011\ni = 2.777\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA type assertion accesses the underlying concrete type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003er := i.(float64)\nfmt.Println(\u0026#34;the circle\u0026#39;s area\u0026#34;, math.Pi*r*r)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr, if the underlying type is unknown, a type switch determines the type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eswitch v := i.(type) {\ncase int:\n    fmt.Println(\u0026#34;twice i is\u0026#34;, v*2)\ncase float64:\n    fmt.Println(\u0026#34;the reciprocal of i is\u0026#34;, 1/v)\ncase string:\n    h := len(v) / 2\n    fmt.Println(\u0026#34;i swapped by halves is\u0026#34;, v[h:]+v[:h])\ndefault:\n    // i isn\u0026#39;t one of the types above\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe json package uses \u003ccode\u003emap[string]interface{}\u003c/code\u003e and\n\u003ccode\u003e[]interface{}\u003c/code\u003e values to store arbitrary JSON objects and arrays;\nit will happily unmarshal any valid JSON blob into a plain\n\u003ccode\u003einterface{}\u003c/code\u003e value.  The default concrete Go types are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ebool\u003c/code\u003e for JSON booleans,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003efloat64\u003c/code\u003e for JSON numbers,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003estring\u003c/code\u003e for JSON strings, and\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003enil\u003c/code\u003e for JSON null.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"decoding-arbitrary-data\"\u003eDecoding arbitrary data\u003c/h2\u003e\n\u003cp\u003eConsider this JSON data, stored in the variable \u003ccode\u003eb\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := []byte(`{\u0026#34;Name\u0026#34;:\u0026#34;Wednesday\u0026#34;,\u0026#34;Age\u0026#34;:6,\u0026#34;Parents\u0026#34;:[\u0026#34;Gomez\u0026#34;,\u0026#34;Morticia\u0026#34;]}`)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout knowing this data’s structure, we can decode it into an \u003ccode\u003einterface{}\u003c/code\u003e value with \u003ccode\u003eUnmarshal\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar f interface{}\nerr := json.Unmarshal(b, \u0026amp;f)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point the Go value in \u003ccode\u003ef\u003c/code\u003e would be a map whose keys are strings\nand whose values are themselves stored as empty interface values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef = map[string]interface{}{\n    \u0026#34;Name\u0026#34;: \u0026#34;Wednesday\u0026#34;,\n    \u0026#34;Age\u0026#34;:  6,\n    \u0026#34;Parents\u0026#34;: []interface{}{\n        \u0026#34;Gomez\u0026#34;,\n        \u0026#34;Morticia\u0026#34;,\n    },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo access this data we can use a type assertion to access \u003ccode\u003ef\u003c/code\u003e’s underlying \u003ccode\u003emap[string]interface{}\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em := f.(map[string]interface{})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can then iterate through the map with a range statement and use a type\nswitch to access its values as their concrete types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efor k, v := range m {\n    switch vv := v.(type) {\n    case string:\n        fmt.Println(k, \u0026#34;is string\u0026#34;, vv)\n    case float64:\n        fmt.Println(k, \u0026#34;is float64\u0026#34;, vv)\n    case []interface{}:\n        fmt.Println(k, \u0026#34;is an array:\u0026#34;)\n        for i, u := range vv {\n            fmt.Println(i, u)\n        }\n    default:\n        fmt.Println(k, \u0026#34;is of a type I don\u0026#39;t know how to handle\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this way you can work with unknown JSON data while still enjoying the benefits of type safety.\u003c/p\u003e\n\u003ch2 id=\"reference-types\"\u003eReference Types\u003c/h2\u003e\n\u003cp\u003eLet’s define a Go type to contain the data from the previous example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype FamilyMember struct {\n    Name    string\n    Age     int\n    Parents []string\n}\n\nvar m FamilyMember\nerr := json.Unmarshal(b, \u0026amp;m)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnmarshaling that data into a \u003ccode\u003eFamilyMember\u003c/code\u003e value works as expected,\nbut if we look closely we can see a remarkable thing has happened.\nWith the var statement we allocated a \u003ccode\u003eFamilyMember\u003c/code\u003e struct,\nand then provided a pointer to that value to \u003ccode\u003eUnmarshal\u003c/code\u003e,\nbut at that time the \u003ccode\u003eParents\u003c/code\u003e field was a \u003ccode\u003enil\u003c/code\u003e slice value.\nTo populate the \u003ccode\u003eParents\u003c/code\u003e field, \u003ccode\u003eUnmarshal\u003c/code\u003e allocated a new slice behind the scenes.\nThis is typical of how \u003ccode\u003eUnmarshal\u003c/code\u003e works with the supported reference types\n(pointers, slices, and maps).\u003c/p\u003e\n\u003cp\u003eConsider unmarshaling into this data structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Foo struct {\n    Bar *Bar\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf there were a \u003ccode\u003eBar\u003c/code\u003e field in the JSON object,\n\u003ccode\u003eUnmarshal\u003c/code\u003e would allocate a new \u003ccode\u003eBar\u003c/code\u003e and populate it.\nIf not, \u003ccode\u003eBar\u003c/code\u003e would be left as a \u003ccode\u003enil\u003c/code\u003e pointer.\u003c/p\u003e\n\u003cp\u003eFrom this a useful pattern arises: if you have an application that receives\na few distinct message types,\nyou might define “receiver” structure like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype IncomingMessage struct {\n    Cmd *Command\n    Msg *Message\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand the sending party can populate the \u003ccode\u003eCmd\u003c/code\u003e field and/or the \u003ccode\u003eMsg\u003c/code\u003e field\nof the top-level JSON object,\ndepending on the type of message they want to communicate.\n\u003ccode\u003eUnmarshal\u003c/code\u003e, when decoding the JSON into an \u003ccode\u003eIncomingMessage\u003c/code\u003e struct,\nwill only allocate the data structures present in the JSON data.\nTo know which messages to process, the programmer need simply test that\neither \u003ccode\u003eCmd\u003c/code\u003e or \u003ccode\u003eMsg\u003c/code\u003e is not \u003ccode\u003enil\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"streaming-encoders-and-decoders\"\u003eStreaming Encoders and Decoders\u003c/h2\u003e\n\u003cp\u003eThe json package provides \u003ccode\u003eDecoder\u003c/code\u003e and \u003ccode\u003eEncoder\u003c/code\u003e types to support the common\noperation of reading and writing streams of JSON data.\nThe \u003ccode\u003eNewDecoder\u003c/code\u003e and \u003ccode\u003eNewEncoder\u003c/code\u003e functions wrap the \u003ca href=\"/pkg/io/#Reader\"\u003e\u003ccode\u003eio.Reader\u003c/code\u003e\u003c/a\u003e\nand \u003ca href=\"/pkg/io/#Writer\"\u003e\u003ccode\u003eio.Writer\u003c/code\u003e\u003c/a\u003e interface types.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc NewDecoder(r io.Reader) *Decoder\nfunc NewEncoder(w io.Writer) *Encoder\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s an example program that reads a series of JSON objects from standard input,\nremoves all but the \u003ccode\u003eName\u003c/code\u003e field from each object,\nand then writes the objects to standard output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;encoding/json\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;os\u0026#34;\n)\n\nfunc main() {\n    dec := json.NewDecoder(os.Stdin)\n    enc := json.NewEncoder(os.Stdout)\n    for {\n        var v map[string]interface{}\n        if err := dec.Decode(\u0026amp;v); err != nil {\n            log.Println(err)\n            return\n        }\n        for k := range v {\n            if k != \u0026#34;Name\u0026#34; {\n                delete(v, k)\n            }\n        }\n        if err := enc.Encode(\u0026amp;v); err != nil {\n            log.Println(err)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDue to the ubiquity of Readers and Writers,\nthese \u003ccode\u003eEncoder\u003c/code\u003e and \u003ccode\u003eDecoder\u003c/code\u003e types can be used in a broad range of scenarios,\nsuch as reading and writing to HTTP connections,\nWebSockets, or files.\u003c/p\u003e\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\u003cp\u003eFor more information see the \u003ca href=\"/pkg/encoding/json/\"\u003ejson package documentation\u003c/a\u003e.\nFor an example usage of json see the source files of the \u003ca href=\"/pkg/net/rpc/jsonrpc/\"\u003ejsonrpc package\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-01-25T00:00:00Z",
  "Author": "Andrew Gerrand"
}