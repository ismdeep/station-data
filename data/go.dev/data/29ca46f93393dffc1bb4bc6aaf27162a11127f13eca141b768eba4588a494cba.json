{
  "Source": "go.dev",
  "Title": "A Proposal for Package Versioning in Go",
  "Link": "https://go.dev/blog/versioning-proposal",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/versioning-proposal\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eA Proposal for Package Versioning in Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      26 March 2018\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eEight years ago, the Go team introduced \u003ccode\u003egoinstall\u003c/code\u003e\n(which led to \u003ccode\u003ego get\u003c/code\u003e)\nand with it the decentralized, URL-like import paths\nthat Go developers are familiar with today.\nAfter we released \u003ccode\u003egoinstall\u003c/code\u003e, one of the first questions people asked\nwas how to incorporate version information.\nWe admitted we didn’t know.\nFor a long time, we believed that the problem of package versioning\nwould be best solved by an add-on tool,\nand we encouraged people to create one.\nThe Go community created many tools with different approaches.\nEach one helped us all better understand the problem,\nbut by mid-2016 it was clear that there were now too many solutions.\nWe needed to adopt a single, official tool.\u003c/p\u003e\n\u003cp\u003eAfter a community discussion started at GopherCon in July 2016 and continuing into the fall,\nwe all believed the answer would be to follow the package versioning approach\nexemplified by Rust’s Cargo, with tagged semantic versions,\na manifest, a lock file, and a\n\u003ca href=\"https://research.swtch.com/version-sat\" rel=\"noreferrer\" target=\"_blank\"\u003eSAT solver\u003c/a\u003e to decide which versions to use.\nSam Boyer led a team to create Dep, which followed this rough plan,\nand which we intended to serve as the model for \u003ccode\u003ego\u003c/code\u003e command integration.\nBut as we learned more about the implications of the Cargo/Dep approach,\nit became clear to me that Go would benefit from changing\nsome of the details, especially concerning backwards compatibility.\u003c/p\u003e\n\u003ch2 id=\"the-impact-of-compatibility\"\u003eThe Impact of Compatibility\u003c/h2\u003e\n\u003cp\u003eThe most important new feature of\n\u003ca href=\"/blog/preview-of-go-version-1\"\u003eGo 1\u003c/a\u003e\nwas not a language feature.\nIt was Go 1’s emphasis on backwards compatibility.\nUntil that point we’d issued stable release\nsnapshots approximately monthly,\neach with significant incompatible changes.\nWe observed significant acceleration in interest and adoption\nimmediately after the release of Go 1.\nWe believe that the\n\u003ca href=\"/doc/go1compat.html\"\u003epromise of compatibility\u003c/a\u003e\nmade developers feel much more comfortable relying on\nGo for production use\nand is a key reason that Go is popular today.\nSince 2013 the\n\u003ca href=\"/doc/faq#get_version\"\u003eGo FAQ\u003c/a\u003e\nhas encouraged package developers to provide their own\nusers with similar expectations of compatibility.\nWe call this the \u003cem\u003eimport compatibility rule\u003c/em\u003e:\n“If an old package and a new package have the same import path,\nthe new package must be backwards compatible with the old package.”\u003c/p\u003e\n\u003cp\u003eIndependently,\n\u003ca href=\"http://semver.org/\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic versioning\u003c/a\u003e\nhas become the \u003cem\u003ede facto\u003c/em\u003e\nstandard for describing software versions in many language communities,\nincluding the Go community.\nUsing semantic versioning, later versions are expected to be\nbackwards-compatible with earlier versions,\nbut only within a single major version:\nv1.2.3 must be compatible with v1.2.1 and v1.1.5,\nbut v2.3.4 need not be compatible with any of those.\u003c/p\u003e\n\u003cp\u003eIf we adopt semantic versioning for Go packages,\nas most Go developers expect,\nthen the import compatibility rule requires that\ndifferent major versions must use different import paths.\nThis observation led us to \u003cem\u003esemantic import versioning\u003c/em\u003e,\nin which versions starting at v2.0.0 include the major\nversion in the import path: \u003ccode\u003emy/thing/v2/sub/pkg\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA year ago I strongly believed that whether to include\nversion numbers in import paths was largely a matter of taste,\nand I was skeptical that having them was particularly elegant.\nBut the decision turns out to be a matter not of taste but of logic:\nimport compatibility and semantic versioning together require\nsemantic import versioning.\nWhen I realized this, the logical necessity surprised me.\u003c/p\u003e\n\u003cp\u003eI was also surprised to realize that\nthere is a second, independent logical route to\nsemantic import versioning:\n\u003ca href=\"/talks/2016/refactor.article\"\u003egradual code repair\u003c/a\u003e\nor partial code upgrades.\nIn a large program, it’s unrealistic to expect all packages in the program\nto update from v1 to v2 of a particular dependency at the same time.\nInstead, it must be possible for some of the program to keep using v1\nwhile other parts have upgraded to v2.\nBut then the program’s build, and the program’s final binary,\nmust include both v1 and v2 of the dependency.\nGiving them the same import path would lead to confusion,\nviolating what we might call the \u003cem\u003eimport uniqueness rule\u003c/em\u003e:\ndifferent packages must have different import paths.\nThe only way to have\npartial code upgrades, import uniqueness, \u003cem\u003eand\u003c/em\u003e semantic versioning\nis to adopt\nsemantic import versioning as well.\u003c/p\u003e\n\u003cp\u003eIt is of course possible to build systems that use semantic versioning\nwithout semantic import versioning,\nbut only by giving up either partial code upgrades or import uniqueness.\nCargo allows partial code upgrades by\ngiving up import uniqueness:\na given import path can have different meanings\nin different parts of a large build.\nDep ensures import uniqueness by\ngiving up partial code upgrades:\nall packages involved in a large build must find\na single agreed-upon version of a given dependency,\nraising the possibility that large programs will be unbuildable.\nCargo is right to insist on partial code upgrades,\nwhich are critical to large-scale software development.\nDep is equally right to insist on import uniqueness.\nComplex uses of Go’s current vendoring support can violate import uniqueness.\nWhen they have, the resulting problems have been quite challenging\nfor both developers and tools to understand.\nDeciding between partial code upgrades\nand import uniqueness\nrequires predicting which will hurt more to give up.\nSemantic import versioning lets us avoid the choice\nand keep both instead.\u003c/p\u003e\n\u003cp\u003eI was also surprised to discover how much\nimport compatibility simplifies version selection,\nwhich is the problem of deciding which package versions to use for a given build.\nThe constraints of Cargo and Dep make version selection\nequivalent to\n\u003ca href=\"https://research.swtch.com/version-sat\" rel=\"noreferrer\" target=\"_blank\"\u003esolving Boolean satisfiability\u003c/a\u003e,\nmeaning it can be very expensive to determine whether\na valid version configuration even exists.\nAnd then there may be many valid configurations,\nwith no clear criteria for choosing the “best” one.\nRelying on import compatibility can instead let Go use\na trivial, linear-time algorithm\nto find the single best configuration, which always exists.\nThis algorithm,\nwhich I call\n\u003ca href=\"https://research.swtch.com/vgo-mvs\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eminimal version selection\u003c/em\u003e\u003c/a\u003e,\nin turn eliminates the need for separate lock and manifest files.\nIt replaces them with a single, short configuration file,\nedited directly by both developers and tools,\nthat still supports reproducible builds.\u003c/p\u003e\n\u003cp\u003eOur experience with Dep demonstrates the impact of compatibility.\nFollowing the lead of Cargo and earlier systems,\nwe designed Dep to give up import compatibility\nas part of adopting semantic versioning.\nI don’t believe we decided this deliberately;\nwe just followed those other systems.\nThe first-hand experience of using Dep helped us\nbetter understand exactly how much complexity\nis created by permitting incompatible import paths.\nReviving the import compatibility rule\nby introducing semantic import versioning\neliminates that complexity,\nleading to a much simpler system.\u003c/p\u003e\n\u003ch2 id=\"progress-a-prototype-and-a-proposal\"\u003eProgress, a Prototype, and a Proposal\u003c/h2\u003e\n\u003cp\u003eDep was released in January 2017.\nIts basic model—code tagged with\nsemantic versions, along with a configuration file that\nspecified dependency requirements—was\na clear step forward from most of the Go vendoring tools,\nand converging on Dep itself was also a clear step forward.\nI wholeheartedly encouraged its adoption,\nespecially to help developers get used to thinking about Go package versions,\nboth for their own code and their dependencies.\nWhile Dep was clearly moving us in the right direction, I had lingering concerns\nabout the complexity devil in the details.\nI was particularly concerned about Dep\nlacking support for gradual code upgrades in large programs.\nOver the course of 2017, I talked to many people,\nincluding Sam Boyer and the rest of the\npackage management working group,\nbut none of us could see any clear way to reduce the complexity.\n(I did find many approaches that added to it.)\nApproaching the end of the year,\nit still seemed like SAT solvers and unsatisfiable builds\nmight be the best we could do.\u003c/p\u003e\n\u003cp\u003eIn mid-November, trying once again to work through\nhow Dep could support gradual code upgrades,\nI realized that our old advice about import compatibility\nimplied semantic import versioning.\nThat seemed like a real breakthrough.\nI wrote a first draft of what became my\n\u003ca href=\"https://research.swtch.com/vgo-import\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic import versioning\u003c/a\u003e\nblog post,\nconcluding it by suggesting that Dep adopt the convention.\nI sent the draft to the people I’d been talking to,\nand it elicited very strong responses:\neveryone loved it or hated it.\nI realized that I needed to work out more of the\nimplications of semantic import versioning\nbefore circulating the idea further,\nand I set out to do that.\u003c/p\u003e\n\u003cp\u003eIn mid-December, I discovered that import compatibility\nand semantic import versioning together allowed\ncutting version selection down to \u003ca href=\"https://research.swtch.com/vgo-mvs\" rel=\"noreferrer\" target=\"_blank\"\u003eminimal version selection\u003c/a\u003e.\nI wrote a basic implementation to be sure I understood it,\nI spent a while learning the theory behind why it was so simple,\nand I wrote a draft of the post describing it.\nEven so, I still wasn’t sure the approach would be practical\nin a real tool like Dep.\nIt was clear that a prototype was needed.\u003c/p\u003e\n\u003cp\u003eIn January, I started work on a simple \u003ccode\u003ego\u003c/code\u003e command wrapper\nthat implemented semantic import versioning\nand minimal version selection.\nTrivial tests worked well.\nApproaching the end of the month,\nmy simple wrapper could build Dep,\na real program that made use of many versioned packages.\nThe wrapper still had no command-line interface—the fact that\nit was building Dep was hard-coded in a few string constants—but\nthe approach was clearly viable.\u003c/p\u003e\n\u003cp\u003eI spent the first three weeks of February turning the\nwrapper into a full versioned \u003ccode\u003ego\u003c/code\u003e command, \u003ccode\u003evgo\u003c/code\u003e;\nwriting drafts of a\n\u003ca href=\"https://research.swtch.com/vgo\" rel=\"noreferrer\" target=\"_blank\"\u003eblog post series introducing \u003ccode\u003evgo\u003c/code\u003e\u003c/a\u003e;\nand discussing them with\nSam Boyer, the package management working group,\nand the Go team.\nAnd then I spent the last week of February finally\nsharing \u003ccode\u003evgo\u003c/code\u003e and the ideas behind it with the whole Go community.\u003c/p\u003e\n\u003cp\u003eIn addition to the core ideas of import compatibility,\nsemantic import versioning, and minimal version selection,\nthe \u003ccode\u003evgo\u003c/code\u003e prototype introduces a number of smaller\nbut significant changes motivated by eight years of\nexperience with \u003ccode\u003egoinstall\u003c/code\u003e and \u003ccode\u003ego get\u003c/code\u003e:\nthe new concept of a \u003ca href=\"https://research.swtch.com/vgo-module\" rel=\"noreferrer\" target=\"_blank\"\u003eGo module\u003c/a\u003e,\nwhich is a collection of packages versioned as a unit;\n\u003ca href=\"https://research.swtch.com/vgo-repro\" rel=\"noreferrer\" target=\"_blank\"\u003everifiable and verified builds\u003c/a\u003e;\nand\n\u003ca href=\"https://research.swtch.com/vgo-cmd\" rel=\"noreferrer\" target=\"_blank\"\u003eversion-awareness throughout the \u003ccode\u003ego\u003c/code\u003e command\u003c/a\u003e,\nenabling work outside \u003ccode\u003e$GOPATH\u003c/code\u003e\nand the elimination of (most) \u003ccode\u003evendor\u003c/code\u003e directories.\u003c/p\u003e\n\u003cp\u003eThe result of all of this is the \u003ca href=\"/design/24301-versioned-go\"\u003eofficial Go proposal\u003c/a\u003e,\nwhich I filed last week.\nEven though it might look like a complete implementation,\nit’s still just a prototype,\none that we will all need to work together to complete.\nYou can download and try the \u003ccode\u003evgo\u003c/code\u003e prototype from \u003ca href=\"https://golang.org/x/vgo\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/vgo\u003c/a\u003e,\nand you can read the\n\u003ca href=\"https://research.swtch.com/vgo-tour\" rel=\"noreferrer\" target=\"_blank\"\u003eTour of Versioned Go\u003c/a\u003e\nto get a sense of what using \u003ccode\u003evgo\u003c/code\u003e is like.\u003c/p\u003e\n\u003ch2 id=\"the-path-forward\"\u003eThe Path Forward\u003c/h2\u003e\n\u003cp\u003eThe proposal I filed last week is exactly that: an initial proposal.\nI know there are problems with it that the Go team and I can’t see,\nbecause Go developers use Go in many clever ways that we don’t know about.\nThe goal of the proposal feedback process is for us all to work together\nto identify and address the problems in the current proposal,\nto make sure that the final implementation that ships in a future\nGo release works well for as many developers as possible.\nPlease point out problems on the \u003ca href=\"/issue/24301\"\u003eproposal discussion issue\u003c/a\u003e.\nI will keep the\n\u003ca href=\"/issue/24301#issuecomment-371228742\"\u003ediscussion summary\u003c/a\u003e\nand\n\u003ca href=\"/issue/24301#issuecomment-371228664\"\u003eFAQ\u003c/a\u003e\nupdated as feedback arrives.\u003c/p\u003e\n\u003cp\u003eFor this proposal to succeed, the Go ecosystem as a\nwhole—and in particular today’s major Go projects—will need to\nadopt the import compatibility rule and semantic import versioning.\nTo make sure that can happen smoothly,\nwe will also be conducting user feedback sessions\nby video conference with projects that have questions about\nhow to incorporate the new versioning proposal into their code bases\nor have feedback about their experiences.\nIf you are interested in participating in such a session,\nplease email Steve Francia at spf@golang.org.\u003c/p\u003e\n\u003cp\u003eWe’re looking forward to (finally!) providing the Go community with a single, official answer\nto the question of how to incorporate package versioning into \u003ccode\u003ego get\u003c/code\u003e.\nThanks to everyone who helped us get this far, and to everyone who will help us going forward.\nWe hope that, with your help, we can ship something that Go developers will love.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2018-03-26T00:00:00Z",
  "Author": "Russ Cox"
}