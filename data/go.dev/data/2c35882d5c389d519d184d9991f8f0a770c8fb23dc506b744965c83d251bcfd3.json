{
  "Source": "go.dev",
  "Title": "Structured Logging with slog",
  "Link": "https://go.dev/blog/slog",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/slog\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eStructured Logging with slog\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jonathan Amsterdam\u003cbr/\u003e\n      22 August 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eThe new \u003ccode\u003elog/slog\u003c/code\u003e package in Go 1.21 brings structured logging to the standard\nlibrary. Structured logs use key-value pairs so they can be parsed, filtered,\nsearched, and analyzed quickly and reliably.\nFor servers, logging is an important way for developers to\nobserve the detailed behavior of the system, and often the first place they go\nto debug it. Logs therefore tend to be voluminous, and the ability to search and\nfilter them quickly is essential.\u003c/p\u003e\n\u003cp\u003eThe standard library has had a logging package, \u003ccode\u003elog\u003c/code\u003e,\nsince Go’s initial release over a decade ago.\nOver time,\nwe’ve learned that structured logging is important to Go programmers. It has\nconsistently ranked high in our annual survey, and many packages in the Go\necosystem provide it. Some of these are quite popular: one of the first structured\nlogging packages for Go, \u003ca href=\"https://pkg.go.dev/github.com/sirupsen/logrus\" rel=\"noreferrer\" target=\"_blank\"\u003elogrus\u003c/a\u003e,\nis used in over 100,000 other packages.\u003c/p\u003e\n\u003cp\u003eWith many structured logging packages to choose from, large programs\nwill often end up including more than one through their dependencies. The main program\nmight have to configure each of these logging packages so that the log output is\nconsistent: it all goes to the same place, in the same format. By including\nstructured logging in the standard library, we can provide a common framework\nthat all the other structured logging packages can share.\u003c/p\u003e\n\u003ch2 id=\"a-tour-of-slog\"\u003eA tour of \u003ccode\u003eslog\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eHere is the simplest program that uses \u003ccode\u003eslog\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;log/slog\u0026#34;\n\nfunc main() {\n    slog.Info(\u0026#34;hello, world\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs of this writing, it prints:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e2023/08/04 16:09:19 INFO hello, world\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eInfo\u003c/code\u003e function prints a message at the Info log level using the\ndefault logger, which in this case is the default logger from the \u003ccode\u003elog\u003c/code\u003e\npackage—the same logger you get when you write \u003ccode\u003elog.Printf\u003c/code\u003e.\nThat explains why the output looks so similar: only the “INFO” is new.\nOut of the box, \u003ccode\u003eslog\u003c/code\u003e and the original \u003ccode\u003elog\u003c/code\u003e package work together to make it\neasy to get started.\u003c/p\u003e\n\u003cp\u003eBesides \u003ccode\u003eInfo\u003c/code\u003e, there are functions for three other levels—\u003ccode\u003eDebug\u003c/code\u003e, \u003ccode\u003eWarn\u003c/code\u003e, and\n\u003ccode\u003eError\u003c/code\u003e—as well as a more general \u003ccode\u003eLog\u003c/code\u003e function that takes the level as an\nargument. In \u003ccode\u003eslog\u003c/code\u003e, levels are just integers, so you aren’t limited to the four\nnamed levels. For example, \u003ccode\u003eInfo\u003c/code\u003e is zero and \u003ccode\u003eWarn\u003c/code\u003e is 4, so if your logging system\nhas a level in between those, you can use 2 for it.\u003c/p\u003e\n\u003cp\u003eUnlike with the \u003ccode\u003elog\u003c/code\u003e package, we can easily add key-value pairs to our output\nby writing them after the message:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslog.Info(\u0026#34;hello, world\u0026#34;, \u0026#34;user\u0026#34;, os.Getenv(\u0026#34;USER\u0026#34;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output now looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e2023/08/04 16:27:19 INFO hello, world user=jba\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs we mentioned, \u003ccode\u003eslog\u003c/code\u003e’s top-level functions use the default logger.\nWe can get this logger explicitly, and call its methods:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogger := slog.Default()\nlogger.Info(\u0026#34;hello, world\u0026#34;, \u0026#34;user\u0026#34;, os.Getenv(\u0026#34;USER\u0026#34;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery top-level function corresponds to a method on a \u003ccode\u003eslog.Logger\u003c/code\u003e.\nThe output is the same as before.\u003c/p\u003e\n\u003cp\u003eInitially, slog’s output goes through the default \u003ccode\u003elog.Logger\u003c/code\u003e, producing the\noutput we’ve seen above.\nWe can change the output by changing the \u003cem\u003ehandler\u003c/em\u003e used by the logger.\n\u003ccode\u003eslog\u003c/code\u003e comes with two built-in handlers.\nA \u003ccode\u003eTextHandler\u003c/code\u003e emits all log information in the form \u003ccode\u003ekey=value\u003c/code\u003e.\nThis program creates a new logger using a \u003ccode\u003eTextHandler\u003c/code\u003e and\nmakes the same call to the \u003ccode\u003eInfo\u003c/code\u003e method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogger := slog.New(slog.NewTextHandler(os.Stdout, nil))\nlogger.Info(\u0026#34;hello, world\u0026#34;, \u0026#34;user\u0026#34;, os.Getenv(\u0026#34;USER\u0026#34;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow the output looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etime=2023-08-04T16:56:03.786-04:00 level=INFO msg=\u0026#34;hello, world\u0026#34; user=jba\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEverything has been turned into a key-value pair, with strings quoted as needed to preserve structure.\u003c/p\u003e\n\u003cp\u003eFor JSON output, install the built-in \u003ccode\u003eJSONHandler\u003c/code\u003e instead:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elogger := slog.New(slog.NewJSONHandler(os.Stdout, nil))\nlogger.Info(\u0026#34;hello, world\u0026#34;, \u0026#34;user\u0026#34;, os.Getenv(\u0026#34;USER\u0026#34;))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow our output is a sequence of JSON objects, one per logging call:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\u0026#34;time\u0026#34;:\u0026#34;2023-08-04T16:58:02.939245411-04:00\u0026#34;,\u0026#34;level\u0026#34;:\u0026#34;INFO\u0026#34;,\u0026#34;msg\u0026#34;:\u0026#34;hello, world\u0026#34;,\u0026#34;user\u0026#34;:\u0026#34;jba\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou are not limited to the built-in handlers. Anyone can write a handler by\nimplementing the \u003ccode\u003eslog.Handler\u003c/code\u003e interface. A handler can generate output in a\nparticular format, or it can wrap another handler to add functionality.\nOne of the\n\u003ca href=\"https://pkg.go.dev/log/slog@master#example-Handler-LevelHandler\" rel=\"noreferrer\" target=\"_blank\"\u003eexamples\u003c/a\u003e in\nthe \u003ccode\u003eslog\u003c/code\u003e documentation shows how to write a wrapping handler that changes the minimum\nlevel at which log messages will be displayed.\u003c/p\u003e\n\u003cp\u003eThe alternating key-value syntax for attributes that we’ve been using so far is convenient, but for frequently executed log statements it may be more efficient to use the \u003ccode\u003eAttr\u003c/code\u003e type and call the \u003ccode\u003eLogAttrs\u003c/code\u003e method.\nThese work together to minimize memory allocations.\nThere are functions for building \u003ccode\u003eAttr\u003c/code\u003es out of strings, numbers, and other common\ntypes. This call to \u003ccode\u003eLogAttrs\u003c/code\u003e produces the same output as above, but does it faster:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslog.LogAttrs(context.Background(), slog.LevelInfo, \u0026#34;hello, world\u0026#34;,\n    slog.String(\u0026#34;user\u0026#34;, os.Getenv(\u0026#34;USER\u0026#34;)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is a lot more to \u003ccode\u003eslog\u003c/code\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAs the call to \u003ccode\u003eLogAttrs\u003c/code\u003e shows, you can pass a \u003ccode\u003econtext.Context\u003c/code\u003e to some log functions\nso a handler can extract context information like trace IDs. (Canceling the context does not prevent the log entry from being written.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can call \u003ccode\u003eLogger.With\u003c/code\u003e to add attributes to a logger that will appear in\nall of its output, effectively factoring out the common parts of several log\nstatements. This is not only convenient, but it can also help performance, as discussed below.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAttributes can be combined into groups. This can add more structure to your\nlog output and can help to disambiguate keys that would otherwise be identical.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eYou can control how a value appears in the logs by providing its type with a \u003ccode\u003eLogValue\u003c/code\u003e\nmethod. That can be used to \u003ca href=\"https://pkg.go.dev/log/slog@master#example-LogValuer-Group\" rel=\"noreferrer\" target=\"_blank\"\u003elog the fields of a struct as a\ngroup\u003c/a\u003e or \u003ca href=\"https://pkg.go.dev/log/slog@master#example-LogValuer-Secret\" rel=\"noreferrer\" target=\"_blank\"\u003eredact\nsensitive data\u003c/a\u003e,\namong other things.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe best place to learn about all of \u003ccode\u003eslog\u003c/code\u003e is the \u003ca href=\"https://pkg.go.dev/log/slog\" rel=\"noreferrer\" target=\"_blank\"\u003epackage\ndocumentation\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\n\u003cp\u003eWe wanted \u003ccode\u003eslog\u003c/code\u003e to be fast.\nFor large-scale performance gains, we designed \u003ca href=\"https://pkg.go.dev/log/slog#Handler\" rel=\"noreferrer\" target=\"_blank\"\u003ethe \u003ccode\u003eHandler\u003c/code\u003e\ninterface\u003c/a\u003e to provide optimization\nopportunities. The \u003ccode\u003eEnabled\u003c/code\u003e method is called at the beginning of every log\nevent, giving the handler a chance to drop unwanted log events quickly. The\n\u003ccode\u003eWithAttrs\u003c/code\u003e and \u003ccode\u003eWithGroup\u003c/code\u003e methods let the handler format\nattributes added by \u003ccode\u003eLogger.With\u003c/code\u003e once, rather than at each logging call. This\npre-formatting can provide a significant speedup when large attributes, like an\n\u003ccode\u003ehttp.Request\u003c/code\u003e, are added to a \u003ccode\u003eLogger\u003c/code\u003e and then used in many logging calls.\u003c/p\u003e\n\u003cp\u003eTo inform our performance optimization work, we investigated typical patterns of logging in existing open-source projects. We found that over 95%\nof calls to logging methods pass five or fewer attributes. We also categorized\nthe types of attributes, finding that a handful of common types accounted for\nthe majority.\nWe then wrote benchmarks that captured the common cases, and used them as a\nguide to see where the time went.\nThe greatest gains came from paying careful attention to memory allocation.\u003c/p\u003e\n\u003ch2 id=\"the-design-process\"\u003eThe design process\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eslog\u003c/code\u003e package is one of the largest additions to the standard library since\nGo 1 was released in 2012. We wanted to take our time designing it, and we knew\nthat community feedback would be essential.\u003c/p\u003e\n\u003cp\u003eBy April 2022, we had gathered enough data to demonstrate the importance of\nstructured logging to the Go community. The Go team decided to explore adding it\nto the standard library.\u003c/p\u003e\n\u003cp\u003eWe began by looking at how the existing structured logging packages were\ndesigned. We also took advantage of the large collection of open-source Go code\nstored on the Go module proxy to learn how these packages were actually used.\nOur first design was informed by this research as well as Go’s spirit of\nsimplicity.\nWe wanted an API that is light on the page and easy to understand, without\nsacrificing performance.\u003c/p\u003e\n\u003cp\u003eIt was never a goal to replace existing third-party logging packages.\nThey are all good at what they do, and replacing existing code that works well\nis rarely a good use of a developer’s time.\nWe divided the API into a frontend, \u003ccode\u003eLogger\u003c/code\u003e, that calls a backend interface, \u003ccode\u003eHandler\u003c/code\u003e.\nThat way, existing logging packages can talk to a common backend,\nso the packages that use them can interoperate without having to be rewritten.\nHandlers are written or in progress for many common logging\npackages, including\n\u003ca href=\"https://github.com/uber-go/zap/tree/master/exp/zapslog\" rel=\"noreferrer\" target=\"_blank\"\u003eZap\u003c/a\u003e,\n\u003ca href=\"https://github.com/go-logr/logr/pull/196\" rel=\"noreferrer\" target=\"_blank\"\u003elogr\u003c/a\u003e\nand \u003ca href=\"https://github.com/evanphx/go-hclog-slog\" rel=\"noreferrer\" target=\"_blank\"\u003ehclog\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe shared our initial design within the Go team and other developers who had\nextensive logging experience. We made alterations based on their feedback, and\nby August of 2022 we felt we had a workable design. On August 29,\nwe made our \u003ca href=\"https://github.com/golang/exp/tree/master/slog\" rel=\"noreferrer\" target=\"_blank\"\u003eexperimental\nimplementation\u003c/a\u003e public\nand began a \u003ca href=\"https://github.com/golang/go/discussions/54763\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub discussion\u003c/a\u003e to hear\nwhat the community had to say.\nThe response was enthusiastic and largely positive.\nThanks to insightful comments from the designers and users of other structured\nlogging packages, we made several changes and added a few features, like groups\nand the \u003ccode\u003eLogValuer\u003c/code\u003e interface. We changed the mapping from log levels to\nintegers twice.\u003c/p\u003e\n\u003cp\u003eAfter two months and about 300 comments, we felt we were ready for an actual\n\u003ca href=\"/issue/56345\"\u003eproposal\u003c/a\u003e and accompanying \u003ca href=\"https://go.googlesource.com/proposal/+/03441cb358c7b27a8443bca839e5d7a314677ea6/design/56345-structured-logging.md\" rel=\"noreferrer\" target=\"_blank\"\u003edesign\ndoc\u003c/a\u003e.\nThe proposal issue garnered over 800 comments and resulted in many improvements to\nthe API and the implementation. Here are two examples of API changes, both\nconcerning \u003ccode\u003econtext.Context\u003c/code\u003e:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eOriginally the API supported adding loggers to a\ncontext. Many felt that this was a convenient way to plumb a logger easily\nthrough levels of code that didn’t care about it. But others felt it was\nsmuggling in  an implicit dependency, making the code harder to understand.\nUltimately, we removed the feature as being too controversial.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe also wrestled\nwith the related question of passing a context to logging methods, trying a\nnumber of designs. We initially resisted the standard pattern of passing the\ncontext as the first argument because we didn’t want every logging call to\nrequire a context, but ultimately created two sets of logging methods, one\nwith a context and one without.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eOne change we did not make concerned the alternating key-and-value syntax for\nexpressing attributes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslog.Info(\u0026#34;message\u0026#34;, \u0026#34;k1\u0026#34;, v1, \u0026#34;k2\u0026#34;, v2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMany felt strongly that this was a bad idea. They found it hard to read\nand easy to get wrong by omitting a key or value. They preferred explicit\nattributes for expressing structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslog.Info(\u0026#34;message\u0026#34;, slog.Int(\u0026#34;k1\u0026#34;, v1), slog.String(\u0026#34;k2\u0026#34;, v2))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut we felt that the lighter syntax was important to keeping Go easy and fun to\nuse, especially for new Go programmers. We also knew that several Go logging\npackages, like \u003ccode\u003elogr\u003c/code\u003e, \u003ccode\u003ego-kit/log\u003c/code\u003e and \u003ccode\u003ezap\u003c/code\u003e (with its \u003ccode\u003eSugaredLogger\u003c/code\u003e)\nsuccessfully used alternating keys and\nvalues. We added a \u003ca href=\"https://pkg.go.dev/golang.org/x/tools/go/analysis/passes/slog\" rel=\"noreferrer\" target=\"_blank\"\u003evet\ncheck\u003c/a\u003e\nto catch common mistakes, but did not change the design.\u003c/p\u003e\n\u003cp\u003eOn March 15, 2023, the proposal was accepted, but there were still some minor\nunresolved issues. Over the next few weeks, ten additional changes were proposed\nand resolved. By early July, the \u003ccode\u003elog/slog\u003c/code\u003e package implementation was complete,\nalong with the \u003ccode\u003etesting/slogtest\u003c/code\u003e package for verifying\nhandlers and the vet check for correct usage of alternating keys and values.\u003c/p\u003e\n\u003cp\u003eAnd on August 8, Go 1.21 was released, and \u003ccode\u003eslog\u003c/code\u003e with it.\nWe hope you find it useful, and as fun to use as it was to build.\u003c/p\u003e\n\u003cp\u003eAnd a big thanks to everyone who participated in the discussion and the proposal\nprocess. Your contributions improved \u003ccode\u003eslog\u003c/code\u003e immensely.\u003c/p\u003e\n\u003ch2 id=\"resources\"\u003eResources\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://pkg.go.dev/log/slog\" rel=\"noreferrer\" target=\"_blank\"\u003edocumentation\u003c/a\u003e for the \u003ccode\u003elog/slog\u003c/code\u003e package\nexplains how to use it and provides several examples.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/wiki/Resources-for-slog\"\u003ewiki page\u003c/a\u003e has\nadditional resources provided by the Go community, including a variety of\nhandlers.\u003c/p\u003e\n\u003cp\u003eIf you want to write a handler, consult the\n\u003ca href=\"https://github.com/golang/example/blob/master/slog-handler-guide/README.md\" rel=\"noreferrer\" target=\"_blank\"\u003ehandler writing\nguide\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-08-22T00:00:00Z",
  "Author": "Jonathan Amsterdam"
}