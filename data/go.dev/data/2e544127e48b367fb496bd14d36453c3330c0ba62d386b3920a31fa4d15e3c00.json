{
  "Source": "go.dev",
  "Title": "Finding unreachable functions with deadcode",
  "Link": "https://go.dev/blog/deadcode",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/deadcode\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eFinding unreachable functions with deadcode\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Alan Donovan\u003cbr/\u003e\n      12 December 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eFunctions that are part of your project’s source code but can never be\nreached in any execution are called “dead code”, and they exert a drag\non codebase maintenance efforts.\nToday we’re pleased to share a tool named \u003ccode\u003edeadcode\u003c/code\u003e to help you identify them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go install golang.org/x/tools/cmd/deadcode@latest\n$ deadcode -help\nThe deadcode command reports unreachable functions in Go programs.\n\nUsage: deadcode [flags] package...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"example\"\u003eExample\u003c/h2\u003e\n\u003cp\u003eOver the last year or so, we’ve been making a lot of changes to the\nstructure of \u003ca href=\"/blog/gopls-scalability\"\u003egopls\u003c/a\u003e, the\nlanguage server for Go that powers VS Code and other editors.\nA typical change might rewrite some existing function, taking care to\nensure that its new behavior satisfies the needs of all existing callers.\nSometimes, after putting in all that effort, we would discover to our\nfrustration that one of the callers was never actually reached in any\nexecution, so it could safely have been been deleted.\nIf we had known this beforehand our refactoring task would have been\neasier.\u003c/p\u003e\n\u003cp\u003eThe simple Go program below illustrates the problem:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodule example.com/greet\ngo 1.21\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    var g Greeter\n    g = Helloer{}\n    g.Greet()\n}\n\ntype Greeter interface{ Greet() }\n\ntype Helloer struct{}\ntype Goodbyer struct{}\n\nvar _ Greeter = Helloer{}  // Helloer  implements Greeter\nvar _ Greeter = Goodbyer{} // Goodbyer implements Greeter\n\nfunc (Helloer) Greet()  { hello() }\nfunc (Goodbyer) Greet() { goodbye() }\n\nfunc hello()   { fmt.Println(\u0026#34;hello\u0026#34;) }\nfunc goodbye() { fmt.Println(\u0026#34;goodbye\u0026#34;) }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we execute it, it says hello:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go run .\nhello\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s clear from its output that this program executes the \u003ccode\u003ehello\u003c/code\u003e\nfunction but not the \u003ccode\u003egoodbye\u003c/code\u003e function.\nWhat’s less clear at a glance is that the \u003ccode\u003egoodbye\u003c/code\u003e function can\nnever be called.\nHowever, we can’t simply delete \u003ccode\u003egoodbye\u003c/code\u003e, because it’s required by the\n\u003ccode\u003eGoodbyer.Greet\u003c/code\u003e method, which in turn is required to implement the\n\u003ccode\u003eGreeter\u003c/code\u003e interface whose \u003ccode\u003eGreet\u003c/code\u003e method we can see is called from \u003ccode\u003emain\u003c/code\u003e.\nBut if we work forwards from main, we can see that no \u003ccode\u003eGoodbyer\u003c/code\u003e values\nare ever created, so the \u003ccode\u003eGreet\u003c/code\u003e call in \u003ccode\u003emain\u003c/code\u003e can only reach \u003ccode\u003eHelloer.Greet\u003c/code\u003e.\nThat’s the idea behind the algorithm used by the \u003ccode\u003edeadcode\u003c/code\u003e tool.\u003c/p\u003e\n\u003cp\u003eWhen we run deadcode on this program, the tool tells us that the\n\u003ccode\u003egoodbye\u003c/code\u003e function and the \u003ccode\u003eGoodbyer.Greet\u003c/code\u003e method are both unreachable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ deadcode .\ngreet.go:23: unreachable func: goodbye\ngreet.go:20: unreachable func: Goodbyer.Greet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this knowledge, we can safely remove both functions,\nalong with the \u003ccode\u003eGoodbyer\u003c/code\u003e type itself.\u003c/p\u003e\n\u003cp\u003eThe tool can also explain why the \u003ccode\u003ehello\u003c/code\u003e function is live. It responds\nwith a chain of function calls that reaches \u003ccode\u003ehello\u003c/code\u003e, starting from main:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ deadcode -whylive=example.com/greet.hello .\n                  example.com/greet.main\ndynamic@L0008 --\u0026gt; example.com/greet.Helloer.Greet\n static@L0019 --\u0026gt; example.com/greet.hello\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output is designed to be easy to read on a terminal, but you can\nuse the \u003ccode\u003e-json\u003c/code\u003e or \u003ccode\u003e-f=template\u003c/code\u003e flags to specify richer output formats for\nconsumption by other tools.\u003c/p\u003e\n\u003ch2 id=\"how-it-works\"\u003eHow it works\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003edeadcode\u003c/code\u003e command\n\u003ca href=\"https://pkg.go.dev/golang.org/x/tools/go/packages\" rel=\"noreferrer\" target=\"_blank\"\u003eloads\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/go/parser\" rel=\"noreferrer\" target=\"_blank\"\u003eparses\u003c/a\u003e,\nand \u003ca href=\"https://pkg.go.dev/go/types\" rel=\"noreferrer\" target=\"_blank\"\u003etype-checks\u003c/a\u003e the specified packages,\nthen converts them into an\n\u003ca href=\"https://pkg.go.dev/golang.org/x/tools/go/ssa\" rel=\"noreferrer\" target=\"_blank\"\u003eintermediate representation\u003c/a\u003e\nsimilar to a typical compiler.\u003c/p\u003e\n\u003cp\u003eIt then uses an algorithm called\n\u003ca href=\"https://pkg.go.dev/golang.org/x/tools/go/callgraph/rta\" rel=\"noreferrer\" target=\"_blank\"\u003eRapid Type Analysis\u003c/a\u003e (RTA)\nto build up the set of functions that are reachable,\nwhich is initially just the entry points of each \u003ccode\u003emain\u003c/code\u003e package:\nthe \u003ccode\u003emain\u003c/code\u003e function,\nand the package initializer function,\nwhich assigns global variables and calls functions named \u003ccode\u003einit\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eRTA looks at the statements in the body of each reachable function to\ngather three kinds of information: the set of functions it calls directly;\nthe set of dynamic calls it makes through interface methods;\nand the set of types it converts to an interface.\u003c/p\u003e\n\u003cp\u003eDirect function calls are easy: we just add the callee to the set of\nreachable functions, and if it’s the first time we’ve encountered the\ncallee, we inspect its function body the same way we did for main.\u003c/p\u003e\n\u003cp\u003eDynamic calls through interface methods are trickier, because we don’t\nknow the set of types that implement the interface. We don’t want\nto assume that every possible method in the program whose type matches\nis a possible target for the call, because some of those types may\nbe instantiated only from dead code! That’s why we gather the set of\ntypes converted to interfaces: the conversion makes each of these\ntypes reachable from \u003ccode\u003emain\u003c/code\u003e, so that its methods are now possible\ntargets of dynamic calls.\u003c/p\u003e\n\u003cp\u003eThis leads to a chicken-and-egg situation. As we encounter each new\nreachable function, we discover more interface method calls and more\nconversions of concrete types to interface types.\nBut as the cross product of these two sets (interface method calls ×\nconcrete types) grows ever larger, we discover new reachable\nfunctions.\nThis class of problems, called “dynamic programming”, can be solved by\n(conceptually) making checkmarks in a large two-dimensional table,\nadding rows and columns as we go, until there are no more checks to\nadd. The checkmarks in the final table tells us what is reachable;\nthe blank cells are the dead code.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003ccenter\u003e\n  \u003cimg src=\"deadcode-rta.svg\" alt=\"illustration of Rapid Type Analysis\"/\u003e\u003cbr/\u003e  \u003ci\u003e\n   The \u003ccode\u003emain\u003c/code\u003e function causes \u003ccode\u003eHelloer\u003c/code\u003e to be\n   instantiated, and the \u003ccode\u003eg.Greet\u003c/code\u003e call\u003cbr/\u003e\n   dispatches to the \u003ccode\u003eGreet\u003c/code\u003e method of each type instantiated so far.\n  \u003c/i\u003e\n\u003c/center\u003e\n\u003c/div\u003e\n\u003cp\u003eDynamic calls to (non-method) functions are treated similar to\ninterfaces of a single method.\nAnd calls made \u003ca href=\"https://pkg.go.dev/reflect#Value.Call\" rel=\"noreferrer\" target=\"_blank\"\u003eusing reflection\u003c/a\u003e\nare considered to reach any method of any type used in an interface\nconversion, or any type derivable from one using the \u003ccode\u003ereflect\u003c/code\u003e package.\nBut the principle is the same in all cases.\u003c/p\u003e\n\u003ch2 id=\"tests\"\u003eTests\u003c/h2\u003e\n\u003cp\u003eRTA is a whole-program analysis. That means it always starts from a\nmain function and works forward: you can’t start from a library\npackage such as \u003ccode\u003eencoding/json\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHowever, most library packages have tests, and tests have main\nfunctions. We don’t see them because they are generated behind the\nscenes of \u003ccode\u003ego test\u003c/code\u003e, but we can include them in the analysis using the\n\u003ccode\u003e-test\u003c/code\u003e flag.\u003c/p\u003e\n\u003cp\u003eIf this reports that a function in a library package is dead, that’s\na sign that your test coverage could be improved.\nFor example, this command lists all the functions in \u003ccode\u003eencoding/json\u003c/code\u003e\nthat are not reached by any of its tests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ deadcode -test -filter=encoding/json encoding/json\nencoding/json/decode.go:150:31: unreachable func: UnmarshalFieldError.Error\nencoding/json/encode.go:225:28: unreachable func: InvalidUTF8Error.Error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(The \u003ccode\u003e-filter\u003c/code\u003e flag restricts the output to packages matching the\nregular expression. By default, the tool reports all packages in the\ninitial module.)\u003c/p\u003e\n\u003ch2 id=\"soundness\"\u003eSoundness\u003c/h2\u003e\n\u003cp\u003eAll static analysis tools\n\u003ca href=\"https://en.wikipedia.org/wiki/Rice%27s_theorem\" rel=\"noreferrer\" target=\"_blank\"\u003enecessarily\u003c/a\u003e\nproduce imperfect approximations of the possible dynamic\nbehaviors of the target program.\nA tool’s assumptions and inferences may be “sound”, meaning\nconservative but perhaps overly cautious, or “unsound”, meaning\noptimistic but not always correct.\u003c/p\u003e\n\u003cp\u003eThe deadcode tool is no exception: it must approximate the set of\ntargets of dynamic calls through function and interface values or\nusing reflection.\nIn this respect, the tool is sound. In other words, if it reports a\nfunction as dead code, it means the function cannot be called even\nthrough these dynamic mechanisms. However the tool may fail to report\nsome functions that in fact can never be executed.\u003c/p\u003e\n\u003cp\u003eThe deadcode tool must also approximate the set of calls made from\nfunctions not written in Go, which it cannot see.\nIn this respect, the tool is not sound.\nIts analysis is not aware of functions called exclusively from\nassembly code, or of the aliasing of functions that arises from\nthe \u003ca href=\"https://pkg.go.dev/cmd/compile#hdr-Compiler_Directives\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ego:linkname\u003c/code\u003e directive\u003c/a\u003e.\nFortunately both of these features are rarely used outside the Go runtime.\u003c/p\u003e\n\u003ch2 id=\"try-it-out\"\u003eTry it out\u003c/h2\u003e\n\u003cp\u003eWe run \u003ccode\u003edeadcode\u003c/code\u003e periodically on our projects, especially after\nrefactoring work, to help identify parts of the program that are no\nlonger needed.\u003c/p\u003e\n\u003cp\u003eWith the dead code laid to rest, you can focus on eliminating code\nwhose time has come to an end but that stubbornly remains alive,\ncontinuing to drain your life force. We call such undead functions\n“vampire code”!\u003c/p\u003e\n\u003cp\u003ePlease try it out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go install golang.org/x/tools/cmd/deadcode@latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ve found it useful, and we hope you do too.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-12-12T00:00:00Z",
  "Author": "Alan Donovan"
}