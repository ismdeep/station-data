{
  "Source": "go.dev",
  "Title": "Compile-time Dependency Injection With Go Cloud's Wire",
  "Link": "https://go.dev/blog/wire",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/wire\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eCompile-time Dependency Injection With Go Cloud\u0026#39;s Wire\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert van Gent\u003cbr/\u003e\n      9 October 2018\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cp\u003eThe Go team recently \u003ca href=\"/blog/go-cloud\"\u003eannounced\u003c/a\u003e the\nopen source project \u003ca href=\"https://github.com/google/go-cloud\" rel=\"noreferrer\" target=\"_blank\"\u003eGo Cloud\u003c/a\u003e,\nwith portable Cloud APIs and tools for \u003ca href=\"https://cloud.google.com/open-cloud/\" rel=\"noreferrer\" target=\"_blank\"\u003eopen cloud\u003c/a\u003e development.\nThis post goes into more detail about Wire,\na dependency injection tool used in Go Cloud.\u003c/p\u003e\n\u003ch2 id=\"what-problem-does-wire-solve\"\u003eWhat problem does Wire solve?\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Dependency_injection\" rel=\"noreferrer\" target=\"_blank\"\u003eDependency injection\u003c/a\u003e\nis a standard technique for producing flexible and loosely coupled code,\nby explicitly providing components with all of the dependencies they need to work.\nIn Go, this often takes the form of passing dependencies to constructors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// NewUserStore returns a UserStore that uses cfg and db as dependencies.\nfunc NewUserStore(cfg *Config, db *mysql.DB) (*UserStore, error) {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis technique works great at small scale,\nbut larger applications can have a complex graph of dependencies,\nresulting in a big block of initialization code that’s order-dependent but\notherwise not very interesting.\nIt’s often hard to break up this code cleanly,\nespecially because some dependencies are used multiple times.\nReplacing one implementation of a service with another can be painful because\nit involves modifying the dependency graph by adding a whole new set of\ndependencies (and their dependencies…),\nand removing unused old ones.\nIn practice, making changes to initialization code in applications with\nlarge dependency graphs is tedious and slow.\u003c/p\u003e\n\u003cp\u003eDependency injection tools like Wire aim to simplify the management of initialization code.\nYou describe your services and their dependencies,\neither as code or as configuration, then Wire processes the resulting graph\nto figure out ordering and how to pass each service what it needs.\nMake changes to an application’s dependencies by changing a function signature\nor adding or removing an initializer,\nand then let Wire do the tedious work of generating initialization code\nfor the entire dependency graph.\u003c/p\u003e\n\u003ch2 id=\"why-is-this-part-of-go-cloud\"\u003eWhy is this part of Go Cloud?\u003c/h2\u003e\n\u003cp\u003eGo Cloud’s goal is to make it easier to write portable Cloud applications\nby providing idiomatic Go APIs for useful Cloud services.\nFor example, \u003ca href=\"https://godoc.org/github.com/google/go-cloud/blob\" rel=\"noreferrer\" target=\"_blank\"\u003eblob.Bucket\u003c/a\u003e\nprovides a storage API with implementations for Amazon’s S3 and Google Cloud Storage (GCS);\napplications written using \u003ccode\u003eblob.Bucket\u003c/code\u003e can swap implementations without\nchanging their application logic.\nHowever, the initialization code is inherently provider-specific,\nand each provider has a different set of dependencies.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ca href=\"https://godoc.org/github.com/google/go-cloud/blob/gcsblob#OpenBucket\" rel=\"noreferrer\" target=\"_blank\"\u003econstructing a GCS \u003ccode\u003eblob.Bucket\u003c/code\u003e\u003c/a\u003e\nrequires a \u003ccode\u003egcp.HTTPClient\u003c/code\u003e,\nwhich eventually requires \u003ccode\u003egoogle.Credentials\u003c/code\u003e,\nwhile \u003ca href=\"https://godoc.org/github.com/google/go-cloud/blob/s3blob\" rel=\"noreferrer\" target=\"_blank\"\u003econstructing one for S3\u003c/a\u003e\nrequires an \u003ccode\u003eaws.Config\u003c/code\u003e,\nwhich eventually requires AWS credentials.\nThus, updating an application to use a different \u003ccode\u003eblob.Bucket\u003c/code\u003e implementation\ninvolves exactly the kind of tedious update to the dependency graph that we described above.\nThe driving use case for Wire is to make it easy to swap implementations\nof Go Cloud portable APIs,\nbut it’s also a general-purpose tool for dependency injection.\u003c/p\u003e\n\u003ch2 id=\"hasnt-this-been-done-already\"\u003eHasn’t this been done already?\u003c/h2\u003e\n\u003cp\u003eThere are a number of dependency injection frameworks out there.\nFor Go, \u003ca href=\"https://github.com/uber-go/dig\" rel=\"noreferrer\" target=\"_blank\"\u003eUber’s dig\u003c/a\u003e and \u003ca href=\"https://github.com/facebookgo/inject\" rel=\"noreferrer\" target=\"_blank\"\u003eFacebook’s inject\u003c/a\u003e\nboth use reflection to do runtime dependency injection.\nWire was primarily inspired by Java’s \u003ca href=\"https://google.github.io/dagger/\" rel=\"noreferrer\" target=\"_blank\"\u003eDagger 2\u003c/a\u003e,\nand uses code generation rather than reflection or \u003ca href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\" rel=\"noreferrer\" target=\"_blank\"\u003eservice locators\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWe think this approach has several advantages:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRuntime dependency injection can be hard to follow and debug when the\ndependency graph gets complex.\nUsing code generation means that the initialization code that’s executed\nat runtime is regular,\nidiomatic Go code that’s easy to understand and debug.\nNothing is obfuscated by an intervening framework doing “magic”.\nIn particular, problems like forgetting a dependency become compile-time errors,\nnot run-time errors.\u003c/li\u003e\n\u003cli\u003eUnlike \u003ca href=\"https://en.wikipedia.org/wiki/Service_locator_pattern\" rel=\"noreferrer\" target=\"_blank\"\u003eservice locators\u003c/a\u003e,\nthere’s no need to make up arbitrary names or keys to register services.\nWire uses Go types to connect components with their dependencies.\u003c/li\u003e\n\u003cli\u003eIt’s easier to avoid dependency bloat. Wire’s generated code will only\nimport the dependencies you need,\nso your binary won’t have unused imports.\nRuntime dependency injectors can’t identify unused dependencies until runtime.\u003c/li\u003e\n\u003cli\u003eWire’s dependency graph is knowable statically, which provides opportunities for tooling and visualization.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"how-does-it-work\"\u003eHow does it work?\u003c/h2\u003e\n\u003cp\u003eWire has two basic concepts: providers and injectors.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eProviders\u003c/em\u003e are ordinary Go functions that “provide” values given their dependencies,\nwhich are described simply as parameters to the function.\nHere’s some sample code that defines three providers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// NewUserStore is the same function we saw above; it is a provider for UserStore,\n// with dependencies on *Config and *mysql.DB.\nfunc NewUserStore(cfg *Config, db *mysql.DB) (*UserStore, error) {...}\n\n// NewDefaultConfig is a provider for *Config, with no dependencies.\nfunc NewDefaultConfig() *Config {...}\n\n// NewDB is a provider for *mysql.DB based on some connection info.\nfunc NewDB(info *ConnectionInfo) (*mysql.DB, error) {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProviders that are commonly used together can be grouped into \u003ccode\u003eProviderSets\u003c/code\u003e.\nFor example, it’s common to use a default \u003ccode\u003e*Config\u003c/code\u003e when creating a \u003ccode\u003e*UserStore\u003c/code\u003e,\nso we can group \u003ccode\u003eNewUserStore\u003c/code\u003e and \u003ccode\u003eNewDefaultConfig\u003c/code\u003e in a \u003ccode\u003eProviderSet\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar UserStoreSet = wire.ProviderSet(NewUserStore, NewDefaultConfig)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cem\u003eInjectors\u003c/em\u003e are generated functions that call providers in dependency order.\nYou write the injector’s signature, including any needed inputs as arguments,\nand insert a call to \u003ccode\u003ewire.Build\u003c/code\u003e with the list of providers or provider\nsets that are needed to construct the end result:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc initUserStore() (*UserStore, error) {\n    // We\u0026#39;re going to get an error, because NewDB requires a *ConnectionInfo\n    // and we didn\u0026#39;t provide one.\n    wire.Build(UserStoreSet, NewDB)\n    return nil, nil  // These return values are ignored.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we run go generate to execute wire:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go generate\nwire.go:2:10: inject initUserStore: no provider found for ConnectionInfo (required by provider of *mysql.DB)\nwire: generate failed\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOops! We didn’t include a \u003ccode\u003eConnectionInfo\u003c/code\u003e or tell Wire how to build one.\nWire helpfully tells us the line number and types involved.\nWe can either add a provider for it to \u003ccode\u003ewire.Build\u003c/code\u003e,\nor add it as an argument:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc initUserStore(info ConnectionInfo) (*UserStore, error) {\n    wire.Build(UserStoreSet, NewDB)\n    return nil, nil  // These return values are ignored.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow \u003ccode\u003ego generate\u003c/code\u003e will create a new file with the generated code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// File: wire_gen.go\n// Code generated by Wire. DO NOT EDIT.\n//go:generate wire\n//+build !wireinject\n\nfunc initUserStore(info ConnectionInfo) (*UserStore, error) {\n    defaultConfig := NewDefaultConfig()\n    db, err := NewDB(info)\n    if err != nil {\n        return nil, err\n    }\n    userStore, err := NewUserStore(defaultConfig, db)\n    if err != nil {\n        return nil, err\n    }\n    return userStore, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny non-injector declarations are copied into the generated file.\nThere is no dependency on Wire at runtime:\nall of the written code is just normal Go code.\u003c/p\u003e\n\u003cp\u003eAs you can see, the output is very close to what a developer would write themselves.\nThis was a trivial example with just three components,\nso writing the initializer by hand wouldn’t be too painful,\nbut Wire saves a lot of manual toil for components and applications with\nmore complex dependency graphs.\u003c/p\u003e\n\u003ch2 id=\"how-can-i-get-involved-and-learn-more\"\u003eHow can I get involved and learn more?\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://github.com/google/wire/blob/master/README.md\" rel=\"noreferrer\" target=\"_blank\"\u003eWire README\u003c/a\u003e\ngoes into more detail about how to use Wire and its more advanced features.\nThere’s also a \u003ca href=\"https://github.com/google/wire/tree/master/_tutorial\" rel=\"noreferrer\" target=\"_blank\"\u003etutorial\u003c/a\u003e\nthat walks through using Wire in a simple application.\u003c/p\u003e\n\u003cp\u003eWe appreciate any input you have about your experience with Wire!\n\u003ca href=\"https://github.com/google/wire\" rel=\"noreferrer\" target=\"_blank\"\u003eWire’s\u003c/a\u003e development is conducted on GitHub,\nso you can \u003ca href=\"https://github.com/google/wire/issues/new/choose\" rel=\"noreferrer\" target=\"_blank\"\u003efile an issue\u003c/a\u003e\nto tell us what could be better.\nFor updates and discussion about the project,\njoin \u003ca href=\"https://groups.google.com/forum/#!forum/go-cloud\" rel=\"noreferrer\" target=\"_blank\"\u003ethe Go Cloud mailing list\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThank you for taking the time to learn about Go Cloud’s Wire.\nWe’re excited to work with you to make Go the language of choice for developers\nbuilding portable cloud applications.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2018-10-09T00:00:00Z",
  "Author": "Robert van Gent"
}