{
  "Source": "go.dev",
  "Title": "From zero to Go: launching on the Google homepage in 24 hours",
  "Link": "https://go.dev/blog/turkey-doodle",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/turkey-doodle\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eFrom zero to Go: launching on the Google homepage in 24 hours\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Reinaldo Aguiar\u003cbr/\u003e\n      13 December 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eThis article was written by Reinaldo Aguiar, a software engineer from the Search team at Google. He shares his experience developing his first Go program and launching it to an audience of millions - all in one day!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eI was recently given the opportunity to collaborate on a small but highly\nvisible “20% project”:\nthe \u003ca href=\"http://www.google.com/logos/2011/thanksgiving.html\" rel=\"noreferrer\" target=\"_blank\"\u003eThanksgiving 2011 Google Doodle\u003c/a\u003e.\nThe doodle features a turkey produced by randomly combining different styles of head,\nwings, feathers and legs.\nThe user can customize it by clicking on the different parts of the turkey.\nThis interactivity is implemented in the browser by a combination of JavaScript,\nCSS and of course HTML, creating turkeys on the fly.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"turkey-doodle/image00.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eOnce the user has created a personalized turkey it can be shared with friends\nand family by posting to Google+.\nClicking a “Share” button (not pictured here) creates in the user’s Google+\nstream a post containing a snapshot of the turkey.\nThe snapshot is a single image that matches the turkey the user created.\u003c/p\u003e\n\u003cp\u003eWith 13 alternatives for each of 8 parts of the turkey (heads,\npairs of legs, distinct feathers, etc.) there are more than 800 million\npossible snapshot images that could be generated.\nTo pre-compute them all is clearly infeasible.\nInstead, we must generate the snapshots on the fly.\nCombining that problem with a need for immediate scalability and high availability,\nthe choice of platform is obvious: Google App Engine!\u003c/p\u003e\n\u003cp\u003eThe next thing we needed to decide was which App Engine runtime to use.\nImage manipulation tasks are CPU-bound, so performance is the deciding factor in this case.\u003c/p\u003e\n\u003cp\u003eTo make an informed decision we ran a test.\nWe quickly prepared a couple of equivalent demo apps for the new \u003ca href=\"http://code.google.com/appengine/docs/python/python27/newin27.html\" rel=\"noreferrer\" target=\"_blank\"\u003ePython 2.7 runtime\u003c/a\u003e\n(which provides \u003ca href=\"http://www.pythonware.com/products/pil/\" rel=\"noreferrer\" target=\"_blank\"\u003ePIL\u003c/a\u003e,\na C-based imaging library) and the Go runtime.\nEach app generates an image composed of several small images,\nencodes the image as a JPEG, and sends the JPEG data as the HTTP response.\nThe Python 2.7 app served requests with a median latency of 65 milliseconds,\nwhile the Go app ran with a median latency of just 32 milliseconds.\u003c/p\u003e\n\u003cp\u003eThis problem therefore seemed the perfect opportunity to try the experimental Go runtime.\u003c/p\u003e\n\u003cp\u003eI had no previous experience with Go and the timeline was tight:\ntwo days to be production ready.\nThis was intimidating, but I saw it as an opportunity to test Go from a different,\noften overlooked angle:\ndevelopment velocity.\nHow fast can a person with no Go experience pick it up and build something\nthat performs and scales?\u003c/p\u003e\n\u003ch2 id=\"design\"\u003eDesign\u003c/h2\u003e\n\u003cp\u003eThe approach was to encode the state of the turkey in the URL, drawing and encoding the snapshot on the fly.\u003c/p\u003e\n\u003cp\u003eThe base for every doodle is the background:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"turkey-doodle/image01.jpg\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eA valid request URL might look like this:\n\u003ccode\u003ehttp://google-turkey.appspot.com/thumb/20332620][http://google-turkey.appspot.com/thumb/20332620\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe alphanumeric string that follows “/thumb/” indicates (in hexadecimal)\nwhich choice to draw for each layout element,\nas illustrated by this image:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"turkey-doodle/image03.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe program’s request handler parses the URL to determine which element\nis selected for each component,\ndraws the appropriate images on top of the background image,\nand serves the result as a JPEG.\u003c/p\u003e\n\u003cp\u003eIf an error occurs, a default image is served.\nThere’s no point serving an error page because the user will never see it -\nthe browser is almost certainly loading this URL into an image tag.\u003c/p\u003e\n\u003ch2 id=\"implementation\"\u003eImplementation\u003c/h2\u003e\n\u003cp\u003eIn the package scope we declare some data structures to describe the elements of the turkey,\nthe location of the corresponding images,\nand where they should be drawn on the background image.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar (\n    // dirs maps each layout element to its location on disk.\n    dirs = map[string]string{\n        \u0026#34;h\u0026#34;: \u0026#34;img/heads\u0026#34;,\n        \u0026#34;b\u0026#34;: \u0026#34;img/eyes_beak\u0026#34;,\n        \u0026#34;i\u0026#34;: \u0026#34;img/index_feathers\u0026#34;,\n        \u0026#34;m\u0026#34;: \u0026#34;img/middle_feathers\u0026#34;,\n        \u0026#34;r\u0026#34;: \u0026#34;img/ring_feathers\u0026#34;,\n        \u0026#34;p\u0026#34;: \u0026#34;img/pinky_feathers\u0026#34;,\n        \u0026#34;f\u0026#34;: \u0026#34;img/feet\u0026#34;,\n        \u0026#34;w\u0026#34;: \u0026#34;img/wing\u0026#34;,\n    }\n\n    // urlMap maps each URL character position to\n    // its corresponding layout element.\n    urlMap = [...]string{\u0026#34;b\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;i\u0026#34;, \u0026#34;m\u0026#34;, \u0026#34;r\u0026#34;, \u0026#34;p\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;w\u0026#34;}\n\n    // layoutMap maps each layout element to its position\n    // on the background image.\n    layoutMap = map[string]image.Rectangle{\n        \u0026#34;h\u0026#34;: {image.Pt(109, 50), image.Pt(166, 152)},\n        \u0026#34;i\u0026#34;: {image.Pt(136, 21), image.Pt(180, 131)},\n        \u0026#34;m\u0026#34;: {image.Pt(159, 7), image.Pt(201, 126)},\n        \u0026#34;r\u0026#34;: {image.Pt(188, 20), image.Pt(230, 125)},\n        \u0026#34;p\u0026#34;: {image.Pt(216, 48), image.Pt(258, 134)},\n        \u0026#34;f\u0026#34;: {image.Pt(155, 176), image.Pt(243, 213)},\n        \u0026#34;w\u0026#34;: {image.Pt(169, 118), image.Pt(250, 197)},\n        \u0026#34;b\u0026#34;: {image.Pt(105, 104), image.Pt(145, 148)},\n    }\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe geometry of the points above was calculated by measuring the actual\nlocation and size of each layout element within the image.\u003c/p\u003e\n\u003cp\u003eLoading the images from disk on each request would be wasteful repetition,\nso we load all 106 images (13 * 8 elements + 1 background + 1 default) into\nglobal variables upon receipt of the first request.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar (\n    // elements maps each layout element to its images.\n    elements = make(map[string][]*image.RGBA)\n\n    // backgroundImage contains the background image data.\n    backgroundImage *image.RGBA\n\n    // defaultImage is the image that is served if an error occurs.\n    defaultImage *image.RGBA\n\n    // loadOnce is used to call the load function only on the first request.\n    loadOnce sync.Once\n)\n\n// load reads the various PNG images from disk and stores them in their\n// corresponding global variables.\nfunc load() {\n    defaultImage = loadPNG(defaultImageFile)\n    backgroundImage = loadPNG(backgroundImageFile)\n    for dirKey, dir := range dirs {\n        paths, err := filepath.Glob(dir + \u0026#34;/*.png\u0026#34;)\n        if err != nil {\n            panic(err)\n        }\n        for _, p := range paths {\n            elements[dirKey] = append(elements[dirKey], loadPNG(p))\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRequests are handled in a straightforward sequence:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eParse the request URL, decoding the decimal value of each character in the path.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eMake a copy of the background image as the base for the final image.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDraw each image element onto the background image using the layoutMap to determine where they should be drawn.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eEncode the image as a JPEG\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReturn the image to user by writing the JPEG directly to the HTTP response writer.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eShould any error occur, we serve the defaultImage to the user and log the\nerror to the App Engine dashboard for later analysis.\u003c/p\u003e\n\u003cp\u003eHere’s the code for the request handler with explanatory comments:\u003c/p\u003e\n\u003cpre\u003efunc handler(w http.ResponseWriter, r *http.Request) {\n    // \u003ca href=\"/blog/defer-panic-and-recover.html\"\u003eDefer\u003c/a\u003e a function to recover from any panics.\n    // When recovering from a panic, log the error condition to\n    // the App Engine dashboard and send the default image to the user.\n    defer func() {\n        if err := recover(); err != nil {\n            c := appengine.NewContext(r)\n            c.Errorf(\u0026#34;%s\u0026#34;, err)\n            c.Errorf(\u0026#34;%s\u0026#34;, \u0026#34;Traceback: %s\u0026#34;, r.RawURL)\n            if defaultImage != nil {\n                w.Header().Set(\u0026#34;Content-type\u0026#34;, \u0026#34;image/jpeg\u0026#34;)\n                jpeg.Encode(w, defaultImage, \u0026amp;imageQuality)\n            }\n        }\n    }()\n\n    // Load images from disk on the first request.\n    loadOnce.Do(load)\n\n    // Make a copy of the background to draw into.\n    bgRect := backgroundImage.Bounds()\n    m := image.NewRGBA(bgRect.Dx(), bgRect.Dy())\n    draw.Draw(m, m.Bounds(), backgroundImage, image.ZP, draw.Over)\n\n    // Process each character of the request string.\n    code := strings.ToLower(r.URL.Path[len(prefix):])\n    for i, p := range code {\n        // Decode hex character p in place.\n        if p \u0026lt; \u0026#39;a\u0026#39; {\n            // it\u0026#39;s a digit\n            p = p - \u0026#39;0\u0026#39;\n        } else {\n            // it\u0026#39;s a letter\n            p = p - \u0026#39;a\u0026#39; + 10\n        }\n\n        t := urlMap[i]    // element type by index\n        em := elements[t] // element images by type\n        if p \u0026gt;= len(em) {\n            panic(fmt.Sprintf(\u0026#34;element index out of range %s: \u0026#34;+\n                \u0026#34;%d \u0026gt;= %d\u0026#34;, t, p, len(em)))\n        }\n\n        // Draw the element to m,\n        // using the layoutMap to specify its position.\n        draw.Draw(m, layoutMap[t], em[p], image.ZP, draw.Over)\n    }\n\n    // Encode JPEG image and write it as the response.\n    w.Header().Set(\u0026#34;Content-type\u0026#34;, \u0026#34;image/jpeg\u0026#34;)\n    w.Header().Set(\u0026#34;Cache-control\u0026#34;, \u0026#34;public, max-age=259200\u0026#34;)\n    jpeg.Encode(w, m, \u0026amp;imageQuality)\n}\n\u003c/pre\u003e\n\u003cp\u003eFor brevity, I’ve omitted several helper functions from these code listings.\nSee the \u003ca href=\"http://code.google.com/p/go-thanksgiving/source/browse/\" rel=\"noreferrer\" target=\"_blank\"\u003esource code\u003c/a\u003e for the full scoop.\u003c/p\u003e\n\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"turkey-doodle/image02.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThis chart - taken directly from the App Engine dashboard - shows average\nrequest latency during launch.\nAs you can see, even under load it never exceeds 60 ms,\nwith a median latency of 32 milliseconds.\nThis is wicked fast, considering that our request handler is doing image\nmanipulation and encoding on the fly.\u003c/p\u003e\n\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\n\u003cp\u003eI found Go’s syntax to be intuitive, simple and clean.\nI have worked a lot with interpreted languages in the past,\nand although Go is instead a statically typed and compiled language,\nwriting this app felt more like working with a dynamic,\ninterpreted language.\u003c/p\u003e\n\u003cp\u003eThe development server provided with the \u003ca href=\"http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go\" rel=\"noreferrer\" target=\"_blank\"\u003eSDK\u003c/a\u003e\nquickly recompiles the program after any change,\nso I could iterate as fast as I would with an interpreted language.\nIt’s dead simple, too - it took less than a minute to set up my development environment.\u003c/p\u003e\n\u003cp\u003eGo’s great documentation also helped me put this together fast.\nThe docs are generated from the source code,\nso each function’s documentation links directly to the associated source code.\nThis not only allows the developer to understand very quickly what a particular\nfunction does but also encourages the developer to dig into the package implementation,\nmaking it easier to learn good style and conventions.\u003c/p\u003e\n\u003cp\u003eIn writing this application I used just three resources:\nApp Engine’s \u003ca href=\"http://code.google.com/appengine/docs/go/gettingstarted/helloworld.html\" rel=\"noreferrer\" target=\"_blank\"\u003eHello World Go example\u003c/a\u003e,\n\u003ca href=\"/pkg/\"\u003ethe Go packages documentation\u003c/a\u003e,\nand \u003ca href=\"/blog/go-imagedraw-package\"\u003ea blog post showcasing the Draw package\u003c/a\u003e.\nThanks to the rapid iteration made possible by the development server and\nthe language itself,\nI was able to pick up the language and build a super fast,\nproduction ready, doodle generator in less than 24 hours.\u003c/p\u003e\n\u003cp\u003eDownload the full app source code (including images) at \u003ca href=\"http://code.google.com/p/go-thanksgiving/source/browse/\" rel=\"noreferrer\" target=\"_blank\"\u003ethe Google Code project\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eSpecial thanks go to Guillermo Real and Ryan Germick who designed the doodle.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-12-13T00:00:00Z",
  "Author": "Reinaldo Aguiar"
}