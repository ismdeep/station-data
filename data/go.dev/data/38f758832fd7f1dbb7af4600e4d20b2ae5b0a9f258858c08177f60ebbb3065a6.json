{
  "Source": "go.dev",
  "Title": "Secure Randomness in Go 1.22",
  "Link": "https://go.dev/blog/chacha8rand",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/chacha8rand\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eSecure Randomness in Go 1.22\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox and Filippo Valsorda\u003cbr/\u003e\n      2 May 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eComputers aren’t random.\nOn the contrary, hardware designers work very hard to make sure computers run every program the same way every time.\nSo when a program does need random numbers, that requires extra effort.\nTraditionally, computer scientists and programming languages\nhave distinguished between two different kinds of random numbers:\nstatistical and cryptographic randomness.\nIn Go, those are provided by \u003ca href=\"/pkg/math/rand/\"\u003e\u003ccode\u003emath/rand\u003c/code\u003e\u003c/a\u003e\nand \u003ca href=\"/pkg/crypto/rand\"\u003e\u003ccode\u003ecrypto/rand\u003c/code\u003e\u003c/a\u003e, respectively.\nThis post is about how Go 1.22 brings the two closer together,\nby using a cryptographic random number source in \u003ccode\u003emath/rand\u003c/code\u003e\n(as well as \u003ccode\u003emath/rand/v2\u003c/code\u003e, as mentioned in our \u003ca href=\"/blog/randv2\"\u003eprevious post\u003c/a\u003e).\nThe result is better randomness and far less damage when\ndevelopers accidentally use \u003ccode\u003emath/rand\u003c/code\u003e instead of \u003ccode\u003ecrypto/rand\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBefore we can explain what Go 1.22 did, let’s take a closer look\nat statistical randomness compared to cryptographic randomness.\u003c/p\u003e\n\u003ch2 id=\"statistical-randomness\"\u003eStatistical Randomness\u003c/h2\u003e\n\u003cp\u003eRandom numbers that pass basic statistical tests\nare usually appropriate for use cases like simulations, sampling,\nnumerical analysis, non-cryptographic randomized algorithms,\n\u003ca href=\"/doc/security/fuzz/\"\u003erandom testing\u003c/a\u003e,\n\u003ca href=\"https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\" rel=\"noreferrer\" target=\"_blank\"\u003eshuffling inputs\u003c/a\u003e,\nand\n\u003ca href=\"https://en.wikipedia.org/wiki/Exponential_backoff#Collision_avoidance\" rel=\"noreferrer\" target=\"_blank\"\u003erandom exponential backoff\u003c/a\u003e.\nVery basic, easy to compute mathematical formulas turn out to work\nwell enough for these use cases.\nBecause the methods are so simple, however, an observer who\nknows what algorithm is being used can typically predict the rest\nof the sequence after seeing enough values.\u003c/p\u003e\n\u003cp\u003eEssentially all programming environments provide a mechanism for generating\nstatistical random numbers\nthat traces back through C to\nResearch Unix Third Edition (V3), which added a pair of functions: \u003ccode\u003esrand\u003c/code\u003e and \u003ccode\u003erand\u003c/code\u003e.\nThe manual page included\na note that read:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cem\u003eWARNING   The author of this routine has been writing\nrandom-number generators for many years and has never been\nknown to write one that worked.\u003c/em\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis note was partly a joke but also an acknowledgement that such\ngenerators are \u003ca href=\"https://www.tuhs.org/pipermail/tuhs/2024-March/029587.html\" rel=\"noreferrer\" target=\"_blank\"\u003einherently not random\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe source code of the generator makes clear how trivial it is.\nTranslated from PDP-11 assembly to modern C, it was:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003euint16 ranx;\n\nvoid\nsrand(uint16 seed)\n{\n    ranx = seed;\n}\n\nint16\nrand(void)\n{\n    ranx = 13077*ranx + 6925;\n    return ranx \u0026amp; ~0x8000;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCalling \u003ccode\u003esrand\u003c/code\u003e seeds the generator with a single integer seed,\nand \u003ccode\u003erand\u003c/code\u003e returns the next number from the generator.\nThe AND in the return statement clears the sign bit to make sure the result is positive.\u003c/p\u003e\n\u003cp\u003eThis function is an instance of the general class of\n\u003ca href=\"https://en.wikipedia.org/wiki/Linear_congruential_generator\" rel=\"noreferrer\" target=\"_blank\"\u003elinear congruential generators (LCGs)\u003c/a\u003e,\nwhich Knuth analyzes in \u003cem\u003eThe Art of Computer Programming\u003c/em\u003e, Volume 2, section 3.2.1.\nThe main benefit of LCGs is that constants can be chosen such that they\nemit every possible output value once before repeating,\nas the Unix implementation did for 15-bit outputs.\nA serious problem with LCGs, however, is that the high bits of the state do not affect the low bits at all,\nso every truncation of the sequence to \u003cem\u003ek\u003c/em\u003e bits necessarily repeats with a smaller period.\nThe low bit must toggle: 0, 1, 0, 1, 0, 1.\nThe low two bits must count up or down: 0, 1, 2, 3, 0, 1, 2, 3, or else 0, 3, 2, 1, 0, 3, 2, 1.\nThere are four possible three-bit sequences; the original Unix implementation repeats 0, 5, 6, 3, 4, 1, 2, 7.\n(These problems can be avoided by reducing the value modulo a prime,\nbut that would have been quite expensive at the time.\nSee S. K. Park and K. W. Miller’s 1988 CACM paper\n“\u003ca href=\"https://dl.acm.org/doi/10.1145/63039.63042\" rel=\"noreferrer\" target=\"_blank\"\u003eRandom number generators: good ones are hard to find\u003c/a\u003e”\nfor a short analysis\nand the first chapter of Knuth Volume 2 for a longer one.)\u003c/p\u003e\n\u003cp\u003eEven with these known problems,\nthe \u003ccode\u003esrand\u003c/code\u003e and \u003ccode\u003erand\u003c/code\u003e functions were included in the first C standard,\nand equivalent functionality was included in essentially every language since then.\nLCGs were once the dominant implementation strategy,\nalthough they’ve fallen off in popularity due to some important drawbacks.\nOne significant remaining use is \u003ca href=\"https://github.com/openjdk/jdk8u-dev/blob/master/jdk/src/share/classes/java/util/Random.java\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ejava.util.Random\u003c/code\u003e\u003c/a\u003e,\nwhich powers \u003ca href=\"https://github.com/openjdk/jdk8u-dev/blob/master/jdk/src/share/classes/java/util/Random.java\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ejava.lang.Math.random\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAnother thing you can see from the implementation above\nis that the internal state is completely exposed by the result of \u003ccode\u003erand\u003c/code\u003e.\nAn observer who knows the algorithm and sees a single result\ncan easily compute all future results.\nIf you are running a server that calculates some random values\nthat become public and some random values that must stay secret,\nusing this kind of generator would be disastrous:\nthe secrets wouldn’t be secret.\u003c/p\u003e\n\u003cp\u003eMore modern random generators aren’t as terrible as the original Unix one,\nbut they’re still not completely unpredictable.\nTo make that point, next we will look at the original \u003ccode\u003emath/rand\u003c/code\u003e generator from Go 1\nand the PCG generator we added in \u003ccode\u003emath/rand/v2\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"the-go-1-generator\"\u003eThe Go 1 Generator\u003c/h2\u003e\n\u003cp\u003eThe generator used in Go 1’s \u003ccode\u003emath/rand\u003c/code\u003e is an instance of what is called a\n\u003ca href=\"https://en.wikipedia.org/wiki/Linear-feedback_shift_register\" rel=\"noreferrer\" target=\"_blank\"\u003elinear-feedback shift register\u003c/a\u003e.\nThe algorithm is based on an idea by George Marsaglia,\ntweaked by Don Mitchell and Jim Reeds,\nand further customized by Ken Thompson for Plan 9 and then Go.\nIt has no official name, so this post calls it the Go 1 generator.\u003c/p\u003e\n\u003cp\u003eThe Go 1 generator’s internal state is a slice \u003ccode\u003evec\u003c/code\u003e of 607 uint64s.\nIn that slice, there are two distinguished elements: \u003ccode\u003evec[606]\u003c/code\u003e, the last element, is called the “tap”,\nand \u003ccode\u003evec[334]\u003c/code\u003e is called the “feed”.\nTo generate the next random number,\nthe generator adds the tap and the feed\nto produce a value \u003ccode\u003ex\u003c/code\u003e,\nstores \u003ccode\u003ex\u003c/code\u003e back into the feed,\nshifts the entire slice one position to the right\n(the tap moves to \u003ccode\u003evec[0]\u003c/code\u003e and \u003ccode\u003evec[i]\u003c/code\u003e moves to \u003ccode\u003evec[i+1]\u003c/code\u003e),\nand returns \u003ccode\u003ex\u003c/code\u003e.\nThe generator is called “linear feedback” because the tap is \u003cem\u003eadded\u003c/em\u003e to the feed;\nthe entire state is a “shift register” because each step shifts the slice entries.\u003c/p\u003e\n\u003cp\u003eOf course, actually moving every slice entry forward would be prohibitively expensive,\nso instead the implementation leaves the slice data in place\nand moves the tap and feed positions backward\non each step. The code looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (r *rngSource) Uint64() uint64 {\n    r.tap--\n    if r.tap \u0026lt; 0 {\n        r.tap += len(r.vec)\n    }\n\n    r.feed--\n    if r.feed \u0026lt; 0 {\n        r.feed += len(r.vec)\n    }\n\n    x := r.vec[r.feed] + r.vec[r.tap]\n    r.vec[r.feed] = x\n    return uint64(x)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGenerating the next number is quite cheap: two subtractions, two conditional adds, two loads, one add, one store.\u003c/p\u003e\n\u003cp\u003eUnfortunately, because the generator directly returns one slice element from its internal state vector,\nreading 607 values from the generator completely exposes all its state.\nWith those values, you can predict all the future values, by filling in your own \u003ccode\u003evec\u003c/code\u003e\nand then running the algorithm.\nYou can also recover all the previous values, by running the algorithm backward\n(subtracting the tap from the feed and shifting the slice to the left).\u003c/p\u003e\n\u003cp\u003eAs a complete demonstration, here is an \u003ca href=\"/play/p/v0QdGjUAtzC\"\u003einsecure program\u003c/a\u003e\ngenerating pseudorandom authentication\ntokens along with code that predicts the next token given a sequence of earlier tokens.\nAs you can see, the Go 1 generator provides no security at all (nor was it meant to).\nThe quality of the generated numbers also depends on the initial setting of \u003ccode\u003evec\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"the-pcg-generator\"\u003eThe PCG Generator\u003c/h2\u003e\n\u003cp\u003eFor \u003ccode\u003emath/rand/v2\u003c/code\u003e, we wanted to provide a more modern statistical random generator\nand settled on Melissa O’Neill’s PCG algorithm, published in 2014 in her paper\n“\u003ca href=\"https://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003ePCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\u003c/a\u003e”.\nThe exhaustive analysis in the paper can make it hard to notice at first glance how utterly trivial the generators are:\nPCG is a post-processed 128-bit LCG.\u003c/p\u003e\n\u003cp\u003eIf the state \u003ccode\u003ep.x\u003c/code\u003e were a \u003ccode\u003euint128\u003c/code\u003e (hypothetically), the code to compute the next value would be:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst (\n    pcgM = 0x2360ed051fc65da44385df649fccf645\n    pcgA = 0x5851f42d4c957f2d14057b7ef767814f\n)\n\ntype PCG struct {\n    x uint128\n}\n\nfunc (p *PCG) Uint64() uint64 {\n    p.x = p.x * pcgM + pcgA\n    return scramble(p.x)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe entire state is a single 128-bit number,\nand the update is a 128-bit multiply and add.\nIn the return statement, the \u003ccode\u003escramble\u003c/code\u003e function reduces the 128-bit state\ndown to a 64-bit state.\nThe original PCG used (again using a hypothetical \u003ccode\u003euint128\u003c/code\u003e type):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc scramble(x uint128) uint64 {\n    return bits.RotateLeft(uint64(x\u0026gt;\u0026gt;64) ^ uint64(x), -int(x\u0026gt;\u0026gt;122))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code XORs the two halves of the 128-bit state together\nand then rotates the result according to the top six bits of the state.\nThis version is called PCG-XSL-RR, for “xor shift low, right rotate”.\u003c/p\u003e\n\u003cp\u003eBased on a \u003ca href=\"/issue/21835#issuecomment-739065688\"\u003esuggestion from O’Neill during proposal discussion\u003c/a\u003e,\nGo’s PCG uses a new scramble function based on multiplication,\nwhich mixes the bits more aggressively:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc scramble(x uint128) uint64 {\n    hi, lo := uint64(x\u0026gt;\u0026gt;64), uint64(x)\n    hi ^= hi \u0026gt;\u0026gt; 32\n    hi *= 0xda942042e4dd58b5\n    hi ^= hi \u0026gt;\u0026gt; 48\n    hi *= lo | 1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eO’Neill calls PCG with this scrambler PCG-DXSM, for “double xorshift multiply.”\nNumpy uses this form of PCG as well.\u003c/p\u003e\n\u003cp\u003eAlthough PCG uses more computation to generate each value,\nit uses significantly less state: two uint64s instead of 607.\nIt is also much less sensitive to the initial values of that state,\nand \u003ca href=\"https://www.pcg-random.org/statistical-tests.html\" rel=\"noreferrer\" target=\"_blank\"\u003eit passes many statistical tests that other generators do not\u003c/a\u003e.\nIn many ways it is an ideal statistical generator.\u003c/p\u003e\n\u003cp\u003eEven so, PCG is not unpredictable.\nWhile the scrambling of bits to prepare the result does not\nexpose the state directly like in the LCG and Go 1 generators,\n\u003ca href=\"https://pdfs.semanticscholar.org/4c5e/4a263d92787850edd011d38521966751a179.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003ePCG-XSL-RR can still be reversed\u003c/a\u003e,\nand it would not be surprising if PCG-DXSM could too.\nFor secrets, we need something different.\u003c/p\u003e\n\u003ch2 id=\"cryptographic-randomness\"\u003eCryptographic Randomness\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eCryptographic random numbers\u003c/em\u003e need to be utterly unpredictable\nin practice, even to an observer who knows how they are generated\nand has observed any number of previously generated values.\nThe safety of cryptographic protocols, secret keys, modern commerce,\nonline privacy, and more all critically depend on access to cryptographic\nrandomness.\u003c/p\u003e\n\u003cp\u003eProviding cryptographic randomness is ultimately the job of the\noperating system, which can gather true randomness from physical devices—timings\nof the mouse, keyboard, disks, and network, and more recently\n\u003ca href=\"https://web.archive.org/web/20141230024150/http://www.cryptography.com/public/pdf/Intel_TRNG_Report_20120312.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003eelectrical noise measured directly by the CPU itself\u003c/a\u003e.\nOnce the operating system has gathered a meaningful\namount of randomness—say, at least 256 bits—it can use cryptographic\nhashing or encryption algorithms to stretch that seed into\nan arbitrarily long sequence of random numbers.\n(In practice the operating system is also constantly gathering and\nadding new randomness to the sequence too.)\u003c/p\u003e\n\u003cp\u003eThe exact operating system interfaces have evolved over time.\nA decade ago, most systems provided a device file named\n\u003ccode\u003e/dev/random\u003c/code\u003e or something similar.\nToday, in recognition of how fundamental randomness has become,\noperating systems provide a direct system call instead.\n(This also allows programs to read randomness even\nwhen cut off from the file system.)\nIn Go, the \u003ca href=\"/pkg/crypto/rand/\"\u003e\u003ccode\u003ecrypto/rand\u003c/code\u003e\u003c/a\u003e package abstracts away those details,\nproviding the same interface on every operating system: \u003ca href=\"/pkg/crypto/rand/#Read\"\u003e\u003ccode\u003erand.Read\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt would not be practical for \u003ccode\u003emath/rand\u003c/code\u003e to ask the operating system for\nrandomness each time it needs a \u003ccode\u003euint64\u003c/code\u003e.\nBut we can use cryptographic techniques to define an in-process\nrandom generator that improves on LCGs, the Go 1 generator, and even PCG.\u003c/p\u003e\n\u003ch2 id=\"the-chacha8rand-generator\"\u003eThe ChaCha8Rand Generator\u003c/h2\u003e\n\u003cp\u003eOur new generator, which we unimaginatively named ChaCha8Rand for specification purposes\nand implemented as \u003ccode\u003emath/rand/v2\u003c/code\u003e’s \u003ca href=\"/pkg/math/rand/v2/#ChaCha8\"\u003e\u003ccode\u003erand.ChaCha8\u003c/code\u003e\u003c/a\u003e,\nis a lightly modified version of Daniel J. Bernstein’s \u003ca href=\"https://cr.yp.to/chacha.html\" rel=\"noreferrer\" target=\"_blank\"\u003eChaCha stream cipher\u003c/a\u003e.\nChaCha is widely used in a 20-round form called ChaCha20, including in TLS and SSH.\nJean-Philippe Aumasson’s paper “\u003ca href=\"https://eprint.iacr.org/2019/1492.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003eToo Much Crypto\u003c/a\u003e”\nargues persuasively that the 8-round form ChaCha8 is secure too (and it’s roughly 2.5X faster).\nWe used ChaCha8 as the core of ChaCha8Rand.\u003c/p\u003e\n\u003cp\u003eMost stream ciphers, including ChaCha8, work by defining a function that is given\na key and a block number and produces a fixed-size block of apparently random data.\nThe cryptographic standard these aim for (and usually meet) is for this output to be indistinguishable\nfrom actual random data in the absence of some kind of exponentially costly brute force search.\nA message is encrypted or decrypted by XOR’ing successive blocks of input data\nwith successive randomly generated blocks.\nTo use ChaCha8 as a \u003ccode\u003erand.Source\u003c/code\u003e,\nwe use the generated blocks directly instead of XOR’ing them with input data\n(this is equivalent to encrypting or decrypting all zeros).\u003c/p\u003e\n\u003cp\u003eWe changed a few details to make ChaCha8Rand more suitable for generating random numbers. Briefly:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChaCha8Rand takes a 32-byte seed, used as the ChaCha8 key.\u003c/li\u003e\n\u003cli\u003eChaCha8 generates 64-byte blocks, with calculations treating a block as 16 \u003ccode\u003euint32\u003c/code\u003es.\nA common implementation is to compute four blocks at a time using \u003ca href=\"https://en.wikipedia.org/wiki/Single_instruction,_multiple_data\" rel=\"noreferrer\" target=\"_blank\"\u003eSIMD instructions\u003c/a\u003e\non 16 vector registers of four \u003ccode\u003euint32\u003c/code\u003es each.\nThis produces four interleaved blocks that must be unshuffled for XOR’ing with the input data.\nChaCha8Rand defines that the interleaved blocks are the random data stream,\nremoving the cost of the unshuffle.\n(For security purposes, this can be viewed as standard ChaCha8 followed by a reshuffle.)\u003c/li\u003e\n\u003cli\u003eChaCha8 finishes a block by adding certain values to each \u003ccode\u003euint32\u003c/code\u003e in the block.\nHalf the values are key material and the other half are known constants.\nChaCha8Rand defines that the known constants are not re-added,\nremoving half of the final adds.\n(For security purposes, this can be viewed as standard ChaCha8 followed by subtracting the known constants.)\u003c/li\u003e\n\u003cli\u003eEvery 16th generated block, ChaCha8Rand takes the final 32 bytes of the block for itself,\nmaking them the key for the next 16 blocks.\nThis provides a kind of \u003ca href=\"https://en.wikipedia.org/wiki/Forward_secrecy\" rel=\"noreferrer\" target=\"_blank\"\u003eforward secrecy\u003c/a\u003e:\nif a system is compromised by an attack that\nrecovers the entire memory state of the generator, only values generated\nsince the last rekeying can be recovered. The past is inaccessible.\nChaCha8Rand as defined so far must generate 4 blocks at a time,\nbut we chose to do this key rotation every 16 blocks to leave open the\npossibility of faster implementations using 256-bit or 512-bit vectors,\nwhich could generate 8 or 16 blocks at a time.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe wrote and published a \u003ca href=\"https://c2sp.org/chacha8rand\" rel=\"noreferrer\" target=\"_blank\"\u003eC2SP specification for ChaCha8Rand\u003c/a\u003e,\nalong with test cases.\nThis will enable other implementations to share repeatability with the Go implementation\nfor a given seed.\u003c/p\u003e\n\u003cp\u003eThe Go runtime now maintains a per-core ChaCha8Rand state (300 bytes),\nseeded with operating system-supplied cryptographic randomness,\nso that random numbers can be generated quickly without any lock contention.\nDedicating 300 bytes per core may sound expensive,\nbut on a 16-core system, it is about the same as storing a single shared Go 1 generator state (4,872 bytes).\nThe speed is worth the memory.\nThis per-core ChaCha8Rand generator is now used in three different places in the Go standard library:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003emath/rand/v2\u003c/code\u003e package functions, such as\n\u003ca href=\"/pkg/math/rand/v2/#Float64\"\u003e\u003ccode\u003erand.Float64\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/math/rand/v2/#N\"\u003e\u003ccode\u003erand.N\u003c/code\u003e\u003c/a\u003e, always use ChaCha8Rand.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe \u003ccode\u003emath/rand\u003c/code\u003e package functions, such as\n\u003ca href=\"/pkg/math/rand/#Float64\"\u003e\u003ccode\u003erand.Float64\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/math/rand/#Intn\"\u003e\u003ccode\u003erand.Intn\u003c/code\u003e\u003c/a\u003e,\nuse ChaCha8Rand when\n\u003ca href=\"/pkg/math/rand/#Seed\"\u003e\u003ccode\u003erand.Seed\u003c/code\u003e\u003c/a\u003e has not been called.\nApplying ChaCha8Rand in \u003ccode\u003emath/rand\u003c/code\u003e improves the security of programs\neven before they update to \u003ccode\u003emath/rand/v2\u003c/code\u003e,\nprovided they are not calling \u003ccode\u003erand.Seed\u003c/code\u003e.\n(If \u003ccode\u003erand.Seed\u003c/code\u003e is called, the implementation is required to fall back to the Go 1 generator for compatibility.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe runtime chooses the hash seed for each new map\nusing ChaCha8Rand instead of a less secure \u003ca href=\"https://github.com/wangyi-fudan/wyhash\" rel=\"noreferrer\" target=\"_blank\"\u003ewyrand-based generator\u003c/a\u003e\nit previously used.\nRandom seeds are needed because if\nan attacker knows the specific hash function used by a map implementation,\nthey can prepare input that drives the map into quadratic behavior\n(see Crosby and Wallach’s “\u003ca href=\"https://www.usenix.org/conference/12th-usenix-security-symposium/denial-service-algorithmic-complexity-attacks\" rel=\"noreferrer\" target=\"_blank\"\u003eDenial of Service via Algorithmic Complexity Attacks\u003c/a\u003e”).\nUsing a per-map seed, instead of one global seed for all maps,\nalso avoids \u003ca href=\"https://accidentallyquadratic.tumblr.com/post/153545455987/rust-hash-iteration-reinsertion\" rel=\"noreferrer\" target=\"_blank\"\u003eother degenerate behaviors\u003c/a\u003e.\nIt is not strictly clear that maps need a cryptographically random seed,\nbut it’s also not clear that they don’t. It seemed prudent and was trivial to switch.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eCode that needs its own ChaCha8Rand instances can create its own \u003ca href=\"/pkg/math/rand/v2/#ChaCha8\"\u003e\u003ccode\u003erand.ChaCha8\u003c/code\u003e\u003c/a\u003e directly.\u003c/p\u003e\n\u003ch2 id=\"fixing-security-mistakes\"\u003eFixing Security Mistakes\u003c/h2\u003e\n\u003cp\u003eGo aims to help developers write code that is secure by default.\nWhen we observe a common mistake with security consequences,\nwe look for ways to reduce the risk of that mistake\nor eliminate it entirely.\nIn this case, \u003ccode\u003emath/rand\u003c/code\u003e’s global generator was far too predictable,\nleading to serious problems in a variety of contexts.\u003c/p\u003e\n\u003cp\u003eFor example, when Go 1.20 deprecated \u003ca href=\"/pkg/math/rand/#Read\"\u003e\u003ccode\u003emath/rand\u003c/code\u003e’s \u003ccode\u003eRead\u003c/code\u003e\u003c/a\u003e,\nwe heard from developers who discovered (thanks to tooling pointing out\nuse of deprecated functionality) they had been\nusing it in places where \u003ca href=\"/pkg/crypto/rand/#Read\"\u003e\u003ccode\u003ecrypto/rand\u003c/code\u003e’s \u003ccode\u003eRead\u003c/code\u003e\u003c/a\u003e\nwas definitely needed, like generating key material.\nUsing Go 1.20, that mistake\nis a serious security problem that merits a detailed investigation\nto understand the damage.\nWhere were the keys used?\nHow were the keys exposed?\nWere other random outputs exposed that might allow an attacker to derive the keys?\nAnd so on.\nUsing Go 1.22, that mistake is just a mistake.\nIt’s still better to use \u003ccode\u003ecrypto/rand\u003c/code\u003e,\nbecause the operating system kernel can do a better job keeping the random values\nsecret from various kinds of prying eyes,\nthe kernel is continually adding new entropy to its generator,\nand the kernel has had more scrutiny.\nBut accidentally using \u003ccode\u003emath/rand\u003c/code\u003e is no longer a security catastrophe.\u003c/p\u003e\n\u003cp\u003eThere are also a variety of use cases that don’t seem like “crypto”\nbut nonetheless need unpredictable randomness.\nThese cases are made more robust by using ChaCha8Rand instead of the Go 1 generator.\u003c/p\u003e\n\u003cp\u003eFor example, consider generating a\n\u003ca href=\"https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)\" rel=\"noreferrer\" target=\"_blank\"\u003erandom UUID\u003c/a\u003e.\nSince UUIDs are not secret, using \u003ccode\u003emath/rand\u003c/code\u003e might seem fine.\nBut if \u003ccode\u003emath/rand\u003c/code\u003e has been seeded with the current time,\nthen running it at the same instant on different computers\nwill produce the same value, making them not “universally unique”.\nThis is especially likely on systems where the current time\nis only available with millisecond precision.\nEven with auto-seeding using OS-provided entropy,\nas introduced in Go 1.20,\nthe Go 1 generator’s seed is only a 63-bit integer,\nso a program that generates a UUID at startup\ncan only generate 2⁶³ possible UUIDs and is\nlikely to see collisions after 2³¹ or so UUIDs.\nUsing Go 1.22, the new ChaCha8Rand generator\nis seeded from 256 bits of entropy and can generate\n2²⁵⁶ possible first UUIDs.\nIt does not need to worry about collisions.\u003c/p\u003e\n\u003cp\u003eAs another example, consider load balancing in a front-end server\nthat randomly assigns incoming requests to back-end servers.\nIf an attacker can observe the assignments and knows the\npredictable algorithm generating them,\nthen the attacker could send a stream\nof mostly cheap requests but arrange for all the expensive requests\nto land on a single back-end server.\nThis is an unlikely but plausible problem using the Go 1 generator.\nUsing Go 1.22, it’s not a problem at all.\u003c/p\u003e\n\u003cp\u003eIn all these examples, Go 1.22 has eliminated or greatly reduced\nsecurity problems.\u003c/p\u003e\n\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\n\u003cp\u003eThe security benefits of ChaCha8Rand do have a small cost,\nbut ChaCha8Rand is still in the same ballpark as both the Go 1 generator and PCG.\nThe following graphs compare the performance of the three generators,\nacross a variety of hardware, running two operations:\nthe primitive operation “Uint64,” which returns the next \u003ccode\u003euint64\u003c/code\u003e in the random stream,\nand the higher-level operation “N(1000),” which returns a random value in the range [0, 1000).\u003c/p\u003e\n\u003cdiv style=\"background-color: white;\"\u003e\n\u003cimg src=\"chacha8rand/amd.svg\"/\u003e\n\u003cimg src=\"chacha8rand/intel.svg\"/\u003e\n\u003cimg src=\"chacha8rand/amd32.svg\"/\u003e\n\u003cimg src=\"chacha8rand/intel32.svg\"/\u003e\n\u003cimg src=\"chacha8rand/m1.svg\"/\u003e\n\u003cimg src=\"chacha8rand/m3.svg\"/\u003e\n\u003cimg src=\"chacha8rand/taut2a.svg\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe “running 32-bit code” graphs show modern 64-bit x86 chips\nexecuting code built with \u003ccode\u003eGOARCH=386\u003c/code\u003e, meaning they are\nrunning in 32-bit mode.\nIn that case, the fact that PCG requires 128-bit multiplications\nmakes it slower than ChaCha8Rand, which only uses 32-bit SIMD arithmetic.\nActual 32-bit systems matter less every year,\nbut it is still interesting that ChaCha8Rand is faster than PCG\non those systems.\u003c/p\u003e\n\u003cp\u003eOn some systems, “Go 1: Uint64” is faster than “PCG: Uint64”,\nbut “Go 1: N(1000)” is slower than “PCG: N(1000)”.\nThis happens because “Go 1: N(1000)” is using \u003ccode\u003emath/rand\u003c/code\u003e’s algorithm for\nreducing a random \u003ccode\u003eint64\u003c/code\u003e down to a value in the range [0, 1000),\nand that algorithm does two 64-bit integer divide operations.\nIn contrast, “PCG: N(1000)” and “ChaCha8: N(1000)” use the \u003ca href=\"/blog/randv2#problem.rand\"\u003efaster \u003ccode\u003emath/rand/v2\u003c/code\u003e algorithm\u003c/a\u003e,\nwhich almost always avoids the divisions.\nRemoving the 64-bit divisions dominates the algorithm change\nfor 32-bit execution and on the Ampere.\u003c/p\u003e\n\u003cp\u003eOverall, ChaCha8Rand is slower than the Go 1 generator,\nbut it is never more than twice as slow, and on typical servers the\ndifference is never more than 3ns.\nVery few programs will be bottlenecked by this difference,\nand many programs will enjoy the improved security.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eGo 1.22 makes your programs more secure without any code changes.\nWe did this by identifying the common mistake of accidentally using \u003ccode\u003emath/rand\u003c/code\u003e\ninstead of \u003ccode\u003ecrypto/rand\u003c/code\u003e and then strengthening \u003ccode\u003emath/rand\u003c/code\u003e.\nThis is one small step in Go’s ongoing journey to keep programs\nsafe by default.\u003c/p\u003e\n\u003cp\u003eThese kinds of mistakes are not unique to Go.\nFor example, the npm \u003ccode\u003ekeypair\u003c/code\u003e package tries to generate an RSA key pair\nusing Web Crypto APIs, but if they’re not available, it falls back to JavaScript’s \u003ccode\u003eMath.random\u003c/code\u003e.\nThis is hardly an isolated case,\nand the security of our systems cannot depend on developers not making mistakes.\nInstead, we hope that eventually all programming languages\nwill move to cryptographically strong pseudorandom generators\neven for “mathematical” randomness,\neliminating this kind of mistake, or at least greatly reducing its blast radius.\nGo 1.22’s \u003ca href=\"https://c2sp.org/chacha8rand\" rel=\"noreferrer\" target=\"_blank\"\u003eChaCha8Rand\u003c/a\u003e implementation\nproves that this approach is competitive with other generators.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-05-02T00:00:00Z",
  "Author": "Russ Cox and Filippo Valsorda"
}