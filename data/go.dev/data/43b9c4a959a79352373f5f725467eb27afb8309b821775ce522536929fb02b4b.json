{
  "Source": "go.dev",
  "Title": "Debugging Go code (a status report)",
  "Link": "https://go.dev/blog/debug-status",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/debug-status\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eDebugging Go code (a status report)\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Luuk van Dijk\u003cbr/\u003e\n      2 November 2010\n      \u003c/p\u003e\n      \n      \u003cp\u003eWhen it comes to debugging, nothing beats a few strategic print statements\nto inspect variables or a well-placed panic to obtain a stack trace.\nHowever, sometimes you’re missing either the patience or the source code,\nand in those cases a good debugger can be invaluable.\nThat’s why over the past few releases we have been improving the support\nin Go’s gc linker (6l,\n8l) for GDB, the GNU debugger.\u003c/p\u003e\n\u003cp\u003eIn the latest release (2010-11-02), the 6l and 8l linkers emit DWARF3 debugging\ninformation when writing ELF (Linux,\nFreeBSD) or Mach-O (Mac OS X) binaries.\nThe DWARF code is rich enough to let you do the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eload a Go program in GDB version 7.x,\u003c/li\u003e\n\u003cli\u003elist all Go, C, and assembly source files by line (parts of the Go runtime are written in C and assembly),\u003c/li\u003e\n\u003cli\u003eset breakpoints by line and step through the code,\u003c/li\u003e\n\u003cli\u003eprint stack traces and inspect stack frames, and\u003c/li\u003e\n\u003cli\u003efind the addresses and print the contents of most variables.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere are still some inconveniences:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe emitted DWARF code is unreadable by the GDB version 6.x that ships with Mac OS X.\nWe would gladly accept patches to make the DWARF output compatible with\nthe standard OS X GDB,\nbut until that’s fixed you’ll need to download,\nbuild, and install GDB 7.x to use it under OS X.\nThe source can be found at \u003ca href=\"http://sourceware.org/gdb/download/\" rel=\"noreferrer\" target=\"_blank\"\u003ehttp://sourceware.org/gdb/download/\u003c/a\u003e.\nDue to the particulars of OS X you’ll need to install the binary on a\nlocal file system with \u003ccode\u003echgrp procmod\u003c/code\u003e and \u003ccode\u003echmod g+s\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eNames are qualified with a package name and,\nas GDB doesn’t understand Go packages, you must reference each item by its full name.\nFor example, the variable named \u003ccode\u003ev\u003c/code\u003e in package \u003ccode\u003emain\u003c/code\u003e must be referred to\nas \u003ccode\u003e\u0026#39;main.v\u0026#39;\u003c/code\u003e, in single quotes.\nA consequence of this is that tab completion of variable and function names does not work.\u003c/li\u003e\n\u003cli\u003eLexical scoping information is somewhat obfuscated.\nIf there are multiple variables of the same name,\nthe nth instance will have a suffix of the form ‘#n’.\nWe plan to fix this, but it will require some changes to the data exchanged\nbetween the compiler and linker.\u003c/li\u003e\n\u003cli\u003eSlice and string variables are represented as their underlying structure\nin the runtime library.\nThey will look something like \u003ccode\u003e{data = 0x2aaaaab3e320, len = 1, cap = 1}.\u003c/code\u003e For slices,\nyou must dereference the data pointer to inspect the elements.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSome things don’t work yet:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eChannel, function, interface, and map variables cannot be inspected.\u003c/li\u003e\n\u003cli\u003eOnly Go variables are annotated with type information; the runtime’s C variables are not.\u003c/li\u003e\n\u003cli\u003eWindows and ARM binaries do not contain DWARF debugging information and, as such, cannot be inspected with GDB.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOver the coming months we intend to address these issues,\neither by changing the compiler and linker or by using the Python extensions to GDB.\nIn the meantime, we hope that Go programmers will benefit from having better\naccess to this well-known debugging tool.\u003c/p\u003e\n\u003cp\u003eP.S. The DWARF information can also be read by tools other than GDB.\nFor example, on Linux you can use it with the sysprof system-wide profiler.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-11-02T00:00:00Z",
  "Author": "Luuk van Dijk"
}