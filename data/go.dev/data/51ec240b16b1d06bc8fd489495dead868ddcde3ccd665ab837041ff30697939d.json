{
  "Source": "go.dev",
  "Title": "Deploying Go servers with Docker",
  "Link": "https://go.dev/blog/docker",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/docker\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eDeploying Go servers with Docker\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      26 September 2014\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis week Docker \u003ca href=\"https://blog.docker.com/2014/09/docker-hub-official-repos-announcing-language-stacks/\" rel=\"noreferrer\" target=\"_blank\"\u003eannounced\u003c/a\u003e\nofficial base images for Go and other major languages,\ngiving programmers a trusted and easy way to build containers for their Go programs.\u003c/p\u003e\n\u003cp\u003eIn this article we’ll walk through a recipe for creating a Docker container for\na simple Go web application and deploying that container to Google Compute Engine.\nIf you’re not familiar with Docker, you should read\n\u003ca href=\"https://docs.docker.com/engine/understanding-docker/\" rel=\"noreferrer\" target=\"_blank\"\u003eUnderstanding Docker\u003c/a\u003e\nbefore reading on.\u003c/p\u003e\n\u003ch2 id=\"the-demo-app\"\u003eThe demo app\u003c/h2\u003e\n\u003cp\u003eFor our demonstration we will use the\n\u003ca href=\"https://pkg.go.dev/golang.org/x/example/outyet\" rel=\"noreferrer\" target=\"_blank\"\u003eoutyet\u003c/a\u003e program from the\n\u003ca href=\"https://cs.opensource.google/go/x/example\" rel=\"noreferrer\" target=\"_blank\"\u003eGo examples repository\u003c/a\u003e,\na simple web server that reports whether the next version of Go has been released\n(designed to power sites like \u003ca href=\"http://isgo1point4.outyet.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eisgo1point4.outyet.org\u003c/a\u003e).\nIt has no dependencies outside the standard library and requires no additional\ndata files at run time; for a web server, it’s about as simple as it gets.\u003c/p\u003e\n\u003cp\u003eUse “go get” to fetch and install outyet in your\n\u003ca href=\"/doc/code.html#Workspaces\"\u003eworkspace\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get golang.org/x/example/outyet\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"write-a-dockerfile\"\u003eWrite a Dockerfile\u003c/h2\u003e\n\u003cp\u003eReplace a file named \u003ccode\u003eDockerfile\u003c/code\u003e in the \u003ccode\u003eoutyet\u003c/code\u003e directory with the following contents:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# Start from a Debian image with the latest version of Go installed\n# and a workspace (GOPATH) configured at /go.\nFROM golang\n\n# Copy the local package files to the container\u0026#39;s workspace.\nADD . /go/src/golang.org/x/example/outyet\n\n# Build the outyet command inside the container.\n# (You may fetch or manage dependencies here,\n# either manually or with a tool like \u0026#34;godep\u0026#34;.)\nRUN go install golang.org/x/example/outyet\n\n# Run the outyet command by default when the container starts.\nENTRYPOINT /go/bin/outyet\n\n# Document that the service listens on port 8080.\nEXPOSE 8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis \u003ccode\u003eDockerfile\u003c/code\u003e specifies how to construct a container that runs \u003ccode\u003eoutyet\u003c/code\u003e,\nstarting with the basic dependencies (a Debian system with Go installed;\nthe \u003ca href=\"https://registry.hub.docker.com/_/golang/\" rel=\"noreferrer\" target=\"_blank\"\u003eofficial \u003ccode\u003egolang\u003c/code\u003e docker image\u003c/a\u003e),\nadding the \u003ccode\u003eoutyet\u003c/code\u003e package source, building it, and then finally running it.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eADD\u003c/code\u003e, \u003ccode\u003eRUN\u003c/code\u003e, and \u003ccode\u003eENTRYPOINT\u003c/code\u003e steps are common tasks for any Go project.\nTo simplify this, there is an\n\u003ca href=\"https://github.com/docker-library/golang/blob/9ff2ccca569f9525b023080540f1bb55f6b59d7f/1.3.1/onbuild/Dockerfile\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eonbuild\u003c/code\u003e variant\u003c/a\u003e\nof the \u003ccode\u003egolang\u003c/code\u003e image that automatically copies the package source, fetches the\napplication dependencies, builds the program, and configures it to run on\nstartup.\u003c/p\u003e\n\u003cp\u003eWith the \u003ccode\u003eonbuild\u003c/code\u003e variant, the \u003ccode\u003eDockerfile\u003c/code\u003e is much simpler:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFROM golang:onbuild\nEXPOSE 8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"build-and-run-the-image\"\u003eBuild and run the image\u003c/h2\u003e\n\u003cp\u003eInvoke Docker from the \u003ccode\u003eoutyet\u003c/code\u003e package directory to build an image using the \u003ccode\u003eDockerfile\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker build -t outyet .\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will fetch the \u003ccode\u003egolang\u003c/code\u003e base image from Docker Hub, copy the package source\nto it, build the package inside it, and tag the resulting image as \u003ccode\u003eoutyet\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo run a container from the resulting image:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker run --publish 6060:8080 --name test --rm outyet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e--publish\u003c/code\u003e flag tells docker to publish the container’s port \u003ccode\u003e8080\u003c/code\u003e on the\nexternal port \u003ccode\u003e6060\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--name\u003c/code\u003e flag gives our container a predictable name to make it easier to work with.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--rm\u003c/code\u003e flag tells docker to remove the container image when the outyet server exits.\u003c/p\u003e\n\u003cp\u003eWith the container running, open \u003ccode\u003ehttp://localhost:6060/\u003c/code\u003e in a web browser and\nyou should see something like this:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"docker/outyet.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003e(If your docker daemon is running on another machine (or in a virtual machine),\nyou should replace \u003ccode\u003elocalhost\u003c/code\u003e with the address of that machine. If you’re\nusing \u003ca href=\"http://boot2docker.io/\" rel=\"noreferrer\" target=\"_blank\"\u003eboot2docker\u003c/a\u003e on OS X or Windows you can find\nthat address with \u003ccode\u003eboot2docker ip\u003c/code\u003e.)\u003c/p\u003e\n\u003cp\u003eNow that we’ve verified that the image works, shut down the running container\nfrom another terminal window:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker stop test\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"create-a-repository-on-docker-hub\"\u003eCreate a repository on Docker Hub\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://hub.docker.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eDocker Hub\u003c/a\u003e, the container registry from which we\npulled the \u003ccode\u003egolang\u003c/code\u003e image earlier, offers a feature called\n\u003ca href=\"http://docs.docker.com/docker-hub/builds/\" rel=\"noreferrer\" target=\"_blank\"\u003eAutomated Builds\u003c/a\u003e that builds\nimages from a GitHub or BitBucket repository.\u003c/p\u003e\n\u003cp\u003eBy committing \u003ca href=\"https://go.googlesource.com/example/+/refs/heads/master/outyet/\" rel=\"noreferrer\" target=\"_blank\"\u003ethe Dockerfile\u003c/a\u003e\nto the repository and creating an\n\u003ca href=\"https://registry.hub.docker.com/u/adg1/outyet/\" rel=\"noreferrer\" target=\"_blank\"\u003eautomated build\u003c/a\u003e\nfor it, anyone with Docker installed can download and run our image with a\nsingle command. (We will see the utility of this in the next section.)\u003c/p\u003e\n\u003cp\u003eTo set up an Automated Build, commit the Dockerfile to your repo on\n\u003ca href=\"https://github.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub\u003c/a\u003e or \u003ca href=\"https://bitbucket.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eBitBucket\u003c/a\u003e,\ncreate an account on Docker Hub, and follow the instructions for\n\u003ca href=\"http://docs.docker.com/docker-hub/builds/\" rel=\"noreferrer\" target=\"_blank\"\u003ecreating an Automated Build\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eWhen you’re done, you can run your container using the name of the automated build:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ docker run goexample/outyet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Replace \u003ccode\u003egoexample/outyet\u003c/code\u003e with the name of the automated build you created.)\u003c/p\u003e\n\u003ch2 id=\"deploy-the-container-to-google-compute-engine\"\u003eDeploy the container to Google Compute Engine\u003c/h2\u003e\n\u003cp\u003eGoogle provides\n\u003ca href=\"https://developers.google.com/compute/docs/containers/container_vms\" rel=\"noreferrer\" target=\"_blank\"\u003econtainer-optimized Google Compute Engine images\u003c/a\u003e\nthat make it easy to spin up a virtual machine running an arbitrary Docker container.\nOn startup, a program running on the instance reads a configuration file that\nspecifies which container to run, fetches the container image, and runs it.\u003c/p\u003e\n\u003cp\u003eCreate a \u003ca href=\"https://cloud.google.com/compute/docs/containers/container_vms#container_manifest\" rel=\"noreferrer\" target=\"_blank\"\u003econtainers.yaml\u003c/a\u003e\nfile that specifies the docker image to run and the ports to expose:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eversion: v1beta2\ncontainers:\n- name: outyet\n  image: goexample/outyet\n  ports:\n  - name: http\n    hostPort: 80\n    containerPort: 8080\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Note that we’re publishing the container’s port \u003ccode\u003e8080\u003c/code\u003e as external port \u003ccode\u003e80\u003c/code\u003e,\nthe default port for serving HTTP traffic. And, again, you should replace\n\u003ccode\u003egoexample/outyet\u003c/code\u003e with the name of your Automated Build.)\u003c/p\u003e\n\u003cp\u003eUse the \u003ca href=\"https://cloud.google.com/sdk/#Quick_Start\" rel=\"noreferrer\" target=\"_blank\"\u003egcloud tool\u003c/a\u003e\nto create a VM instance running the container:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ gcloud compute instances create outyet \\\n    --image container-vm-v20140925 \\\n    --image-project google-containers \\\n    --metadata-from-file google-container-manifest=containers.yaml \\\n    --tags http-server \\\n    --zone us-central1-a \\\n    --machine-type f1-micro\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first argument (\u003ccode\u003eoutyet\u003c/code\u003e) specifies the instance name, a convenient label\nfor administrative purposes.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--image\u003c/code\u003e and \u003ccode\u003e--image-project\u003c/code\u003e flags specify the special\ncontainer-optimized system image to use (copy these flags verbatim).\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--metadata-from-file\u003c/code\u003e flag supplies your \u003ccode\u003econtainers.yaml\u003c/code\u003e file to the VM.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--tags\u003c/code\u003e flag tags your VM instance as an HTTP server, adjusting the\nfirewall to expose port 80 on the public network interface.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003e--zone\u003c/code\u003e and \u003ccode\u003e--machine-type\u003c/code\u003e flags specify the zone in which to run the VM\nand the type of machine to run. (To see a list of machine types and the zones,\nrun \u003ccode\u003egcloud compute machine-types list\u003c/code\u003e.)\u003c/p\u003e\n\u003cp\u003eOnce this has completed, the gcloud command should print some information about\nthe instance. In the output, locate the \u003ccode\u003enetworkInterfaces\u003c/code\u003e section to find the\ninstance’s external IP address. Within a couple of minutes you should be able\nto access that IP with your web browser and see the “Has Go 1.4 been released\nyet?” page.\u003c/p\u003e\n\u003cp\u003e(To see what’s happening on the new VM instance you can ssh into it with\n\u003ccode\u003egcloud compute ssh outyet\u003c/code\u003e. From there, try \u003ccode\u003esudo docker ps\u003c/code\u003e to see which\nDocker containers are running.)\u003c/p\u003e\n\u003ch2 id=\"learn-more\"\u003eLearn more\u003c/h2\u003e\n\u003cp\u003eThis is just the tip of the iceberg—there’s a lot more you can do with Go, Docker, and Google Compute Engine.\u003c/p\u003e\n\u003cp\u003eTo learn more about Docker, see their \u003ca href=\"https://docs.docker.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eextensive documentation\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo learn more about Docker and Go, see the \u003ca href=\"https://registry.hub.docker.com/_/golang/\" rel=\"noreferrer\" target=\"_blank\"\u003eofficial \u003ccode\u003egolang\u003c/code\u003e Docker Hub repository\u003c/a\u003e and Kelsey Hightower’s \u003ca href=\"https://medium.com/@kelseyhightower/optimizing-docker-images-for-static-binaries-b5696e26eb07\" rel=\"noreferrer\" target=\"_blank\"\u003eOptimizing Docker Images for Static Go Binaries\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTo learn more about Docker and \u003ca href=\"http://cloud.google.com/compute\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle Compute Engine\u003c/a\u003e,\nsee the \u003ca href=\"https://cloud.google.com/compute/docs/containers/container_vms\" rel=\"noreferrer\" target=\"_blank\"\u003eContainer-optimized VMs page\u003c/a\u003e\nand the \u003ca href=\"https://registry.hub.docker.com/u/google/docker-registry/\" rel=\"noreferrer\" target=\"_blank\"\u003egoogle/docker-registry Docker Hub repository\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-09-26T00:00:00Z",
  "Author": "Andrew Gerrand"
}