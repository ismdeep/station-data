{
  "Source": "go.dev",
  "Title": "WASI support in Go",
  "Link": "https://go.dev/blog/wasi",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/wasi\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eWASI support in Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Johan Brandhorst-Satzkorn, Julien Fabre, Damian Gryski, Evan Phoenix, and Achille Roussel\u003cbr/\u003e\n      13 September 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eGo 1.21 adds a new port targeting the WASI preview 1 syscall API through the\nnew \u003ccode\u003eGOOS\u003c/code\u003e value \u003ccode\u003ewasip1\u003c/code\u003e. This port builds on the existing WebAssembly\nport introduced in Go 1.11.\u003c/p\u003e\n\u003ch2 id=\"what-is-webassembly\"\u003eWhat is WebAssembly?\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://webassembly.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eWebAssembly (Wasm)\u003c/a\u003e is a binary instruction format\noriginally designed for the web. It represents a standard that allows\ndevelopers to run high-performance, low-level code directly in web browsers at\nnear-native speeds.\u003c/p\u003e\n\u003cp\u003eGo first added support for compiling to Wasm in the 1.11 release, through the\n\u003ccode\u003ejs/wasm\u003c/code\u003e port. This allowed Go code compiled using the Go compiler to be\nexecuted in web browsers, but it required a JavaScript execution environment.\u003c/p\u003e\n\u003cp\u003eAs the use of Wasm has grown, so have use cases outside of the browser. Many\ncloud providers are now offering services that allow the user to execute Wasm\nexecutables directly, leveraging the new\n\u003ca href=\"https://wasi.dev/\" rel=\"noreferrer\" target=\"_blank\"\u003eWebAssembly System Interface (WASI)\u003c/a\u003e syscall API.\u003c/p\u003e\n\u003ch2 id=\"the-webassembly-system-interface\"\u003eThe WebAssembly System Interface\u003c/h2\u003e\n\u003cp\u003eWASI defines a syscall API for Wasm executables, allowing them to interact with\nsystem resources such as the filesystem, the system clock, random data\nutilities, and more. The latest release of the WASI spec is called\n\u003ccode\u003ewasi_snapshot_preview1\u003c/code\u003e, from which we derive the \u003ccode\u003eGOOS\u003c/code\u003e name \u003ccode\u003ewasip1\u003c/code\u003e. New\nversions of the API are being developed, and supporting them in the Go\ncompiler in the future will likely mean adding a new \u003ccode\u003eGOOS\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe creation of WASI has allowed a number of Wasm runtimes (hosts) to\nstandardize their syscall API around it. Examples of Wasm/WASI hosts include\n\u003ca href=\"https://wasmtime.dev\" rel=\"noreferrer\" target=\"_blank\"\u003eWasmtime\u003c/a\u003e, \u003ca href=\"https://wazero.io/\" rel=\"noreferrer\" target=\"_blank\"\u003eWazero\u003c/a\u003e,\n\u003ca href=\"https://wasmedge.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eWasmEdge\u003c/a\u003e, \u003ca href=\"https://wasmer.io/\" rel=\"noreferrer\" target=\"_blank\"\u003eWasmer\u003c/a\u003e, and\n\u003ca href=\"https://nodejs.org\" rel=\"noreferrer\" target=\"_blank\"\u003eNodeJS\u003c/a\u003e. There are also a number of cloud providers\noffering hosting of Wasm/WASI executables.\u003c/p\u003e\n\u003ch2 id=\"how-can-we-use-it-with-go\"\u003eHow can we use it with Go?\u003c/h2\u003e\n\u003cp\u003eMake sure that you have installed at least version 1.21 of Go. For this demo,\nwe’ll use \u003ca href=\"https://docs.wasmtime.dev/cli-install.html\" rel=\"noreferrer\" target=\"_blank\"\u003ethe Wasmtime host\u003c/a\u003e to\nexecute our binary. Let’s start with a simple \u003ccode\u003emain.go\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    fmt.Println(\u0026#34;Hello world!\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can build it for \u003ccode\u003ewasip1\u003c/code\u003e using the command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ GOOS=wasip1 GOARCH=wasm go build -o main.wasm main.go\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will produce a file, \u003ccode\u003emain.wasm\u003c/code\u003e which we can execute with \u003ccode\u003ewasmtime\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ wasmtime main.wasm\nHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s all it takes to get started with Wasm/WASI! You can expect almost all\nthe features of Go to just work with \u003ccode\u003ewasip1\u003c/code\u003e. To learn more about the details\nof how WASI works with Go, please see\n\u003ca href=\"/issue/58141\"\u003ethe proposal\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"running-go-tests-with-wasip1\"\u003eRunning go tests with wasip1\u003c/h2\u003e\n\u003cp\u003eBuilding and running a binary is easy, but sometimes we want to be able to run\n\u003ccode\u003ego test\u003c/code\u003e directly without having to build and execute the binary manually.\nSimilar to the \u003ccode\u003ejs/wasm\u003c/code\u003e port, the standard library distribution included\nin your Go installation comes with a file that makes this very easy. Add the\n\u003ccode\u003emisc/wasm\u003c/code\u003e directory to your \u003ccode\u003ePATH\u003c/code\u003e when running Go tests and it will\nrun the tests using the Wasm host of your choice. This works by \u003ccode\u003ego test\u003c/code\u003e\n\u003ca href=\"https://pkg.go.dev/cmd/go#hdr-Compile_and_run_Go_program\" rel=\"noreferrer\" target=\"_blank\"\u003eautomatically executing\u003c/a\u003e\n\u003ccode\u003emisc/wasm/go_wasip1_wasm_exec\u003c/code\u003e when it finds this file in the \u003ccode\u003ePATH\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ export PATH=$PATH:$(go env GOROOT)/misc/wasm\n$ GOOS=wasip1 GOARCH=wasm go test ./...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis will run \u003ccode\u003ego test\u003c/code\u003e using Wasmtime. The Wasm host used can be controlled\nusing the environment variable \u003ccode\u003eGOWASIRUNTIME\u003c/code\u003e. Currently supported values\nfor this variable are \u003ccode\u003ewazero\u003c/code\u003e, \u003ccode\u003ewasmedge\u003c/code\u003e, \u003ccode\u003ewasmtime\u003c/code\u003e, and \u003ccode\u003ewasmer\u003c/code\u003e. This\nscript is subject to breaking changes between Go versions. Note that Go\n\u003ccode\u003ewasip1\u003c/code\u003e binaries don’t execute perfectly on all hosts yet (see\n\u003ca href=\"/issue/59907\"\u003e#59907\u003c/a\u003e and\n\u003ca href=\"/issue/60097\"\u003e#60097\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eThis functionality also works when using \u003ccode\u003ego run\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-shell\"\u003e$ GOOS=wasip1 GOARCH=wasm go run ./main.go\nHello world!\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"wrapping-wasm-functions-in-go-with-gowasmimport\"\u003eWrapping Wasm functions in Go with go:wasmimport\u003c/h2\u003e\n\u003cp\u003eIn addition to the new \u003ccode\u003ewasip1/wasm\u003c/code\u003e port, Go 1.21 introduces a new compiler\ndirective: \u003ccode\u003ego:wasmimport\u003c/code\u003e. It instructs the compiler to translate calls to\nthe annotated function into a call to the function specified by the host\nmodule name and function name. This new compiler functionality is what allowed\nus to define the \u003ccode\u003ewasip1\u003c/code\u003e syscall API in Go to support the new port, but it\nisn’t limited to being used in the standard library.\u003c/p\u003e\n\u003cp\u003eFor example, the wasip1 syscall API defines the\n\u003ca href=\"https://github.com/WebAssembly/WASI/blob/a51a66df5b1db01cf9e873f5537bc5bd552cf770/legacy/preview1/docs.md#-random_getbuf-pointeru8-buf_len-size---result-errno\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003erandom_get\u003c/code\u003e function\u003c/a\u003e,\nand it is exposed to the Go standard library through\n\u003ca href=\"https://cs.opensource.google/go/go/+/refs/tags/go1.21.0:src/runtime/os_wasip1.go;l=73-75\" rel=\"noreferrer\" target=\"_blank\"\u003ea function wrapper\u003c/a\u003e\ndefined in the runtime package. It looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003e//go:wasmimport wasi_snapshot_preview1 random_get\n//go:noescape\nfunc random_get(buf unsafe.Pointer, bufLen size) errno\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function wrapper is then wrapped in\n\u003ca href=\"https://cs.opensource.google/go/go/+/refs/tags/go1.21.0:src/runtime/os_wasip1.go;l=183-187\" rel=\"noreferrer\" target=\"_blank\"\u003ea more ergonomic function\u003c/a\u003e\nfor use in the standard library:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003efunc getRandomData(r []byte) {\n    if random_get(unsafe.Pointer(\u0026amp;r[0]), size(len(r))) != 0 {\n        throw(\u0026#34;random_get failed\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis way, a user can call \u003ccode\u003egetRandomData\u003c/code\u003e with a byte slice and it will\neventually make its way to the host-defined \u003ccode\u003erandom_get\u003c/code\u003e function. In the same\nway, users can define their own wrappers for host functions.\u003c/p\u003e\n\u003cp\u003eTo learn more about the intricacies of wrapping Wasm functions in Go, please\nsee \u003ca href=\"/issue/59149\"\u003ethe \u003ccode\u003ego:wasmimport\u003c/code\u003e proposal\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"limitations\"\u003eLimitations\u003c/h2\u003e\n\u003cp\u003eWhile the \u003ccode\u003ewasip1\u003c/code\u003e port passes all standard library tests, there are some\nnotable fundamental limitations of the Wasm architecture that may surprise\nusers.\u003c/p\u003e\n\u003cp\u003eWasm is a single threaded architecture with no parallelism. The scheduler can\nstill schedule goroutines to run concurrently, and standard in/out/error is\nnon-blocking, so a goroutine can execute while another reads or writes, but any\nhost function calls (such as requesting random data using the example above)\nwill cause all goroutines to block until the host function call has returned.\u003c/p\u003e\n\u003cp\u003eA notable missing feature in the \u003ccode\u003ewasip1\u003c/code\u003e API is a full implementation of\nnetwork sockets. \u003ccode\u003ewasip1\u003c/code\u003e only defines functions that operate on already opened\nsockets, making it impossible to support some of the most popular features of\nthe Go standard library, such as HTTP servers. Hosts like Wasmer and WasmEdge\nimplement extensions to the \u003ccode\u003ewasip1\u003c/code\u003e API, allowing the opening of network\nsockets. While these extensions are not implemented by the Go compiler, there\nexists a third party library,\n\u003ca href=\"https://github.com/stealthrocket/net\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egithub.com/stealthrocket/net\u003c/code\u003e\u003c/a\u003e, which\nuses \u003ccode\u003ego:wasmimport\u003c/code\u003e to allow the use of \u003ccode\u003enet.Dial\u003c/code\u003e and \u003ccode\u003enet.Listen\u003c/code\u003e on\nsupported Wasm hosts. This enables the creation of \u003ccode\u003enet/http\u003c/code\u003e servers and other\nnetwork related functionality when using this package.\u003c/p\u003e\n\u003ch2 id=\"the-future-of-wasm-in-go\"\u003eThe future of Wasm in Go\u003c/h2\u003e\n\u003cp\u003eThe addition of the \u003ccode\u003ewasip1/wasm\u003c/code\u003e port is just the beginning of the Wasm\ncapabilities we would like to bring to Go. Please keep an eye out on\n\u003ca href=\"https://github.com/golang/go/issues?q=is%3Aopen+is%3Aissue+label%3Aarch-wasm\" rel=\"noreferrer\" target=\"_blank\"\u003ethe issue tracker\u003c/a\u003e\nfor proposals around exporting Go functions to Wasm (\u003ccode\u003ego:wasmexport\u003c/code\u003e), a 32-bit\nport and future WASI API compatibility.\u003c/p\u003e\n\u003ch2 id=\"get-involved\"\u003eGet involved\u003c/h2\u003e\n\u003cp\u003eIf you are experimenting with and want to contribute to Wasm and Go, please get\ninvolved! The Go issue tracker tracks all in-progress work and the #webassembly\nchannel on \u003ca href=\"https://invite.slack.golangbridge.org/\" rel=\"noreferrer\" target=\"_blank\"\u003ethe Gophers Slack\u003c/a\u003e is a\ngreat place to discuss Go and WebAssembly. We look forward to hearing from you!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-09-13T00:00:00Z",
  "Author": "Johan Brandhorst-Satzkorn, Julien Fabre, Damian Gryski, Evan Phoenix, and Achille Roussel"
}