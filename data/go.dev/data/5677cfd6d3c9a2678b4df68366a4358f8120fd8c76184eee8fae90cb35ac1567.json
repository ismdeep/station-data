{
  "Source": "go.dev",
  "Title": "The first Go program",
  "Link": "https://go.dev/blog/first-go-program",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/first-go-program\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eThe first Go program\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      18 July 2013\n      \u003c/p\u003e\n      \n      \u003cp\u003eBrad Fitzpatrick and I (Andrew Gerrand) recently started restructuring\n\u003ca href=\"/cmd/godoc/\"\u003egodoc\u003c/a\u003e, and it occurred to me that it is one\nof the oldest Go programs.\nRobert Griesemer started writing it back in early 2009,\nand we’re still using it today.\u003c/p\u003e\n\u003cp\u003eWhen I \u003ca href=\"https://twitter.com/enneff/status/357403054632484865\" rel=\"noreferrer\" target=\"_blank\"\u003etweeted\u003c/a\u003e about\nthis, Dave Cheney replied with an \u003ca href=\"https://twitter.com/davecheney/status/357406479415914497\" rel=\"noreferrer\" target=\"_blank\"\u003einteresting question\u003c/a\u003e:\nwhat is the oldest Go program? Rob Pike dug into his mail and found it\nin an old message to Robert and Ken Thompson.\u003c/p\u003e\n\u003cp\u003eWhat follows is the first Go program. It was written by Rob in February 2008,\nwhen the team was just Rob, Robert, and Ken. They had a solid feature list\n(mentioned in \u003ca href=\"https://commandcenter.blogspot.com.au/2012/06/less-is-exponentially-more.html\" rel=\"noreferrer\" target=\"_blank\"\u003ethis blog post\u003c/a\u003e)\nand a rough language specification. Ken had just finished the first working version of\na Go compiler (it didn’t produce native code, but rather transliterated Go code\nto C for fast prototyping) and it was time to try writing a program with it.\u003c/p\u003e\n\u003cp\u003eRob sent mail to the “Go team”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFrom: Rob \u0026#39;Commander\u0026#39; Pike\nDate: Wed, Feb 6, 2008 at 3:42 PM\nTo: Ken Thompson, Robert Griesemer\nSubject: slist\n\nit works now.\n\nroro=% a.out\n(defn foo (add 12 34))\nreturn: icounter = 4440\nroro=%\n\nhere\u0026#39;s the code.\nsome ugly hackery to get around the lack of strings.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(The \u003ccode\u003eicounter\u003c/code\u003e line in the program output is the number of executed\nstatements, printed for debugging.)\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003epackage main\n\n\u003cspan class=\"comment\"\u003e// fake stuff\u003c/span\u003e\ntype char uint8;\n\n\u003cspan class=\"comment\"\u003e// const char TESTSTRING[] = \u0026#34;(defn foo (add \u0026#39;a \u0026#39;b))\\n\u0026#34;;\u003c/span\u003e\n\ntype Atom struct {\n        string  *[100]char;\n        integer int;\n        next    *Slist;  \u003cspan class=\"comment\"\u003e/* in hash bucket */\u003c/span\u003e\n}\n\ntype List struct {\n        car     *Slist;\n        cdr     *Slist;\n}\n\ntype Slist struct {\n        isatom          bool;\n        isstring        bool;\n        \u003cspan class=\"comment\"\u003e//union {\u003c/span\u003e\n        atom    Atom;\n        list    List;\n        \u003cspan class=\"comment\"\u003e//} u;\u003c/span\u003e\n\n        Free method();\n        Print method();\n        PrintOne method(doparen bool);\n        String method(*char \u0026lt;-);\n        Integer method(int \u0026lt;-);\n        Car method(*Slist \u0026lt;-);\n        Cdr method(*Slist \u0026lt;-);\n}\n\nmethod (this *Slist) Car(*Slist \u0026lt;-) {\n        return this.list.car;\n}\n\nmethod (this *Slist) Cdr(*Slist \u0026lt;-) {\n        return this.list.cdr;\n}\n\nmethod (this *Slist) String(*[100]char \u0026lt;-) {\n        return this.atom.string;\n}\n\nmethod (this *Slist) Integer(int \u0026lt;-) {\n        return this.atom.integer;\n}\n\nfunction OpenFile();\nfunction Parse(*Slist \u0026lt;-);\n\n\u003cspan class=\"comment\"\u003e//Slist* atom(char *s, int i);\u003c/span\u003e\n\nvar token int;\nvar peekc int = -1;\nvar lineno int32 = 1;\n\nvar input [100*1000]char;\nvar inputindex int = 0;\nvar tokenbuf [100]char;\n\nvar EOF int = -1;  \u003cspan class=\"comment\"\u003e// BUG should be const\u003c/span\u003e\n\nfunction main(int32 \u0026lt;-) {\n        var list *Slist;\n\n        OpenFile();\n        for ;; {\n                list = Parse();\n                if list == nil {\n                        break;\n                }\n                list.Print();\n                list.Free();\n                break;\n        }\n\n        return 0;\n}\n\nmethod (slist *Slist) Free(\u0026lt;-) {\n        if slist == nil {\n                return;\n        }\n        if slist.isatom {\n\u003cspan class=\"comment\"\u003e//              free(slist.String());\u003c/span\u003e\n        } else {\n                slist.Car().Free();\n                slist.Cdr().Free();\n        }\n\u003cspan class=\"comment\"\u003e//      free(slist);\u003c/span\u003e\n}\n\nmethod (slist *Slist) PrintOne(\u0026lt;- doparen bool) {\n        if slist == nil {\n                return;\n        }\n        if slist.isatom {\n                if slist.isstring {\n                        print(slist.String());\n                } else {\n                        print(slist.Integer());\n                }\n        } else {\n                if doparen {\n                        print(\u0026#34;(\u0026#34;);\n                }\n                slist.Car().PrintOne(true);\n                if slist.Cdr() != nil {\n                        print(\u0026#34; \u0026#34;);\n                        slist.Cdr().PrintOne(false);\n                }\n                if doparen {\n                        print(\u0026#34;)\u0026#34;);\n                }\n        }\n}\n\nmethod (slist *Slist) Print() {\n        slist.PrintOne(true);\n        print \u0026#34;\\n\u0026#34;;\n}\n\nfunction Get(int \u0026lt;-) {\n        var c int;\n\n        if peekc \u0026gt;= 0 {\n                c = peekc;\n                peekc = -1;\n        } else {\n                c = convert(int, input[inputindex]);\n                inputindex = inputindex + 1; \u003cspan class=\"comment\"\u003e// BUG should be incr one expr\u003c/span\u003e\n                if c == \u0026#39;\\n\u0026#39; {\n                        lineno = lineno + 1;\n                }\n                if c == \u0026#39;\\0\u0026#39; {\n                        inputindex = inputindex - 1;\n                        c = EOF;\n                }\n        }\n        return c;\n}\n\nfunction WhiteSpace(bool \u0026lt;- c int) {\n        return c == \u0026#39; \u0026#39; || c == \u0026#39;\\t\u0026#39; || c == \u0026#39;\\r\u0026#39; || c == \u0026#39;\\n\u0026#39;;\n}\n\nfunction NextToken() {\n        var i, c int;\n        var backslash bool;\n\n        tokenbuf[0] = \u0026#39;\\0\u0026#39;;     \u003cspan class=\"comment\"\u003e// clear previous token\u003c/span\u003e\n        c = Get();\n        while WhiteSpace(c)  {\n                c = Get();\n        }\n        switch c {\n                case EOF:\n                        token = EOF;\n                case \u0026#39;(\u0026#39;:\n                case \u0026#39;)\u0026#39;:\n                        token = c;\n                        break;\n                case:\n                        for i = 0; i \u0026lt; 100 - 1; {  \u003cspan class=\"comment\"\u003e// sizeof tokenbuf - 1\u003c/span\u003e\n                                tokenbuf[i] = convert(char, c);\n                                i = i + 1;\n                                c = Get();\n                                if c == EOF {\n                                        break;\n                                }\n                                if WhiteSpace(c) || c == \u0026#39;)\u0026#39; {\n                                        peekc = c;\n                                        break;\n                                }\n                        }\n                        if i \u0026gt;= 100 - 1 {  \u003cspan class=\"comment\"\u003e// sizeof tokenbuf - 1\u003c/span\u003e\n                                panic \u0026#34;atom too long\\n\u0026#34;;\n                        }\n                        tokenbuf[i] = \u0026#39;\\0\u0026#39;;\n                        if \u0026#39;0\u0026#39; \u0026lt;= tokenbuf[0] \u0026amp;\u0026amp; tokenbuf[0] \u0026lt;= \u0026#39;9\u0026#39; {\n                                token = \u0026#39;0\u0026#39;;\n                        } else {\n                                token = \u0026#39;A\u0026#39;;\n                        }\n        }\n}\n\nfunction Expect(\u0026lt;- c int) {\n        if token != c {\n                print \u0026#34;parse error: expected \u0026#34;, c, \u0026#34;\\n\u0026#34;;\n                panic \u0026#34;parse\u0026#34;;\n        }\n        NextToken();\n}\n\n\u003cspan class=\"comment\"\u003e// Parse a non-parenthesized list up to a closing paren or EOF\u003c/span\u003e\nfunction ParseList(*Slist \u0026lt;-) {\n        var slist, retval *Slist;\n\n        slist = new(Slist);\n        slist.list.car = nil;\n        slist.list.cdr = nil;\n        slist.isatom = false;\n        slist.isstring = false;\n\n        retval = slist;\n        for ;; {\n                slist.list.car = Parse();\n                if token == \u0026#39;)\u0026#39; {       \u003cspan class=\"comment\"\u003e// empty cdr\u003c/span\u003e\n                        break;\n                }\n                if token == EOF {       \u003cspan class=\"comment\"\u003e// empty cdr  BUG SHOULD USE ||\u003c/span\u003e\n                        break;\n                }\n                slist.list.cdr = new(Slist);\n                slist = slist.list.cdr;\n        }\n        return retval;\n}\n\nfunction atom(*Slist \u0026lt;- i int) {  \u003cspan class=\"comment\"\u003e// BUG: uses tokenbuf; should take argument\u003c/span\u003e\n        var h, length int;\n        var slist, tail *Slist;\n\n        slist = new(Slist);\n        if token == \u0026#39;0\u0026#39; {\n                slist.atom.integer = i;\n                slist.isstring = false;\n        } else {\n                slist.atom.string = new([100]char);\n                var i int;\n                for i = 0; ; i = i + 1 {\n                        (*slist.atom.string)[i] = tokenbuf[i];\n                        if tokenbuf[i] == \u0026#39;\\0\u0026#39; {\n                                break;\n                        }\n                }\n                \u003cspan class=\"comment\"\u003e//slist.atom.string = \u0026#34;hello\u0026#34;; // BUG! s; //= strdup(s);\u003c/span\u003e\n                slist.isstring = true;\n        }\n        slist.isatom = true;\n        return slist;\n}\n\nfunction atoi(int \u0026lt;-) {  \u003cspan class=\"comment\"\u003e// BUG: uses tokenbuf; should take argument\u003c/span\u003e\n        var v int = 0;\n        for i := 0; \u0026#39;0\u0026#39; \u0026lt;= tokenbuf[i] \u0026amp;\u0026amp; tokenbuf[i] \u0026lt;= \u0026#39;9\u0026#39;; i = i + 1 {\n                v = 10 * v + convert(int, tokenbuf[i] - \u0026#39;0\u0026#39;);\n        }\n        return v;\n}\n\nfunction Parse(*Slist \u0026lt;-) {\n        var slist *Slist;\n\n        if token == EOF || token == \u0026#39;)\u0026#39; {\n                return nil;\n        }\n        if token == \u0026#39;(\u0026#39; {\n                NextToken();\n                slist = ParseList();\n                Expect(\u0026#39;)\u0026#39;);\n                return slist;\n        } else {\n                \u003cspan class=\"comment\"\u003e// Atom\u003c/span\u003e\n                switch token {\n                        case EOF:\n                                return nil;\n                        case \u0026#39;0\u0026#39;:\n                                slist = atom(atoi());\n                        case \u0026#39;\u0026#34;\u0026#39;:\n                        case \u0026#39;A\u0026#39;:\n                                slist = atom(0);\n                        case:\n                                slist = nil;\n                                print \u0026#34;unknown token\u0026#34;; \u003cspan class=\"comment\"\u003e//, token, tokenbuf;\u003c/span\u003e\n                }\n                NextToken();\n                return slist;\n        }\n        return nil;\n}\n\nfunction OpenFile() {\n        \u003cspan class=\"comment\"\u003e//strcpy(input, TESTSTRING);\u003c/span\u003e\n        \u003cspan class=\"comment\"\u003e//inputindex = 0;\u003c/span\u003e\n        \u003cspan class=\"comment\"\u003e// (defn foo (add 12 34))\\n\u003c/span\u003e\n        inputindex = 0;\n        peekc = -1;  \u003cspan class=\"comment\"\u003e// BUG\u003c/span\u003e\n        EOF = -1;  \u003cspan class=\"comment\"\u003e// BUG\u003c/span\u003e\n        i := 0;\n        input[i] = \u0026#39;(\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;d\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;e\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;f\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;n\u0026#39;; i = i + 1;\n        input[i] = \u0026#39; \u0026#39;; i = i + 1;\n        input[i] = \u0026#39;f\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;o\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;o\u0026#39;; i = i + 1;\n        input[i] = \u0026#39; \u0026#39;; i = i + 1;\n        input[i] = \u0026#39;(\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;a\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;d\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;d\u0026#39;; i = i + 1;\n        input[i] = \u0026#39; \u0026#39;; i = i + 1;\n        input[i] = \u0026#39;1\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;2\u0026#39;; i = i + 1;\n        input[i] = \u0026#39; \u0026#39;; i = i + 1;\n        input[i] = \u0026#39;3\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;4\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;)\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;)\u0026#39;; i = i + 1;\n        input[i] = \u0026#39;\\n\u0026#39;; i = i + 1;\n        NextToken();\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe program parses and prints an\n\u003ca href=\"https://en.wikipedia.org/wiki/S-expression\" rel=\"noreferrer\" target=\"_blank\"\u003eS-expression\u003c/a\u003e.\nIt takes no user input and has no imports, relying only on the built-in\n\u003ccode\u003eprint\u003c/code\u003e facility for output.\nIt was written literally the first day there was a\n\u003ca href=\"/change/8b8615138da3\"\u003eworking but rudimentary compiler\u003c/a\u003e.\nMuch of the language wasn’t implemented and some of it wasn’t even specified.\u003c/p\u003e\n\u003cp\u003eStill, the basic flavor of the language today is recognizable in this program.\nType and variable declarations, control flow, and package statements haven’t\nchanged much.\u003c/p\u003e\n\u003cp\u003eBut there are many differences and absences.\nMost significant are the lack of concurrency and interfaces—both\nconsidered essential since day 1 but not yet designed.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003efunc\u003c/code\u003e was a \u003ccode\u003efunction\u003c/code\u003e, and its signature specified return values\n\u003cem\u003ebefore\u003c/em\u003e arguments, separating them with \u003ccode\u003e\u0026lt;-\u003c/code\u003e, which we now use as the channel\nsend/receive operator. For example, the \u003ccode\u003eWhiteSpace\u003c/code\u003e function takes the integer\n\u003ccode\u003ec\u003c/code\u003e and returns a boolean.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction WhiteSpace(bool \u0026lt;- c int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis arrow was a stop-gap measure until a better syntax arose for declaring\nmultiple return values.\u003c/p\u003e\n\u003cp\u003eMethods were distinct from functions and had their own keyword.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emethod (this *Slist) Car(*Slist \u0026lt;-) {\n    return this.list.car;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd methods were pre-declared in the struct definition, although that changed soon.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Slist struct {\n    ...\n    Car method(*Slist \u0026lt;-);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere were no strings, although they were in the spec.\nTo work around this, Rob had to build the input string as an \u003ccode\u003euint8\u003c/code\u003e array with\na clumsy construction. (Arrays were rudimentary and slices hadn’t been designed\nyet, let alone implemented, although there was the unimplemented concept of an\n“open array”.)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einput[i] = \u0026#39;(\u0026#39;; i = i + 1;\ninput[i] = \u0026#39;d\u0026#39;; i = i + 1;\ninput[i] = \u0026#39;e\u0026#39;; i = i + 1;\ninput[i] = \u0026#39;f\u0026#39;; i = i + 1;\ninput[i] = \u0026#39;n\u0026#39;; i = i + 1;\ninput[i] = \u0026#39; \u0026#39;; i = i + 1;\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBoth \u003ccode\u003epanic\u003c/code\u003e and \u003ccode\u003eprint\u003c/code\u003e were built-in keywords, not pre-declared functions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprint \u0026#34;parse error: expected \u0026#34;, c, \u0026#34;\\n\u0026#34;;\npanic \u0026#34;parse\u0026#34;;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd there are many other little differences; see if you can identify some others.\u003c/p\u003e\n\u003cp\u003eLess than two years after this program was written, Go was released as an\nopen source project. Looking back, it is striking how much the language has\ngrown and matured. (The last thing to change between this proto-Go and the Go\nwe know today was the elimination of semicolons.)\u003c/p\u003e\n\u003cp\u003eBut even more striking is how much we have learned about \u003cem\u003ewriting\u003c/em\u003e Go code.\nFor instance, Rob called his method receivers \u003ccode\u003ethis\u003c/code\u003e, but now we use shorter\ncontext-specific names. There are hundreds of more significant examples\nand to this day we’re still discovering better ways to write Go code.\n(Check out the \u003ca href=\"https://github.com/golang/glog\" rel=\"noreferrer\" target=\"_blank\"\u003eglog package\u003c/a\u003e’s clever trick for\n\u003ca href=\"https://github.com/golang/glog/blob/c6f9652c7179652e2fd8ed7002330db089f4c9db/glog.go#L893\" rel=\"noreferrer\" target=\"_blank\"\u003ehandling verbosity levels\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eI wonder what we’ll learn tomorrow.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-07-18T00:00:00Z",
  "Author": "Andrew Gerrand"
}