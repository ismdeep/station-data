{
  "Source": "go.dev",
  "Title": "Go's Declaration Syntax",
  "Link": "https://go.dev/blog/declaration-syntax",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/declaration-syntax\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo\u0026#39;s Declaration Syntax\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      7 July 2010\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eNewcomers to Go wonder why the declaration syntax is different from the\ntradition established in the C family.\nIn this post we’ll compare the two approaches and explain why Go’s declarations look as they do.\u003c/p\u003e\n\u003ch2 id=\"c-syntax\"\u003eC syntax\u003c/h2\u003e\n\u003cp\u003eFirst, let’s talk about C syntax. C took an unusual and clever approach\nto declaration syntax.\nInstead of describing the types with special syntax,\none writes an expression involving the item being declared,\nand states what type that expression will have. Thus\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint x;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edeclares x to be an int: the expression ‘x’ will have type int.\nIn general, to figure out how to write the type of a new variable,\nwrite an expression involving that variable that evaluates to a basic type,\nthen put the basic type on the left and the expression on the right.\u003c/p\u003e\n\u003cp\u003eThus, the declarations\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint *p;\nint a[3];\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003estate that p is a pointer to int because ‘*p’ has type int,\nand that a is an array of ints because a[3] (ignoring the particular index value,\nwhich is punned to be the size of the array) has type int.\u003c/p\u003e\n\u003cp\u003eWhat about functions? Originally, C’s function declarations wrote the types\nof the arguments outside the parens, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint main(argc, argv)\n    int argc;\n    char *argv[];\n{ /* ... */ }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, we see that main is a function because the expression main(argc,\nargv) returns an int.\nIn modern notation we’d write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint main(int argc, char *argv[]) { /* ... */ }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebut the basic structure is the same.\u003c/p\u003e\n\u003cp\u003eThis is a clever syntactic idea that works well for simple types but can get confusing fast.\nThe famous example is declaring a function pointer.\nFollow the rules and you get this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint (*fp)(int a, int b);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, fp is a pointer to a function because if you write the expression (*fp)(a,\nb) you’ll call a function that returns int.\nWhat if one of fp’s arguments is itself a function?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint (*fp)(int (*ff)(int x, int y), int b)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s starting to get hard to read.\u003c/p\u003e\n\u003cp\u003eOf course, we can leave out the name of the parameters when we declare a function, so main can be declared\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint main(int, char *[])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRecall that argv is declared like this,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003echar *argv[]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eso you drop the name from the middle of its declaration to construct its type.\nIt’s not obvious, though, that you declare something of type char *[] by\nputting its name in the middle.\u003c/p\u003e\n\u003cp\u003eAnd look what happens to fp’s declaration if you don’t name the parameters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint (*fp)(int (*)(int, int), int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNot only is it not obvious where to put the name inside\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint (*)(int, int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eit’s not exactly clear that it’s a function pointer declaration at all.\nAnd what if the return type is a function pointer?\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint (*(*fp)(int (*)(int, int), int))(int, int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s hard even to see that this declaration is about fp.\u003c/p\u003e\n\u003cp\u003eYou can construct more elaborate examples but these should illustrate some\nof the difficulties that C’s declaration syntax can introduce.\u003c/p\u003e\n\u003cp\u003eThere’s one more point that needs to be made, though.\nBecause type and declaration syntax are the same,\nit can be difficult to parse expressions with types in the middle.\nThis is why, for instance, C casts always parenthesize the type, as in\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(int)M_PI\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"go-syntax\"\u003eGo syntax\u003c/h2\u003e\n\u003cp\u003eLanguages outside the C family usually use a distinct type syntax in declarations.\nAlthough it’s a separate point, the name usually comes first,\noften followed by a colon.\nThus our examples above become something like (in a fictional but illustrative language)\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ex: int\np: pointer to int\na: array[3] of int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese declarations are clear, if verbose - you just read them left to right.\nGo takes its cue from here, but in the interests of brevity it drops the\ncolon and removes some of the keywords:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ex int\np *int\na [3]int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is no direct correspondence between the look of [3]int and how to\nuse a in an expression.\n(We’ll come back to pointers in the next section.) You gain clarity at the\ncost of a separate syntax.\u003c/p\u003e\n\u003cp\u003eNow consider functions. Let’s transcribe the declaration for main as it would read in Go,\nalthough the real main function in Go takes no arguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc main(argc int, argv []string) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuperficially that’s not much different from C,\nother than the change from \u003ccode\u003echar\u003c/code\u003e arrays to strings,\nbut it reads well from left to right:\u003c/p\u003e\n\u003cp\u003efunction main takes an int and a slice of strings and returns an int.\u003c/p\u003e\n\u003cp\u003eDrop the parameter names and it’s just as clear - they’re always first so there’s no confusion.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc main(int, []string) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne merit of this left-to-right style is how well it works as the types\nbecome more complex.\nHere’s a declaration of a function variable (analogous to a function pointer in C):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef func(func(int,int) int, int) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr if f returns a function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef func(func(int,int) int, int) func(int, int) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt still reads clearly, from left to right,\nand it’s always obvious which name is being declared - the name comes first.\u003c/p\u003e\n\u003cp\u003eThe distinction between type and expression syntax makes it easy to write and invoke closures in Go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esum := func(a, b int) int { return a+b } (3, 4)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"pointers\"\u003ePointers\u003c/h2\u003e\n\u003cp\u003ePointers are the exception that proves the rule.\nNotice that in arrays and slices, for instance,\nGo’s type syntax puts the brackets on the left of the type but the expression\nsyntax puts them on the right of the expression:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar a []int\nx = a[1]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor familiarity, Go’s pointers use the * notation from C,\nbut we could not bring ourselves to make a similar reversal for pointer types.\nThus pointers work like this\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar p *int\nx = *p\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe couldn’t say\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar p *int\nx = p*\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebecause that postfix * would conflate with multiplication. We could have used the Pascal ^, for example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar p ^int\nx = p^\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand perhaps we should have (and chosen another operator for xor),\nbecause the prefix asterisk on both types and expressions complicates things\nin a number of ways.\nFor instance, although one can write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[]int(\u0026#34;hi\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eas a conversion, one must parenthesize the type if it starts with a *:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(*int)(nil)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHad we been willing to give up * as pointer syntax, those parentheses would be unnecessary.\u003c/p\u003e\n\u003cp\u003eSo Go’s pointer syntax is tied to the familiar C form,\nbut those ties mean that we cannot break completely from using parentheses\nto disambiguate types and expressions in the grammar.\u003c/p\u003e\n\u003cp\u003eOverall, though, we believe Go’s type syntax is easier to understand than C’s, especially when things get complicated.\u003c/p\u003e\n\u003ch2 id=\"notes\"\u003eNotes\u003c/h2\u003e\n\u003cp\u003eGo’s declarations read left to right. It’s been pointed out that C’s read in a spiral!\nSee \u003ca href=\"http://c-faq.com/decl/spiral.anderson.html\" rel=\"noreferrer\" target=\"_blank\"\u003e The “Clockwise/Spiral Rule”\u003c/a\u003e by David Anderson.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-07-07T00:00:00Z",
  "Author": "Rob Pike"
}