{
  "Source": "go.dev",
  "Title": "The Go image package",
  "Link": "https://go.dev/blog/image",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/image\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eThe Go image package\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Nigel Tao\u003cbr/\u003e\n      21 September 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/image/\"\u003eimage\u003c/a\u003e and \u003ca href=\"/pkg/image/color/\"\u003eimage/color\u003c/a\u003e\npackages define a number of types:\n\u003ccode\u003ecolor.Color\u003c/code\u003e and \u003ccode\u003ecolor.Model\u003c/code\u003e describe colors,\n\u003ccode\u003eimage.Point\u003c/code\u003e and \u003ccode\u003eimage.Rectangle\u003c/code\u003e describe basic 2-D geometry,\nand \u003ccode\u003eimage.Image\u003c/code\u003e brings the two concepts together to represent a rectangular grid of colors.\nA \u003ca href=\"/doc/articles/image_draw.html\"\u003eseparate article\u003c/a\u003e\ncovers image composition with the \u003ca href=\"/pkg/image/draw/\"\u003eimage/draw\u003c/a\u003e package.\u003c/p\u003e\n\u003ch2 id=\"colors-and-color-models\"\u003eColors and Color Models\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/pkg/image/color/#Color\"\u003eColor\u003c/a\u003e is an interface that\ndefines the minimal method set of any type that can be considered a color:\none that can be converted to red, green, blue and alpha values.\nThe conversion may be lossy, such as converting from CMYK or YCbCr color spaces.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Color interface {\n    // RGBA returns the alpha-premultiplied red, green, blue and alpha values\n    // for the color. Each value ranges within [0, 0xFFFF], but is represented\n    // by a uint32 so that multiplying by a blend factor up to 0xFFFF will not\n    // overflow.\n    RGBA() (r, g, b, a uint32)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are three important subtleties about the return values.\nFirst, the red, green and blue are alpha-premultiplied:\na fully saturated red that is also 25% transparent is represented by RGBA returning a 75% r.\nSecond, the channels have a 16-bit effective range:\n100% red is represented by RGBA returning an r of 65535,\nnot 255, so that converting from CMYK or YCbCr is not as lossy.\nThird, the type returned is \u003ccode\u003euint32\u003c/code\u003e, even though the maximum value is 65535,\nto guarantee that multiplying two values together won’t overflow.\nSuch multiplications occur when blending two colors according to an alpha\nmask from a third color,\nin the style of \u003ca href=\"https://en.wikipedia.org/wiki/Alpha_compositing\" rel=\"noreferrer\" target=\"_blank\"\u003ePorter and Duff’s\u003c/a\u003e classic algebra:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edstr, dstg, dstb, dsta := dst.RGBA()\nsrcr, srcg, srcb, srca := src.RGBA()\n_, _, _, m := mask.RGBA()\nconst M = 1\u0026lt;\u0026lt;16 - 1\n// The resultant red value is a blend of dstr and srcr, and ranges in [0, M].\n// The calculation for green, blue and alpha is similar.\ndstr = (dstr*(M-m) + srcr*m) / M\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe last line of that code snippet would have been more complicated if we\nworked with non-alpha-premultiplied colors,\nwhich is why \u003ccode\u003eColor\u003c/code\u003e uses alpha-premultiplied values.\u003c/p\u003e\n\u003cp\u003eThe image/color package also defines a number of concrete types that implement\nthe \u003ccode\u003eColor\u003c/code\u003e interface.\nFor example, \u003ca href=\"/pkg/image/color/#RGBA\"\u003e\u003ccode\u003eRGBA\u003c/code\u003e\u003c/a\u003e is a struct\nthat represents the classic “8 bits per channel” color.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype RGBA struct {\n    R, G, B, A uint8\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that the \u003ccode\u003eR\u003c/code\u003e field of an \u003ccode\u003eRGBA\u003c/code\u003e is an 8-bit alpha-premultiplied color\nin the range [0, 255].\n\u003ccode\u003eRGBA\u003c/code\u003e satisfies the \u003ccode\u003eColor\u003c/code\u003e interface by multiplying that value by 0x101\nto generate a 16-bit alpha-premultiplied color in the range [0, 65535].\nSimilarly, the \u003ca href=\"/pkg/image/color/#NRGBA\"\u003e\u003ccode\u003eNRGBA\u003c/code\u003e\u003c/a\u003e struct\ntype represents an 8-bit non-alpha-premultiplied color,\nas used by the PNG image format.\nWhen manipulating an \u003ccode\u003eNRGBA\u003c/code\u003e’s fields directly,\nthe values are non-alpha-premultiplied, but when calling the \u003ccode\u003eRGBA\u003c/code\u003e method,\nthe return values are alpha-premultiplied.\u003c/p\u003e\n\u003cp\u003eA \u003ca href=\"/pkg/image/color/#Model\"\u003e\u003ccode\u003eModel\u003c/code\u003e\u003c/a\u003e is simply something\nthat can convert \u003ccode\u003eColor\u003c/code\u003es to other \u003ccode\u003eColor\u003c/code\u003es, possibly lossily.\nFor example, the \u003ccode\u003eGrayModel\u003c/code\u003e can convert any \u003ccode\u003eColor\u003c/code\u003e to a desaturated \u003ca href=\"/pkg/image/color/#Gray\"\u003e\u003ccode\u003eGray\u003c/code\u003e\u003c/a\u003e.\nA \u003ccode\u003ePalette\u003c/code\u003e can convert any \u003ccode\u003eColor\u003c/code\u003e to one from a limited palette.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Model interface {\n    Convert(c Color) Color\n}\n\ntype Palette []Color\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"points-and-rectangles\"\u003ePoints and Rectangles\u003c/h2\u003e\n\u003cp\u003eA \u003ca href=\"/pkg/image/#Point\"\u003e\u003ccode\u003ePoint\u003c/code\u003e\u003c/a\u003e is an (x,\ny) co-ordinate on the integer grid, with axes increasing right and down.\nIt is neither a pixel nor a grid square. A \u003ccode\u003ePoint\u003c/code\u003e has no intrinsic width,\nheight or color, but the visualizations below use a small colored square.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Point struct {\n    X, Y int\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image/image-package-01.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003ep := image.Point{2, 1}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA \u003ca href=\"/pkg/image/#Rectangle\"\u003e\u003ccode\u003eRectangle\u003c/code\u003e\u003c/a\u003e is an axis-aligned\nrectangle on the integer grid,\ndefined by its top-left and bottom-right \u003ccode\u003ePoint\u003c/code\u003e.\nA \u003ccode\u003eRectangle\u003c/code\u003e also has no intrinsic color,\nbut the visualizations below outline rectangles with a thin colored line,\nand call out their \u003ccode\u003eMin\u003c/code\u003e and \u003ccode\u003eMax\u003c/code\u003e \u003ccode\u003ePoint\u003c/code\u003es.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Rectangle struct {\n    Min, Max Point\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor convenience, \u003ccode\u003eimage.Rect(x0, y0, x1, y1)\u003c/code\u003e is equivalent to \u003ccode\u003eimage.Rectangle{image.Point{x0, y0}, image.Point{x1, y1}}\u003c/code\u003e,\nbut is much easier to type.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eRectangle\u003c/code\u003e is inclusive at the top-left and exclusive at the bottom-right.\nFor a \u003ccode\u003ePoint p\u003c/code\u003e and a \u003ccode\u003eRectangle r\u003c/code\u003e, \u003ccode\u003ep.In(r)\u003c/code\u003e if and only if \u003ccode\u003er.Min.X \u0026lt;= p.X \u0026amp;\u0026amp; p.X \u0026lt; r.Max.X\u003c/code\u003e,\nand similarly for \u003ccode\u003eY\u003c/code\u003e.\nThis is analogous to how a slice \u003ccode\u003es[i0:i1]\u003c/code\u003e is inclusive at the low end\nand exclusive at the high end.\n(Unlike arrays and slices, a \u003ccode\u003eRectangle\u003c/code\u003e often has a non-zero origin.)\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image/image-package-02.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003er := image.Rect(2, 1, 5, 5)\n// Dx and Dy return a rectangle\u0026#39;s width and height.\nfmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAdding a \u003ccode\u003ePoint\u003c/code\u003e to a \u003ccode\u003eRectangle\u003c/code\u003e translates the \u003ccode\u003eRectangle\u003c/code\u003e.\nPoints and Rectangles are not restricted to be in the bottom-right quadrant.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image/image-package-03.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003er := image.Rect(2, 1, 5, 5).Add(image.Pt(-4, -2))\nfmt.Println(r.Dx(), r.Dy(), image.Pt(0, 0).In(r)) // prints 3 4 true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIntersecting two Rectangles yields another Rectangle, which may be empty.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image/image-package-04.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003er := image.Rect(0, 0, 4, 3).Intersect(image.Rect(2, 2, 5, 5))\n// Size returns a rectangle\u0026#39;s width and height, as a Point.\nfmt.Printf(\u0026#34;%#v\\n\u0026#34;, r.Size()) // prints image.Point{X:2, Y:1}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePoints and Rectangles are passed and returned by value.\nA function that takes a \u003ccode\u003eRectangle\u003c/code\u003e argument will be as efficient as a function\nthat takes two \u003ccode\u003ePoint\u003c/code\u003e arguments,\nor four \u003ccode\u003eint\u003c/code\u003e arguments.\u003c/p\u003e\n\u003ch2 id=\"images\"\u003eImages\u003c/h2\u003e\n\u003cp\u003eAn \u003ca href=\"/pkg/image/#Image\"\u003eImage\u003c/a\u003e maps every grid square\nin a \u003ccode\u003eRectangle\u003c/code\u003e to a \u003ccode\u003eColor\u003c/code\u003e from a \u003ccode\u003eModel\u003c/code\u003e.\n“The pixel at (x, y)” refers to the color of the grid square defined by the points (x,\ny), (x+1, y), (x+1, y+1) and (x, y+1).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Image interface {\n    // ColorModel returns the Image\u0026#39;s color model.\n    ColorModel() color.Model\n    // Bounds returns the domain for which At can return non-zero color.\n    // The bounds do not necessarily contain the point (0, 0).\n    Bounds() Rectangle\n    // At returns the color of the pixel at (x, y).\n    // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\n    // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\n    At(x, y int) color.Color\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA common mistake is assuming that an \u003ccode\u003eImage\u003c/code\u003e’s bounds start at (0, 0).\nFor example, an animated GIF contains a sequence of Images,\nand each \u003ccode\u003eImage\u003c/code\u003e after the first typically only holds pixel data for the area that changed,\nand that area doesn’t necessarily start at (0, 0).\nThe correct way to iterate over an \u003ccode\u003eImage\u003c/code\u003e m’s pixels looks like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := m.Bounds()\nfor y := b.Min.Y; y \u0026lt; b.Max.Y; y++ {\n for x := b.Min.X; x \u0026lt; b.Max.X; x++ {\n  doStuffWith(m.At(x, y))\n }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eImage\u003c/code\u003e implementations do not have to be based on an in-memory slice of pixel data.\nFor example, a \u003ca href=\"/pkg/image/#Uniform\"\u003e\u003ccode\u003eUniform\u003c/code\u003e\u003c/a\u003e is an\n\u003ccode\u003eImage\u003c/code\u003e of enormous bounds and uniform color,\nwhose in-memory representation is simply that color.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Uniform struct {\n    C color.Color\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypically, though, programs will want an image based on a slice.\nStruct types like \u003ca href=\"/pkg/image/#RGBA\"\u003e\u003ccode\u003eRGBA\u003c/code\u003e\u003c/a\u003e and \u003ca href=\"/pkg/image/#Gray\"\u003e\u003ccode\u003eGray\u003c/code\u003e\u003c/a\u003e\n(which other packages refer to as \u003ccode\u003eimage.RGBA\u003c/code\u003e and \u003ccode\u003eimage.Gray\u003c/code\u003e) hold slices\nof pixel data and implement the \u003ccode\u003eImage\u003c/code\u003e interface.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype RGBA struct {\n    // Pix holds the image\u0026#39;s pixels, in R, G, B, A order. The pixel at\n    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].\n    Pix []uint8\n    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n    Stride int\n    // Rect is the image\u0026#39;s bounds.\n    Rect Rectangle\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese types also provide a \u003ccode\u003eSet(x, y int, c color.Color)\u003c/code\u003e method that allows modifying the image one pixel at a time.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em := image.NewRGBA(image.Rect(0, 0, 640, 480))\nm.Set(5, 5, color.RGBA{255, 0, 0, 255})\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you’re reading or writing a lot of pixel data,\nit can be more efficient, but more complicated,\nto access these struct type’s \u003ccode\u003ePix\u003c/code\u003e field directly.\u003c/p\u003e\n\u003cp\u003eThe slice-based \u003ccode\u003eImage\u003c/code\u003e implementations also provide a \u003ccode\u003eSubImage\u003c/code\u003e method,\nwhich returns an \u003ccode\u003eImage\u003c/code\u003e backed by the same array.\nModifying the pixels of a sub-image will affect the pixels of the original image,\nanalogous to how modifying the contents of a sub-slice \u003ccode\u003es[i0:i1]\u003c/code\u003e will affect\nthe contents of the original slice \u003ccode\u003es\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image/image-package-05.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cpre\u003e\u003ccode\u003em0 := image.NewRGBA(image.Rect(0, 0, 8, 5))\nm1 := m0.SubImage(image.Rect(1, 2, 5, 5)).(*image.RGBA)\nfmt.Println(m0.Bounds().Dx(), m1.Bounds().Dx()) // prints 8, 4\nfmt.Println(m0.Stride == m1.Stride)             // prints true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor low-level code that works on an image’s \u003ccode\u003ePix\u003c/code\u003e field,\nbe aware that ranging over \u003ccode\u003ePix\u003c/code\u003e can affect pixels outside an image’s bounds.\nIn the example above, the pixels covered by \u003ccode\u003em1.Pix\u003c/code\u003e are shaded in blue.\nHigher-level code, such as the \u003ccode\u003eAt\u003c/code\u003e and \u003ccode\u003eSet\u003c/code\u003e methods or the \u003ca href=\"/pkg/image/draw/\"\u003eimage/draw package\u003c/a\u003e,\nwill clip their operations to the image’s bounds.\u003c/p\u003e\n\u003ch2 id=\"image-formats\"\u003eImage Formats\u003c/h2\u003e\n\u003cp\u003eThe standard package library supports a number of common image formats,\nsuch as GIF, JPEG and PNG.\nIf you know the format of a source image file,\nyou can decode from an \u003ca href=\"/pkg/io/#Reader\"\u003e\u003ccode\u003eio.Reader\u003c/code\u003e\u003c/a\u003e directly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport (\n \u0026#34;image/jpeg\u0026#34;\n \u0026#34;image/png\u0026#34;\n \u0026#34;io\u0026#34;\n)\n\n// convertJPEGToPNG converts from JPEG to PNG.\nfunc convertJPEGToPNG(w io.Writer, r io.Reader) error {\n img, err := jpeg.Decode(r)\n if err != nil {\n  return err\n }\n return png.Encode(w, img)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you have image data of unknown format,\nthe \u003ca href=\"/pkg/image/#Decode\"\u003e\u003ccode\u003eimage.Decode\u003c/code\u003e\u003c/a\u003e function can detect the format.\nThe set of recognized formats is constructed at run time and is not limited\nto those in the standard package library.\nAn image format package typically registers its format in an init function,\nand the main package will “underscore import” such a package solely for\nthe side effect of format registration.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport (\n \u0026#34;image\u0026#34;\n \u0026#34;image/png\u0026#34;\n \u0026#34;io\u0026#34;\n\n _ \u0026#34;code.google.com/p/vp8-go/webp\u0026#34;\n _ \u0026#34;image/jpeg\u0026#34;\n)\n\n// convertToPNG converts from any recognized format to PNG.\nfunc convertToPNG(w io.Writer, r io.Reader) error {\n img, _, err := image.Decode(r)\n if err != nil {\n  return err\n }\n return png.Encode(w, img)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-09-21T00:00:00Z",
  "Author": "Nigel Tao"
}