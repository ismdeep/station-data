{
  "Source": "go.dev",
  "Title": "Arrays, slices (and strings): The mechanics of 'append'",
  "Link": "https://go.dev/blog/slices",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/slices\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eArrays, slices (and strings): The mechanics of \u0026#39;append\u0026#39;\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      26 September 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eOne of the most common features of procedural programming languages is\nthe concept of an array.\nArrays seem like simple things but there are many questions that must be\nanswered when adding them to a language, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003efixed-size or variable-size?\u003c/li\u003e\n\u003cli\u003eis the size part of the type?\u003c/li\u003e\n\u003cli\u003ewhat do multidimensional arrays look like?\u003c/li\u003e\n\u003cli\u003edoes the empty array have meaning?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe answers to these questions affect whether arrays are just\na feature of the language or a core part of its design.\u003c/p\u003e\n\u003cp\u003eIn the early development of Go, it took about a year to decide the answers\nto these questions before the design felt right.\nThe key step was the introduction of \u003cem\u003eslices\u003c/em\u003e, which built on fixed-size\n\u003cem\u003earrays\u003c/em\u003e to give a flexible, extensible data structure.\nTo this day, however, programmers new to Go often stumble over the way slices\nwork, perhaps because experience from other languages has colored their thinking.\u003c/p\u003e\n\u003cp\u003eIn this post we’ll attempt to clear up the confusion.\nWe’ll do so by building up the pieces to explain how the \u003ccode\u003eappend\u003c/code\u003e built-in function\nworks, and why it works the way it does.\u003c/p\u003e\n\u003ch2 id=\"arrays\"\u003eArrays\u003c/h2\u003e\n\u003cp\u003eArrays are an important building block in Go, but like the foundation of a building\nthey are often hidden below more visible components.\nWe must talk about them briefly before we move on to the more interesting,\npowerful, and prominent idea of slices.\u003c/p\u003e\n\u003cp\u003eArrays are not often seen in Go programs because\nthe size of an array is part of its type, which limits its expressive power.\u003c/p\u003e\n\u003cp\u003eThe declaration\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003evar buffer [256]byte\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003edeclares the variable \u003ccode\u003ebuffer\u003c/code\u003e, which holds 256 bytes.\nThe type of \u003ccode\u003ebuffer\u003c/code\u003e includes its size, \u003ccode\u003e[256]byte\u003c/code\u003e.\nAn array with 512 bytes would be of the distinct type \u003ccode\u003e[512]byte\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe data associated with an array is just that: an array of elements.\nSchematically, our buffer looks like this in memory,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebuffer: byte byte byte ... 256 times ... byte byte byte\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat is, the variable holds 256 bytes of data and nothing else. We can\naccess its elements with the familiar indexing syntax, \u003ccode\u003ebuffer[0]\u003c/code\u003e, \u003ccode\u003ebuffer[1]\u003c/code\u003e,\nand so on through \u003ccode\u003ebuffer[255]\u003c/code\u003e. (The index range 0 through 255 covers\n256 elements.) Attempting to index \u003ccode\u003ebuffer\u003c/code\u003e with a value outside this\nrange will crash the program.\u003c/p\u003e\n\u003cp\u003eThere is a built-in function called \u003ccode\u003elen\u003c/code\u003e that returns the number of elements\nof an array or slice and also of a few other data types.\nFor arrays, it’s obvious what \u003ccode\u003elen\u003c/code\u003e returns.\nIn our example, \u003ccode\u003elen(buffer)\u003c/code\u003e returns the fixed value 256.\u003c/p\u003e\n\u003cp\u003eArrays have their place—they are a good representation of a transformation\nmatrix for instance—but their most common purpose in Go is to hold storage\nfor a slice.\u003c/p\u003e\n\u003ch2 id=\"slices-the-slice-header\"\u003eSlices: The slice header\u003c/h2\u003e\n\u003cp\u003eSlices are where the action is, but to use them well one must understand\nexactly what they are and what they do.\u003c/p\u003e\n\u003cp\u003eA slice is a data structure describing a contiguous section of an array\nstored separately from the slice variable itself.\n\u003cem\u003eA slice is not an array\u003c/em\u003e.\nA slice \u003cem\u003edescribes\u003c/em\u003e a piece of an array.\u003c/p\u003e\n\u003cp\u003eGiven our \u003ccode\u003ebuffer\u003c/code\u003e array variable from the previous section, we could create\na slice that describes elements 100 through 150 (to be precise, 100 through 149,\ninclusive) by \u003cem\u003eslicing\u003c/em\u003e the array:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003evar slice []byte = buffer[100:150]\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIn that snippet we used the full variable declaration to be explicit.\nThe variable \u003ccode\u003eslice\u003c/code\u003e has type \u003ccode\u003e[]byte\u003c/code\u003e, pronounced “slice of bytes”,\nand is initialized from the array, called\n\u003ccode\u003ebuffer\u003c/code\u003e, by slicing elements 100 (inclusive) through 150 (exclusive).\nThe more idiomatic syntax would drop the type, which is set by the initializing expression:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar slice = buffer[100:150]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInside a function we could use the short declaration form,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice := buffer[100:150]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat exactly is this slice variable?\nIt’s not quite the full story, but for now think of a\nslice as a little data structure with two elements: a length and a pointer to an element\nof an array.\nYou can think of it as being built like this behind the scenes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype sliceHeader struct {\n    Length        int\n    ZerothElement *byte\n}\n\nslice := sliceHeader{\n    Length:        50,\n    ZerothElement: \u0026amp;buffer[100],\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOf course, this is just an illustration.\nDespite what this snippet says that \u003ccode\u003esliceHeader\u003c/code\u003e struct is not visible\nto the programmer, and the type\nof the element pointer depends on the type of the elements,\nbut this gives the general idea of the mechanics.\u003c/p\u003e\n\u003cp\u003eSo far we’ve used a slice operation on an array, but we can also slice a slice, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice2 := slice[5:10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJust as before, this operation creates a new slice, in this case with elements\n5 through 9 (inclusive) of the original slice, which means elements\n105 through 109 of the original array.\nThe underlying \u003ccode\u003esliceHeader\u003c/code\u003e struct for the \u003ccode\u003eslice2\u003c/code\u003e variable looks like\nthis:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice2 := sliceHeader{\n    Length:        5,\n    ZerothElement: \u0026amp;buffer[105],\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that this header still points to the same underlying array, stored in\nthe \u003ccode\u003ebuffer\u003c/code\u003e variable.\u003c/p\u003e\n\u003cp\u003eWe can also \u003cem\u003ereslice\u003c/em\u003e, which is to say slice a slice and store the result back in\nthe original slice structure. After\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice = slice[5:10]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe \u003ccode\u003esliceHeader\u003c/code\u003e structure for the \u003ccode\u003eslice\u003c/code\u003e variable looks just like it did for the \u003ccode\u003eslice2\u003c/code\u003e\nvariable.\nYou’ll see reslicing used often, for example to truncate a slice. This statement drops\nthe first and last elements of our slice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice = slice[1:len(slice)-1]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e[Exercise: Write out what the \u003ccode\u003esliceHeader\u003c/code\u003e struct looks like after this assignment.]\u003c/p\u003e\n\u003cp\u003eYou’ll often hear experienced Go programmers talk about the “slice header”\nbecause that really is what’s stored in a slice variable.\nFor instance, when you call a function that takes a slice as an argument, such as\n\u003ca href=\"/pkg/bytes/#IndexRune\"\u003ebytes.IndexRune\u003c/a\u003e, that header is\nwhat gets passed to the function.\nIn this call,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslashPos := bytes.IndexRune(slice, \u0026#39;/\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe \u003ccode\u003eslice\u003c/code\u003e argument that is passed to the \u003ccode\u003eIndexRune\u003c/code\u003e function is, in fact,\na “slice header”.\u003c/p\u003e\n\u003cp\u003eThere’s one more data item in the slice header, which we talk about below,\nbut first let’s see what the existence of the slice header means when you\nprogram with slices.\u003c/p\u003e\n\u003ch2 id=\"passing-slices-to-functions\"\u003ePassing slices to functions\u003c/h2\u003e\n\u003cp\u003eIt’s important to understand that even though a slice contains a pointer,\nit is itself a value.\nUnder the covers, it is a struct value holding a pointer and a length.\nIt is \u003cem\u003enot\u003c/em\u003e a pointer to a struct.\u003c/p\u003e\n\u003cp\u003eThis matters.\u003c/p\u003e\n\u003cp\u003eWhen we called \u003ccode\u003eIndexRune\u003c/code\u003e in the previous example,\nit was passed a \u003cem\u003ecopy\u003c/em\u003e of the slice header.\nThat behavior has important ramifications.\u003c/p\u003e\n\u003cp\u003eConsider this simple function:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc AddOneToEachElement(slice []byte) {\n    for i := range slice {\n        slice[i]++\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIt does just what its name implies, iterating over the indices of a slice\n(using a \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop), incrementing its elements.\u003c/p\u003e\n\u003cp\u003eTry it:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nvar buffer [256]byte\nvar slice []byte = buffer[100:150]\n\nfunc AddOneToEachElement(slice []byte) {\n    for i := range slice {\n        slice[i]++\n    }\n}\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    slice := buffer[10:20]\n    for i := 0; i \u0026lt; len(slice); i++ {\n        slice[i] = byte(i)\n    }\n    fmt.Println(\u0026#34;before\u0026#34;, slice)\n    AddOneToEachElement(slice)\n    fmt.Println(\u0026#34;after\u0026#34;, slice)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e(You can edit and re-execute these runnable snippets if you want to explore.)\u003c/p\u003e\n\u003cp\u003eEven though the slice \u003cem\u003eheader\u003c/em\u003e is passed by value, the header includes\na pointer to elements of an array, so both the original slice header\nand the copy of the header passed to the function describe the same\narray.\nTherefore, when the function returns, the modified elements can\nbe seen through the original slice variable.\u003c/p\u003e\n\u003cp\u003eThe argument to the function really is a copy, as this example shows:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nvar buffer [256]byte\nvar slice []byte = buffer[100:150]\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc SubtractOneFromLength(slice []byte) []byte {\n    slice = slice[0 : len(slice)-1]\n    return slice\n}\n\nfunc main() {\n    fmt.Println(\u0026#34;Before: len(slice) =\u0026#34;, len(slice))\n    newSlice := SubtractOneFromLength(slice)\n    fmt.Println(\u0026#34;After:  len(slice) =\u0026#34;, len(slice))\n    fmt.Println(\u0026#34;After:  len(newSlice) =\u0026#34;, len(newSlice))\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHere we see that the \u003cem\u003econtents\u003c/em\u003e of a slice argument can be modified by a function,\nbut its \u003cem\u003eheader\u003c/em\u003e cannot.\nThe length stored in the \u003ccode\u003eslice\u003c/code\u003e variable is not modified by the call to the function,\nsince the function is passed a copy of the slice header, not the original.\nThus if we want to write a function that modifies the header, we must return it as a result\nparameter, just as we have done here.\nThe \u003ccode\u003eslice\u003c/code\u003e variable is unchanged but the returned value has the new length,\nwhich is then stored in \u003ccode\u003enewSlice\u003c/code\u003e,\u003c/p\u003e\n\u003ch2 id=\"pointers-to-slices-method-receivers\"\u003ePointers to slices: Method receivers\u003c/h2\u003e\n\u003cp\u003eAnother way to have a function modify the slice header is to pass a pointer to it.\nHere’s a variant of our previous example that does this:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nvar buffer [256]byte\nvar slice []byte = buffer[100:150]\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc PtrSubtractOneFromLength(slicePtr *[]byte) {\n    slice := *slicePtr\n    *slicePtr = slice[0 : len(slice)-1]\n}\n\nfunc main() {\n    fmt.Println(\u0026#34;Before: len(slice) =\u0026#34;, len(slice))\n    PtrSubtractOneFromLength(\u0026amp;slice)\n    fmt.Println(\u0026#34;After:  len(slice) =\u0026#34;, len(slice))\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIt seems clumsy in that example, especially dealing with the extra level of indirection\n(a temporary variable helps),\nbut there is one common case where you see pointers to slices.\nIt is idiomatic to use a pointer receiver for a method that modifies a slice.\u003c/p\u003e\n\u003cp\u003eLet’s say we wanted to have a method on a slice that truncates it at the final slash.\nWe could write it like this:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;bytes\u0026#34;\n    \u0026#34;fmt\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003etype path []byte\n\nfunc (p *path) TruncateAtFinalSlash() {\n    i := bytes.LastIndex(*p, []byte(\u0026#34;/\u0026#34;))\n    if i \u0026gt;= 0 {\n        *p = (*p)[0:i]\n    }\n}\n\nfunc main() {\n    pathName := path(\u0026#34;/usr/bin/tso\u0026#34;) // Conversion from string to path.\n    pathName.TruncateAtFinalSlash()\n    fmt.Printf(\u0026#34;%s\\n\u0026#34;, pathName)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIf you run this example you’ll see that it works properly, updating the slice in the caller.\u003c/p\u003e\n\u003cp\u003e[Exercise: Change the type of the receiver to be a value rather\nthan a pointer and run it again. Explain what happens.]\u003c/p\u003e\n\u003cp\u003eOn the other hand, if we wanted to write a method for \u003ccode\u003epath\u003c/code\u003e that upper-cases\nthe ASCII letters in the path (parochially ignoring non-English names), the method could\nbe a value because the value receiver will still point to the same underlying array.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003etype path []byte\n\nfunc (p path) ToUpper() {\n    for i, b := range p {\n        if \u0026#39;a\u0026#39; \u0026lt;= b \u0026amp;\u0026amp; b \u0026lt;= \u0026#39;z\u0026#39; {\n            p[i] = b + \u0026#39;A\u0026#39; - \u0026#39;a\u0026#39;\n        }\n    }\n}\n\nfunc main() {\n    pathName := path(\u0026#34;/usr/bin/tso\u0026#34;)\n    pathName.ToUpper()\n    fmt.Printf(\u0026#34;%s\\n\u0026#34;, pathName)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHere the \u003ccode\u003eToUpper\u003c/code\u003e method uses two variables in the \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e construct\nto capture the index and slice element.\nThis form of loop avoids writing \u003ccode\u003ep[i]\u003c/code\u003e multiple times in the body.\u003c/p\u003e\n\u003cp\u003e[Exercise: Convert the \u003ccode\u003eToUpper\u003c/code\u003e method to use a pointer receiver and see if its behavior changes.]\u003c/p\u003e\n\u003cp\u003e[Advanced exercise: Convert the \u003ccode\u003eToUpper\u003c/code\u003e method to handle Unicode letters, not just ASCII.]\u003c/p\u003e\n\u003ch2 id=\"capacity\"\u003eCapacity\u003c/h2\u003e\n\u003cp\u003eLook at the following function that extends its argument slice of \u003ccode\u003eints\u003c/code\u003e by one element:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e(Why does it need to return the modified slice?) Now run it:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nfunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    var iBuffer [10]int\n    slice := iBuffer[0:0]\n    for i := 0; i \u0026lt; 20; i++ {\n        slice = Extend(slice, i)\n        fmt.Println(slice)\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eSee how the slice grows until… it doesn’t.\u003c/p\u003e\n\u003cp\u003eIt’s time to talk about the third component of the slice header: its \u003cem\u003ecapacity\u003c/em\u003e.\nBesides the array pointer and length, the slice header also stores its capacity:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype sliceHeader struct {\n    Length        int\n    Capacity      int\n    ZerothElement *byte\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eCapacity\u003c/code\u003e field records how much space the underlying array actually has; it is the maximum\nvalue the \u003ccode\u003eLength\u003c/code\u003e can reach.\nTrying to grow the slice beyond its capacity will step beyond the limits of the array and will trigger a panic.\u003c/p\u003e\n\u003cp\u003eAfter our example slice is created by\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice := iBuffer[0:0]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eits header looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice := sliceHeader{\n    Length:        0,\n    Capacity:      10,\n    ZerothElement: \u0026amp;iBuffer[0],\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eCapacity\u003c/code\u003e field is equal to the length of the underlying array,\nminus the index in the array of the first element of the slice (zero in this case).\nIf you want to inquire what the capacity is for a slice, use the built-in function \u003ccode\u003ecap\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif cap(slice) == len(slice) {\n    fmt.Println(\u0026#34;slice is full!\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"make\"\u003eMake\u003c/h2\u003e\n\u003cp\u003eWhat if we want to grow the slice beyond its capacity?\nYou can’t!\nBy definition, the capacity is the limit to growth.\nBut you can achieve an equivalent result by allocating a new array, copying the data over, and modifying\nthe slice to describe the new array.\u003c/p\u003e\n\u003cp\u003eLet’s start with allocation.\nWe could use the \u003ccode\u003enew\u003c/code\u003e built-in function to allocate a bigger array\nand then slice the result,\nbut it is simpler to use the \u003ccode\u003emake\u003c/code\u003e built-in function instead.\nIt allocates a new array and\ncreates a slice header to describe it, all at once.\nThe \u003ccode\u003emake\u003c/code\u003e function takes three arguments: the type of the slice, its initial length, and its capacity, which is the\nlength of the array that \u003ccode\u003emake\u003c/code\u003e allocates to hold the slice data.\nThis call creates a slice of length 10 with room for 5 more (15-10), as you can see by running it:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice := make([]int, 10, 15)\n    fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice))\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThis snippet doubles the capacity of our \u003ccode\u003eint\u003c/code\u003e slice but keeps its length the same:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice := make([]int, 10, 15)\n    fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice))\n    newSlice := make([]int, len(slice), 2*cap(slice))\n    for i := range slice {\n        newSlice[i] = slice[i]\n    }\n    slice = newSlice\n    fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice))\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eAfter running this code the slice has much more room to grow before needing another reallocation.\u003c/p\u003e\n\u003cp\u003eWhen creating slices, it’s often true that the length and capacity will be same.\nThe \u003ccode\u003emake\u003c/code\u003e built-in has a shorthand for this common case.\nThe length argument defaults to the capacity, so you can leave it out\nto set them both to the same value.\nAfter\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egophers := make([]Gopher, 10)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe \u003ccode\u003egophers\u003c/code\u003e slice has both its length and capacity set to 10.\u003c/p\u003e\n\u003ch2 id=\"copy\"\u003eCopy\u003c/h2\u003e\n\u003cp\u003eWhen we doubled the capacity of our slice in the previous section,\nwe wrote a loop to copy the old data to the new slice.\nGo has a built-in function, \u003ccode\u003ecopy\u003c/code\u003e, to make this easier.\nIts arguments are two slices, and it copies the data from the right-hand argument to the left-hand argument.\nHere’s our example rewritten to use \u003ccode\u003ecopy\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nfunc main() {\n    slice := make([]int, 10, 15)\n    fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice))\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    newSlice := make([]int, len(slice), 2*cap(slice))\n    copy(newSlice, slice)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   slice = newSlice\n    fmt.Printf(\u0026#34;len: %d, cap: %d\\n\u0026#34;, len(slice), cap(slice))\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003ecopy\u003c/code\u003e function is smart.\nIt only copies what it can, paying attention to the lengths of both arguments.\nIn other words, the number of elements it copies is the minimum of the lengths of the two slices.\nThis can save a little bookkeeping.\nAlso, \u003ccode\u003ecopy\u003c/code\u003e returns an integer value, the number of elements it copied, although it’s not always worth checking.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ecopy\u003c/code\u003e function also gets things right when source and destination overlap, which means it can be used to shift\nitems around in a single slice.\nHere’s how to use \u003ccode\u003ecopy\u003c/code\u003e to insert a value into the middle of a slice.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// Insert inserts the value into the slice at the specified index,\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// which must be in range.\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// The slice must have room for the new element.\u003c/span\u003e\nfunc Insert(slice []int, index, value int) []int {\n    \u003cspan class=\"comment\"\u003e// Grow the slice by one element.\u003c/span\u003e\n    slice = slice[0 : len(slice)+1]\n    \u003cspan class=\"comment\"\u003e// Use copy to move the upper part of the slice out of the way and open a hole.\u003c/span\u003e\n    copy(slice[index+1:], slice[index:])\n    \u003cspan class=\"comment\"\u003e// Store the new value.\u003c/span\u003e\n    slice[index] = value\n    \u003cspan class=\"comment\"\u003e// Return the result.\u003c/span\u003e\n    return slice\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThere are a couple of things to notice in this function.\nFirst, of course, it must return the updated slice because its length has changed.\nSecond, it uses a convenient shorthand.\nThe expression\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice[i:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emeans exactly the same as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice[i:len(slice)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlso, although we haven’t used the trick yet, we can leave out the first element of a slice expression too;\nit defaults to zero. Thus\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice[:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ejust means the slice itself, which is useful when slicing an array.\nThis expression is the shortest way to say “a slice describing all the elements of the array”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003earray[:]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow that’s out of the way, let’s run our \u003ccode\u003eInsert\u003c/code\u003e function.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n// Insert inserts the value into the slice at the specified index,\n// which must be in range.\n// The slice must have room for the new element.\nfunc Insert(slice []int, index, value int) []int {\n    // Grow the slice by one element.\n    slice = slice[0 : len(slice)+1]\n    // Use copy to move the upper part of the slice out of the way and open a hole.\n    copy(slice[index+1:], slice[index:])\n    // Store the new value.\n    slice[index] = value\n    // Return the result.\n    return slice\n}\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice := make([]int, 10, 20) // Note capacity \u0026gt; length: room to add element.\n    for i := range slice {\n        slice[i] = i\n    }\n    fmt.Println(slice)\n    slice = Insert(slice, 5, 99)\n    fmt.Println(slice)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"append-an-example\"\u003eAppend: An example\u003c/h2\u003e\n\u003cp\u003eA few sections back, we wrote an \u003ccode\u003eExtend\u003c/code\u003e function that extends a slice by one element.\nIt was buggy, though, because if the slice’s capacity was too small, the function would\ncrash.\n(Our \u003ccode\u003eInsert\u003c/code\u003e example has the same problem.)\nNow we have the pieces in place to fix that, so let’s write a robust implementation of\n\u003ccode\u003eExtend\u003c/code\u003e for integer slices.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    if n == cap(slice) {\n        \u003cspan class=\"comment\"\u003e// Slice is full; must grow.\u003c/span\u003e\n        \u003cspan class=\"comment\"\u003e// We double its size and add 1, so if the size is zero we still grow.\u003c/span\u003e\n        newSlice := make([]int, len(slice), 2*len(slice)+1)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIn this case it’s especially important to return the slice, since when it reallocates\nthe resulting slice describes a completely different array.\nHere’s a little snippet to demonstrate what happens as the slice fills up:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n// Extend extends the slice by adding the element to the end.\nfunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    if n == cap(slice) {\n        // Slice is full; must grow.\n        // We double its size and add 1, so if the size is zero we still grow.\n        newSlice := make([]int, len(slice), 2*len(slice)+1)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice := make([]int, 0, 5)\n    for i := 0; i \u0026lt; 10; i++ {\n        slice = Extend(slice, i)\n        fmt.Printf(\u0026#34;len=%d cap=%d slice=%v\\n\u0026#34;, len(slice), cap(slice), slice)\n        fmt.Println(\u0026#34;address of 0th element:\u0026#34;, \u0026amp;slice[0])\n    }\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eNotice the reallocation when the initial array of size 5 is filled up.\nBoth the capacity and the address of the zeroth element change when the new array is allocated.\u003c/p\u003e\n\u003cp\u003eWith the robust \u003ccode\u003eExtend\u003c/code\u003e function as a guide we can write an even nicer function that lets\nus extend the slice by multiple elements.\nTo do this, we use Go’s ability to turn a list of function arguments into a slice when the\nfunction is called.\nThat is, we use Go’s variadic function facility.\u003c/p\u003e\n\u003cp\u003eLet’s call the function \u003ccode\u003eAppend\u003c/code\u003e.\nFor the first version, we can just call \u003ccode\u003eExtend\u003c/code\u003e repeatedly so the mechanism of the variadic function is clear.\nThe signature of \u003ccode\u003eAppend\u003c/code\u003e is this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Append(slice []int, items ...int) []int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhat that says is that \u003ccode\u003eAppend\u003c/code\u003e takes one argument, a slice, followed by zero or more\n\u003ccode\u003eint\u003c/code\u003e arguments.\nThose arguments are exactly a slice of \u003ccode\u003eint\u003c/code\u003e as far as the implementation\nof \u003ccode\u003eAppend\u003c/code\u003e is concerned, as you can see:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// Append appends the items to the slice.\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// First version: just loop calling Extend.\u003c/span\u003e\nfunc Append(slice []int, items ...int) []int {\n    for _, item := range items {\n        slice = Extend(slice, item)\n    }\n    return slice\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eNotice the \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop iterating over the elements of the \u003ccode\u003eitems\u003c/code\u003e argument, which has implied type \u003ccode\u003e[]int\u003c/code\u003e.\nAlso notice the use of the blank identifier \u003ccode\u003e_\u003c/code\u003e to discard the index in the loop, which we don’t need in this case.\u003c/p\u003e\n\u003cp\u003eTry it:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n// Extend extends the slice by adding the element to the end.\nfunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    if n == cap(slice) {\n        // Slice is full; must grow.\n        // We double its size and add 1, so if the size is zero we still grow.\n        newSlice := make([]int, len(slice), 2*len(slice)+1)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\n// Append appends the items to the slice.\n// First version: just loop calling Extend.\nfunc Append(slice []int, items ...int) []int {\n    for _, item := range items {\n        slice = Extend(slice, item)\n    }\n    return slice\n}\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice := []int{0, 1, 2, 3, 4}\n    fmt.Println(slice)\n    slice = Append(slice, 5, 6, 7, 8)\n    fmt.Println(slice)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eAnother new technique in this example is that we initialize the slice by writing a composite literal,\nwhich consists of the type of the slice followed by its elements in braces:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    slice := []int{0, 1, 2, 3, 4}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003eAppend\u003c/code\u003e function is interesting for another reason.\nNot only can we append elements, we can append a whole second slice\nby “exploding” the slice into arguments using the \u003ccode\u003e...\u003c/code\u003e notation at the call site:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n// Extend extends the slice by adding the element to the end.\nfunc Extend(slice []int, element int) []int {\n    n := len(slice)\n    if n == cap(slice) {\n        // Slice is full; must grow.\n        // We double its size and add 1, so if the size is zero we still grow.\n        newSlice := make([]int, len(slice), 2*len(slice)+1)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0 : n+1]\n    slice[n] = element\n    return slice\n}\n\n// Append appends the items to the slice.\n// First version: just loop calling Extend.\nfunc Append(slice []int, items ...int) []int {\n    for _, item := range items {\n        slice = Extend(slice, item)\n    }\n    return slice\n}\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice1 := []int{0, 1, 2, 3, 4}\n    slice2 := []int{55, 66, 77}\n    fmt.Println(slice1)\n    slice1 = Append(slice1, slice2...) // The \u0026#39;...\u0026#39; is essential!\n    fmt.Println(slice1)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eOf course, we can make \u003ccode\u003eAppend\u003c/code\u003e more efficient by allocating no more than once,\nbuilding on the innards of \u003ccode\u003eExtend\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// Append appends the elements to the slice.\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// Efficient version.\u003c/span\u003e\nfunc Append(slice []int, elements ...int) []int {\n    n := len(slice)\n    total := len(slice) + len(elements)\n    if total \u0026gt; cap(slice) {\n        \u003cspan class=\"comment\"\u003e// Reallocate. Grow to 1.5 times the new size, so we can still grow.\u003c/span\u003e\n        newSize := total*3/2 + 1\n        newSlice := make([]int, total, newSize)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[:total]\n    copy(slice[n:], elements)\n    return slice\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHere, notice how we use \u003ccode\u003ecopy\u003c/code\u003e twice, once to move the slice data to the newly\nallocated memory, and then to copy the appending items to the end of the old data.\u003c/p\u003e\n\u003cp\u003eTry it; the behavior is the same as before:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\n// Append appends the elements to the slice.\n// Efficient version.\nfunc Append(slice []int, elements ...int) []int {\n    n := len(slice)\n    total := len(slice) + len(elements)\n    if total \u0026gt; cap(slice) {\n        // Reallocate. Grow to 1.5 times the new size, so we can still grow.\n        newSize := total*3/2 + 1\n        newSlice := make([]int, total, newSize)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[:total]\n    copy(slice[n:], elements)\n    return slice\n}\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    slice1 := []int{0, 1, 2, 3, 4}\n    slice2 := []int{55, 66, 77}\n    fmt.Println(slice1)\n    slice1 = Append(slice1, slice2...) // The \u0026#39;...\u0026#39; is essential!\n    fmt.Println(slice1)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"append-the-built-in-function\"\u003eAppend: The built-in function\u003c/h2\u003e\n\u003cp\u003eAnd so we arrive at the motivation for the design of the \u003ccode\u003eappend\u003c/code\u003e built-in function.\nIt does exactly what our \u003ccode\u003eAppend\u003c/code\u003e example does, with equivalent efficiency, but it\nworks for any slice type.\u003c/p\u003e\n\u003cp\u003eA weakness of Go is that any generic-type operations must be provided by the\nrun-time. Some day that may change, but for now, to make working with slices\neasier, Go provides a built-in generic \u003ccode\u003eappend\u003c/code\u003e function.\nIt works the same as our \u003ccode\u003eint\u003c/code\u003e slice version, but for \u003cem\u003eany\u003c/em\u003e slice type.\u003c/p\u003e\n\u003cp\u003eRemember, since the slice header is always updated by a call to \u003ccode\u003eappend\u003c/code\u003e, you need\nto save the returned slice after the call.\nIn fact, the compiler won’t let you call append without saving the result.\u003c/p\u003e\n\u003cp\u003eHere are some one-liners intermingled with print statements. Try them, edit them and explore:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n)\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    // Create a couple of starter slices.\n    slice := []int{1, 2, 3}\n    slice2 := []int{55, 66, 77}\n    fmt.Println(\u0026#34;Start slice: \u0026#34;, slice)\n    fmt.Println(\u0026#34;Start slice2:\u0026#34;, slice2)\n\n    // Add an item to a slice.\n    slice = append(slice, 4)\n    fmt.Println(\u0026#34;Add one item:\u0026#34;, slice)\n\n    // Add one slice to another.\n    slice = append(slice, slice2...)\n    fmt.Println(\u0026#34;Add one slice:\u0026#34;, slice)\n\n    // Make a copy of a slice (of int).\n    slice3 := append([]int(nil), slice...)\n    fmt.Println(\u0026#34;Copy a slice:\u0026#34;, slice3)\n\n    // Copy a slice to the end of itself.\n    fmt.Println(\u0026#34;Before append to self:\u0026#34;, slice)\n    slice = append(slice, slice...)\n    fmt.Println(\u0026#34;After append to self:\u0026#34;, slice)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIt’s worth taking a moment to think about the final one-liner of that example in detail to understand\nhow the design of slices makes it possible for this simple call to work correctly.\u003c/p\u003e\n\u003cp\u003eThere are lots more examples of \u003ccode\u003eappend\u003c/code\u003e, \u003ccode\u003ecopy\u003c/code\u003e, and other ways to use slices\non the community-built\n\u003ca href=\"/wiki/SliceTricks\"\u003e“Slice Tricks” Wiki page\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"nil\"\u003eNil\u003c/h2\u003e\n\u003cp\u003eAs an aside, with our newfound knowledge we can see what the representation of a \u003ccode\u003enil\u003c/code\u003e slice is.\nNaturally, it is the zero value of the slice header:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esliceHeader{\n    Length:        0,\n    Capacity:      0,\n    ZerothElement: nil,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor just\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esliceHeader{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe key detail is that the element pointer is \u003ccode\u003enil\u003c/code\u003e too. The slice created by\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003earray[0:0]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ehas length zero (and maybe even capacity zero) but its pointer is not \u003ccode\u003enil\u003c/code\u003e, so\nit is not a nil slice.\u003c/p\u003e\n\u003cp\u003eAs should be clear, an empty slice can grow (assuming it has non-zero capacity), but a \u003ccode\u003enil\u003c/code\u003e\nslice has no array to put values in and can never grow to hold even one element.\u003c/p\u003e\n\u003cp\u003eThat said, a \u003ccode\u003enil\u003c/code\u003e slice is functionally equivalent to a zero-length slice, even though it points\nto nothing.\nIt has length zero and can be appended to, with allocation.\nAs an example, look at the one-liner above that copies a slice by appending\nto a \u003ccode\u003enil\u003c/code\u003e slice.\u003c/p\u003e\n\u003ch2 id=\"strings\"\u003eStrings\u003c/h2\u003e\n\u003cp\u003eNow a brief section about strings in Go in the context of slices.\u003c/p\u003e\n\u003cp\u003eStrings are actually very simple: they are just read-only slices of bytes with a bit\nof extra syntactic support from the language.\u003c/p\u003e\n\u003cp\u003eBecause they are read-only, there is no need for a capacity (you can’t grow them),\nbut otherwise for most purposes you can treat them just like read-only slices\nof bytes.\u003c/p\u003e\n\u003cp\u003eFor starters, we can index them to access individual bytes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslash := \u0026#34;/usr/ken\u0026#34;[0] // yields the byte value \u0026#39;/\u0026#39;.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can slice a string to grab a substring:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eusr := \u0026#34;/usr/ken\u0026#34;[0:4] // yields the string \u0026#34;/usr\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt should be obvious now what’s going on behind the scenes when we slice a string.\u003c/p\u003e\n\u003cp\u003eWe can also take a normal slice of bytes and create a string from it with the simple conversion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estr := string(slice)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand go in the reverse direction as well:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslice := []byte(usr)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe array underlying a string is hidden from view; there is no way to access its contents\nexcept through the string. That means that when we do either of these conversions, a\ncopy of the array must be made.\nGo takes care of this, of course, so you don’t have to.\nAfter either of these conversions, modifications to\nthe array underlying the byte slice don’t affect the corresponding string.\u003c/p\u003e\n\u003cp\u003eAn important consequence of this slice-like design for strings is that\ncreating a substring is very efficient.\nAll that needs to happen\nis the creation of a two-word string header. Since the string is read-only, the original\nstring and the string resulting from the slice operation can share the same array safely.\u003c/p\u003e\n\u003cp\u003eA historical note: The earliest implementation of strings always allocated, but when slices\nwere added to the language, they provided a model for efficient string handling. Some of\nthe benchmarks saw huge speedups as a result.\u003c/p\u003e\n\u003cp\u003eThere’s much more to strings, of course, and a\n\u003ca href=\"/blog/strings\"\u003eseparate blog post\u003c/a\u003e covers them in greater depth.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eTo understand how slices work, it helps to understand how they are implemented.\nThere is a little data structure, the slice header, that is the item associated with the slice\nvariable, and that header describes a section of a separately allocated array.\nWhen we pass slice values around, the header gets copied but the array it points\nto is always shared.\u003c/p\u003e\n\u003cp\u003eOnce you appreciate how they work, slices become not only easy to use, but\npowerful and expressive, especially with the help of the \u003ccode\u003ecopy\u003c/code\u003e and \u003ccode\u003eappend\u003c/code\u003e\nbuilt-in functions.\u003c/p\u003e\n\u003ch2 id=\"more-reading\"\u003eMore reading\u003c/h2\u003e\n\u003cp\u003eThere’s lots to find around the intertubes about slices in Go.\nAs mentioned earlier,\nthe \u003ca href=\"/wiki/SliceTricks\"\u003e“Slice Tricks” Wiki page\u003c/a\u003e\nhas many examples.\nThe \u003ca href=\"/blog/go-slices-usage-and-internals\"\u003eGo Slices\u003c/a\u003e blog post\ndescribes the memory layout details with clear diagrams.\nRuss Cox’s \u003ca href=\"https://research.swtch.com/godata\" rel=\"noreferrer\" target=\"_blank\"\u003eGo Data Structures\u003c/a\u003e article includes\na discussion of slices along with some of Go’s other internal data structures.\u003c/p\u003e\n\u003cp\u003eThere is much more material available, but the best way to learn about slices is to use them.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-09-26T00:00:00Z",
  "Author": "Rob Pike"
}