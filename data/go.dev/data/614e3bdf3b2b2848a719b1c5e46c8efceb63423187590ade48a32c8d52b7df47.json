{
  "Source": "go.dev",
  "Title": "Backward Compatibility, Go 1.21, and Go 2",
  "Link": "https://go.dev/blog/compat",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/compat\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eBackward Compatibility, Go 1.21, and Go 2\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      14 August 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eGo 1.21 includes new features to improve compatibility.\nBefore you stop reading, I know that sounds boring.\nBut boring can be good.\nBack in the early days of Go 1,\nGo was exciting and full of surprises.\nEach week we cut a new snapshot release\nand everyone got to roll the dice\nto see what we’d changed\nand how their programs would break.\nWe released Go 1 and its compatibility promise\nto remove the excitement,\nso that new releases of Go would be boring.\u003c/p\u003e\n\u003cp\u003eBoring is good.\nBoring is stable.\nBoring means being able to focus on your work,\nnot on what’s different about Go.\nThis post is about the important work we shipped in Go 1.21\nto keep Go boring.\u003c/p\u003e\n\u003ch2 id=\"go1\"\u003eGo 1 Compatibility\u003c/h2\u003e\n\u003cp\u003eWe’ve been focused on compatibility for over a decade.\nFor Go 1, back in 2012, we published a document titled\n“\u003ca href=\"/doc/go1compat\"\u003eGo 1 and the Future of Go Programs\u003c/a\u003e”\nthat lays out a very clear intention:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIt is intended that programs written to the Go 1 specification\nwill continue to compile and run correctly, unchanged,\nover the lifetime of that specification. …\nGo programs that work today should continue to work\neven as future releases of Go 1 arise.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThere are a few qualifications to that.\nFirst, compatibility means source compatibility.\nWhen you update to a new version of Go,\nyou do have to recompile your code.\nSecond, we can add new APIs,\nbut not in a way that breaks existing code.\u003c/p\u003e\n\u003cp\u003eThe end of the document warns,\n“[It] is impossible to guarantee that no future change will break any program.”\nThen it lays out a number of reasons why programs might still break.\u003c/p\u003e\n\u003cp\u003eFor example, it makes sense that if your program depends on a buggy behavior\nand we fix the bug, your program will break.\nBut we try very hard to break as little as possible and keep Go boring.\nThere are two main approaches we’ve used so far: API checking and testing.\u003c/p\u003e\n\u003ch2 id=\"api\"\u003eAPI Checking\u003c/h2\u003e\n\u003cp\u003ePerhaps the clearest fact about compatibility\nis that we can’t take away API, or else programs using it will break.\u003c/p\u003e\n\u003cp\u003eFor example, here’s a program someone has written\nthat we can’t break:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;os\u0026#34;\n\nfunc main() {\n    os.Stdout.WriteString(\u0026#34;hello, world\\n\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can’t remove the package \u003ccode\u003eos\u003c/code\u003e;\nwe can’t remove the global variable \u003ccode\u003eos.Stdout\u003c/code\u003e, which is an \u003ccode\u003e*os.File\u003c/code\u003e;\nand we also can’t remove the \u003ccode\u003eos.File\u003c/code\u003e method \u003ccode\u003eWriteString\u003c/code\u003e.\nIt should be clear that removing any of those would\nbreak this program.\u003c/p\u003e\n\u003cp\u003eIt’s perhaps less clear that we can’t change the type of \u003ccode\u003eos.Stdout\u003c/code\u003e at all.\nSuppose we want to make it an interface with the same methods.\nThe program we just saw wouldn’t break, but this one would:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;os\u0026#34;\n\nfunc main() {\n    greet(os.Stdout)\n}\n\nfunc greet(f *os.File) {\n    f.WriteString(“hello, world\\n”)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis program passes \u003ccode\u003eos.Stdout\u003c/code\u003e to a function named \u003ccode\u003egreet\u003c/code\u003e\nthat requires an argument of type \u003ccode\u003e*os.File\u003c/code\u003e.\nSo changing \u003ccode\u003eos.Stdout\u003c/code\u003e to an interface will break this program.\u003c/p\u003e\n\u003cp\u003eTo help us as we develop Go, we use a tool that maintains\na list of each package’s exported API\nin files separate from the actual packages:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e% cat go/api/go1.21.txt\npkg bytes, func ContainsFunc([]uint8, func(int32) bool) bool #54386\npkg bytes, method (*Buffer) AvailableBuffer() []uint8 #53685\npkg bytes, method (*Buffer) Available() int #53685\npkg cmp, func Compare[$0 Ordered]($0, $0) int #59488\npkg cmp, func Less[$0 Ordered]($0, $0) bool #59488\npkg cmp, type Ordered interface {} #59488\npkg context, func AfterFunc(Context, func()) func() bool #57928\npkg context, func WithDeadlineCause(Context, time.Time, error) (Context, CancelFunc) #56661\npkg context, func WithoutCancel(Context) Context #40221\npkg context, func WithTimeoutCause(Context, time.Duration, error) (Context, CancelFunc) #56661\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of our standard tests checks that the actual package APIs match those files.\nIf we add new API to a package, the test breaks unless we add it to the API files.\nAnd if we change or remove API, the test breaks too. This helps us avoid mistakes.\nHowever, a tool like this only finds a certain class of problems, namely API changes and removals.\nThere are other ways to make incompatible changes to Go.\u003c/p\u003e\n\u003cp\u003eThat leads us to the second approach we use to keep Go boring: testing.\u003c/p\u003e\n\u003ch2 id=\"testing\"\u003eTesting\u003c/h2\u003e\n\u003cp\u003eThe most effective way to find unexpected incompatibilities\nis to run existing tests against the development version of the next Go release.\nWe test the development version of Go against\nall of Google’s internal Go code on a rolling basis.\nWhen tests are passing, we install that commit as\nGoogle’s production Go toolchain.\u003c/p\u003e\n\u003cp\u003eIf a change breaks tests inside Google,\nwe assume it will also break tests outside Google,\nand we look for ways to reduce the impact.\nMost of the time, we roll back the change entirely\nor find a way to rewrite it so that it doesn’t break any programs.\nSometimes, however, we conclude that the change is\nimportant to make and “compatible” even though it does\nbreak some programs.\nIn that case, we still work to reduce the impact as much as possible,\nand then we document the potential problem in the release notes.\u003c/p\u003e\n\u003cp\u003eHere are two examples of that kind of subtle compatibility problems\nwe found by testing Go inside Google but still included in Go 1.1.\u003c/p\u003e\n\u003ch2 id=\"struct\"\u003eStruct Literals and New Fields\u003c/h2\u003e\n\u003cp\u003eHere is some code that runs fine in Go 1:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;net\u0026#34;\n\nvar myAddr = \u0026amp;net.TCPAddr{\n    net.IPv4(18, 26, 4, 9),\n    80,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePackage \u003ccode\u003emain\u003c/code\u003e declares a global variable \u003ccode\u003emyAddr\u003c/code\u003e,\nwhich is a composite literal of type \u003ccode\u003enet.TCPAddr\u003c/code\u003e.\nIn Go 1, package \u003ccode\u003enet\u003c/code\u003e defines the type \u003ccode\u003eTCPAddr\u003c/code\u003e\nas a struct with two fields, \u003ccode\u003eIP\u003c/code\u003e and \u003ccode\u003ePort\u003c/code\u003e.\nThose match the fields in the composite literal,\nso the program compiles.\u003c/p\u003e\n\u003cp\u003eIn Go 1.1, the program stopped compiling, with a compiler error\nthat said “too few initializers in struct literal.”\nThe problem is that we added a third field, \u003ccode\u003eZone\u003c/code\u003e, to \u003ccode\u003enet.TCPAddr\u003c/code\u003e,\nand this program is missing the value for that third field.\nThe fix is to rewrite the program using tagged literals,\nso that it builds in both versions of Go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar myAddr = \u0026amp;net.TCPAddr{\n    IP:   net.IPv4(18, 26, 4, 9),\n    Port: 80,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince this literal doesn’t specify a value for \u003ccode\u003eZone\u003c/code\u003e, it will use the\nzero value (an empty string in this case).\u003c/p\u003e\n\u003cp\u003eThis requirement to use composite literals for standard library\nstructs is explicitly called out in the \u003ca href=\"/doc/go1compat\"\u003ecompatibility document\u003c/a\u003e,\nand \u003ccode\u003ego vet\u003c/code\u003e reports literals that need tags\nto ensure compatibility with later versions of Go.\nThis problem was new enough in Go 1.1\nto merit a short comment in the release notes.\nNowadays we just mention the new field.\u003c/p\u003e\n\u003ch2 id=\"precision\"\u003eTime Precision\u003c/h2\u003e\n\u003cp\u003eThe second problem we found while testing Go 1.1\nhad nothing to do with APIs at all.\nIt had to do with time.\u003c/p\u003e\n\u003cp\u003eShortly after Go 1 was released, someone pointed\nout that \u003ca href=\"/pkg/time/#Now\"\u003e\u003ccode\u003etime.Now\u003c/code\u003e\u003c/a\u003e\nreturned times with microsecond precision,\nbut with some extra code,\nit could return times with nanosecond precision instead.\nThat sounds good, right?\nMore precision is better.\nSo we made that change.\u003c/p\u003e\n\u003cp\u003eThat broke a handful of tests inside Google that\nwere schematically like this one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestSaveTime(t *testing.T) {\n    t1 := time.Now()\n    save(t1)\n    if t2 := load(); t2 != t1 {\n        t.Fatalf(\u0026#34;load() = %v, want %v\u0026#34;, t1, t2)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code calls \u003ccode\u003etime.Now\u003c/code\u003e\nand then round-trips the result\nthrough \u003ccode\u003esave\u003c/code\u003e and \u003ccode\u003eload\u003c/code\u003e\nand expects to get the same time back.\nIf \u003ccode\u003esave\u003c/code\u003e and \u003ccode\u003eload\u003c/code\u003e use a representation\nthat only stores microsecond precision,\nthat will work fine in Go 1 but fail in Go 1.1.\u003c/p\u003e\n\u003cp\u003eTo help fix tests like this,\nwe added \u003ca href=\"/pkg/time/#Time.Round\"\u003e\u003ccode\u003eRound\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/time/#Time.Truncate\"\u003e\u003ccode\u003eTruncate\u003c/code\u003e\u003c/a\u003e methods\nto discard unwanted precision,\nand in the release notes,\nwe documented the possible problem\nand the new methods to help fix it.\u003c/p\u003e\n\u003cp\u003eThese examples show how\ntesting finds different kinds of incompatibility\nthan the API checks do.\nOf course, testing is not a complete guarantee\nof compatibility either,\nbut it’s more complete than just API checks.\nThere are many examples of problems we’ve found\nwhile testing that we decided did break the compatibility\nrules and rolled back before the release.\nThe time precision change is an interesting example\nof something that broke programs but that we released\nanyway.\nWe made the change because the improved precision\nwas better and was allowed within the documented behavior of the function.\u003c/p\u003e\n\u003cp\u003eThis example shows that sometimes, despite significant effort\nand attention, there are times when changing Go means\nbreaking Go programs.\nThe changes are, strictly speaking, “compatible” in the sense\nof the Go 1 document, but they still break programs.\nMost of these compatibility issues can be placed\nin one of three categories:\noutput changes,\ninput changes,\nand protocol changes.\u003c/p\u003e\n\u003ch2 id=\"output\"\u003eOutput Changes\u003c/h2\u003e\n\u003cp\u003eAn output change happens when a function gives a different output\nthan it used to, but the new output is just as correct as, or even more correct than,\nthe old output.\nIf existing code is written to expect only the old output, it will break.\nWe just saw an example of this, with \u003ccode\u003etime.Now\u003c/code\u003e adding nanosecond precision.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSort.\u003c/strong\u003e Another example happened in Go 1.6,\nwhen we changed the implementation of sort\nto run about 10% faster.\nHere’s an example program\nthat sorts a list of colors by length of name:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecolors := strings.Fields(\n    `black white red orange yellow green blue indigo violet`)\nsort.Sort(ByLen(colors))\nfmt.Println(colors)\n\nGo 1.5:  [red blue green white black yellow orange indigo violet]\nGo 1.6:  [red blue white green black orange yellow indigo violet]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eChanging sort algorithms often changes\nhow equal elements are ordered,\nand that happened here.\nGo 1.5 returned green, white, black, in that order.\nGo 1.6 returned white, green, black.\u003c/p\u003e\n\u003cp\u003eSort is clearly allowed to return equal results in any order it likes,\nand this change made it 10% faster, which is great.\nBut programs that expect a specific output will break.\nThis is a good example of why compatibility is so hard.\nWe don’t want to break programs,\nbut we also don’t want to be locked in\nto undocumented implementation details.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompress/flate.\u003c/strong\u003e As another example, in Go 1.8 we improved\n\u003ccode\u003ecompress/flate\u003c/code\u003e to produce smaller outputs,\nwith roughly the same CPU and memory overheads.\nThat sounds like a win-win, but it broke a project inside Google\nthat needed reproducible archive builds:\nnow they couldn’t reproduce their old archives.\nThey forked \u003ccode\u003ecompress/flate\u003c/code\u003e and \u003ccode\u003ecompress/gzip\u003c/code\u003e\nto keep a copy of the old algorithm.\u003c/p\u003e\n\u003cp\u003eWe do a similar thing with the Go compiler,\nusing a fork of the \u003ccode\u003esort\u003c/code\u003e package (\u003ca href=\"https://go.googlesource.com/go/+/go1.21.0/src/cmd/dist/buildtool.go#22\" rel=\"noreferrer\" target=\"_blank\"\u003eand others\u003c/a\u003e)\nso that the compiler produces the same results\neven when it is built using earlier versions of Go.\u003c/p\u003e\n\u003cp\u003eFor output change incompatibilities like these,\nthe best answer is to write programs and tests\nthat accept any valid output,\nand to use these kinds of breakages\nas an opportunity to change your testing strategy,\nnot just update the expected answers.\nIf you need truly reproducible outputs,\nthe next best answer is to fork the code\nto insulate yourself from changes,\nbut remember that\nyou’re also insulating yourself from bug fixes.\u003c/p\u003e\n\u003ch2 id=\"input\"\u003eInput Changes\u003c/h2\u003e\n\u003cp\u003eAn input change happens when a function changes which inputs it accepts\nor how it processes them.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eParseInt.\u003c/strong\u003e For example, Go 1.13 added support for\nunderscores in large numbers for readability.\nAlong with the language change,\nwe made \u003ccode\u003estrconv.ParseInt\u003c/code\u003e accept the new syntax.\nThis change didn’t break anything inside Google,\nbut much later we heard from an external user\nwhose code did break.\nTheir program used numbers separated by underscores\nas a data format.\nIt tried \u003ccode\u003eParseInt\u003c/code\u003e first and only fell back to checking for underscores if \u003ccode\u003eParseInt\u003c/code\u003e failed.\nWhen \u003ccode\u003eParseInt\u003c/code\u003e stopped failing, the underscore-handling code stopped running.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eParseIP.\u003c/strong\u003e As another example, Go’s \u003ccode\u003enet.ParseIP\u003c/code\u003e,\nfollowed the examples in early IP RFCs,\nwhich often showed decimal IP addresses with leading zeros.\nIt read the IP address 18.032.4.011 address as 18.32.4.11, just with a few extra zeros.\nWe found out much later that BSD-derived C libraries\ninterpret leading zeros in IP addresses as starting an octal number:\nin those libraries, 18.032.4.011 means 18.26.4.9!\u003c/p\u003e\n\u003cp\u003eThis was a serious mismatch\nbetween Go and the rest of the world,\nbut changing the meaning of leading zeros\nfrom one Go release to the next\nwould be a serious mismatch too.\nIt would be a huge incompatibility.\nIn the end, we decided to change \u003ccode\u003enet.ParseIP\u003c/code\u003e in Go 1.17\nto reject leading zeros entirely.\nThis stricter parsing ensures that when Go and C\nboth parse an IP address successfully,\nor when old and new Go versions do,\nthey all agree about what it means.\u003c/p\u003e\n\u003cp\u003eThis change didn’t break anything inside Google,\nbut the Kubernetes team was concerned about\nsaved configurations that might have parsed before\nbut would stop parsing with Go 1.17.\nAddresses with leading zeros\nprobably should be removed from those configs,\nsince Go interprets them differently from\nessentially every other language,\nbut that should happen on Kubernetes’s timeline, not Go’s.\nTo avoid the semantic change,\nKubernetes started using its own forked copy\nof the original \u003ccode\u003enet.ParseIP\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe best response to input changes is to process user input\nby first validating the syntax you want to accept\nbefore parsing the values,\nbut sometimes you need to fork the code instead.\u003c/p\u003e\n\u003ch2 id=\"protocol\"\u003eProtocol Changes\u003c/h2\u003e\n\u003cp\u003eThe final common kind of incompatibility is protocol changes.\nA protocol change is a change made to a package\nthat ends up externally visible\nin the protocols a program uses\nto communicate with the external world.\nAlmost any change can become externally visible\nin certain programs, as we saw with \u003ccode\u003eParseInt\u003c/code\u003e and \u003ccode\u003eParseIP\u003c/code\u003e,\nbut protocol changes are externally visible\nin essentially all programs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eHTTP/2.\u003c/strong\u003e A clear example of a protocol change is when\nGo 1.6 added automatic support for HTTP/2.\nSuppose a Go 1.5 client is connecting to an HTTP/2-capable\nserver over a network with middleboxes that happen to\nbreak HTTP/2.\nSince Go 1.5 only uses HTTP/1.1, the program works fine.\nBut then updating to Go 1.6 breaks the program, because Go 1.6\nstarts using HTTP/2, and in this context, HTTP/2 doesn’t work.\u003c/p\u003e\n\u003cp\u003eGo aims to support modern protocols by default,\nbut this example shows that enabling HTTP/2 can break programs\nthrough no fault of their own (nor any fault of Go’s).\nDevelopers in this situation could go back to using Go 1.5,\nbut that’s not very satisfying.\nInstead, Go 1.6 documented the change in the release notes\nand made it straightforward to disable HTTP/2.\u003c/p\u003e\n\u003cp\u003eIn fact, \u003ca href=\"/doc/go1.6#http2\"\u003eGo 1.6 documented two ways\u003c/a\u003e to disable HTTP/2:\nconfigure the \u003ccode\u003eTLSNextProto\u003c/code\u003e field explicitly using the package API,\nor set the GODEBUG environment variable:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGODEBUG=http2client=0 ./myprog\nGODEBUG=http2server=0 ./myprog\nGODEBUG=http2client=0,http2server=0 ./myprog\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs we’ll see later, Go 1.21 generalizes this GODEBUG mechanism\nto make it a standard for all potentially breaking changes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSHA1.\u003c/strong\u003e Here’s a subtler example of a protocol change.\nNo one should be using SHA1-based certificates for HTTPS anymore.\nCertificate authorities stopped issuing them in 2015,\nand all the major browsers stopped accepting them in 2017.\nIn early 2020, Go 1.18 disabled support for them by default,\nwith a GODEBUG setting to override that change.\nWe also announced our intent to remove the GODEBUG setting in Go 1.19.\u003c/p\u003e\n\u003cp\u003eThe Kubernetes team let us know that\nsome installations still use private SHA1 certificates.\nPutting aside the security questions,\nit’s not Kubernetes’s place to force these enterprises to\nupgrade their certificate infrastructure,\nand it would be extremely painful to fork \u003ccode\u003ecrypto/tls\u003c/code\u003e\nand \u003ccode\u003enet/http\u003c/code\u003e to keep SHA1 support.\nInstead, we agreed to keep the override in place longer than we had planned,\nto create more time for an orderly transition.\nAfter all, we want to break as few programs as possible.\u003c/p\u003e\n\u003ch2 id=\"expanded-godebug-support-in-go-121\"\u003eExpanded GODEBUG Support in Go 1.21\u003c/h2\u003e\n\u003cp\u003eTo improve backwards compatibility even in these subtle cases\nwe’ve been examining, Go 1.21 expands and formalizes the use of GODEBUG.\u003c/p\u003e\n\u003cp\u003eTo begin with, for any change that is permitted by Go 1 compatibility but\nstill might break existing programs,\nwe do all the work we just saw to understand potential\ncompatibility problems, and we engineer the change to keep as many existing\nprograms working as possible.\nFor the remaining programs, the new approach is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eWe will define a new GODEBUG setting that allows\nindividual programs to opt out of the new behavior.\nA GODEBUG setting may not be added if doing so is infeasible, but that should be extremely rare.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGODEBUG settings added for compatibility will be maintained for a minimum\nof two years (four Go releases). Some, such as \u003ccode\u003ehttp2client\u003c/code\u003e and \u003ccode\u003ehttp2server\u003c/code\u003e,\nwill be maintained much longer, even indefinitely.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWhen possible, each GODEBUG setting has an associated\n\u003ca href=\"/pkg/runtime/metrics/\"\u003e\u003ccode\u003eruntime/metrics\u003c/code\u003e\u003c/a\u003e counter\nnamed \u003ccode\u003e/godebug/non-default-behavior/\u0026lt;name\u0026gt;:events\u003c/code\u003e\nthat counts the number of times a particular program’s behavior\nhas changed based on a non-default value for that setting.\nFor example, when \u003ccode\u003eGODEBUG=http2client=0\u003c/code\u003e is set,\n\u003ccode\u003e/godebug/non-default-behavior/http2client:events\u003c/code\u003e counts the\nnumber of HTTP transports that the program has configured without HTTP/2 support.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA program’s GODEBUG settings are configured to match the Go version\nlisted in the main package’s \u003ccode\u003ego.mod\u003c/code\u003e file.\nIf your program’s \u003ccode\u003ego.mod\u003c/code\u003e file says \u003ccode\u003ego 1.20\u003c/code\u003e and you update to\na Go 1.21 toolchain, any GODEBUG-controlled behaviors changed in\nGo 1.21 will retain their old Go 1.20 behavior until you change the\n\u003ccode\u003ego.mod\u003c/code\u003e to say \u003ccode\u003ego 1.21\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eA program can change individual GODEBUG settings by using \u003ccode\u003e//go:debug\u003c/code\u003e lines\nin package \u003ccode\u003emain\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAll GODEBUG settings are documented in a \u003ca href=\"/doc/godebug#history\"\u003esingle, central list\u003c/a\u003e\nfor easy reference.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis approach means that each new version of Go should be the best possible\nimplementation of older versions of Go, even preserving behaviors that were\nchanged in compatible-but-breaking ways in later releases when compiling old code.\u003c/p\u003e\n\u003cp\u003eFor example, in Go 1.21, \u003ccode\u003epanic(nil)\u003c/code\u003e now causes a (non-nil) runtime panic,\nso that the result of \u003ca href=\"/ref/spec/#Handling_panics\"\u003e\u003ccode\u003erecover\u003c/code\u003e\u003c/a\u003e now reliably\nreports whether the current goroutine is panicking.\nThis new behavior is controlled by a GODEBUG setting and therefore dependent\non the main package’s \u003ccode\u003ego.mod\u003c/code\u003e’s \u003ccode\u003ego\u003c/code\u003e line: if it says \u003ccode\u003ego 1.20\u003c/code\u003e or earlier,\n\u003ccode\u003epanic(nil)\u003c/code\u003e is still allowed.\nIf it says \u003ccode\u003ego 1.21\u003c/code\u003e or later, \u003ccode\u003epanic(nil)\u003c/code\u003e turns into a panic with a \u003ccode\u003eruntime.PanicNilError\u003c/code\u003e.\nAnd the version-based default can be overridden explicitly by adding a line like this to package main:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//go:debug panicnil=1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis combination of features means that programs can update to newer toolchains\nwhile preserving the behaviors of the earlier toolchains they used,\ncan apply finer-grained control over specific settings as needed,\nand can use production monitoring to understand which jobs make\nuse of these non-default behaviors in practice.\nCombined, those should make rolling out new toolchains even\nsmoother than in the past.\u003c/p\u003e\n\u003cp\u003eSee “\u003ca href=\"/doc/godebug\"\u003eGo, Backwards Compatibility, and GODEBUG\u003c/a\u003e” for more details.\u003c/p\u003e\n\u003ch2 id=\"go2\"\u003eAn Update on Go 2\u003c/h2\u003e\n\u003cp\u003eIn the quoted text from “\u003ca href=\"/doc/go1compat\"\u003eGo 1 and the Future of Go Programs\u003c/a\u003e”\nat the top of this post, the ellipsis hid the following qualifier:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAt some indefinite point, a Go 2 specification may arise,\nbut until that time, [… all the compatibility details …].\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThat raises an obvious question: when should we expect the\nGo 2 specification that breaks old Go 1 programs?\u003c/p\u003e\n\u003cp\u003eThe answer is never.\nGo 2, in the sense of breaking with the past\nand no longer compiling old programs,\nis never going to happen.\nGo 2 in the sense of being the major revision of Go 1\nwe started toward in 2017 has already happened.\u003c/p\u003e\n\u003cp\u003eThere will not be a Go 2 that breaks Go 1 programs.\nInstead, we are going to double down on compatibility,\nwhich is far more valuable than any possible break with the past.\nIn fact, we believe that prioritizing compatibility\nwas the most important design decision we made for Go 1.\u003c/p\u003e\n\u003cp\u003eSo what you will see over the next few years\nis plenty of new, exciting work, but done in a careful,\ncompatible way, so that we can keep your upgrades from\none toolchain to the next as boring as possible.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-08-14T00:00:00Z",
  "Author": "Russ Cox"
}