{
  "Source": "go.dev",
  "Title": "Automatic cipher suite ordering in crypto/tls",
  "Link": "https://go.dev/blog/tls-cipher-suites",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/tls-cipher-suites\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eAutomatic cipher suite ordering in crypto/tls\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Filippo Valsorda\u003cbr/\u003e\n      15 September 2021\n      \u003c/p\u003e\n      \n      \u003cp\u003eThe Go standard library provides \u003ccode\u003ecrypto/tls\u003c/code\u003e,\na robust implementation of Transport Layer Security (TLS),\nthe most important security protocol on the Internet,\nand the fundamental component of HTTPS.\nIn Go 1.17 we made its configuration easier, more secure,\nand more efficient by automating the priority order of cipher suites.\u003c/p\u003e\n\u003ch2 id=\"how-cipher-suites-work\"\u003eHow cipher suites work\u003c/h2\u003e\n\u003cp\u003eCipher suites date back to TLS’s predecessor Secure Socket Layer (SSL),\nwhich \u003ca href=\"https://datatracker.ietf.org/doc/html/draft-hickman-netscape-ssl-00#appendix-C.4\" rel=\"noreferrer\" target=\"_blank\"\u003ecalled them “cipher kinds”\u003c/a\u003e.\nThey are the intimidating-looking identifiers like\n\u003ccode\u003eTLS_RSA_WITH_AES_256_CBC_SHA\u003c/code\u003e and\n\u003ccode\u003eTLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\u003c/code\u003e\nthat spell out the algorithms used to exchange keys,\nauthenticate certificates, and encrypt records in a TLS connection.\u003c/p\u003e\n\u003cp\u003eCipher suites are \u003cem\u003enegotiated\u003c/em\u003e during the TLS handshake:\nthe client sends the list of cipher suites it supports in its first message,\nthe Client Hello, and the server picks one from that list,\ncommunicating its choice to the client.\nThe client sends the list of supported cipher suites in its own preference order,\nand the server is free to pick from it however it wants.\nMost commonly, the server will pick the first mutually supported cipher\nsuite either in client preference order or in server preference order,\nbased on its configuration.\u003c/p\u003e\n\u003cp\u003eCipher suites are really only one of many negotiated parameters—supported\ncurves/groups and signature algorithms are additionally negotiated through\ntheir own extensions—but are the most complex and famous ones,\nand the only ones that developers and administrators were trained over the\nyears to have opinions on.\u003c/p\u003e\n\u003cp\u003eIn TLS 1.0–1.2, all these parameters interact in a complex web of inter-dependencies:\nfor example supported certificates depend on supported signature algorithms,\nsupported curves, and supported cipher suites.\nIn TLS 1.3 this was all drastically simplified:\ncipher suites only specify symmetric encryption algorithms,\nwhile supported curves/groups govern the key exchange and supported signature\nalgorithms apply to the certificate.\u003c/p\u003e\n\u003ch2 id=\"a-complex-choice-abdicated-to-developers\"\u003eA complex choice abdicated to developers\u003c/h2\u003e\n\u003cp\u003eMost HTTPS and TLS servers delegate the choice of cipher suites and preference\norder to the server operator or the applications developer.\nThis is a complex choice that requires up-to-date and specialized knowledge for many reasons.\u003c/p\u003e\n\u003cp\u003eSome older cipher suites have insecure components,\nsome require extremely careful and complex implementations to be secure,\nand some are only secure if the client applies certain mitigations or even\nhas certain hardware.\nBeyond the security of the individual components,\ndifferent cipher suites can provide drastically different security properties\nfor the whole connection,\nas cipher suites without ECDHE or DHE don’t provide forward secrecy—the\nproperty that connections can’t be retroactively or passively decrypted\nwith the certificate’s key.\nFinally, the choice of supported cipher suites impacts compatibility and performance,\nand making changes without an up-to-date understanding of the ecosystem\ncan lead to breaking connections from legacy clients,\nincreasing the resources consumed by the server,\nor draining the batteries of mobile clients.\u003c/p\u003e\n\u003cp\u003eThis choice is so arcane and delicate that there are dedicated tools to guide operators,\nsuch as the excellent \u003ca href=\"https://ssl-config.mozilla.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eMozilla SSL Configuration Generator\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eHow did we get here and why is it like this?\u003c/p\u003e\n\u003cp\u003eTo start, individual cryptographic components used to break much more often.\nIn 2011, when the BEAST attack broke CBC cipher suites in such a way that\nonly clients could mitigate the attack,\nservers moved to preferring RC4, which was unaffected.\nIn 2013, when it became clear that RC4 was broken,\nservers went back to CBC.\nWhen Lucky Thirteen made it clear it was extremely hard to implement CBC\ncipher suites due to their backwards MAC-then-encrypt design…\nWell, there wasn’t anything else on the table so implementations had to\n\u003ca href=\"https://www.imperialviolet.org/2013/02/04/luckythirteen.html\" rel=\"noreferrer\" target=\"_blank\"\u003ecarefully jump through hoops\u003c/a\u003e\nto implement CBC and kept \u003ca href=\"https://blog.cloudflare.com/yet-another-padding-oracle-in-openssl-cbc-ciphersuites/\" rel=\"noreferrer\" target=\"_blank\"\u003efailing at that daunting task for years\u003c/a\u003e.\nConfigurable cipher suites and \u003ca href=\"https://www.imperialviolet.org/2016/05/16/agility.html\" rel=\"noreferrer\" target=\"_blank\"\u003ecryptographic agility\u003c/a\u003e\nused to provide some reassurance that when a component broke it could be\nreplaced on the fly.\u003c/p\u003e\n\u003cp\u003eModern cryptography is significantly different.\nProtocols can still break from time to time,\nbut it’s rarely an individual abstracted component that fails.\n\u003cem\u003eNone of the AEAD-based cipher suites introduced starting with TLS 1.2 in\n2008 have been broken.\u003c/em\u003e These days cryptographic agility is a liability:\nit introduces complexity that can lead to weaknesses or downgrades,\nand it is only necessary for performance and compliance reasons.\u003c/p\u003e\n\u003cp\u003ePatching used to be different, too. Today we acknowledge that promptly applying\nsoftware patches for disclosed vulnerabilities is the cornerstone of secure\nsoftware deployments,\nbut ten years ago it was not standard practice.\nChanging configuration was seen as a much more rapid option to respond to\nvulnerable cipher suites,\nso the operator, through configuration, was put fully in charge of them.\nWe now have the opposite problem: there are fully patched and updated servers\nthat still behave weirdly,\nsuboptimally, or insecurely, because their configurations haven’t been touched in years.\u003c/p\u003e\n\u003cp\u003eFinally, it was understood that servers tended to update more slowly than clients,\nand therefore were less reliable judges of the best choice of cipher suite.\nHowever, it’s servers who have the last word on cipher suite selection,\nso the default became to make servers defer to the client preference order,\ninstead of having strong opinions.\nThis is still partially true: browsers managed to make automatic updates\nhappen and are much more up-to-date than the average server.\nOn the other hand, a number of legacy devices are now out of support and\nare stuck on old TLS client configurations,\nwhich often makes an up-to-date server better equipped to choose than some of its clients.\u003c/p\u003e\n\u003cp\u003eRegardless of how we got here, it’s a failure of cryptography engineering\nto require application developers and server operators to become experts\nin the nuances of cipher suite selection,\nand to stay up-to-date on the latest developments to keep their configs up-to-date.\nIf they are deploying our security patches,\nthat should be enough.\u003c/p\u003e\n\u003cp\u003eThe Mozilla SSL Configuration Generator is great, and it should not exist.\u003c/p\u003e\n\u003cp\u003eIs this getting any better?\u003c/p\u003e\n\u003cp\u003eThere is good news and bad news for how things are trending in the past few years.\nThe bad news is that ordering is getting even more nuanced,\nbecause there are sets of cipher suites that have equivalent security properties.\nThe best choice within such a set depends on the available hardware and\nis hard to express in a config file.\nIn other systems, what started as a simple list of cipher suites now depends\non \u003ca href=\"https://boringssl.googlesource.com/boringssl/+/c3b373bf4f4b2e2fba2578d1d5b5fe04e410f7cb/include/openssl/ssl.h#1457\" rel=\"noreferrer\" target=\"_blank\"\u003emore complex syntax\u003c/a\u003e\nor additional flags like \u003ca href=\"https://www.openssl.org/docs/man1.1.1/man3/SSL_CTX_clear_options.html#:~:text=session-,ssl_op_prioritize_chacha,-When\" rel=\"noreferrer\" target=\"_blank\"\u003eSSL_OP_PRIORITIZE_CHACHA\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe good news is that TLS 1.3 drastically simplified cipher suites,\nand it uses a disjoint set from TLS 1.0–1.2.\nAll TLS 1.3 cipher suites are secure, so application developers and server\noperators shouldn’t have to worry about them at all.\nIndeed, some TLS libraries like BoringSSL and Go’s \u003ccode\u003ecrypto/tls\u003c/code\u003e don’t\nallow configuring them at all.\u003c/p\u003e\n\u003ch2 id=\"gos-cryptotls-and-cipher-suites\"\u003eGo’s crypto/tls and cipher suites\u003c/h2\u003e\n\u003cp\u003eGo does allow configuring cipher suites in TLS 1.0–1.2.\nApplications have always been able to set the enabled cipher suites and\npreference order with \u003ca href=\"https://pkg.go.dev/crypto/tls#Config.CipherSuites\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eConfig.CipherSuites\u003c/code\u003e\u003c/a\u003e.\nServers prioritize the client’s preference order by default,\nunless \u003ca href=\"https://pkg.go.dev/crypto/tls#Config.PreferServerCipherSuites\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eConfig.PreferServerCipherSuites\u003c/code\u003e\u003c/a\u003e is set.\u003c/p\u003e\n\u003cp\u003eWhen we implemented TLS 1.3 in Go 1.12, \u003ca href=\"/issue/29349\"\u003ewe didn’t make TLS 1.3 cipher suites configurable\u003c/a\u003e,\nbecause they are a disjoint set from the TLS 1.0–1.2 ones and most importantly\nthey are all secure,\nso there is no need to delegate a choice to the application.\n\u003ccode\u003eConfig.PreferServerCipherSuites\u003c/code\u003e still controls which side’s preference order is used,\nand the local side’s preferences depend on the available hardware.\u003c/p\u003e\n\u003cp\u003eIn Go 1.14 we \u003ca href=\"https://pkg.go.dev/crypto/tls#CipherSuites\" rel=\"noreferrer\" target=\"_blank\"\u003eexposed supported cipher suites\u003c/a\u003e,\nbut explicitly chose to return them in a neutral order (sorted by their ID),\nso that we wouldn’t end up tied to representing our priority logic in\nterms of a static sort order.\u003c/p\u003e\n\u003cp\u003eIn Go 1.16, we started actively \u003ca href=\"/cl/262857\"\u003epreferring ChaCha20Poly1305 cipher suites over AES-GCM on the server\u003c/a\u003e\nwhen we detect that either the client or the server lacks hardware support for AES-GCM.\nThis is because AES-GCM is hard to implement efficiently and securely without\ndedicated hardware support (such as the AES-NI and CLMUL instruction sets).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGo 1.17, recently released, takes over cipher suite preference ordering for all Go users.\u003c/strong\u003e\nWhile \u003ccode\u003eConfig.CipherSuites\u003c/code\u003e still controls which TLS 1.0–1.2 cipher suites are enabled,\nit is not used for ordering, and \u003ccode\u003eConfig.PreferServerCipherSuites\u003c/code\u003e is now ignored.\nInstead, \u003ccode\u003ecrypto/tls\u003c/code\u003e \u003ca href=\"/cl/314609\"\u003emakes all ordering decisions\u003c/a\u003e,\nbased on the available cipher suites, the local hardware,\nand the inferred remote hardware capabilities.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://cs.opensource.google/go/go/+/9d0819b27ca248f9949e7cf6bf7cb9fe7cf574e8:src/crypto/tls/cipher_suites.go;l=206-270\" rel=\"noreferrer\" target=\"_blank\"\u003ecurrent TLS 1.0–1.2 ordering logic\u003c/a\u003e\nfollows the following rules:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eECDHE is preferred over the static RSA key exchange.\u003c/p\u003e\n\u003cp\u003eThe most important property of a cipher suite is enabling forward secrecy.\nWe don’t implement “classic” finite-field Diffie-Hellman,\nbecause it’s complex, slower, weaker, and \u003ca href=\"https://datatracker.ietf.org/doc/draft-bartle-tls-deprecate-ffdh/\" rel=\"noreferrer\" target=\"_blank\"\u003esubtly broken\u003c/a\u003e in TLS 1.0–1.2,\nso that means prioritizing the Elliptic Curve Diffie-Hellman key exchange\nover the legacy static RSA key exchange.\n(The latter simply encrypts the connection’s secret using the certificate’s\npublic key, making it possible to decrypt if the certificate is compromised\nin the future.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAEAD modes are preferred over CBC for encryption.\u003c/p\u003e\n\u003cp\u003eEven if we do implement partial countermeasures for Lucky13\n(\u003ca href=\"/cl/18130\"\u003emy first contribution to the Go standard library, back in 2015!\u003c/a\u003e),\nthe CBC suites are \u003ca href=\"https://blog.cloudflare.com/yet-another-padding-oracle-in-openssl-cbc-ciphersuites/\" rel=\"noreferrer\" target=\"_blank\"\u003ea nightmare to get right\u003c/a\u003e,\nso all other more important things being equal,\nwe pick AES-GCM and ChaCha20Poly1305 instead.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e3DES, CBC-SHA256, and RC4 are only used if nothing else is available, in that preference order.\u003c/p\u003e\n\u003cp\u003e3DES has 64-bit blocks, which makes it fundamentally vulnerable to\n\u003ca href=\"https://sweet32.info\" rel=\"noreferrer\" target=\"_blank\"\u003ebirthday attacks\u003c/a\u003e given enough traffic.\n3DES is listed under \u003ca href=\"https://pkg.go.dev/crypto/tls#InsecureCipherSuites\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eInsecureCipherSuites\u003c/code\u003e\u003c/a\u003e,\nbut it’s enabled by default for compatibility.\n(An additional benefit of controlling preference orders is that\nwe can afford to keep less secure cipher suites enabled by default\nwithout worrying about applications or clients selecting them\nexcept as a last resort.\nThis is safe because there are no downgrade attacks that rely on\nthe availability of a weaker cipher suite to attack peers\nthat support better alternatives.)\u003c/p\u003e\n\u003cp\u003eThe CBC cipher suites are vulnerable to Lucky13-style side channel attacks\nand we only partially implement the \u003ca href=\"https://www.imperialviolet.org/2013/02/04/luckythirteen.html\" rel=\"noreferrer\" target=\"_blank\"\u003ecomplex\u003c/a\u003e\ncountermeasures discussed above for the SHA-1 hash, not for SHA-256.\nCBC-SHA1 suites have compatibility value, justifying the extra complexity,\nwhile the CBC-SHA256 ones don’t, so they are disabled by default.\u003c/p\u003e\n\u003cp\u003eRC4 has \u003ca href=\"https://www.rc4nomore.com\" rel=\"noreferrer\" target=\"_blank\"\u003epractically exploitable biases\u003c/a\u003e\nthat can lead to plaintext recovery without side channels.\nIt doesn’t get any worse than this, so RC4 is disabled by default.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eChaCha20Poly1305 is preferred over AES-GCM for encryption,\nunless both sides have hardware support for the latter.\u003c/p\u003e\n\u003cp\u003eAs we discussed above, AES-GCM is hard to implement efficiently and\nsecurely without hardware support.\nIf we detect that there isn’t local hardware support or (on the server)\nthat the client has not prioritized AES-GCM,\nwe pick ChaCha20Poly1305 instead.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAES-128 is preferred over AES-256 for encryption.\u003c/p\u003e\n\u003cp\u003eAES-256 has a larger key than AES-128, which is usually good,\nbut it also performs more rounds of the core encryption function,\nmaking it slower.\n(The extra rounds in AES-256 are independent of the key size change;\nthey are an attempt to provide a wider margin against cryptanalysis.)\nThe larger key is only useful in multi-user and post-quantum settings,\nwhich are not relevant to TLS, which generates sufficiently random IVs\nand has no post-quantum key exchange support.\nSince the larger key doesn’t have any benefit,\nwe prefer AES-128 for its speed.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003ca href=\"https://cs.opensource.google/go/go/+/9d0819b27ca248f9949e7cf6bf7cb9fe7cf574e8:src/crypto/tls/cipher_suites.go;l=342-355\" rel=\"noreferrer\" target=\"_blank\"\u003eTLS 1.3’s ordering logic\u003c/a\u003e\nneeds only the last two rules,\nbecause TLS 1.3 eliminated the problematic algorithms the first three rules\nare guarding against.\u003c/p\u003e\n\u003ch2 id=\"faqs\"\u003eFAQs\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eWhat if a cipher suite turns out to be broken?\u003c/em\u003e Just like any other vulnerability,\nit will be fixed in a security release for all supported Go versions.\nAll applications need to be prepared to apply security fixes to operate securely.\nHistorically, broken cipher suites are increasingly rare.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eWhy leave enabled TLS 1.0–1.2 cipher suites configurable?\u003c/em\u003e There is a\nmeaningful tradeoff between \u003cem\u003ebaseline\u003c/em\u003e security and legacy compatibility\nto make in choosing which cipher suites to enable,\nand that’s a choice we can’t make ourselves without either cutting out\nan unacceptable slice of the ecosystem,\nor reducing the security guarantees of modern users.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eWhy not make TLS 1.3 cipher suites configurable?\u003c/em\u003e Conversely,\nthere is no tradeoff to make with TLS 1.3,\nas all its cipher suites provide strong security.\nThis lets us leave them all enabled and pick the fastest based on the specifics\nof the connection without requiring the developer’s involvement.\u003c/p\u003e\n\u003ch2 id=\"key-takeaways\"\u003eKey takeaways\u003c/h2\u003e\n\u003cp\u003eStarting in Go 1.17, \u003ccode\u003ecrypto/tls\u003c/code\u003e is taking over the order in which available\ncipher suites are selected.\nWith a regularly updated Go version, this is safer than letting potentially\noutdated clients pick the order,\nlets us optimize performance, and it lifts significant complexity from Go developers.\u003c/p\u003e\n\u003cp\u003eThis is consistent with our general philosophy of making cryptographic decisions whenever we can,\ninstead of delegating them to developers,\nand with our \u003ca href=\"/design/cryptography-principles\"\u003ecryptography principles\u003c/a\u003e.\nHopefully other TLS libraries will adopt similar changes,\nmaking delicate cipher suite configuration a thing of the past.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-09-15T00:00:00Z",
  "Author": "Filippo Valsorda"
}