{
  "Source": "go.dev",
  "Title": "Share Memory By Communicating",
  "Link": "https://go.dev/blog/codelab-share",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/codelab-share\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eShare Memory By Communicating\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      13 July 2010\n      \u003c/p\u003e\n      \n      \u003cp\u003eTraditional threading models (commonly used when writing Java,\nC++, and Python programs, for example) require the programmer to communicate\nbetween threads using shared memory.\nTypically, shared data structures are protected by locks,\nand threads will contend over those locks to access the data.\nIn some cases, this is made easier by the use of thread-safe data structures\nsuch as Python’s Queue.\u003c/p\u003e\n\u003cp\u003eGo’s concurrency primitives - goroutines and channels - provide an elegant\nand distinct means of structuring concurrent software.\n(These concepts have an \u003ca href=\"https://swtch.com/~rsc/thread/\" rel=\"noreferrer\" target=\"_blank\"\u003einteresting history\u003c/a\u003e that begins with C.\nA. R. Hoare’s \u003ca href=\"http://www.usingcsp.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eCommunicating Sequential Processes\u003c/a\u003e.)\nInstead of explicitly using locks to mediate access to shared data,\nGo encourages the use of channels to pass references to data between goroutines.\nThis approach ensures that only one goroutine has access to the data at a given time.\nThe concept is summarized in the document \u003ca href=\"/doc/effective_go.html\"\u003eEffective Go\u003c/a\u003e\n(a must-read for any Go programmer):\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eDo not communicate by sharing memory; instead, share memory by communicating.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eConsider a program that polls a list of URLs.\nIn a traditional threading environment, one might structure its data like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Resource struct {\n    url        string\n    polling    bool\n    lastPolled int64\n}\n\ntype Resources struct {\n    data []*Resource\n    lock *sync.Mutex\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd then a Poller function (many of which would run in separate threads) might look something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Poller(res *Resources) {\n    for {\n        // get the least recently-polled Resource\n        // and mark it as being polled\n        res.lock.Lock()\n        var r *Resource\n        for _, v := range res.data {\n            if v.polling {\n                continue\n            }\n            if r == nil || v.lastPolled \u0026lt; r.lastPolled {\n                r = v\n            }\n        }\n        if r != nil {\n            r.polling = true\n        }\n        res.lock.Unlock()\n        if r == nil {\n            continue\n        }\n\n        // poll the URL\n\n        // update the Resource\u0026#39;s polling and lastPolled\n        res.lock.Lock()\n        r.polling = false\n        r.lastPolled = time.Nanoseconds()\n        res.lock.Unlock()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function is about a page long, and requires more detail to make it complete.\nIt doesn’t even include the URL polling logic (which,\nitself, would only be a few lines), nor will it gracefully handle exhausting\nthe pool of Resources.\u003c/p\u003e\n\u003cp\u003eLet’s take a look at the same functionality implemented using Go idiom.\nIn this example, Poller is a function that receives Resources to be polled\nfrom an input channel,\nand sends them to an output channel when they’re done.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Resource string\n\nfunc Poller(in, out chan *Resource) {\n    for r := range in {\n        // poll the URL\n\n        // send the processed Resource to out\n        out \u0026lt;- r\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe delicate logic from the previous example is conspicuously absent,\nand our Resource data structure no longer contains bookkeeping data.\nIn fact, all that’s left are the important parts.\nThis should give you an inkling as to the power of these simple language features.\u003c/p\u003e\n\u003cp\u003eThere are many omissions from the above code snippets.\nFor a walkthrough of a complete, idiomatic Go program that uses these ideas,\nsee the Codewalk \u003ca href=\"/doc/codewalk/sharemem/\"\u003e\u003cem\u003eShare Memory By Communicating\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-07-13T00:00:00Z",
  "Author": "Andrew Gerrand"
}