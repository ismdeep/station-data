{
  "Source": "go.dev",
  "Title": "Using Subtests and Sub-benchmarks",
  "Link": "https://go.dev/blog/subtests",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/subtests\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eUsing Subtests and Sub-benchmarks\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Marcel van Lohuizen\u003cbr/\u003e\n      3 October 2016\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn Go 1.7, the \u003ccode\u003etesting\u003c/code\u003e package introduces a Run method on the\n\u003ca href=\"/pkg/testing/#T.Run\"\u003e\u003ccode\u003eT\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/testing/#B.Run\"\u003e\u003ccode\u003eB\u003c/code\u003e\u003c/a\u003e types\nthat allows for the creation of subtests and sub-benchmarks.\nThe introduction of subtests and sub-benchmarks enables better handling of\nfailures, fine-grained control of which tests to run from the command line,\ncontrol of parallelism, and often results in simpler and more maintainable code.\u003c/p\u003e\n\u003ch2 id=\"table-driven-tests-basics\"\u003eTable-driven tests basics\u003c/h2\u003e\n\u003cp\u003eBefore digging into the details, let’s first discuss a common\nway of writing tests in Go.\nA series of related checks can be implemented by looping over a slice of test\ncases:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestTime(t *testing.T) {\n    testCases := []struct {\n        gmt  string\n        loc  string\n        want string\n    }{\n        {\u0026#34;12:31\u0026#34;, \u0026#34;Europe/Zuri\u0026#34;, \u0026#34;13:31\u0026#34;},     // incorrect location name\n        {\u0026#34;12:31\u0026#34;, \u0026#34;America/New_York\u0026#34;, \u0026#34;7:31\u0026#34;}, // should be 07:31\n        {\u0026#34;08:08\u0026#34;, \u0026#34;Australia/Sydney\u0026#34;, \u0026#34;18:08\u0026#34;},\n    }\n    for _, tc := range testCases {\n        loc, err := time.LoadLocation(tc.loc)\n        if err != nil {\n            t.Fatalf(\u0026#34;could not load location %q\u0026#34;, tc.loc)\n        }\n        gmt, _ := time.Parse(\u0026#34;15:04\u0026#34;, tc.gmt)\n        if got := gmt.In(loc).Format(\u0026#34;15:04\u0026#34;); got != tc.want {\n            t.Errorf(\u0026#34;In(%s, %s) = %s; want %s\u0026#34;, tc.gmt, tc.loc, got, tc.want)\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis approach, commonly referred to as table-driven tests, reduces the amount\nof repetitive code compared to repeating the same code for each test\nand makes it straightforward to add more test cases.\u003c/p\u003e\n\u003ch2 id=\"table-driven-benchmarks\"\u003eTable-driven benchmarks\u003c/h2\u003e\n\u003cp\u003eBefore Go 1.7 it was not possible to use the same table-driven approach for\nbenchmarks.\nA benchmark tests the performance of an entire function, so iterating over\nbenchmarks would just measure all of them as a single benchmark.\u003c/p\u003e\n\u003cp\u003eA common workaround was to define separate top-level benchmarks\nthat each call a common function with different parameters.\nFor instance, before 1.7 the \u003ccode\u003estrconv\u003c/code\u003e package’s benchmarks for \u003ccode\u003eAppendFloat\u003c/code\u003e\nlooked something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc benchmarkAppendFloat(b *testing.B, f float64, fmt byte, prec, bitSize int) {\n    dst := make([]byte, 30)\n    b.ResetTimer() // Overkill here, but for illustrative purposes.\n    for i := 0; i \u0026lt; b.N; i++ {\n        AppendFloat(dst[:0], f, fmt, prec, bitSize)\n    }\n}\n\nfunc BenchmarkAppendFloatDecimal(b *testing.B) { benchmarkAppendFloat(b, 33909, \u0026#39;g\u0026#39;, -1, 64) }\nfunc BenchmarkAppendFloat(b *testing.B)        { benchmarkAppendFloat(b, 339.7784, \u0026#39;g\u0026#39;, -1, 64) }\nfunc BenchmarkAppendFloatExp(b *testing.B)     { benchmarkAppendFloat(b, -5.09e75, \u0026#39;g\u0026#39;, -1, 64) }\nfunc BenchmarkAppendFloatNegExp(b *testing.B)  { benchmarkAppendFloat(b, -5.11e-95, \u0026#39;g\u0026#39;, -1, 64) }\nfunc BenchmarkAppendFloatBig(b *testing.B)     { benchmarkAppendFloat(b, 123456789123456789123456789, \u0026#39;g\u0026#39;, -1, 64) }\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing the \u003ccode\u003eRun\u003c/code\u003e method available in Go 1.7, the same set of benchmarks is now\nexpressed as a single top-level benchmark:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc BenchmarkAppendFloat(b *testing.B) {\n    benchmarks := []struct{\n        name    string\n        float   float64\n        fmt     byte\n        prec    int\n        bitSize int\n    }{\n        {\u0026#34;Decimal\u0026#34;, 33909, \u0026#39;g\u0026#39;, -1, 64},\n        {\u0026#34;Float\u0026#34;, 339.7784, \u0026#39;g\u0026#39;, -1, 64},\n        {\u0026#34;Exp\u0026#34;, -5.09e75, \u0026#39;g\u0026#39;, -1, 64},\n        {\u0026#34;NegExp\u0026#34;, -5.11e-95, \u0026#39;g\u0026#39;, -1, 64},\n        {\u0026#34;Big\u0026#34;, 123456789123456789123456789, \u0026#39;g\u0026#39;, -1, 64},\n        ...\n    }\n    dst := make([]byte, 30)\n    for _, bm := range benchmarks {\n        b.Run(bm.name, func(b *testing.B) {\n            for i := 0; i \u0026lt; b.N; i++ {\n                AppendFloat(dst[:0], bm.float, bm.fmt, bm.prec, bm.bitSize)\n            }\n        })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach invocation of the \u003ccode\u003eRun\u003c/code\u003e method creates a separate benchmark.\nAn enclosing benchmark function that calls a \u003ccode\u003eRun\u003c/code\u003e method is only run once and\nis not measured.\u003c/p\u003e\n\u003cp\u003eThe new code has more lines of code, but is more maintainable, more readable,\nand consistent with the table-driven approach commonly used for testing.\nMoreover, common setup code is now shared between runs while eliminating the\nneed to reset the timer.\u003c/p\u003e\n\u003ch2 id=\"table-driven-tests-using-subtests\"\u003eTable-driven tests using subtests\u003c/h2\u003e\n\u003cp\u003eGo 1.7 also introduces a \u003ccode\u003eRun\u003c/code\u003e method for creating subtests.\nThis test is a rewritten version of our earlier example using subtests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestTime(t *testing.T) {\n    testCases := []struct {\n        gmt  string\n        loc  string\n        want string\n    }{\n        {\u0026#34;12:31\u0026#34;, \u0026#34;Europe/Zuri\u0026#34;, \u0026#34;13:31\u0026#34;},\n        {\u0026#34;12:31\u0026#34;, \u0026#34;America/New_York\u0026#34;, \u0026#34;7:31\u0026#34;},\n        {\u0026#34;08:08\u0026#34;, \u0026#34;Australia/Sydney\u0026#34;, \u0026#34;18:08\u0026#34;},\n    }\n    for _, tc := range testCases {\n        t.Run(fmt.Sprintf(\u0026#34;%s in %s\u0026#34;, tc.gmt, tc.loc), func(t *testing.T) {\n            loc, err := time.LoadLocation(tc.loc)\n            if err != nil {\n                t.Fatal(\u0026#34;could not load location\u0026#34;)\n            }\n            gmt, _ := time.Parse(\u0026#34;15:04\u0026#34;, tc.gmt)\n            if got := gmt.In(loc).Format(\u0026#34;15:04\u0026#34;); got != tc.want {\n                t.Errorf(\u0026#34;got %s; want %s\u0026#34;, got, tc.want)\n            }\n        })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe first thing to note is the difference in output from the two implementations.\nThe original implementation prints:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e--- FAIL: TestTime (0.00s)\n    time_test.go:62: could not load location \u0026#34;Europe/Zuri\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEven though there are two errors, execution of the test halts on the call to\n\u003ccode\u003eFatalf\u003c/code\u003e and the second test never runs.\u003c/p\u003e\n\u003cp\u003eThe implementation using \u003ccode\u003eRun\u003c/code\u003e prints both:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e--- FAIL: TestTime (0.00s)\n    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)\n        time_test.go:84: could not load location\n    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)\n        time_test.go:88: got 07:31; want 7:31\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eFatal\u003c/code\u003e and its siblings causes a subtest to be skipped but not its parent or\nsubsequent subtests.\u003c/p\u003e\n\u003cp\u003eAnother thing to note is the shorter error messages in the new implementation.\nSince the subtest name uniquely identifies the subtest there is no need to\nidentify the test again within the error messages.\u003c/p\u003e\n\u003cp\u003eThere are several other benefits to using subtests or sub-benchmarks,\nas clarified by the following sections.\u003c/p\u003e\n\u003ch2 id=\"running-specific-tests-or-benchmarks\"\u003eRunning specific tests or benchmarks\u003c/h2\u003e\n\u003cp\u003eBoth subtests and sub-benchmarks can be singled out on the command line using\nthe \u003ca href=\"/cmd/go/#hdr-Description_of_testing_flags\"\u003e\u003ccode\u003e-run\u003c/code\u003e or \u003ccode\u003e-bench\u003c/code\u003e flag\u003c/a\u003e.\nBoth flags take a slash-separated list of regular expressions that match the\ncorresponding parts of the full name of the subtest or sub-benchmark.\u003c/p\u003e\n\u003cp\u003eThe full name of a subtest or sub-benchmark is a slash-separated list of\nits name and the names of all of its parents, starting with the top-level.\nThe name is the corresponding function name for top-level tests and benchmarks,\nand the first argument to \u003ccode\u003eRun\u003c/code\u003e otherwise.\nTo avoid display and parsing issues, a name is sanitized by replacing spaces\nwith underscores and escaping non-printable characters.\nThe same sanitizing is applied to the regular expressions passed to\nthe \u003ccode\u003e-run\u003c/code\u003e or \u003ccode\u003e-bench\u003c/code\u003e flags.\u003c/p\u003e\n\u003cp\u003eA few examples:\u003c/p\u003e\n\u003cp\u003eRun tests that use a timezone in Europe:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test -run=TestTime/\u0026#34;in Europe\u0026#34;\n--- FAIL: TestTime (0.00s)\n    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)\n        time_test.go:85: could not load location\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRun only tests for times after noon:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test -run=Time/12:[0-9] -v\n=== RUN   TestTime\n=== RUN   TestTime/12:31_in_Europe/Zuri\n=== RUN   TestTime/12:31_in_America/New_York\n--- FAIL: TestTime (0.00s)\n    --- FAIL: TestTime/12:31_in_Europe/Zuri (0.00s)\n        time_test.go:85: could not load location\n    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)\n        time_test.go:89: got 07:31; want 7:31\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePerhaps a bit surprising, using \u003ccode\u003e-run=TestTime/New_York\u003c/code\u003e won’t match any tests.\nThis is because the slash present in the location names is treated as\na separator as well.\nInstead use:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go test -run=Time//New_York\n--- FAIL: TestTime (0.00s)\n    --- FAIL: TestTime/12:31_in_America/New_York (0.00s)\n        time_test.go:88: got 07:31; want 7:31\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote the \u003ccode\u003e//\u003c/code\u003e in the string passed to \u003ccode\u003e-run\u003c/code\u003e.\nThe \u003ccode\u003e/\u003c/code\u003e in time zone name \u003ccode\u003eAmerica/New_York\u003c/code\u003e is handled as if it were\na separator resulting from a subtest.\nThe first regular expression of the pattern (\u003ccode\u003eTestTime\u003c/code\u003e) matches the top-level\ntest.\nThe second regular expression (the empty string) matches anything, in this case\nthe time and the continent part of the location.\nThe third regular expression (\u003ccode\u003eNew_York\u003c/code\u003e) matches the city part of the location.\u003c/p\u003e\n\u003cp\u003eTreating slashes in names as separators allows the user to refactor\nhierarchies of tests without the need to change the naming.\nIt also simplifies the escaping rules.\nThe user should escape slashes in names, for instance by replacing them with\nbackslashes, if this poses a problem.\u003c/p\u003e\n\u003cp\u003eA unique sequence number is appended to test names that are not unique.\nSo one could just pass an empty string to \u003ccode\u003eRun\u003c/code\u003e\nif there is no obvious naming scheme for subtests and the subtests\ncan easily be identified by their sequence number.\u003c/p\u003e\n\u003ch2 id=\"setup-and-tear-down\"\u003eSetup and Tear-down\u003c/h2\u003e\n\u003cp\u003eSubtests and sub-benchmarks can be used to manage common setup and tear-down code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestFoo(t *testing.T) {\n    // \u0026lt;setup code\u0026gt;\n    t.Run(\u0026#34;A=1\u0026#34;, func(t *testing.T) { ... })\n    t.Run(\u0026#34;A=2\u0026#34;, func(t *testing.T) { ... })\n    t.Run(\u0026#34;B=1\u0026#34;, func(t *testing.T) {\n        if !test(foo{B:1}) {\n            t.Fail()\n        }\n    })\n    // \u0026lt;tear-down code\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe setup and tear-down code will run if any of the enclosed subtests are run\nand will run at most once.\nThis applies even if any of the subtests calls \u003ccode\u003eSkip\u003c/code\u003e, \u003ccode\u003eFail\u003c/code\u003e, or \u003ccode\u003eFatal\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"control-of-parallelism\"\u003eControl of Parallelism\u003c/h2\u003e\n\u003cp\u003eSubtests allow fine-grained control over parallelism.\nTo understand how to use subtests in the way\nit is important to understand the semantics of parallel tests.\u003c/p\u003e\n\u003cp\u003eEach test is associated with a test function.\nA test is called a parallel test if its test function calls the Parallel\nmethod on its instance of \u003ccode\u003etesting.T\u003c/code\u003e.\nA parallel test never runs concurrently with a sequential test and its execution\nis suspended until its calling test function, that of the parent test,\nhas returned.\nThe \u003ccode\u003e-parallel\u003c/code\u003e flag defines the maximum number of parallel tests that can run\nin parallel.\u003c/p\u003e\n\u003cp\u003eA test blocks until its test function returns and all of its subtests\nhave completed.\nThis means that the parallel tests that are run by a sequential test will\ncomplete before any other consecutive sequential test is run.\u003c/p\u003e\n\u003cp\u003eThis behavior is identical for tests created by \u003ccode\u003eRun\u003c/code\u003e and top-level tests.\nIn fact, under the hood top-level tests are implemented as subtests of\na hidden master test.\u003c/p\u003e\n\u003ch3 id=\"run-a-group-of-tests-in-parallel\"\u003eRun a group of tests in parallel\u003c/h3\u003e\n\u003cp\u003eThe above semantics allows for running a group of tests in parallel with\neach other but not with other parallel tests:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestGroupedParallel(t *testing.T) {\n    for _, tc := range testCases {\n        tc := tc // capture range variable\n        t.Run(tc.Name, func(t *testing.T) {\n            t.Parallel()\n            if got := foo(tc.in); got != tc.out {\n                t.Errorf(\u0026#34;got %v; want %v\u0026#34;, got, tc.out)\n            }\n            ...\n        })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe outer test will not complete until all parallel tests started by \u003ccode\u003eRun\u003c/code\u003e\nhave completed.\nAs a result, no other parallel tests can run in parallel to these parallel tests.\u003c/p\u003e\n\u003cp\u003eNote that we need to capture the range variable to ensure that \u003ccode\u003etc\u003c/code\u003e gets bound to\nthe correct instance.\u003c/p\u003e\n\u003ch3 id=\"cleaning-up-after-a-group-of-parallel-tests\"\u003eCleaning up after a group of parallel tests\u003c/h3\u003e\n\u003cp\u003eIn the previous example we used the semantics to wait on a group of parallel\ntests to complete before commencing other tests.\nThe same technique can be used to clean up after a group of parallel tests\nthat share common resources:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestTeardownParallel(t *testing.T) {\n    // \u0026lt;setup code\u0026gt;\n    // This Run will not return until its parallel subtests complete.\n    t.Run(\u0026#34;group\u0026#34;, func(t *testing.T) {\n        t.Run(\u0026#34;Test1\u0026#34;, parallelTest1)\n        t.Run(\u0026#34;Test2\u0026#34;, parallelTest2)\n        t.Run(\u0026#34;Test3\u0026#34;, parallelTest3)\n    })\n    // \u0026lt;tear-down code\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe behavior of waiting on a group of parallel tests is identical to that\nof the previous example.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eGo 1.7’s addition of subtests and sub-benchmarks allows you to write structured\ntests and benchmarks in a natural way that blends nicely into the existing\ntools.\nOne way to think about this is that earlier versions of the testing package had\na 1-level hierarchy: the package-level test was structured as a set of\nindividual tests and benchmarks.\nNow that structure has been extended to those individual tests and benchmarks,\nrecursively.\nIn fact, in the implementation, the top-level tests and benchmarks are tracked\nas if they were subtests and sub-benchmarks of an implicit master test and\nbenchmark: the treatment really is the same at all levels.\u003c/p\u003e\n\u003cp\u003eThe ability for tests to define this structure enables fine-grained execution of\nspecific test cases, shared setup and teardown, and better control over test\nparallelism.\nWe are excited to see what other uses people find. Enjoy.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-10-03T00:00:00Z",
  "Author": "Marcel van Lohuizen"
}