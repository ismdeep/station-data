{
  "Source": "go.dev",
  "Title": "Scaling gopls for the growing Go ecosystem",
  "Link": "https://go.dev/blog/gopls-scalability",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/gopls-scalability\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eScaling gopls for the growing Go ecosystem\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Findley and Alan Donovan\u003cbr/\u003e\n      8 September 2023\n      \u003c/p\u003e\n      \n      \u003cstyle type=\"text/css\" scoped=\"\"\u003e\n  .chart {\n    width: 100%;\n  }\n  @media (prefers-color-scheme: dark) {\n    .chart {\n      border-radius: 8px;\n    }\n  }\n\u003c/style\u003e\n\u003cp\u003eEarlier this summer, the Go team released version \u003ca href=\"/s/gopls-v0.12\"\u003ev0.12\u003c/a\u003e\nof \u003ca href=\"https://pkg.go.dev/golang.org/x/tools/gopls\" rel=\"noreferrer\" target=\"_blank\"\u003egopls\u003c/a\u003e,\nthe \u003ca href=\"https://microsoft.github.io/language-server-protocol/\" rel=\"noreferrer\" target=\"_blank\"\u003elanguage server\u003c/a\u003e for Go, featuring a rewrite of its core that allows\nit to scale to larger codebases.\nThis is the culmination of a year-long effort,\nand we’re excited to share our progress, as well as talk a little bit about\nthe new architecture and what it means for the future of gopls.\u003c/p\u003e\n\u003cp\u003eSince the v0.12 release, we’ve fine-tuned the new design,\nfocusing on making interactive queries (such as auto-completion or finding\nreferences) as fast as they were with v0.11,\ndespite holding so much less state in memory.\nIf you haven’t already, we hope you’ll try it out:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go install golang.org/x/tools/gopls@latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’d love to hear about your experience with it via this \u003ca href=\"https://google.qualtrics.com/jfe/form/SV_4SnGxpcSKN33WZw?s=blog\" rel=\"noreferrer\" target=\"_blank\"\u003ebrief survey\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"results\"\u003eReductions in memory use and startup time\u003c/h2\u003e\n\u003cp\u003eBefore we dive into the details, let’s look at the results!\nThe chart below shows the change to startup time and memory usage for 28\nof the most popular Go repositories on GitHub.\nThese measurements were taken after opening a randomly selected Go file\nand waiting for gopls to fully load its state,\nand since we assume that the initial indexing is amortized over many editing sessions,\nwe take these measurements the \u003cem\u003esecond\u003c/em\u003e time we open the file.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"gopls-scalability/performance-improvements.svg\" alt=\"Relative savings\nin memory and startup time\" class=\"chart\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eAcross these repos, the savings average around 75%,\nbut memory reductions are non-linear:\nas projects get larger, so does the relative decrease in memory usage.\nWe’ll explain this in more detail below.\u003c/p\u003e\n\u003ch2 id=\"background\"\u003eGopls and the evolving Go ecosystem\u003c/h2\u003e\n\u003cp\u003eGopls provides language-agnostic editors with IDE-like features such as auto-completion,\nformatting, cross-references, and refactoring.\nSince its beginnings in 2018, gopls has consolidated many disparate command-line\ntools such as \u003ca href=\"https://pkg.go.dev/golang.org/x/tools/cmd/guru\" rel=\"noreferrer\" target=\"_blank\"\u003eguru\u003c/a\u003e,\n\u003ca href=\"https://pkg.go.dev/golang.org/x/tools/cmd/gorename\" rel=\"noreferrer\" target=\"_blank\"\u003egorename\u003c/a\u003e,\nand \u003ca href=\"https://pkg.go.dev/golang.org/x/tools/cmd/goimports\" rel=\"noreferrer\" target=\"_blank\"\u003egoimports\u003c/a\u003e and\nhas become the \u003ca href=\"/blog/gopls-vscode-go\"\u003edefault backend for the VS Code Go extension\u003c/a\u003e\nas well as many other editors and LSP plugins.\nPerhaps you’ve been using gopls through your editor without even knowing\nit—that’s the goal!\u003c/p\u003e\n\u003cp\u003eFive years ago, gopls offered improved performance merely by maintaining a stateful session.\nWhereas older command-line tools had to start from scratch each time they executed,\ngopls could save intermediate results to significantly reduce latency.\nBut all that state came with a cost, and over time we increasingly \u003ca href=\"https://github.com/golang/go/issues?q=is%3Aissue+is%3Aclosed+in%3Atitle+gopls+memory\" rel=\"noreferrer\" target=\"_blank\"\u003eheard from users\u003c/a\u003e\nthat gopls’s high memory usage was barely tolerable.\u003c/p\u003e\n\u003cp\u003eMeanwhile, the Go ecosystem was growing, with more code being written in\nlarger repositories.\n\u003ca href=\"/blog/get-familiar-with-workspaces\"\u003eGo workspaces\u003c/a\u003e allowed\ndevelopers to work on multiple modules simultaneously,\nand \u003ca href=\"https://code.visualstudio.com/docs/devcontainers/containers\" rel=\"noreferrer\" target=\"_blank\"\u003econtainerized development\u003c/a\u003e\nput language servers in increasingly resource-constrained environments.\nCodebases were getting larger, and developer environments were getting smaller.\nWe needed to change the way gopls scaled in order to keep up.\u003c/p\u003e\n\u003ch2 id=\"origins\"\u003eRevisiting gopls’s compiler origins\u003c/h2\u003e\n\u003cp\u003eIn many ways, gopls resembles a compiler:\nit has to read, parse, type-check, and analyze Go source files,\nfor which it uses many of the compiler \u003ca href=\"https://github.com/golang/example/tree/master/gotypes#introduction\" rel=\"noreferrer\" target=\"_blank\"\u003ebuilding blocks\u003c/a\u003e\nprovided by the \u003ca href=\"https://pkg.go.dev/go\" rel=\"noreferrer\" target=\"_blank\"\u003eGo standard library\u003c/a\u003e and \u003ca href=\"https://pkg.go.dev/golang.org/x/tools\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/tools\u003c/a\u003e module.\nThese building blocks use the technique of “symbolic programming”:\nin a running compiler there is a single object or “symbol” that stands for\neach function such as \u003ccode\u003efmt.Println\u003c/code\u003e.\nAny reference to a function is represented as a pointer to its symbol.\nTo test whether two references are talking about the same symbol,\nyou don’t need to think about names.\nYou just compare pointers. A pointer is much smaller than a string,\nand pointer comparison is very cheap, so symbols are an efficient way to\nrepresent a structure as complex as a program.\u003c/p\u003e\n\u003cp\u003eIn order to respond quickly to requests, gopls v0.11 held all these symbols in memory,\nas though gopls was \u003cstrong\u003ecompiling your entire program at once\u003c/strong\u003e.\nThe result was a memory footprint that was proportional to and much larger\nthan the source code being edited (for example,\ntyped syntax trees are typically 30x larger than the source text!).\u003c/p\u003e\n\u003ch2 id=\"separate-compilation\"\u003eSeparate compilation\u003c/h2\u003e\n\u003cp\u003eThe designers of the first compilers in the 1950s quickly discovered the\nlimits of monolithic compilation.\nTheir solution was to break the program into units and compile each unit separately.\nSeparate compilation makes it possible to build a program that does not fit in memory,\nby doing it in small pieces.\nIn Go, the units are packages. Compilation of different packages cannot\nbe completely separated:\nwhen compiling a package P, the compiler still needs information about what’s\nprovided by the packages that P imports.\nTo arrange this, the Go build system compiles all of P’s imported packages before P itself,\nand the Go compiler writes a compact summary of each package’s exported API.\nThe summaries of P’s imported packages are provided as inputs to the compilation of P itself.\u003c/p\u003e\n\u003cp\u003eGopls v0.12 brings separate compilation to gopls,\nreusing the same package summary format used by the compiler.\nThe idea is simple, but there’s subtlety in the details.\nWe rewrote each algorithm that previously inspected the data structure representing the entire program,\nso that it now works on one package at a time and saves per-package results to files,\njust like a compiler emitting object code.\nFor example, finding all references to a function used to be as easy as\nsearching the program data structure for all occurrences of a particular pointer value.\nNow, when gopls processes each package, it must construct and save an index\nthat associates each identifier location in the source code with the name\nof the symbol to which it refers.\nAt query time, gopls loads and searches these indexes.\nOther global queries, such as “find implementations”,\nuse similar techniques.\u003c/p\u003e\n\u003cp\u003eLike the \u003ccode\u003ego build\u003c/code\u003e command, gopls now uses a \u003ca href=\"https://cs.opensource.google/go/x/tools/+/master:gopls/internal/lsp/filecache/filecache.go;l=5;drc=6f567c8090cb88f13a71b19595bf88c6b27dbeed\" rel=\"noreferrer\" target=\"_blank\"\u003efile-based cache\u003c/a\u003e\nstore to record summaries of information computed from each package,\nincluding the type of each declaration, the index of cross-references,\nand the method set of each type.\nSince the cache is persisted across processes,\nyou’ll notice that the second time you start gopls in your workspace,\nit becomes ready to serve much more quickly,\nand if you run two gopls instances, they work together synergistically.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"gopls-scalability/separate-compilation.png\" alt=\"separate compilation\" class=\"chart\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe result of this change is that gopls’s memory use is proportional to\nthe number of open packages and their direct imports.\nThis is why we observe sublinear scaling in the chart above:\nas repositories get larger, the fraction of the project observed by any\none open package gets smaller.\u003c/p\u003e\n\u003ch2 id=\"invalidation\"\u003eFine-grained invalidation\u003c/h2\u003e\n\u003cp\u003eWhen you make a change in one package, it’s only necessary to recompile\nthe packages that import that one,\ndirectly or indirectly.\nThis idea is the basis of all incremental build systems since Make in the 1970s,\nand gopls has been using it since its inception.\nIn effect, every keystroke in your LSP-enabled editor starts an incremental build!\nHowever, in a large project, indirect dependencies add up,\nmaking these incremental rebuilds too slow.\nIt turns out that a lot of this work isn’t strictly necessary,\nbecause most changes, such as adding a statement within an existing function,\ndon’t affect the import summaries.\u003c/p\u003e\n\u003cp\u003eIf you make a small change in one file, we have to recompile its package,\nbut if the change does not affect the import summary, we don’t have to compile any other packages.\nThe effect of the change is “pruned”. A change that does affect the import\nsummary requires recompiling the packages that directly import that package,\nbut most such changes won’t affect the import summaries of \u003cem\u003ethose\u003c/em\u003e packages,\nin which case the effect is still pruned and avoids recompiling indirect importers.\nThanks to this pruning, it is rare for a change in a low-level package to\nrequire recompiling \u003cem\u003eall\u003c/em\u003e the packages that indirectly depend on that package.\nPruned incremental rebuilds make the amount of work proportional to the\nscope of each change.\nThis is not a new idea: it was introduced by \u003ca href=\"https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-177.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003eVesta\u003c/a\u003e\nand also used in \u003ca href=\"/doc/go1.10#build\"\u003e\u003ccode\u003ego build\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe v0.12 release introduces a similar pruning technique to gopls,\ngoing one step further to implement a faster pruning heuristic based on syntactic analysis.\nBy keeping a simplified graph of symbol references in memory,\ngopls can quickly determine whether a change in package \u003ccode\u003ec\u003c/code\u003e can possibly\naffect package \u003ccode\u003ea\u003c/code\u003e through a chain of references.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cimg src=\"gopls-scalability/precise-pruning.png\" alt=\"fine-grained invalidation\" class=\"chart\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eIn the example above, there’s no chain of references from \u003ccode\u003ea\u003c/code\u003e to \u003ccode\u003ec\u003c/code\u003e,\nso a is not exposed to changes in c even though it indirectly depends on it.\u003c/p\u003e\n\u003ch2 id=\"new-possibilities\"\u003eNew possibilities\u003c/h2\u003e\n\u003cp\u003eWhile we’re happy with the performance improvements we’ve achieved,\nwe’re also excited about several gopls features that are feasible now that\ngopls is no longer constrained by memory.\u003c/p\u003e\n\u003cp\u003eThe first is robust static analysis. Previously,\nour static analysis driver had to operate on gopls’s in-memory representation of packages,\nso it couldn’t analyze dependencies:\ndoing so would pull in too much additional code.\nWith that requirement removed, we were able to include a new analysis driver\nin gopls v0.12 that analyzes all dependencies,\nresulting in greater precision.\nFor example, gopls now reports diagnostics for \u003ccode\u003ePrintf\u003c/code\u003e formatting mistakes\neven in your user-defined wrappers around \u003ccode\u003efmt.Printf\u003c/code\u003e.\nNotably, \u003ccode\u003ego vet\u003c/code\u003e has provided this level of precision for years,\nbut gopls was unable to do this in real time after each edit. Now it can.\u003c/p\u003e\n\u003cp\u003eThe second is \u003ca href=\"/issue/57979\"\u003esimpler workspace configuration\u003c/a\u003e\nand \u003ca href=\"/issue/29202\"\u003eimproved handling for build tags\u003c/a\u003e.\nThese two features both amount to gopls “doing the right thing” when you\nopen any Go file on your machine,\nbut both were infeasible without the optimization work because (for example)\neach build configuration multiplies the memory footprint!\u003c/p\u003e\n\u003ch2 id=\"try\"\u003eTry it out!\u003c/h2\u003e\n\u003cp\u003eIn addition to scalability and performance improvements,\nwe’ve also fixed \u003ca href=\"https://github.com/golang/go/milestone/282?closed=1\" rel=\"noreferrer\" target=\"_blank\"\u003enumerous\u003c/a\u003e\n\u003ca href=\"https://github.com/golang/go/milestone/318?closed=1\" rel=\"noreferrer\" target=\"_blank\"\u003ereported bugs\u003c/a\u003e and\nmany unreported ones that we discovered while improving test coverage during the transition.\u003c/p\u003e\n\u003cp\u003eTo install the latest gopls:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go install golang.org/x/tools/gopls@latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease try it out and fill out the \u003ca href=\"https://google.qualtrics.com/jfe/form/SV_4SnGxpcSKN33WZw?s=blog\" rel=\"noreferrer\" target=\"_blank\"\u003esurvey\u003c/a\u003e —\nand if you should encounter a bug,\n\u003ca href=\"/issue/new\"\u003ereport it\u003c/a\u003e and we will fix it.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-09-08T00:00:00Z",
  "Author": "Robert Findley and Alan Donovan"
}