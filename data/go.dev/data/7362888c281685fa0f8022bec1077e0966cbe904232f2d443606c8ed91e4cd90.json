{
  "Source": "go.dev",
  "Title": "Contributors Summit 2019",
  "Link": "https://go.dev/blog/contributors-summit-2019",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/contributors-summit-2019\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eContributors Summit 2019\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Carmen Andoh and contributors\u003cbr/\u003e\n      15 August 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eFor the third year in a row, the Go team and contributors convened\nthe day before GopherCon to discuss and plan for the future of the Go project.\nThe event included self-organizing into breakout groups,\na town-hall style discussion about the proposal process in the morning,\nand afternoon break-out roundtable discussions\nbased on topics our contributors chose.\nWe asked five contributors to write about their experience\nin various discussions at this year’s summit.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"contributors-summit-2019/group.jpg\" width=\"800\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003cem\u003e(Photo by Steve Francia.)\u003c/em\u003e\u003c/p\u003e\n\u003ch2 id=\"compiler-and-runtime-report-by-lynn-boger\"\u003eCompiler and Runtime (report by Lynn Boger)\u003c/h2\u003e\n\u003cp\u003eThe Go contributors summit was a great opportunity\nto meet and discuss topics and ideas with others who also contribute to Go.\u003c/p\u003e\n\u003cp\u003eThe day started out with a time to meet everyone in the room.\nThere was a good mix of the core Go team\nand others who actively contribute to Go.\nFrom there we decided what topics were of interest\nand how to split the big group into smaller groups.\nMy area of interest is the compiler, so I joined that group\nand stayed with them for most of the time.\u003c/p\u003e\n\u003cp\u003eAt our first meeting, a long list of topics were brought up\nand as a result the compiler group decided to keep meeting throughout the day.\nI had a few topics of interest that I shared and many that others suggested\nwere also of interest to me.\nNot all items on the list were discussed in detail;\nhere is my list of those topics which had the most interest and discussion,\nfollowed by some brief comments that were made on other topics.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBinary size\u003c/strong\u003e.\nThere was a concern expressed about binary size,\nespecially that it continues to grow with each release.\nSome possible reasons were identified such as increased inlining and other optimizations.\nMost likely there is a set of users who want small binaries,\nand another group who wants the best performance possible and maybe some don’t care.\nThis led to the topic of TinyGo, and it was noted that TinyGo was not a full implementation of Go\nand that it is important to keep TinyGo from diverging from Go and splitting the user base.\nMore investigation is required to understand the need among users and the exact reasons\ncontributing to the current size.\nIf there are opportunities to reduce the size without affecting performance,\nthose changes could be made, but if performance were affected\nsome users would prefer better performance.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eVector assembly\u003c/strong\u003e.\nHow to leverage vector assembly in Go was discussed for a while\nand has been a topic of interest in the past.\nI have split this into three separate possibilities, since they all relate to the use of vector instructions,\nbut the way they are used are different, starting with the topic of vector assembly.\nThis is another case of a compiler trade off.\u003c/p\u003e\n\u003cp\u003eFor most targets, there are critical functions in standard packages\nsuch as crypto, hash, math and others, where the use of assembly is necessary\nto get the best possible performance; however having large functions\nwritten in assembly makes them difficult to support and maintain\nand could require different implementations for each target platform.\nOne solution is to make use of macro assembly or other\nhigh-level generation techniques to make the vector assembly easier to read and understand.\u003c/p\u003e\n\u003cp\u003eAnother side to this question is whether the Go compiler can\ndirectly generate SIMD vector instructions when compiling a Go source file,\nby enhancing the Go compiler to transform code sequences to “simdize”\nthe code to make use of vector instructions.\nImplementing SIMD in the Go compiler would add complexity and compile time,\nand might not always result in code that performs better.\nThe way the code is transformed could in some cases depend\non the target platform so that would not be ideal.\u003c/p\u003e\n\u003cp\u003eAnother way to leverage vector instructions in Go is to provide a way\nto make it easier to make use of vector instructions from within the Go source code.\nTopics discussed were intrinsics, or implementations that exist in other compilers like Rust.\nIn gcc some platforms provide inline asm, and Go possibly could provide this capability,\nbut I know from experience that intermixing inline asm with Go code adds complexity\nto the compiler in terms of tracking register use and debugging.\nIt allows the user to do things the compiler might not expect or want,\nand it does add an extra level of complexity.\nIt could be inserted in places that are not ideal.\u003c/p\u003e\n\u003cp\u003eIn summary, it is important to provide a way to leverage\nthe available vector instructions, and make it easier and safer to write.\nWhere possible, functions use as much Go code as possible,\nand potentially find a way to use high level assembly.\nThere was some discussion of designing an experimental vector package\nto try and implement some of these ideas.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNew calling convention\u003c/strong\u003e.\nSeveral people were interested in the topic of the\n\u003ca href=\"/issue/18597\"\u003eABI changes to provide a register based calling convention\u003c/a\u003e.\nThe current status was reported with details.\nThere was discussion on what remained to be done before it could be used.\nThe ABI specification needs to be written first and it was not clear when that would be done.\nI know this will benefit some target platforms more than others\nand a register calling convention is used in most compilers for other platforms.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGeneral optimizations\u003c/strong\u003e.\nCertain optimizations that are more beneficial for some platforms other than x86 were discussed.\nIn particular, loop optimizations such as hoisting of invariants and strength reduction could be done\nand provide more benefit on some platforms.\nPotential solutions were discussed, and implementation would probably be\nup to the targets that find those improvements important.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eFeedback-directed optimizations\u003c/strong\u003e.\nThis was discussed and debated as a possible future enhancement.\nIn my experience, it is hard to find meaningful programs to use for\ncollecting performance data that can later be used to optimize code.\nIt increases compile time and takes a lot of space to save the data\nwhich might only be meaningful for a small set of programs.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePending submissions\u003c/strong\u003e.\nA few members in the group mentioned changes they had been working on\nand plan to submit soon, including improvements to makeslice, and a rewrite of rulegen.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompile time concerns\u003c/strong\u003e.\nCompile time was discussed briefly. It was noted that phase timing was added to the GOSSAFUNC output.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompiler contributor communication\u003c/strong\u003e.\nSomeone asked if there was a need for a Go compiler mailing list.\nIt was suggested that we use golang-dev for that purpose,\nadding compiler to the subject line to identify it.\nIf there is too much traffic on golang-dev, then a compiler-specific mailing list\ncan be considered at some later point in time.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCommunity\u003c/strong\u003e.\nI found the day very beneficial in terms of connecting with people\nwho have been active in the community and have similar areas of interest.\nI was able to meet many people who I’ve only known by the user name\nappearing in issues or mailing lists or CLs.\nI was able to discuss some topics and existing issues\nand get direct interactive feedback instead of waiting for online responses.\nI was encouraged to write issues on problems I have seen.\nThese connections happened not just during this day but while\nrunning into others throughout the conference,\nhaving been introduced on this first day, which led to many interesting discussions.\nHopefully these connections will lead to more effective communication\nand improved handling of issues and code changes in the future.\u003c/p\u003e\n\u003ch2 id=\"tools-report-by-paul-jolly\"\u003eTools (report by Paul Jolly)\u003c/h2\u003e\n\u003cp\u003eThe tools breakout session during the contributor summit took an extended form,\nwith two further sessions on the main conference days organized by the\n\u003ca href=\"/wiki/golang-tools\"\u003egolang-tools\u003c/a\u003e group.\nThis summary is broken down into two parts: the tools session at the contributor workshop,\nand a combined report from the golang-tools sessions on the main conference days.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eContributor summit\u003c/strong\u003e.\nThe tools session started with introductions from ~25 folks gathered,\nfollowed by a brainstorming of topics, including:\ngopls, ARM 32-bit, eval, signal, analysis, go/packages api, refactoring, pprof,\nmodule experience, mono repo analysis, go mobile, dependencies, editor integrations,\ncompiler opt decisions, debugging, visualization, documentation.\nA lot of people with lots of interest in lots of tools!\u003c/p\u003e\n\u003cp\u003eThe session focused on two areas (all that time allowed): gopls and visualizations.\n\u003ca href=\"/wiki/gopls\"\u003eGopls\u003c/a\u003e (pronounced: “go please”) is an implementation of the\n\u003ca href=\"https://langserver.org\" rel=\"noreferrer\" target=\"_blank\"\u003eLanguage Server Protocol (LSP)\u003c/a\u003e server for Go.\nRebecca Stambler, the gopls lead author, and the rest of the Go tools team were interested\nin hearing people’s experiences with gopls: stability, missing features, integrations in editors working, etc?\nThe general feeling was that gopls was in really good shape and working extremely well for the majority of use cases.\nIntegration test coverage needs to be improved, but this is a hard problem to get “right” across all editors.\nWe discussed a better means of users reporting gopls errors they encounter via their editor,\ntelemetry/diagnostics, gopls performance metrics, all subjects that got more detailed coverage\nin golang-tools sessions that followed on the main conference days (see below).\nA key area of discussion was how to extend gopls, e.g., in the form of\nadditional go/analysis vet-like checks, lint checks, refactoring, etc.\nCurrently there is no good solution, but it’s actively under investigation.\nConversation shifted to the very broad topic of visualizations, with a\ndemo-based introduction from Anthony Starks (who, incidentally, gave an excellent talk about\n\u003ca href=\"https://www.youtube.com/watch?v=NyDNJnioWhI\" rel=\"noreferrer\" target=\"_blank\"\u003eGo for information displays\u003c/a\u003e at GopherCon 2018).\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eConference days\u003c/strong\u003e.\nThe golang-tools sessions on the main conference days were a continuation of the\n\u003ca href=\"/wiki/golang-tools\"\u003emonthly calls\u003c/a\u003e that have been happening since the group’s inception at GopherCon 2018.\nFull notes are available for the\n\u003ca href=\"https://docs.google.com/document/d/1-RVyttQ0ncjCpR_sRwizf-Ubedkr0Emwmk2LhnsUOmE/edit\" rel=\"noreferrer\" target=\"_blank\"\u003eday 1\u003c/a\u003e and\n\u003ca href=\"https://docs.google.com/document/d/1ZI_WqpLCB8DO6teJ3aBuXTeYD2iZZZlkDptmcY6Ja60/edit#heading=h.x9lkytc2gxmg\" rel=\"noreferrer\" target=\"_blank\"\u003eday 2\u003c/a\u003e sessions.\nThese sessions were again well attended with 25-30 people at each session.\nThe Go tools team was there in strength (a good sign of the support being put behind this area), as was the Uber platform team.\nIn contrast to the contributor summit, the goal from these sessions was to come away with specific action items.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGopls\u003c/strong\u003e.\nGopls “readiness” was a major focus for both sessions.\nThis answer effectively boiled down to determining when it makes sense to tell\neditor integrators “we have a good first cut of gopls” and then compiling a\nlist of “blessed” editor integrations/plugins known to work with gopls.\nCentral to this “certification” of editor integrations/plugins is a well-defined process\nby which users can report problems they experience with gopls.\nPerformance and memory are not blockers for this initial “release”.\nThe conversation about how to extend gopls, started in the\ncontributor summit the day before, continued in earnest.\nDespite the many obvious benefits and attractions to extending gopls\n(custom go/analysis checks, linter support, refactoring, code generation…),\nthere isn’t a clear answer on how to implement this in a scalable way.\nThose gathered agreed that this should not be seen as a blocker for the\ninitial “release”, but should continue to be worked on.\nIn the spirit of gopls and editor integrations,\nHeschi Kreinick from the Go tools team brought up the topic of debugging support.\nDelve has become the de facto debugger for Go and is in good shape;\nnow the state of debugger-editor integration needs to be established,\nfollowing a process similar to that of gopls and the “blessed” integrations.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGo Discovery Site\u003c/strong\u003e.\nThe second golang-tools session started with an excellent introduction to\nthe Go Discovery Site by Julie Qiu from the Go tools team, along with a quick demo.\nJulie talked about the plans for the Discovery Site: open sourcing the project,\nwhat signals are used in search ranking, how \u003ca href=\"http://godoc.org/\" rel=\"noreferrer\" target=\"_blank\"\u003egodoc.org\u003c/a\u003e will ultimately be replaced,\nhow submodules should work, how users can discover new major versions.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBuild Tags\u003c/strong\u003e.\nConversation then moved to build tag support within gopls.\nThis is an area that clearly needs to be better understood\n(use cases are currently being gathered in \u003ca href=\"/issue/33389\"\u003eissue 33389\u003c/a\u003e).\nIn light of this conversation, the session wrapped up with\nAlexander Zolotov from the JetBrains GoLand team suggesting that the gopls and\nGoLand teams should share experience in this and more areas, given GoLand\nhas already gained lots of experience.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eJoin Us!\u003c/strong\u003e\nWe could easily have talked about tools-related topics for days!\nThe good news is that the golang-tools calls will continue for the foreseeable future.\nAnyone interested in Go tooling is very much encouraged to join: \u003ca href=\"/wiki/golang-tools\"\u003ethe wiki\u003c/a\u003e has more details.\u003c/p\u003e\n\u003ch2 id=\"enterprise-use-report-by-daniel-theophanes\"\u003eEnterprise Use (report by Daniel Theophanes)\u003c/h2\u003e\n\u003cp\u003eActively asking after the needs of less vocal developers will be the largest challenge,\nand greatest win, for the Go language. There is a large segment of programmers\nwho don’t actively participate in the Go community.\nSome are business associates, marketers, or quality assurance who also do development.\nSome will wear management hats and make hiring or technology decisions.\nOthers just do their job and return to their families.\nAnd lastly, many times these developers work in businesses with strict IP protection contracts.\nEven though most of these developers won’t end up directly participating in open source\nor the Go community proposals, their ability to use Go depends on both.\u003c/p\u003e\n\u003cp\u003eThe Go community and Go proposals need to understand the needs of these less vocal developers.\nGo proposals can have a large impact on what is adopted and used.\nFor instance, the vendor folder and later the Go modules proxy are incredibly important\nfor businesses that strictly control source code and\ntypically have fewer direct conversations with the Go community.\nHaving these mechanisms allow these organizations to use Go at all.\nIt follows that we must not only pay attention to current Go users,\nbut also to developers and organizations who have considered Go,\nbut have chosen against it.\nWe need to understand these reasons.\u003c/p\u003e\n\u003cp\u003eSimilarly, should the Go community pay attention to “enterprise”\nenvironments it would unlock many additional organizations who can utilize Go.\nBy ensuring active directory authentication works, users who would\nbe forced to use a different ecosystem can keep Go on the table.\nBy ensuring WSDL just works, a section of users can pick Go up as a tool.\nNo one suggested blindly making changes to appease non-Go users.\nBut rather we should be aware of untapped potential and unrecognized\nhindrances in the Go language and ecosystem.\u003c/p\u003e\n\u003cp\u003eWhile several different possibilities to actively solicit this information\nfrom the outside were discussed, this is a problem we fundamentally need your help.\nIf you are in an organization that doesn’t use Go even though it was considered,\nlet us know why Go wasn’t chosen.\nIf you are in an organization where Go is only used for a subsection of programming tasks,\nbut not others, why isn’t it used for more? Are there specific blockers to adoption?\u003c/p\u003e\n\u003ch2 id=\"education-report-by-andy-walker\"\u003eEducation (report by Andy Walker)\u003c/h2\u003e\n\u003cp\u003eOne of the roundtables I was involved in at the Contributors Summit\nthis year was on the topic of Go education,\nspecifically what kind of resources we make available\nto the new Go programmer, and how we can improve them.\nPresent were a number of very passionate organizers, engineers and educators,\neach of whom had a unique perspective on the subject,\neither through tools they’d designed,\ndocuments they’d written or workshops they’d given to developers of all stripes.\u003c/p\u003e\n\u003cp\u003eEarly on, talk turned to whether or not Go makes a good first programming language.\nI wasn’t sure, and advocated against it.\nGo isn’t a good first language, I argued, because it isn’t intended to be.\nAs Rob Pike \u003ca href=\"/talks/2012/splash.article\"\u003ewrote back in 2012\u003c/a\u003e,\n“the language was designed by and for people who write—and read and debug and maintain—large software systems”.\nTo me, this guiding ethos is clear: Go is a deliberate response to perceived flaws\nin the processes used by experienced engineers, not an attempt to create an ideal\nprogramming language, and as such a certain basic familiarity with programming concepts is assumed.\u003c/p\u003e\n\u003cp\u003eThis is evident in the official documentation at \u003ca href=\"/doc/\"\u003egolang.org/doc\u003c/a\u003e.\nIt jumps right into how to install the language before passing the user on to the\n\u003ca href=\"/tour/\"\u003etour\u003c/a\u003e, which is geared towards programmers\nwho are already familiar with a C-like language.\nFrom there, they are taken to \u003ca href=\"/doc/code.html\"\u003eHow to Write Go Code\u003c/a\u003e,\nwhich provides a very basic introduction to the classic non-module Go workspace,\nbefore moving immediately on to writing libraries and testing.\nFinally, we have \u003ca href=\"/doc/effective_go.html\"\u003eEffective Go\u003c/a\u003e,\nand a series of references including the \u003ca href=\"/ref/spec\"\u003espec\u003c/a\u003e,\nrounded out by some examples.\nThese are all decent resources if you’re already familiar with a C-like language,\nbut they still leave a lot to be desired, and there’s nothing to be found\nfor the raw beginner or even someone coming directly from a language like Python.\u003c/p\u003e\n\u003cp\u003eAs an accessible, interactive starting point, the tour is a natural first target\ntowards making the language more beginner friendly,\nand I think a lot of headway can be made targeting that alone.\nFirst, it should be the first link in the documentation,\nif not the first link in the bar at the top of golang.org, front and center.\nWe should encourage the curious user to jump right in and start playing with the language.\nWe should also consider including optional introductory sections on coming\nfrom other common languages, and the differences they are\nlikely to encounter in Go, with interactive exercises.\nThis would go a long way to helping new Go programmers in mapping\nthe concepts they are already familiar with onto Go.\u003c/p\u003e\n\u003cp\u003eFor experienced programmers, an optional, deeper treatment should be given\nto most sections in the tour, allowing them to drill down into more\ndetailed documentation or interactive exercises enumerating the\ndesign decisions principles of good architecture in Go.\nThey should find answers to questions like:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhy are there so many integer types when I am encouraged to use \u003ccode\u003eint\u003c/code\u003e most of the time?\u003c/li\u003e\n\u003cli\u003eIs there ever a good reason to pick a value receiver?\u003c/li\u003e\n\u003cli\u003eWhy is there a plain \u003ccode\u003eint\u003c/code\u003e, but no plain \u003ccode\u003efloat\u003c/code\u003e?\u003c/li\u003e\n\u003cli\u003eWhat are send- and receive-only channels, and when would I use them?\u003c/li\u003e\n\u003cli\u003eHow do I effectively compose concurrency primitives, and when would I \u003cem\u003enot\u003c/em\u003e want to use channels?\u003c/li\u003e\n\u003cli\u003eWhat is \u003ccode\u003euint\u003c/code\u003e good for? Should I use it to restrict my user to positive values? Why not?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe tour should be someplace they can revisit upon finishing the first run-through\nto dive more deeply into some of the more interesting choices in language design.\u003c/p\u003e\n\u003cp\u003eBut we can do more. Many people seek out programming as a way to design\napplications or scratch a particular itch, and they are most likely to want\nto target the interface they are most familiar with: the browser.\nGo does not have a good front-end story yet.\nJavascript is still the only language that really provides\nboth a frontend and a backend environment,\nbut WASM is fast becoming a first-order platform,\nand there are so many places we could go with that.\nWe could provide something like \u003ca href=\"https://github.com/gopherjs/vecty\" rel=\"noreferrer\" target=\"_blank\"\u003evecty\u003c/a\u003e\nin \u003ca href=\"https://goplay.space/\" rel=\"noreferrer\" target=\"_blank\"\u003eThe Go Play Space\u003c/a\u003e,\nor perhaps \u003ca href=\"https://gioui.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eGio\u003c/a\u003e, targeting WASM, for people to get\nstarted programming in the browser right away, inspiring their imagination,\nand provide them a migration path out of our playground into\na terminal and onto GitHub.\u003c/p\u003e\n\u003cp\u003eSo, is Go a good first language?\nI honestly don’t know, but it’s certainly true there are a significant\nnumber of people entering the programming profession\nwith Go as their starting point, and I am very interested in talking to them,\nlearning about their journey and their process,\nand shaping the future of Go education with their input.\u003c/p\u003e\n\u003ch2 id=\"learning-platforms-report-by-ronna-steinberg\"\u003eLearning Platforms (report by Ronna Steinberg)\u003c/h2\u003e\n\u003cp\u003eWe discussed what a learning platform for Go should look like\nand how we can combine global resources to effectively teach the language.\nWe generally agreed that teaching and learning is easier with visualization\nand that a REPL is very gratifying.\nWe also overviewed some existing solutions for visualization with Go:\ntemplates, Go WASM, GopherJS as well as SVG and GIFs generation.\u003c/p\u003e\n\u003cp\u003eCompiler errors not making sense to the new developer was also brought up\nand we considered ideas of how to handle it, perhaps a bank of errors and how they would be useful.\nOne idea was a wrapper for the compiler that explains your errors to you, with examples and solutions.\u003c/p\u003e\n\u003cp\u003eA new group convened for a second round later and we focused more on\nwhat UX should the Go learning platform have,\nand if and how we can take existing materials (talks, blog posts, podcasts, etc)\nfrom the community and organize them into a program people can learn from.\nShould such a platform link to those external resources?\nEmbed them?\nCite them?\nWe agreed that a portal-like-solution (of external links to resources)\nmakes navigation difficult and takes away from the learning experience,\nwhich led us to the conclusion that such contribution cannot be passive,\nand contributors will likely have to opt in to have their material on the platform.\nThere was then much excitement around the idea of adding a voting mechanism to the platform,\neffectively turning the learners into contributors, too,\nand incentivizing the contributors to put their materials on the platform.\u003c/p\u003e\n\u003cp\u003e(If you are interested in helping in educational efforts for Go,\nplease email Carmen Andoh candoh@google.com.)\u003c/p\u003e\n\u003ch2 id=\"thank-you\"\u003eThank You!\u003c/h2\u003e\n\u003cp\u003eThanks to all the attendees for the excellent discussions on contributor day,\nand thanks especially to Lynn, Paul, Daniel, Andy, and Ronna\nfor taking the time to write these reports.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-08-15T00:00:00Z",
  "Author": "Carmen Andoh and contributors"
}