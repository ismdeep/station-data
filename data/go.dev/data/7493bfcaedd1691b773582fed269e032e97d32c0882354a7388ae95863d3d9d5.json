{
  "Source": "go.dev",
  "Title": "Strings, bytes, runes and characters in Go",
  "Link": "https://go.dev/blog/strings",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/strings\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eStrings, bytes, runes and characters in Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      23 October 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"/blog/slices\"\u003eprevious blog post\u003c/a\u003e explained how slices\nwork in Go, using a number of examples to illustrate the mechanism behind\ntheir implementation.\nBuilding on that background, this post discusses strings in Go.\nAt first, strings might seem too simple a topic for a blog post, but to use\nthem well requires understanding not only how they work,\nbut also the difference between a byte, a character, and a rune,\nthe difference between Unicode and UTF-8,\nthe difference between a string and a string literal,\nand other even more subtle distinctions.\u003c/p\u003e\n\u003cp\u003eOne way to approach this topic is to think of it as an answer to the frequently\nasked question, “When I index a Go string at position \u003cem\u003en\u003c/em\u003e, why don’t I get the\n\u003cem\u003enth\u003c/em\u003e character?”\nAs you’ll see, this question leads us to many details about how text works\nin the modern world.\u003c/p\u003e\n\u003cp\u003eAn excellent introduction to some of these issues, independent of Go,\nis Joel Spolsky’s famous blog post,\n\u003ca href=\"http://www.joelonsoftware.com/articles/Unicode.html\" rel=\"noreferrer\" target=\"_blank\"\u003eThe Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!)\u003c/a\u003e.\nMany of the points he raises will be echoed here.\u003c/p\u003e\n\u003ch2 id=\"what-is-a-string\"\u003eWhat is a string?\u003c/h2\u003e\n\u003cp\u003eLet’s start with some basics.\u003c/p\u003e\n\u003cp\u003eIn Go, a string is in effect a read-only slice of bytes.\nIf you’re at all uncertain about what a slice of bytes is or how it works,\nplease read the \u003ca href=\"/blog/slices\"\u003eprevious blog post\u003c/a\u003e;\nwe’ll assume here that you have.\u003c/p\u003e\n\u003cp\u003eIt’s important to state right up front that a string holds \u003cem\u003earbitrary\u003c/em\u003e bytes.\nIt is not required to hold Unicode text, UTF-8 text, or any other predefined format.\nAs far as the content of a string is concerned, it is exactly equivalent to a\nslice of bytes.\u003c/p\u003e\n\u003cp\u003eHere is a string literal (more about those soon) that uses the\n\u003ccode\u003e\\xNN\u003c/code\u003e notation to define a string constant holding some peculiar byte values.\n(Of course, bytes range from hexadecimal values 00 through FF, inclusive.)\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    const sample = \u0026#34;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026#34;\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"printing-strings\"\u003ePrinting strings\u003c/h2\u003e\n\u003cp\u003eBecause some of the bytes in our sample string are not valid ASCII, not even\nvalid UTF-8, printing the string directly will produce ugly output.\nThe simple print statement\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Println(sample)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eproduces this mess (whose exact appearance varies with the environment):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e��=� ⌘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo find out what that string really holds, we need to take it apart and examine the pieces.\nThere are several ways to do this.\nThe most obvious is to loop over its contents and pull out the bytes\nindividually, as in this \u003ccode\u003efor\u003c/code\u003e loop:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    for i := 0; i \u0026lt; len(sample); i++ {\n        fmt.Printf(\u0026#34;%x \u0026#34;, sample[i])\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eAs implied up front, indexing a string accesses individual bytes, not\ncharacters. We’ll return to that topic in detail below. For now, let’s\nstick with just the bytes.\nThis is the output from the byte-by-byte loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebd b2 3d bc 20 e2 8c 98\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice how the individual bytes match the\nhexadecimal escapes that defined the string.\u003c/p\u003e\n\u003cp\u003eA shorter way to generate presentable output for a messy string\nis to use the \u003ccode\u003e%x\u003c/code\u003e (hexadecimal) format verb of \u003ccode\u003efmt.Printf\u003c/code\u003e.\nIt just dumps out the sequential bytes of the string as hexadecimal\ndigits, two per byte.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Printf(\u0026#34;%x\\n\u0026#34;, sample)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eCompare its output to that above:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebdb23dbc20e28c98\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA nice trick is to use the “space” flag in that format, putting a\nspace between the \u003ccode\u003e%\u003c/code\u003e and the \u003ccode\u003ex\u003c/code\u003e. Compare the format string\nused here to the one above,\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Printf(\u0026#34;% x\\n\u0026#34;, sample)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eand notice how the bytes come\nout with spaces between, making the result a little less imposing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebd b2 3d bc 20 e2 8c 98\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere’s more. The \u003ccode\u003e%q\u003c/code\u003e (quoted) verb will escape any non-printable\nbyte sequences in a string so the output is unambiguous.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Printf(\u0026#34;%q\\n\u0026#34;, sample)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThis technique is handy when much of the string is\nintelligible as text but there are peculiarities to root out; it produces:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#34;\\xbd\\xb2=\\xbc ⌘\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we squint at that, we can see that buried in the noise is one ASCII equals sign,\nalong with a regular space, and at the end appears the well-known Swedish “Place of Interest”\nsymbol.\nThat symbol has Unicode value U+2318, encoded as UTF-8 by the bytes\nafter the space (hex value \u003ccode\u003e20\u003c/code\u003e): \u003ccode\u003ee2\u003c/code\u003e \u003ccode\u003e8c\u003c/code\u003e \u003ccode\u003e98\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf we are unfamiliar or confused by strange values in the string,\nwe can use the “plus” flag to the \u003ccode\u003e%q\u003c/code\u003e verb. This flag causes the output to escape\nnot only non-printable sequences, but also any non-ASCII bytes, all\nwhile interpreting UTF-8.\nThe result is that it exposes the Unicode values of properly formatted UTF-8\nthat represents non-ASCII data in the string:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Printf(\u0026#34;%+q\\n\u0026#34;, sample)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eWith that format, the Unicode value of the Swedish symbol shows up as a\n\u003ccode\u003e\\u\u003c/code\u003e escape:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#34;\\xbd\\xb2=\\xbc \\u2318\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese printing techniques are good to know when debugging\nthe contents of strings, and will be handy in the discussion that follows.\nIt’s worth pointing out as well that all these methods behave exactly the\nsame for byte slices as they do for strings.\u003c/p\u003e\n\u003cp\u003eHere’s the full set of printing options we’ve listed, presented as\na complete program you can run (and edit) right in the browser:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const sample = \u0026#34;\\xbd\\xb2\\x3d\\xbc\\x20\\xe2\\x8c\\x98\u0026#34;\n\n    fmt.Println(\u0026#34;Println:\u0026#34;)\n    fmt.Println(sample)\n\n    fmt.Println(\u0026#34;Byte loop:\u0026#34;)\n    for i := 0; i \u0026lt; len(sample); i++ {\n        fmt.Printf(\u0026#34;%x \u0026#34;, sample[i])\n    }\n    fmt.Printf(\u0026#34;\\n\u0026#34;)\n\n    fmt.Println(\u0026#34;Printf with %x:\u0026#34;)\n    fmt.Printf(\u0026#34;%x\\n\u0026#34;, sample)\n\n    fmt.Println(\u0026#34;Printf with % x:\u0026#34;)\n    fmt.Printf(\u0026#34;% x\\n\u0026#34;, sample)\n\n    fmt.Println(\u0026#34;Printf with %q:\u0026#34;)\n    fmt.Printf(\u0026#34;%q\\n\u0026#34;, sample)\n\n    fmt.Println(\u0026#34;Printf with %+q:\u0026#34;)\n    fmt.Printf(\u0026#34;%+q\\n\u0026#34;, sample)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e[Exercise: Modify the examples above to use a slice of bytes\ninstead of a string. Hint: Use a conversion to create the slice.]\u003c/p\u003e\n\u003cp\u003e[Exercise: Loop over the string using the \u003ccode\u003e%q\u003c/code\u003e format on each byte.\nWhat does the output tell you?]\u003c/p\u003e\n\u003ch2 id=\"utf-8-and-string-literals\"\u003eUTF-8 and string literals\u003c/h2\u003e\n\u003cp\u003eAs we saw, indexing a string yields its bytes, not its characters: a string is just a\nbunch of bytes.\nThat means that when we store a character value in a string,\nwe store its byte-at-a-time representation.\nLet’s look at a more controlled example to see how that happens.\u003c/p\u003e\n\u003cp\u003eHere’s a simple program that prints a string constant with a single character\nthree different ways, once as a plain string, once as an ASCII-only quoted\nstring, and once as individual bytes in hexadecimal.\nTo avoid any confusion, we create a “raw string”, enclosed by back quotes,\nso it can contain only literal text. (Regular strings, enclosed by double\nquotes, can contain escape sequences as we showed above.)\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    const placeOfInterest = `⌘`\n\n    fmt.Printf(\u0026#34;plain string: \u0026#34;)\n    fmt.Printf(\u0026#34;%s\u0026#34;, placeOfInterest)\n    fmt.Printf(\u0026#34;\\n\u0026#34;)\n\n    fmt.Printf(\u0026#34;quoted string: \u0026#34;)\n    fmt.Printf(\u0026#34;%+q\u0026#34;, placeOfInterest)\n    fmt.Printf(\u0026#34;\\n\u0026#34;)\n\n    fmt.Printf(\u0026#34;hex bytes: \u0026#34;)\n    for i := 0; i \u0026lt; len(placeOfInterest); i++ {\n        fmt.Printf(\u0026#34;%x \u0026#34;, placeOfInterest[i])\n    }\n    fmt.Printf(\u0026#34;\\n\u0026#34;)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe output is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eplain string: ⌘\nquoted string: \u0026#34;\\u2318\u0026#34;\nhex bytes: e2 8c 98\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich reminds us that the Unicode character value U+2318, the “Place\nof Interest” symbol ⌘, is represented by the bytes \u003ccode\u003ee2\u003c/code\u003e \u003ccode\u003e8c\u003c/code\u003e \u003ccode\u003e98\u003c/code\u003e, and\nthat those bytes are the UTF-8 encoding of the hexadecimal\nvalue 2318.\u003c/p\u003e\n\u003cp\u003eIt may be obvious or it may be subtle, depending on your familiarity with\nUTF-8, but it’s worth taking a moment to explain how the UTF-8 representation\nof the string was created.\nThe simple fact is: it was created when the source code was written.\u003c/p\u003e\n\u003cp\u003eSource code in Go is \u003cem\u003edefined\u003c/em\u003e to be UTF-8 text; no other representation is\nallowed. That implies that when, in the source code, we write the text\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e`⌘`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe text editor used to create the program places the UTF-8 encoding\nof the symbol ⌘ into the source text.\nWhen we print out the hexadecimal bytes, we’re just dumping the\ndata the editor placed in the file.\u003c/p\u003e\n\u003cp\u003eIn short, Go source code is UTF-8, so\n\u003cem\u003ethe source code for the string literal is UTF-8 text\u003c/em\u003e.\nIf that string literal contains no escape sequences, which a raw\nstring cannot, the constructed string will hold exactly the\nsource text  between the quotes.\nThus by definition and\nby construction the raw string will always contain a valid UTF-8\nrepresentation of its contents.\nSimilarly, unless it contains UTF-8-breaking escapes like those\nfrom the previous section, a regular string literal will also always\ncontain valid UTF-8.\u003c/p\u003e\n\u003cp\u003eSome people think Go strings are always UTF-8, but they\nare not: only string literals are UTF-8.\nAs we showed in the previous section, string \u003cem\u003evalues\u003c/em\u003e can contain arbitrary\nbytes;\nas we showed in this one, string \u003cem\u003eliterals\u003c/em\u003e always contain UTF-8 text\nas long as they have no byte-level escapes.\u003c/p\u003e\n\u003cp\u003eTo summarize, strings can contain arbitrary bytes, but when constructed\nfrom string literals, those bytes are (almost always) UTF-8.\u003c/p\u003e\n\u003ch2 id=\"code-points-characters-and-runes\"\u003eCode points, characters, and runes\u003c/h2\u003e\n\u003cp\u003eWe’ve been very careful so far in how we use the words “byte” and “character”.\nThat’s partly because strings hold bytes, and partly because the idea of “character”\nis a little hard to define.\nThe Unicode standard uses the term “code point” to refer to the item represented\nby a single value.\nThe code point U+2318, with hexadecimal value 2318, represents the symbol ⌘.\n(For lots more information about that code point, see\n\u003ca href=\"http://unicode.org/cldr/utility/character.jsp?a=2318\" rel=\"noreferrer\" target=\"_blank\"\u003eits Unicode page\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eTo pick a more prosaic example, the Unicode code point U+0061 is the lower\ncase Latin letter ‘A’: a.\u003c/p\u003e\n\u003cp\u003eBut what about the lower case grave-accented letter ‘A’, à?\nThat’s a character, and it’s also a code point (U+00E0), but it has other\nrepresentations.\nFor example we can use the “combining” grave accent code point, U+0300,\nand attach it to the lower case letter a, U+0061, to create the same character à.\nIn general, a character may be represented by a number of different\nsequences of code points, and therefore different sequences of UTF-8 bytes.\u003c/p\u003e\n\u003cp\u003eThe concept of character in computing is therefore ambiguous, or at least\nconfusing, so we use it with care.\nTo make things dependable, there are \u003cem\u003enormalization\u003c/em\u003e techniques that guarantee that\na given character is always represented by the same code points, but that\nsubject takes us too far off the topic for now.\nA later blog post will explain how the Go libraries address normalization.\u003c/p\u003e\n\u003cp\u003e“Code point” is a bit of a mouthful, so Go introduces a shorter term for the\nconcept: \u003cem\u003erune\u003c/em\u003e.\nThe term appears in the libraries and source code, and means exactly\nthe same as “code point”, with one interesting addition.\u003c/p\u003e\n\u003cp\u003eThe Go language defines the word \u003ccode\u003erune\u003c/code\u003e as an alias for the type \u003ccode\u003eint32\u003c/code\u003e, so\nprograms can be clear when an integer value represents a code point.\nMoreover, what you might think of as a character constant is called a\n\u003cem\u003erune constant\u003c/em\u003e in Go.\nThe type and value of the expression\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#39;⌘\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eis \u003ccode\u003erune\u003c/code\u003e with integer value \u003ccode\u003e0x2318\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTo summarize, here are the salient points:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGo source code is always UTF-8.\u003c/li\u003e\n\u003cli\u003eA string holds arbitrary bytes.\u003c/li\u003e\n\u003cli\u003eA string literal, absent byte-level escapes, always holds valid UTF-8 sequences.\u003c/li\u003e\n\u003cli\u003eThose sequences represent Unicode code points, called runes.\u003c/li\u003e\n\u003cli\u003eNo guarantee is made in Go that characters in strings are normalized.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"range-loops\"\u003eRange loops\u003c/h2\u003e\n\u003cp\u003eBesides the axiomatic detail that Go source code is UTF-8,\nthere’s really only one way that Go treats UTF-8 specially, and that is when using\na \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop on a string.\u003c/p\u003e\n\u003cp\u003eWe’ve seen what happens with a regular \u003ccode\u003efor\u003c/code\u003e loop.\nA \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop, by contrast, decodes one UTF-8-encoded rune on each\niteration.\nEach time around the loop, the index of the loop is the starting position of the\ncurrent rune, measured in bytes, and the code point is its value.\nHere’s an example using yet another handy \u003ccode\u003ePrintf\u003c/code\u003e format, \u003ccode\u003e%#U\u003c/code\u003e, which shows\nthe code point’s Unicode value and its printed representation:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const nihongo = \u0026#34;日本語\u0026#34;\n    for index, runeValue := range nihongo {\n        fmt.Printf(\u0026#34;%#U starts at byte position %d\\n\u0026#34;, runeValue, index)\n    }\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe output shows how each code point occupies multiple bytes:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eU+65E5 \u0026#39;日\u0026#39; starts at byte position 0\nU+672C \u0026#39;本\u0026#39; starts at byte position 3\nU+8A9E \u0026#39;語\u0026#39; starts at byte position 6\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e[Exercise: Put an invalid UTF-8 byte sequence into the string. (How?)\nWhat happens to the iterations of the loop?]\u003c/p\u003e\n\u003ch2 id=\"libraries\"\u003eLibraries\u003c/h2\u003e\n\u003cp\u003eGo’s standard library provides strong support for interpreting UTF-8 text.\nIf a \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop isn’t sufficient for your purposes,\nchances are the facility you need is provided by a package in the library.\u003c/p\u003e\n\u003cp\u003eThe most important such package is\n\u003ca href=\"/pkg/unicode/utf8/\"\u003e\u003ccode\u003eunicode/utf8\u003c/code\u003e\u003c/a\u003e,\nwhich contains\nhelper routines to validate, disassemble, and reassemble UTF-8 strings.\nHere is a program equivalent to the \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e example above,\nbut using the \u003ccode\u003eDecodeRuneInString\u003c/code\u003e function from that package to\ndo the work.\nThe return values from the function are the rune and its width in\nUTF-8-encoded bytes.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\n// Copyright 2013 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;unicode/utf8\u0026#34;\n)\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const nihongo = \u0026#34;日本語\u0026#34;\n    for i, w := 0, 0; i \u0026lt; len(nihongo); i += w {\n        runeValue, width := utf8.DecodeRuneInString(nihongo[i:])\n        fmt.Printf(\u0026#34;%#U starts at byte position %d\\n\u0026#34;, runeValue, i)\n        w = width\n    }\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eRun it to see that it performs the same.\nThe \u003ccode\u003efor\u003c/code\u003e \u003ccode\u003erange\u003c/code\u003e loop and \u003ccode\u003eDecodeRuneInString\u003c/code\u003e are defined to produce\nexactly the same iteration sequence.\u003c/p\u003e\n\u003cp\u003eLook at the\n\u003ca href=\"/pkg/unicode/utf8/\"\u003edocumentation\u003c/a\u003e\nfor the \u003ccode\u003eunicode/utf8\u003c/code\u003e package to see what\nother facilities it provides.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eTo answer the question posed at the beginning: Strings are built from bytes\nso indexing them yields bytes, not characters.\nA string might not even hold characters.\nIn fact, the definition of “character” is ambiguous and it would\nbe a mistake to try to resolve the ambiguity by defining that strings are made\nof characters.\u003c/p\u003e\n\u003cp\u003eThere’s much more to say about Unicode, UTF-8, and the world of multilingual\ntext processing, but it can wait for another post.\nFor now, we hope you have a better understanding of how Go strings behave\nand that, although they may contain arbitrary bytes, UTF-8 is a central part\nof their design.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-10-23T00:00:00Z",
  "Author": "Rob Pike"
}