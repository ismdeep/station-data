{
  "Source": "go.dev",
  "Title": "Constants",
  "Link": "https://go.dev/blog/constants",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/constants\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eConstants\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      25 August 2014\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo is a statically typed language that does not permit operations that mix numeric types.\nYou can’t add a \u003ccode\u003efloat64\u003c/code\u003e to an \u003ccode\u003eint\u003c/code\u003e, or even an \u003ccode\u003eint32\u003c/code\u003e to an \u003ccode\u003eint\u003c/code\u003e.\nYet it is legal to write \u003ccode\u003e1e6*time.Second\u003c/code\u003e or \u003ccode\u003emath.Exp(1)\u003c/code\u003e or even \u003ccode\u003e1\u0026lt;\u0026lt;(\u0026#39;  \u0026#39;+2.0)\u003c/code\u003e.\nIn Go, constants, unlike variables, behave pretty much like regular numbers.\nThis post explains why that is and what it means.\u003c/p\u003e\n\u003ch2 id=\"background-c\"\u003eBackground: C\u003c/h2\u003e\n\u003cp\u003eIn the early days of thinking about Go, we talked about a number of problems\ncaused by the way C and its descendants let you mix and match numeric types.\nMany mysterious bugs, crashes, and portability problems are caused by expressions\nthat combine integers of different sizes and “signedness”.\nAlthough to a seasoned C programmer the result of a calculation like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eunsigned int u = 1e9;\nlong signed int i = -1;\n... i + u ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emay be familiar, it isn’t \u003cem\u003ea priori\u003c/em\u003e obvious.\nHow big is the result?\nWhat is its value?\nIs it signed or unsigned?\u003c/p\u003e\n\u003cp\u003eNasty bugs lurk here.\u003c/p\u003e\n\u003cp\u003eC has a set of rules called “the usual arithmetic conversions” and it is\nan indicator of their subtlety that they have changed over the years (introducing\nyet more bugs, retroactively).\u003c/p\u003e\n\u003cp\u003eWhen designing Go, we decided to avoid this minefield by mandating that there is \u003cem\u003eno\u003c/em\u003e mixing of numeric types.\nIf you want to add \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003eu\u003c/code\u003e, you must be explicit about what you want the result to be.\nGiven\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar u uint\nvar i int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eyou can write either \u003ccode\u003euint(i)+u\u003c/code\u003e or \u003ccode\u003ei+int(u)\u003c/code\u003e,\nwith both the meaning and type of the addition clearly expressed,\nbut unlike in C you cannot write \u003ccode\u003ei+u\u003c/code\u003e.\nYou can’t even mix \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003eint32\u003c/code\u003e, even when \u003ccode\u003eint\u003c/code\u003e is a 32-bit type.\u003c/p\u003e\n\u003cp\u003eThis strictness eliminates a common cause of bugs and other failures.\nIt is a vital property of Go.\nBut it has a cost: it sometimes requires programmers to decorate their code\nwith clumsy numeric conversions to express their meaning clearly.\u003c/p\u003e\n\u003cp\u003eAnd what about constants?\nGiven the declarations above, what would make it legal to write \u003ccode\u003ei\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e or \u003ccode\u003eu\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e \u003ccode\u003e0\u003c/code\u003e?\nWhat is the \u003cem\u003etype\u003c/em\u003e of \u003ccode\u003e0\u003c/code\u003e?\nIt would be unreasonable to require constants to have type conversions in simple contexts such as \u003ccode\u003ei\u003c/code\u003e \u003ccode\u003e=\u003c/code\u003e \u003ccode\u003eint(0)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe soon realized the answer lay in making numeric constants work differently\nfrom how they behave in other C-like languages.\nAfter much thinking and experimentation, we came up with a design that we\nbelieve feels right almost always,\nfreeing the programmer from converting constants all the time yet being\nable to write things like \u003ccode\u003emath.Sqrt(2)\u003c/code\u003e without being chided by the compiler.\u003c/p\u003e\n\u003cp\u003eIn short, constants in Go just work, most of the time anyway.\nLet’s see how that happens.\u003c/p\u003e\n\u003ch2 id=\"terminology\"\u003eTerminology\u003c/h2\u003e\n\u003cp\u003eFirst, a quick definition.\nIn Go, \u003ccode\u003econst\u003c/code\u003e is a keyword introducing a name for a scalar value such as \u003ccode\u003e2\u003c/code\u003e or \u003ccode\u003e3.14159\u003c/code\u003e or \u003ccode\u003e\u0026#34;scrumptious\u0026#34;\u003c/code\u003e.\nSuch values, named or otherwise, are called \u003cem\u003econstants\u003c/em\u003e in Go.\nConstants can also be created by expressions built from constants,\nsuch as \u003ccode\u003e2+3\u003c/code\u003e or \u003ccode\u003e2+3i\u003c/code\u003e or \u003ccode\u003emath.Pi/2\u003c/code\u003e or \u003ccode\u003e(\u0026#34;go\u0026#34;+\u0026#34;pher\u0026#34;)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSome languages don’t have constants, and others have a more general definition\nof constant or application of the word \u003ccode\u003econst\u003c/code\u003e.\nIn C and C++, for instance, \u003ccode\u003econst\u003c/code\u003e is a type qualifier that can codify\nmore intricate properties of more intricate values.\u003c/p\u003e\n\u003cp\u003eBut in Go, a constant is just a simple, unchanging value, and from here on we’re talking only about Go.\u003c/p\u003e\n\u003ch2 id=\"string-constants\"\u003eString constants\u003c/h2\u003e\n\u003cp\u003eThere are many kinds of numeric constants—integers,\nfloats, runes, signed, unsigned, imaginary,\ncomplex—so let’s start with a simpler form of constant: strings.\nString constants are easy to understand and provide a smaller space in which\nto explore the type issues of constants in Go.\u003c/p\u003e\n\u003cp\u003eA string constant encloses some text between double quotes.\n(Go also has raw string literals, enclosed by backquotes \u003ccode\u003e``\u003c/code\u003e,\nbut for the purpose of this discussion they have all the same properties.)\nHere is a string constant:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(For much more detail about the representation and interpretation of strings,\nsee \u003ca href=\"/blog/strings\"\u003ethis blog post\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eWhat type does this string constant have?\nThe obvious answer is \u003ccode\u003estring\u003c/code\u003e, but that is \u003cem\u003ewrong\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eThis is an \u003cem\u003euntyped string constant\u003c/em\u003e, which is to say it is a constant textual\nvalue that does not yet have a fixed type.\nYes, it’s a string, but it’s not a Go value of type \u003ccode\u003estring\u003c/code\u003e.\nIt remains an untyped string constant even when given a name:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst hello = \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter this declaration, \u003ccode\u003ehello\u003c/code\u003e is also an untyped string constant.\nAn untyped constant is just a value, one not yet given a defined type that\nwould force it to obey the strict rules that prevent combining differently typed values.\u003c/p\u003e\n\u003cp\u003eIt is this notion of an \u003cem\u003euntyped\u003c/em\u003e constant that makes it possible for us to use constants in Go with great freedom.\u003c/p\u003e\n\u003cp\u003eSo what, then, is a \u003cem\u003etyped\u003c/em\u003e string constant?\nIt’s one that’s been given a type, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst typedHello string = \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNotice that the declaration of \u003ccode\u003etypedHello\u003c/code\u003e has an explicit \u003ccode\u003estring\u003c/code\u003e type before the equals sign.\nThis means that \u003ccode\u003etypedHello\u003c/code\u003e has Go type \u003ccode\u003estring\u003c/code\u003e, and cannot be assigned to a Go variable of a different type.\nThat is to say, this code works:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nconst typedHello string = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var s string\n    s = typedHello\n    fmt.Println(s)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003ebut this does not:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nconst typedHello string = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type MyString string\n    var m MyString\n    m = typedHello // Type error\n    fmt.Println(m)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe variable \u003ccode\u003em\u003c/code\u003e has type \u003ccode\u003eMyString\u003c/code\u003e and cannot be assigned a value of a different type.\nIt can only be assigned values of type \u003ccode\u003eMyString\u003c/code\u003e, like this:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nconst typedHello string = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n    type MyString string\n    var m MyString\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const myStringHello MyString = \u0026#34;Hello, 世界\u0026#34;\n    m = myStringHello // OK\n    fmt.Println(m)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eor by forcing the issue with a conversion, like this:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nconst typedHello string = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n    type MyString string\n    var m MyString\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    m = MyString(typedHello)\n    fmt.Println(m)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eReturning to our \u003cem\u003euntyped\u003c/em\u003e string constant,\nit has the helpful property that, since it has no type,\nassigning it to a typed variable does not cause a type error.\nThat is, we can write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em = \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em = hello\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebecause, unlike the typed constants \u003ccode\u003etypedHello\u003c/code\u003e and \u003ccode\u003emyStringHello\u003c/code\u003e,\nthe untyped constants \u003ccode\u003e\u0026#34;Hello, 世界\u0026#34;\u003c/code\u003e and \u003ccode\u003ehello\u003c/code\u003e \u003cem\u003ehave no type\u003c/em\u003e.\nAssigning them to a variable of any type compatible with strings works without error.\u003c/p\u003e\n\u003cp\u003eThese untyped string constants are strings,\nof course, so they can only be used where a string is allowed,\nbut they do not have \u003cem\u003etype\u003c/em\u003e \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"default-type\"\u003eDefault type\u003c/h2\u003e\n\u003cp\u003eAs a Go programmer, you have certainly seen many declarations like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estr := \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand by now you might be asking, “if the constant is untyped, how does \u003ccode\u003estr\u003c/code\u003e get a type in this variable declaration?”\nThe answer is that an untyped constant has a default type,\nan implicit type that it transfers to a value if a type is needed where none is provided.\nFor untyped string constants, that default type is obviously \u003ccode\u003estring\u003c/code\u003e, so\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estr := \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar str = \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emeans exactly the same as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar str string = \u0026#34;Hello, 世界\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne way to think about untyped constants is that they live in a kind of\nideal space of values,\na space less restrictive than Go’s full type system.\nBut to do anything with them, we need to assign them to variables,\nand when that happens the \u003cem\u003evariable\u003c/em\u003e (not the constant itself) needs a type,\nand the constant can tell the variable what type it should have.\nIn this example, \u003ccode\u003estr\u003c/code\u003e becomes a value of type \u003ccode\u003estring\u003c/code\u003e because the untyped\nstring constant gives the declaration its default type, \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn such a declaration, a variable is declared with a type and initial value.\nSometimes when we use a constant, however, the destination of the value is not so clear.\nFor instance consider this statement:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Printf(\u0026#34;%s\u0026#34;, \u0026#34;Hello, 世界\u0026#34;)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe signature of \u003ccode\u003efmt.Printf\u003c/code\u003e is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Printf(format string, a ...interface{}) (n int, err error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is to say its arguments (after the format string) are interface values.\nWhat happens when \u003ccode\u003efmt.Printf\u003c/code\u003e is called with an untyped constant is that an interface value is created\nto pass as an argument, and the concrete type stored for that argument is the default type of the constant.\nThis process is analogous to what we saw earlier when declaring an initialized value using an untyped string constant.\u003c/p\u003e\n\u003cp\u003eYou can see the result in this example, which uses the format \u003ccode\u003e%v\u003c/code\u003e to print\nthe value and \u003ccode\u003e%T\u003c/code\u003e to print the type of the value being passed to \u003ccode\u003efmt.Printf\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nconst hello = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Printf(\u0026#34;%T: %v\\n\u0026#34;, \u0026#34;Hello, 世界\u0026#34;, \u0026#34;Hello, 世界\u0026#34;)\n    fmt.Printf(\u0026#34;%T: %v\\n\u0026#34;, hello, hello)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIf the constant has a type, that goes into the interface, as this example shows:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\ntype MyString string\n\nconst myStringHello MyString = \u0026#34;Hello, 世界\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Printf(\u0026#34;%T: %v\\n\u0026#34;, myStringHello, myStringHello)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e(For more information about how interface values work,\nsee the first sections of \u003ca href=\"/blog/laws-of-reflection\"\u003ethis blog post\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eIn summary, a typed constant obeys all the rules of typed values in Go.\nOn the other hand, an untyped constant does not carry a Go type in the same\nway and can be mixed and matched more freely.\nIt does, however, have a default type that is exposed when, and only when, no other type information is available.\u003c/p\u003e\n\u003ch2 id=\"default-type-determined-by-syntax\"\u003eDefault type determined by syntax\u003c/h2\u003e\n\u003cp\u003eThe default type of an untyped constant is determined by its syntax.\nFor string constants, the only possible implicit type is \u003ccode\u003estring\u003c/code\u003e.\nFor \u003ca href=\"/ref/spec#Numeric_types\"\u003enumeric constants\u003c/a\u003e, the implicit type has more variety.\nInteger constants default to \u003ccode\u003eint\u003c/code\u003e, floating-point constants \u003ccode\u003efloat64\u003c/code\u003e,\nrune constants to \u003ccode\u003erune\u003c/code\u003e (an alias for \u003ccode\u003eint32\u003c/code\u003e),\nand imaginary constants to \u003ccode\u003ecomplex128\u003c/code\u003e.\nHere’s our canonical print statement used repeatedly to show the default types in action:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, 0, 0)\n    fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, 0.0, 0.0)\n    fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, \u0026#39;x\u0026#39;, \u0026#39;x\u0026#39;)\n    fmt.Printf(\u0026#34;%T %v\\n\u0026#34;, 0i, 0i)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e(Exercise: Explain the result for \u003ccode\u003e\u0026#39;x\u0026#39;\u003c/code\u003e.)\u003c/p\u003e\n\u003ch2 id=\"booleans\"\u003eBooleans\u003c/h2\u003e\n\u003cp\u003eEverything we said about untyped string constants can be said for untyped boolean constants.\nThe values \u003ccode\u003etrue\u003c/code\u003e and \u003ccode\u003efalse\u003c/code\u003e are untyped boolean constants that can be assigned to any boolean variable,\nbut once given a type, boolean variables cannot be mixed:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type MyBool bool\n    const True = true\n    const TypedTrue bool = true\n    var mb MyBool\n    mb = true      // OK\n    mb = True      // OK\n    mb = TypedTrue // Bad\n    fmt.Println(mb)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eRun the example and see what happens, then comment out the “Bad” line and run it again.\nThe pattern here follows exactly that of string constants.\u003c/p\u003e\n\u003ch2 id=\"floats\"\u003eFloats\u003c/h2\u003e\n\u003cp\u003eFloating-point constants are just like boolean constants in most respects.\nOur standard example works as expected in translation:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type MyFloat64 float64\n    const Zero = 0.0\n    const TypedZero float64 = 0.0\n    var mf MyFloat64\n    mf = 0.0       // OK\n    mf = Zero      // OK\n    mf = TypedZero // Bad\n    fmt.Println(mf)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eOne wrinkle is that there are \u003cem\u003etwo\u003c/em\u003e floating-point types in Go: \u003ccode\u003efloat32\u003c/code\u003e and \u003ccode\u003efloat64\u003c/code\u003e.\nThe default type for a floating-point constant is \u003ccode\u003efloat64\u003c/code\u003e, although an untyped floating-point\nconstant can be assigned to a \u003ccode\u003efloat32\u003c/code\u003e value just fine:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const Zero = 0.0\n    const TypedZero float64 = 0.0\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var f32 float32\n    f32 = 0.0\n    f32 = Zero      // OK: Zero is untyped\n    f32 = TypedZero // Bad: TypedZero is float64 not float32.\n    fmt.Println(f32)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eFloating-point values are a good place to introduce the concept of overflow, or the range of values.\u003c/p\u003e\n\u003cp\u003eNumeric constants live in an arbitrary-precision numeric space; they are just regular numbers.\nBut when they are assigned to a variable the value must be able to fit in the destination.\nWe can declare a constant with a very large value:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    const Huge = 1e1000\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e—that’s just a number, after all—but we can’t assign it or even print it. This statement won’t even compile:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const Huge = 1e1000\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Println(Huge)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe error is, “constant 1.00000e+1000 overflows float64”, which is true.\nBut \u003ccode\u003eHuge\u003c/code\u003e might be useful: we can use it in expressions with other constants\nand use the value of those expressions if the result\ncan be represented in the range of a \u003ccode\u003efloat64\u003c/code\u003e.\nThe statement,\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const Huge = 1e1000\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    fmt.Println(Huge / 1e999)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eprints \u003ccode\u003e10\u003c/code\u003e, as one would expect.\u003c/p\u003e\n\u003cp\u003eIn a related way, floating-point constants may have very high precision,\nso that arithmetic involving them is more accurate.\nThe constants defined in the \u003ca href=\"/pkg/math\"\u003emath\u003c/a\u003e package are given with many more digits than are\navailable in a \u003ccode\u003efloat64\u003c/code\u003e. Here is the definition of \u003ccode\u003emath.Pi\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePi  = 3.14159265358979323846264338327950288419716939937510582097494459\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen that value is assigned to a variable,\nsome of the precision will be lost;\nthe assignment will create the \u003ccode\u003efloat64\u003c/code\u003e (or \u003ccode\u003efloat32\u003c/code\u003e)\nvalue closest to the high-precision value. This snippet\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;math\u0026#34;\n)\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    pi := math.Pi\n    fmt.Println(pi)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eprints \u003ccode\u003e3.141592653589793\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHaving so many digits available means that calculations like \u003ccode\u003ePi/2\u003c/code\u003e or other\nmore intricate evaluations can carry more precision\nuntil the result is assigned, making calculations involving constants easier to write without losing precision.\nIt also means that there is no occasion in which the floating-point corner cases like infinities,\nsoft underflows, and \u003ccode\u003eNaNs\u003c/code\u003e arise in constant expressions.\n(Division by a constant zero is a compile-time error,\nand when everything is a number there’s no such thing as “not a number”.)\u003c/p\u003e\n\u003ch2 id=\"complex-numbers\"\u003eComplex numbers\u003c/h2\u003e\n\u003cp\u003eComplex constants behave a lot like floating-point constants.\nHere’s a version of our now-familiar litany translated into complex numbers:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type MyComplex128 complex128\n    const I = (0.0 + 1.0i)\n    const TypedI complex128 = (0.0 + 1.0i)\n    var mc MyComplex128\n    mc = (0.0 + 1.0i) // OK\n    mc = I            // OK\n    mc = TypedI       // Bad\n    fmt.Println(mc)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe default type of a complex number is \u003ccode\u003ecomplex128\u003c/code\u003e, the larger-precision version composed of two \u003ccode\u003efloat64\u003c/code\u003e values.\u003c/p\u003e\n\u003cp\u003eFor clarity in our example, we wrote out the full expression \u003ccode\u003e(0.0+1.0i)\u003c/code\u003e,\nbut this value can be shortened to \u003ccode\u003e0.0+1.0i\u003c/code\u003e,\n\u003ccode\u003e1.0i\u003c/code\u003e or even \u003ccode\u003e1i\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eLet’s play a trick.\nWe know that in Go, a numeric constant is just a number.\nWhat if that number is a complex number with no imaginary part, that is, a real?\nHere’s one:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    const Two = 2.0 + 0i\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThat’s an untyped complex constant.\nEven though it has no imaginary part, the \u003cem\u003esyntax\u003c/em\u003e of the expression defines it to have default type \u003ccode\u003ecomplex128\u003c/code\u003e.\nTherefore, if we use it to declare a variable, the default type will be \u003ccode\u003ecomplex128\u003c/code\u003e. The snippet\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const Two = 2.0 + 0i\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    s := Two\n    fmt.Printf(\u0026#34;%T: %v\\n\u0026#34;, s, s)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eprints \u003ccode\u003ecomplex128:\u003c/code\u003e \u003ccode\u003e(2+0i)\u003c/code\u003e.\nBut numerically, \u003ccode\u003eTwo\u003c/code\u003e can be stored in a scalar floating-point number,\na \u003ccode\u003efloat64\u003c/code\u003e or \u003ccode\u003efloat32\u003c/code\u003e, with no loss of information.\nThus we can assign \u003ccode\u003eTwo\u003c/code\u003e to a \u003ccode\u003efloat64\u003c/code\u003e, either in an initialization or an assignment, without problems:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    const Two = 2.0 + 0i\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var f float64\n    var g float64 = Two\n    f = Two\n    fmt.Println(f, \u0026#34;and\u0026#34;, g)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe output is \u003ccode\u003e2\u003c/code\u003e \u003ccode\u003eand\u003c/code\u003e \u003ccode\u003e2\u003c/code\u003e.\nEven though \u003ccode\u003eTwo\u003c/code\u003e is a complex constant, it can be assigned to scalar floating-point variables.\nThis ability for a constant to “cross” types like this will prove useful.\u003c/p\u003e\n\u003ch2 id=\"integers\"\u003eIntegers\u003c/h2\u003e\n\u003cp\u003eAt last we come to integers.\nThey have more moving parts—\u003ca href=\"/ref/spec#Numeric_types\"\u003emany sizes, signed or unsigned, and more\u003c/a\u003e—but\nthey play by the same rules.\nFor the last time, here is our familiar example, using just \u003ccode\u003eint\u003c/code\u003e this time:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type MyInt int\n    const Three = 3\n    const TypedThree int = 3\n    var mi MyInt\n    mi = 3          // OK\n    mi = Three      // OK\n    mi = TypedThree // Bad\n    fmt.Println(mi)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe same example could be built for any of the integer types, which are:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eint int8 int16 int32 int64\nuint uint8 uint16 uint32 uint64\nuintptr\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(plus the aliases \u003ccode\u003ebyte\u003c/code\u003e for \u003ccode\u003euint8\u003c/code\u003e and \u003ccode\u003erune\u003c/code\u003e for \u003ccode\u003eint32\u003c/code\u003e).\nThat’s a lot, but the pattern in the way constants work should be familiar\nenough by now that you can see how things will play out.\u003c/p\u003e\n\u003cp\u003eAs mentioned above, integers come in a couple of forms and each form has\nits own default type:\n\u003ccode\u003eint\u003c/code\u003e for simple constants like \u003ccode\u003e123\u003c/code\u003e or \u003ccode\u003e0xFF\u003c/code\u003e or \u003ccode\u003e-14\u003c/code\u003e\nand \u003ccode\u003erune\u003c/code\u003e for quoted characters like ‘a’, ‘世’ or ‘\\r’.\u003c/p\u003e\n\u003cp\u003eNo constant form has as its default type an unsigned integer type.\nHowever, the flexibility of untyped constants means we can initialize unsigned\ninteger variables using simple constants as long as we are clear about the type.\nIt’s analogous to how we can initialize a \u003ccode\u003efloat64\u003c/code\u003e using a complex number with zero imaginary part.\nHere are several different ways to initialize a \u003ccode\u003euint\u003c/code\u003e;\nall are equivalent, but all must mention the type explicitly for the result to be unsigned.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar u uint = 17\nvar u = uint(17)\nu := uint(17)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSimilarly to the range issue mentioned in the section on floating-point values,\nnot all integer values can fit in all integer types.\nThere are two problems that might arise: the value might be too large,\nor it might be a negative value being assigned to an unsigned integer type.\nFor instance, \u003ccode\u003eint8\u003c/code\u003e has range -128 through 127,\nso constants outside of that range can never be assigned to a variable of type \u003ccode\u003eint8\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var i8 int8 = 128 // Error: too large.\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   _ = i8\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eSimilarly, \u003ccode\u003euint8\u003c/code\u003e, also known as \u003ccode\u003ebyte\u003c/code\u003e,\nhas range 0 through 255, so a large or negative constant cannot be assigned to a \u003ccode\u003euint8\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var u8 uint8 = -1 // Error: negative value.\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   _ = u8\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThis type-checking can catch mistakes like this one:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    type Char byte\n    var c Char = \u0026#39;世\u0026#39; // Error: \u0026#39;世\u0026#39; has value 0x4e16, too large.\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   _ = c\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIf the compiler complains about your use of a constant, it’s likely a real bug like this.\u003c/p\u003e\n\u003ch2 id=\"an-exercise-the-largest-unsigned-int\"\u003eAn exercise: The largest unsigned int\u003c/h2\u003e\n\u003cp\u003eHere is an informative little exercise.\nHow do we express a constant representing the largest value that fits in a \u003ccode\u003euint\u003c/code\u003e?\nIf we were talking about \u003ccode\u003euint32\u003c/code\u003e rather than \u003ccode\u003euint\u003c/code\u003e, we could write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst MaxUint32 = 1\u0026lt;\u0026lt;32 - 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebut we want \u003ccode\u003euint\u003c/code\u003e, not \u003ccode\u003euint32\u003c/code\u003e.\nThe \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003euint\u003c/code\u003e types have equal unspecified numbers of bits, either 32 or 64.\nSince the number of bits available depends on the architecture, we can’t just write down a single value.\u003c/p\u003e\n\u003cp\u003eFans of \u003ca href=\"http://en.wikipedia.org/wiki/Two\u0026#39;s_complement\" rel=\"noreferrer\" target=\"_blank\"\u003etwo’s-complement arithmetic\u003c/a\u003e,\nwhich Go’s integers are defined to use, know that the representation of \u003ccode\u003e-1\u003c/code\u003e has all its bits set to 1,\nso the bit pattern of \u003ccode\u003e-1\u003c/code\u003e is internally the same as that of the\nlargest unsigned integer.\nWe therefore might think we could write\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const MaxUint uint = -1 // Error: negative value\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003ebut that is illegal because -1 cannot be represented by an unsigned variable;\n\u003ccode\u003e-1\u003c/code\u003e is not in the range of unsigned values.\nA conversion won’t help either, for the same reason:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const MaxUint uint = uint(-1) // Error: negative value\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eEven though at run-time a value of -1 can be converted to an unsigned integer, the rules\nfor constant \u003ca href=\"/ref/spec#Conversions\"\u003econversions\u003c/a\u003e forbid this kind of coercion at compile time.\nThat is to say, this works:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var u uint\n    var v = -1\n    u = uint(v)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   _ = u\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003ebut only because \u003ccode\u003ev\u003c/code\u003e is a variable; if we made \u003ccode\u003ev\u003c/code\u003e a constant,\neven an untyped constant, we’d be back in forbidden territory:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var u uint\n    const v = -1\n    u = uint(v) // Error: negative value\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e   _ = u\n}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eWe return to our previous approach, but instead of \u003ccode\u003e-1\u003c/code\u003e we try \u003ccode\u003e^0\u003c/code\u003e,\nthe bitwise negation of an arbitrary number of zero bits.\nBut that fails too, for a similar reason:\nIn the space of numeric values,\n\u003ccode\u003e^0\u003c/code\u003e represents an infinite number of ones, so we lose information if we assign that to any fixed-size integer:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const MaxUint uint = ^0 // Error: overflow\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHow then do we represent the largest unsigned integer as a constant?\u003c/p\u003e\n\u003cp\u003eThe key is to constrain the operation to the number of bits in a \u003ccode\u003euint\u003c/code\u003e and avoiding\nvalues, such as negative numbers, that are not representable in a \u003ccode\u003euint\u003c/code\u003e.\nThe simplest \u003ccode\u003euint\u003c/code\u003e value is the typed constant \u003ccode\u003euint(0)\u003c/code\u003e.\nIf \u003ccode\u003euints\u003c/code\u003e have 32 or 64 bits, \u003ccode\u003euint(0)\u003c/code\u003e has 32 or 64 zero bits accordingly.\nIf we invert each of those bits, we’ll get the correct number of one bits, which is the largest \u003ccode\u003euint\u003c/code\u003e value.\u003c/p\u003e\n\u003cp\u003eTherefore we don’t flip the bits of the untyped constant \u003ccode\u003e0\u003c/code\u003e, we flip the bits of the typed constant \u003ccode\u003euint(0)\u003c/code\u003e.\nHere, then, is our constant:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    const MaxUint = ^uint(0)\n    fmt.Printf(\u0026#34;%x\\n\u0026#34;, MaxUint)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eWhatever the number of bits it takes to represent a \u003ccode\u003euint\u003c/code\u003e in the current execution environment\n(on the \u003ca href=\"/blog/playground\"\u003eplayground\u003c/a\u003e, it’s 32),\nthis constant correctly represents the largest value a variable of type \u003ccode\u003euint\u003c/code\u003e can hold.\u003c/p\u003e\n\u003cp\u003eIf you understand the analysis that got us to this result,\nyou understand all the important points about constants in Go.\u003c/p\u003e\n\u003ch2 id=\"numbers\"\u003eNumbers\u003c/h2\u003e\n\u003cp\u003eThe concept of untyped constants in Go means that all the numeric constants,\nwhether integer, floating-point, complex,\nor even character values,\nlive in a kind of unified space.\nIt’s when we bring them to the computational world of variables,\nassignments, and operations that the actual types matter.\nBut as long as we stay in the world of numeric constants, we can mix and match values as we like.\nAll these constants have numeric value 1:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n1.000\n1e3-99.0*10-9\n\u0026#39;\\x01\u0026#39;\n\u0026#39;\\u0001\u0026#39;\n\u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;\n1.0+3i-3.0i\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTherefore, although they have different implicit default types,\nwritten as untyped constants they can be assigned to a variable of any numeric type:\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var f float32 = 1\n    var i int = 1.000\n    var u uint32 = 1e3 - 99.0*10.0 - 9\n    var c float64 = \u0026#39;\\x01\u0026#39;\n    var p uintptr = \u0026#39;\\u0001\u0026#39;\n    var r complex64 = \u0026#39;b\u0026#39; - \u0026#39;a\u0026#39;\n    var b byte = 1.0 + 3i - 3.0i\n\n    fmt.Println(f, i, u, c, p, r, b)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe output from this snippet is: \u003ccode\u003e1 1 1 1 1 (1+0i) 1\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou can even do nutty stuff like\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003e    var f = \u0026#39;a\u0026#39; * 1.5\n    fmt.Println(f)\n\u003c/pre\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003ewhich yields 145.5, which is pointless except to prove a point.\u003c/p\u003e\n\u003cp\u003eBut the real point of these rules is flexibility.\nThat flexibility means that, despite the fact that in Go it is illegal in\nthe same expression to mix floating-point and integer variables,\nor even \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003eint32\u003c/code\u003e variables, it is fine to write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esqrt2 := math.Sqrt(2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst millisecond = time.Second/1e3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebigBufferWithHeader := make([]byte, 512+1e6)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand have the results mean what you expect.\u003c/p\u003e\n\u003cp\u003eBecause in Go, numeric constants work as you expect: like numbers.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-08-25T00:00:00Z",
  "Author": "Rob Pike"
}