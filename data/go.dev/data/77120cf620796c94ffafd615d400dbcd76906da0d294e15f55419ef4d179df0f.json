{
  "Source": "go.dev",
  "Title": "An Introduction To Generics",
  "Link": "https://go.dev/blog/intro-generics",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/intro-generics\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eAn Introduction To Generics\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Griesemer and Ian Lance Taylor\u003cbr/\u003e\n      22 March 2022\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis blog post is based on our talk at GopherCon 2021:\u003c/p\u003e\n\u003cdiv class=\"iframe\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/Pa_e9EeCdy8\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" mozallowfullscreen=\"\" webkitallowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003cp\u003eThe Go 1.18 release adds support for generics.\nGenerics are the biggest change we’ve made to Go since the first open\nsource release.\nIn this article we’ll introduce the new language features.\nWe won’t try to cover all the details, but we will hit all the\nimportant points.\nFor a more detailed and much longer description, including many\nexamples, see the \u003ca href=\"https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md\" rel=\"noreferrer\" target=\"_blank\"\u003eproposal\ndocument\u003c/a\u003e.\nFor a more precise description of the language changes, see the\n\u003ca href=\"/ref/spec\"\u003eupdated language spec\u003c/a\u003e.\n(Note that the actual 1.18 implementation imposes some restrictions on\nwhat the proposal document permits; the spec should be accurate.\nFuture releases may lift some of the restrictions.)\u003c/p\u003e\n\u003cp\u003eGenerics are a way of writing code that is independent of the specific\ntypes being used.\nFunctions and types may now be written to use any of a set of types.\u003c/p\u003e\n\u003cp\u003eGenerics add three new big things to the language:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eType parameters for function and types.\u003c/li\u003e\n\u003cli\u003eDefining interface types as sets of types, including types that\ndon’t have methods.\u003c/li\u003e\n\u003cli\u003eType inference, which permits omitting type arguments in many\ncases when calling a function.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"type-parameters\"\u003eType Parameters\u003c/h2\u003e\n\u003cp\u003eFunctions and types are now permitted to have type parameters.\nA type parameter list looks like an ordinary parameter list, except\nthat it uses square brackets instead of parentheses.\u003c/p\u003e\n\u003cp\u003eTo show how this works, let’s start with the basic non-generic \u003ccode\u003eMin\u003c/code\u003e\nfunction for floating point values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Min(x, y float64) float64 {\n    if x \u0026lt; y {\n        return x\n    }\n    return y\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can make this function generic–make it work for different\ntypes–by adding a type parameter list.\nIn this example we add a type parameter list with a single type\nparameter \u003ccode\u003eT\u003c/code\u003e, and replace the uses of \u003ccode\u003efloat64\u003c/code\u003e with \u003ccode\u003eT\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026#34;golang.org/x/exp/constraints\u0026#34;\n\nfunc GMin[T constraints.Ordered](x, y T) T {\n    if x \u0026lt; y {\n        return x\n    }\n    return y\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is now possible to call this function with a type argument by\nwriting a call like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ex := GMin[int](2, 3)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eProviding the type argument to \u003ccode\u003eGMin\u003c/code\u003e, in this case \u003ccode\u003eint\u003c/code\u003e, is called\n\u003cem\u003einstantiation\u003c/em\u003e.\nInstantiation happens in two steps.\nFirst, the compiler substitutes all type arguments for their\nrespective type parameters throughout the generic function or type.\nSecond, the compiler verifies that each type argument satisfies the\nrespective constraint.\nWe’ll get to what that means shortly, but if that second step fails,\ninstantiation fails and the program is invalid.\u003c/p\u003e\n\u003cp\u003eAfter successful instantiation we have a non-generic function that can\nbe called just like any other function.\nFor example, in code like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efmin := GMin[float64]\nm := fmin(2.71, 3.14)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe instantiation \u003ccode\u003eGMin[float64]\u003c/code\u003e produces what is effectively our\noriginal floating-point \u003ccode\u003eMin\u003c/code\u003e function, and we can use that in a\nfunction call.\u003c/p\u003e\n\u003cp\u003eType parameters can be used with types also.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Tree[T interface{}] struct {\n    left, right *Tree[T]\n    value       T\n}\n\nfunc (t *Tree[T]) Lookup(x T) *Tree[T] { ... }\n\nvar stringTree Tree[string]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere the generic type \u003ccode\u003eTree\u003c/code\u003e stores values of the type parameter \u003ccode\u003eT\u003c/code\u003e.\nGeneric types can have methods, like \u003ccode\u003eLookup\u003c/code\u003e in this example.\nIn order to use a generic type, it must be instantiated;\n\u003ccode\u003eTree[string]\u003c/code\u003e is an example of instantiating \u003ccode\u003eTree\u003c/code\u003e with the type\nargument \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"type-sets\"\u003eType sets\u003c/h2\u003e\n\u003cp\u003eLet’s look a bit deeper at the type arguments that can be used to\ninstantiate a type parameter.\u003c/p\u003e\n\u003cp\u003eAn ordinary function has a type for each value parameter; that type\ndefines a set of values.\nFor instance, if we have a \u003ccode\u003efloat64\u003c/code\u003e type as in the non-generic\nfunction \u003ccode\u003eMin\u003c/code\u003e above, the permissible set of argument values is the\nset of floating-point values that can be represented by the \u003ccode\u003efloat64\u003c/code\u003e\ntype.\u003c/p\u003e\n\u003cp\u003eSimilarly, type parameter lists have a type for each type parameter.\nBecause a type parameter is itself a type, the types of type\nparameters define sets of types.\nThis meta-type is called a \u003cem\u003etype constraint\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eIn the generic \u003ccode\u003eGMin\u003c/code\u003e, the type constraint is imported from the\n\u003ca href=\"https://golang.org/x/exp/constraints\" rel=\"noreferrer\" target=\"_blank\"\u003econstraints package\u003c/a\u003e.\nThe \u003ccode\u003eOrdered\u003c/code\u003e constraint describes the set of all types with values\nthat can be ordered, or, in other words, compared with the  \u0026lt;\noperator (or  \u0026lt;= ,  \u0026gt; , etc.).\nThe constraint ensures that only types with orderable values can be\npassed to \u003ccode\u003eGMin\u003c/code\u003e.\nIt also means that in the \u003ccode\u003eGMin\u003c/code\u003e function body values of that type\nparameter can be used in a comparison with the  \u0026lt;  operator.\u003c/p\u003e\n\u003cp\u003eIn Go, type constraints must be interfaces.\nThat is, an interface type can be used as a value type, and it can\nalso be used as a meta-type.\nInterfaces define methods, so obviously we can express type\nconstraints that require certain methods to be present.\nBut \u003ccode\u003econstraints.Ordered\u003c/code\u003e is an interface type too, and the  \u0026lt;\noperator is not a method.\u003c/p\u003e\n\u003cp\u003eTo make this work, we look at interfaces in a new way.\u003c/p\u003e\n\u003cp\u003eUntil recently, the Go spec said that an interface defines a method\nset, which is roughly the set of methods enumerated in the interface.\nAny type that implements all those methods implements that interface.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"intro-generics/method-sets.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eBut another way of looking at this is to say that the interface\ndefines a set of types, namely the types that implement those methods.\nFrom this perspective, any type that is an element of the interface’s\ntype set implements the interface.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"intro-generics/type-sets.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe two views lead to the same outcome: For each set of methods we can\nimagine the corresponding set of types that implement those methods,\nand that is the set of types defined by the interface.\u003c/p\u003e\n\u003cp\u003eFor our purposes, though, the type set view has an advantage over the\nmethod set view: we can explicitly add types to the set, and thus\ncontrol the type set in new ways.\u003c/p\u003e\n\u003cp\u003eWe have extended the syntax for interface types to make this work.\nFor instance, \u003ccode\u003einterface{ int|string|bool }\u003c/code\u003e defines the type set\ncontaining the types \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, and \u003ccode\u003ebool\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"intro-generics/type-sets-2.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eAnother way of saying this is that this interface is satisfied by\nonly \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e, or \u003ccode\u003ebool\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNow let’s look at the actual definition of \u003ccode\u003econstraints.Ordered\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Ordered interface {\n    Integer|Float|~string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis declaration says that the \u003ccode\u003eOrdered\u003c/code\u003e interface is the set of all\ninteger, floating-point, and string types.\nThe vertical bar expresses a union of types (or sets of types in this\ncase).\n\u003ccode\u003eInteger\u003c/code\u003e and \u003ccode\u003eFloat\u003c/code\u003e are interface types that are similarly defined\nin the \u003ccode\u003econstraints\u003c/code\u003e package.\nNote that there are no methods defined by the \u003ccode\u003eOrdered\u003c/code\u003e interface.\u003c/p\u003e\n\u003cp\u003eFor type constraints we usually don’t care about a specific type, such\nas \u003ccode\u003estring\u003c/code\u003e; we are interested in all string types.\nThat is what the \u003ccode\u003e~\u003c/code\u003e token is for.\nThe expression \u003ccode\u003e~string\u003c/code\u003e means the set of all types whose underlying\ntype is \u003ccode\u003estring\u003c/code\u003e.\nThis includes the type \u003ccode\u003estring\u003c/code\u003e itself as well as all types declared\nwith definitions such as \u003ccode\u003etype MyString string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eOf course we still want to specify methods in interfaces, and we want\nto be backward compatible.\nIn Go 1.18 an interface may contain methods and embedded interfaces\njust as before, but it may also embed non-interface types, unions, and\nsets of underlying types.\u003c/p\u003e\n\u003cp\u003eWhen used as a type constraint, the type set defined by an interface\nspecifies exactly the types that are permitted as type arguments for\nthe respective type parameter.\nWithin a generic function body, if the type of a operand is a type\nparameter \u003ccode\u003eP\u003c/code\u003e with constraint \u003ccode\u003eC\u003c/code\u003e, operations are permitted if they\nare permitted by all types in the type set of \u003ccode\u003eC\u003c/code\u003e (there are currently\nsome implementation restrictions here, but ordinary code is unlikely\nto encounter them).\u003c/p\u003e\n\u003cp\u003eInterfaces used as constraints may be given names (such as \u003ccode\u003eOrdered\u003c/code\u003e),\nor they may be literal interfaces inlined in a type parameter list.\nFor example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[S interface{~[]E}, E interface{}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere \u003ccode\u003eS\u003c/code\u003e must be a slice type whose element type can be any type.\u003c/p\u003e\n\u003cp\u003eBecause this is a common case, the enclosing \u003ccode\u003einterface{}\u003c/code\u003e may be\nomitted for interfaces in constraint position, and we can simply\nwrite:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[S ~[]E, E interface{}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause the empty interface is common in type parameter lists, and in\nordinary Go code for that matter, Go 1.18 introduces a new predeclared\nidentifier \u003ccode\u003eany\u003c/code\u003e as an alias for the empty interface type.\nWith that, we arrive at this idiomatic code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[S ~[]E, E any]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInterfaces as type sets is a powerful new mechanism and is key to\nmaking type constraints work in Go.\nFor now, interfaces that use the new syntactic forms may only be used\nas constraints.\nBut it’s not hard to imagine how explicitly type-constrained\ninterfaces might be useful in general.\u003c/p\u003e\n\u003ch2 id=\"type-inference\"\u003eType inference\u003c/h2\u003e\n\u003cp\u003eThe last new major language feature is type inference.\nIn some ways this is the most complicated change to the language, but\nit is important because it lets people use a natural style when\nwriting code that calls generic functions.\u003c/p\u003e\n\u003ch3 id=\"function-argument-type-inference\"\u003eFunction argument type inference\u003c/h3\u003e\n\u003cp\u003eWith type parameters comes the need to pass type arguments, which can\nmake for verbose code.\nGoing back to our generic \u003ccode\u003eGMin\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc GMin[T constraints.Ordered](x, y T) T { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe type parameter \u003ccode\u003eT\u003c/code\u003e is used to specify the types of the ordinary\nnon-type arguments \u003ccode\u003ex\u003c/code\u003e, and \u003ccode\u003ey\u003c/code\u003e.\nAs we saw earlier, this can be called with an explicit type argument\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar a, b, m float64\n\nm = GMin[float64](a, b) // explicit type argument\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn many cases the compiler can infer the type argument for \u003ccode\u003eT\u003c/code\u003e from\nthe ordinary arguments.\nThis makes the code shorter while remaining clear.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar a, b, m float64\n\nm = GMin(a, b) // no type argument\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works by matching the types of the arguments \u003ccode\u003ea\u003c/code\u003e and \u003ccode\u003eb\u003c/code\u003e with the\ntypes of the parameters \u003ccode\u003ex\u003c/code\u003e, and \u003ccode\u003ey\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis kind of inference, which infers the type arguments from the types\nof the arguments to the function, is called \u003cem\u003efunction argument type\ninference\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eFunction argument type inference only works for type parameters that\nare used in the function parameters, not for type parameters used only\nin function results or only in the function body.\nFor example, it does not apply to functions like \u003ccode\u003eMakeT[T any]() T\u003c/code\u003e,\nthat only uses \u003ccode\u003eT\u003c/code\u003e for a result.\u003c/p\u003e\n\u003ch3 id=\"constraint-type-inference\"\u003eConstraint type inference\u003c/h3\u003e\n\u003cp\u003eThe language supports another kind of type inference, \u003cem\u003econstraint type\ninference\u003c/em\u003e.\nTo describe this, let’s start with this example of scaling a slice of\nintegers:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Scale returns a copy of s with each element multiplied by c.\n// This implementation has a problem, as we will see.\nfunc Scale[E constraints.Integer](s []E, c E) []E {\n    r := make([]E, len(s))\n    for i, v := range s {\n        r[i] = v * c\n    }\n    return r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is a generic function that works for a slice of any integer\ntype.\u003c/p\u003e\n\u003cp\u003eNow suppose that we have a multi-dimensional \u003ccode\u003ePoint\u003c/code\u003e type, where each\n\u003ccode\u003ePoint\u003c/code\u003e is simply a list of integers giving the coordinates of the\npoint.\nNaturally this type will have some methods.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Point []int32\n\nfunc (p Point) String() string {\n    // Details not important.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSometimes we want to scale a \u003ccode\u003ePoint\u003c/code\u003e.\nSince a \u003ccode\u003ePoint\u003c/code\u003e is just a slice of integers, we can use the \u003ccode\u003eScale\u003c/code\u003e\nfunction we wrote earlier:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// ScaleAndPrint doubles a Point and prints it.\nfunc ScaleAndPrint(p Point) {\n    r := Scale(p, 2)\n    fmt.Println(r.String()) // DOES NOT COMPILE\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnfortunately this does not compile, failing with an error like\n\u003ccode\u003er.String undefined (type []int32 has no field or method String)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe problem is that the \u003ccode\u003eScale\u003c/code\u003e function returns a value of type \u003ccode\u003e[]E\u003c/code\u003e\nwhere \u003ccode\u003eE\u003c/code\u003e is the element type of the argument slice.\nWhen we call \u003ccode\u003eScale\u003c/code\u003e with a value of type \u003ccode\u003ePoint\u003c/code\u003e, whose underlying\ntype is \u003ccode\u003e[]int32\u003c/code\u003e, we get back a value of type \u003ccode\u003e[]int32\u003c/code\u003e, not type\n\u003ccode\u003ePoint\u003c/code\u003e.\nThis follows from the way that the generic code is written, but it’s\nnot what we want.\u003c/p\u003e\n\u003cp\u003eIn order to fix this, we have to change the \u003ccode\u003eScale\u003c/code\u003e function to use a\ntype parameter for the slice type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Scale returns a copy of s with each element multiplied by c.\nfunc Scale[S ~[]E, E constraints.Integer](s S, c E) S {\n    r := make(S, len(s))\n    for i, v := range s {\n        r[i] = v * c\n    }\n    return r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ve introduced a new type parameter \u003ccode\u003eS\u003c/code\u003e that is the type of the\nslice argument.\nWe’ve constrained it such that the underlying type is \u003ccode\u003eS\u003c/code\u003e rather than\n\u003ccode\u003e[]E\u003c/code\u003e, and the result type is now \u003ccode\u003eS\u003c/code\u003e.\nSince \u003ccode\u003eE\u003c/code\u003e is constrained to be an integer, the effect is the same as\nbefore: the first argument has to be a slice of some integer type.\nThe only change to the body of the function is that now we pass \u003ccode\u003eS\u003c/code\u003e,\nrather than \u003ccode\u003e[]E\u003c/code\u003e, when we call \u003ccode\u003emake\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe new function acts the same as before if we call it with a plain\nslice, but if we call it with the type \u003ccode\u003ePoint\u003c/code\u003e we now get back a value\nof type \u003ccode\u003ePoint\u003c/code\u003e.\nThat is what we want.\nWith this version of \u003ccode\u003eScale\u003c/code\u003e the earlier \u003ccode\u003eScaleAndPrint\u003c/code\u003e function will\ncompile and run as we expect.\u003c/p\u003e\n\u003cp\u003eBut it’s fair to ask: why is it OK to write the call to \u003ccode\u003eScale\u003c/code\u003e\nwithout passing explicit type arguments?\nThat is, why can we write \u003ccode\u003eScale(p, 2)\u003c/code\u003e, with no type arguments,\nrather than having to write \u003ccode\u003eScale[Point, int32](p, 2)\u003c/code\u003e?\nOur new \u003ccode\u003eScale\u003c/code\u003e function has two type parameters, \u003ccode\u003eS\u003c/code\u003e and \u003ccode\u003eE\u003c/code\u003e.\nIn a call to \u003ccode\u003eScale\u003c/code\u003e not passing any type arguments, function argument\ntype inference, described above, lets the compiler infer that the type\nargument for \u003ccode\u003eS\u003c/code\u003e is \u003ccode\u003ePoint\u003c/code\u003e.\nBut the function also has a type parameter \u003ccode\u003eE\u003c/code\u003e which is the type of the\nmultiplication factor \u003ccode\u003ec\u003c/code\u003e.\nThe corresponding function argument is \u003ccode\u003e2\u003c/code\u003e, and because \u003ccode\u003e2\u003c/code\u003e is an \u003cem\u003euntyped\u003c/em\u003e\nconstant, function argument type inference cannot infer the correct type for\n\u003ccode\u003eE\u003c/code\u003e (at best it might infer the default type for \u003ccode\u003e2\u003c/code\u003e which is \u003ccode\u003eint\u003c/code\u003e and which\nwould be incorrect).\nInstead, the process by which the compiler infers that the type argument\nfor \u003ccode\u003eE\u003c/code\u003e is the element type of the slice is called \u003cem\u003econstraint type\ninference\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eConstraint type inference deduces type arguments from type parameter\nconstraints.\nIt is used when one type parameter has a constraint defined in terms\nof another type parameter.\nWhen the type argument of one of those type parameters is known,\nthe constraint is used to infer the type argument of the other.\u003c/p\u003e\n\u003cp\u003eThe usual case where this applies is when one constraint uses the form\n\u003ccode\u003e~\u003c/code\u003e\u003cem\u003e\u003ccode\u003etype\u003c/code\u003e\u003c/em\u003e for some type, where that type is written using other type\nparameters.\nWe see this in the \u003ccode\u003eScale\u003c/code\u003e example.\n\u003ccode\u003eS\u003c/code\u003e is \u003ccode\u003e~[]E\u003c/code\u003e, which is \u003ccode\u003e~\u003c/code\u003e followed by a type \u003ccode\u003e[]E\u003c/code\u003e written in terms\nof another type parameter.\nIf we know the type argument for \u003ccode\u003eS\u003c/code\u003e we can infer the type argument\nfor \u003ccode\u003eE\u003c/code\u003e.\n\u003ccode\u003eS\u003c/code\u003e is a slice type, and \u003ccode\u003eE\u003c/code\u003e is the element type of that slice.\u003c/p\u003e\n\u003cp\u003eThis was just an introduction to constraint type inference.\nFor full details see the \u003ca href=\"https://go.googlesource.com/proposal/+/HEAD/design/43651-type-parameters.md\" rel=\"noreferrer\" target=\"_blank\"\u003eproposal\ndocument\u003c/a\u003e\nor the \u003ca href=\"/ref/spec\"\u003elanguage spec\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"type-inference-in-practice\"\u003eType inference in practice\u003c/h3\u003e\n\u003cp\u003eThe exact details of how type inference works are complicated, but\nusing it is not: type inference either succeeds or fails.\nIf it succeeds, type arguments can be omitted, and calling generic\nfunctions looks no different than calling ordinary functions.\nIf type inference fails, the compiler will give an error message, and\nin those cases we can just provide the necessary type arguments.\u003c/p\u003e\n\u003cp\u003eIn adding type inference to the language we’ve tried to strike a\nbalance between inference power and complexity.\nWe want to ensure that when the compiler infers types, those types are\nnever surprising.\nWe’ve tried to be careful to err on the side of failing to infer a\ntype rather than on the side of inferring the wrong type.\nWe probably have not gotten it entirely right, and we may continue to\nrefine it in future releases.\nThe effect will be that more programs can be written without explicit\ntype arguments.\nPrograms that don’t need type arguments today won’t need them tomorrow\neither.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eGenerics are a big new language feature in 1.18.\nThese new language changes required a large amount of new\ncode that has not had significant testing in production settings.\nThat will only happen as more people write and use generic code.\nWe believe that this feature is well implemented and high quality.\nHowever, unlike most aspects of Go, we can’t back up that belief with\nreal world experience.\nTherefore, while we encourage the use of generics where it makes\nsense, please use appropriate caution when deploying generic code in\nproduction.\u003c/p\u003e\n\u003cp\u003eThat caution aside, we’re excited to have generics available, and we\nhope that they will make Go programmers more productive.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-03-22T00:00:00Z",
  "Author": "Robert Griesemer and Ian Lance Taylor"
}