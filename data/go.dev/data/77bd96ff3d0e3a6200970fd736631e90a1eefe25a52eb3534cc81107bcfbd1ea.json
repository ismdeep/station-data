{
  "Source": "go.dev",
  "Title": "The Go image/draw package",
  "Link": "https://go.dev/blog/image-draw",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/image-draw\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eThe Go image/draw package\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Nigel Tao\u003cbr/\u003e\n      29 September 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/pkg/image/draw/\"\u003ePackage image/draw\u003c/a\u003e defines only one operation:\ndrawing a source image onto a destination image,\nthrough an optional mask image.\nThis one operation is surprisingly versatile and can perform a number of\ncommon image manipulation tasks elegantly and efficiently.\u003c/p\u003e\n\u003cp\u003eComposition is performed pixel by pixel in the style of the Plan 9 graphics\nlibrary and the X Render extension.\nThe model is based on the classic “Compositing Digital Images” paper by Porter and Duff,\nwith an additional mask parameter:\n\u003ccode\u003edst = (src IN mask) OP dst\u003c/code\u003e.\nFor a fully opaque mask, this reduces to the original Porter-Duff formula: \u003ccode\u003edst = src OP dst\u003c/code\u003e.\nIn Go, a nil mask image is equivalent to an infinitely sized,\nfully opaque mask image.\u003c/p\u003e\n\u003cp\u003eThe Porter-Duff paper presented \u003ca href=\"http://www.w3.org/TR/SVGCompositing/examples/compop-porterduff-examples.png\" rel=\"noreferrer\" target=\"_blank\"\u003e12 different composition operators\u003c/a\u003e,\nbut with an explicit mask, only 2 of these are needed in practice:\nsource-over-destination and source.\nIn Go, these operators are represented by the \u003ccode\u003eOver\u003c/code\u003e and \u003ccode\u003eSrc\u003c/code\u003e constants.\nThe \u003ccode\u003eOver\u003c/code\u003e operator performs the natural layering of a source image over\na destination image:\nthe change to the destination image is smaller where the source (after masking)\nis more transparent (that is, has lower alpha).\nThe \u003ccode\u003eSrc\u003c/code\u003e operator merely copies the source (after masking) with no regard\nfor the destination image’s original content.\nFor fully opaque source and mask images, the two operators produce the same output,\nbut the \u003ccode\u003eSrc\u003c/code\u003e operator is usually faster.\u003c/p\u003e\n\u003ch2 id=\"geometric-alignment\"\u003eGeometric Alignment\u003c/h2\u003e\n\u003cp\u003eComposition requires associating destination pixels with source and mask pixels.\nObviously, this requires destination, source and mask images,\nand a composition operator, but it also requires specifying what rectangle\nof each image to use.\nNot every drawing should write to the entire destination:\nwhen updating an animating image, it is more efficient to only draw the\nparts of the image that have changed.\nNot every drawing should read from the entire source:\nwhen using a sprite that combines many small images into one large one,\nonly a part of the image is needed.\nNot every drawing should read from the entire mask:\na mask image that collects a font’s glyphs is similar to a sprite.\nThus, drawing also needs to know three rectangles, one for each image.\nSince each rectangle has the same width and height,\nit suffices to pass a destination rectangle \u003ccode\u003er\u003c/code\u003e and two points \u003ccode\u003esp\u003c/code\u003e and \u003ccode\u003emp\u003c/code\u003e:\nthe source rectangle is equal to \u003ccode\u003er\u003c/code\u003e translated so that \u003ccode\u003er.Min\u003c/code\u003e in the destination\nimage aligns with \u003ccode\u003esp\u003c/code\u003e in the source image,\nand similarly for \u003ccode\u003emp\u003c/code\u003e.\nThe effective rectangle is also clipped to each image’s bounds in their\nrespective co-ordinate space.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/20.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/image/draw/#DrawMask\"\u003e\u003ccode\u003eDrawMask\u003c/code\u003e\u003c/a\u003e function\ntakes seven arguments,\nbut an explicit mask and mask-point are usually unnecessary,\nso the \u003ca href=\"/pkg/image/draw/#Draw\"\u003e\u003ccode\u003eDraw\u003c/code\u003e\u003c/a\u003e function takes five:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Draw calls DrawMask with a nil mask.\nfunc Draw(dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\nfunc DrawMask(dst Image, r image.Rectangle, src image.Image, sp image.Point,\n mask image.Image, mp image.Point, op Op)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe destination image must be mutable, so the image/draw package defines\na \u003ca href=\"/pkg/image/draw/#Image\"\u003e\u003ccode\u003edraw.Image\u003c/code\u003e\u003c/a\u003e interface which has a \u003ccode\u003eSet\u003c/code\u003e method.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Image interface {\n    image.Image\n    Set(x, y int, c color.Color)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"filling-a-rectangle\"\u003eFilling a Rectangle\u003c/h2\u003e\n\u003cp\u003eTo fill a rectangle with a solid color, use an \u003ccode\u003eimage.Uniform\u003c/code\u003e source.\nThe \u003ccode\u003eColorImage\u003c/code\u003e type re-interprets a \u003ccode\u003eColor\u003c/code\u003e as a practically infinite-sized\n\u003ccode\u003eImage\u003c/code\u003e of that color.\nFor those familiar with the design of Plan 9’s draw library,\nthere is no need for an explicit “repeat bit” in Go’s slice-based image types;\nthe concept is subsumed by \u003ccode\u003eUniform\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// image.ZP is the zero point -- the origin.\ndraw.Draw(dst, r, \u0026amp;image.Uniform{c}, image.ZP, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo initialize a new image to all-blue:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em := image.NewRGBA(image.Rect(0, 0, 640, 480))\nblue := color.RGBA{0, 0, 255, 255}\ndraw.Draw(m, m.Bounds(), \u0026amp;image.Uniform{blue}, image.ZP, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo reset an image to transparent (or black,\nif the destination image’s color model cannot represent transparency),\nuse \u003ccode\u003eimage.Transparent\u003c/code\u003e, which is an \u003ccode\u003eimage.Uniform\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edraw.Draw(m, m.Bounds(), image.Transparent, image.ZP, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2a.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"copying-an-image\"\u003eCopying an Image\u003c/h2\u003e\n\u003cp\u003eTo copy from a rectangle \u003ccode\u003esr\u003c/code\u003e in the source image to a rectangle starting\nat a point \u003ccode\u003edp\u003c/code\u003e in the destination,\nconvert the source rectangle into the destination image’s co-ordinate space:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003er := image.Rectangle{dp, dp.Add(sr.Size())}\ndraw.Draw(dst, r, src, sr.Min, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAlternatively:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003er := sr.Sub(sr.Min).Add(dp)\ndraw.Draw(dst, r, src, sr.Min, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo copy the entire source image, use \u003ccode\u003esr = src.Bounds()\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2b.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"scrolling-an-image\"\u003eScrolling an Image\u003c/h2\u003e\n\u003cp\u003eScrolling an image is just copying an image to itself,\nwith different destination and source rectangles.\nOverlapping destination and source images are perfectly valid,\njust as Go’s built-in copy function can handle overlapping destination and source slices.\nTo scroll an image m by 20 pixels:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := m.Bounds()\np := image.Pt(0, 20)\n// Note that even though the second argument is b,\n// the effective rectangle is smaller due to clipping.\ndraw.Draw(m, b, m, b.Min.Add(p), draw.Src)\ndirtyRect := b.Intersect(image.Rect(b.Min.X, b.Max.Y-20, b.Max.X, b.Max.Y))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2c.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"converting-an-image-to-rgba\"\u003eConverting an Image to RGBA\u003c/h2\u003e\n\u003cp\u003eThe result of decoding an image format might not be an \u003ccode\u003eimage.RGBA\u003c/code\u003e:\ndecoding a GIF results in an \u003ccode\u003eimage.Paletted\u003c/code\u003e,\ndecoding a JPEG results in a \u003ccode\u003eycbcr.YCbCr\u003c/code\u003e,\nand the result of decoding a PNG depends on the image data.\nTo convert any image to an \u003ccode\u003eimage.RGBA\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := src.Bounds()\nm := image.NewRGBA(image.Rect(0, 0, b.Dx(), b.Dy()))\ndraw.Draw(m, m.Bounds(), src, b.Min, draw.Src)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2d.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"drawing-through-a-mask\"\u003eDrawing Through a Mask\u003c/h2\u003e\n\u003cp\u003eTo draw an image through a circular mask with center \u003ccode\u003ep\u003c/code\u003e and radius \u003ccode\u003er\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype circle struct {\n    p image.Point\n    r int\n}\n\nfunc (c *circle) ColorModel() color.Model {\n    return color.AlphaModel\n}\n\nfunc (c *circle) Bounds() image.Rectangle {\n    return image.Rect(c.p.X-c.r, c.p.Y-c.r, c.p.X+c.r, c.p.Y+c.r)\n}\n\nfunc (c *circle) At(x, y int) color.Color {\n    xx, yy, rr := float64(x-c.p.X)+0.5, float64(y-c.p.Y)+0.5, float64(c.r)\n    if xx*xx+yy*yy \u0026lt; rr*rr {\n        return color.Alpha{255}\n    }\n    return color.Alpha{0}\n}\n\n    draw.DrawMask(dst, dst.Bounds(), src, image.ZP, \u0026amp;circle{p, r}, image.ZP, draw.Over)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2e.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"drawing-font-glyphs\"\u003eDrawing Font Glyphs\u003c/h2\u003e\n\u003cp\u003eTo draw a font glyph in blue starting from a point \u003ccode\u003ep\u003c/code\u003e,\ndraw with an \u003ccode\u003eimage.ColorImage\u003c/code\u003e source and an \u003ccode\u003eimage.Alpha mask\u003c/code\u003e.\nFor simplicity, we aren’t performing any sub-pixel positioning or rendering,\nor correcting for a font’s height above a baseline.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esrc := \u0026amp;image.Uniform{color.RGBA{0, 0, 255, 255}}\nmask := theGlyphImageForAFont()\nmr := theBoundsFor(glyphIndex)\ndraw.DrawMask(dst, mr.Sub(mr.Min).Add(p), src, image.ZP, mask, mr.Min, draw.Over)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"image-draw/2f.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\n\u003cp\u003eThe image/draw package implementation demonstrates how to provide an image\nmanipulation function that is both general purpose,\nyet efficient for common cases.\nThe \u003ccode\u003eDrawMask\u003c/code\u003e function takes arguments of interface types,\nbut immediately makes type assertions that its arguments are of specific struct types,\ncorresponding to common operations like drawing one \u003ccode\u003eimage.RGBA\u003c/code\u003e image onto another,\nor drawing an \u003ccode\u003eimage.Alpha\u003c/code\u003e mask (such as a font glyph) onto an \u003ccode\u003eimage.RGBA\u003c/code\u003e image.\nIf a type assertion succeeds, that type information is used to run a specialized\nimplementation of the general algorithm.\nIf the assertions fail, the fallback code path uses the generic \u003ccode\u003eAt\u003c/code\u003e and \u003ccode\u003eSet\u003c/code\u003e methods.\nThe fast-paths are purely a performance optimization;\nthe resultant destination image is the same either way.\nIn practice, only a small number of special cases are necessary to support\ntypical applications.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-09-29T00:00:00Z",
  "Author": "Nigel Tao"
}