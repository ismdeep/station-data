{
  "Source": "go.dev",
  "Title": "Inside the Go Playground",
  "Link": "https://go.dev/blog/playground",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/playground\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eInside the Go Playground\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      12 December 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e\u003cem\u003eNOTE: This article does not describe the current version of the Go Playground.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eIn September 2010 we \u003ca href=\"/blog/introducing-go-playground\"\u003eintroduced the Go Playground\u003c/a\u003e,\na web service that compiles and executes arbitrary Go code and returns the\nprogram output.\u003c/p\u003e\n\u003cp\u003eIf you’re a Go programmer then you have probably already used the playground\nby using the \u003ca href=\"/play/\"\u003eGo Playground\u003c/a\u003e directly,\ntaking the \u003ca href=\"/tour/\"\u003eGo Tour\u003c/a\u003e,\nor running \u003ca href=\"/pkg/strings/#pkg-examples\"\u003eexecutable examples\u003c/a\u003e\nfrom the Go documentation.\u003c/p\u003e\n\u003cp\u003eYou may also have used it by clicking one of the “Run” buttons in a slide\ndeck on \u003ca href=\"/talks/\"\u003ego.dev/talks\u003c/a\u003e or a post on this\nvery blog\n(such as the \u003ca href=\"/blog/strings\"\u003erecent article on Strings\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eIn this article we will take a look at how the playground is implemented\nand integrated with these services.\nThe implementation involves a variant operating system environment and runtime\nand our description here assumes you have some familiarity with systems\nprogramming using Go.\u003c/p\u003e\n\u003ch2 id=\"overview\"\u003eOverview\u003c/h2\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"playground/overview.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe playground service has three parts:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA back end that runs on Google’s servers.\nIt receives RPC requests, compiles the user program using the gc tool chain,\nexecutes the user program, and returns the program output (or compilation\nerrors) as the RPC response.\u003c/li\u003e\n\u003cli\u003eA front end that runs on \u003ca href=\"https://cloud.google.com/appengine/docs/go/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle App Engine\u003c/a\u003e.\nIt receives HTTP requests from the client and makes corresponding RPC requests to the back end.\nIt also does some caching.\u003c/li\u003e\n\u003cli\u003eA JavaScript client that implements the user interface and makes HTTP requests to the front end.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"the-back-end\"\u003eThe back end\u003c/h2\u003e\n\u003cp\u003eThe back end program itself is trivial, so we won’t discuss its implementation\nhere. The interesting part is how we safely execute arbitrary user code in a\nsecure environment while still providing core functionality such as time, the\nnetwork, and the file system.\u003c/p\u003e\n\u003cp\u003eTo isolate user programs from Google’s infrastructure, the back end runs\nthem under \u003ca href=\"https://developers.google.com/native-client/\" rel=\"noreferrer\" target=\"_blank\"\u003eNative Client\u003c/a\u003e\n(or “NaCl”), a technology developed by Google to permit the safe execution of\nx86 programs inside web browsers. The back end uses a special version of the gc\ntool chain that generates NaCl executables.\u003c/p\u003e\n\u003cp\u003e(This special tool chain was merged into Go 1.3.\nTo learn more, read the \u003ca href=\"/s/go13nacl\"\u003edesign document\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eNaCl limits the amount of CPU and RAM a program may consume, and it prevents\nprograms from accessing the network or file system.\nThis presents a problem, however.\nGo’s concurrency and networking support are among its key strengths,\nand access to the file system is vital for many programs.\nTo demonstrate concurrency effectively we need time, and to demonstrate\nnetworking and the file system we obviously need a network and a file system.\u003c/p\u003e\n\u003cp\u003eAlthough all these things are supported today, the first version of the\nplayground, launched in 2010, had none of them.\nThe current time was fixed at 10 November 2009, \u003ccode\u003etime.Sleep\u003c/code\u003e had no effect,\nand most functions of the \u003ccode\u003eos\u003c/code\u003e and \u003ccode\u003enet\u003c/code\u003e packages were stubbed out to\nreturn an \u003ccode\u003eEINVALID\u003c/code\u003e error.\u003c/p\u003e\n\u003cp\u003eA year ago we\n\u003ca href=\"https://groups.google.com/d/msg/golang-nuts/JBsCrDEVyVE/30MaQsiQcWoJ\" rel=\"noreferrer\" target=\"_blank\"\u003eimplemented fake time\u003c/a\u003e\nin the playground, so that programs that sleep would behave correctly.\nA more recent update to the playground introduced a fake network stack and a\nfake file system, making the playground’s tool chain similar to a normal\nGo tool chain.\nThese facilities are described in the following sections.\u003c/p\u003e\n\u003ch3 id=\"faking-time\"\u003eFaking time\u003c/h3\u003e\n\u003cp\u003ePlayground programs are limited in the amount of CPU time and memory they can\nuse, but they are also restricted in how much real time they can use.\nThis is because each running program consumes resources on the back end\nand any stateful infrastructure between it and the client.\nLimiting the run time of each playground program makes our service more\npredictable and defends us against denial of service attacks.\u003c/p\u003e\n\u003cp\u003eBut these restrictions become stifling when running code that uses time.\nThe \u003ca href=\"/talks/2012/concurrency.slide\"\u003eGo Concurrency Patterns\u003c/a\u003e\ntalk demonstrates concurrency with examples that use timing functions like\n\u003ca href=\"/pkg/time/#Sleep\"\u003e\u003ccode\u003etime.Sleep\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/time/#After\"\u003e\u003ccode\u003etime.After\u003c/code\u003e\u003c/a\u003e.\nWhen run under early versions of the playground, these programs’ sleeps would\nhave no effect and their behavior would be strange (and sometimes wrong).\u003c/p\u003e\n\u003cp\u003eBy using a clever trick we can make a Go program \u003cem\u003ethink\u003c/em\u003e that it is sleeping,\nwhen really the sleeps take no time at all.\nTo explain the trick we first need to understand how the scheduler manages\nsleeping goroutines.\u003c/p\u003e\n\u003cp\u003eWhen a goroutine calls \u003ccode\u003etime.Sleep\u003c/code\u003e (or similar) the scheduler adds a timer to\na heap of pending timers and puts the goroutine to sleep.\nMeanwhile, a special timer goroutine manages that heap.\nWhen the timer goroutine starts it tells the scheduler to wake\nit when the next pending timer is ready to fire and then sleeps.\nWhen it wakes up it checks which timers have expired, wakes the appropriate\ngoroutines, and goes back to sleep.\u003c/p\u003e\n\u003cp\u003eThe trick is to change the condition that wakes the timer goroutine.\nInstead of waking it after a specific time period, we modify the scheduler to\nwait for a deadlock; the state where all goroutines are blocked.\u003c/p\u003e\n\u003cp\u003eThe playground version of the runtime maintains its own internal clock. When\nthe modified scheduler detects a deadlock it checks whether any timers are\npending. If so, it advances the internal clock to the trigger time of the\nearliest timer and then wakes the timer goroutine. Execution continues and the\nprogram believes that time has passed, when in fact the sleep was nearly\ninstantaneous.\u003c/p\u003e\n\u003cp\u003eThese changes to the scheduler can be found in \u003ca href=\"/cl/73110043\"\u003e\u003ccode\u003eproc.c\u003c/code\u003e\u003c/a\u003e\nand \u003ca href=\"/cl/73110043\"\u003e\u003ccode\u003etime.goc\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFake time fixes the issue of resource exhaustion on the back end, but what\nabout the program output? It would be odd to see a program that sleeps run to\ncompletion correctly without taking any time.\u003c/p\u003e\n\u003cp\u003eThe following program prints the current time each second and then exits after\nthree seconds. Try running it.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;time\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    stop := time.After(3 * time.Second)\n    tick := time.NewTicker(1 * time.Second)\n    defer tick.Stop()\n    for {\n        select {\n        case \u0026lt;-tick.C:\n            fmt.Println(time.Now())\n        case \u0026lt;-stop:\n            return\n        }\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eHow does this work? It is a collaboration between the back end, front end, and client.\u003c/p\u003e\n\u003cp\u003eWe capture the timing of each write to standard output and standard error and\nprovide it to the client. Then the client can “play back” the writes with the\ncorrect timing, so that the output appears just as if the program were running\nlocally.\u003c/p\u003e\n\u003cp\u003eThe playground’s \u003ccode\u003eruntime\u003c/code\u003e package provides a special\n\u003ca href=\"https://github.com/golang/go/blob/go1.3/src/pkg/runtime/sys_nacl_amd64p32.s#L54\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ewrite\u003c/code\u003e function\u003c/a\u003e\nthat includes a small “playback header” before each write.\nThe playback header comprises a magic string, the current time, and the\nlength of the write data. A write with a playback header has this structure:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0 0 P B \u0026lt;8-byte time\u0026gt; \u0026lt;4-byte data length\u0026gt; \u0026lt;data\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe raw output of the program above looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\\x00\\x00PB\\x11\\x74\\xef\\xed\\xe6\\xb3\\x2a\\x00\\x00\\x00\\x00\\x1e2009-11-10 23:00:01 +0000 UTC\n\\x00\\x00PB\\x11\\x74\\xef\\xee\\x22\\x4d\\xf4\\x00\\x00\\x00\\x00\\x1e2009-11-10 23:00:02 +0000 UTC\n\\x00\\x00PB\\x11\\x74\\xef\\xee\\x5d\\xe8\\xbe\\x00\\x00\\x00\\x00\\x1e2009-11-10 23:00:03 +0000 UTC\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe front end parses this output as a series of events\nand returns a list of events to the client as a JSON object:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e{\n    \u0026#34;Errors\u0026#34;: \u0026#34;\u0026#34;,\n    \u0026#34;Events\u0026#34;: [\n        {\n            \u0026#34;Delay\u0026#34;: 1000000000,\n            \u0026#34;Message\u0026#34;: \u0026#34;2009-11-10 23:00:01 +0000 UTC\\n\u0026#34;\n        },\n        {\n            \u0026#34;Delay\u0026#34;: 1000000000,\n            \u0026#34;Message\u0026#34;: \u0026#34;2009-11-10 23:00:02 +0000 UTC\\n\u0026#34;\n        },\n        {\n            \u0026#34;Delay\u0026#34;: 1000000000,\n            \u0026#34;Message\u0026#34;: \u0026#34;2009-11-10 23:00:03 +0000 UTC\\n\u0026#34;\n        }\n    ]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe JavaScript client (running in the user’s web browser) then plays back the\nevents using the provided delay intervals.\nTo the user it appears that the program is running in real time.\u003c/p\u003e\n\u003ch3 id=\"faking-the-file-system\"\u003eFaking the file system\u003c/h3\u003e\n\u003cp\u003ePrograms built with the Go’s NaCl tool chain cannot access the local machine’s\nfile system. Instead, the \u003ccode\u003esyscall\u003c/code\u003e package’s file-related functions\n(\u003ccode\u003eOpen\u003c/code\u003e, \u003ccode\u003eRead\u003c/code\u003e, \u003ccode\u003eWrite\u003c/code\u003e, and so on) operate on an in-memory file system\nthat is implemented by the \u003ccode\u003esyscall\u003c/code\u003e package itself.\nSince package \u003ccode\u003esyscall\u003c/code\u003e is the interface between the Go code and the operating\nsystem kernel, user programs see the file system exactly the same way as they\nwould a real one.\u003c/p\u003e\n\u003cp\u003eThe following example program writes data to a file, and then copies\nits contents to standard output. Try running it. (You can edit it, too!)\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;io/ioutil\u0026#34;\n    \u0026#34;log\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    const filename = \u0026#34;/tmp/file.txt\u0026#34;\n\n    err := ioutil.WriteFile(filename, []byte(\u0026#34;Hello, file system\\n\u0026#34;), 0644)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    b, err := ioutil.ReadFile(filename)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    fmt.Printf(\u0026#34;%s\u0026#34;, b)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eWhen a process starts, the file system is populated with some devices under\n\u003ccode\u003e/dev\u003c/code\u003e and an empty \u003ccode\u003e/tmp\u003c/code\u003e directory. The program can manipulate the file\nsystem as usual, but when the process exits any changes to the file system are\nlost.\u003c/p\u003e\n\u003cp\u003eThere is also a provision to load a zip file into the file system at init time\n(see \u003ca href=\"https://github.com/golang/go/blob/go1.3/src/pkg/syscall/unzip_nacl.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eunzip_nacl.go\u003c/code\u003e\u003c/a\u003e).\nSo far we have only used the unzip facility to provide the data files required\nto run the standard library tests, but we intend to provide playground programs\nwith a set of files that can be used in documentation examples, blog posts, and\nthe Go Tour.\u003c/p\u003e\n\u003cp\u003eThe implementation can be found in the\n\u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fs_nacl.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efs_nacl.go\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fd_nacl.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efd_nacl.go\u003c/code\u003e\u003c/a\u003e files\n(which, by virtue of their \u003ccode\u003e_nacl\u003c/code\u003e suffix, are built into package \u003ccode\u003esyscall\u003c/code\u003e only\nwhen \u003ccode\u003eGOOS\u003c/code\u003e is set to \u003ccode\u003enacl\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eThe file system itself is represented by the\n\u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fs_nacl.go#L26\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efsys\u003c/code\u003e struct\u003c/a\u003e,\nof which a global instance (named \u003ccode\u003efs\u003c/code\u003e) is created during init time.\nThe various file-related functions then operate on \u003ccode\u003efs\u003c/code\u003e instead of making the\nactual system call.\nFor instance, here is the \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fs_nacl.go#L473\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003esyscall.Open\u003c/code\u003e\u003c/a\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Open(path string, openmode int, perm uint32) (fd int, err error) {\n    fs.mu.Lock()\n    defer fs.mu.Unlock()\n    f, err := fs.open(path, openmode, perm\u0026amp;0777|S_IFREG)\n    if err != nil {\n        return -1, err\n    }\n    return newFD(f), nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFile descriptors are tracked by a global slice named\n\u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fd_nacl.go#L17\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efiles\u003c/code\u003e\u003c/a\u003e.\nEach file descriptor corresponds to a \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fd_nacl.go#L23\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efile\u003c/code\u003e\u003c/a\u003e\nand each \u003ccode\u003efile\u003c/code\u003e provides a value that implements the \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fd_nacl.go#L30\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efileImpl\u003c/code\u003e\u003c/a\u003e interface.\nThere are several implementations of the interface:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eregular files and devices (such as \u003ccode\u003e/dev/random\u003c/code\u003e) are represented by \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fs_nacl.go#L58\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efsysFile\u003c/code\u003e\u003c/a\u003e,\u003c/li\u003e\n\u003cli\u003estandard input, output, and error are instances of \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/fd_nacl.go#L216\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003enaclFile\u003c/code\u003e\u003c/a\u003e,\nwhich uses system calls to interact with the actual files (these are a playground\nprogram’s only way to interact with the outside world),\u003c/li\u003e\n\u003cli\u003enetwork sockets have their own implementation, discussed in the next section.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"faking-the-network\"\u003eFaking the network\u003c/h3\u003e\n\u003cp\u003eLike the file system, the playground’s network stack is an in-process fake\nimplemented by the \u003ccode\u003esyscall\u003c/code\u003e package. It permits playground projects to use\nthe loopback interface (\u003ccode\u003e127.0.0.1\u003c/code\u003e). Requests to other hosts will fail.\u003c/p\u003e\n\u003cp\u003eFor an executable example, run the following program. It listens on a TCP port,\nwaits for an incoming connection, copies the data from that connection to\nstandard output, and exits. In another goroutine, it makes a connection to the\nlistening port, writes a string to the connection, and closes it.\u003c/p\u003e\n\u003cdiv class=\"playground\"\u003e\n\u003cpre style=\"display: none\"\u003e\u003cspan\u003e\npackage main\n\nimport (\n    \u0026#34;io\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;net\u0026#34;\n    \u0026#34;os\u0026#34;\n)\n\n\u003c/span\u003e\n\u003c/pre\u003e\n\u003cpre contenteditable=\"true\" spellcheck=\"false\"\u003efunc main() {\n    l, err := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:4000\u0026#34;)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer l.Close()\n\n    go dial()\n\n    c, err := l.Accept()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer c.Close()\n\n    io.Copy(os.Stdout, c)\n}\n\nfunc dial() {\n    c, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;127.0.0.1:4000\u0026#34;)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer c.Close()\n    c.Write([]byte(\u0026#34;Hello, network\\n\u0026#34;))\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe interface to the network is more complex than the one for files, so the\nimplementation of the fake network is larger and more complex than the fake\nfile system. It must simulate read and write timeouts, different address types\nand protocols, and so on.\u003c/p\u003e\n\u003cp\u003eThe implementation can be found in \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/net_nacl.go\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003enet_nacl.go\u003c/code\u003e\u003c/a\u003e.\nA good place to start reading is \u003ca href=\"https://github.com/golang/go/blob/2197321db1dd997165c0091ba2bcb3b6be7633d0/src/syscall/net_nacl.go#L461\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003enetFile\u003c/code\u003e\u003c/a\u003e,\nthe network socket implementation of the \u003ccode\u003efileImpl\u003c/code\u003e interface.\u003c/p\u003e\n\u003ch2 id=\"the-front-end\"\u003eThe front end\u003c/h2\u003e\n\u003cp\u003eThe playground front end is another simple program (shorter than 100 lines).\nIt receives HTTP requests from the client, makes RPC requests to the back end,\nand does some caching.\u003c/p\u003e\n\u003cp\u003eThe front end serves an HTTP handler at \u003ccode\u003ehttps://golang.org/compile\u003c/code\u003e.\nThe handler expects a POST request with a \u003ccode\u003ebody\u003c/code\u003e field\n(the Go program to run) and an optional \u003ccode\u003eversion\u003c/code\u003e field\n(for most clients this should be \u003ccode\u003e\u0026#34;2\u0026#34;\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eWhen the front end receives a compilation request it first checks\n\u003ca href=\"https://developers.google.com/appengine/docs/memcache/\" rel=\"noreferrer\" target=\"_blank\"\u003ememcache\u003c/a\u003e\nto see if it has cached the results of a previous compilation of that source.\nIf found, it returns the cached response.\nThe cache prevents popular programs such as those on the\n\u003ca href=\"/\"\u003eGo home page\u003c/a\u003e from overloading the back ends.\nIf there is no cached response, the front end makes an RPC request to the back\nend, stores the response in memcache, parses the playback events, and returns\na JSON object to the client as the HTTP response (as described above).\u003c/p\u003e\n\u003ch2 id=\"the-client\"\u003eThe client\u003c/h2\u003e\n\u003cp\u003eThe various sites that use the playground each share some common JavaScript\ncode for setting up the user interface (the code and output boxes, the run\nbutton, and so on) and communicating with the playground front end.\u003c/p\u003e\n\u003cp\u003eThis implementation is in the file\n\u003ca href=\"https://github.com/golang/tools/blob/f8e922be8efeabd06a510065ca5836b62fa10b9a/godoc/static/playground.js\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eplayground.js\u003c/code\u003e\u003c/a\u003e\nin the \u003ccode\u003ego.tools\u003c/code\u003e repository, which can be imported from the\n\u003ca href=\"https://godoc.org/golang.org/x/tools/godoc/static\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/tools/godoc/static\u003c/code\u003e\u003c/a\u003e package.\nSome of it is clean and some is a bit crufty, as it is the result of\nconsolidating several divergent implementations of the client code.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://github.com/golang/tools/blob/f8e922be8efeabd06a510065ca5836b62fa10b9a/godoc/static/playground.js#L227\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eplayground\u003c/code\u003e\u003c/a\u003e\nfunction takes some HTML elements and turns them into an interactive\nplayground widget. You should use this function if you want to put the\nplayground on your own site (see ‘Other clients’ below).\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"https://github.com/golang/tools/blob/f8e922be8efeabd06a510065ca5836b62fa10b9a/godoc/static/playground.js#L6\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eTransport\u003c/code\u003e\u003c/a\u003e\ninterface (not formally defined, this being JavaScript)\nabstracts the user interface from the means of talking to the web front end.\n\u003ca href=\"https://github.com/golang/tools/blob/f8e922be8efeabd06a510065ca5836b62fa10b9a/godoc/static/playground.js#L43\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eHTTPTransport\u003c/code\u003e\u003c/a\u003e\nis an implementation of \u003ccode\u003eTransport\u003c/code\u003e that speaks the HTTP-based protocol\ndescribed earlier.\n\u003ca href=\"https://github.com/golang/tools/blob/f8e922be8efeabd06a510065ca5836b62fa10b9a/godoc/static/playground.js#L115\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSocketTransport\u003c/code\u003e\u003c/a\u003e\nis another implementation that speaks WebSocket (see ‘Playing offline’ below).\u003c/p\u003e\n\u003cp\u003eTo comply with the \u003ca href=\"https://en.wikipedia.org/wiki/Same-origin_policy\" rel=\"noreferrer\" target=\"_blank\"\u003esame-origin policy\u003c/a\u003e,\nthe various web servers (godoc, for instance) proxy requests to\n\u003ccode\u003e/compile\u003c/code\u003e through to the playground service at \u003ccode\u003ehttps://golang.org/compile\u003c/code\u003e.\nThe common \u003ca href=\"https://godoc.org/golang.org/x/tools/playground\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/tools/playground\u003c/code\u003e\u003c/a\u003e\npackage does this proxying.\u003c/p\u003e\n\u003ch2 id=\"playing-offline\"\u003ePlaying offline\u003c/h2\u003e\n\u003cp\u003eBoth the \u003ca href=\"/tour/\"\u003eGo Tour\u003c/a\u003e and the\n\u003ca href=\"https://godoc.org/golang.org/x/tools/present\" rel=\"noreferrer\" target=\"_blank\"\u003ePresent Tool\u003c/a\u003e can be\nrun offline. This is great for people with limited internet connectivity\nor presenters at conferences who cannot (and \u003cem\u003eshould\u003c/em\u003e not) rely on a working\ninternet connection.\u003c/p\u003e\n\u003cp\u003eTo run offline, the tools run their own version of the playground back end on\nthe local machine. The back end uses a regular Go tool chain with none of the\naforementioned modifications and uses a WebSocket to communicate with the\nclient.\u003c/p\u003e\n\u003cp\u003eThe WebSocket back end implementation can be found in the\n\u003ca href=\"https://godoc.org/golang.org/x/tools/playground/socket\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/tools/playground/socket\u003c/code\u003e\u003c/a\u003e package.\nThe \u003ca href=\"/talks/2012/insidepresent.slide#1\"\u003eInside Present\u003c/a\u003e talk discusses this code in detail.\u003c/p\u003e\n\u003ch2 id=\"other-clients\"\u003eOther clients\u003c/h2\u003e\n\u003cp\u003eThe playground service is used by more than just the official Go project\n(\u003ca href=\"https://gobyexample.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eGo by Example\u003c/a\u003e is one other instance)\nand we are happy for you to use it on your own site. All we ask is that\nyou \u003ca href=\"mailto:golang-dev@googlegroups.com\"\u003econtact us first\u003c/a\u003e,\nuse a unique user agent in your requests (so we can identify you), and that\nyour service is of benefit to the Go community.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eFrom godoc to the tour to this very blog, the playground has become an\nessential part of our Go documentation story. With the recent additions\nof the fake file system and network stack we are excited to expand\nour learning materials to cover those areas.\u003c/p\u003e\n\u003cp\u003eBut, ultimately, the playground is just the tip of the iceberg.\nWith Native Client support scheduled for Go 1.3,\nwe look forward to seeing what the community can do with it.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThis article is part 12 of the\u003c/em\u003e\n\u003ca href=\"https://blog.gopheracademy.com/go-advent-2013\" rel=\"noreferrer\" target=\"_blank\"\u003eGo Advent Calendar\u003c/a\u003e,\n\u003cem\u003ea series of daily blog posts throughout December .\u003c/em\u003e\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-12-12T00:00:00Z",
  "Author": "Andrew Gerrand"
}