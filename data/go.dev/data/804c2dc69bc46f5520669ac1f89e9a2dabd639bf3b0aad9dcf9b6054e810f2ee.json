{
  "Source": "go.dev",
  "Title": "Contexts and structs",
  "Link": "https://go.dev/blog/context-and-structs",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/context-and-structs\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eContexts and structs\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jean de Klerk, Matt T. Proud\u003cbr/\u003e\n      24 February 2021\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn many Go APIs, especially modern ones, the first argument to functions and methods is often \u003ca href=\"/pkg/context/\"\u003e\u003ccode\u003econtext.Context\u003c/code\u003e\u003c/a\u003e. Context provides a means of transmitting deadlines, caller cancellations, and other request-scoped values across API boundaries and between processes. It is often used when a library interacts — directly or transitively — with remote servers, such as databases, APIs, and the like.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/context/\"\u003edocumentation for context\u003c/a\u003e states:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eContexts should not be stored inside a struct type, but instead passed to each function that needs it.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis article expands on that advice with reasons and examples describing why it’s important to pass Context rather than store it in another type. It also highlights a rare case where storing Context in a struct type may make sense, and how to do so safely.\u003c/p\u003e\n\u003ch2 id=\"prefer-contexts-passed-as-arguments\"\u003ePrefer contexts passed as arguments\u003c/h2\u003e\n\u003cp\u003eTo understand the advice to not store context in structs, let’s consider the preferred context-as-argument approach:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Worker fetches and adds works to a remote work orchestration server.\ntype Worker struct { /* … */ }\n\ntype Work struct { /* … */ }\n\nfunc New() *Worker {\n  return \u0026amp;Worker{}\n}\n\nfunc (w *Worker) Fetch(ctx context.Context) (*Work, error) {\n  _ = ctx // A per-call ctx is used for cancellation, deadlines, and metadata.\n}\n\nfunc (w *Worker) Process(ctx context.Context, work *Work) error {\n  _ = ctx // A per-call ctx is used for cancellation, deadlines, and metadata.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, the \u003ccode\u003e(*Worker).Fetch\u003c/code\u003e and \u003ccode\u003e(*Worker).Process\u003c/code\u003e methods both accept a context directly. With this pass-as-argument design, users can set per-call deadlines, cancellation, and metadata. And, it’s clear how the \u003ccode\u003econtext.Context\u003c/code\u003e passed to each method will be used: there’s no expectation that a \u003ccode\u003econtext.Context\u003c/code\u003e passed to one method will be used by any other method. This is because the context is scoped to as small an operation as it needs to be, which greatly increases the utility and clarity of \u003ccode\u003econtext\u003c/code\u003e in this package.\u003c/p\u003e\n\u003ch2 id=\"storing-context-in-structs-leads-to-confusion\"\u003eStoring context in structs leads to confusion\u003c/h2\u003e\n\u003cp\u003eLet’s inspect again the \u003ccode\u003eWorker\u003c/code\u003e example above with the disfavored context-in-struct approach. The problem with it is that when you store the context in a struct, you obscure lifetime to the callers, or worse intermingle two scopes together in unpredictable ways:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Worker struct {\n  ctx context.Context\n}\n\nfunc New(ctx context.Context) *Worker {\n  return \u0026amp;Worker{ctx: ctx}\n}\n\nfunc (w *Worker) Fetch() (*Work, error) {\n  _ = w.ctx // A shared w.ctx is used for cancellation, deadlines, and metadata.\n}\n\nfunc (w *Worker) Process(work *Work) error {\n  _ = w.ctx // A shared w.ctx is used for cancellation, deadlines, and metadata.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e(*Worker).Fetch\u003c/code\u003e and \u003ccode\u003e(*Worker).Process\u003c/code\u003e method both use a context stored in Worker. This prevents the callers of Fetch and Process (which may themselves have different contexts) from specifying a deadline, requesting cancellation, and attaching metadata on a per-call basis. For example: the user is unable to provide a deadline just for \u003ccode\u003e(*Worker).Fetch\u003c/code\u003e, or cancel just the \u003ccode\u003e(*Worker).Process\u003c/code\u003e call. The caller’s lifetime is intermingled with a shared context, and the context is scoped to the lifetime where the \u003ccode\u003eWorker\u003c/code\u003e is created.\u003c/p\u003e\n\u003cp\u003eThe API is also much more confusing to users compared to the pass-as-argument approach. Users might ask themselves:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSince \u003ccode\u003eNew\u003c/code\u003e takes a \u003ccode\u003econtext.Context\u003c/code\u003e, is the constructor doing work that needs cancellation or deadlines?\u003c/li\u003e\n\u003cli\u003eDoes the \u003ccode\u003econtext.Context\u003c/code\u003e passed in to \u003ccode\u003eNew\u003c/code\u003e apply to work in \u003ccode\u003e(*Worker).Fetch\u003c/code\u003e and \u003ccode\u003e(*Worker).Process\u003c/code\u003e? Neither? One but not the other?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe API would need a good deal of documentation to explicitly tell the user exactly what the \u003ccode\u003econtext.Context\u003c/code\u003e is used for. The user might also have to read code rather than being able to rely on the structure of the API conveys.\u003c/p\u003e\n\u003cp\u003eAnd, finally, it can be quite dangerous to design a production-grade server whose requests don’t each have a context and thus can’t adequately honor cancellation. Without the ability to set per-call deadlines, \u003ca href=\"https://sre.google/sre-book/handling-overload/\" rel=\"noreferrer\" target=\"_blank\"\u003eyour process could backlog\u003c/a\u003e and exhaust its resources (like memory)!\u003c/p\u003e\n\u003ch2 id=\"exception-to-the-rule-preserving-backwards-compatibility\"\u003eException to the rule: preserving backwards compatibility\u003c/h2\u003e\n\u003cp\u003eWhen Go 1.7 — which \u003ca href=\"/doc/go1.7\"\u003eintroduced context.Context\u003c/a\u003e — was released, a large number of APIs had to add context support in backwards compatible ways. For example, \u003ca href=\"/pkg/net/http/\"\u003e\u003ccode\u003enet/http\u003c/code\u003e’s \u003ccode\u003eClient\u003c/code\u003e methods\u003c/a\u003e, like \u003ccode\u003eGet\u003c/code\u003e and \u003ccode\u003eDo\u003c/code\u003e, were excellent candidates for context. Each external request sent with these methods would benefit from having the deadline, cancellation, and metadata support that came with \u003ccode\u003econtext.Context\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere are two approaches for adding support for \u003ccode\u003econtext.Context\u003c/code\u003e in backwards compatible ways: including a context in a struct, as we’ll see in a moment, and duplicating functions, with duplicates accepting \u003ccode\u003econtext.Context\u003c/code\u003e and having \u003ccode\u003eContext\u003c/code\u003e as their function name suffix. The duplicate approach should be preferred over the context-in-struct, and is further discussed in \u003ca href=\"/blog/module-compatibility\"\u003eKeeping your modules compatible\u003c/a\u003e. However, in some cases it’s impractical: for example, if your API exposes a large number of functions, then duplicating them all might be infeasible.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003enet/http\u003c/code\u003e package chose the context-in-struct approach, which provides a useful case study. Let’s look at \u003ccode\u003enet/http\u003c/code\u003e’s \u003ccode\u003eDo\u003c/code\u003e. Prior to the introduction of \u003ccode\u003econtext.Context\u003c/code\u003e, \u003ccode\u003eDo\u003c/code\u003e was defined as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Do sends an HTTP request and returns an HTTP response [...]\nfunc (c *Client) Do(req *Request) (*Response, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter Go 1.7, \u003ccode\u003eDo\u003c/code\u003e might have looked like the following, if not for the fact that it would break backwards compatibility:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Do sends an HTTP request and returns an HTTP response [...]\nfunc (c *Client) Do(ctx context.Context, req *Request) (*Response, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut, preserving the backwards compatibility and adhering to the \u003ca href=\"/doc/go1compat\"\u003eGo 1 promise of compatibility\u003c/a\u003e is crucial for the standard library. So, instead, the maintainers chose to add a \u003ccode\u003econtext.Context\u003c/code\u003e on the \u003ccode\u003ehttp.Request\u003c/code\u003e struct in order to allow support \u003ccode\u003econtext.Context\u003c/code\u003e without breaking backwards compatibility:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// A Request represents an HTTP request received by a server or to be sent by a client.\n// ...\ntype Request struct {\n  ctx context.Context\n\n  // ...\n}\n\n// NewRequestWithContext returns a new Request given a method, URL, and optional\n// body.\n// [...]\n// The given ctx is used for the lifetime of the Request.\nfunc NewRequestWithContext(ctx context.Context, method, url string, body io.Reader) (*Request, error) {\n  // Simplified for brevity of this article.\n  return \u0026amp;Request{\n    ctx: ctx,\n    // ...\n  }\n}\n\n// Do sends an HTTP request and returns an HTTP response [...]\nfunc (c *Client) Do(req *Request) (*Response, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen retrofitting your API to support context, it may make sense to add a \u003ccode\u003econtext.Context\u003c/code\u003e to a struct, as above. However, remember to first consider duplicating your functions, which allows retrofitting \u003ccode\u003econtext.Context\u003c/code\u003e in a backwards compatibility without sacrificing utility and comprehension. For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Call uses context.Background internally; to specify the context, use\n// CallContext.\nfunc (c *Client) Call() error {\n  return c.CallContext(context.Background())\n}\n\nfunc (c *Client) CallContext(ctx context.Context) error {\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eContext makes it easy to propagate important cross-library and cross-API information down a calling stack. But, it must be used consistently and clearly in order to remain comprehensible, easy to debug, and effective.\u003c/p\u003e\n\u003cp\u003eWhen passed as the first argument in a method rather than stored in a struct type, users can take full advantage of its extensibility in order to build a powerful tree of cancellation, deadline, and metadata information through the call stack. And, best of all, its scope is clearly understood when it’s passed in as an argument, leading to clear comprehension and debuggability up and down the stack.\u003c/p\u003e\n\u003cp\u003eWhen designing an API with context, remember the advice: pass \u003ccode\u003econtext.Context\u003c/code\u003e in as an argument; don’t store it in structs.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-02-24T00:00:00Z",
  "Author": "Jean de Klerk, Matt T. Proud"
}