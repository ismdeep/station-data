{
  "Source": "go.dev",
  "Title": "JSON-RPC: a tale of interfaces",
  "Link": "https://go.dev/blog/json-rpc",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/json-rpc\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eJSON-RPC: a tale of interfaces\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      27 April 2010\n      \u003c/p\u003e\n      \n      \u003cp\u003eHere we present an example where Go’s \u003ca href=\"/doc/effective_go.html#interfaces_and_types\"\u003einterfaces\u003c/a\u003e\nmade it easy to refactor some existing code to make it more flexible and extensible.\nOriginally, the standard library’s \u003ca href=\"/pkg/net/rpc/\"\u003eRPC package\u003c/a\u003e\nused a custom wire format called \u003ca href=\"/pkg/encoding/gob/\"\u003egob\u003c/a\u003e.\nFor a particular application, we wanted to use \u003ca href=\"/pkg/encoding/json/\"\u003eJSON\u003c/a\u003e\nas an alternate wire format.\u003c/p\u003e\n\u003cp\u003eWe first defined a pair of interfaces to describe the functionality of the\nexisting wire format,\none for the client, and one for the server (depicted below).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype ServerCodec interface {\n ReadRequestHeader(*Request) error\n ReadRequestBody(interface{}) error\n WriteResponse(*Response, interface{}) error\n Close() error\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn the server side, we then changed two internal function signatures to\naccept the \u003ccode\u003eServerCodec\u003c/code\u003e interface instead of our existing \u003ccode\u003egob.Encoder\u003c/code\u003e. Here’s one of them:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc sendResponse(sending *sync.Mutex, req *Request,\n reply interface{}, enc *gob.Encoder, errmsg string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebecame\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc sendResponse(sending *sync.Mutex, req *Request,\n  reply interface{}, enc ServerCodec, errmsg string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe then wrote a trivial \u003ccode\u003egobServerCodec\u003c/code\u003e wrapper to reproduce the original functionality.\nFrom there it is simple to build a \u003ccode\u003ejsonServerCodec\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAfter some similar changes to the client side,\nthis was the full extent of the work we needed to do on the RPC package.\nThis whole exercise took about 20 minutes!\nAfter tidying up and testing the new code,\nthe \u003ca href=\"https://github.com/golang/go/commit/dcff89057bc0e0d7cb14cf414f2df6f5fb1a41ec\" rel=\"noreferrer\" target=\"_blank\"\u003efinal changeset\u003c/a\u003e was submitted.\u003c/p\u003e\n\u003cp\u003eIn an inheritance-oriented language like Java or C++,\nthe obvious path would be to generalize the RPC class,\nand create JsonRPC and GobRPC subclasses.\nHowever, this approach becomes tricky if you want to make a further generalization\northogonal to that hierarchy.\n(For example, if you were to implement an alternate RPC standard).\nIn our Go package, we took a route that is both conceptually simpler and\nrequires less code be written or changed.\u003c/p\u003e\n\u003cp\u003eA vital quality for any codebase is maintainability.\nAs needs change, it is essential to adapt your code easily and cleanly,\nlest it become unwieldy to work with.\nWe believe Go’s lightweight, composition-oriented type system provides a\nmeans of structuring code that scales.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-04-27T00:00:00Z",
  "Author": "Andrew Gerrand"
}