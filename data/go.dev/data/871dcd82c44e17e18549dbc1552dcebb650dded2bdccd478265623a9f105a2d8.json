{
  "Source": "go.dev",
  "Title": "Language and Locale Matching in Go",
  "Link": "https://go.dev/blog/matchlang",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/matchlang\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eLanguage and Locale Matching in Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Marcel van Lohuizen\u003cbr/\u003e\n      9 February 2016\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eConsider an application, such as a web site, with support for multiple languages\nin its user interface.\nWhen a user arrives with a list of preferred languages, the application must\ndecide which language it should use in its presentation to the user.\nThis requires finding the best match between the languages the application supports\nand those the user prefers.\nThis post explains why this is a difficult decision and how Go can help.\u003c/p\u003e\n\u003ch2 id=\"language-tags\"\u003eLanguage Tags\u003c/h2\u003e\n\u003cp\u003eLanguage tags, also known as locale identifiers, are machine-readable\nidentifiers for the language and/or dialect being used.\nThe most common reference for them is the IETF BCP 47 standard, and that is the\nstandard the Go libraries follow.\nHere are some examples of BCP 47 language tags and the language or dialect they\nrepresent.\u003c/p\u003e\n\u003cstyle\u003e\n    .padtable { padding-left: 40px; }\n    .padtable td, .padtable th { padding-right: 10px; }\n    .tag { font-family: courier; }\n\u003c/style\u003e\n\u003cdiv class=\"padtable\"\u003e\n\u003ctable\u003e\n\u003ctbody\u003e\u003ctr\u003e\n    \u003cth\u003eTag\u003c/th\u003e\n    \u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003een\u003c/td\u003e\n    \u003ctd\u003eEnglish\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003een-US\u003c/td\u003e\n    \u003ctd\u003eAmerican English\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003ecmn\u003c/td\u003e\n    \u003ctd\u003eMandarin Chinese\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003ezh\u003c/td\u003e\n    \u003ctd\u003eChinese, typically Mandarin\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003enl\u003c/td\u003e\n    \u003ctd\u003eDutch\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003enl-BE\u003c/td\u003e\n    \u003ctd\u003eFlemish\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003ees-419\u003c/td\u003e\n    \u003ctd\u003eLatin American Spanish\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003eaz, az-Latn\u003c/td\u003e\n    \u003ctd\u003eboth Azerbaijani written in Latin script\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n    \u003ctd class=\"tag\"\u003eaz-Arab\u003c/td\u003e\n    \u003ctd\u003eAzerbaijani written in Arabic\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003cp\u003eThe general form of the language tag is\na language code (“en”, “cmn”, “zh”, “nl”, “az” above)\nfollowed by an optional subtag for script (“-Arab”),\nregion (“-US”, “-BE”, “-419”),\nvariants (“-oxendict” for Oxford English Dictionary spelling),\nand extensions (“-u-co-phonebk” for phone-book sorting).\nThe most common form is assumed if a subtag is omitted, for instance\n“az-Latn-AZ” for “az”.\u003c/p\u003e\n\u003cp\u003eThe most common use of language tags is to select from a set of system-supported\nlanguages according to a list of the user’s language preferences, for example\ndeciding that a user who prefers Afrikaans would be best served (assuming\nAfrikaans is not available) by the system showing Dutch. Resolving such matches\ninvolves consulting data on mutual language comprehensibility.\u003c/p\u003e\n\u003cp\u003eThe tag resulting from this match is subsequently used to obtain\nlanguage-specific resources such as translations, sorting order,\nand casing algorithms.\nThis involves a different kind of matching. For example, as there is no specific\nsorting order for Portuguese, a collate package may fall back to the sorting\norder for the default, or “root”, language.\u003c/p\u003e\n\u003ch2 id=\"the-messy-nature-of-matching-languages\"\u003eThe Messy Nature of Matching Languages\u003c/h2\u003e\n\u003cp\u003eHandling language tags is tricky.\nThis is partly because the boundaries of human languages are not well defined\nand partly because of the legacy of evolving language tag standards.\nIn this section we will show some of the messy aspects of handling language tags.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eTags with different language codes can indicate the same language\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor historical and political reasons, many language codes have changed over\ntime, leaving languages with an older legacy code as well as a new one.\nBut even two current codes may refer to the same language.\nFor example, the official language code for Mandarin is “cmn”, but “zh” is by\nfar the most commonly used designator for this language.\nThe code “zh” is officially reserved for a so called macro language, identifying\nthe group of Chinese languages.\nTags for macro languages are often used interchangeably with the most-spoken\nlanguage in the group.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eMatching language code alone is not sufficient\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eAzerbaijani (“az”), for example, is written in different scripts depending on\nthe country in which it is spoken: “az-Latn” for Latin (the default script),\n“az-Arab” for Arabic, and “az-Cyrl” for Cyrillic.\nIf you replace “az-Arab” with just “az”, the result will be in Latin script and\nmay not be understandable to a user who only knows the Arabic form.\u003c/p\u003e\n\u003cp\u003eAlso different regions may imply different scripts.\nFor example: “zh-TW” and “zh-SG” respectively imply the use of Traditional and\nSimplified Han. As another example, “sr” (Serbian) defaults to Cyrillic script,\nbut “sr-RU” (Serbian as written in Russia) implies the Latin script!\nA similar thing can be said for Kyrgyz and other languages.\u003c/p\u003e\n\u003cp\u003eIf you ignore subtags, you might as well present Greek to the user.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThe best match might be a language not listed by the user\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe most common written form of Norwegian (“nb”) looks an awful lot like Danish.\nIf Norwegian is not available, Danish may be a good second choice.\nSimilarly, a user requesting Swiss German (“gsw”) will likely be happy to be\npresented German (“de”), though the converse is far from true.\nA user requesting Uygur may be happier to fall back to Chinese than to English.\nOther examples abound.\nIf a user-requested language is not supported, falling back to English is often\nnot the best thing to do.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eThe choice of language decides more than translation\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSuppose a user asks for Danish, with German as a second choice.\nIf an application chooses German, it must not only use German translations\nbut also use German (not Danish) collation.\nOtherwise, for example, a list of animals might sort “Bär” before “Äffin”.\u003c/p\u003e\n\u003cp\u003eSelecting a supported language given the user’s preferred languages is like a\nhandshaking algorithm: first you determine which protocol to communicate in (the\nlanguage) and then you stick with this protocol for all communication for the\nduration of a session.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eUsing a “parent” of a language as fallback is non-trivial\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSuppose your application supports Angolan Portuguese (“pt-AO”).\nPackages in \u003ca href=\"https://golang.org/x/text\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/text\u003c/a\u003e, like collation and display, may not\nhave specific support for this dialect.\nThe correct course of action in such cases is to match the closest parent dialect.\nLanguages are arranged in a hierarchy, with each specific language having a more\ngeneral parent.\nFor example, the parent of “en-GB-oxendict” is “en-GB”, whose parent is “en”,\nwhose parent is the undefined language “und”, also known as the root language.\nIn the case of collation, there is no specific collation order for Portuguese,\nso the collate package will select the sorting order of the root language.\nThe closest parent to Angolan Portuguese supported by the display package is\nEuropean Portuguese (“pt-PT”) and not the more obvious “pt”, which implies\nBrazilian.\u003c/p\u003e\n\u003cp\u003eIn general, parent relationships are non-trivial.\nTo give a few more examples, the parent of “es-CL” is “es-419”, the parent of\n“zh-TW” is “zh-Hant”, and the parent of “zh-Hant” is “und”.\nIf you compute the parent by simply removing subtags, you may select a “dialect”\nthat is incomprehensible to the user.\u003c/p\u003e\n\u003ch2 id=\"language-matching-in-go\"\u003eLanguage Matching in Go\u003c/h2\u003e\n\u003cp\u003eThe Go package \u003ca href=\"https://golang.org/x/text/language\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/text/language\u003c/a\u003e implements the BCP 47\nstandard for language tags and adds support for deciding which language to use\nbased on data published in the Unicode Common Locale Data Repository (CLDR).\u003c/p\u003e\n\u003cp\u003eHere is a sample program, explained below, matching a user’s language\npreferences against an application’s supported languages:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n\n    \u0026#34;golang.org/x/text/language\u0026#34;\n    \u0026#34;golang.org/x/text/language/display\u0026#34;\n)\n\nvar userPrefs = []language.Tag{\n    language.Make(\u0026#34;gsw\u0026#34;), \u003cspan class=\"comment\"\u003e// Swiss German\u003c/span\u003e\n    language.Make(\u0026#34;fr\u0026#34;),  \u003cspan class=\"comment\"\u003e// French\u003c/span\u003e\n}\n\nvar serverLangs = []language.Tag{\n    language.AmericanEnglish, \u003cspan class=\"comment\"\u003e// en-US fallback\u003c/span\u003e\n    language.German,          \u003cspan class=\"comment\"\u003e// de\u003c/span\u003e\n}\n\nvar matcher = language.NewMatcher(serverLangs)\n\nfunc main() {\n    tag, index, confidence := matcher.Match(userPrefs...)\n\n    fmt.Printf(\u0026#34;best match: %s (%s) index=%d confidence=%v\\n\u0026#34;,\n        display.English.Tags().Name(tag),\n        display.Self.Name(tag),\n        index, confidence)\n    \u003cspan class=\"comment\"\u003e// best match: German (Deutsch) index=1 confidence=High\u003c/span\u003e\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch3 id=\"creating-language-tags\"\u003eCreating Language Tags\u003c/h3\u003e\n\u003cp\u003eThe simplest way to create a language.Tag from a user-given language code string\nis with language.Make.\nIt extracts meaningful information even from malformed input.\nFor example, “en-USD” will result in “en” even though USD is not a valid subtag.\u003c/p\u003e\n\u003cp\u003eMake doesn’t return an error.\nIt is common practice to use the default language if an error occurs anyway so\nthis makes it more convenient. Use Parse to handle any error manually.\u003c/p\u003e\n\u003cp\u003eThe HTTP Accept-Language header is often used to pass a user’s desired\nlanguages.\nThe ParseAcceptLanguage function parses it into a slice of language tags,\nordered by preference.\u003c/p\u003e\n\u003cp\u003eBy default, the language package does not canonicalize tags.\nFor example, it does not follow the BCP 47 recommendation of eliminating scripts\nif it is the common choice in the “overwhelming majority”.\nIt similarly ignores CLDR recommendations: “cmn” is not replaced by “zh” and\n“zh-Hant-HK” is not simplified to “zh-HK”.\nCanonicalizing tags may throw away useful information about user intent.\nCanonicalization is handled in the Matcher instead.\nA full array of canonicalization options are available if the programmer still\ndesires to do so.\u003c/p\u003e\n\u003ch3 id=\"matching-user-preferred-languages-to-supported-languages\"\u003eMatching User-Preferred Languages to Supported Languages\u003c/h3\u003e\n\u003cp\u003eA Matcher matches user-preferred languages to supported languages.\nUsers are strongly advised to use it if they don’t want to deal with all the\nintricacies of matching languages.\u003c/p\u003e\n\u003cp\u003eThe Match method may pass through user settings (from BCP 47 extensions) from\nthe preferred tags to the selected supported tag.\nIt is therefore important that the tag returned by Match is used to obtain\nlanguage-specific resources.\nFor example, “de-u-co-phonebk” requests phone-book ordering for German.\nThe extension is ignored for matching, but is used by the collate package to\nselect the respective sorting order variant.\u003c/p\u003e\n\u003cp\u003eA Matcher is initialized with the languages supported by an application, which\nare usually the languages for which there are translations.\nThis set is typically fixed, allowing a matcher to be created at startup.\nMatcher is optimized to improve the performance of Match at the expense of\ninitialization cost.\u003c/p\u003e\n\u003cp\u003eThe language package provides a predefined set of the most commonly used\nlanguage tags that can be used for defining the supported set.\nUsers generally don’t have to worry about the exact tags to pick for supported\nlanguages.\nFor example, AmericanEnglish (“en-US”) may be used interchangeably with the more\ncommon English (“en”), which defaults to American.\nIt is all the same for the Matcher. An application may even add both, allowing\nfor more specific American slang for “en-US”.\u003c/p\u003e\n\u003ch3 id=\"matching-example\"\u003eMatching Example\u003c/h3\u003e\n\u003cp\u003eConsider the following Matcher and lists of supported languages:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar supported = []language.Tag{\n    language.AmericanEnglish,    // en-US: first language is fallback\n    language.German,             // de\n    language.Dutch,              // nl\n    language.Portuguese          // pt (defaults to Brazilian)\n    language.EuropeanPortuguese, // pt-pT\n    language.Romanian            // ro\n    language.Serbian,            // sr (defaults to Cyrillic script)\n    language.SerbianLatin,       // sr-Latn\n    language.SimplifiedChinese,  // zh-Hans\n    language.TraditionalChinese, // zh-Hant\n}\nvar matcher = language.NewMatcher(supported)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s look at the matches against this list of supported languages for various\nuser preferences.\u003c/p\u003e\n\u003cp\u003eFor a user preference of “he” (Hebrew), the best match is “en-US” (American\nEnglish).\nThere is no good match, so the matcher uses the fallback language (the first in\nthe supported list).\u003c/p\u003e\n\u003cp\u003eFor a user preference of “hr” (Croatian), the best match is “sr-Latn” (Serbian\nwith Latin script), because, once they are written in the same script, Serbian\nand Croatian are mutually intelligible.\u003c/p\u003e\n\u003cp\u003eFor a user preference of “ru, mo” (Russian, then Moldavian), the best match is\n“ro” (Romanian), because Moldavian is now canonically classified as “ro-MD”\n(Romanian in Moldova).\u003c/p\u003e\n\u003cp\u003eFor a user preference of “zh-TW” (Mandarin in Taiwan), the best match is\n“zh-Hant” (Mandarin written in Traditional Chinese), not “zh-Hans” (Mandarin\nwritten in Simplified Chinese).\u003c/p\u003e\n\u003cp\u003eFor a user preference of “af, ar” (Afrikaans, then Arabic), the best match is\n“nl” (Dutch). Neither preference is supported directly, but Dutch is a\nsignificantly closer match to Afrikaans than the fallback language English is to\neither.\u003c/p\u003e\n\u003cp\u003eFor a user preference of “pt-AO, id” (Angolan Portuguese, then Indonesian), the\nbest match is “pt-PT” (European Portuguese), not “pt” (Brazilian Portuguese).\u003c/p\u003e\n\u003cp\u003eFor a user preference of “gsw-u-co-phonebk” (Swiss German with phone-book\ncollation order), the best match is “de-u-co-phonebk” (German with phone-book\ncollation order).\nGerman is the best match for Swiss German in the server’s language list, and the\noption for phone-book collation order has been carried over.\u003c/p\u003e\n\u003ch3 id=\"confidence-scores\"\u003eConfidence Scores\u003c/h3\u003e\n\u003cp\u003eGo uses coarse-grained confidence scoring with rule-based elimination.\nA match is classified as Exact, High (not exact, but no known ambiguity), Low\n(probably the correct match, but maybe not), or No.\nIn case of multiple matches, there is a set of tie-breaking rules that are\nexecuted in order.\nThe first match is returned in the case of multiple equal matches.\nThese confidence scores may be useful, for example, to reject relatively weak\nmatches.\nThey are also used to score, for example, the most likely region or script from\na language tag.\u003c/p\u003e\n\u003cp\u003eImplementations in other languages often use more fine-grained, variable-scale\nscoring.\nWe found that using coarse-grained scoring in the Go implementation ended up\nsimpler to implement, more maintainable, and faster, meaning that we could\nhandle more rules.\u003c/p\u003e\n\u003ch3 id=\"displaying-supported-languages\"\u003eDisplaying Supported Languages\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"https://golang.org/x/text/language/display\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/text/language/display\u003c/a\u003e package allows naming language\ntags in many languages.\nIt also contains a “Self” namer for displaying a tag in its own language.\u003c/p\u003e\n\u003cp\u003eFor example:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    var supported = []language.Tag{\n        language.English,            \u003cspan class=\"comment\"\u003e// en\u003c/span\u003e\n        language.French,             \u003cspan class=\"comment\"\u003e// fr\u003c/span\u003e\n        language.Dutch,              \u003cspan class=\"comment\"\u003e// nl\u003c/span\u003e\n        language.Make(\u0026#34;nl-BE\u0026#34;),      \u003cspan class=\"comment\"\u003e// nl-BE\u003c/span\u003e\n        language.SimplifiedChinese,  \u003cspan class=\"comment\"\u003e// zh-Hans\u003c/span\u003e\n        language.TraditionalChinese, \u003cspan class=\"comment\"\u003e// zh-Hant\u003c/span\u003e\n        language.Russian,            \u003cspan class=\"comment\"\u003e// ru\u003c/span\u003e\n    }\n\n    en := display.English.Tags()\n    for _, t := range supported {\n        fmt.Printf(\u0026#34;%-20s (%s)\\n\u0026#34;, en.Name(t), display.Self.Name(t))\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eprints\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEnglish              (English)\nFrench               (français)\nDutch                (Nederlands)\nFlemish              (Vlaams)\nSimplified Chinese   (简体中文)\nTraditional Chinese  (繁體中文)\nRussian              (русский)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the second column, note the differences in capitalization, reflecting the\nrules of the respective language.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAt first glance, language tags look like nicely structured data, but because\nthey describe human languages, the structure of relationships between language\ntags is actually quite complex.\nIt is often tempting, especially for English-speaking programmers, to write\nad-hoc language matching using nothing other than string manipulation of the\nlanguage tags.\nAs described above, this can produce awful results.\u003c/p\u003e\n\u003cp\u003eGo’s \u003ca href=\"https://golang.org/x/text/language\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/text/language\u003c/a\u003e package solves this complex problem\nwhile still presenting a simple, easy-to-use API. Enjoy.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-02-09T00:00:00Z",
  "Author": "Marcel van Lohuizen"
}