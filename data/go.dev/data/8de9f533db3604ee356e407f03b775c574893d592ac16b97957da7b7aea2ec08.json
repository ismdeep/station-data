{
  "Source": "go.dev",
  "Title": "Working with Errors in Go 1.13",
  "Link": "https://go.dev/blog/go1.13-errors",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/go1.13-errors\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eWorking with Errors in Go 1.13\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Damien Neil and Jonathan Amsterdam\u003cbr/\u003e\n      17 October 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo’s treatment of \u003ca href=\"/blog/errors-are-values\"\u003eerrors as values\u003c/a\u003e\nhas served us well over the last decade. Although the standard library’s support\nfor errors has been minimal—just the \u003ccode\u003eerrors.New\u003c/code\u003e and \u003ccode\u003efmt.Errorf\u003c/code\u003e functions,\nwhich produce errors that contain only a message—the built-in \u003ccode\u003eerror\u003c/code\u003e interface\nallows Go programmers to add whatever information they desire. All it requires\nis a type that implements an \u003ccode\u003eError\u003c/code\u003e method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype QueryError struct {\n    Query string\n    Err   error\n}\n\nfunc (e *QueryError) Error() string { return e.Query + \u0026#34;: \u0026#34; + e.Err.Error() }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eError types like this one are ubiquitous, and the information they store varies\nwidely, from timestamps to filenames to server addresses. Often, that\ninformation includes another, lower-level error to provide additional context.\u003c/p\u003e\n\u003cp\u003eThe pattern of one error containing another is so pervasive in Go code that,\nafter \u003ca href=\"/issue/29934\"\u003eextensive discussion\u003c/a\u003e, Go 1.13 added\nexplicit support for it. This post describes the additions to the standard\nlibrary that provide that support: three new functions in the \u003ccode\u003eerrors\u003c/code\u003e package,\nand a new formatting verb for \u003ccode\u003efmt.Errorf\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eBefore describing the changes in detail, let’s review how errors are examined\nand constructed in previous versions of the language.\u003c/p\u003e\n\u003ch2 id=\"errors-before-go-113\"\u003eErrors before Go 1.13\u003c/h2\u003e\n\u003ch3 id=\"examining-errors\"\u003eExamining errors\u003c/h3\u003e\n\u003cp\u003eGo errors are values. Programs make decisions based on those values in a few\nways. The most common is to compare an error to \u003ccode\u003enil\u003c/code\u003e to see if an operation\nfailed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil {\n    // something went wrong\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSometimes we compare an error to a known \u003cem\u003esentinel\u003c/em\u003e value, to see if a specific error has occurred.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar ErrNotFound = errors.New(\u0026#34;not found\u0026#34;)\n\nif err == ErrNotFound {\n    // something wasn\u0026#39;t found\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAn error value may be of any type which satisfies the language-defined \u003ccode\u003eerror\u003c/code\u003e\ninterface. A program can use a type assertion or type switch to view an error\nvalue as a more specific type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype NotFoundError struct {\n    Name string\n}\n\nfunc (e *NotFoundError) Error() string { return e.Name + \u0026#34;: not found\u0026#34; }\n\nif e, ok := err.(*NotFoundError); ok {\n    // e.Name wasn\u0026#39;t found\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"adding-information\"\u003eAdding information\u003c/h3\u003e\n\u003cp\u003eFrequently a function passes an error up the call stack while adding information\nto it, like a brief description of what was happening when the error occurred. A\nsimple way to do this is to construct a new error that includes the text of the\nprevious one:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil {\n    return fmt.Errorf(\u0026#34;decompress %v: %v\u0026#34;, name, err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCreating a new error with \u003ccode\u003efmt.Errorf\u003c/code\u003e discards everything from the original\nerror except the text. As we saw above with \u003ccode\u003eQueryError\u003c/code\u003e, we may sometimes want\nto define a new error type that contains the underlying error, preserving it for\ninspection by code. Here is \u003ccode\u003eQueryError\u003c/code\u003e again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype QueryError struct {\n    Query string\n    Err   error\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePrograms can look inside a \u003ccode\u003e*QueryError\u003c/code\u003e value to make decisions based on the\nunderlying error. You’ll sometimes see this referred to as “unwrapping” the\nerror.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif e, ok := err.(*QueryError); ok \u0026amp;\u0026amp; e.Err == ErrPermission {\n    // query failed because of a permission problem\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eos.PathError\u003c/code\u003e type in the standard library is another example of one error which contains another.\u003c/p\u003e\n\u003ch2 id=\"errors-in-go-113\"\u003eErrors in Go 1.13\u003c/h2\u003e\n\u003ch3 id=\"the-unwrap-method\"\u003eThe Unwrap method\u003c/h3\u003e\n\u003cp\u003eGo 1.13 introduces new features to the \u003ccode\u003eerrors\u003c/code\u003e and \u003ccode\u003efmt\u003c/code\u003e standard library\npackages to simplify working with errors that contain other errors. The most\nsignificant of these is a convention rather than a change: an error which\ncontains another may implement an \u003ccode\u003eUnwrap\u003c/code\u003e method returning the underlying\nerror. If \u003ccode\u003ee1.Unwrap()\u003c/code\u003e returns \u003ccode\u003ee2\u003c/code\u003e, then we say that \u003ccode\u003ee1\u003c/code\u003e \u003cem\u003ewraps\u003c/em\u003e \u003ccode\u003ee2\u003c/code\u003e, and\nthat you can \u003cem\u003eunwrap\u003c/em\u003e \u003ccode\u003ee1\u003c/code\u003e to get \u003ccode\u003ee2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFollowing this convention, we can give the \u003ccode\u003eQueryError\u003c/code\u003e type above an \u003ccode\u003eUnwrap\u003c/code\u003e\nmethod that returns its contained error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (e *QueryError) Unwrap() error { return e.Err }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe result of unwrapping an error may itself have an \u003ccode\u003eUnwrap\u003c/code\u003e method; we call\nthe sequence of errors produced by repeated unwrapping the \u003cem\u003eerror chain\u003c/em\u003e.\u003c/p\u003e\n\u003ch3 id=\"examining-errors-with-is-and-as\"\u003eExamining errors with Is and As\u003c/h3\u003e\n\u003cp\u003eThe Go 1.13 \u003ccode\u003eerrors\u003c/code\u003e package includes two new functions for examining errors: \u003ccode\u003eIs\u003c/code\u003e and \u003ccode\u003eAs\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eerrors.Is\u003c/code\u003e function compares an error to a value.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Similar to:\n//   if err == ErrNotFound { … }\nif errors.Is(err, ErrNotFound) {\n    // something wasn\u0026#39;t found\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eAs\u003c/code\u003e function tests whether an error is a specific type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Similar to:\n//   if e, ok := err.(*QueryError); ok { … }\nvar e *QueryError\n// Note: *QueryError is the type of the error.\nif errors.As(err, \u0026amp;e) {\n    // err is a *QueryError, and e is set to the error\u0026#39;s value\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the simplest case, the \u003ccode\u003eerrors.Is\u003c/code\u003e function behaves like a comparison to a\nsentinel error, and the \u003ccode\u003eerrors.As\u003c/code\u003e function behaves like a type assertion. When\noperating on wrapped errors, however, these functions consider all the errors in\na chain. Let’s look again at the example from above of unwrapping a \u003ccode\u003eQueryError\u003c/code\u003e\nto examine the underlying error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif e, ok := err.(*QueryError); ok \u0026amp;\u0026amp; e.Err == ErrPermission {\n    // query failed because of a permission problem\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing the \u003ccode\u003eerrors.Is\u003c/code\u003e function, we can write this as:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif errors.Is(err, ErrPermission) {\n    // err, or some error that it wraps, is a permission problem\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eerrors\u003c/code\u003e package also includes a new \u003ccode\u003eUnwrap\u003c/code\u003e function which returns the\nresult of calling an error’s \u003ccode\u003eUnwrap\u003c/code\u003e method, or \u003ccode\u003enil\u003c/code\u003e when the error has no\n\u003ccode\u003eUnwrap\u003c/code\u003e method. It is usually better to use \u003ccode\u003eerrors.Is\u003c/code\u003e or \u003ccode\u003eerrors.As\u003c/code\u003e,\nhowever, since these functions will examine the entire chain in a single call.\u003c/p\u003e\n\u003cp\u003eNote: although it may feel odd to take a pointer to a pointer, in this case it\nis correct. Think of it instead as taking a pointer to a value of the error\ntype; it so happens in this case that the returned error is a pointer type.\u003c/p\u003e\n\u003ch3 id=\"wrapping-errors-with-w\"\u003eWrapping errors with %w\u003c/h3\u003e\n\u003cp\u003eAs mentioned earlier, it is common to use the \u003ccode\u003efmt.Errorf\u003c/code\u003e function to add additional information to an error.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil {\n    return fmt.Errorf(\u0026#34;decompress %v: %v\u0026#34;, name, err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Go 1.13, the \u003ccode\u003efmt.Errorf\u003c/code\u003e function supports a new \u003ccode\u003e%w\u003c/code\u003e verb. When this verb\nis present, the error returned by \u003ccode\u003efmt.Errorf\u003c/code\u003e will have an \u003ccode\u003eUnwrap\u003c/code\u003e method\nreturning the argument of \u003ccode\u003e%w\u003c/code\u003e, which must be an error. In all other ways, \u003ccode\u003e%w\u003c/code\u003e\nis identical to \u003ccode\u003e%v\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil {\n    // Return an error which unwraps to err.\n    return fmt.Errorf(\u0026#34;decompress %v: %w\u0026#34;, name, err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWrapping an error with \u003ccode\u003e%w\u003c/code\u003e makes it available to \u003ccode\u003eerrors.Is\u003c/code\u003e and \u003ccode\u003eerrors.As\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eerr := fmt.Errorf(\u0026#34;access denied: %w\u0026#34;, ErrPermission)\n...\nif errors.Is(err, ErrPermission) ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"whether-to-wrap\"\u003eWhether to Wrap\u003c/h3\u003e\n\u003cp\u003eWhen adding additional context to an error, either with \u003ccode\u003efmt.Errorf\u003c/code\u003e or by\nimplementing a custom type, you need to decide whether the new error should wrap\nthe original. There is no single answer to this question; it depends on the\ncontext in which the new error is created. Wrap an error to expose it to\ncallers. Do not wrap an error when doing so would expose implementation details.\u003c/p\u003e\n\u003cp\u003eAs one example, imagine a \u003ccode\u003eParse\u003c/code\u003e function which reads a complex data structure\nfrom an \u003ccode\u003eio.Reader\u003c/code\u003e. If an error occurs, we wish to report the line and column\nnumber at which it occurred. If the error occurs while reading from the\n\u003ccode\u003eio.Reader\u003c/code\u003e, we will want to wrap that error to allow inspection of the\nunderlying problem. Since the caller provided the \u003ccode\u003eio.Reader\u003c/code\u003e to the function,\nit makes sense to expose the error produced by it.\u003c/p\u003e\n\u003cp\u003eIn contrast, a function which makes several calls to a database probably should\nnot return an error which unwraps to the result of one of those calls. If the\ndatabase used by the function is an implementation detail, then exposing these\nerrors is a violation of abstraction. For example, if the \u003ccode\u003eLookupUser\u003c/code\u003e function\nof your package \u003ccode\u003epkg\u003c/code\u003e uses Go’s \u003ccode\u003edatabase/sql\u003c/code\u003e package, then it may encounter a\n\u003ccode\u003esql.ErrNoRows\u003c/code\u003e error. If you return that error with\n\u003ccode\u003efmt.Errorf(\u0026#34;accessing DB: %v\u0026#34;, err)\u003c/code\u003e\nthen a caller cannot look inside to find the \u003ccode\u003esql.ErrNoRows\u003c/code\u003e. But if\nthe function instead returns \u003ccode\u003efmt.Errorf(\u0026#34;accessing DB: %w\u0026#34;, err)\u003c/code\u003e, then a\ncaller could reasonably write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eerr := pkg.LookupUser(...)\nif errors.Is(err, sql.ErrNoRows) …\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt that point, the function must always return \u003ccode\u003esql.ErrNoRows\u003c/code\u003e if you don’t want\nto break your clients, even if you switch to a different database package. In\nother words, wrapping an error makes that error part of your API. If you don’t\nwant to commit to supporting that error as part of your API in the future, you\nshouldn’t wrap the error.\u003c/p\u003e\n\u003cp\u003eIt’s important to remember that whether you wrap or not, the error text will be\nthe same. A \u003cem\u003eperson\u003c/em\u003e trying to understand the error will have the same information\neither way; the choice to wrap is about whether to give \u003cem\u003eprograms\u003c/em\u003e additional\ninformation so they can make more informed decisions, or to withhold that\ninformation to preserve an abstraction layer.\u003c/p\u003e\n\u003ch2 id=\"customizing-error-tests-with-is-and-as-methods\"\u003eCustomizing error tests with Is and As methods\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eerrors.Is\u003c/code\u003e function examines each error in a chain for a match with a\ntarget value. By default, an error matches the target if the two are\n\u003ca href=\"/ref/spec#Comparison_operators\"\u003eequal\u003c/a\u003e. In addition, an\nerror in the chain may declare that it matches a target by implementing an \u003ccode\u003eIs\u003c/code\u003e\n\u003cem\u003emethod\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eAs an example, consider this error inspired by the\n\u003ca href=\"https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html\" rel=\"noreferrer\" target=\"_blank\"\u003eUpspin error package\u003c/a\u003e\nwhich compares an error against a template, considering only fields which are\nnon-zero in the template:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Error struct {\n    Path string\n    User string\n}\n\nfunc (e *Error) Is(target error) bool {\n    t, ok := target.(*Error)\n    if !ok {\n        return false\n    }\n    return (e.Path == t.Path || t.Path == \u0026#34;\u0026#34;) \u0026amp;\u0026amp;\n           (e.User == t.User || t.User == \u0026#34;\u0026#34;)\n}\n\nif errors.Is(err, \u0026amp;Error{User: \u0026#34;someuser\u0026#34;}) {\n    // err\u0026#39;s User field is \u0026#34;someuser\u0026#34;.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eerrors.As\u003c/code\u003e function similarly consults an \u003ccode\u003eAs\u003c/code\u003e method when present.\u003c/p\u003e\n\u003ch2 id=\"errors-and-package-apis\"\u003eErrors and package APIs\u003c/h2\u003e\n\u003cp\u003eA package which returns errors (and most do) should describe what properties of\nthose errors programmers may rely on. A well-designed package will also avoid\nreturning errors with properties that should not be relied upon.\u003c/p\u003e\n\u003cp\u003eThe simplest specification is to say that operations either succeed or fail,\nreturning a nil or non-nil error value respectively. In many cases, no further\ninformation is needed.\u003c/p\u003e\n\u003cp\u003eIf we wish a function to return an identifiable error condition, such as “item\nnot found,” we might return an error wrapping a sentinel.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar ErrNotFound = errors.New(\u0026#34;not found\u0026#34;)\n\n// FetchItem returns the named item.\n//\n// If no item with the name exists, FetchItem returns an error\n// wrapping ErrNotFound.\nfunc FetchItem(name string) (*Item, error) {\n    if itemNotFound(name) {\n        return nil, fmt.Errorf(\u0026#34;%q: %w\u0026#34;, name, ErrNotFound)\n    }\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are other existing patterns for providing errors which can be semantically\nexamined by the caller, such as directly returning a sentinel value, a specific\ntype, or a value which can be examined with a predicate function.\u003c/p\u003e\n\u003cp\u003eIn all cases, care should be taken not to expose internal details to the user.\nAs we touched on in “Whether to Wrap” above, when you return\nan error from another package you should convert the error to a form that does\nnot expose the underlying error, unless you are willing to commit to returning\nthat specific error in the future.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef, err := os.Open(filename)\nif err != nil {\n    // The *os.PathError returned by os.Open is an internal detail.\n    // To avoid exposing it to the caller, repackage it as a new\n    // error with the same text. We use the %v formatting verb, since\n    // %w would permit the caller to unwrap the original *os.PathError.\n    return fmt.Errorf(\u0026#34;%v\u0026#34;, err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf a function is defined as returning an error wrapping some sentinel or type,\ndo not return the underlying error directly.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar ErrPermission = errors.New(\u0026#34;permission denied\u0026#34;)\n\n// DoSomething returns an error wrapping ErrPermission if the user\n// does not have permission to do something.\nfunc DoSomething() error {\n    if !userHasPermission() {\n        // If we return ErrPermission directly, callers might come\n        // to depend on the exact error value, writing code like this:\n        //\n        //     if err := pkg.DoSomething(); err == pkg.ErrPermission { … }\n        //\n        // This will cause problems if we want to add additional\n        // context to the error in the future. To avoid this, we\n        // return an error wrapping the sentinel so that users must\n        // always unwrap it:\n        //\n        //     if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... }\n        return fmt.Errorf(\u0026#34;%w\u0026#34;, ErrPermission)\n    }\n    // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAlthough the changes we’ve discussed amount to just three functions and a\nformatting verb, we hope they will go a long way toward improving how errors are\nhandled in Go programs. We expect that wrapping to provide additional context\nwill become commonplace, helping programs to make better decisions and helping\nprogrammers to find bugs more quickly.\u003c/p\u003e\n\u003cp\u003eAs Russ Cox said in his \u003ca href=\"/blog/experiment\"\u003eGopherCon 2019 keynote\u003c/a\u003e,\non the path to Go 2 we experiment, simplify and ship. Now that we’ve\nshipped these changes, we look forward to the experiments that will follow.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-10-17T00:00:00Z",
  "Author": "Damien Neil and Jonathan Amsterdam"
}