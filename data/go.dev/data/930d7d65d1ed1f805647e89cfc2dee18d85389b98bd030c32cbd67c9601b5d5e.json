{
  "Source": "go.dev",
  "Title": "Go at Heroku",
  "Link": "https://go.dev/blog/heroku",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/heroku\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo at Heroku\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Keith Rarick and Blake Mizerany\u003cbr/\u003e\n      21 April 2011\n      \u003c/p\u003e\n      \n      \u003cp\u003e\u003cem\u003eThis week’s blog post is written by\u003c/em\u003e \u003ca href=\"http://xph.us/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eKeith Rarick\u003c/em\u003e\u003c/a\u003e\n\u003cem\u003eand\u003c/em\u003e \u003ca href=\"http://itsbonus.heroku.com/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eBlake Mizerany\u003c/em\u003e\u003c/a\u003e,\n\u003cem\u003esystems engineers at\u003c/em\u003e \u003ca href=\"http://www.heroku.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eHeroku\u003c/a\u003e.\n\u003cem\u003eIn their own words, they “eat, drink, and sleep distributed systems.” Here they discuss their experiences using Go.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eA big problem that comes with building distributed systems is the coordination\nof physical servers.\nEach server needs to know various facts about the system as a whole.\nThis critical data includes locks, configuration data,\nand so on, and it must be consistent and available even during data store failures,\nso we need a data store with solid consistency guarantees.\nOur solution to this problem is \u003ca href=\"http://xph.us/2011/04/13/introducing-doozer.html\" rel=\"noreferrer\" target=\"_blank\"\u003eDoozer\u003c/a\u003e,\na new, consistent, highly-available data store written in Go.\u003c/p\u003e\n\u003cp\u003eAt Doozer’s core is \u003ca href=\"http://en.wikipedia.org/wiki/Paxos_(computer_science)\" rel=\"noreferrer\" target=\"_blank\"\u003ePaxos\u003c/a\u003e,\na family of protocols for solving consensus in an unreliable network of unreliable nodes.\nWhile Paxos is essential to running a fault-tolerant system,\nit is notorious for being difficult to implement.\nEven example implementations that can be found online are complex and hard to follow,\ndespite being simplified for educational purposes.\nExisting production systems have a reputation for being worse.\u003c/p\u003e\n\u003cp\u003eFortunately, Go’s concurrency primitives made the task much easier.\nPaxos is defined in terms of independent,\nconcurrent processes that communicate via passing messages.\nIn Doozer, these processes are implemented as goroutines,\nand their communications as channel operations.\nIn the same way that garbage collectors improve upon malloc and free,\nwe found that \u003ca href=\"/blog/share-memory-by-communicating\"\u003egoroutines and channels\u003c/a\u003e\nimprove upon the lock-based approach to concurrency.\nThese tools let us avoid complex bookkeeping and stay focused on the problem at hand.\nWe are still amazed at how few lines of code it took to achieve something\nrenowned for being difficult.\u003c/p\u003e\n\u003cp\u003eThe standard packages in Go were another big win for Doozer.\nThe Go team is very pragmatic about what goes into them.\nFor instance, a package we quickly found useful was \u003ca href=\"/pkg/websocket/\"\u003ewebsocket\u003c/a\u003e.\nOnce we had a working data store, we needed an easy way to introspect it\nand visualize activity.\nUsing the websocket package, Keith was able to add the web viewer on his\ntrain ride home and without requiring external dependencies.\nThis is a real testament to how well Go mixes systems and application programming.\u003c/p\u003e\n\u003cp\u003eOne of our favorite productivity gains was provided by Go’s source formatter:\n\u003ca href=\"/cmd/gofmt/\"\u003egofmt\u003c/a\u003e.\nWe never argued over where to put a curly-brace,\ntabs vs. spaces, or if we should align assignments.\nWe simply agreed that the buck stopped at the default output from gofmt.\u003c/p\u003e\n\u003cp\u003eDeploying Doozer was satisfyingly simple.\nGo builds statically linked binaries which means Doozer has no external dependencies;\nit’s a single file that can be copied to any machine and immediately launched\nto join a cluster of running Doozers.\u003c/p\u003e\n\u003cp\u003eFinally, Go’s maniacal focus on simplicity and orthogonality aligns with\nour view of software engineering.\nLike the Go team, we are pragmatic about what features go into Doozer.\nWe sweat the details, preferring to change an existing feature instead of\nintroducing a new one.\nIn this sense, Go is a perfect match for Doozer.\u003c/p\u003e\n\u003cp\u003eWe already have future projects in mind for Go. Doozer is just the start of much bigger system.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-04-21T00:00:00Z",
  "Author": "Keith Rarick and Blake Mizerany"
}