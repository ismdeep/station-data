{
  "Source": "go.dev",
  "Title": "Code coverage for Go integration tests",
  "Link": "https://go.dev/blog/integration-test-coverage",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/integration-test-coverage\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eCode coverage for Go integration tests\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Than McIntosh\u003cbr/\u003e\n      8 March 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eCode coverage tools help developers determine what fraction of a source code base is executed (covered) when a given test suite is executed.\u003c/p\u003e\n\u003cp\u003eGo has for some time provided support (\u003ca href=\"/blog/cover\"\u003eintroduced\u003c/a\u003e in the Go 1.2 release) to measure code coverage at the package level, using the \u003cstrong\u003e\u0026#34;-cover\u0026#34;\u003c/strong\u003e flag of the “go test” command.\u003c/p\u003e\n\u003cp\u003eThis tooling works well in most cases, but has some weaknesses for larger Go applications.\nFor such applications, developers often write “integration” tests that verify the behavior of an entire program (in addition to package-level unit tests).\u003c/p\u003e\n\u003cp\u003eThis type of test typically involves building a complete application binary, then running the binary on a set of representative inputs (or under production load, if it is a server) to ensure that all of the component packages are working correctly together, as opposed to testing individual packages in isolation.\u003c/p\u003e\n\u003cp\u003eBecause the integration test binaries are built with “go build” and not “go test”, Go’s tooling didn’t provide any easy way to collect a coverage profile for these tests, up until now.\u003c/p\u003e\n\u003cp\u003eWith Go 1.20, you can now build coverage-instrumented programs using “go build -cover”, then feed these instrumented binaries into an integration test to extend the scope of coverage testing.\u003c/p\u003e\n\u003cp\u003eIn this blog post we’ll give an example of how these new features work, and outline some of the use cases and workflow for collecting coverage profiles from integration tests.\u003c/p\u003e\n\u003ch2 id=\"example\"\u003eExample\u003c/h2\u003e\n\u003cp\u003eLet’s take a very small example program, write a simple integration test for it, and then collect a coverage profile from the integration test.\u003c/p\u003e\n\u003cp\u003eFor this exercise we’ll use the “mdtool” markdown processing tool from \u003ca href=\"https://pkg.go.dev/gitlab.com/golang-commonmark/mdtool\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egitlab.com/golang-commonmark/mdtool\u003c/code\u003e\u003c/a\u003e.\nThis is a demo program designed to show how clients can use the package \u003ca href=\"https://pkg.go.dev/gitlab.com/golang-commonmark/markdown\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egitlab.com/golang-commonmark/markdown\u003c/code\u003e\u003c/a\u003e, a markdown-to-HTML conversion library.\u003c/p\u003e\n\u003ch2 id=\"set-up-for-mdtool\"\u003eSet up for mdtool\u003c/h2\u003e\n\u003cp\u003eFirst let’s download a copy of “mdtool” itself (we’re picking a specific version just to make these steps reproducible):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git clone https://gitlab.com/golang-commonmark/mdtool.git\n...\n$ cd mdtool\n$ git tag example e210a4502a825ef7205691395804eefce536a02f\n$ git checkout example\n...\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-simple-integration-test\"\u003eA simple integration test\u003c/h2\u003e\n\u003cp\u003eNow we’ll write a simple integration test for “mdtool”; our test will build the\n“mdtool” binary, then run it on a set of input markdown files.\nThis very simple script runs the “mdtool” binary on each file from a test data directory, checking to make sure that it produces some output and doesn’t crash.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat integration_test.sh\n#!/bin/sh\nBUILDARGS=\u0026#34;$*\u0026#34;\n#\n# Terminate the test if any command below does not complete successfully.\n#\nset -e\n#\n# Download some test inputs (the \u0026#39;website\u0026#39; repo contains various *.md files).\n#\nif [ ! -d testdata ]; then\n  git clone https://go.googlesource.com/website testdata\n  git -C testdata tag example 8bb4a56901ae3b427039d490207a99b48245de2c\n  git -C testdata checkout example\nfi\n#\n# Build mdtool binary for testing purposes.\n#\nrm -f mdtool.exe\ngo build $BUILDARGS -o mdtool.exe .\n#\n# Run the tool on a set of input files from \u0026#39;testdata\u0026#39;.\n#\nFILES=$(find testdata -name \u0026#34;*.md\u0026#34; -print)\nN=$(echo $FILES | wc -w)\nfor F in $FILES\ndo\n  ./mdtool.exe +x +a $F \u0026gt; /dev/null\ndone\necho \u0026#34;finished processing $N files, no crashes\u0026#34;\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is an example run of our test:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh integration_test.sh\n...\nfinished processing 380 files, no crashes\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuccess: we’ve verified that the “mdtool” binary successfully digested a set of input files… but how much of the tool’s source code have we actually exercised?\nIn the next section we’ll collect a coverage profile to find out.\u003c/p\u003e\n\u003ch2 id=\"using-the-integration-test-to-collect-coverage-data\"\u003eUsing the integration test to collect coverage data\u003c/h2\u003e\n\u003cp\u003eLet’s write another wrapper script that invokes the previous script, but\nbuilds the tool for coverage and then post-processes the resulting profiles:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat wrap_test_for_coverage.sh\n#!/bin/sh\nset -e\nPKGARGS=\u0026#34;$*\u0026#34;\n#\n# Setup\n#\nrm -rf covdatafiles\nmkdir covdatafiles\n#\n# Pass in \u0026#34;-cover\u0026#34; to the script to build for coverage, then\n# run with GOCOVERDIR set.\n#\nGOCOVERDIR=covdatafiles \\\n  /bin/sh integration_test.sh -cover $PKGARGS\n#\n# Post-process the resulting profiles.\n#\ngo tool covdata percent -i=covdatafiles\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSome key things to note about the wrapper above:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eit passes in the “-cover” flag when running \u003ccode\u003eintegration_test.sh\u003c/code\u003e, which gives us a coverage-instrumented “mdtool.exe” binary\u003c/li\u003e\n\u003cli\u003eit sets the GOCOVERDIR environment variable to a directory into which coverage data files will be written\u003c/li\u003e\n\u003cli\u003ewhen the test is complete, it runs “go tool covdata percent” to produce a report on percentage of statements covered\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere’s the output when we run this new wrapper script:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh wrap_test_for_coverage.sh\n...\n    gitlab.com/golang-commonmark/mdtool coverage: 48.1% of statements\n$\n# Note: covdatafiles now contains 381 files.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eVoila!\nWe now have some idea of how well our integration tests work in exercising the “mdtool” application’s source code.\u003c/p\u003e\n\u003cp\u003eIf we make changes to enhance the test harness, then do a second coverage collection run, we’ll see the changes reflected in the coverage report.\nFor example, suppose we improve our test by adding these two additional lines to \u003ccode\u003eintegration_test.sh\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e./mdtool.exe +ty testdata/README.md  \u0026gt; /dev/null\n./mdtool.exe +ta \u0026lt; testdata/README.md  \u0026gt; /dev/null\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eRunning the coverage testing wrapper again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh wrap_test_for_coverage.sh\nfinished processing 380 files, no crashes\n    gitlab.com/golang-commonmark/mdtool coverage: 54.6% of statements\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see the effects of our change: statement coverage has increased from 48% to 54%.\u003c/p\u003e\n\u003ch2 id=\"selecting-packages-to-cover\"\u003eSelecting packages to cover\u003c/h2\u003e\n\u003cp\u003eBy default, “go build -cover” will instrument just the packages that are part of the Go module being built, which in this case is the \u003ccode\u003egitlab.com/golang-commonmark/mdtool\u003c/code\u003e package.\nIn some cases however it is useful to extend coverage instrumentation to other packages; this can be accomplished by passing “-coverpkg” to “go build -cover”.\u003c/p\u003e\n\u003cp\u003eFor our example program, “mdtool” is in fact largely just a wrapper around the\npackage \u003ccode\u003egitlab.com/golang-commonmark/markdown\u003c/code\u003e, so it is interesting to include\n\u003ccode\u003emarkdown\u003c/code\u003e in the set of packages that are instrumented.\u003c/p\u003e\n\u003cp\u003eHere’s the \u003ccode\u003ego.mod\u003c/code\u003e file for “mdtool”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ head go.mod\nmodule gitlab.com/golang-commonmark/mdtool\n\ngo 1.17\n\nrequire (\n    github.com/pkg/browser v0.0.0-20210911075715-681adbf594b8\n    gitlab.com/golang-commonmark/markdown v0.0.0-20211110145824-bf3e522c626a\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can use the “-coverpkg” flag to control which packages are selected for inclusion in the coverage analysis to include one of the deps above.\nHere’s an example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh wrap_test_for_coverage.sh -coverpkg=gitlab.com/golang-commonmark/markdown,gitlab.com/golang-commonmark/mdtool\n...\n    gitlab.com/golang-commonmark/markdown   coverage: 70.6% of statements\n    gitlab.com/golang-commonmark/mdtool coverage: 54.6% of statements\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"working-with-coverage-data-files\"\u003eWorking with coverage data files\u003c/h1\u003e\n\u003cp\u003eWhen a coverage integration test has completed and written out a set of raw data files (in our case, the contents of the \u003ccode\u003ecovdatafiles\u003c/code\u003e directory), we can post-process these files in various ways.\u003c/p\u003e\n\u003ch2 id=\"converting-profiles-to--coverprofile-text-format\"\u003eConverting profiles to ‘-coverprofile’ text format\u003c/h2\u003e\n\u003cp\u003eWhen working with unit tests, you can run \u003ccode\u003ego test -coverprofile=abc.txt\u003c/code\u003e to write a text-format coverage profile for a given coverage test run.\u003c/p\u003e\n\u003cp\u003eWith binaries built with \u003ccode\u003ego build -cover\u003c/code\u003e, you can generate a text-format profile after the fact by running \u003ccode\u003ego tool covdata textfmt\u003c/code\u003e on the files emitted into the GOCOVERDIR directory.\u003c/p\u003e\n\u003cp\u003eOnce this step is complete, you can use \u003ccode\u003ego tool cover -func=\u0026lt;file\u0026gt;\u003c/code\u003e or \u003ccode\u003ego tool cover -html=\u0026lt;file\u0026gt;\u003c/code\u003e to interpret/visualize the data just as you would with \u003ccode\u003ego test -coverprofile\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh wrap_test_for_coverage.sh\n...\n$ go tool covdata textfmt -i=covdatafiles -o=cov.txt\n$ go tool cover -func=cov.txt\ngitlab.com/golang-commonmark/mdtool/main.go:40:     readFromStdin   100.0%\ngitlab.com/golang-commonmark/mdtool/main.go:44:     readFromFile    80.0%\ngitlab.com/golang-commonmark/mdtool/main.go:54:     readFromWeb 0.0%\ngitlab.com/golang-commonmark/mdtool/main.go:64:     readInput   80.0%\ngitlab.com/golang-commonmark/mdtool/main.go:74:     extractText 100.0%\ngitlab.com/golang-commonmark/mdtool/main.go:88:     writePreamble   100.0%\ngitlab.com/golang-commonmark/mdtool/main.go:111:    writePostamble  100.0%\ngitlab.com/golang-commonmark/mdtool/main.go:118:    handler     0.0%\ngitlab.com/golang-commonmark/mdtool/main.go:139:    main        51.6%\ntotal:                          (statements)    54.6%\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"merging-raw-profiles-with-go-tool-covdata-merge\"\u003eMerging raw profiles with ‘go tool covdata merge’\u003c/h2\u003e\n\u003cp\u003eEach execution of a “-cover” built application will write out one or more data files to the directory specified in the GOCOVERDIR environment variable.\nIf an integration test performs N program executions, you’ll wind up with O(N) files in your output directory.\nThere is typically a lot of duplicated content in the data files, so to compact the data and/or combine data sets from different integration test runs, you can use the \u003ccode\u003ego tool covdata merge\u003c/code\u003e command to merge profiles together.\nExample:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ /bin/sh wrap_test_for_coverage.sh\nfinished processing 380 files, no crashes\n    gitlab.com/golang-commonmark/mdtool coverage: 54.6% of statements\n$ ls covdatafiles\ncovcounters.13326b42c2a107249da22f6e0d35b638.772307.1677775306041466651\ncovcounters.13326b42c2a107249da22f6e0d35b638.772314.1677775306053066987\n...\ncovcounters.13326b42c2a107249da22f6e0d35b638.774973.1677775310032569308\ncovmeta.13326b42c2a107249da22f6e0d35b638\n$ ls covdatafiles | wc\n    381     381   27401\n$ rm -rf merged ; mkdir merged ; go tool covdata merge -i=covdatafiles -o=merged\n$ ls merged\ncovcounters.13326b42c2a107249da22f6e0d35b638.0.1677775331350024014\ncovmeta.13326b42c2a107249da22f6e0d35b638\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ego tool covdata merge\u003c/code\u003e operation also accepts a \u003ccode\u003e-pkg\u003c/code\u003e flag that can be used to select out a specific package or set of packages, if that is desired.\u003c/p\u003e\n\u003cp\u003eThis merge capability is also useful to combine results from different types of test runs, including runs generated by other test harnesses.\u003c/p\u003e\n\u003ch1 id=\"wrap-up\"\u003eWrap-up\u003c/h1\u003e\n\u003cp\u003eThat covers it: with the 1.20 release, Go’s coverage tooling is no longer limited to package tests, but supports collecting profiles from larger integration tests.\nWe hope you will make good use of the new features to help understand how well your larger and more complicated tests are working, and which parts of your source code they are exercising.\u003c/p\u003e\n\u003cp\u003ePlease try out these new features, and as always if you encounter problems, file issues on our \u003ca href=\"https://github.com/golang/go/issues\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub issue tracker\u003c/a\u003e.\nThanks.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-03-08T00:00:00Z",
  "Author": "Than McIntosh"
}