{
  "Source": "go.dev",
  "Title": "HTTP/2 Server Push",
  "Link": "https://go.dev/blog/h2push",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/h2push\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eHTTP/2 Server Push\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jaana Burcu Dogan and Tom Bergan\u003cbr/\u003e\n      24 March 2017\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eHTTP/2 is designed to address many of the failings of HTTP/1.x.\nModern web pages use many resources: HTML, stylesheets,\nscripts, images, and so on. In HTTP/1.x, each of these resources must\nbe requested explicitly. This can be a slow process.\nThe browser starts by fetching the HTML, then learns of more resources\nincrementally as it parses and evaluates the page. Since the server\nmust wait for the browser to make each request, the network is often\nidle and underutilized.\u003c/p\u003e\n\u003cp\u003eTo improve latency, HTTP/2 introduced \u003cem\u003eserver push\u003c/em\u003e, which allows the\nserver to push resources to the browser before they are explicitly\nrequested. A server often knows many of the additional resources a\npage will need and can start pushing those resources as it responds\nto the initial request. This allows the server to fully utilize an\notherwise idle network and improve page load times.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"h2push/serverpush.svg\" width=\"600\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eAt the protocol level, HTTP/2 server push is driven by \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e\nframes. A \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e describes a request that the server predicts the\nbrowser will make in the near future. As soon as the browser receives\na \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e, it knows that the server will deliver the resource.\nIf the browser later discovers that it needs this resource, it will\nwait for the push to complete rather than sending a new request.\nThis reduces the time the browser spends waiting on the network.\u003c/p\u003e\n\u003ch2 id=\"server-push-in-nethttp\"\u003eServer Push in net/http\u003c/h2\u003e\n\u003cp\u003eGo 1.8 introduced support for pushing responses from an \u003ca href=\"/pkg/net/http/#Server\"\u003e\u003ccode\u003ehttp.Server\u003c/code\u003e\u003c/a\u003e.\nThis feature is available if the running server is an HTTP/2 server\nand the incoming connection uses HTTP/2. In any HTTP handler,\nyou can assert if the http.ResponseWriter supports server push by checking\nif it implements the new \u003ca href=\"/pkg/net/http/#Pusher\"\u003e\u003ccode\u003ehttp.Pusher\u003c/code\u003e\u003c/a\u003e interface.\u003c/p\u003e\n\u003cp\u003eFor example, if the server knows that \u003ccode\u003eapp.js\u003c/code\u003e will be required to\nrender the page, the handler can initiate a push if \u003ccode\u003ehttp.Pusher\u003c/code\u003e\nis available:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) {\n        if pusher, ok := w.(http.Pusher); ok {\n            \u003cspan class=\"comment\"\u003e// Push is supported.\u003c/span\u003e\n            if err := pusher.Push(\u0026#34;/app.js\u0026#34;, nil); err != nil {\n                log.Printf(\u0026#34;Failed to push: %v\u0026#34;, err)\n            }\n        }\n        \u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\n    })\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe Push call creates a synthetic request for \u003ccode\u003e/app.js\u003c/code\u003e,\nsynthesizes that request into a \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e frame, then forwards\nthe synthetic request to the server’s request handler, which will\ngenerate the pushed response. The second argument to Push specifies\nadditional headers to include in the \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e. For example,\nif the response to \u003ccode\u003e/app.js\u003c/code\u003e varies on Accept-Encoding,\nthen the \u003ccode\u003ePUSH_PROMISE\u003c/code\u003e should include an Accept-Encoding value:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) {\n        if pusher, ok := w.(http.Pusher); ok {\n            \u003cspan class=\"comment\"\u003e// Push is supported.\u003c/span\u003e\n            options := \u0026amp;http.PushOptions{\n                Header: http.Header{\n                    \u0026#34;Accept-Encoding\u0026#34;: r.Header[\u0026#34;Accept-Encoding\u0026#34;],\n                },\n            }\n            if err := pusher.Push(\u0026#34;/app.js\u0026#34;, options); err != nil {\n                log.Printf(\u0026#34;Failed to push: %v\u0026#34;, err)\n            }\n        }\n        \u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\n    })\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eA fully working example is \u003ca href=\"https://cs.opensource.google/go/x/website/+/master:_content/blog/h2push/server/\" rel=\"noreferrer\" target=\"_blank\"\u003eavailable here\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIf you run the server and load \u003ca href=\"https://localhost:8080\" rel=\"noreferrer\" target=\"_blank\"\u003ehttps://localhost:8080\u003c/a\u003e,\nyour browser’s developer tools should show that \u003ccode\u003eapp.js\u003c/code\u003e and\n\u003ccode\u003estyle.css\u003c/code\u003e were pushed by the server.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"h2push/networktimeline.png\" width=\"605\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"start-your-pushes-before-you-respond\"\u003eStart Your Pushes Before You Respond\u003c/h2\u003e\n\u003cp\u003eIt’s a good idea to call the Push method before sending any bytes\nof the response. Otherwise it is possible to accidentally generate\nduplicate responses. For example, suppose you write part of an HTML\nresponse:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026lt;html\u0026gt;\n\u0026lt;head\u0026gt;\n    \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;a.css\u0026#34;\u0026gt;...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen you call Push(“a.css”, nil). The browser may parse this fragment\nof HTML before it receives your PUSH_PROMISE, in which case the browser\nwill send a request for \u003ccode\u003ea.css\u003c/code\u003e in addition to receiving your\n\u003ccode\u003ePUSH_PROMISE\u003c/code\u003e. Now the server will generate two responses for \u003ccode\u003ea.css\u003c/code\u003e.\nCalling Push before writing the response avoids this possibility entirely.\u003c/p\u003e\n\u003ch2 id=\"when-to-use-server-push\"\u003eWhen To Use Server Push\u003c/h2\u003e\n\u003cp\u003eConsider using server push any time your network link is idle.\nJust finished sending the HTML for your web app? Don’t waste time waiting,\nstart pushing the resources your client will need. Are you inlining\nresources into your HTML file to reduce latency? Instead of inlining,\ntry pushing. Redirects are another good time to use push because there\nis almost always a wasted round trip while the client follows the redirect.\nThere are many possible scenarios for using push – we are only getting started.\u003c/p\u003e\n\u003cp\u003eWe would be remiss if we did not mention a few caveats. First, you can only\npush resources your server is authoritative for – this means you cannot\npush resources that are hosted on third-party servers or CDNs. Second,\ndon’t push resources unless you are confident they are actually needed\nby the client, otherwise your push wastes bandwidth. A corollary is to\navoid pushing resources when it’s likely that the client already has\nthose resources cached. Third, the naive approach of pushing all\nresources on your page often makes performance worse. When in doubt, measure.\u003c/p\u003e\n\u003cp\u003eThe following links make for good supplemental reading:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://calendar.perfplanet.com/2016/http2-push-the-details/\" rel=\"noreferrer\" target=\"_blank\"\u003eHTTP/2 Push: The Details\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/\" rel=\"noreferrer\" target=\"_blank\"\u003eInnovating with HTTP/2 Server Push\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/h2o/h2o/issues/421\" rel=\"noreferrer\" target=\"_blank\"\u003eCache-Aware Server Push in H2O\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\" rel=\"noreferrer\" target=\"_blank\"\u003eThe PRPL Pattern\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0\" rel=\"noreferrer\" target=\"_blank\"\u003eRules of Thumb for HTTP/2 Push\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://tools.ietf.org/html/rfc7540#section-8.2\" rel=\"noreferrer\" target=\"_blank\"\u003eServer Push in the HTTP/2 spec\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eWith Go 1.8, the standard library provides out-of-the-box support for HTTP/2\nServer Push, giving you more flexibility to optimize your web applications.\u003c/p\u003e\n\u003cp\u003eGo to our \u003ca href=\"https://http2.golang.org/serverpush\" rel=\"noreferrer\" target=\"_blank\"\u003eHTTP/2 Server Push demo\u003c/a\u003e\npage to see it in action.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-03-24T00:00:00Z",
  "Author": "Jaana Burcu Dogan and Tom Bergan"
}