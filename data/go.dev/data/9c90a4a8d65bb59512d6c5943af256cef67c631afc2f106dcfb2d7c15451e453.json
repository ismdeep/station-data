{
  "Source": "go.dev",
  "Title": "Fixing For Loops in Go 1.22",
  "Link": "https://go.dev/blog/loopvar-preview",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/loopvar-preview\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eFixing For Loops in Go 1.22\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      David Chase and Russ Cox\u003cbr/\u003e\n      19 September 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eGo 1.21 includes a preview of a change to \u003ccode\u003efor\u003c/code\u003e loop scoping\nthat we plan to ship in Go 1.22,\nremoving one of the most common Go mistakes.\u003c/p\u003e\n\u003ch2 id=\"the-problem\"\u003eThe Problem\u003c/h2\u003e\n\u003cp\u003eIf you’ve written any amount of Go code, you’ve probably made the mistake\nof keeping a reference to a loop variable past the end of its iteration,\nat which point it takes on a new value that you didn’t want.\nFor example, consider this program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc main() {\n    done := make(chan bool)\n\n    values := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;}\n    for _, v := range values {\n        go func() {\n            fmt.Println(v)\n            done \u0026lt;- true\n        }()\n    }\n\n    // wait for all goroutines to complete before exiting\n    for _ = range values {\n        \u0026lt;-done\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe three created goroutines are all printing the same variable \u003ccode\u003ev\u003c/code\u003e,\nso they usually print “c”, “c”, “c”, instead of printing “a”, “b”, and “c” in some order.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/doc/faq#closures_and_goroutines\"\u003eGo FAQ entry “What happens with closures running as goroutines?”\u003c/a\u003e,\ngives this example and remarks\n“Some confusion may arise when using closures with concurrency.”\u003c/p\u003e\n\u003cp\u003eAlthough concurrency is often involved, it need not be.\nThis example has the same problem but no goroutines:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc main() {\n    var prints []func()\n    for i := 1; i \u0026lt;= 3; i++ {\n        prints = append(prints, func() { fmt.Println(i) })\n    }\n    for _, print := range prints {\n        print()\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis kind of mistake has caused production problems at many companies,\nincluding a\n\u003ca href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=1619047\" rel=\"noreferrer\" target=\"_blank\"\u003epublicly documented issue at Lets Encrypt\u003c/a\u003e.\nIn that instance, the accidental capture of the loop variable was spread across\nmultiple functions and much more difficult to notice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// authz2ModelMapToPB converts a mapping of domain name to authz2Models into a\n// protobuf authorizations map\nfunc authz2ModelMapToPB(m map[string]authz2Model) (*sapb.Authorizations, error) {\n    resp := \u0026amp;sapb.Authorizations{}\n    for k, v := range m {\n        // Make a copy of k because it will be reassigned with each loop.\n        kCopy := k\n        authzPB, err := modelToAuthzPB(\u0026amp;v)\n        if err != nil {\n            return nil, err\n        }\n        resp.Authz = append(resp.Authz, \u0026amp;sapb.Authorizations_MapElement{\n            Domain: \u0026amp;kCopy,\n            Authz: authzPB,\n        })\n    }\n    return resp, nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe author of this code clearly understood the general problem, because they made a copy of \u003ccode\u003ek\u003c/code\u003e,\nbut it turns out \u003ccode\u003emodelToAuthzPB\u003c/code\u003e used pointers to fields in \u003ccode\u003ev\u003c/code\u003e when constructing its result,\nso the loop also needed to make a copy of \u003ccode\u003ev\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eTools have been written to identify these mistakes, but it is hard to analyze\nwhether references to a variable outlive its iteration or not.\nThese tools must choose between false negatives and false positives.\nThe \u003ccode\u003eloopclosure\u003c/code\u003e analyzer used by \u003ccode\u003ego vet\u003c/code\u003e and \u003ccode\u003egopls\u003c/code\u003e opts for false negatives,\nonly reporting when it is sure there is a problem but missing others.\nOther checkers opt for false positives, accusing correct code of being incorrect.\nWe ran an analysis of commits adding \u003ccode\u003ex := x\u003c/code\u003e lines in open-source Go code,\nexpecting to find bug fixes.\nInstead we found many unnecessary lines being added,\nsuggesting instead that popular checkers have significant false positive rates,\nbut developers add the lines anyway to keep the checkers happy.\u003c/p\u003e\n\u003cp\u003eOne pair of examples we found was particularly illuminating:\u003c/p\u003e\n\u003cp\u003eThis diff was in one program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e     for _, informer := range c.informerMap {\n+        informer := informer\n         go informer.Run(stopCh)\n     }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd this diff was in another program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e     for _, a := range alarms {\n+        a := a\n         go a.Monitor(b)\n     }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne of these two diffs is a bug fix; the other is an unnecessary change.\nYou can’t tell which is which unless you know more about the types\nand functions involved.\u003c/p\u003e\n\u003ch2 id=\"the-fix\"\u003eThe Fix\u003c/h2\u003e\n\u003cp\u003eFor Go 1.22, we plan to change \u003ccode\u003efor\u003c/code\u003e loops to make these variables have\nper-iteration scope instead of per-loop scope.\nThis change will fix the examples above, so that they are no longer buggy Go programs;\nit will end the production problems caused by such mistakes;\nand it will remove the need for imprecise tools that prompt users\nto make unnecessary changes to their code.\u003c/p\u003e\n\u003cp\u003eTo ensure backwards compatibility with existing code, the new semantics\nwill only apply in packages contained in modules that declare \u003ccode\u003ego 1.22\u003c/code\u003e or\nlater in their \u003ccode\u003ego.mod\u003c/code\u003e files.\nThis per-module decision provides developer control of a gradual update\nto the new semantics throughout a codebase.\nIt is also possible to use \u003ccode\u003e//go:build\u003c/code\u003e lines to control the decision on a\nper-file basis.\u003c/p\u003e\n\u003cp\u003eOld code will continue to mean exactly what it means today:\nthe fix only applies to new or updated code.\nThis will give developers control over when the semantics change\nin a particular package.\nAs a consequence of our \u003ca href=\"toolchain\"\u003eforward compatibility work\u003c/a\u003e,\nGo 1.21 will not attempt to compile code that declares \u003ccode\u003ego 1.22\u003c/code\u003e or later.\nWe included a special case with the same effect in\nthe point releases Go 1.20.8 and Go 1.19.13,\nso when Go 1.22 is released,\ncode written depending on the new semantics will never be compiled with\nthe old semantics, unless people are using very old, \u003ca href=\"/doc/devel/release#policy\"\u003eunsupported Go versions\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"previewing-the-fix\"\u003ePreviewing The Fix\u003c/h2\u003e\n\u003cp\u003eGo 1.21 includes a preview of the scoping change.\nIf you compile your code with \u003ccode\u003eGOEXPERIMENT=loopvar\u003c/code\u003e set in your environment,\nthen the new semantics are applied to all loops\n(ignoring the \u003ccode\u003ego.mod\u003c/code\u003e \u003ccode\u003ego\u003c/code\u003e lines).\nFor example, to check whether your tests still pass with the new loop semantics\napplied to your package and all your dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGOEXPERIMENT=loopvar go test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe patched our internal Go toolchain at Google to force this mode during all builds\nat the start of May 2023, and in the past four months\nwe have had zero reports of any problems in production code.\u003c/p\u003e\n\u003cp\u003eYou can also try test programs to better understand the semantics\non the Go playground by including a \u003ccode\u003e// GOEXPERIMENT=loopvar\u003c/code\u003e comment\nat the top of the program, like in \u003ca href=\"/play/p/YchKkkA1ETH\"\u003ethis program\u003c/a\u003e.\n(This comment only applies in the Go playground.)\u003c/p\u003e\n\u003ch2 id=\"fixing-buggy-tests\"\u003eFixing Buggy Tests\u003c/h2\u003e\n\u003cp\u003eAlthough we’ve had no production problems,\nto prepare for that switch, we did have to correct many buggy tests that were not\ntesting what they thought they were, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc TestAllEvenBuggy(t *testing.T) {\n    testCases := []int{1, 2, 4, 6}\n    for _, v := range testCases {\n        t.Run(\u0026#34;sub\u0026#34;, func(t *testing.T) {\n            t.Parallel()\n            if v\u0026amp;1 != 0 {\n                t.Fatal(\u0026#34;odd v\u0026#34;, v)\n            }\n        })\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn Go 1.21, this test passes because \u003ccode\u003et.Parallel\u003c/code\u003e blocks each subtest\nuntil the entire loop has finished and then runs all the subtests\nin parallel. When the loop has finished, \u003ccode\u003ev\u003c/code\u003e is always 6,\nso the subtests all check that 6 is even,\nso the test passes.\nOf course, this test really should fail, because 1 is not even.\nFixing for loops exposes this kind of buggy test.\u003c/p\u003e\n\u003cp\u003eTo help prepare for this kind of discovery, we improved the precision\nof the \u003ccode\u003eloopclosure\u003c/code\u003e analyzer in Go 1.21 so that it can identify and\nreport this problem.\nYou can see the report \u003ca href=\"/play/p/WkJkgXRXg0m\"\u003ein this program\u003c/a\u003e on the Go playground.\nIf \u003ccode\u003ego vet\u003c/code\u003e is reporting this kind of problem in your own tests,\nfixing them will prepare you better for Go 1.22.\u003c/p\u003e\n\u003cp\u003eIf you run into other problems,\n\u003ca href=\"/wiki/LoopvarExperiment#my-test-fails-with-the-change-how-can-i-debug-it\"\u003ethe FAQ\u003c/a\u003e\nhas links to examples and details about using a tool we’ve written to identify\nwhich specific loop is causing a test failure when the new semantics are applied.\u003c/p\u003e\n\u003ch2 id=\"more-information\"\u003eMore Information\u003c/h2\u003e\n\u003cp\u003eFor more information about the change, see the\n\u003ca href=\"https://go.googlesource.com/proposal/+/master/design/60078-loopvar.md\" rel=\"noreferrer\" target=\"_blank\"\u003edesign document\u003c/a\u003e\nand the\n\u003ca href=\"/wiki/LoopvarExperiment\"\u003eFAQ\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-09-19T00:00:00Z",
  "Author": "David Chase and Russ Cox"
}