{
  "Source": "go.dev",
  "Title": "Deconstructing Type Parameters",
  "Link": "https://go.dev/blog/deconstructing-type-parameters",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/deconstructing-type-parameters\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eDeconstructing Type Parameters\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Ian Lance Taylor\u003cbr/\u003e\n      26 September 2023\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"slices-package-function-signatures\"\u003eslices package function signatures\u003c/h2\u003e\n\u003cp\u003eThe \u003ca href=\"https://pkg.go.dev/slices#Clone\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eslices.Clone\u003c/code\u003e\u003c/a\u003e function is\npretty simple: it makes a copy of a slice of any type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone[S ~[]E, E any](s S) S {\n    return append(s[:0:0], s...)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works because appending to a slice with zero capacity will\nallocate a new backing array.\nThe function body winds up being shorter than the function signature,\nwhich is in part because the body is short, but also because the\nsignature is long.\nIn this blog post we’ll explain why the signature is written the way\nthat it is.\u003c/p\u003e\n\u003ch2 id=\"simple-clone\"\u003eSimple Clone\u003c/h2\u003e\n\u003cp\u003eWe’ll start by writing a simple generic \u003ccode\u003eClone\u003c/code\u003e function.\nThis is not the one in the \u003ccode\u003eslices\u003c/code\u003e package.\nWe want to take a slice of any element type, and return a new slice.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone1[E any](s []E) []E {\n    // body omitted\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe generic function \u003ccode\u003eClone1\u003c/code\u003e has a single type parameter \u003ccode\u003eE\u003c/code\u003e.\nIt takes a single argument \u003ccode\u003es\u003c/code\u003e which is a slice of type \u003ccode\u003eE\u003c/code\u003e, and it\nreturns a slice of the same type.\nThis signature is straightforward for anybody familiar with generics\nin Go.\u003c/p\u003e\n\u003cp\u003eHowever, there is a problem.\nNamed slice types are not common in Go, but people do use them.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// MySlice is a slice of strings with a special String method.\ntype MySlice []string\n\n// String returns the printable version of a MySlice value.\nfunc (s MySlice) String() string {\n    return strings.Join(s, \u0026#34;+\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s say that we want to make a copy of a \u003ccode\u003eMySlice\u003c/code\u003e and then get the\nprintable version, but with the strings in sorted order.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc PrintSorted(ms MySlice) string {\n    c := Clone1(ms)\n    slices.Sort(c)\n    return c.String() // FAILS TO COMPILE\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnfortunately, this doesn’t work.\nThe compiler reports an error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ec.String undefined (type []string has no field or method String)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can see the problem if we manually instantiate \u003ccode\u003eClone1\u003c/code\u003e by\nreplacing the type parameter with the type argument.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc InstantiatedClone1(s []string) []string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href=\"/ref/spec#Assignability\"\u003eGo assignment rules\u003c/a\u003e allow\nus to pass a value of type \u003ccode\u003eMySlice\u003c/code\u003e to a parameter of type\n\u003ccode\u003e[]string\u003c/code\u003e, so calling \u003ccode\u003eClone1\u003c/code\u003e is fine.\nBut \u003ccode\u003eClone1\u003c/code\u003e will return a value of type \u003ccode\u003e[]string\u003c/code\u003e, not a value of\ntype \u003ccode\u003eMySlice\u003c/code\u003e.\nThe type \u003ccode\u003e[]string\u003c/code\u003e doesn’t have a \u003ccode\u003eString\u003c/code\u003e method, so the compiler\nreports an error.\u003c/p\u003e\n\u003ch2 id=\"flexible-clone\"\u003eFlexible Clone\u003c/h2\u003e\n\u003cp\u003eTo fix this problem, we have to write a version of \u003ccode\u003eClone\u003c/code\u003e that\nreturns the same type as its argument.\nIf we can do that, then when we call \u003ccode\u003eClone\u003c/code\u003e with a value of type\n\u003ccode\u003eMySlice\u003c/code\u003e, it will return a result of type \u003ccode\u003eMySlice\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe know that it has to look something like this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone2[S ?](s S) S // INVALID\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis \u003ccode\u003eClone2\u003c/code\u003e function returns a value that is the same type as its\nargument.\u003c/p\u003e\n\u003cp\u003eHere I’ve written the constraint as \u003ccode\u003e?\u003c/code\u003e, but that’s just a\nplaceholder.\nTo make this work we need to write a constraint that will let us write\nthe body of the function.\nFor \u003ccode\u003eClone1\u003c/code\u003e we could just use a constraint of \u003ccode\u003eany\u003c/code\u003e for the element\ntype.\nFor \u003ccode\u003eClone2\u003c/code\u003e that won’t work: we want to require that \u003ccode\u003es\u003c/code\u003e be a slice\ntype.\u003c/p\u003e\n\u003cp\u003eSince we know we want a slice, the constraint of \u003ccode\u003eS\u003c/code\u003e has to be a\nslice.\nWe don’t care what the slice element type is, so let’s just call it\n\u003ccode\u003eE\u003c/code\u003e, as we did with \u003ccode\u003eClone1\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone3[S []E](s S) S // INVALID\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is still invalid, because we haven’t declared \u003ccode\u003eE\u003c/code\u003e.\nThe type argument for \u003ccode\u003eE\u003c/code\u003e can be any type, which means it also has to\nbe a type parameter itself.\nSince it can be any type, its constraint is \u003ccode\u003eany\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone4[S []E, E any](s S) S\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is getting close, and at least it will compile, but we’re not\nquite there yet.\nIf we compile this version, we get an error when we call \u003ccode\u003eClone4(ms)\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMySlice does not satisfy []string (possibly missing ~ for []string in []string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe compiler is telling us that we can’t use the type argument\n\u003ccode\u003eMySlice\u003c/code\u003e for the type parameter \u003ccode\u003eS\u003c/code\u003e, because \u003ccode\u003eMySlice\u003c/code\u003e does not\nsatisfy the constraint \u003ccode\u003e[]E\u003c/code\u003e.\nThat’s because \u003ccode\u003e[]E\u003c/code\u003e as a constraint only permits a slice type\nliteral, like \u003ccode\u003e[]string\u003c/code\u003e.\nIt doesn’t permit a named type like \u003ccode\u003eMySlice\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"underlying-type-constraints\"\u003eUnderlying type constraints\u003c/h2\u003e\n\u003cp\u003eAs the error message hints, the answer is to add a \u003ccode\u003e~\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone5[S ~[]E, E any](s S) S\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo repeat, writing type parameters and constraints \u003ccode\u003e[S []E, E any]\u003c/code\u003e\nmeans that the type argument for \u003ccode\u003eS\u003c/code\u003e can be any unnamed slice type,\nbut it can’t be a named type defined as a slice literal.\nWriting \u003ccode\u003e[S ~[]E, E any]\u003c/code\u003e, with a \u003ccode\u003e~\u003c/code\u003e, means that the type argument\nfor \u003ccode\u003eS\u003c/code\u003e can be any type whose underlying type is a slice type.\u003c/p\u003e\n\u003cp\u003eFor any named type \u003ccode\u003etype T1 T2\u003c/code\u003e the underlying type of \u003ccode\u003eT1\u003c/code\u003e is the\nunderlying type of \u003ccode\u003eT2\u003c/code\u003e.\nThe underlying type of a predeclared type like \u003ccode\u003eint\u003c/code\u003e or a type literal\nlike \u003ccode\u003e[]string\u003c/code\u003e is just the type itself.\nFor the exact details, \u003ca href=\"/ref/spec#Underlying_types\"\u003esee the language\nspec\u003c/a\u003e.\nIn our example, the underlying type of \u003ccode\u003eMySlice\u003c/code\u003e is \u003ccode\u003e[]string\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSince the underlying type of \u003ccode\u003eMySlice\u003c/code\u003e is a slice, we can pass an\nargument of type \u003ccode\u003eMySlice\u003c/code\u003e to \u003ccode\u003eClone5\u003c/code\u003e.\nAs you may have noticed, the signature of \u003ccode\u003eClone5\u003c/code\u003e is the same as the\nsignature of \u003ccode\u003eslices.Clone\u003c/code\u003e.\nWe’ve finally gotten to where we want to be.\u003c/p\u003e\n\u003cp\u003eBefore we move on, let’s discuss why the Go syntax requires a \u003ccode\u003e~\u003c/code\u003e.\nIt might seem that we would always want to permit passing \u003ccode\u003eMySlice\u003c/code\u003e,\nso why not make that the default?\nOr, if we need to support exact matching, why not flip things around,\nso that a constraint of \u003ccode\u003e[]E\u003c/code\u003e permits a named type while a constraint\nof, say, \u003ccode\u003e=[]E\u003c/code\u003e, only permits slice type literals?\u003c/p\u003e\n\u003cp\u003eTo explain this, let’s first observe that a type parameter list like\n\u003ccode\u003e[T ~MySlice]\u003c/code\u003e doesn’t make sense.\nThat’s because \u003ccode\u003eMySlice\u003c/code\u003e is not the underlying type of any other type.\nFor instance, if we have a definition like \u003ccode\u003etype MySlice2 MySlice\u003c/code\u003e,\nthe underlying type of \u003ccode\u003eMySlice2\u003c/code\u003e is \u003ccode\u003e[]string\u003c/code\u003e, not \u003ccode\u003eMySlice\u003c/code\u003e.\nSo either \u003ccode\u003e[T ~MySlice]\u003c/code\u003e would permit no types at all, or it would be\nthe same as \u003ccode\u003e[T MySlice]\u003c/code\u003e and only match \u003ccode\u003eMySlice\u003c/code\u003e.\nEither way, \u003ccode\u003e[T ~MySlice]\u003c/code\u003e isn’t useful.\nTo avoid this confusion, the language prohibits \u003ccode\u003e[T ~MySlice]\u003c/code\u003e, and\nthe compiler produces an error like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einvalid use of ~ (underlying type of MySlice is []string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf Go didn’t require the tilde, so that \u003ccode\u003e[S []E]\u003c/code\u003e would match any type\nwhose underlying type is \u003ccode\u003e[]E\u003c/code\u003e, then we would have to define the\nmeaning of \u003ccode\u003e[S MySlice]\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe could prohibit \u003ccode\u003e[S MySlice]\u003c/code\u003e, or we could say that \u003ccode\u003e[S MySlice]\u003c/code\u003e\nonly matches \u003ccode\u003eMySlice\u003c/code\u003e, but either approach runs into trouble with\npredeclared types.\nA predeclared type, like \u003ccode\u003eint\u003c/code\u003e is its own underlying type.\nWe want to permit people to be able to write constraints that accept\nany type argument whose underlying type is \u003ccode\u003eint\u003c/code\u003e.\nIn the language today, they can do that by writing \u003ccode\u003e[T ~int]\u003c/code\u003e.\nIf we don’t require the tilde we would still need a way to say “any\ntype whose underlying type is \u003ccode\u003eint\u003c/code\u003e”.\nThe natural way to say that would be \u003ccode\u003e[T int]\u003c/code\u003e.\nThat would mean that \u003ccode\u003e[T MySlice]\u003c/code\u003e and \u003ccode\u003e[T int]\u003c/code\u003e would behave\ndifferently, although they look very similar.\u003c/p\u003e\n\u003cp\u003eWe could perhaps say that \u003ccode\u003e[S MySlice]\u003c/code\u003e matches any type whose\nunderlying type is the underlying type of \u003ccode\u003eMySlice\u003c/code\u003e, but that makes\n\u003ccode\u003e[S MySlice]\u003c/code\u003e unnecessary and confusing.\u003c/p\u003e\n\u003cp\u003eWe think it’s better to require the \u003ccode\u003e~\u003c/code\u003e and be very clear about when\nwe are matching the underlying type rather than the type itself.\u003c/p\u003e\n\u003ch2 id=\"type-inference\"\u003eType inference\u003c/h2\u003e\n\u003cp\u003eNow that we’ve explained the signature of \u003ccode\u003eslices.Clone\u003c/code\u003e, let’s see\nhow actually using \u003ccode\u003eslices.Clone\u003c/code\u003e is simplified by type inference.\nRemember, the signature of \u003ccode\u003eClone\u003c/code\u003e is\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone[S ~[]E, E any](s S) S\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA call of \u003ccode\u003eslices.Clone\u003c/code\u003e will pass a slice to the parameter \u003ccode\u003es\u003c/code\u003e.\nSimple type inference will let the compiler infer that the type\nargument for the type parameter \u003ccode\u003eS\u003c/code\u003e is the type of the slice being\npassed to \u003ccode\u003eClone\u003c/code\u003e.\nType inference is then powerful enough to see that the type argument\nfor \u003ccode\u003eE\u003c/code\u003e is the element type of the type argument passed to \u003ccode\u003eS\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis means that we can write\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e    c := Clone(ms)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewithout having to write\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e    c := Clone[MySlice, string](ms)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we refer to \u003ccode\u003eClone\u003c/code\u003e without calling it, we do have to specify a\ntype argument for \u003ccode\u003eS\u003c/code\u003e, as the compiler has nothing it can use to infer\nit.\nFortunately, in that case, type inference is able to infer the type\nargument for \u003ccode\u003eE\u003c/code\u003e from the argument for \u003ccode\u003eS\u003c/code\u003e, and we don’t have to\nspecify it separately.\u003c/p\u003e\n\u003cp\u003eThat is, we can write\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e    myClone := Clone[MySlice]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewithout having to write\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e    myClone := Clone[MySlice, string]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"deconstructing-type-parameters\"\u003eDeconstructing type parameters\u003c/h2\u003e\n\u003cp\u003eThe general technique we’ve used here, in which we define one type\nparameter \u003ccode\u003eS\u003c/code\u003e using another type parameter \u003ccode\u003eE\u003c/code\u003e, is a way to\ndeconstruct types in generic function signatures.\nBy deconstructing a type, we can name, and constrain, all aspects of\nthe type.\u003c/p\u003e\n\u003cp\u003eFor example, here is the signature for \u003ccode\u003emaps.Clone\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone[M ~map[K]V, K comparable, V any](m M) M\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eJust as with \u003ccode\u003eslices.Clone\u003c/code\u003e, we use a type parameter for the type of\nthe parameter \u003ccode\u003em\u003c/code\u003e, and then deconstruct the type using two other type\nparameters \u003ccode\u003eK\u003c/code\u003e and \u003ccode\u003eV\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn \u003ccode\u003emaps.Clone\u003c/code\u003e we constrain \u003ccode\u003eK\u003c/code\u003e to be comparable, as is required for\na map key type.\nWe can constrain the component types any way we like.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc WithStrings[S ~[]E, E interface { String() string }](s S) (S, []string)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis says that the argument of \u003ccode\u003eWithStrings\u003c/code\u003e must be a slice type for\nwhich the element type has a \u003ccode\u003eString\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eSince all Go types can be built up from component types, we can always\nuse type parameters to deconstruct those types and constrain them as\nwe like.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-09-26T00:00:00Z",
  "Author": "Ian Lance Taylor"
}