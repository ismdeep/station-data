{
  "Source": "go.dev",
  "Title": "When To Use Generics",
  "Link": "https://go.dev/blog/when-generics",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/when-generics\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eWhen To Use Generics\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Ian Lance Taylor\u003cbr/\u003e\n      12 April 2022\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is the blog post version of my talks at Google Open Source Live:\u003c/p\u003e\n\u003cdiv class=\"iframe\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/nr8EpUO9jhw\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" mozallowfullscreen=\"\" webkitallowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003cp\u003eand GopherCon 2021:\u003c/p\u003e\n\u003cdiv class=\"iframe\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/Pa_e9EeCdy8?start=1244\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" mozallowfullscreen=\"\" webkitallowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003cp\u003eThe Go 1.18 release adds a major new language feature: support for\ngeneric programming.\nIn this article I’m not going to describe what generics are nor how to\nuse them.\nThis article is about when to use generics in Go code, and when not to\nuse them.\u003c/p\u003e\n\u003cp\u003eTo be clear, I’ll provide general guidelines, not hard and fast\nrules.\nUse your own judgement.\nBut if you aren’t sure, I recommend using the guidelines discussed\nhere.\u003c/p\u003e\n\u003ch2 id=\"write-code\"\u003eWrite code\u003c/h2\u003e\n\u003cp\u003eLet’s start with a general guideline for programming Go: write Go\nprograms by writing code, not by defining types.\nWhen it comes to generics, if you start writing your program by\ndefining type parameter constraints, you are probably on the wrong\npath.\nStart by writing functions.\nIt’s easy to add type parameters later when it’s clear that they will\nbe useful.\u003c/p\u003e\n\u003ch2 id=\"when-are-type-parameters-useful\"\u003eWhen are type parameters useful?\u003c/h2\u003e\n\u003cp\u003eThat said, let’s look at cases for which type parameters can be\nuseful.\u003c/p\u003e\n\u003ch3 id=\"when-using-language-defined-container-types\"\u003eWhen using language-defined container types\u003c/h3\u003e\n\u003cp\u003eOne case is when writing functions that operate on the special\ncontainer types that are defined by the language: slices, maps, and\nchannels.\nIf a function has parameters with those types, and the function code\ndoesn’t make any particular assumptions about the element types, then\nit may be useful to use a type parameter.\u003c/p\u003e\n\u003cp\u003eFor example, here is a function that returns a slice of all the keys\nin a map of any type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// MapKeys returns a slice of all the keys in m.\n// The keys are not returned in any particular order.\nfunc MapKeys[Key comparable, Val any](m map[Key]Val) []Key {\n    s := make([]Key, 0, len(m))\n    for k := range m {\n        s = append(s, k)\n    }\n    return s\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code doesn’t assume anything about the map key type, and it\ndoesn’t use the map value type at all.\nIt works for any map type.\nThat makes it a good candidate for using type parameters.\u003c/p\u003e\n\u003cp\u003eThe alternative to type parameters for this kind of function is\ntypically to use reflection, but that is a more awkward programming\nmodel, is not statically typechecked at build time, and is often slower\nat run time.\u003c/p\u003e\n\u003ch3 id=\"general-purpose-data-structures\"\u003eGeneral purpose data structures\u003c/h3\u003e\n\u003cp\u003eAnother case where type parameters can be useful is for general\npurpose data structures.\nA general purpose data structure is something like a slice or map, but\none that is not built into the language, such as a linked list, or a\nbinary tree.\u003c/p\u003e\n\u003cp\u003eToday, programs that need such data structures typically do one of two\nthings: write them with a specific element type, or use an interface\ntype.\nReplacing a specific element type with a type parameter can produce a\nmore general data structure that can be used in other parts of the\nprogram, or by other programs.\nReplacing an interface type with a type parameter can permit data to\nbe stored more efficiently, saving memory resources; it can also\npermit the code to avoid type assertions, and to be fully type checked\nat build time.\u003c/p\u003e\n\u003cp\u003eFor example, here is part of what a binary tree data structure might\nlook like using type parameters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Tree is a binary tree.\ntype Tree[T any] struct {\n    cmp  func(T, T) int\n    root *node[T]\n}\n\n// A node in a Tree.\ntype node[T any] struct {\n    left, right  *node[T]\n    val          T\n}\n\n// find returns a pointer to the node containing val,\n// or, if val is not present, a pointer to where it\n// would be placed if added.\nfunc (bt *Tree[T]) find(val T) **node[T] {\n    pl := \u0026amp;bt.root\n    for *pl != nil {\n        switch cmp := bt.cmp(val, (*pl).val); {\n        case cmp \u0026lt; 0:\n            pl = \u0026amp;(*pl).left\n        case cmp \u0026gt; 0:\n            pl = \u0026amp;(*pl).right\n        default:\n            return pl\n        }\n    }\n    return pl\n}\n\n// Insert inserts val into bt if not already there,\n// and reports whether it was inserted.\nfunc (bt *Tree[T]) Insert(val T) bool {\n    pl := bt.find(val)\n    if *pl != nil {\n        return false\n    }\n    *pl = \u0026amp;node[T]{val: val}\n    return true\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEach node in the tree contains a value of the type parameter \u003ccode\u003eT\u003c/code\u003e.\nWhen the tree is instantiated with a particular type argument, values\nof that type will be stored directly in the nodes.\nThey will not be stored as interface types.\u003c/p\u003e\n\u003cp\u003eThis is a reasonable use of type parameters because the \u003ccode\u003eTree\u003c/code\u003e data\nstructure, including the code in the methods, is largely independent\nof the element type \u003ccode\u003eT\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eTree\u003c/code\u003e data structure does need to know how to compare values of\nthe element type \u003ccode\u003eT\u003c/code\u003e; it uses a passed-in comparison function for\nthat.\nYou can see this on the fourth line of the \u003ccode\u003efind\u003c/code\u003e method, in the call\nto \u003ccode\u003ebt.cmp\u003c/code\u003e.\nOther than that, the type parameter doesn’t matter at all.\u003c/p\u003e\n\u003ch3 id=\"for-type-parameters-prefer-functions-to-methods\"\u003eFor type parameters, prefer functions to methods\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003eTree\u003c/code\u003e example illustrates another general guideline: when you\nneed something like a comparison function, prefer a function to a\nmethod.\u003c/p\u003e\n\u003cp\u003eWe could have defined the \u003ccode\u003eTree\u003c/code\u003e type such that the element type is\nrequired to have a \u003ccode\u003eCompare\u003c/code\u003e or \u003ccode\u003eLess\u003c/code\u003e method.\nThis would be done by writing a constraint that requires the method,\nmeaning that any type argument used to instantiate the \u003ccode\u003eTree\u003c/code\u003e type\nwould need to have that method.\u003c/p\u003e\n\u003cp\u003eA consequence would be that anybody who wants to use \u003ccode\u003eTree\u003c/code\u003e with a\nsimple data type like \u003ccode\u003eint\u003c/code\u003e would have to define their own integer\ntype and write their own comparison method.\nIf we define \u003ccode\u003eTree\u003c/code\u003e to take a comparison function, as in the code\nshown above, then it is easy to pass in the desired function.\nIt’s just as easy to write that comparison function as it is to write\na method.\u003c/p\u003e\n\u003cp\u003eIf the \u003ccode\u003eTree\u003c/code\u003e element type happens to already have a \u003ccode\u003eCompare\u003c/code\u003e method,\nthen we can simply use a method expression like \u003ccode\u003eElementType.Compare\u003c/code\u003e\nas the comparison function.\u003c/p\u003e\n\u003cp\u003eTo put it another way, it is much simpler to turn a method into a\nfunction than it is to add a method to a type.\nSo for general purpose data types, prefer a function rather than\nwriting a constraint that requires a method.\u003c/p\u003e\n\u003ch3 id=\"implementing-a-common-method\"\u003eImplementing a common method\u003c/h3\u003e\n\u003cp\u003eAnother case where type parameters can be useful is when different\ntypes need to implement some common method, and the implementations\nfor the different types all look the same.\u003c/p\u003e\n\u003cp\u003eFor example, consider the standard library’s \u003ccode\u003esort.Interface\u003c/code\u003e.\nIt requires that a type implement three methods: \u003ccode\u003eLen\u003c/code\u003e, \u003ccode\u003eSwap\u003c/code\u003e, and\n\u003ccode\u003eLess\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere is an example of a generic type \u003ccode\u003eSliceFn\u003c/code\u003e that implements\n\u003ccode\u003esort.Interface\u003c/code\u003e for any slice type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// SliceFn implements sort.Interface for a slice of T.\ntype SliceFn[T any] struct {\n    s    []T\n    less func(T, T) bool\n}\n\nfunc (s SliceFn[T]) Len() int {\n    return len(s.s)\n}\nfunc (s SliceFn[T]) Swap(i, j int) {\n    s.s[i], s.s[j] = s.s[j], s.s[i]\n}\nfunc (s SliceFn[T]) Less(i, j int) bool {\n    return s.less(s.s[i], s.s[j])\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor any slice type, the \u003ccode\u003eLen\u003c/code\u003e and \u003ccode\u003eSwap\u003c/code\u003e methods are exactly the same.\nThe \u003ccode\u003eLess\u003c/code\u003e method requires a comparison, which is the \u003ccode\u003eFn\u003c/code\u003e part of the\nname \u003ccode\u003eSliceFn\u003c/code\u003e.\nAs with the earlier \u003ccode\u003eTree\u003c/code\u003e example, we will pass in a function when we\ncreate a \u003ccode\u003eSliceFn\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere is how to use \u003ccode\u003eSliceFn\u003c/code\u003e to sort any slice using a comparison\nfunction:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// SortFn sorts s in place using a comparison function.\nfunc SortFn[T any](s []T, less func(T, T) bool) {\n    sort.Sort(SliceFn[T]{s, less})\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is similar to the standard library function \u003ccode\u003esort.Slice\u003c/code\u003e, but the\ncomparison function is written using values rather than slice\nindexes.\u003c/p\u003e\n\u003cp\u003eUsing type parameters for this kind of code is appropriate because the\nmethods look exactly the same for all slice types.\u003c/p\u003e\n\u003cp\u003e(I should mention that Go 1.19–not 1.18–will most likely include a\ngeneric function to sort a slice using a comparison function, and that\ngeneric function will most likely not use \u003ccode\u003esort.Interface\u003c/code\u003e.\nSee \u003ca href=\"/issue/47619\"\u003eproposal #47619\u003c/a\u003e.\nBut the general point is still true even if this specific example will\nmost likely not be useful: it’s reasonable to use type parameters when\nyou need to implement methods that look the same for all the relevant\ntypes.)\u003c/p\u003e\n\u003ch2 id=\"when-are-type-parameters-not-useful\"\u003eWhen are type parameters not useful?\u003c/h2\u003e\n\u003cp\u003eNow let’s talk about the other side of the question: when not to use\ntype parameters.\u003c/p\u003e\n\u003ch3 id=\"dont-replace-interface-types-with-type-parameters\"\u003eDon’t replace interface types with type parameters\u003c/h3\u003e\n\u003cp\u003eAs we all know, Go has interface types.\nInterface types permit a kind of generic programming.\u003c/p\u003e\n\u003cp\u003eFor example, the widely used \u003ccode\u003eio.Reader\u003c/code\u003e interface provides a generic\nmechanism for reading data from any value that contains information\n(for example, a file) or that produces information (for example, a\nrandom number generator).\nIf all you need to do with a value of some type is call a method on\nthat value, use an interface type, not a type parameter.\n\u003ccode\u003eio.Reader\u003c/code\u003e is easy to read, efficient, and effective.\nThere is no need to use a type parameter to read data from a value by\ncalling the \u003ccode\u003eRead\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eFor example, it might be tempting to change the first function\nsignature here, which uses just an interface type, into the second\nversion, which uses a type parameter.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc ReadSome(r io.Reader) ([]byte, error)\n\nfunc ReadSome[T io.Reader](r T) ([]byte, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDon’t make that kind of change.\nOmitting the type parameter makes the function easier to write, easier\nto read, and the execution time will likely be the same.\u003c/p\u003e\n\u003cp\u003eIt’s worth emphasizing the last point.\nWhile it’s possible to implement generics in several different ways,\nand implementations will change and improve over time, the\nimplementation used in Go 1.18 will in many cases treat values whose\ntype is a type parameter much like values whose type is an interface\ntype.\nWhat this means is that using a type parameter will generally not be\nfaster than using an interface type.\nSo don’t change from interface types to type parameters just for\nspeed, because it probably won’t run any faster.\u003c/p\u003e\n\u003ch3 id=\"dont-use-type-parameters-if-method-implementations-differ\"\u003eDon’t use type parameters if method implementations differ\u003c/h3\u003e\n\u003cp\u003eWhen deciding whether to use a type parameter or an interface type,\nconsider the implementation of the methods.\nEarlier we said that if the implementation of a method is the same for\nall types, use a type parameter.\nInversely, if the implementation is different for each type, then use\nan interface type and write different method implementations, don’t\nuse a type parameter.\u003c/p\u003e\n\u003cp\u003eFor example, the implementation of \u003ccode\u003eRead\u003c/code\u003e from a file is nothing like\nthe implementation of \u003ccode\u003eRead\u003c/code\u003e from a random number generator.\nThat means that we should write two different \u003ccode\u003eRead\u003c/code\u003e methods, and\nuse an interface type like \u003ccode\u003eio.Reader\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"use-reflection-where-appropriate\"\u003eUse reflection where appropriate\u003c/h3\u003e\n\u003cp\u003eGo has \u003ca href=\"https://pkg.go.dev/reflect\" rel=\"noreferrer\" target=\"_blank\"\u003erun time reflection\u003c/a\u003e.\nReflection permits a kind of generic programming, in that it permits\nyou to write code that works with any type.\u003c/p\u003e\n\u003cp\u003eIf some operation has to support even types that don’t have methods\n(so that interface types don’t help), and if the operation is\ndifferent for each type (so that type parameters aren’t appropriate),\nuse reflection.\u003c/p\u003e\n\u003cp\u003eAn example of this is the\n\u003ca href=\"https://pkg.go.dev/encoding/json\" rel=\"noreferrer\" target=\"_blank\"\u003eencoding/json\u003c/a\u003e package.\nWe don’t want to require that every type that we encode have a\n\u003ccode\u003eMarshalJSON\u003c/code\u003e method, so we can’t use interface types.\nBut encoding an interface type is nothing like encoding a struct type,\nso we shouldn’t use type parameters.\nInstead, the package uses reflection.\nThe code is not simple, but it works.\nFor details, see \u003ca href=\"/src/encoding/json/encode.go\"\u003ethe source\ncode\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"one-simple-guideline\"\u003eOne simple guideline\u003c/h2\u003e\n\u003cp\u003eIn closing, this discussion of when to use generics can be reduced to\none simple guideline.\u003c/p\u003e\n\u003cp\u003eIf you find yourself writing the exact same code multiple times, where\nthe only difference between the copies is that the code uses different\ntypes, consider whether you can use a type parameter.\u003c/p\u003e\n\u003cp\u003eAnother way to say this is that you should avoid type parameters until\nyou notice that you are about to write the exact same code multiple\ntimes.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-04-12T00:00:00Z",
  "Author": "Ian Lance Taylor"
}