{
  "Source": "go.dev",
  "Title": "Go Concurrency Patterns: Context",
  "Link": "https://go.dev/blog/context",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/context\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Concurrency Patterns: Context\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Sameer Ajmani\u003cbr/\u003e\n      29 July 2014\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn Go servers, each incoming request is handled in its own goroutine.\nRequest handlers often start additional goroutines to access backends such as\ndatabases and RPC services.\nThe set of goroutines working on a request typically needs access to\nrequest-specific values such as the identity of the end user, authorization\ntokens, and the request’s deadline.\nWhen a request is canceled or times out, all the goroutines working on that\nrequest should exit quickly so the system can reclaim any resources they are\nusing.\u003c/p\u003e\n\u003cp\u003eAt Google, we developed a \u003ccode\u003econtext\u003c/code\u003e package that makes it easy to pass\nrequest-scoped values, cancellation signals, and deadlines across API boundaries\nto all the goroutines involved in handling a request.\nThe package is publicly available as\n\u003ca href=\"/pkg/context\"\u003econtext\u003c/a\u003e.\nThis article describes how to use the package and provides a complete working\nexample.\u003c/p\u003e\n\u003ch2 id=\"context\"\u003eContext\u003c/h2\u003e\n\u003cp\u003eThe core of the \u003ccode\u003econtext\u003c/code\u003e package is the \u003ccode\u003eContext\u003c/code\u003e type:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// A Context carries a deadline, cancellation signal, and request-scoped values\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// across API boundaries. Its methods are safe for simultaneous use by multiple\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// goroutines.\u003c/span\u003e\ntype Context interface {\n    \u003cspan class=\"comment\"\u003e// Done returns a channel that is closed when this Context is canceled\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// or times out.\u003c/span\u003e\n    Done() \u0026lt;-chan struct{}\n\n    \u003cspan class=\"comment\"\u003e// Err indicates why this context was canceled, after the Done channel\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// is closed.\u003c/span\u003e\n    Err() error\n\n    \u003cspan class=\"comment\"\u003e// Deadline returns the time when this Context will be canceled, if any.\u003c/span\u003e\n    Deadline() (deadline time.Time, ok bool)\n\n    \u003cspan class=\"comment\"\u003e// Value returns the value associated with key or nil if none.\u003c/span\u003e\n    Value(key interface{}) interface{}\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e(This description is condensed; the\n\u003ca href=\"/pkg/context\"\u003egodoc\u003c/a\u003e is authoritative.)\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eDone\u003c/code\u003e method returns a channel that acts as a cancellation signal to\nfunctions running on behalf of the \u003ccode\u003eContext\u003c/code\u003e: when the channel is closed, the\nfunctions should abandon their work and return.\nThe \u003ccode\u003eErr\u003c/code\u003e method returns an error indicating why the \u003ccode\u003eContext\u003c/code\u003e was canceled.\nThe \u003ca href=\"/blog/pipelines\"\u003ePipelines and Cancellation\u003c/a\u003e article discusses the \u003ccode\u003eDone\u003c/code\u003e\nchannel idiom in more detail.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eContext\u003c/code\u003e does \u003cem\u003enot\u003c/em\u003e have a \u003ccode\u003eCancel\u003c/code\u003e method for the same reason the \u003ccode\u003eDone\u003c/code\u003e\nchannel is receive-only: the function receiving a cancellation signal is usually\nnot the one that sends the signal.\nIn particular, when a parent operation starts goroutines for sub-operations,\nthose sub-operations should not be able to cancel the parent.\nInstead, the \u003ccode\u003eWithCancel\u003c/code\u003e function (described below) provides a way to cancel a\nnew \u003ccode\u003eContext\u003c/code\u003e value.\u003c/p\u003e\n\u003cp\u003eA \u003ccode\u003eContext\u003c/code\u003e is safe for simultaneous use by multiple goroutines.\nCode can pass a single \u003ccode\u003eContext\u003c/code\u003e to any number of goroutines and cancel that\n\u003ccode\u003eContext\u003c/code\u003e to signal all of them.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eDeadline\u003c/code\u003e method allows functions to determine whether they should start\nwork at all; if too little time is left, it may not be worthwhile.\nCode may also use a deadline to set timeouts for I/O operations.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eValue\u003c/code\u003e allows a \u003ccode\u003eContext\u003c/code\u003e to carry request-scoped data.\nThat data must be safe for simultaneous use by multiple goroutines.\u003c/p\u003e\n\u003ch3 id=\"derived-contexts\"\u003eDerived contexts\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003econtext\u003c/code\u003e package provides functions to \u003cem\u003ederive\u003c/em\u003e new \u003ccode\u003eContext\u003c/code\u003e values from\nexisting ones.\nThese values form a tree: when a \u003ccode\u003eContext\u003c/code\u003e is canceled, all \u003ccode\u003eContexts\u003c/code\u003e derived\nfrom it are also canceled.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBackground\u003c/code\u003e is the root of any \u003ccode\u003eContext\u003c/code\u003e tree; it is never canceled:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// Background returns an empty Context. It is never canceled, has no deadline,\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// and has no values. Background is typically used in main, init, and tests,\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// and as the top-level Context for incoming requests.\u003c/span\u003e\nfunc Background() Context\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eWithCancel\u003c/code\u003e and \u003ccode\u003eWithTimeout\u003c/code\u003e return derived \u003ccode\u003eContext\u003c/code\u003e values that can be\ncanceled sooner than the parent \u003ccode\u003eContext\u003c/code\u003e.\nThe \u003ccode\u003eContext\u003c/code\u003e associated with an incoming request is typically canceled when the\nrequest handler returns.\n\u003ccode\u003eWithCancel\u003c/code\u003e is also useful for canceling redundant requests when using multiple\nreplicas.\n\u003ccode\u003eWithTimeout\u003c/code\u003e is useful for setting a deadline on requests to backend servers:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// WithCancel returns a copy of parent whose Done channel is closed as soon as\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// parent.Done is closed or cancel is called.\u003c/span\u003e\nfunc WithCancel(parent Context) (ctx Context, cancel CancelFunc)\n\n\u003cspan class=\"comment\"\u003e// A CancelFunc cancels a Context.\u003c/span\u003e\ntype CancelFunc func()\n\n\u003cspan class=\"comment\"\u003e// WithTimeout returns a copy of parent whose Done channel is closed as soon as\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// parent.Done is closed, cancel is called, or timeout elapses. The new\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// Context\u0026#39;s Deadline is the sooner of now+timeout and the parent\u0026#39;s deadline, if\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// any. If the timer is still running, the cancel function releases its\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// resources.\u003c/span\u003e\nfunc WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eWithValue\u003c/code\u003e provides a way to associate request-scoped values with a \u003ccode\u003eContext\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// WithValue returns a copy of parent whose Value method returns val for key.\u003c/span\u003e\nfunc WithValue(parent Context, key interface{}, val interface{}) Context\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe best way to see how to use the \u003ccode\u003econtext\u003c/code\u003e package is through a worked\nexample.\u003c/p\u003e\n\u003ch2 id=\"example-google-web-search\"\u003eExample: Google Web Search\u003c/h2\u003e\n\u003cp\u003eOur example is an HTTP server that handles URLs like\n\u003ccode\u003e/search?q=golang\u0026amp;timeout=1s\u003c/code\u003e by forwarding the query “golang” to the\n\u003ca href=\"https://developers.google.com/web-search/docs/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle Web Search API\u003c/a\u003e and\nrendering the results.\nThe \u003ccode\u003etimeout\u003c/code\u003e parameter tells the server to cancel the request after that\nduration elapses.\u003c/p\u003e\n\u003cp\u003eThe code is split across three packages:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"context/server/server.go\"\u003eserver\u003c/a\u003e provides the \u003ccode\u003emain\u003c/code\u003e function and the handler for \u003ccode\u003e/search\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"context/userip/userip.go\"\u003euserip\u003c/a\u003e provides functions for extracting a user IP address from a request and associating it with a \u003ccode\u003eContext\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"context/google/google.go\"\u003egoogle\u003c/a\u003e provides the \u003ccode\u003eSearch\u003c/code\u003e function for sending a query to Google.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"the-server-program\"\u003eThe server program\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"context/server/server.go\"\u003eserver\u003c/a\u003e program handles requests like\n\u003ccode\u003e/search?q=golang\u003c/code\u003e by serving the first few Google search results for \u003ccode\u003egolang\u003c/code\u003e.\nIt registers \u003ccode\u003ehandleSearch\u003c/code\u003e to handle the \u003ccode\u003e/search\u003c/code\u003e endpoint.\nThe handler creates an initial \u003ccode\u003eContext\u003c/code\u003e called \u003ccode\u003ectx\u003c/code\u003e and arranges for it to be\ncanceled when the handler returns.\nIf the request includes the \u003ccode\u003etimeout\u003c/code\u003e URL parameter, the \u003ccode\u003eContext\u003c/code\u003e is canceled\nautomatically when the timeout elapses:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc handleSearch(w http.ResponseWriter, req *http.Request) {\n    \u003cspan class=\"comment\"\u003e// ctx is the Context for this handler. Calling cancel closes the\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// ctx.Done channel, which is the cancellation signal for requests\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// started by this handler.\u003c/span\u003e\n    var (\n        ctx    context.Context\n        cancel context.CancelFunc\n    )\n    timeout, err := time.ParseDuration(req.FormValue(\u0026#34;timeout\u0026#34;))\n    if err == nil {\n        \u003cspan class=\"comment\"\u003e// The request has a timeout, so create a context that is\u003c/span\u003e\n        \u003cspan class=\"comment\"\u003e// canceled automatically when the timeout expires.\u003c/span\u003e\n        ctx, cancel = context.WithTimeout(context.Background(), timeout)\n    } else {\n        ctx, cancel = context.WithCancel(context.Background())\n    }\n    defer cancel() \u003cspan class=\"comment\"\u003e// Cancel ctx as soon as handleSearch returns.\u003c/span\u003e\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe handler extracts the query from the request and extracts the client’s IP\naddress by calling on the \u003ccode\u003euserip\u003c/code\u003e package.\nThe client’s IP address is needed for backend requests, so \u003ccode\u003ehandleSearch\u003c/code\u003e\nattaches it to \u003ccode\u003ectx\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    \u003cspan class=\"comment\"\u003e// Check the search query.\u003c/span\u003e\n    query := req.FormValue(\u0026#34;q\u0026#34;)\n    if query == \u0026#34;\u0026#34; {\n        http.Error(w, \u0026#34;no query\u0026#34;, http.StatusBadRequest)\n        return\n    }\n\n    \u003cspan class=\"comment\"\u003e// Store the user IP in ctx for use by code in other packages.\u003c/span\u003e\n    userIP, err := userip.FromRequest(req)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    ctx = userip.NewContext(ctx, userIP)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe handler calls \u003ccode\u003egoogle.Search\u003c/code\u003e with \u003ccode\u003ectx\u003c/code\u003e and the \u003ccode\u003equery\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    \u003cspan class=\"comment\"\u003e// Run the Google search and print the results.\u003c/span\u003e\n    start := time.Now()\n    results, err := google.Search(ctx, query)\n    elapsed := time.Since(start)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eIf the search succeeds, the handler renders the results:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    if err := resultsTemplate.Execute(w, struct {\n        Results          google.Results\n        Timeout, Elapsed time.Duration\n    }{\n        Results: results,\n        Timeout: timeout,\n        Elapsed: elapsed,\n    }); err != nil {\n        log.Print(err)\n        return\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch3 id=\"package-userip\"\u003ePackage userip\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"context/userip/userip.go\"\u003euserip\u003c/a\u003e package provides functions for\nextracting a user IP address from a request and associating it with a \u003ccode\u003eContext\u003c/code\u003e.\nA \u003ccode\u003eContext\u003c/code\u003e provides a key-value mapping, where the keys and values are both of\ntype \u003ccode\u003einterface{}\u003c/code\u003e.\nKey types must support equality, and values must be safe for simultaneous use by\nmultiple goroutines.\nPackages like \u003ccode\u003euserip\u003c/code\u003e hide the details of this mapping and provide\nstrongly-typed access to a specific \u003ccode\u003eContext\u003c/code\u003e value.\u003c/p\u003e\n\u003cp\u003eTo avoid key collisions, \u003ccode\u003euserip\u003c/code\u003e defines an unexported type \u003ccode\u003ekey\u003c/code\u003e and uses\na value of this type as the context key:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e\u003cspan class=\"comment\"\u003e// The key type is unexported to prevent collisions with context keys defined in\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// other packages.\u003c/span\u003e\ntype key int\n\n\u003cspan class=\"comment\"\u003e// userIPkey is the context key for the user IP address.  Its value of zero is\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// arbitrary.  If this package defined other context keys, they would have\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// different integer values.\u003c/span\u003e\nconst userIPKey key = 0\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eFromRequest\u003c/code\u003e extracts a \u003ccode\u003euserIP\u003c/code\u003e value from an \u003ccode\u003ehttp.Request\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc FromRequest(req *http.Request) (net.IP, error) {\n    ip, _, err := net.SplitHostPort(req.RemoteAddr)\n    if err != nil {\n        return nil, fmt.Errorf(\u0026#34;userip: %q is not IP:port\u0026#34;, req.RemoteAddr)\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eNewContext\u003c/code\u003e returns a new \u003ccode\u003eContext\u003c/code\u003e that carries a provided \u003ccode\u003euserIP\u003c/code\u003e value:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc NewContext(ctx context.Context, userIP net.IP) context.Context {\n    return context.WithValue(ctx, userIPKey, userIP)\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eFromContext\u003c/code\u003e extracts a \u003ccode\u003euserIP\u003c/code\u003e from a \u003ccode\u003eContext\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc FromContext(ctx context.Context) (net.IP, bool) {\n    \u003cspan class=\"comment\"\u003e// ctx.Value returns nil if ctx has no value for the key;\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// the net.IP type assertion returns ok=false for nil.\u003c/span\u003e\n    userIP, ok := ctx.Value(userIPKey).(net.IP)\n    return userIP, ok\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch3 id=\"package-google\"\u003ePackage google\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"context/google/google.go\"\u003egoogle.Search\u003c/a\u003e function makes an HTTP request\nto the \u003ca href=\"https://developers.google.com/web-search/docs/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle Web Search API\u003c/a\u003e\nand parses the JSON-encoded result.\nIt accepts a \u003ccode\u003eContext\u003c/code\u003e parameter \u003ccode\u003ectx\u003c/code\u003e and returns immediately if \u003ccode\u003ectx.Done\u003c/code\u003e is\nclosed while the request is in flight.\u003c/p\u003e\n\u003cp\u003eThe Google Web Search API request includes the search query and the user IP as\nquery parameters:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc Search(ctx context.Context, query string) (Results, error) {\n    \u003cspan class=\"comment\"\u003e// Prepare the Google Search API request.\u003c/span\u003e\n    req, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://ajax.googleapis.com/ajax/services/search/web?v=1.0\u0026#34;, nil)\n    if err != nil {\n        return nil, err\n    }\n    q := req.URL.Query()\n    q.Set(\u0026#34;q\u0026#34;, query)\n\n    \u003cspan class=\"comment\"\u003e// If ctx is carrying the user IP address, forward it to the server.\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// Google APIs use the user IP to distinguish server-initiated requests\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// from end-user requests.\u003c/span\u003e\n    if userIP, ok := userip.FromContext(ctx); ok {\n        q.Set(\u0026#34;userip\u0026#34;, userIP.String())\n    }\n    req.URL.RawQuery = q.Encode()\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003eSearch\u003c/code\u003e uses a helper function, \u003ccode\u003ehttpDo\u003c/code\u003e, to issue the HTTP request and cancel\nit if \u003ccode\u003ectx.Done\u003c/code\u003e is closed while the request or response is being processed.\n\u003ccode\u003eSearch\u003c/code\u003e passes a closure to \u003ccode\u003ehttpDo\u003c/code\u003e handle the HTTP response:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    var results Results\n    err = httpDo(ctx, req, func(resp *http.Response, err error) error {\n        if err != nil {\n            return err\n        }\n        defer resp.Body.Close()\n\n        \u003cspan class=\"comment\"\u003e// Parse the JSON search result.\u003c/span\u003e\n        \u003cspan class=\"comment\"\u003e// https://developers.google.com/web-search/docs/#fonje\u003c/span\u003e\n        var data struct {\n            ResponseData struct {\n                Results []struct {\n                    TitleNoFormatting string\n                    URL               string\n                }\n            }\n        }\n        if err := json.NewDecoder(resp.Body).Decode(\u0026amp;data); err != nil {\n            return err\n        }\n        for _, res := range data.ResponseData.Results {\n            results = append(results, Result{Title: res.TitleNoFormatting, URL: res.URL})\n        }\n        return nil\n    })\n    \u003cspan class=\"comment\"\u003e// httpDo waits for the closure we provided to return, so it\u0026#39;s safe to\u003c/span\u003e\n    \u003cspan class=\"comment\"\u003e// read results here.\u003c/span\u003e\n    return results, err\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003ehttpDo\u003c/code\u003e function runs the HTTP request and processes its response in a new\ngoroutine.\nIt cancels the request if \u003ccode\u003ectx.Done\u003c/code\u003e is closed before the goroutine exits:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003efunc httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {\n    \u003cspan class=\"comment\"\u003e// Run the HTTP request in a goroutine and pass the response to f.\u003c/span\u003e\n    c := make(chan error, 1)\n    req = req.WithContext(ctx)\n    go func() { c \u0026lt;- f(http.DefaultClient.Do(req)) }()\n    select {\n    case \u0026lt;-ctx.Done():\n        \u0026lt;-c \u003cspan class=\"comment\"\u003e// Wait for f to return.\u003c/span\u003e\n        return ctx.Err()\n    case err := \u0026lt;-c:\n        return err\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003ch2 id=\"adapting-code-for-contexts\"\u003eAdapting code for Contexts\u003c/h2\u003e\n\u003cp\u003eMany server frameworks provide packages and types for carrying request-scoped\nvalues.\nWe can define new implementations of the \u003ccode\u003eContext\u003c/code\u003e interface to bridge between\ncode using existing frameworks and code that expects a \u003ccode\u003eContext\u003c/code\u003e parameter.\u003c/p\u003e\n\u003cp\u003eFor example, Gorilla’s\n\u003ca href=\"http://www.gorillatoolkit.org/pkg/context\" rel=\"noreferrer\" target=\"_blank\"\u003egithub.com/gorilla/context\u003c/a\u003e\npackage allows handlers to associate data with incoming requests by providing a\nmapping from HTTP requests to key-value pairs.\nIn \u003ca href=\"context/gorilla/gorilla.go\"\u003egorilla.go\u003c/a\u003e, we provide a \u003ccode\u003eContext\u003c/code\u003e\nimplementation whose \u003ccode\u003eValue\u003c/code\u003e method returns the values associated with a\nspecific HTTP request in the Gorilla package.\u003c/p\u003e\n\u003cp\u003eOther packages have provided cancellation support similar to \u003ccode\u003eContext\u003c/code\u003e.\nFor example, \u003ca href=\"https://godoc.org/gopkg.in/tomb.v2\" rel=\"noreferrer\" target=\"_blank\"\u003eTomb\u003c/a\u003e provides a \u003ccode\u003eKill\u003c/code\u003e\nmethod that signals cancellation by closing a \u003ccode\u003eDying\u003c/code\u003e channel.\n\u003ccode\u003eTomb\u003c/code\u003e also provides methods to wait for those goroutines to exit, similar to\n\u003ccode\u003esync.WaitGroup\u003c/code\u003e.\nIn \u003ca href=\"context/tomb/tomb.go\"\u003etomb.go\u003c/a\u003e, we provide a \u003ccode\u003eContext\u003c/code\u003e implementation that\nis canceled when either its parent \u003ccode\u003eContext\u003c/code\u003e is canceled or a provided \u003ccode\u003eTomb\u003c/code\u003e is\nkilled.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eAt Google, we require that Go programmers pass a \u003ccode\u003eContext\u003c/code\u003e parameter as the\nfirst argument to every function on the call path between incoming and outgoing\nrequests.\nThis allows Go code developed by many different teams to interoperate well.\nIt provides simple control over timeouts and cancellation and ensures that\ncritical values like security credentials transit Go programs properly.\u003c/p\u003e\n\u003cp\u003eServer frameworks that want to build on \u003ccode\u003eContext\u003c/code\u003e should provide implementations\nof \u003ccode\u003eContext\u003c/code\u003e to bridge between their packages and those that expect a \u003ccode\u003eContext\u003c/code\u003e\nparameter.\nTheir client libraries would then accept a \u003ccode\u003eContext\u003c/code\u003e from the calling code.\nBy establishing a common interface for request-scoped data and cancellation,\n\u003ccode\u003eContext\u003c/code\u003e makes it easier for package developers to share code for creating\nscalable services.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-07-29T00:00:00Z",
  "Author": "Sameer Ajmani"
}