{
  "Source": "go.dev",
  "Title": "Experiment, Simplify, Ship",
  "Link": "https://go.dev/blog/experiment",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/experiment\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eExperiment, Simplify, Ship\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      1 August 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is the blog post version of my talk last week at GopherCon 2019.\u003c/p\u003e\n\u003cdiv class=\"iframe\"\u003e\n  \u003ciframe src=\"https://www.youtube.com/embed/kNHo788oO5Y?rel=0\" width=\"560\" height=\"315\" frameborder=\"0\" allowfullscreen=\"\" mozallowfullscreen=\"\" webkitallowfullscreen=\"\"\u003e\u003c/iframe\u003e\n\u003c/div\u003e\n\u003cp\u003eWe are all on the path to Go 2, together,\nbut none of us know exactly where that path leads\nor sometimes even which direction the path goes.\nThis post discusses how we actually\nfind and follow the path to Go 2.\nHere’s what the process looks like.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/expsimp1.png\" width=\"179\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eWe experiment with Go as it exists now,\nto understand it better,\nlearning what works well and what doesn’t.\nThen we experiment with possible changes,\nto understand them better,\nagain learning what works well and what doesn’t.\nBased on what we learn from those experiments,\nwe simplify.\nAnd then we experiment again.\nAnd then we simplify again.\nAnd so on.\nAnd so on.\u003c/p\u003e\n\u003ch2 id=\"the-four-rs-of-simplifying\"\u003eThe Four R’s of Simplifying\u003c/h2\u003e\n\u003cp\u003eDuring this process, there are four main ways that we can simplify\nthe overall experience of writing Go programs:\nreshaping, redefining, removing, and restricting.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSimplify by Reshaping\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe first way we simplify is by reshaping what exists into a new form,\none that ends up being simpler overall.\u003c/p\u003e\n\u003cp\u003eEvery Go program we write serves as an experiment to test Go itself.\nIn the early days of Go, we quickly learned that\nit was common to write code like this \u003ccode\u003eaddToList\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc addToList(list []int, x int) []int {\n    n := len(list)\n    if n+1 \u0026gt; cap(list) {\n        big := make([]int, n, (n+5)*2)\n        copy(big, list)\n        list = big\n    }\n    list = list[:n+1]\n    list[n] = x\n    return list\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’d write the same code for slices of bytes,\nand slices of strings, and so on.\nOur programs were too complex, because Go was too simple.\u003c/p\u003e\n\u003cp\u003eSo we took the many functions like \u003ccode\u003eaddToList\u003c/code\u003e in our programs\nand reshaped them into one function provided by Go itself.\nAdding \u003ccode\u003eappend\u003c/code\u003e made the Go language a little more complex,\nbut on balance\nit made the overall experience of writing Go programs simpler,\neven after accounting for the cost of learning about \u003ccode\u003eappend\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere’s another example.\nFor Go 1, we looked at the very many development tools\nin the Go distribution, and we reshaped them into one new command.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e5a      8g\n5g      8l\n5l      cgo\n6a      gobuild\n6cov    gofix         →     go\n6g      goinstall\n6l      gomake\n6nm     gopack\n8a      govet\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e command is so central now that\nit is easy to forget that we went so long without it and how much extra work that involved.\u003c/p\u003e\n\u003cp\u003eWe added code and complexity to the Go distribution,\nbut on balance we simplified the experience of writing Go programs.\nThe new structure also created space for other interesting experiments,\nwhich we’ll see later.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSimplify by Redefining\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA second way we simplify is by redefining\nfunctionality we already have,\nallowing it to do more.\nLike simplifying by reshaping,\nsimplifying by redefining makes programs simpler to write,\nbut now with nothing new to learn.\u003c/p\u003e\n\u003cp\u003eFor example, \u003ccode\u003eappend\u003c/code\u003e was originally defined to read only from slices.\nWhen appending to a byte slice, you could append the bytes from another byte slice,\nbut not the bytes from a string.\nWe redefined append to allow appending from a string,\nwithout adding anything new to the language.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar b []byte\nvar more []byte\nb = append(b, more...) // ok\n\nvar b []byte\nvar more string\nb = append(b, more...) // ok later\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eSimplify by Removing\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA third way we simplify is by removing functionality\nwhen it has turned out to be less useful\nor less important than we expected.\nRemoving functionality means one less thing to learn,\none less thing to fix bugs in,\none less thing to be distracted by or use incorrectly.\nOf course, removing also\nforces users to update existing programs,\nperhaps making them more complex,\nto make up for the removal.\nBut the overall result can still be that the\nprocess of writing Go programs becomes simpler.\u003c/p\u003e\n\u003cp\u003eAn example of this is when we removed\nthe boolean forms of non-blocking channel operations from the language:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eok := c \u0026lt;- x  // before Go 1, was non-blocking send\nx, ok := \u0026lt;-c  // before Go 1, was non-blocking receive\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThese operations were also possible to do using \u003ccode\u003eselect\u003c/code\u003e,\nmaking it confusing to need to decide which form to use.\nRemoving them simplified the language without reducing its power.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSimplify by Restricting\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWe can also simplify by restricting what is allowed.\nFrom day one, Go has restricted the encoding of Go source files:\nthey must be UTF-8.\nThis restriction makes every program that tries to read Go source files simpler.\nThose programs don’t have to worry about Go source files\nencoded in Latin-1 or UTF-16 or UTF-7 or anything else.\u003c/p\u003e\n\u003cp\u003eAnother important restriction is \u003ccode\u003egofmt\u003c/code\u003e for program formatting.\nNothing rejects Go code that isn’t formatted using \u003ccode\u003egofmt\u003c/code\u003e,\nbut we have established a convention that tools that rewrite Go programs\nleave them in \u003ccode\u003egofmt\u003c/code\u003e form.\nIf you keep your programs in \u003ccode\u003egofmt\u003c/code\u003e form too,\nthen these rewriters don’t make any formatting changes.\nWhen you compare before and after,\nthe only diffs you see are real changes.\nThis restriction has simplified program rewriters\nand led to successful experiments like\n\u003ccode\u003egoimports\u003c/code\u003e, \u003ccode\u003egorename\u003c/code\u003e, and many others.\u003c/p\u003e\n\u003ch2 id=\"go-development-process\"\u003eGo Development Process\u003c/h2\u003e\n\u003cp\u003eThis cycle of experiment and simplify is a good model for what we’ve been doing the past ten years.\nbut it has a problem:\nit’s too simple.\nWe can’t only experiment and simplify.\u003c/p\u003e\n\u003cp\u003eWe have to ship the result.\nWe have to make it available to use.\nOf course, using it enables more experiments,\nand possibly more simplifying,\nand the process cycles on and on.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/expsimp2.png\" width=\"326\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eWe shipped Go to all of you for the first time\non November 10, 2009.\nThen, with your help, we shipped Go 1 together in March 2012.\nAnd we’ve shipped twelve Go releases since then.\nAll of these were important milestones,\nto enable more experimentation,\nto help us learn more about Go,\nand of course to make Go available for production use.\u003c/p\u003e\n\u003cp\u003eWhen we shipped Go 1,\nwe explicitly shifted our focus to using Go,\nto understand this version of the language much better\nbefore trying any more simplifications involving\nlanguage changes.\nWe needed to take time to experiment,\nto really understand what works and what doesn’t.\u003c/p\u003e\n\u003cp\u003eOf course, we’ve had twelve releases since Go 1,\nso we have still been experimenting and simplifying and shipping.\nBut we’ve focused on ways to simplify Go development\nwithout significant language changes and without breaking\nexisting Go programs.\nFor example, Go 1.5 shipped the first concurrent garbage collector\nand then the following releases improved it,\nsimplifying Go development by removing pause times as an ongoing concern.\u003c/p\u003e\n\u003cp\u003eAt Gophercon in 2017, we announced that after five years of\nexperimentation, it was again time\nto think about\nsignificant changes that would simplify Go development.\nOur path to Go 2 is really the same as the path to Go 1:\nexperiment and simplify and ship,\ntowards an overall goal of simplifying Go development.\u003c/p\u003e\n\u003cp\u003eFor Go 2, the concrete topics that we believed were\nmost important to address are\nerror handling, generics, and dependencies.\nSince then we have realized that another\nimportant topic is developer tooling.\u003c/p\u003e\n\u003cp\u003eThe rest of this post discusses how\nour work in each of these areas\nfollows that path.\nAlong the way,\nwe’ll take one detour,\nstopping to inspect the technical detail\nof what will be shipping soon in Go 1.13\nfor error handling.\u003c/p\u003e\n\u003ch2 id=\"errors\"\u003eErrors\u003c/h2\u003e\n\u003cp\u003eIt is hard enough to write a program\nthat works the right way in all cases\nwhen all the inputs are valid and correct\nand nothing the program depends on is failing.\nWhen you add errors into the mix,\nwriting a program that works the right way\nno matter what goes wrong is even harder.\u003c/p\u003e\n\u003cp\u003eAs part of thinking about Go 2,\nwe want to understand better\nwhether Go can help make that job any simpler.\u003c/p\u003e\n\u003cp\u003eThere are two different aspects that could\npotentially be simplified:\nerror values and error syntax.\nWe’ll look at each in turn,\nwith the technical detour I promised focusing\non the Go 1.13 error value changes.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eError Values\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eError values had to start somewhere.\nHere is the \u003ccode\u003eRead\u003c/code\u003e function from the first version of the \u003ccode\u003eos\u003c/code\u003e package:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport func Read(fd int64, b *[]byte) (ret int64, errno int64) {\n    r, e := syscall.read(fd, \u0026amp;b[0], int64(len(b)));\n    return r, e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere was no \u003ccode\u003eFile\u003c/code\u003e type yet, and also no error type.\n\u003ccode\u003eRead\u003c/code\u003e and the other functions in the package\nreturned an \u003ccode\u003eerrno int64\u003c/code\u003e directly from the underlying Unix system call.\u003c/p\u003e\n\u003cp\u003eThis code was checked in on September 10, 2008 at 12:14pm.\nLike everything back then, it was an experiment,\nand code changed quickly.\nTwo hours and five minutes later, the API changed:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eexport type Error struct { s string }\n\nfunc (e *Error) Print() { … } // to standard error!\nfunc (e *Error) String() string { … }\n\nexport func Read(fd int64, b *[]byte) (ret int64, err *Error) {\n    r, e := syscall.read(fd, \u0026amp;b[0], int64(len(b)));\n    return r, ErrnoToError(e)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis new API introduced the first \u003ccode\u003eError\u003c/code\u003e type.\nAn error held a string and could return that string\nand also print it to standard error.\u003c/p\u003e\n\u003cp\u003eThe intent here was to generalize beyond integer codes.\nWe knew from past experience\nthat operating system error numbers were too limited\na representation,\nthat it would simplify programs not to have to shoehorn\nall detail about an error into 64 bits.\nUsing error strings had worked reasonably well\nfor us in the past, so we did the same here.\nThis new API lasted seven months.\u003c/p\u003e\n\u003cp\u003eThe next April, after more experience using interfaces,\nwe decided to generalize further\nand allow user-defined error implementations,\nby making the \u003ccode\u003eos.Error\u003c/code\u003e type itself an interface.\nWe simplified by removing the \u003ccode\u003ePrint\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eFor Go 1 two years later,\nbased on a suggestion by Roger Peppe,\n\u003ccode\u003eos.Error\u003c/code\u003e became the built-in \u003ccode\u003eerror\u003c/code\u003e type,\nand the \u003ccode\u003eString\u003c/code\u003e method was renamed to \u003ccode\u003eError\u003c/code\u003e.\nNothing has changed since then.\nBut we have written many Go programs,\nand as a result we have experimented a lot with how\nbest to implement and use errors.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eErrors Are Values\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eMaking \u003ccode\u003eerror\u003c/code\u003e a simple interface\nand allowing many different implementations\nmeans we have the entire Go language\navailable to define and inspect errors.\nWe like to say that \u003ca href=\"/blog/errors-are-values\"\u003eerrors are values\u003c/a\u003e,\nthe same as any other Go value.\u003c/p\u003e\n\u003cp\u003eHere’s an example.\nOn Unix,\nan attempt to dial a network connection\nends up using the \u003ccode\u003econnect\u003c/code\u003e system call.\nThat system call returns a \u003ccode\u003esyscall.Errno\u003c/code\u003e,\nwhich is a named integer type that represents\na system call error number\nand implements the \u003ccode\u003eerror\u003c/code\u003e interface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage syscall\n\ntype Errno int64\n\nfunc (e Errno) Error() string { ... }\n\nconst ECONNREFUSED = Errno(61)\n\n    ... err == ECONNREFUSED ...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003esyscall\u003c/code\u003e package also defines named constants\nfor the host operating system’s defined error numbers.\nIn this case, on this system, \u003ccode\u003eECONNREFUSED\u003c/code\u003e is number 61.\nCode that gets an error from a function\ncan test whether the error is \u003ccode\u003eECONNREFUSED\u003c/code\u003e\nusing ordinary \u003ca href=\"/ref/spec#Comparison_operators\"\u003evalue equality\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMoving up a level,\nin package \u003ccode\u003eos\u003c/code\u003e,\nany system call failure is reported using\na larger error structure that records what\noperation was attempted in addition to the error.\nThere are a handful of these structures.\nThis one, \u003ccode\u003eSyscallError\u003c/code\u003e, describes an error\ninvoking a specific system call\nwith no additional information recorded:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage os\n\ntype SyscallError struct {\n    Syscall string\n    Err     error\n}\n\nfunc (e *SyscallError) Error() string {\n    return e.Syscall + \u0026#34;: \u0026#34; + e.Err.Error()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMoving up another level,\nin package \u003ccode\u003enet\u003c/code\u003e,\nany network failure is reported using an even\nlarger error structure that records the details\nof the surrounding network operation,\nsuch as dial or listen,\nand the network and addresses involved:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage net\n\ntype OpError struct {\n    Op     string\n    Net    string\n    Source Addr\n    Addr   Addr\n    Err    error\n}\n\nfunc (e *OpError) Error() string { ... }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePutting these together,\nthe errors returned by operations like \u003ccode\u003enet.Dial\u003c/code\u003e can format as strings,\nbut they are also structured Go data values.\nIn this case, the error is a \u003ccode\u003enet.OpError\u003c/code\u003e, which adds context\nto an \u003ccode\u003eos.SyscallError\u003c/code\u003e, which adds context to a \u003ccode\u003esyscall.Errno\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ec, err := net.Dial(\u0026#34;tcp\u0026#34;, \u0026#34;localhost:50001\u0026#34;)\n\n// \u0026#34;dial tcp [::1]:50001: connect: connection refused\u0026#34;\n\nerr is \u0026amp;net.OpError{\n    Op:   \u0026#34;dial\u0026#34;,\n    Net:  \u0026#34;tcp\u0026#34;,\n    Addr: \u0026amp;net.TCPAddr{IP: ParseIP(\u0026#34;::1\u0026#34;), Port: 50001},\n    Err: \u0026amp;os.SyscallError{\n        Syscall: \u0026#34;connect\u0026#34;,\n        Err:     syscall.Errno(61), // == ECONNREFUSED\n    },\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we say errors are values, we mean both that\nthe entire Go language is available to define them\nand also that\nthe entire Go language is available to inspect them.\u003c/p\u003e\n\u003cp\u003eHere is an example from package net.\nIt turns out that when you attempt a socket connection,\nmost of the time you will get connected or get connection refused,\nbut sometimes you can get a spurious \u003ccode\u003eEADDRNOTAVAIL\u003c/code\u003e,\nfor no good reason.\nGo shields user programs from this failure mode by retrying.\nTo do this, it has to inspect the error structure to find out\nwhether the \u003ccode\u003esyscall.Errno\u003c/code\u003e deep inside is \u003ccode\u003eEADDRNOTAVAIL\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere is the code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc spuriousENOTAVAIL(err error) bool {\n    if op, ok := err.(*OpError); ok {\n        err = op.Err\n    }\n    if sys, ok := err.(*os.SyscallError); ok {\n        err = sys.Err\n    }\n    return err == syscall.EADDRNOTAVAIL\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA \u003ca href=\"/ref/spec#Type_assertions\"\u003etype assertion\u003c/a\u003e peels away any \u003ccode\u003enet.OpError\u003c/code\u003e wrapping.\nAnd then a second type assertion peels away any \u003ccode\u003eos.SyscallError\u003c/code\u003e wrapping.\nAnd then the function checks the unwrapped error for equality with \u003ccode\u003eEADDRNOTAVAIL\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhat we’ve learned from years of experience,\nfrom this experimenting with Go errors,\nis that it is very powerful to be able to define\narbitrary implementations of the \u003ccode\u003eerror\u003c/code\u003e interface,\nto have the full Go language available\nboth to construct and to deconstruct errors,\nand not to require the use of any single implementation.\u003c/p\u003e\n\u003cp\u003eThese properties—that errors are values,\nand that there is not one required error implementation—are\nimportant to preserve.\u003c/p\u003e\n\u003cp\u003eNot mandating one error implementation\nenabled everyone to experiment with\nadditional functionality that an error might provide,\nleading to many packages,\nsuch as\n\u003ca href=\"https://godoc.org/github.com/pkg/errors\" rel=\"noreferrer\" target=\"_blank\"\u003egithub.com/pkg/errors\u003c/a\u003e,\n\u003ca href=\"https://godoc.org/gopkg.in/errgo.v2\" rel=\"noreferrer\" target=\"_blank\"\u003egopkg.in/errgo.v2\u003c/a\u003e,\n\u003ca href=\"https://godoc.org/github.com/hashicorp/errwrap\" rel=\"noreferrer\" target=\"_blank\"\u003egithub.com/hashicorp/errwrap\u003c/a\u003e,\n\u003ca href=\"https://godoc.org/upspin.io/errors\" rel=\"noreferrer\" target=\"_blank\"\u003eupspin.io/errors\u003c/a\u003e,\n\u003ca href=\"https://godoc.org/github.com/spacemonkeygo/errors\" rel=\"noreferrer\" target=\"_blank\"\u003egithub.com/spacemonkeygo/errors\u003c/a\u003e,\nand more.\u003c/p\u003e\n\u003cp\u003eOne problem with unconstrained experimentation,\nthough, is that as a client\nyou have to program to the union of\nall the possible implementations you might encounter.\nA simplification that seemed worth exploring for Go 2\nwas to define a standard version of commonly-added functionality,\nin the form of agreed-upon optional interfaces,\nso that different implementations could interoperate.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eUnwrap\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe most commonly-added functionality\nin these packages is some method that can be\ncalled to remove context from an error,\nreturning the error inside.\nPackages use different names and meanings\nfor this operation, and sometimes it removes one level of context,\nwhile sometimes it removes as many levels as possible.\u003c/p\u003e\n\u003cp\u003eFor Go 1.13, we have introduced a convention that an error\nimplementation adding removable context to an inner error\nshould implement an \u003ccode\u003eUnwrap\u003c/code\u003e method that returns the inner error,\nunwrapping the context.\nIf there is no inner error appropriate to expose to callers,\neither the error shouldn’t have an \u003ccode\u003eUnwrap\u003c/code\u003e method,\nor the \u003ccode\u003eUnwrap\u003c/code\u003e method should return nil.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Go 1.13 optional method for error implementations.\n\ninterface {\n    // Unwrap removes one layer of context,\n    // returning the inner error if any, or else nil.\n    Unwrap() error\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe way to call this optional method is to invoke the helper function \u003ccode\u003eerrors.Unwrap\u003c/code\u003e,\nwhich handles cases like the error itself being nil or not having an \u003ccode\u003eUnwrap\u003c/code\u003e method at all.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage errors\n\n// Unwrap returns the result of calling\n// the Unwrap method on err,\n// if err’s type defines an Unwrap method.\n// Otherwise, Unwrap returns nil.\nfunc Unwrap(err error) error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can use the \u003ccode\u003eUnwrap\u003c/code\u003e method\nto write a simpler, more general version of \u003ccode\u003espuriousENOTAVAIL\u003c/code\u003e.\nInstead of looking for specific error wrapper implementations\nlike \u003ccode\u003enet.OpError\u003c/code\u003e or \u003ccode\u003eos.SyscallError\u003c/code\u003e,\nthe general version can loop, calling \u003ccode\u003eUnwrap\u003c/code\u003e to remove context,\nuntil either it reaches \u003ccode\u003eEADDRNOTAVAIL\u003c/code\u003e or there’s no error left:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc spuriousENOTAVAIL(err error) bool {\n    for err != nil {\n        if err == syscall.EADDRNOTAVAIL {\n            return true\n        }\n        err = errors.Unwrap(err)\n    }\n    return false\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis loop is so common, though, that Go 1.13 defines a second function, \u003ccode\u003eerrors.Is\u003c/code\u003e,\nthat repeatedly unwraps an error looking for a specific target.\nSo we can replace the entire loop with a single call to \u003ccode\u003eerrors.Is\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc spuriousENOTAVAIL(err error) bool {\n    return errors.Is(err, syscall.EADDRNOTAVAIL)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point we probably wouldn’t even define the function;\nit would be equally clear, and simpler, to call \u003ccode\u003eerrors.Is\u003c/code\u003e directly at the call sites.\u003c/p\u003e\n\u003cp\u003eGo 1.13 also introduces a function \u003ccode\u003eerrors.As\u003c/code\u003e\nthat unwraps until it finds a specific implementation type.\u003c/p\u003e\n\u003cp\u003eIf you want to write code that works with\narbitrarily-wrapped errors,\n\u003ccode\u003eerrors.Is\u003c/code\u003e is the wrapper-aware\nversion of an error equality check:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eerr == target\n\n    →\n\nerrors.Is(err, target)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd \u003ccode\u003eerrors.As\u003c/code\u003e is the wrapper-aware\nversion of an error type assertion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etarget, ok := err.(*Type)\nif ok {\n    ...\n}\n\n    →\n\nvar target *Type\nif errors.As(err, \u0026amp;target) {\n   ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eTo Unwrap Or Not To Unwrap?\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWhether to make it possible to unwrap an error is an API decision,\nthe same way that whether to export a struct field is an API decision.\nSometimes it is appropriate to expose that detail to calling code,\nand sometimes it isn’t.\nWhen it is, implement Unwrap.\nWhen it isn’t, don’t implement Unwrap.\u003c/p\u003e\n\u003cp\u003eUntil now, \u003ccode\u003efmt.Errorf\u003c/code\u003e has not exposed\nan underlying error formatted with \u003ccode\u003e%v\u003c/code\u003e to caller inspection.\nThat is, the result of \u003ccode\u003efmt.Errorf\u003c/code\u003e has not been possible to unwrap.\nConsider this example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// errors.Unwrap(err2) == nil\n// err1 is not available (same as earlier Go versions)\nerr2 := fmt.Errorf(\u0026#34;connect: %v\u0026#34;, err1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf \u003ccode\u003eerr2\u003c/code\u003e is returned to\na caller, that caller has never had any way to open up \u003ccode\u003eerr2\u003c/code\u003e and access \u003ccode\u003eerr1\u003c/code\u003e.\nWe preserved that property in Go 1.13.\u003c/p\u003e\n\u003cp\u003eFor the times when you do want to allow unwrapping the result of \u003ccode\u003efmt.Errorf\u003c/code\u003e,\nwe also added a new printing verb \u003ccode\u003e%w\u003c/code\u003e, which formats like \u003ccode\u003e%v\u003c/code\u003e,\nrequires an error value argument,\nand makes the resulting error’s \u003ccode\u003eUnwrap\u003c/code\u003e method return that argument.\nIn our example, suppose we replace \u003ccode\u003e%v\u003c/code\u003e with \u003ccode\u003e%w\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// errors.Unwrap(err4) == err3\n// (%w is new in Go 1.13)\nerr4 := fmt.Errorf(\u0026#34;connect: %w\u0026#34;, err3)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, if \u003ccode\u003eerr4\u003c/code\u003e is returned to a caller,\nthe caller can use \u003ccode\u003eUnwrap\u003c/code\u003e to retrieve \u003ccode\u003eerr3\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt is important to note that absolute rules like\n“always use \u003ccode\u003e%v\u003c/code\u003e (or never implement \u003ccode\u003eUnwrap\u003c/code\u003e)” or “always use \u003ccode\u003e%w\u003c/code\u003e (or always implement \u003ccode\u003eUnwrap\u003c/code\u003e)”\nare as wrong as absolute rules like “never export struct fields” or “always export struct fields.”\nInstead, the right decision depends on\nwhether callers should be able to inspect and depend on\nthe additional information that using \u003ccode\u003e%w\u003c/code\u003e or implementing \u003ccode\u003eUnwrap\u003c/code\u003e exposes.\u003c/p\u003e\n\u003cp\u003eAs an illustration of this point,\nevery error-wrapping type in the standard library\nthat already had an exported \u003ccode\u003eErr\u003c/code\u003e field\nnow also has an \u003ccode\u003eUnwrap\u003c/code\u003e method returning that field,\nbut implementations with unexported error fields do not,\nand existing uses of \u003ccode\u003efmt.Errorf\u003c/code\u003e with \u003ccode\u003e%v\u003c/code\u003e still use \u003ccode\u003e%v\u003c/code\u003e, not \u003ccode\u003e%w\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eError Value Printing (Abandoned)\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAlong with the design draft for Unwrap,\nwe also published a\n\u003ca href=\"/design/go2draft-error-printing\"\u003edesign draft for an optional method for richer error printing\u003c/a\u003e,\nincluding stack frame information\nand support for localized, translated errors.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Optional method for error implementations\ntype Formatter interface {\n    Format(p Printer) (next error)\n}\n\n// Interface passed to Format\ntype Printer interface {\n    Print(args ...interface{})\n    Printf(format string, args ...interface{})\n    Detail() bool\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis one is not as simple as \u003ccode\u003eUnwrap\u003c/code\u003e,\nand I won’t go into the details here.\nAs we discussed the design with the Go community over the winter,\nwe learned that the design wasn’t simple enough.\nIt was too hard for individual error types to implement,\nand it did not help existing programs enough.\nOn balance, it did not simplify Go development.\u003c/p\u003e\n\u003cp\u003eAs a result of this community discussion,\nwe abandoned this printing design.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eError Syntax\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThat was error values.\nLet’s look briefly at error syntax,\nanother abandoned experiment.\u003c/p\u003e\n\u003cp\u003eHere is some code from\n\u003ca href=\"https://go.googlesource.com/go/+/go1.12/src/compress/lzw/writer.go#209\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ecompress/lzw/writer.go\u003c/code\u003e\u003c/a\u003e in the standard library:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Write the savedCode if valid.\nif e.savedCode != invalidCode {\n    if err := e.write(e, e.savedCode); err != nil {\n        return err\n    }\n    if err := e.incHi(); err != nil \u0026amp;\u0026amp; err != errOutOfCodes {\n        return err\n    }\n}\n\n// Write the eof code.\neof := uint32(1)\u0026lt;\u0026lt;e.litWidth + 1\nif err := e.write(e, eof); err != nil {\n    return err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt a glance, this code is about half error checks.\nMy eyes glaze over when I read it.\nAnd we know that code that is tedious to write and tedious to read is easy to misread,\nmaking it a good home for hard-to-find bugs.\nFor example, one of these three error checks is not like the others,\na fact that is easy to miss on a quick skim.\nIf you were debugging this code, how long would it take to notice that?\u003c/p\u003e\n\u003cp\u003eAt Gophercon last year we\n\u003ca href=\"/design/go2draft-error-handling\"\u003epresented a draft design\u003c/a\u003e\nfor a new control flow construct marked by the keyword \u003ccode\u003echeck\u003c/code\u003e.\n\u003ccode\u003eCheck\u003c/code\u003e consumes the error result from a function call or expression.\nIf the error is non-nil, the \u003ccode\u003echeck\u003c/code\u003e returns that error.\nOtherwise the \u003ccode\u003echeck\u003c/code\u003e evaluates to the other results\nfrom the call. We can use \u003ccode\u003echeck\u003c/code\u003e to simplify the lzw code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Write the savedCode if valid.\nif e.savedCode != invalidCode {\n    check e.write(e, e.savedCode)\n    if err := e.incHi(); err != errOutOfCodes {\n        check err\n    }\n}\n\n// Write the eof code.\neof := uint32(1)\u0026lt;\u0026lt;e.litWidth + 1\ncheck e.write(e, eof)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis version of the same code uses \u003ccode\u003echeck\u003c/code\u003e,\nwhich removes four lines of code and\nmore importantly highlights that\nthe call to \u003ccode\u003ee.incHi\u003c/code\u003e is allowed to return \u003ccode\u003eerrOutOfCodes\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eMaybe most importantly,\nthe design also allowed defining error handler blocks\nto be run when later checks failed.\nThat would let you write shared context-adding code just once,\nlike in this snippet:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehandle err {\n    err = fmt.Errorf(\u0026#34;closing writer: %w\u0026#34;, err)\n}\n\n// Write the savedCode if valid.\nif e.savedCode != invalidCode {\n    check e.write(e, e.savedCode)\n    if err := e.incHi(); err != errOutOfCodes {\n        check err\n    }\n}\n\n// Write the eof code.\neof := uint32(1)\u0026lt;\u0026lt;e.litWidth + 1\ncheck e.write(e, eof)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn essence, \u003ccode\u003echeck\u003c/code\u003e was a short way to write the \u003ccode\u003eif\u003c/code\u003e statement,\nand \u003ccode\u003ehandle\u003c/code\u003e was like\n\u003ca href=\"/ref/spec#Defer_statements\"\u003e\u003ccode\u003edefer\u003c/code\u003e\u003c/a\u003e but only for error return paths.\nIn contrast to exceptions in other languages,\nthis design retained Go’s important property that\nevery potential failing call was marked explicitly in the code,\nnow using the \u003ccode\u003echeck\u003c/code\u003e keyword instead of \u003ccode\u003eif err != nil\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe big problem with this design\nwas that \u003ccode\u003ehandle\u003c/code\u003e overlapped too much,\nand in confusing ways, with \u003ccode\u003edefer\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn May we posted\n\u003ca href=\"/design/32437-try-builtin\"\u003ea new design with three simplifications\u003c/a\u003e:\nto avoid the confusion with \u003ccode\u003edefer\u003c/code\u003e, the design dropped \u003ccode\u003ehandle\u003c/code\u003e in favor of just using \u003ccode\u003edefer\u003c/code\u003e;\nto match a similar idea in Rust and Swift, the design renamed \u003ccode\u003echeck\u003c/code\u003e to \u003ccode\u003etry\u003c/code\u003e;\nand to allow experimentation in a way that existing parsers like \u003ccode\u003egofmt\u003c/code\u003e would recognize,\nit changed \u003ccode\u003echeck\u003c/code\u003e (now \u003ccode\u003etry\u003c/code\u003e) from a keyword to a built-in function.\u003c/p\u003e\n\u003cp\u003eNow the same code would look like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edefer errd.Wrapf(\u0026amp;err, \u0026#34;closing writer\u0026#34;)\n\n// Write the savedCode if valid.\nif e.savedCode != invalidCode {\n    try(e.write(e, e.savedCode))\n    if err := e.incHi(); err != errOutOfCodes {\n        try(err)\n    }\n}\n\n// Write the eof code.\neof := uint32(1)\u0026lt;\u0026lt;e.litWidth + 1\ntry(e.write(e, eof))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe spent most of June discussing this proposal publicly on GitHub.\u003c/p\u003e\n\u003cp\u003eThe fundamental idea of \u003ccode\u003echeck\u003c/code\u003e or \u003ccode\u003etry\u003c/code\u003e was to shorten\nthe amount of syntax repeated at each error check,\nand in particular to remove the \u003ccode\u003ereturn\u003c/code\u003e statement from view,\nkeeping the error check explicit and better highlighting interesting variations.\nOne interesting point raised during the public feedback discussion,\nhowever, was that without an explicit \u003ccode\u003eif\u003c/code\u003e statement and \u003ccode\u003ereturn\u003c/code\u003e,\nthere’s nowhere to put a debugging print,\nthere’s nowhere to put a breakpoint,\nand there’s no code to show as unexecuted in code coverage results.\nThe benefits we were after\ncame at the cost of making these situations more complex.\nOn balance, from this as well as other considerations,\nit was not at all clear that the overall result would\nbe simpler Go development,\nso we abandoned this experiment.\u003c/p\u003e\n\u003cp\u003eThat’s everything about error handling,\nwhich was one of the main focuses for this year.\u003c/p\u003e\n\u003ch2 id=\"generics\"\u003eGenerics\u003c/h2\u003e\n\u003cp\u003eNow for something a little less controversial: generics.\u003c/p\u003e\n\u003cp\u003eThe second big topic we identified for Go 2 was\nsome kind of way to write code with\ntype parameters.\nThis would enable writing generic data structures\nand also writing generic functions that\nwork with any kind of slice,\nor any kind of channel,\nor any kind of map.\nFor example, here is a generic channel filter:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Filter copies values from c to the returned channel,\n// passing along only those values satisfying f.\nfunc Filter(type value)(f func(value) bool, c \u0026lt;-chan value) \u0026lt;-chan value {\n    out := make(chan value)\n    go func() {\n        for v := range c {\n            if f(v) {\n                out \u0026lt;- v\n            }\n        }\n        close(out)\n    }()\n    return out\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe’ve been thinking about generics since work on Go began,\nand we wrote and rejected our first concrete design in 2010.\nWe wrote and rejected three more designs by the end of 2013.\nFour abandoned experiments,\nbut not failed experiments,\nWe learned from them,\nlike we learned from \u003ccode\u003echeck\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e.\nEach time, we learned that the path to Go 2 is not in that exact direction,\nand we noticed other directions that might be interesting to explore.\nBut by 2013 we had decided that we needed to focus on other concerns,\nso we put the entire topic aside for a few years.\u003c/p\u003e\n\u003cp\u003eLast year we started exploring and experimenting again,\nand we presented a\n\u003ca href=\"https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md\" rel=\"noreferrer\" target=\"_blank\"\u003enew design\u003c/a\u003e,\nbased on the idea of a contract,\nat Gophercon last summer.\nWe’ve continued to experiment and simplify,\nand we’ve been working\nwith programming language theory experts\nto understand the design better.\u003c/p\u003e\n\u003cp\u003eOverall, I am hopeful that we’re headed in a good direction,\ntoward a design that will simplify Go development.\nEven so, we might find that this design doesn’t work either.\nWe might have to abandon this experiment\nand adjust our path based on what we learned.\nWe’ll find out.\u003c/p\u003e\n\u003cp\u003eAt Gophercon 2019, Ian Lance Taylor talked about\nwhy we might want to add generics to Go\nand briefly previewed the latest design draft.\nFor details, see his blog post “\u003ca href=\"/blog/why-generics\"\u003eWhy Generics?\u003c/a\u003e”\u003c/p\u003e\n\u003ch2 id=\"dependencies\"\u003eDependencies\u003c/h2\u003e\n\u003cp\u003eThe third big topic we identified for Go 2 was dependency management.\u003c/p\u003e\n\u003cp\u003eIn 2010 we published a tool called \u003ccode\u003egoinstall\u003c/code\u003e,\nwhich we called\n“\u003ca href=\"https://groups.google.com/forum/#!msg/golang-nuts/8JFwR3ESjjI/cy7qZzN7Lw4J\" rel=\"noreferrer\" target=\"_blank\"\u003ean experiment in package installation\u003c/a\u003e.”\nIt downloaded dependencies and stored them in your\nGo distribution tree, in GOROOT.\u003c/p\u003e\n\u003cp\u003eAs we experimented with \u003ccode\u003egoinstall\u003c/code\u003e,\nwe learned that the Go distribution and the installed packages\nshould be kept separate,\nso that it was possible to change to a new Go distribution\nwithout losing all your Go packages.\nSo in 2011 we introduced \u003ccode\u003eGOPATH\u003c/code\u003e,\nan environment variable that specified\nwhere to look for packages not found in the main Go distribution.\u003c/p\u003e\n\u003cp\u003eAdding GOPATH created more places for Go packages\nbut simplified Go development overall,\nby separating your Go distribution from your Go libraries.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eCompatibility\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003egoinstall\u003c/code\u003e experiment intentionally left out\nan explicit concept of package versioning.\nInstead, \u003ccode\u003egoinstall\u003c/code\u003e always downloaded the latest copy.\nWe did this so we could focus on the other\ndesign problems for package installation.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGoinstall\u003c/code\u003e became \u003ccode\u003ego get\u003c/code\u003e as part of Go 1.\nWhen people asked about versions,\nwe encouraged them to experiment by\ncreating additional tools, and they did.\nAnd we encouraged package authors\nto provide their users\nwith the same backwards compatibility\nwe did for the Go 1 libraries.\nQuoting \u003ca href=\"/doc/faq#get_version\"\u003ethe Go FAQ\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em; font-style: italic;\"\u003e\n\u003cp\u003e“Packages intended for public use should try to maintain backwards compatibility as they evolve.\u003c/p\u003e\n\u003cp\u003eIf different functionality is required,\nadd a new name instead of changing an old one.\u003c/p\u003e\n\u003cp\u003eIf a complete break is required,\ncreate a new package with a new import path.”\u003c/p\u003e\n\u003c/div\u003e\n\u003cp\u003eThis convention\nsimplifies the overall experience of using a package\nby restricting what authors can do:\navoid breaking changes to APIs;\ngive new functionality a new name;\nand\ngive a whole new package design a new import path.\u003c/p\u003e\n\u003cp\u003eOf course, people kept experimenting.\nOne of the most interesting experiments\nwas started by Gustavo Niemeyer.\nHe created a Git redirector called\n\u003ca href=\"https://gopkg.in\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egopkg.in\u003c/code\u003e\u003c/a\u003e,\nwhich provided different import paths\nfor different API versions,\nto help package authors\nfollow the convention\nof giving a new package design\na new import path.\u003c/p\u003e\n\u003cp\u003eFor example,\nthe Go source code in the GitHub repository\n\u003ca href=\"https://github.com/go-yaml/yaml\" rel=\"noreferrer\" target=\"_blank\"\u003ego-yaml/yaml\u003c/a\u003e\nhas different APIs\nin the v1 and v2 semantic version tags.\nThe \u003ccode\u003egopkg.in\u003c/code\u003e server provides these with\ndifferent import paths\n\u003ca href=\"https://godoc.org/gopkg.in/yaml.v1\" rel=\"noreferrer\" target=\"_blank\"\u003egopkg.in/yaml.v1\u003c/a\u003e\nand\n\u003ca href=\"https://godoc.org/gopkg.in/yaml.v2\" rel=\"noreferrer\" target=\"_blank\"\u003egopkg.in/yaml.v2\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe convention of providing backwards compatibility,\nso that a newer version of a package can be used\nin place of an older version,\nis what makes \u003ccode\u003ego get\u003c/code\u003e’s very simple rule—“always download the latest copy”—work well even today.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eVersioning And Vendoring\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBut in production contexts you need to be more precise\nabout dependency versions, to make builds reproducible.\u003c/p\u003e\n\u003cp\u003eMany people experimented with what that should look like,\nbuilding tools that served their needs,\nincluding Keith Rarick’s \u003ccode\u003egoven\u003c/code\u003e (2012) and \u003ccode\u003egodep\u003c/code\u003e (2013),\nMatt Butcher’s \u003ccode\u003eglide\u003c/code\u003e (2014), and Dave Cheney’s \u003ccode\u003egb\u003c/code\u003e (2015).\nAll of these tools use the model that you copy dependency\npackages into your own source control repository.\nThe exact mechanisms used\nto make those packages available for import varied,\nbut they were all more complex than it seemed they should be.\u003c/p\u003e\n\u003cp\u003eAfter a community-wide discussion,\nwe adopted a proposal by Keith Rarick\nto add explicit support for referring to copied dependencies\nwithout GOPATH tricks.\nThis was simplifying by reshaping:\nlike with \u003ccode\u003eaddToList\u003c/code\u003e and \u003ccode\u003eappend\u003c/code\u003e,\nthese tools were already implementing the concept,\nbut it was more awkward than it needed to be.\nAdding explicit support for vendor directories\nmade these uses simpler overall.\u003c/p\u003e\n\u003cp\u003eShipping vendor directories in the \u003ccode\u003ego\u003c/code\u003e command\nled to more experimentation with vendoring itself,\nand we realized that we had introduced a few problems.\nThe most serious was that we lost \u003cem\u003epackage uniqueness\u003c/em\u003e.\nBefore, during any given build,\nan import path\nmight appear in lots of different packages,\nand all the imports referred to the same target.\nNow with vendoring, the same import path in different\npackages might refer to different vendored copies of the package,\nall of which would appear in the final resulting binary.\u003c/p\u003e\n\u003cp\u003eAt the time, we didn’t have a name for this property:\npackage uniqueness.\nIt was just how the GOPATH model worked.\nWe didn’t completely appreciate it until it went away.\u003c/p\u003e\n\u003cp\u003eThere is a parallel here with the \u003ccode\u003echeck\u003c/code\u003e and \u003ccode\u003etry\u003c/code\u003e\nerror syntax proposals.\nIn that case, we were relying\non how the visible \u003ccode\u003ereturn\u003c/code\u003e statement worked\nin ways we didn’t appreciate\nuntil we considered removing it.\u003c/p\u003e\n\u003cp\u003eWhen we added vendor directory support,\nthere were many different tools for managing dependencies.\nWe thought that a clear agreement\nabout the format of vendor directories\nand vendoring metadata\nwould allow the various tools to interoperate,\nthe same way that agreement about\nhow Go programs are stored in text files\nenables interoperation\nbetween the Go compiler, text editors,\nand tools like \u003ccode\u003egoimports\u003c/code\u003e and \u003ccode\u003egorename\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThis turned out to be naively optimistic.\nThe vendoring tools all differed in subtle semantic ways.\nInteroperation would require changing them all\nto agree about the semantics,\nlikely breaking their respective users.\nConvergence did not happen.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDep\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eAt Gophercon in 2016, we started an effort\nto define a single tool to manage dependencies.\nAs part of that effort, we conducted surveys\nwith many different kinds of users\nto understand what they needed\nas far as dependency management,\nand a team started work on a new tool,\nwhich became \u003ccode\u003edep\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDep\u003c/code\u003e aimed to be able to replace all the\nexisting dependency management tools.\nThe goal was to simplify by reshaping the\nexisting different tools into a single one.\nIt partly accomplished that.\n\u003ccode\u003eDep\u003c/code\u003e also restored package uniqueness for its users,\nby having only one vendor directory\nat the top of the project tree.\u003c/p\u003e\n\u003cp\u003eBut \u003ccode\u003edep\u003c/code\u003e also introduced a serious problem\nthat took us a while to fully appreciate.\nThe problem was that \u003ccode\u003edep\u003c/code\u003e embraced a design choice from \u003ccode\u003eglide\u003c/code\u003e,\nto support and encourage incompatible changes to a given package\nwithout changing the import path.\u003c/p\u003e\n\u003cp\u003eHere is an example.\nSuppose you are building your own program,\nand you need to have a configuration file,\nso you use version 2 of a popular Go YAML package:\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/yamldeps1.png\" width=\"214\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eNow suppose your program\nimports the Kubernetes client.\nIt turns out that Kubernetes uses YAML extensively,\nand it uses version 1 of the same popular package:\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/yamldeps2.png\" width=\"557\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eVersion 1 and version 2 have incompatible APIs,\nbut they also have different import paths,\nso there is no ambiguity about which is meant by a given import.\nKubernetes gets version 1,\nyour config parser gets version 2,\nand everything works.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDep\u003c/code\u003e abandoned this model.\nVersion 1 and version 2 of the yaml package would now\nhave the same import path,\nproducing a conflict.\nUsing the same import path for two incompatible versions,\ncombined with package uniqueness,\nmakes it impossible to build this program\nthat you could build before:\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/yamldeps3.png\" width=\"450\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eIt took us a while to understand this problem,\nbecause we had been applying the\n“new API means new import path”\nconvention for so long that we took it for granted.\nThe dep experiment helped us\nappreciate that convention better,\nand we gave it a name:\nthe \u003cem\u003eimport compatibility rule\u003c/em\u003e:\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em; font-style: italic;\"\u003e\n\u003cp\u003e“If an old package and a new package have the same import path,\nthe new package must be backwards compatible with the old package.”\u003c/p\u003e\n\u003c/div\u003e\n\u003cp\u003e\u003cstrong\u003eGo Modules\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWe took what worked well in the dep experiment\nand what we learned about what didn’t work well,\nand we experimented with a new design, called \u003ccode\u003evgo\u003c/code\u003e.\nIn \u003ccode\u003evgo\u003c/code\u003e, packages followed the import compatibility rule,\nso that we can provide package uniqueness\nbut still not break builds like the one we just looked at.\nThis let us simplify other parts of the design as well.\u003c/p\u003e\n\u003cp\u003eBesides restoring the import compatibility rule,\nanother important part of the \u003ccode\u003evgo\u003c/code\u003e design\nwas to give the concept of a group of packages a name\nand to allow that grouping to be separated\nfrom source code repository boundaries.\nThe name of a group of Go packages is a module,\nso we refer to the system now as Go modules.\u003c/p\u003e\n\u003cp\u003eGo modules are now integrated with the \u003ccode\u003ego\u003c/code\u003e command,\nwhich avoids needing to copy around vendor directories at all.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eReplacing GOPATH\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eWith Go modules comes the end of GOPATH as a\nglobal name space.\nNearly all the hard work of converting existing Go usage\nand tools to modules is caused by this change,\nfrom moving away from GOPATH.\u003c/p\u003e\n\u003cp\u003eThe fundamental idea of GOPATH\nis that the GOPATH directory tree\nis the global source of truth\nfor what versions are being used,\nand the versions being used don’t change\nas you move around between directories.\nBut the global GOPATH mode is in direct\nconflict with the production requirement of\nper-project reproducible builds,\nwhich itself simplifies the Go development\nand deployment experience in many important ways.\u003c/p\u003e\n\u003cp\u003ePer-project reproducible builds means that\nwhen you are working in a checkout of project A,\nyou get the same set of dependency versions that the other developers of project A get\nat that commit,\nas defined by the \u003ccode\u003ego.mod\u003c/code\u003e file.\nWhen you switch to working in a checkout of project B,\nnow you get that project’s chosen dependency versions,\nthe same set that the other developers of project B get.\nBut those are likely different from project A.\nThe set of dependency versions\nchanging when you move from project A to project B\nis necessary to keep your development in sync\nwith that of the other developers on A and on B.\nThere can’t be a single global GOPATH anymore.\u003c/p\u003e\n\u003cp\u003eMost of the complexity of adopting modules\narises directly from the loss of the one global GOPATH.\nWhere is the source code for a package?\nBefore, the answer depended only on your GOPATH environment variable,\nwhich most people rarely changed.\nNow, the answer depends on what project you are working on,\nwhich may change often.\nEverything needs updating for this new convention.\u003c/p\u003e\n\u003cp\u003eMost development tools use the\n\u003ca href=\"https://godoc.org/go/build\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ego/build\u003c/code\u003e\u003c/a\u003e package to find and load Go source code.\nWe’ve kept that package working,\nbut the API did not anticipate modules,\nand the workarounds we added to avoid API changes\nare slower than we’d like.\nWe’ve published a replacement,\n\u003ca href=\"https://godoc.org/golang.org/x/tools/go/packages\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/tools/go/packages\u003c/code\u003e\u003c/a\u003e.\nDeveloper tools should now use that instead.\nIt supports both GOPATH and Go modules,\nand it is faster and easier to use.\nIn a release or two we may move it into the standard library,\nbut for now \u003ca href=\"https://godoc.org/golang.org/x/tools/go/packages\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egolang.org/x/tools/go/packages\u003c/code\u003e\u003c/a\u003e\nis stable and ready for use.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGo Module Proxies\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eOne of the ways modules simplify Go development\nis by separating the concept of a group of packages\nfrom the underlying source control repository\nwhere they are stored.\u003c/p\u003e\n\u003cp\u003eWhen we talked to Go users about dependencies,\nalmost everyone using Go at their companies\nasked how to route \u003ccode\u003ego get\u003c/code\u003e package fetches\nthrough their own servers,\nto better control what code can be used.\nAnd even open-source developers were concerned\nabout dependencies disappearing\nor changing unexpectedly,\nbreaking their builds.\nBefore modules, users had attempted\ncomplex solutions to these problems,\nincluding intercepting the version control\ncommands that the \u003ccode\u003ego\u003c/code\u003e command runs.\u003c/p\u003e\n\u003cp\u003eThe Go modules design makes it easy\nto introduce the idea of a module proxy\nthat can be asked for a specific module version.\u003c/p\u003e\n\u003cp\u003eCompanies can now easily run their own module proxy,\nwith custom rules about what is allowed\nand where cached copies are stored.\nThe open-source \u003ca href=\"https://docs.gomods.io\" rel=\"noreferrer\" target=\"_blank\"\u003eAthens project\u003c/a\u003e has built just such a proxy,\nand Aaron Schlesinger gave a talk about it at Gophercon 2019.\n(We’ll add a link here when the video becomes available.)\u003c/p\u003e\n\u003cp\u003eAnd for individual developers and open source teams,\nthe Go team at Google has \u003ca href=\"https://groups.google.com/forum/#!topic/golang-announce/0wo8cOhGuAI\" rel=\"noreferrer\" target=\"_blank\"\u003elaunched a proxy\u003c/a\u003e that serves\nas a public mirror of all open-source Go packages,\nand Go 1.13 will use that proxy by default when in module mode.\nKatie Hockman gave a \u003ca href=\"https://youtu.be/KqTySYYhPUE\" rel=\"noreferrer\" target=\"_blank\"\u003etalk about this system at Gophercon 2019\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGo Modules Status\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eGo 1.11 introduced modules as an experimental, opt-in preview.\nWe keep experimenting and simplifying.\nGo 1.12 shipped improvements,\nand Go 1.13 will ship more improvements.\u003c/p\u003e\n\u003cp\u003eModules are now at the point\nwhere we believe that they will serve most users,\nbut we aren’t ready to shut down GOPATH just yet.\nWe will keep experimenting, simplifying, and revising.\u003c/p\u003e\n\u003cp\u003eWe fully recognize that\nthe Go user community\nbuilt up almost a decade of experience\nand tooling and workflows around GOPATH,\nand it will take a while to convert all of that to Go modules.\u003c/p\u003e\n\u003cp\u003eBut again,\nwe think that modules will now\nwork very well for most users,\nand I encourage you to take a look\nwhen Go 1.13 is released.\u003c/p\u003e\n\u003cp\u003eAs one data point,\nthe Kubernetes project has a lot of dependencies,\nand they have migrated to using Go modules\nto manage them.\nYou probably can too.\nAnd if you can’t,\nplease let us know what’s not working for you\nor what’s too complex,\nby \u003ca href=\"/issue/new\"\u003efiling a bug report\u003c/a\u003e,\nand we will experiment and simplify.\u003c/p\u003e\n\u003ch2 id=\"tools\"\u003eTools\u003c/h2\u003e\n\u003cp\u003eError handling, generics, and dependency management\nare going to take a few more years at least,\nand we’re going to focus on them for now.\nError handling is close to done,\nmodules will be next after that,\nand maybe generics after that.\u003c/p\u003e\n\u003cp\u003eBut suppose we look a couple years out,\nto when we are done experimenting and simplifying\nand have shipped error handling, modules, and generics.\nThen what?\nIt’s very difficult to predict the future,\nbut I think that once these three have shipped,\nthat may mark the start of a new quiet period for major changes.\nOur focus at that point will likely shift to\nsimplifying Go development with improved tools.\u003c/p\u003e\n\u003cp\u003eSome of the tool work is already underway,\nso this post finishes by looking at that.\u003c/p\u003e\n\u003cp\u003eWhile we helped update all the Go community’s\nexisting tools to understand Go modules,\nwe noticed that having a ton of development helper tools\nthat each do one small job is not serving users well.\nThe individual tools are too hard to combine,\ntoo slow to invoke, and too different to use.\u003c/p\u003e\n\u003cp\u003eWe began an effort to unify the most commonly-required\ndevelopment helpers into a single tool,\nnow called \u003ccode\u003egopls\u003c/code\u003e (pronounced “go, please”).\n\u003ccode\u003eGopls\u003c/code\u003e speaks the\n\u003ca href=\"https://langserver.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eLanguage Server Protocol, LSP\u003c/a\u003e,\nand works with any integrated development environment\nor text editor with LSP support,\nwhich is essentially everything at this point.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eGopls\u003c/code\u003e marks an expansion in focus for the Go project,\nfrom delivering standalone compiler-like, command-line\ntools like go vet or gorename\nto also delivering a complete IDE service.\nRebecca Stambler gave a talk with more details about \u003ccode\u003egopls\u003c/code\u003e and IDEs at Gophercon 2019.\n(We’ll add a link here when the video becomes available.)\u003c/p\u003e\n\u003cp\u003eAfter \u003ccode\u003egopls\u003c/code\u003e, we also have ideas for reviving \u003ccode\u003ego fix\u003c/code\u003e in an\nextensible way and for making \u003ccode\u003ego vet\u003c/code\u003e even more helpful.\u003c/p\u003e\n\u003ch2 id=\"coda\"\u003eCoda\u003c/h2\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"experiment/expsimp2.png\" width=\"326\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eSo there’s the path to Go 2.\nWe will experiment and simplify.\nAnd experiment and simplify.\nAnd ship.\nAnd experiment and simplify.\nAnd do it all again.\nIt may look or even feel like the path goes around in circles.\nBut each time we experiment and simplify\nwe learn a little more about what Go 2 should look like\nand move another step closer to it.\nEven abandoned experiments like \u003ccode\u003etry\u003c/code\u003e\nor our first four generics designs\nor \u003ccode\u003edep\u003c/code\u003e are not wasted time.\nThey help us learn what needs to be\nsimplified before we can ship,\nand in some cases they help us better understand\nsomething we took for granted.\u003c/p\u003e\n\u003cp\u003eAt some point we will realize we have\nexperimented enough, and simplified enough,\nand shipped enough,\nand we will have Go 2.\u003c/p\u003e\n\u003cp\u003eThanks to all of you in the Go community\nfor helping us experiment\nand simplify\nand ship\nand find our way on this path.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-08-01T00:00:00Z",
  "Author": "Russ Cox"
}