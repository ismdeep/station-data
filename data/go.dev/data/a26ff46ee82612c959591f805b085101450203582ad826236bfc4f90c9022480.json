{
  "Source": "go.dev",
  "Title": "Go Modules in 2019",
  "Link": "https://go.dev/blog/modules2019",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/modules2019\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Modules in 2019\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      19 December 2018\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"what-a-year\"\u003eWhat a year!\u003c/h2\u003e\n\u003cp\u003e2018 was a great year for the Go ecosystem, with\npackage management as one of our major focuses.\nIn February, we started a community-wide discussion about how to integrate\npackage management directly into the Go toolchain,\nand in August we delivered the first rough implementation of that feature,\ncalled Go modules, in Go 1.11.\nThe migration to Go modules will be the most far-reaching change\nfor the Go ecosystem since Go 1.\nConverting the entire ecosystem—code, users, tools, and so on—from\nGOPATH to modules will require work in many different areas.\nThe module system will in turn help us deliver\nbetter authentication and build speeds to the Go ecosystem.\u003c/p\u003e\n\u003cp\u003eThis post is a preview of what the Go team is planning\nrelating to modules in 2019.\u003c/p\u003e\n\u003ch2 id=\"releases\"\u003eReleases\u003c/h2\u003e\n\u003cp\u003eGo 1.11, released in August 2018, introduced \u003ca href=\"/doc/go1.11#modules\"\u003epreliminary support for modules\u003c/a\u003e.\nFor now, module support is maintained alongside the\ntraditional GOPATH-based mechanisms.\nThe \u003ccode\u003ego\u003c/code\u003e command defaults to module mode when run\nin directory trees outside GOPATH/src and\nmarked by \u003ccode\u003ego.mod\u003c/code\u003e files in their roots.\nThis setting can be overridden by setting the transitional\nenvironment variable \u003ccode\u003e$GO111MODULE\u003c/code\u003e to \u003ccode\u003eon\u003c/code\u003e or \u003ccode\u003eoff\u003c/code\u003e;\nthe default behavior is \u003ccode\u003eauto\u003c/code\u003e mode.\nWe’ve already seen significant adoption of modules across the Go community,\nalong with many helpful suggestions and bug reports\nto help us improve modules.\u003c/p\u003e\n\u003cp\u003eGo 1.12, scheduled for February 2019, will refine module support\nbut still leave it in \u003ccode\u003eauto\u003c/code\u003e mode by default.\nIn addition to many bug fixes and other minor improvements,\nperhaps the most significant change in Go 1.12\nis that commands like \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003erun\u003c/code\u003e \u003ccode\u003ex.go\u003c/code\u003e\nor \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e \u003ccode\u003ersc.io/2fa@v1.1.0\u003c/code\u003e\ncan now operate in \u003ccode\u003eGO111MODULE=on\u003c/code\u003e mode without an explicit \u003ccode\u003ego.mod\u003c/code\u003e file.\u003c/p\u003e\n\u003cp\u003eOur aim is for Go 1.13, scheduled for August 2019, to enable module mode by\ndefault (that is, to change the default from \u003ccode\u003eauto\u003c/code\u003e to \u003ccode\u003eon\u003c/code\u003e)\nand deprecate GOPATH mode.\nIn order to do that, we’ve been working on better tooling support\nalong with better support for the open-source module ecosystem.\u003c/p\u003e\n\u003ch2 id=\"tooling--ide-integration\"\u003eTooling \u0026amp; IDE Integration\u003c/h2\u003e\n\u003cp\u003eIn the eight years that we’ve had GOPATH,\nan incredible amount of tooling has been created\nthat assumes Go source code is stored in GOPATH.\nMoving to modules requires updating all code that makes\nthat assumption.\nWe’ve designed a new package,\n\u003ca href=\"https://godoc.org/golang.org/x/tools/go/packages\" rel=\"noreferrer\" target=\"_blank\"\u003egolang.org/x/tools/go/packages\u003c/a\u003e,\nthat abstracts the operation of finding and loading information\nabout the Go source code for a given target.\nThis new package adapts automatically to both\nGOPATH and modules mode and is also extensible\nto tool-specific code layouts, such as the one\nused by Bazel.\nWe’ve been working with tool authors throughout the Go community\nto help them adopt golang.org/x/tools/go/packages in their tools.\u003c/p\u003e\n\u003cp\u003eAs part of this effort, we’ve also been working to\nunify the various source code querying tools\nlike gocode, godef, and go-outline\ninto a single tool that can be used from the\ncommand line and also supports\nthe \u003ca href=\"https://langserver.org/\" rel=\"noreferrer\" target=\"_blank\"\u003elanguage server protocol\u003c/a\u003e\nused by modern IDEs.\u003c/p\u003e\n\u003cp\u003eThe transition to modules and the changes in package loading\nalso prompted a significant change to Go program analysis.\nAs part of reworking \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003evet\u003c/code\u003e to support modules,\nwe introduced a generalized framework for incremental\nanalysis of Go programs,\nin which an analyzer is invoked for one package at a time.\nIn this framework, the analysis of one package can write out facts\nmade available to analyses of other packages that import the first.\nFor example, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003evet\u003c/code\u003e’s analysis of the \u003ca href=\"/pkg/log/\"\u003elog package\u003c/a\u003e\ndetermines and records the fact that \u003ccode\u003elog.Printf\u003c/code\u003e is a \u003ccode\u003efmt.Printf\u003c/code\u003e wrapper.\nThen \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003evet\u003c/code\u003e can check printf-style format strings in other packages\nthat call \u003ccode\u003elog.Printf\u003c/code\u003e.\nThis framework should enable many new, sophisticated\nprogram analysis tools to help developers find bugs earlier\nand understand code better.\u003c/p\u003e\n\u003ch2 id=\"module-index\"\u003eModule Index\u003c/h2\u003e\n\u003cp\u003eOne of the most important parts of the original design for \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e\nwas that it was \u003cem\u003edecentralized\u003c/em\u003e:\nwe believed then—and we still believe today—that\nanyone should be able to publish their code on any server,\nin contrast to central registries\nsuch as Perl’s CPAN, Java’s Maven, or Node’s NPM.\nPlacing domain names at the start of the \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e import space\nreused an existing decentralized system\nand avoided needing to solve anew the problems of\ndeciding who can use which names.\nIt also allowed companies to import code on private servers\nalongside code from public servers.\nIt is critical to preserve this decentralization as we shift to Go modules.\u003c/p\u003e\n\u003cp\u003eDecentralization of Go’s dependencies has had many benefits,\nbut it also brought a few significant drawbacks.\nThe first is that it’s too hard to find all the publicly-available Go packages.\nEvery site that wants to deliver information about\npackages has\nto do its own crawling, or else wait until a user asks\nabout a particular package before fetching it.\u003c/p\u003e\n\u003cp\u003eWe are working on a new service, the Go Module Index,\nthat will provide a public log of packages entering the Go ecosystem.\nSites like godoc.org and goreportcard.com will be able to watch this log\nfor new entries instead of each independently implementing code\nto find new packages.\nWe also want the service to allow looking up packages\nusing simple queries, to allow \u003ccode\u003egoimports\u003c/code\u003e to add\nimports for packages that have not yet been downloaded to the local system.\u003c/p\u003e\n\u003ch2 id=\"module-authentication\"\u003eModule Authentication\u003c/h2\u003e\n\u003cp\u003eToday, \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e relies on connection-level authentication (HTTPS or SSH)\nto check that it is talking to the right server to download code.\nThere is no additional check of the code itself,\nleaving open the possibility of man-in-the-middle attacks\nif the HTTPS or SSH mechanisms are compromised in some way.\nDecentralization means that the code for a build is fetched\nfrom many different servers, which means the build depends on\nmany systems to serve correct code.\u003c/p\u003e\n\u003cp\u003eThe Go modules design improves code authentication by storing\na \u003ccode\u003ego.sum\u003c/code\u003e file in each module;\nthat file lists the cryptographic hash\nof the expected file tree for each of the module’s dependencies.\nWhen using modules, the \u003ccode\u003ego\u003c/code\u003e command uses \u003ccode\u003ego.sum\u003c/code\u003e to verify\nthat dependencies are bit-for-bit identical to the expected versions\nbefore using them in a build.\nBut the \u003ccode\u003ego.sum\u003c/code\u003e file only lists hashes for the specific dependencies\nused by that module.\nIf you are adding a new dependency\nor updating dependencies with \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e \u003ccode\u003e-u\u003c/code\u003e,\nthere is no corresponding entry in \u003ccode\u003ego.sum\u003c/code\u003e and therefore\nno direct authentication of the downloaded bits.\u003c/p\u003e\n\u003cp\u003eFor publicly-available modules, we intend to run a service we call a \u003cem\u003enotary\u003c/em\u003e\nthat follows the module index log,\ndownloads new modules,\nand cryptographically signs statements of the form\n“module M at version V has file tree hash H.”\nThe notary service will publish all these notarized hashes\nin a queryable, \u003ca href=\"https://www.certificate-transparency.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eCertificate Transparency\u003c/a\u003e-style\n\u003ca href=\"http://static.usenix.org/event/sec09/tech/full_papers/crosby.pdf\" rel=\"noreferrer\" target=\"_blank\"\u003etamper-proof log\u003c/a\u003e,\nso that anyone can verify that the notary is behaving correctly.\nThis log will serve as a public, global \u003ccode\u003ego.sum\u003c/code\u003e file\nthat \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e can use to authenticate modules\nwhen adding or updating dependencies.\u003c/p\u003e\n\u003cp\u003eWe are aiming to have the \u003ccode\u003ego\u003c/code\u003e command check notarized hashes\nfor publicly-available modules not already in \u003ccode\u003ego.sum\u003c/code\u003e\nstarting in Go 1.13.\u003c/p\u003e\n\u003ch2 id=\"module-mirrors\"\u003eModule Mirrors\u003c/h2\u003e\n\u003cp\u003eBecause the decentralized \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e fetches code from multiple origin servers,\nfetching code is only as fast and reliable as the slowest,\nleast reliable server.\nThe only defense available before modules was to vendor\ndependencies into your own repositories.\nWhile vendoring will continue to be supported,\nwe’d prefer a solution that works for all modules—not just the ones you’re already using—and\nthat does not require duplicating a dependency into every\nrepository that uses it.\u003c/p\u003e\n\u003cp\u003eThe Go module design introduces the idea of a module proxy,\nwhich is a server that the \u003ccode\u003ego\u003c/code\u003e command asks for modules,\ninstead of the origin servers.\nOne important kind of proxy is a \u003cem\u003emodule mirror\u003c/em\u003e,\nwhich answers requests for modules by fetching them\nfrom origin servers and then caching them for use in\nfuture requests.\nA well-run mirror should be fast and reliable\neven when some origin servers have gone down.\nWe are planning to launch a mirror service for publicly-available modules in 2019.\nOther projects, like GoCenter and Athens, are planning mirror services too.\n(We anticipate that companies will have multiple options for running\ntheir own internal mirrors as well, but this post is focusing on public mirrors.)\u003c/p\u003e\n\u003cp\u003eOne potential problem with mirrors is that they are\nprecisely man-in-the-middle servers,\nmaking them a natural target for attacks.\nGo developers need some assurance that the mirrors\nare providing the same bits that the origin servers would.\nThe notary process we described in the previous section\naddresses exactly this concern, and it\nwill apply to downloads using mirrors\nas well as downloads using origin servers.\nThe mirrors themselves need not be trusted.\u003c/p\u003e\n\u003cp\u003eWe are aiming to have the Google-run module mirror\nready to be used by default in the \u003ccode\u003ego\u003c/code\u003e command starting in Go 1.13.\nUsing an alternate mirror, or no mirror at all, will be trivial\nto configure.\u003c/p\u003e\n\u003ch2 id=\"module-discovery\"\u003eModule Discovery\u003c/h2\u003e\n\u003cp\u003eFinally, we mentioned earlier that the module index will make it easier to\nbuild sites like godoc.org.\nPart of our work in 2019 will be a major revamp of godoc.org\nto make it more useful for developers who need to\ndiscover available modules\nand then decide whether to rely on a given module or not.\u003c/p\u003e\n\u003ch2 id=\"big-picture\"\u003eBig Picture\u003c/h2\u003e\n\u003cp\u003eThis diagram shows how module source code\nmoves through the design in this post.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"modules2019/code.png\" width=\"374\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eBefore, all consumers of Go source code—the \u003ccode\u003ego\u003c/code\u003e command\nand any sites like godoc.org—fetched code directly from each code host.\nNow they can fetch cached code from a fast, reliable mirror,\nwhile still authenticating that the downloaded bits are correct.\nAnd the index service makes it easy for mirrors, godoc.org,\nand any other similar sites to keep up with all the great new\ncode being added to the Go ecosystem every day.\u003c/p\u003e\n\u003cp\u003eWe’re excited about the future of Go modules in 2019,\nand we hope you are too. Happy New Year!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2018-12-19T00:00:00Z",
  "Author": "Russ Cox"
}