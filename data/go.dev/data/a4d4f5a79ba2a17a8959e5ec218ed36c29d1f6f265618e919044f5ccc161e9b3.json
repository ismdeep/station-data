{
  "Source": "go.dev",
  "Title": "What's in an (Alias) Name?",
  "Link": "https://go.dev/blog/alias-names",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/alias-names\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eWhat\u0026#39;s in an (Alias) Name?\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Griesemer\u003cbr/\u003e\n      17 September 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eThis post is about generic alias types, what they are, and why we need them.\u003c/p\u003e\n\u003ch2 id=\"background\"\u003eBackground\u003c/h2\u003e\n\u003cp\u003eGo was designed for programming at scale.\nProgramming at scale means dealing with large amounts of data, but\nalso large codebases, with many engineers working on those codebases\nover long periods of time.\u003c/p\u003e\n\u003cp\u003eGo’s organization of code into packages enables programming at scale\nby splitting up large codebases into smaller, more manageable pieces,\noften written by different people, and connected through public\nAPIs.\nIn Go, these APIs consist of the identifiers exported by a package:\nthe exported constants, types, variables, and functions.\nThis includes the exported fields of structs and methods of types.\u003c/p\u003e\n\u003cp\u003eAs software projects evolve over time or requirements change,\nthe original organization of the code into packages may turn out to be\ninadequate and require \u003cem\u003erefactoring\u003c/em\u003e.\nRefactoring may involve moving exported identifiers and their respective\ndeclarations from an old package to a new package.\nThis also requires that any references to the moved declarations must be\nupdated so that they refer to the new location.\nIn large codebases it may be unpractical or infeasible to make such\na change atomically; or in other words, to do the move and update all clients\nin a single change.\nInstead, the change must happen incrementally: for instance, to “move”\na function \u003ccode\u003eF\u003c/code\u003e, we add its declaration in a new package without\ndeleting the original declaration in the old package.\nThis way, clients can be updated incrementally, over time.\nOnce all callers refer to \u003ccode\u003eF\u003c/code\u003e in the new package, the original declaration\nof \u003ccode\u003eF\u003c/code\u003e may be safely deleted (unless it must be retained indefinitely, for\nbackward compatibility).\nRuss Cox describes refactoring in detail in his 2016 article on\n\u003ca href=\"/talks/2016/refactor.article\"\u003eCodebase Refactoring (with help from Go)\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eMoving a function \u003ccode\u003eF\u003c/code\u003e from one package to another while also retaining it\nin the original package is easy: a wrapper function is all that’s needed.\nTo move \u003ccode\u003eF\u003c/code\u003e from \u003ccode\u003epkg1\u003c/code\u003e to \u003ccode\u003epkg2\u003c/code\u003e, \u003ccode\u003epkg2\u003c/code\u003e declares a new function \u003ccode\u003eF\u003c/code\u003e\n(the wrapper function) with the same signature as \u003ccode\u003epkg1.F\u003c/code\u003e, and \u003ccode\u003epkg2.F\u003c/code\u003e\ncalls \u003ccode\u003epkg1.F\u003c/code\u003e.\nNew callers may call \u003ccode\u003epkg2.F\u003c/code\u003e, old callers may call \u003ccode\u003epkg1.F\u003c/code\u003e, yet in both\ncases the function eventually called is the same.\u003c/p\u003e\n\u003cp\u003eMoving constants is similarly straightforward.\nVariables take a bit more work: one may have to introduce a pointer to the\noriginal variable in the new package or perhaps use accessor functions.\nThis is less ideal, but at least it is workable.\nThe point here is that for constants, variables, and functions,\nexisting language features exist that permit incremental refactoring as\ndescribed above.\u003c/p\u003e\n\u003cp\u003eBut what about moving a type?\u003c/p\u003e\n\u003cp\u003eIn Go, the \u003ca href=\"/ref/spec#Qualified_identifiers\"\u003e(qualified) identifier\u003c/a\u003e,\nor just \u003cem\u003ename\u003c/em\u003e for short, determines the \u003cem\u003eidentity\u003c/em\u003e of types:\na type \u003ccode\u003eT\u003c/code\u003e \u003ca href=\"/ref/spec#Type_definitions\"\u003edefined\u003c/a\u003e and exported by a package\n\u003ccode\u003epkg1\u003c/code\u003e is \u003ca href=\"/ref/spec#Type_identity\"\u003edifferent\u003c/a\u003e from an \u003cem\u003eotherwise identical\u003c/em\u003e\ntype definition of a type \u003ccode\u003eT\u003c/code\u003e exported by a package \u003ccode\u003epkg2\u003c/code\u003e.\nThis property complicates a move of \u003ccode\u003eT\u003c/code\u003e from one package to another while\nretaining a copy of it in the original package.\nFor instance, a value of type \u003ccode\u003epkg2.T\u003c/code\u003e is not \u003ca href=\"/ref/spec#Assignability\"\u003eassignable\u003c/a\u003e\nto a variable of type \u003ccode\u003epkg1.T\u003c/code\u003e because their type names and thus their\ntype identities are different.\nDuring an incremental update phase, clients may have values and variables\nof both types, even though the programmer’s intent is for them to have the\nsame type.\u003c/p\u003e\n\u003cp\u003eTo solve this problem, \u003ca href=\"/doc/go1.9\"\u003eGo 1.9\u003c/a\u003e introduced the notion of a\n\u003ca href=\"/ref/spec#Alias_declarations\"\u003e\u003cem\u003etype alias\u003c/em\u003e\u003c/a\u003e.\nA type alias provides a new name for an existing type without introducing\na new type that has a different identity.\u003c/p\u003e\n\u003cp\u003eIn contrast to a regular \u003ca href=\"/ref/spec#Type_definitions\"\u003etype definition\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype T T0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich declares a \u003cem\u003enew type\u003c/em\u003e that is never identical to the type on the right-hand side\nof the declaration, an \u003ca href=\"/ref/spec#Alias_declarations\"\u003ealias declaration\u003c/a\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype A = T  // the \u0026#34;=\u0026#34; indicates an alias declaration\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edeclares only a \u003cem\u003enew name\u003c/em\u003e \u003ccode\u003eA\u003c/code\u003e for the type on the right-hand side:\nhere, \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eT\u003c/code\u003e denote the same and thus identical type \u003ccode\u003eT\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAlias declarations make it possible to provide a new name (in a new package!)\nfor a given type while retaining type identity:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage pkg2\n\nimport \u0026#34;path/to/pkg1\u0026#34;\n\ntype T = pkg1.T\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe type name has changed from \u003ccode\u003epkg1.T\u003c/code\u003e to \u003ccode\u003epkg2.T\u003c/code\u003e but values\nof type \u003ccode\u003epkg2.T\u003c/code\u003e have the same type as variables of type \u003ccode\u003epkg1.T\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"generic-alias-types\"\u003eGeneric alias types\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/doc/go1.18\"\u003eGo 1.18\u003c/a\u003e introduced generics.\nSince that release, type definitions and function\ndeclarations can be customized through type parameters.\nFor technical reasons, alias types didn’t gain the same ability at that time.\nObviously, there were also no large codebases exporting generic\ntypes and requiring refactoring.\u003c/p\u003e\n\u003cp\u003eToday, generics have been around for a couple of years, and large codebases\nare making use of generic features.\nEventually the need will arise to refactor these codebases, and with that the\nneed to migrate generic types from one package to another.\u003c/p\u003e\n\u003cp\u003eTo support incremental refactorings involving generic types, the future Go 1.24 release,\nplanned for early February 2025, will fully support type parameters on alias types\nin accordance with proposal \u003ca href=\"/issue/46477\"\u003e#46477\u003c/a\u003e.\nThe new syntax follows the same pattern as it does for type definitions and function declarations,\nwith an optional type parameter list following the identifier (the alias name) on the left-hand side.\nBefore this change one could only write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Alias = someType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ebut now we can also declare type parameters with the alias declaration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Alias[P1 C1, P2 C2] = someType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eConsider the previous example, now with generic types.\nThe original package \u003ccode\u003epkg1\u003c/code\u003e declared and exported a generic type \u003ccode\u003eG\u003c/code\u003e with a type parameter \u003ccode\u003eP\u003c/code\u003e\nthat is suitably constrained:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage pkg1\n\ntype Constraint      someConstraint\ntype G[P Constraint] someType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the need arises to provide access to the same type \u003ccode\u003eG\u003c/code\u003e from a new package \u003ccode\u003epkg2\u003c/code\u003e,\na generic alias type is just the ticket \u003ca href=\"/play/p/wKOf6NbVtdw?v=gotip\"\u003e(playground)\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage pkg2\n\nimport \u0026#34;path/to/pkg1\u0026#34;\n\ntype Constraint      = pkg1.Constraint  // pkg1.Constraint could also be used directly in G\ntype G[P Constraint] = pkg1.G[P]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that one \u003cstrong\u003ecannot\u003c/strong\u003e simply write\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype G = pkg1.G\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efor a couple of reasons:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003ePer \u003ca href=\"/ref/spec#Type_definitions\"\u003eexisting spec rules\u003c/a\u003e, generic\ntypes must be \u003ca href=\"/ref/spec#Instantiations\"\u003einstantiated\u003c/a\u003e when they\nare \u003cem\u003eused\u003c/em\u003e.\nThe right-hand side of the alias declaration uses the type \u003ccode\u003epkg1.G\u003c/code\u003e and\ntherefore type arguments must be provided.\nNot doing so would require an exception for this case, making the spec more\ncomplicated.\nIt is not obvious that the minor convenience is worth the complication.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eIf the alias declaration doesn’t need to declare its own type parameters and\ninstead simply “inherits” them from the aliased type \u003ccode\u003epkg1.G\u003c/code\u003e, the declaration of\n\u003ccode\u003eG\u003c/code\u003e provides no indication that it is a generic type.\nIts type parameters and constraints would have to be retrieved from the declaration\nof \u003ccode\u003epkg1.G\u003c/code\u003e (which itself might be an alias).\nReadability will suffer, yet readable code is one of the primary aims of the Go project.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eWriting down an explicit type parameter list may seem like an unnecessary burden\nat first, but it also provides additional flexibility.\nFor one, the number of type parameters declared by the alias type doesn’t have to\nmatch the number of type parameters of the aliased type.\nConsider a generic map type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Map[K comparable, V any] mapImplementation\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf uses of \u003ccode\u003eMap\u003c/code\u003e as sets are common, the alias\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Set[K comparable] = Map[K, bool]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003emight be useful \u003ca href=\"/play/p/IxeUPGCztqf?v=gotip\"\u003e(playground)\u003c/a\u003e.\nBecause it is an alias, types such as \u003ccode\u003eSet[int]\u003c/code\u003e and \u003ccode\u003eMap[int, bool]\u003c/code\u003e are\nidentical.\nThis would not be the case if \u003ccode\u003eSet\u003c/code\u003e were a \u003ca href=\"/ref/spec#Type_definitions\"\u003edefined\u003c/a\u003e\n(non-alias) type.\u003c/p\u003e\n\u003cp\u003eFurthermore, the type constraints of a generic alias type don’t have to match the\nconstraints of the aliased type, they only have to\n\u003ca href=\"/ref/spec#Satisfying_a_type_constraint\"\u003esatisfy\u003c/a\u003e them.\nFor instance, reusing the set example above, one could define\nan \u003ccode\u003eIntSet\u003c/code\u003e as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype integers interface{ ~int | ~int8 | ~int16 | ~int32 | ~int64 }\ntype IntSet[K integers] = Set[K]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis map can be instantiated with any key type that satisfies the \u003ccode\u003eintegers\u003c/code\u003e\nconstraint \u003ca href=\"/play/p/0f7hOAALaFb?v=gotip\"\u003e(playground)\u003c/a\u003e.\nBecause \u003ccode\u003eintegers\u003c/code\u003e satisfies \u003ccode\u003ecomparable\u003c/code\u003e, the type parameter \u003ccode\u003eK\u003c/code\u003e may be used\nas type argument for the \u003ccode\u003eK\u003c/code\u003e parameter of \u003ccode\u003eSet\u003c/code\u003e, following the usual\ninstantiation rules.\u003c/p\u003e\n\u003cp\u003eFinally, because an alias may also denote a type literal, parameterized aliases\nmake it possible to create generic type literals\n\u003ca href=\"/play/p/wql3NJaUs0o?v=gotip\"\u003e(playground)\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Point3D[E any] = struct{ x, y, z E }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo be clear, none of these examples are “special cases” or somehow require\nadditional rules in the spec. They follow directly from the application of\nthe existing rules put in place for generics. The only thing that changed in the\nspec is the ability to declare type parameters in an alias declaration.\u003c/p\u003e\n\u003ch2 id=\"an-interlude-about-type-names\"\u003eAn interlude about type names\u003c/h2\u003e\n\u003cp\u003eBefore the introduction of alias types, Go had only one form of type declarations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype TypeName existingType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis declaration creates a new and different type from an existing type\nand gives that new type a name.\nIt was natural to call such types \u003cem\u003enamed types\u003c/em\u003e as they have a \u003cem\u003etype name\u003c/em\u003e\nin contrast to unnamed \u003ca href=\"/ref/spec#Types\"\u003etype literals\u003c/a\u003e such as\n\u003ccode\u003estruct{ x, y int }\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWith the introduction of alias types in Go 1.9 it became possible to give\na name (an alias) to type literals, too. For instance, consider:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Point2D = struct{ x, y int }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSuddenly, the notion of a \u003cem\u003enamed type\u003c/em\u003e describing something that is different from\na type literal didn’t make that much sense anymore, since an alias name clearly is\na name for a type, and thus the denoted type (which might be a type literal, not a type name!)\narguably could be called a “named type”.\u003c/p\u003e\n\u003cp\u003eBecause (proper) named types have special properties (one can bind methods to them,\nthey follow different assignment rules, etc.), it seemed prudent to use a new\nterm in order to avoid confusions.\nThus, since Go 1.9, the spec calls the types formerly called named types \u003cem\u003edefined types\u003c/em\u003e:\nonly defined types have properties (methods, assignability restrictions, etc) that are\ntied to their names.\nDefined types are introduced through type definitions, and alias types are\nintroduced through alias declarations.\nIn both cases, names are given to types.\u003c/p\u003e\n\u003cp\u003eThe introduction of generics in Go 1.18 made things more complicated.\nType parameters are types, too, they have a name, and they share rules\nwith defined types.\nFor instance, like defined types, two differently named type parameters\ndenote different types.\nIn other words, type parameters are named types, and furthermore, they\nbehave similarly to Go’s original named types in some ways.\u003c/p\u003e\n\u003cp\u003eTo top things off, Go’s predeclared types (\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003estring\u003c/code\u003e and so on)\ncan only be accessed through their names, and like defined types and\ntype parameters, are different if their names are different\n(ignoring for a moment the \u003ccode\u003ebyte\u003c/code\u003e and \u003ccode\u003erune\u003c/code\u003e alias types).\nThe predeclared types truly are named types.\u003c/p\u003e\n\u003cp\u003eTherefore, with Go 1.18, the spec came full circle and formally\nre-introduced the notion of a \u003ca href=\"/ref/spec#Types\"\u003enamed type\u003c/a\u003e which now\ncomprises “predeclared types, defined types, and type parameters”.\nTo correct for alias types denoting type literals the spec says:\n“An alias denotes a named type if the type given in the alias declaration\nis a named type.”\u003c/p\u003e\n\u003cp\u003eStepping back and outside the box of Go nomenclature for a moment, the correct\ntechnical term for a named type in Go is probably\n\u003ca href=\"https://en.wikipedia.org/wiki/Nominal_type_system\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003enominal type\u003c/em\u003e\u003c/a\u003e.\nA nominal type’s identity is explicitly tied to its name which is exactly what\nGo’s named types (now using the 1.18 terminology) are all about.\nA nominal type’s behavior is in contrast to a \u003cem\u003estructural type\u003c/em\u003e which has\nbehavior that only depends on its structure and not its name\n(if it has one in the first place).\nPutting it all together, Go’s predeclared, defined, and type parameter types are\nall nominal types, while Go’s type literals and aliases denoting type literals\nare structural types.\nBoth nominal and structural types can have names, but having a name\ndoesn’t mean the type is nominal, it just means it is named.\u003c/p\u003e\n\u003cp\u003eNone of this matters for day-to-day use of Go and in practice the details\ncan safely be ignored.\nBut precise terminology matters in the spec because it makes it easier\nto describe the rules governing the language.\nSo should the spec change its terminology one more time?\nIt is probably not worth the churn: it is not just the spec that would need\nto be updated, but also a lot of supporting documentation.\nA fair number of books written on Go might become inaccurate.\nFurthermore, “named”, while less precise, is probably intuitively clearer\nthan “nominal” for most people.\nIt also matches the original terminology used in the spec, even if it now\nrequires an exception for alias types denoting type literals.\u003c/p\u003e\n\u003ch2 id=\"availability\"\u003eAvailability\u003c/h2\u003e\n\u003cp\u003eImplementing generic type aliases has taken longer than expected:\nthe necessary changes required adding a new exported \u003ccode\u003eAlias\u003c/code\u003e type\nto \u003ca href=\"/pkg/go/types\"\u003e\u003ccode\u003ego/types\u003c/code\u003e\u003c/a\u003e and then adding the ability to record type parameters\nwith that type.\nOn the compiler side, the analogous changes also required modifications to\nthe export data format, the file format that describes a package’s\nexports, which now needs to be able to describe type parameters for aliases.\nThe impact of these changes is not confined to the compiler, but affects\nclients of \u003ccode\u003ego/types\u003c/code\u003e and thus many third-party packages.\nThis was very much a change affecting a large code base; to avoid\nbreaking things, an incremental roll-out over several releases was necessary.\u003c/p\u003e\n\u003cp\u003eAfter all this work, generic alias types will finally be available by default in Go 1.24.\u003c/p\u003e\n\u003cp\u003eTo allow third-party clients to get their code ready, starting with\nGo 1.23, support for generic type aliases can be enabled by setting\n\u003ccode\u003eGOEXPERIMENT=aliastypeparams\u003c/code\u003e when invoking the \u003ccode\u003ego\u003c/code\u003e tool.\nHowever, be aware that support for exported generic aliases is still\nmissing for that version.\u003c/p\u003e\n\u003cp\u003eFull support (including export) is implemented at tip, and the default\nsetting for \u003ccode\u003eGOEXPERIMENT\u003c/code\u003e will soon be switched so that generic type\naliases are enabled by default.\nThus, another option is to experiement with the latest version of Go\nat tip.\u003c/p\u003e\n\u003cp\u003eAs always, please let us know if you encounter any problems by filing an\n\u003ca href=\"/issue/new\"\u003eissue\u003c/a\u003e;\nthe better we test a new feature, the smoother the general roll-out.\u003c/p\u003e\n\u003cp\u003eThanks and happy refactoring!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-09-17T00:00:00Z",
  "Author": "Robert Griesemer"
}