{
  "Source": "go.dev",
  "Title": "The App Engine SDK and workspaces (GOPATH)",
  "Link": "https://go.dev/blog/appengine-gopath",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/appengine-gopath\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eThe App Engine SDK and workspaces (GOPATH)\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      9 January 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen we released Go 1 we introduced the \u003ca href=\"/cmd/go/\"\u003ego tool\u003c/a\u003e and,\nwith it, the concept of workspaces.\nWorkspaces (specified by the GOPATH environment variable) are a convention\nfor organizing code that simplifies fetching,\nbuilding, and installing Go packages.\nIf you’re not familiar with workspaces, please read \u003ca href=\"/doc/code.html\"\u003ethis article\u003c/a\u003e\nor watch \u003ca href=\"http://www.youtube.com/watch?v=XCsL89YtqCs\" rel=\"noreferrer\" target=\"_blank\"\u003ethis screencast\u003c/a\u003e before reading on.\u003c/p\u003e\n\u003cp\u003eUntil recently, the tools in the App Engine SDK were not aware of workspaces.\nWithout workspaces the “\u003ca href=\"/cmd/go/#hdr-Download_and_install_packages_and_dependencies\"\u003ego get\u003c/a\u003e”\ncommand cannot function,\nand so app authors had to install and update their app dependencies manually. It was a pain.\u003c/p\u003e\n\u003cp\u003eThis has all changed with version 1.7.4 of the App Engine SDK.\nThe \u003ca href=\"https://developers.google.com/appengine/docs/go/tools/devserver\" rel=\"noreferrer\" target=\"_blank\"\u003edev_appserver\u003c/a\u003e\nand \u003ca href=\"https://developers.google.com/appengine/docs/go/tools/uploadinganapp\" rel=\"noreferrer\" target=\"_blank\"\u003eappcfg\u003c/a\u003e\ntools are now workspace-aware.\nWhen running locally or uploading an app,\nthese tools now search for dependencies in the workspaces specified by the\nGOPATH environment variable.\nThis means you can now use “go get” while building App Engine apps,\nand switch between normal Go programs and App Engine apps without changing\nyour environment or habits.\u003c/p\u003e\n\u003cp\u003eFor example, let’s say you want to build an app that uses OAuth 2.0 to authenticate\nwith a remote service.\nA popular OAuth 2.0 library for Go is the \u003ca href=\"https://godoc.org/golang.org/x/oauth2\" rel=\"noreferrer\" target=\"_blank\"\u003eoauth2\u003c/a\u003e package,\nwhich you can install to your workspace with this command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego get golang.org/x/oauth2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen writing your App Engine app, import the oauth package just as you would in a regular Go program:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026#34;golang.org/x/oauth2\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, whether running your app with the dev_appserver or deploying it with appcfg,\nthe tools will find the oauth package in your workspace. It just works.\u003c/p\u003e\n\u003ch2 id=\"hybrid-stand-aloneapp-engine-apps\"\u003eHybrid stand-alone/App Engine apps\u003c/h2\u003e\n\u003cp\u003eThe Go App Engine SDK builds on Go’s standard \u003ca href=\"/pkg/net/http/\"\u003enet/http\u003c/a\u003e\npackage to serve web requests and,\nas a result, many Go web servers can be run on App Engine with only a few changes.\nFor example, \u003ca href=\"/cmd/godoc/\"\u003egodoc\u003c/a\u003e is included in the\nGo distribution as a stand-alone program,\nbut it can also run as an App Engine app (godoc serves \u003ca href=\"/\"\u003egolang.org\u003c/a\u003e from App Engine).\u003c/p\u003e\n\u003cp\u003eBut wouldn’t it be nice if you could write a program that is both a stand-alone\nweb server and an App Engine app? By using \u003ca href=\"/pkg/go/build/#hdr-Build_Constraints\"\u003ebuild constraints\u003c/a\u003e, you can.\u003c/p\u003e\n\u003cp\u003eBuild constraints are line comments that determine whether a file should\nbe included in a package.\nThey are most often used in code that handles a variety of operating systems\nor processor architectures.\nFor instance, the \u003ca href=\"/pkg/path/filepath/\"\u003epath/filepath\u003c/a\u003e\npackage includes the file \u003ca href=\"/src/pkg/path/filepath/symlink.go\"\u003esymlink.go\u003c/a\u003e,\nwhich specifies a build constraint to ensure that it is not built on Windows\nsystems (which do not have symbolic links):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// +build !windows\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe App Engine SDK introduces a new build constraint term: “appengine”. Files that specify\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// +build appengine\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewill be built by the App Engine SDK and ignored by the go tool. Conversely, files that specify\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// +build !appengine\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eare ignored by the App Engine SDK, while the go tool will happily build them.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"http://code.google.com/p/goprotobuf/\" rel=\"noreferrer\" target=\"_blank\"\u003egoprotobuf\u003c/a\u003e library uses this\nmechanism to provide two implementations of a key part of its encode/decode machinery:\n\u003ca href=\"http://code.google.com/p/goprotobuf/source/browse/proto/pointer_unsafe.go\" rel=\"noreferrer\" target=\"_blank\"\u003epointer_unsafe.go\u003c/a\u003e\nis the faster version that cannot be used on App Engine because it uses\nthe \u003ca href=\"/pkg/unsafe/\"\u003eunsafe package\u003c/a\u003e,\nwhile \u003ca href=\"http://code.google.com/p/goprotobuf/source/browse/proto/pointer_reflect.go\" rel=\"noreferrer\" target=\"_blank\"\u003epointer_reflect.go\u003c/a\u003e\nis a slower version that avoids unsafe by using the \u003ca href=\"/pkg/reflect/\"\u003ereflect package\u003c/a\u003e instead.\u003c/p\u003e\n\u003cp\u003eLet’s take a simple Go web server and turn it into a hybrid app. This is main.go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;net/http\u0026#34;\n)\n\nfunc main() {\n    http.HandleFunc(\u0026#34;/\u0026#34;, handler)\n    http.ListenAndServe(\u0026#34;localhost:8080\u0026#34;, nil)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprint(w, \u0026#34;Hello!\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBuild this with the go tool and you’ll get a stand-alone web server executable.\u003c/p\u003e\n\u003cp\u003eThe App Engine infrastructure provides its own main function that runs its\nequivalent to ListenAndServe.\nTo convert main.go to an App Engine app, drop the call to ListenAndServe\nand register the handler in an init function (which runs before main). This is app.go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;net/http\u0026#34;\n)\n\nfunc init() {\n    http.HandleFunc(\u0026#34;/\u0026#34;, handler)\n}\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprint(w, \u0026#34;Hello!\u0026#34;)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo make this a hybrid app, we need to split it into an App Engine-specific part,\nan stand-alone binary-specific part, and the parts common to both versions.\nIn this case, there is no App Engine-specific part,\nso we split it into just two files:\u003c/p\u003e\n\u003cp\u003eapp.go specifies and registers the handler function.\nIt is identical to the code listing above,\nand requires no build constraints as it should be included in all versions of the program.\u003c/p\u003e\n\u003cp\u003emain.go runs the web server. It includes the “!appengine” build constraint,\nas it must only be included when building the stand-alone binary.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// +build !appengine\n\npackage main\n\nimport \u0026#34;net/http\u0026#34;\n\nfunc main() {\n    http.ListenAndServe(\u0026#34;localhost:8080\u0026#34;, nil)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo see a more complex hybrid app, take a look at the \u003ca href=\"https://godoc.org/golang.org/x/tools/present\" rel=\"noreferrer\" target=\"_blank\"\u003epresent tool\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"conclusions\"\u003eConclusions\u003c/h2\u003e\n\u003cp\u003eWe hope these changes will make it easier to work on apps with external dependencies,\nand to maintain code bases that contain both stand-alone programs and App Engine apps.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-01-09T00:00:00Z",
  "Author": "Andrew Gerrand"
}