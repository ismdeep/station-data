{
  "Source": "go.dev",
  "Title": "All your comparable types",
  "Link": "https://go.dev/blog/comparable",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/comparable\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eAll your comparable types\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Griesemer\u003cbr/\u003e\n      17 February 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eOn February 1 we released our latest Go version, 1.20,\nwhich included a few language changes.\nHere we’ll discuss one of those changes: the predeclared \u003ccode\u003ecomparable\u003c/code\u003e type constraint\nis now satisfied by all \u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable types\u003c/a\u003e.\nSurprisingly, before Go 1.20, some comparable types did not satisfy \u003ccode\u003ecomparable\u003c/code\u003e!\u003c/p\u003e\n\u003cp\u003eIf you’re confused, you’ve come to the right place.\nConsider the valid map declaration\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar lookupTable map[any]string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere the map’s key type is \u003ccode\u003eany\u003c/code\u003e (which is a\n\u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable type\u003c/a\u003e).\nThis works perfectly fine in Go.\nOn the other hand, before Go 1.20, the seemingly equivalent generic map type\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003etype genericLookupTable[K comparable, V any] map[K]V\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecould be used just like a regular map type, but produced a compile-time error when\n\u003ccode\u003eany\u003c/code\u003e was used as the key type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar lookupTable genericLookupTable[any, string] // ERROR: any does not implement comparable (Go 1.18 and Go 1.19)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eStarting with Go 1.20 this code will compile just fine.\u003c/p\u003e\n\u003cp\u003eThe pre-Go 1.20 behavior of \u003ccode\u003ecomparable\u003c/code\u003e was particularly annoying because it\nprevented us from writing the kind of generic libraries we were hoping to write with\ngenerics in the first place.\nThe proposed \u003ca href=\"/issue/57436\"\u003e\u003ccode\u003emaps.Clone\u003c/code\u003e\u003c/a\u003e function\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc Clone[M ~map[K]V, K comparable, V any](m M) M { … }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecan be written but could not be used for a map such as \u003ccode\u003elookupTable\u003c/code\u003e for the same reason\nour \u003ccode\u003egenericLookupTable\u003c/code\u003e could not be used with \u003ccode\u003eany\u003c/code\u003e as key type.\u003c/p\u003e\n\u003cp\u003eIn this blog post, we hope to shine some light on the language mechanics behind all this.\nIn order to do so, we start with a bit of background information.\u003c/p\u003e\n\u003ch2 id=\"type-parameters-and-constraints\"\u003eType parameters and constraints\u003c/h2\u003e\n\u003cp\u003eGo 1.18 introduced generics and, with that,\n\u003ca href=\"/ref/spec#Type_parameter_declarations\"\u003e\u003cem\u003etype parameters\u003c/em\u003e\u003c/a\u003e\nas a new language construct.\u003c/p\u003e\n\u003cp\u003eIn an ordinary function, a parameter ranges over a set of values that is restricted by its type.\nAnalogously, in a generic function (or type), a type parameter ranges over a set of types that is restricted\nby its \u003ca href=\"/ref/spec#Type_constraints\"\u003e\u003cem\u003etype constraint\u003c/em\u003e\u003c/a\u003e.\nThus, a type constraint defines the \u003cem\u003eset of types\u003c/em\u003e that are permissible\nas type arguments.\u003c/p\u003e\n\u003cp\u003eGo 1.18 also changed how we view interfaces: while in the past an\ninterface defined a set of methods, now an interface defines a set of types.\nThis new view is completely backward compatible:\nfor any given set of methods defined by an interface, we can imagine the (infinite)\nset of all types that implement those methods.\nFor instance, given an \u003ca href=\"/pkg/io#Writer\"\u003e\u003ccode\u003eio.Writer\u003c/code\u003e\u003c/a\u003e interface,\nwe can imagine the infinite set of all types that have a \u003ccode\u003eWrite\u003c/code\u003e method\nwith the appropriate signature.\nAll of these types \u003cem\u003eimplement\u003c/em\u003e the interface because they all have the\nrequired \u003ccode\u003eWrite\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eBut the new type set view is more powerful than the old method set one:\nwe can describe a set of types explicitly, not only indirectly through methods.\nThis gives us new ways to control a type set.\nStarting with Go 1.18, an interface may embed not just other interfaces,\nbut any type, a union of types, or an infinite set of types that share the\nsame \u003ca href=\"/ref/spec#Underlying_types\"\u003eunderlying type\u003c/a\u003e. These types are then included in the\n\u003ca href=\"/ref/spec#General_interfaces\"\u003etype set computation\u003c/a\u003e:\nthe union notation \u003ccode\u003eA|B\u003c/code\u003e means “type \u003ccode\u003eA\u003c/code\u003e or type \u003ccode\u003eB\u003c/code\u003e”,\nand the \u003ccode\u003e~T\u003c/code\u003e notation stands for “all types that have the underlying type \u003ccode\u003eT\u003c/code\u003e”.\nFor instance, the interface\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003einterface {\n    ~int | ~string\n    io.Writer\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003edefines the set of all types whose underlying types are either \u003ccode\u003eint\u003c/code\u003e or \u003ccode\u003estring\u003c/code\u003e\nand that also implement \u003ccode\u003eio.Writer\u003c/code\u003e’s \u003ccode\u003eWrite\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eSuch generalized interfaces can’t be used as variable types.\nBut because they describe type sets they are used as type constraints, which\nare sets of types.\nFor instance, we can write a generic \u003ccode\u003emin\u003c/code\u003e function\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc min[P interface{ ~int64 | ~float64 }](x, y P) P\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich accepts any \u003ccode\u003eint64\u003c/code\u003e or \u003ccode\u003efloat64\u003c/code\u003e argument.\n(Of course, a more realistic implementation would use a constraint that\nenumerates all basic types with an \u003ccode\u003e\u0026lt;\u003c/code\u003e operator.)\u003c/p\u003e\n\u003cp\u003eAs an aside, because enumerating explicit types without methods is common,\na little bit of \u003ca href=\"https://en.wikipedia.org/wiki/Syntactic_sugar\" rel=\"noreferrer\" target=\"_blank\"\u003esyntactic sugar\u003c/a\u003e\nallows us to \u003ca href=\"/ref/spec#General_interfaces\"\u003eomit the enclosing \u003ccode\u003einterface{}\u003c/code\u003e\u003c/a\u003e,\nleading to the compact and more idiomatic\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc min[P ~int64 | ~float64](x, y P) P { … }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the new type set view we also need a new way to explain what it means\nto \u003ca href=\"/ref/spec#Implementing_an_interface\"\u003e\u003cem\u003eimplement\u003c/em\u003e\u003c/a\u003e an interface.\nWe say that a (non-interface) type \u003ccode\u003eT\u003c/code\u003e implements\nan interface \u003ccode\u003eI\u003c/code\u003e if \u003ccode\u003eT\u003c/code\u003e is an element of the interface’s type set.\nIf \u003ccode\u003eT\u003c/code\u003e is an interface itself, it describes a type set. Every single type in that set\nmust also be in the type set of \u003ccode\u003eI\u003c/code\u003e, otherwise \u003ccode\u003eT\u003c/code\u003e would contain types that do not implement \u003ccode\u003eI\u003c/code\u003e.\nThus, if \u003ccode\u003eT\u003c/code\u003e is an interface, it implements interface \u003ccode\u003eI\u003c/code\u003e if the type\nset of \u003ccode\u003eT\u003c/code\u003e is a subset of the type set of \u003ccode\u003eI\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNow we have all the ingredients in place to understand constraint satisfaction.\nAs we have seen earlier, a type constraint describes the set of acceptable argument\ntypes for a type parameter. A type argument satisfies the corresponding type parameter\nconstraint if the type argument is in the set described by the constraint interface.\nThis is another way of saying that the type argument implements the constraint.\nIn Go 1.18 and Go 1.19, constraint satisfaction meant constraint implementation.\nAs we’ll see in a bit, in Go 1.20 constraint satisfaction is not quite constraint\nimplementation anymore.\u003c/p\u003e\n\u003ch2 id=\"operations-on-type-parameter-values\"\u003eOperations on type parameter values\u003c/h2\u003e\n\u003cp\u003eA type constraint does not just specify what type arguments are acceptable for a type parameter,\nit also determines the operations that are possible on values of a type parameter.\nAs we would expect, if a constraint defines a method such as \u003ccode\u003eWrite\u003c/code\u003e,\nthe \u003ccode\u003eWrite\u003c/code\u003e method can be called on a value of the respective type parameter.\nMore generally, an operation such as \u003ccode\u003e+\u003c/code\u003e or \u003ccode\u003e*\u003c/code\u003e that is supported by all types in the type set\ndefined by a constraint is permitted with values of the corresponding type parameter.\u003c/p\u003e\n\u003cp\u003eFor instance, given the \u003ccode\u003emin\u003c/code\u003e example, in the function body any operation that is supported by\n\u003ccode\u003eint64\u003c/code\u003e and \u003ccode\u003efloat64\u003c/code\u003e types is permitted on values of the type parameter \u003ccode\u003eP\u003c/code\u003e.\nThat includes all the basic arithmetic operations, but also comparisons such as \u003ccode\u003e\u0026lt;\u003c/code\u003e.\nBut it does not include bitwise operations such as \u003ccode\u003e\u0026amp;\u003c/code\u003e or \u003ccode\u003e|\u003c/code\u003e\nbecause those operations are not defined on \u003ccode\u003efloat64\u003c/code\u003e values.\u003c/p\u003e\n\u003ch2 id=\"comparable-types\"\u003eComparable types\u003c/h2\u003e\n\u003cp\u003eIn contrast to other unary and binary operations, \u003ccode\u003e==\u003c/code\u003e is defined on not just\na limited set of\n\u003ca href=\"/ref/spec#Types\"\u003epredeclared types\u003c/a\u003e, but on an infinite variety of types,\nincluding arrays, structs, and interfaces.\nIt is impossible to enumerate all these types in a constraint.\nWe need a different mechanism to express that a type parameter must support \u003ccode\u003e==\u003c/code\u003e\n(and \u003ccode\u003e!=\u003c/code\u003e, of course) if we care about more than predeclared types.\u003c/p\u003e\n\u003cp\u003eWe solve this problem through the predeclared type\n\u003ca href=\"/ref/spec#Predeclared_identifiers\"\u003e\u003ccode\u003ecomparable\u003c/code\u003e\u003c/a\u003e, introduced with Go 1.18.\n\u003ccode\u003ecomparable\u003c/code\u003e is\nan interface type whose type set is the infinite set of comparable types, and that\nmay be used as a constraint whenever we require a type argument to support \u003ccode\u003e==\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYet, the set of types comprised by \u003ccode\u003ecomparable\u003c/code\u003e is not the same\nas the set of all \u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable types\u003c/a\u003e defined by the Go spec.\n\u003ca href=\"/ref/spec#Interface_types\"\u003eBy construction\u003c/a\u003e, a type set specified by an interface\n(including \u003ccode\u003ecomparable\u003c/code\u003e) does not contain the interface itself (or any other interface).\nThus, an interface such as \u003ccode\u003eany\u003c/code\u003e is not included in \u003ccode\u003ecomparable\u003c/code\u003e,\neven though all interfaces support \u003ccode\u003e==\u003c/code\u003e.\nWhat gives?\u003c/p\u003e\n\u003cp\u003eComparison of interfaces (and of composite types containing them) may panic at run time:\nthis happens when the dynamic type, the type of the actual value stored in the\ninterface variable, is not comparable.\nConsider our original \u003ccode\u003elookupTable\u003c/code\u003e example: it accepts arbitrary values as keys.\nBut if we try to enter a value with a key that does not support \u003ccode\u003e==\u003c/code\u003e, say\na slice value, we get a run-time panic:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003elookupTable[[]int{}] = \u0026#34;slice\u0026#34;  // PANIC: runtime error: hash of unhashable type []int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy contrast, \u003ccode\u003ecomparable\u003c/code\u003e contains only types that the compiler guarantees will not panic with \u003ccode\u003e==\u003c/code\u003e.\nWe call these types \u003cem\u003estrictly comparable\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eMost of the time this is exactly what we want: it’s comforting to know that \u003ccode\u003e==\u003c/code\u003e in a generic\nfunction won’t panic if the operands are constrained by \u003ccode\u003ecomparable\u003c/code\u003e, and it is what we\nwould intuitively expect.\u003c/p\u003e\n\u003cp\u003eUnfortunately, this definition of \u003ccode\u003ecomparable\u003c/code\u003e together with the rules for\nconstraint satisfaction prevented us from writing useful\ngeneric code, such as the \u003ccode\u003egenericLookupTable\u003c/code\u003e type shown earlier:\nfor \u003ccode\u003eany\u003c/code\u003e to be an acceptable argument type, \u003ccode\u003eany\u003c/code\u003e must satisfy (and therefore implement) \u003ccode\u003ecomparable\u003c/code\u003e.\nBut the type set of \u003ccode\u003eany\u003c/code\u003e is larger than (not a subset of) the type set of \u003ccode\u003ecomparable\u003c/code\u003e\nand therefore does not implement \u003ccode\u003ecomparable\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar lookupTable GenericLookupTable[any, string] // ERROR: any does not implement comparable (Go 1.18 and Go 1.19)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsers recognized the problem early on and filed a multitude of issues and proposals in short order\n(\u003ca href=\"/issue/51338\"\u003e#51338\u003c/a\u003e,\n\u003ca href=\"/issue/52474\"\u003e#52474\u003c/a\u003e,\n\u003ca href=\"/issue/52531\"\u003e#52531\u003c/a\u003e,\n\u003ca href=\"/issue/52614\"\u003e#52614\u003c/a\u003e,\n\u003ca href=\"/issue/52624\"\u003e#52624\u003c/a\u003e,\n\u003ca href=\"/issue/53734\"\u003e#53734\u003c/a\u003e,\netc).\nClearly this was a problem we needed to address.\u003c/p\u003e\n\u003cp\u003eThe “obvious” solution was simply to include even non-strictly comparable types in the\n\u003ccode\u003ecomparable\u003c/code\u003e type set.\nBut this leads to inconsistencies with the type set model.\nConsider the following example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc f[Q comparable]() { … }\n\nfunc g[P any]() {\n        _ = f[int] // (1) ok: int implements comparable\n        _ = f[P]   // (2) error: type parameter P does not implement comparable\n        _ = f[any] // (3) error: any does not implement comparable (Go 1.18, Go.19)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunction \u003ccode\u003ef\u003c/code\u003e requires a type argument that is strictly comparable.\nObviously it is ok to instantiate \u003ccode\u003ef\u003c/code\u003e with \u003ccode\u003eint\u003c/code\u003e: \u003ccode\u003eint\u003c/code\u003e values never panic on \u003ccode\u003e==\u003c/code\u003e\nand thus \u003ccode\u003eint\u003c/code\u003e implements \u003ccode\u003ecomparable\u003c/code\u003e (case 1).\nOn the other hand, instantiating \u003ccode\u003ef\u003c/code\u003e with \u003ccode\u003eP\u003c/code\u003e is not permitted: \u003ccode\u003eP\u003c/code\u003e’s type set is defined\nby its constraint \u003ccode\u003eany\u003c/code\u003e, and \u003ccode\u003eany\u003c/code\u003e stands for the set of all possible types.\nThis set includes types that are not comparable at all.\nHence, \u003ccode\u003eP\u003c/code\u003e doesn’t implement \u003ccode\u003ecomparable\u003c/code\u003e and thus cannot be used to instantiate \u003ccode\u003ef\u003c/code\u003e\n(case 2).\nAnd finally, using the type \u003ccode\u003eany\u003c/code\u003e (rather than a type parameter constrained by \u003ccode\u003eany\u003c/code\u003e)\ndoesn’t work either, because of exactly the same problem (case 3).\u003c/p\u003e\n\u003cp\u003eYet, we do want to be able to use the type \u003ccode\u003eany\u003c/code\u003e as type argument in this case.\nThe only way out of this dilemma was to change the language somehow.\nBut how?\u003c/p\u003e\n\u003ch2 id=\"interface-implementation-vs-constraint-satisfaction\"\u003eInterface implementation vs constraint satisfaction\u003c/h2\u003e\n\u003cp\u003eAs mentioned earlier, constraint satisfaction is interface implementation:\na type argument \u003ccode\u003eT\u003c/code\u003e satisfies a constraint \u003ccode\u003eC\u003c/code\u003e if \u003ccode\u003eT\u003c/code\u003e implements \u003ccode\u003eC\u003c/code\u003e.\nThis makes sense: \u003ccode\u003eT\u003c/code\u003e must be in the type set expected by \u003ccode\u003eC\u003c/code\u003e which is\nexactly the definition of interface implementation.\u003c/p\u003e\n\u003cp\u003eBut this is also the problem because it prevents us from using non-strictly comparable\ntypes as type arguments for \u003ccode\u003ecomparable\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eSo for Go 1.20, after almost a year of publicly discussing numerous alternatives\n(see the issues mentioned above), we decided to introduce an exception for just this case.\nTo avoid the inconsistency, rather than changing what \u003ccode\u003ecomparable\u003c/code\u003e means,\nwe differentiated between \u003cem\u003einterface implementation\u003c/em\u003e,\nwhich is relevant for passing values to variables, and \u003cem\u003econstraint satisfaction\u003c/em\u003e,\nwhich is relevant for passing type arguments to type parameters.\nOnce separated, we could give each of those concepts (slightly) different\nrules, and that is exactly what we did with proposal \u003ca href=\"/issue/56548\"\u003e#56548\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe good news is that the exception is quite localized in the\n\u003ca href=\"/ref/spec#Satisfying_a_type_constraint\"\u003espec\u003c/a\u003e.\nConstraint satisfaction remains almost the same as interface implementation, with a caveat:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA type \u003ccode\u003eT\u003c/code\u003e satisfies a constraint \u003ccode\u003eC\u003c/code\u003e if\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eT\u003c/code\u003e implements \u003ccode\u003eC\u003c/code\u003e; or\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eC\u003c/code\u003e can be written in the form \u003ccode\u003einterface{ comparable; E }\u003c/code\u003e, where \u003ccode\u003eE\u003c/code\u003e is a basic interface\nand \u003ccode\u003eT\u003c/code\u003e is \u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable\u003c/a\u003e and implements \u003ccode\u003eE\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe second bullet point is the exception.\nWithout going too much into the formalism of the spec, what the exception says is the following:\na constraint \u003ccode\u003eC\u003c/code\u003e that expects strictly comparable types (and which may also have other requirements\nsuch as methods \u003ccode\u003eE\u003c/code\u003e) is satisfied by any type argument \u003ccode\u003eT\u003c/code\u003e that supports \u003ccode\u003e==\u003c/code\u003e\n(and which also implements the methods in \u003ccode\u003eE\u003c/code\u003e, if any).\nOr even shorter: a type that supports \u003ccode\u003e==\u003c/code\u003e also satisfies \u003ccode\u003ecomparable\u003c/code\u003e\n(even though it may not implement it).\u003c/p\u003e\n\u003cp\u003eWe can immediately see that this change is backward-compatible:\nbefore Go 1.20, constraint satisfaction was the same as interface implementation, and we still\nhave that rule (1st bullet point).\nAll code that relied on that rule continues to work as before.\nOnly if that rule fails do we need to consider the exception.\u003c/p\u003e\n\u003cp\u003eLet’s revisit our previous example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc f[Q comparable]() { … }\n\nfunc g[P any]() {\n        _ = f[int] // (1) ok: int satisfies comparable\n        _ = f[P]   // (2) error: type parameter P does not satisfy comparable\n        _ = f[any] // (3) ok: satisfies comparable (Go 1.20)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, \u003ccode\u003eany\u003c/code\u003e does satisfy (but not implement!) \u003ccode\u003ecomparable\u003c/code\u003e.\nWhy?\nBecause Go permits \u003ccode\u003e==\u003c/code\u003e to be used with values of type \u003ccode\u003eany\u003c/code\u003e\n(which corresponds to the type \u003ccode\u003eT\u003c/code\u003e in the spec rule),\nand because the constraint \u003ccode\u003ecomparable\u003c/code\u003e (which corresponds to the constraint \u003ccode\u003eC\u003c/code\u003e in the rule)\ncan be written as \u003ccode\u003einterface{ comparable; E }\u003c/code\u003e where \u003ccode\u003eE\u003c/code\u003e is simply the empty interface\nin this example (case 3).\u003c/p\u003e\n\u003cp\u003eInterestingly, \u003ccode\u003eP\u003c/code\u003e still does not satisfy \u003ccode\u003ecomparable\u003c/code\u003e (case 2).\nThe reason is that \u003ccode\u003eP\u003c/code\u003e is a type parameter constrained by \u003ccode\u003eany\u003c/code\u003e (it \u003cem\u003eis not\u003c/em\u003e \u003ccode\u003eany\u003c/code\u003e).\nThe operation \u003ccode\u003e==\u003c/code\u003e is \u003cem\u003enot\u003c/em\u003e available with all types in the type set of \u003ccode\u003eP\u003c/code\u003e\nand thus not available on \u003ccode\u003eP\u003c/code\u003e;\nit is not a \u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable type\u003c/a\u003e.\nTherefore the exception doesn’t apply.\nBut this is ok: we do like to know that \u003ccode\u003ecomparable\u003c/code\u003e, the strict comparability\nrequirement, is enforced most of the time. We just need an exception for\nGo types that support \u003ccode\u003e==\u003c/code\u003e, essentially for historical reasons:\nwe always had the ability to compare non-strictly comparable types.\u003c/p\u003e\n\u003ch2 id=\"consequences-and-remedies\"\u003eConsequences and remedies\u003c/h2\u003e\n\u003cp\u003eWe gophers take pride in the fact that language-specific behavior\ncan be explained and reduced to a fairly compact set of rules, spelled out\nin the language spec.\nOver the years we have refined these rules, and when possible made them\nsimpler and often more general.\nWe also have been careful to keep the rules orthogonal,\nalways on the lookout for unintended and unfortunate consequences.\nDisputes are resolved by consulting the spec, not by decree.\nThat is what we have aspired to since the inception of Go.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eOne does not simply add an exception to a carefully crafted type\nsystem without consequences!\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eSo where’s the catch?\nThere’s an obvious (if mild) drawback, and a less obvious (and more\nsevere) one.\nObviously, we now have a more complex rule for constraint satisfaction\nwhich is arguably less elegant than what we had before.\nThis is unlikely to affect our day-to-day work in any significant way.\u003c/p\u003e\n\u003cp\u003eBut we do pay a price for the exception: in Go 1.20, generic functions\nthat rely on \u003ccode\u003ecomparable\u003c/code\u003e are not statically type-safe anymore.\nThe \u003ccode\u003e==\u003c/code\u003e and \u003ccode\u003e!=\u003c/code\u003e operations may panic if applied to operands of\n\u003ccode\u003ecomparable\u003c/code\u003e type parameters, even though the declaration says\nthat they are strictly comparable.\nA single non-comparable value may sneak its way through\nmultiple generic functions or types by way of a single non-strictly\ncomparable type argument and cause a panic.\nIn Go 1.20 we can now declare\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar lookupTable genericLookupTable[any, string]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewithout compile-time error, but we will get a run-time panic\nif we ever use a non-strictly comparable key type in this case, exactly like we would\nwith the built-in \u003ccode\u003emap\u003c/code\u003e type.\nWe have given up static type safety for a run-time check.\u003c/p\u003e\n\u003cp\u003eThere may be situations where this is not good enough,\nand where we want to enforce strict comparability.\nThe following observation allows us to do exactly that, at least in limited\nform: type parameters do not benefit from the exception that we added to the\nconstraint satisfaction rule.\nFor instance, in our earlier example, the type parameter \u003ccode\u003eP\u003c/code\u003e in the function\n\u003ccode\u003eg\u003c/code\u003e is constrained by \u003ccode\u003eany\u003c/code\u003e (which by itself is comparable but not strictly comparable)\nand so \u003ccode\u003eP\u003c/code\u003e does not satisfy \u003ccode\u003ecomparable\u003c/code\u003e.\nWe can use this knowledge to craft a compile-time assertion of sorts for\na given type \u003ccode\u003eT\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003etype T struct { … }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe want to assert that \u003ccode\u003eT\u003c/code\u003e is strictly comparable.\nIt’s tempting to write something like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// isComparable may be instantiated with any type that supports ==\n// including types that are not strictly comparable because of the\n// exception for constraint satisfaction.\nfunc isComparable[_ comparable]() {}\n\n// Tempting but not quite what we want: this declaration is also\n// valid for types T that are not strictly comparable.\nvar _ = isComparable[T] // compile-time error if T does not support ==\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe dummy (blank) variable declaration serves as our “assertion”.\nBut because of the exception in the constraint satisfaction rule,\n\u003ccode\u003eisComparable[T]\u003c/code\u003e only fails if \u003ccode\u003eT\u003c/code\u003e is not comparable at all;\nit will succeed if \u003ccode\u003eT\u003c/code\u003e supports \u003ccode\u003e==\u003c/code\u003e.\nWe can work around this problem by using \u003ccode\u003eT\u003c/code\u003e not as a type argument,\nbut as a type constraint:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc _[P T]() {\n    _ = isComparable[P] // P supports == only if T is strictly comparable\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere is a \u003ca href=\"/play/p/9i9iEto3TgE\"\u003epassing\u003c/a\u003e and \u003ca href=\"/play/p/5d4BeKLevPB\"\u003efailing\u003c/a\u003e playground example\nillustrating this mechanism.\u003c/p\u003e\n\u003ch2 id=\"final-observations\"\u003eFinal observations\u003c/h2\u003e\n\u003cp\u003eInterestingly, until two months before the Go 1.18\nrelease, the compiler implemented constraint satisfaction exactly as we do\nnow in Go 1.20.\nBut because at that time constraint satisfaction meant interface implementation,\nwe did have an implementation that was inconsistent with the language specification.\nWe were alerted to this fact with \u003ca href=\"/issue/50646\"\u003eissue #50646\u003c/a\u003e.\nWe were extremely close to the release and had to make a decision quickly.\nIn the absence of a convincing solution, it seemed safest to make the\nimplementation consistent with the spec.\nA year later, and with plenty of time to consider different approaches,\nit seems that the implementation we had was the implementation we wanted in the first place.\nWe have come full circle.\u003c/p\u003e\n\u003cp\u003eAs always, please let us know if anything doesn’t work as expected\nby filing issues at \u003ca href=\"/issue/new\"\u003ehttps://go.dev/issue/new\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThank you!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-02-17T00:00:00Z",
  "Author": "Robert Griesemer"
}