{
  "Source": "go.dev",
  "Title": "Telemetry in Go 1.23 and beyond",
  "Link": "https://go.dev/blog/gotelemetry",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/gotelemetry\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eTelemetry in Go 1.23 and beyond\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Findley\u003cbr/\u003e\n      3 September 2024\n      \u003c/p\u003e\n      \n      \u003cstyle type=\"text/css\" scoped=\"\"\u003e\n  #blog #content img#prompt {\n    max-width: 500px;\n  }\n  .centered {\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n  .chart {\n    width: 100%;\n  }\n  @media (prefers-color-scheme: dark) {\n    .chart {\n      border-radius: 8px;\n    }\n  }\n  figure.captioned {\n    display: table;\n  }\n  figure.captioned figcaption {\n    display: table-caption;\n    caption-side: bottom;\n    font-style: italic;\n    font-size: small;\n    text-align: center;\n  }\n\u003c/style\u003e\n\u003cp\u003eGo 1.23 provides a new way for you to help improve the Go toolchain. By\nenabling \u003ca href=\"/doc/go1.23#telemetry\"\u003etelemetry uploading\u003c/a\u003e, you can elect to share\ndata about toolchain programs and their usage with the Go team. This data will\nhelp Go contributors fix bugs, avoid regressions, and make better decisions.\u003c/p\u003e\n\u003cp\u003eBy default, Go telemetry data is stored only on your local computer. If you\nenable uploading, a \u003ca href=\"/doc/telemetry#proposals\"\u003elimited\u003c/a\u003e subset of your data\nis published weekly to \u003ca href=\"https://telemetry.go.dev\" rel=\"noreferrer\" target=\"_blank\"\u003etelemetry.go.dev\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eStarting with Go 1.23, you can enable uploading of your local telemetry data\nwith the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego telemetry on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo disable even local telemetry data collection, run the following command:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego telemetry off\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href=\"/doc/telemetry\"\u003etelemetry documentation\u003c/a\u003e contains a more detailed\ndescription of the implementation.\u003c/p\u003e\n\u003ch2 id=\"a-brief-history-of-go-telemetry\"\u003eA brief history of Go telemetry\u003c/h2\u003e\n\u003cp\u003eWhile software telemetry is not a new idea, the Go team went through many\niterations in search of a telemetry implementation that met Go’s requirements\nfor performance, portability, and transparency.\u003c/p\u003e\n\u003cp\u003eThe initial \u003ca href=\"https://research.swtch.com/telemetry-design\" rel=\"noreferrer\" target=\"_blank\"\u003edesign\u003c/a\u003e aimed to be\nso unobtrusive, open, and privacy-preserving that it would be acceptable to\nenable by default, but many users raised concerns in a lengthy \u003ca href=\"/issue/58409\"\u003epublic\ndiscussion\u003c/a\u003e, and the design was ultimately\n\u003ca href=\"https://research.swtch.com/telemetry-opt-in#campaign\" rel=\"noreferrer\" target=\"_blank\"\u003echanged\u003c/a\u003e to require\nexplicit user consent for remote uploading.\u003c/p\u003e\n\u003cp\u003eThe new design was \u003ca href=\"/issue/58894\"\u003eaccepted\u003c/a\u003e in April 2023, and implemented over\nthat summer.\u003c/p\u003e\n\u003ch3 id=\"telemetry-in-gopls\"\u003eTelemetry in gopls\u003c/h3\u003e\n\u003cp\u003eThe first iteration of Go telemetry shipped in\n\u003ca href=\"https://github.com/golang/tools/releases/tag/gopls%2Fv0.14.0\" rel=\"noreferrer\" target=\"_blank\"\u003ev0.14\u003c/a\u003e\nof the Go language server\n\u003ca href=\"https://go.googlesource.com/tools/+/refs/heads/master/gopls/\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egopls\u003c/code\u003e\u003c/a\u003e, in\nOctober 2023. Following the launch, around 100 users enabled uploading,\nperhaps motivated by release notes or discussion in the\n\u003ca href=\"https://gophers.slack.com/messages/gopls/\" rel=\"noreferrer\" target=\"_blank\"\u003eGophers Slack\u003c/a\u003e channel, and data\nstarted to trickle in. It wasn’t long before telemetry found its first bug in\ngopls:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cdiv class=\"centered\"\u003e\n\u003cfigure class=\"captioned\"\u003e\n\u003cimg src=\"gotelemetry/neat.png\" alt=\"Telemetry found its first bug\"/\u003e\n\u003cfigcaption\u003e\nA stack trace Dan noticed in his uploaded telemetry data led to a bug being\nreported and fixed. It\u0026#39;s worth pointing out that we had no idea who had\nreported the stack.\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003ch3 id=\"ide-prompting\"\u003eIDE Prompting\u003c/h3\u003e\n\u003cp\u003eWhile it was great to see telemetry working in practice, and we appreciated the\nsupport of those early adopters, 100 participants isn’t enough to measure the\ntypes of things we want to measure.\u003c/p\u003e\n\u003cp\u003eAs Russ Cox \u003ca href=\"https://research.swtch.com/telemetry-opt-in#campaign\" rel=\"noreferrer\" target=\"_blank\"\u003epointed out\u003c/a\u003e\nin his original blog posts, a drawback of the off-by-default approach for\ntelemetry is the continuous need to encourage participation. It takes outreach\nto maintain a sample of users that’s big enough for meaningful quantitative\ndata analysis, and representative of the user population. While blog posts and\nrelease notes can boost participation (and we’d appreciate it if you would\nenable telemetry after reading this!), they lead to a skewed sample. For\nexample, we received almost no data for \u003ccode\u003eGOOS=windows\u003c/code\u003e from early adopters of\ntelemetry in gopls.\u003c/p\u003e\n\u003cp\u003eTo help reach more users, we introduced a \u003ca href=\"/doc/telemetry#ide\"\u003eprompt\u003c/a\u003e in the\n\u003ca href=\"https://marketplace.visualstudio.com/items?itemName=golang.go\" rel=\"noreferrer\" target=\"_blank\"\u003eVS Code Go plugin\u003c/a\u003e\nasking users if they want to enable telemetry:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cdiv class=\"centered\"\u003e\n\u003cfigure class=\"captioned\"\u003e\n\u003cimg id=\"prompt\" src=\"gotelemetry/prompt.png\" alt=\"The VS Code prompt\"/\u003e\n\u003cfigcaption\u003e\nThe telemetry prompt, as displayed by VS Code.\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eAs of this blog post, the prompt has rolled out to 5% of VS Code Go users, and\nthe telemetry sample has grown to around 1800 weekly participants:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cdiv class=\"centered\"\u003e\n\u003cfigure class=\"captioned\"\u003e\n\u003cimg src=\"gotelemetry/uploads.png\" alt=\"Weekly Uploads vs Prompt Rate\" class=\"chart\"/\u003e\n\u003cfigcaption\u003ePrompting helps reach more users.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e(The initial bump is likely due to prompting \u003cem\u003eall\u003c/em\u003e users of the\n\u003ca href=\"https://marketplace.visualstudio.com/items?itemName=golang.go-nightly\" rel=\"noreferrer\" target=\"_blank\"\u003eVS Code Go nightly\u003c/a\u003e\nextension).\u003c/p\u003e\n\u003cp\u003eHowever, it has introduced a noticeable skew toward VS Code users, as compared\nto the \u003ca href=\"survey2024-h1-results.md\"\u003emost recent Go survey results\u003c/a\u003e:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cdiv class=\"centered\"\u003e\n\u003cfigure class=\"captioned\"\u003e\n\u003cimg src=\"gotelemetry/vscode_skew.png\" alt=\"Skew toward VS Code users\" class=\"chart\"/\u003e\n\u003cfigcaption\u003eWe suspect that VS Code is overrepresented in telemetry data.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eWe’re planning to address this skew by \u003ca href=\"/issue/67821\"\u003eprompting all LSP-capable editors that\nuse gopls\u003c/a\u003e, using a feature of the language server protocol\nitself.\u003c/p\u003e\n\u003ch3 id=\"telemetry-wins\"\u003eTelemetry wins\u003c/h3\u003e\n\u003cp\u003eOut of caution, we proposed the collection of only a few basic metrics for the\ninitial launch of telemetry in gopls. One of those was the\n\u003ca href=\"/issue/62249\"\u003e\u003ccode\u003egopls/bug\u003c/code\u003e\u003c/a\u003e \u003ca href=\"/doc/telemetry#stack-counters\"\u003estack counter\u003c/a\u003e,\nwhich records unexpected or “impossible” conditions encountered by gopls. In\neffect, it’s a kind of assertion, but instead of stopping the program, it\nrecords in telemetry that it was reached in some execution, along with the\nstack.\u003c/p\u003e\n\u003cp\u003eDuring our \u003ca href=\"gopls-scalability.md\"\u003egopls scalability\u003c/a\u003e work, we had added many\nassertions of this kind, but we rarely observed them to fail in tests or in our\nown usage of gopls. We expected that almost all of these assertions were\nunreachable.\u003c/p\u003e\n\u003cp\u003eAs we started prompting random users in VS Code to enable telemetry, we saw\nthat many of these conditions \u003cem\u003ewere\u003c/em\u003e reached in practice, and the context of\nthe stack trace was often sufficient for us to reproduce and fix long-standing\nbugs. We started collecting these issues under the\n\u003ca href=\"https://github.com/golang/go/issues?q=is%3Aissue+label%3Agopls%2Ftelemetry-wins\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egopls/telemetry-wins\u003c/code\u003e\u003c/a\u003e\nlabel, to keep track of “wins” facilitated by telemetry.\u003c/p\u003e\n\u003cp\u003eI’ve come to think of “telemetry wins” with a second meaning: when comparing\ngopls development with and without telemetry, \u003cem\u003etelemetry wins\u003c/em\u003e.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n\u003cdiv class=\"centered\"\u003e\n\u003cfigure class=\"captioned\"\u003e\n\u003cimg src=\"gotelemetry/telemetry_wins.png\" alt=\"Telemetry wins.\"/\u003e\n\u003cfigcaption\u003eThank you Paul for the suggestions.\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eThe most surprising aspect of the bugs coming from telemetry was how many of\nthem were \u003cem\u003ereal\u003c/em\u003e. Sure, some of them were invisible to users, but a good number\nof them were actual misbehaviors of gopls–things like missing cross\nreferences, or subtly inaccurate completion under certain rare conditions. They\nwere exactly the sort of things that a user might be mildly annoyed by but\nprobably wouldn’t bother to report as an issue. Perhaps the user would assume\nthat the behavior was intended. If they did report an issue, they might not be\nsure how to reproduce the bug, or we’d need a long back-and-forth on the issue\ntracker to capture a stack trace. Without telemetry, there is\n\u003cem\u003eno reasonable way\u003c/em\u003e that most of these bugs would have been discovered, much\nless fixed.\u003c/p\u003e\n\u003cp\u003eAnd all this was from only a few counters. We’d only instrumented stack traces\nfor the potential bugs \u003cem\u003ewe knew about\u003c/em\u003e. What about problems we didn’t\nanticipate?\u003c/p\u003e\n\u003ch3 id=\"automated-crash-reporting\"\u003eAutomated crash reporting\u003c/h3\u003e\n\u003cp\u003eGo 1.23 includes a new\n\u003ca href=\"/doc/go1.23#runtimedebugpkgruntimedebug\"\u003e\u003ccode\u003eruntime.SetCrashOutput\u003c/code\u003e\u003c/a\u003e API that\ncan be used to implement automated crash reporting via a watchdog process.\nStarting with\n\u003ca href=\"https://github.com/golang/tools/releases/tag/gopls%2Fv0.15.0\" rel=\"noreferrer\" target=\"_blank\"\u003ev0.15.0\u003c/a\u003e, gopls\nreports a \u003ccode\u003ecrash/crash\u003c/code\u003e stack counter when it crashes, \u003cem\u003eprovided gopls itself\nis built with Go 1.23\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhen we released gopls@v0.15.0, only a handful of users in our sample had built\ngopls using an unreleased development build of Go 1.23, yet the new\n\u003ccode\u003ecrash/crash\u003c/code\u003e counter still found\n\u003ca href=\"https://github.com/golang/tools/releases/tag/gopls%2Fv0.15.2\" rel=\"noreferrer\" target=\"_blank\"\u003etwo bugs\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"telemetry-in-the-go-toolchain-and-beyond\"\u003eTelemetry in the Go toolchain and beyond\u003c/h2\u003e\n\u003cp\u003eGiven how useful telemetry has proven with only a tiny amount of\ninstrumentation and a fraction of our target sample, the future looks bright.\u003c/p\u003e\n\u003cp\u003eGo 1.23 records telemetry within the Go toolchain, including the \u003ccode\u003ego\u003c/code\u003e command\nand other tools such as the compiler, linker, and \u003ccode\u003ego vet\u003c/code\u003e. We’ve added\ntelemetry to \u003ccode\u003evulncheck\u003c/code\u003e and the VS Code Go plugin, and\n\u003ca href=\"/issue/68384\"\u003ewe propose\u003c/a\u003e to add it to \u003ccode\u003edelve\u003c/code\u003e as well.\u003c/p\u003e\n\u003cp\u003eThe original telemetry blog series brainstorms\n\u003ca href=\"https://research.swtch.com/telemetry-uses\" rel=\"noreferrer\" target=\"_blank\"\u003emany ideas\u003c/a\u003e for how telemetry could\nbe used to improve Go. We’re looking forward to exploring those ideas and more.\u003c/p\u003e\n\u003cp\u003eWithin gopls, we plan to use telemetry to improve reliability and inform\ndecision making and prioritization. With the automated crash reporting enabled\nby Go 1.23, we expect to catch many more crashes in prerelease testing. Going\nforward, we’ll add more counters to measure the user experience–latency of key\noperations, frequency of use of various features–so that we can focus our\nefforts where they will most benefit Go developers.\u003c/p\u003e\n\u003cp\u003eGo turns 15 this November, and both the language and its ecosystem continue to\ngrow. Telemetry will play a critical role in helping Go contributors move\nfaster and more safely, in the right direction.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-09-03T00:00:00Z",
  "Author": "Robert Findley"
}