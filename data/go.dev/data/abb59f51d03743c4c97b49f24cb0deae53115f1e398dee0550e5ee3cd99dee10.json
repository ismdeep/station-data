{
  "Source": "go.dev",
  "Title": "Debugging what you deploy in Go 1.12",
  "Link": "https://go.dev/blog/debug-opt",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/debug-opt\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eDebugging what you deploy in Go 1.12\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      David Chase\u003cbr/\u003e\n      21 March 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo 1.11 and Go 1.12 make significant progress toward allowing developers\nto debug the same optimized binaries that they deploy to production.\u003c/p\u003e\n\u003cp\u003eAs the Go compiler has become increasingly aggressive in producing faster binaries,\nwe’ve lost ground in debuggability.\nIn Go 1.10, users needed to disable optimizations entirely in order to have\na good debugging experience from interactive tools like Delve.\nBut users shouldn’t have to trade performance for debuggability,\nespecially when running production services.\nIf your problem is occurring in production,\nyou need to debug it in production, and that shouldn’t require deploying\nunoptimized binaries.\u003c/p\u003e\n\u003cp\u003eFor Go 1.11 and 1.12, we focused on improving the debugging experience on\noptimized binaries (the default setting of the Go compiler).\nImprovements include\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMore accurate value inspection, in particular for arguments at function entry;\u003c/li\u003e\n\u003cli\u003eMore precisely identifying statement boundaries so that stepping is less\njumpy and breakpoints more often land where the programmer expects;\u003c/li\u003e\n\u003cli\u003eAnd preliminary support for Delve to call Go functions (goroutines and\ngarbage collection make this trickier than it is in C and C++).\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"debugging-optimized-code-with-delve\"\u003eDebugging optimized code with Delve\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/go-delve/delve\" rel=\"noreferrer\" target=\"_blank\"\u003eDelve\u003c/a\u003e is a debugger for Go on x86\nsupporting both Linux and macOS.\nDelve is aware of goroutines and other Go features and provides one of the\nbest Go debugging experiences.\nDelve is also the debugging engine behind \u003ca href=\"https://www.jetbrains.com/go/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoLand\u003c/a\u003e,\n\u003ca href=\"https://code.visualstudio.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eVS Code\u003c/a\u003e,\nand \u003ca href=\"https://github.com/fatih/vim-go\" rel=\"noreferrer\" target=\"_blank\"\u003eVim\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eDelve normally rebuilds the code it is debugging with \u003ccode\u003e-gcflags \u0026#34;all=-N -l\u0026#34;\u003c/code\u003e,\nwhich disables inlining and most optimizations.\nTo debug optimized code with delve, first build the optimized binary,\nthen use \u003ccode\u003edlv exec your_program\u003c/code\u003e to debug it.\nOr, if you have a core file from a crash,\nyou can examine it with \u003ccode\u003edlv core your_program your_core\u003c/code\u003e.\nWith 1.12 and the latest Delve releases, you should be able to examine many variables,\neven in optimized binaries.\u003c/p\u003e\n\u003ch2 id=\"improved-value-inspection\"\u003eImproved value inspection\u003c/h2\u003e\n\u003cp\u003eWhen debugging optimized binaries produced by Go 1.10,\nvariable values were usually completely unavailable.\nIn contrast, starting with Go 1.11, variables can usually be examined even\nin optimized binaries,\nunless they’ve been optimized away completely.\nIn Go 1.11 the compiler began emitting DWARF location lists so debuggers\ncan track variables as they move in and out of registers and reconstruct\ncomplex objects that are split across different registers and stack slots.\u003c/p\u003e\n\u003ch2 id=\"improved-stepping\"\u003eImproved stepping\u003c/h2\u003e\n\u003cp\u003eThis shows an example of stepping through a simple function in a debugger in 1.10,\nwith flaws (skipped and repeated lines) highlighted by red arrows.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"debug-opt/stepping.svg\" width=\"450\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eFlaws like this make it easy to lose track of where you are when stepping\nthrough a program and interfere with hitting breakpoints.\u003c/p\u003e\n\u003cp\u003eGo 1.11 and 1.12 record statement boundary information and do a better job\nof tracking source line numbers through optimizations and inlining.\nAs a result, in Go 1.12, stepping through this code stops on every line\nand does so in the order you would expect.\u003c/p\u003e\n\u003ch2 id=\"function-calls\"\u003eFunction calls\u003c/h2\u003e\n\u003cp\u003eFunction call support in Delve is still under development, but simple cases work.  For example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(dlv) call fib(6)\n\u0026gt; main.main() ./hello.go:15 (PC: 0x49d648)\nValues returned:\n    ~r1: 8\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"the-path-forward\"\u003eThe path forward\u003c/h2\u003e\n\u003cp\u003eGo 1.12 is a step toward a better debugging experience for optimized binaries\nand we have plans to improve it even further.\u003c/p\u003e\n\u003cp\u003eThere are fundamental tradeoffs between debuggability and performance,\nso we’re focusing on the highest-priority debugging defects,\nand working to collect automated metrics to monitor our progress and catch regressions.\u003c/p\u003e\n\u003cp\u003eWe’re focusing on generating correct information for debuggers about variable locations,\nso if a variable can be printed, it is printed correctly.\nWe’re also looking at making variable values available more of the time,\nparticularly at key points like call sites,\nthough in many cases improving this would require slowing down program execution.\nFinally, we’re working on improving stepping:\nwe’re focusing on the order of stepping with panics,\nthe order of stepping around loops, and generally trying to follow source\norder where possible.\u003c/p\u003e\n\u003ch2 id=\"a-note-on-macos-support\"\u003eA note on macOS support\u003c/h2\u003e\n\u003cp\u003eGo 1.11 started compressing debug information to reduce binary sizes.\nThis is natively supported by Delve, but neither LLDB nor GDB support compressed\ndebug info on macOS.\nIf you are using LLDB or GDB, there are two workarounds:\nbuild binaries with \u003ccode\u003e-ldflags=-compressdwarf=false\u003c/code\u003e,\nor use \u003ca href=\"https://godoc.org/golang.org/x/tools/cmd/splitdwarf\" rel=\"noreferrer\" target=\"_blank\"\u003esplitdwarf\u003c/a\u003e\n(\u003ccode\u003ego get golang.org/x/tools/cmd/splitdwarf\u003c/code\u003e) to decompress the debug information\nin an existing binary.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-03-21T00:00:00Z",
  "Author": "David Chase"
}