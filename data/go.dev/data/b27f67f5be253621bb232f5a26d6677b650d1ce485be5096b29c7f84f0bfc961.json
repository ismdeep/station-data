{
  "Source": "go.dev",
  "Title": "Go Slices: usage and internals",
  "Link": "https://go.dev/blog/slices-intro",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/slices-intro\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Slices: usage and internals\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      5 January 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo’s slice type provides a convenient and efficient means of working with\nsequences of typed data.\nSlices are analogous to arrays in other languages,\nbut have some unusual properties.\nThis article will look at what slices are and how they are used.\u003c/p\u003e\n\u003ch2 id=\"arrays\"\u003eArrays\u003c/h2\u003e\n\u003cp\u003eThe slice type is an abstraction built on top of Go’s array type,\nand so to understand slices we must first understand arrays.\u003c/p\u003e\n\u003cp\u003eAn array type definition specifies a length and an element type.\nFor example, the type \u003ccode\u003e[4]int\u003c/code\u003e represents an array of four integers.\nAn array’s size is fixed; its length is part of its type (\u003ccode\u003e[4]int\u003c/code\u003e and \u003ccode\u003e[5]int\u003c/code\u003e are distinct,\nincompatible types).\nArrays can be indexed in the usual way, so the expression \u003ccode\u003es[n]\u003c/code\u003e accesses\nthe nth element, starting from zero.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar a [4]int\na[0] = 1\ni := a[0]\n// i == 1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eArrays do not need to be initialized explicitly;\nthe zero value of an array is a ready-to-use array whose elements are themselves zeroed:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// a[2] == 0, the zero value of the int type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe in-memory representation of \u003ccode\u003e[4]int\u003c/code\u003e is just four integer values laid out sequentially:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"slices-intro/slice-array.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eGo’s arrays are values. An array variable denotes the entire array;\nit is not a pointer to the first array element (as would be the case in C).\nThis means that when you assign or pass around an array value you will make\na copy of its contents.\n(To avoid the copy you could pass a \u003cem\u003epointer\u003c/em\u003e to the array,\nbut then that’s a pointer to an array, not an array.) One way to think about\narrays is as a sort of struct but with indexed rather than named fields:\na fixed-size composite value.\u003c/p\u003e\n\u003cp\u003eAn array literal can be specified like so:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := [2]string{\u0026#34;Penn\u0026#34;, \u0026#34;Teller\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOr, you can have the compiler count the array elements for you:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := [...]string{\u0026#34;Penn\u0026#34;, \u0026#34;Teller\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn both cases, the type of \u003ccode\u003eb\u003c/code\u003e is \u003ccode\u003e[2]string\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"slices\"\u003eSlices\u003c/h2\u003e\n\u003cp\u003eArrays have their place, but they’re a bit inflexible,\nso you don’t see them too often in Go code.\nSlices, though, are everywhere. They build on arrays to provide great power and convenience.\u003c/p\u003e\n\u003cp\u003eThe type specification for a slice is \u003ccode\u003e[]T\u003c/code\u003e,\nwhere \u003ccode\u003eT\u003c/code\u003e is the type of the elements of the slice.\nUnlike an array type, a slice type has no specified length.\u003c/p\u003e\n\u003cp\u003eA slice literal is declared just like an array literal, except you leave out the element count:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eletters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA slice can be created with the built-in function called \u003ccode\u003emake\u003c/code\u003e, which has the signature,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc make([]T, len, cap) []T\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere T stands for the element type of the slice to be created.\nThe \u003ccode\u003emake\u003c/code\u003e function takes a type, a length,\nand an optional capacity.\nWhen called, \u003ccode\u003emake\u003c/code\u003e allocates an array and returns a slice that refers to that array.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar s []byte\ns = make([]byte, 5, 5)\n// s == []byte{0, 0, 0, 0, 0}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen the capacity argument is omitted, it defaults to the specified length.\nHere’s a more succinct version of the same code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es := make([]byte, 5)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe length and capacity of a slice can be inspected using the built-in \u003ccode\u003elen\u003c/code\u003e and \u003ccode\u003ecap\u003c/code\u003e functions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elen(s) == 5\ncap(s) == 5\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe next two sections discuss the relationship between length and capacity.\u003c/p\u003e\n\u003cp\u003eThe zero value of a slice is \u003ccode\u003enil\u003c/code\u003e. The \u003ccode\u003elen\u003c/code\u003e and \u003ccode\u003ecap\u003c/code\u003e functions will both return 0 for a nil slice.\u003c/p\u003e\n\u003cp\u003eA slice can also be formed by “slicing” an existing slice or array.\nSlicing is done by specifying a half-open range with two indices separated by a colon.\nFor example, the expression \u003ccode\u003eb[1:4]\u003c/code\u003e creates a slice including elements\n1 through 3 of \u003ccode\u003eb\u003c/code\u003e (the indices of the resulting slice will be 0 through 2).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := []byte{\u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;}\n// b[1:4] == []byte{\u0026#39;o\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;}, sharing the same storage as b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe start and end indices of a slice expression are optional; they default to zero and the slice’s length respectively:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// b[:2] == []byte{\u0026#39;g\u0026#39;, \u0026#39;o\u0026#39;}\n// b[2:] == []byte{\u0026#39;l\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;}\n// b[:] == b\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is also the syntax to create a slice given an array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ex := [3]string{\u0026#34;Лайка\u0026#34;, \u0026#34;Белка\u0026#34;, \u0026#34;Стрелка\u0026#34;}\ns := x[:] // a slice referencing the storage of x\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"slice-internals\"\u003eSlice internals\u003c/h2\u003e\n\u003cp\u003eA slice is a descriptor of an array segment.\nIt consists of a pointer to the array, the length of the segment,\nand its capacity (the maximum length of the segment).\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"slices-intro/slice-struct.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eOur variable \u003ccode\u003es\u003c/code\u003e, created earlier by \u003ccode\u003emake([]byte, 5)\u003c/code\u003e, is structured like this:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"slices-intro/slice-1.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe length is the number of elements referred to by the slice.\nThe capacity is the number of elements in the underlying array (beginning\nat the element referred to by the slice pointer).\nThe distinction between length and capacity will be made clear as we walk\nthrough the next few examples.\u003c/p\u003e\n\u003cp\u003eAs we slice \u003ccode\u003es\u003c/code\u003e, observe the changes in the slice data structure and their relation to the underlying array:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es = s[2:4]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"slices-intro/slice-2.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eSlicing does not copy the slice’s data. It creates a new slice value that\npoints to the original array.\nThis makes slice operations as efficient as manipulating array indices.\nTherefore, modifying the \u003cem\u003eelements\u003c/em\u003e (not the slice itself) of a re-slice\nmodifies the elements of the original slice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ed := []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;}\ne := d[2:]\n// e == []byte{\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;}\ne[1] = \u0026#39;m\u0026#39;\n// e == []byte{\u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}\n// d == []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEarlier we sliced \u003ccode\u003es\u003c/code\u003e to a length shorter than its capacity. We can grow s to its capacity by slicing it again:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es = s[:cap(s)]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"slices-intro/slice-3.png\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eA slice cannot be grown beyond its capacity.\nAttempting to do so will cause a runtime panic,\njust as when indexing outside the bounds of a slice or array.\nSimilarly, slices cannot be re-sliced below zero to access earlier elements in the array.\u003c/p\u003e\n\u003ch2 id=\"growing-slices-the-copy-and-append-functions\"\u003eGrowing slices (the copy and append functions)\u003c/h2\u003e\n\u003cp\u003eTo increase the capacity of a slice one must create a new,\nlarger slice and copy the contents of the original slice into it.\nThis technique is how dynamic array implementations from other languages\nwork behind the scenes.\nThe next example doubles the capacity of \u003ccode\u003es\u003c/code\u003e by making a new slice,\n\u003ccode\u003et\u003c/code\u003e, copying the contents of \u003ccode\u003es\u003c/code\u003e into \u003ccode\u003et\u003c/code\u003e,\nand then assigning the slice value \u003ccode\u003et\u003c/code\u003e to \u003ccode\u003es\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003et := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0\nfor i := range s {\n        t[i] = s[i]\n}\ns = t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe looping piece of this common operation is made easier by the built-in copy function.\nAs the name suggests, copy copies data from a source slice to a destination slice.\nIt returns the number of elements copied.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc copy(dst, src []T) int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003ecopy\u003c/code\u003e function supports copying between slices of different lengths\n(it will copy only up to the smaller number of elements).\nIn addition, \u003ccode\u003ecopy\u003c/code\u003e can handle source and destination slices that share\nthe same underlying array,\nhandling overlapping slices correctly.\u003c/p\u003e\n\u003cp\u003eUsing \u003ccode\u003ecopy\u003c/code\u003e, we can simplify the code snippet above:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003et := make([]byte, len(s), (cap(s)+1)*2)\ncopy(t, s)\ns = t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA common operation is to append data to the end of a slice.\nThis function appends byte elements to a slice of bytes,\ngrowing the slice if necessary, and returns the updated slice value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc AppendByte(slice []byte, data ...byte) []byte {\n    m := len(slice)\n    n := m + len(data)\n    if n \u0026gt; cap(slice) { // if necessary, reallocate\n        // allocate double what\u0026#39;s needed, for future growth.\n        newSlice := make([]byte, (n+1)*2)\n        copy(newSlice, slice)\n        slice = newSlice\n    }\n    slice = slice[0:n]\n    copy(slice[m:n], data)\n    return slice\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOne could use \u003ccode\u003eAppendByte\u003c/code\u003e like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ep := []byte{2, 3, 5}\np = AppendByte(p, 7, 11, 13)\n// p == []byte{2, 3, 5, 7, 11, 13}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFunctions like \u003ccode\u003eAppendByte\u003c/code\u003e are useful because they offer complete control\nover the way the slice is grown.\nDepending on the characteristics of the program,\nit may be desirable to allocate in smaller or larger chunks,\nor to put a ceiling on the size of a reallocation.\u003c/p\u003e\n\u003cp\u003eBut most programs don’t need complete control,\nso Go provides a built-in \u003ccode\u003eappend\u003c/code\u003e function that’s good for most purposes;\nit has the signature\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc append(s []T, x ...T) []T\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eappend\u003c/code\u003e function appends the elements \u003ccode\u003ex\u003c/code\u003e to the end of the slice \u003ccode\u003es\u003c/code\u003e,\nand grows the slice if a greater capacity is needed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ea := make([]int, 1)\n// a == []int{0}\na = append(a, 1, 2, 3)\n// a == []int{0, 1, 2, 3}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo append one slice to another, use \u003ccode\u003e...\u003c/code\u003e to expand the second argument to a list of arguments.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ea := []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;}\nb := []string{\u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;}\na = append(a, b...) // equivalent to \u0026#34;append(a, b[0], b[1], b[2])\u0026#34;\n// a == []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince the zero value of a slice (\u003ccode\u003enil\u003c/code\u003e) acts like a zero-length slice,\nyou can declare a slice variable and then append to it in a loop:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Filter returns a new slice holding only\n// the elements of s that satisfy fn()\nfunc Filter(s []int, fn func(int) bool) []int {\n    var p []int // == nil\n    for _, v := range s {\n        if fn(v) {\n            p = append(p, v)\n        }\n    }\n    return p\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-possible-gotcha\"\u003eA possible “gotcha”\u003c/h2\u003e\n\u003cp\u003eAs mentioned earlier, re-slicing a slice doesn’t make a copy of the underlying array.\nThe full array will be kept in memory until it is no longer referenced.\nOccasionally this can cause the program to hold all the data in memory when\nonly a small piece of it is needed.\u003c/p\u003e\n\u003cp\u003eFor example, this \u003ccode\u003eFindDigits\u003c/code\u003e function loads a file into memory and searches\nit for the first group of consecutive numeric digits,\nreturning them as a new slice.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar digitRegexp = regexp.MustCompile(\u0026#34;[0-9]+\u0026#34;)\n\nfunc FindDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    return digitRegexp.Find(b)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis code behaves as advertised, but the returned \u003ccode\u003e[]byte\u003c/code\u003e points into an\narray containing the entire file.\nSince the slice references the original array,\nas long as the slice is kept around the garbage collector can’t release the array;\nthe few useful bytes of the file keep the entire contents in memory.\u003c/p\u003e\n\u003cp\u003eTo fix this problem one can copy the interesting data to a new slice before returning it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc CopyDigits(filename string) []byte {\n    b, _ := ioutil.ReadFile(filename)\n    b = digitRegexp.Find(b)\n    c := make([]byte, len(b))\n    copy(c, b)\n    return c\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA more concise version of this function could be constructed by using \u003ccode\u003eappend\u003c/code\u003e.\nThis is left as an exercise for the reader.\u003c/p\u003e\n\u003ch2 id=\"further-reading\"\u003eFurther Reading\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/doc/effective_go.html\"\u003eEffective Go\u003c/a\u003e contains an in-depth\ntreatment of \u003ca href=\"/doc/effective_go.html#slices\"\u003eslices\u003c/a\u003e\nand \u003ca href=\"/doc/effective_go.html#arrays\"\u003earrays\u003c/a\u003e,\nand the Go \u003ca href=\"/doc/go_spec.html\"\u003elanguage specification\u003c/a\u003e\ndefines \u003ca href=\"/doc/go_spec.html#Slice_types\"\u003eslices\u003c/a\u003e and\ntheir \u003ca href=\"/doc/go_spec.html#Length_and_capacity\"\u003eassociated\u003c/a\u003e\n\u003ca href=\"/doc/go_spec.html#Making_slices_maps_and_channels\"\u003ehelper\u003c/a\u003e\n\u003ca href=\"/doc/go_spec.html#Appending_and_copying_slices\"\u003efunctions\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-01-05T00:00:00Z",
  "Author": "Andrew Gerrand"
}