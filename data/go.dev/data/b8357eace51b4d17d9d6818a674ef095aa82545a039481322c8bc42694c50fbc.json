{
  "Source": "go.dev",
  "Title": "Range Over Function Types",
  "Link": "https://go.dev/blog/range-functions",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/range-functions\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eRange Over Function Types\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Ian Lance Taylor\u003cbr/\u003e\n      20 August 2024\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis is the blog post version of my talk at GopherCon 2024.\u003c/p\u003e\n\u003cp\u003eRange over function types is a new language feature in the Go 1.23\nrelease.\nThis blog post will explain why we are adding this new feature, what\nexactly it is, and how to use it.\u003c/p\u003e\n\u003ch2 id=\"why\"\u003eWhy?\u003c/h2\u003e\n\u003cp\u003eSince Go 1.18 we’ve had the ability to write new generic container\ntypes in Go.\nFor example, let’s consider this very simple \u003ccode\u003eSet\u003c/code\u003e type, a generic\ntype implemented on top of a map.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Set holds a set of elements.\ntype Set[E comparable] struct {\n    m map[E]struct{}\n}\n\n// New returns a new [Set].\nfunc New[E comparable]() *Set[E] {\n    return \u0026amp;Set[E]{m: make(map[E]struct{})}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNaturally a set type has a way to add elements and a way to check\nwhether elements are present.  The details here don’t matter.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Add adds an element to a set.\nfunc (s *Set[E]) Add(v E) {\n    s.m[v] = struct{}{}\n}\n\n// Contains reports whether an element is in a set.\nfunc (s *Set[E]) Contains(v E) bool {\n    _, ok := s.m[v]\n    return ok\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd among other things we will want a function to return the union of\ntwo sets.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Union returns the union of two sets.\nfunc Union[E comparable](s1, s2 *Set[E]) *Set[E] {\n    r := New[E]()\n    // Note for/range over internal Set field m.\n    // We are looping over the maps in s1 and s2.\n    for v := range s1.m {\n        r.Add(v)\n    }\n    for v := range s2.m {\n        r.Add(v)\n    }\n    return r\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet’s look at this implementation of the \u003ccode\u003eUnion\u003c/code\u003e function for a\nminute.\nIn order to compute the union of two sets, we need a way to get all\nthe elements that are in each set.\nIn this code we use a for/range statement over an unexported field of\nthe set type.\nThat only works if the \u003ccode\u003eUnion\u003c/code\u003e function is defined in the set package.\u003c/p\u003e\n\u003cp\u003eBut there are a lot of reasons why someone might want to loop over all\nthe elements in a set.\nThis set package has to provide some way for its users to do that.\u003c/p\u003e\n\u003cp\u003eHow should that work?\u003c/p\u003e\n\u003ch3 id=\"push-set-elements\"\u003ePush Set elements\u003c/h3\u003e\n\u003cp\u003eOne approach is to provide a \u003ccode\u003eSet\u003c/code\u003e method that takes a function, and\nto call that function with every element in the Set.\nWe’ll call this \u003ccode\u003ePush\u003c/code\u003e, because the \u003ccode\u003eSet\u003c/code\u003e pushes every value to the\nfunction.\nHere if the function returns false, we stop calling it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (s *Set[E]) Push(f func(E) bool) {\n    for v := range s.m {\n        if !f(v) {\n            return\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn the Go standard library, we see this general pattern used for cases\nlike the \u003ca href=\"https://pkg.go.dev/sync#Map.Range\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003esync.Map.Range\u003c/code\u003e\u003c/a\u003e method,\nthe \u003ca href=\"https://pkg.go.dev/flag#Visit\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eflag.Visit\u003c/code\u003e\u003c/a\u003e function, and the\n\u003ca href=\"https://pkg.go.dev/path/filepath#Walk\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003efilepath.Walk\u003c/code\u003e\u003c/a\u003e function.\nThis is a general pattern, not an exact one; as it happens, none of\nthose three examples work quite the same way.\u003c/p\u003e\n\u003cp\u003eThis is what it looks like to use the \u003ccode\u003ePush\u003c/code\u003e method to print all the\nelements of a set: you call \u003ccode\u003ePush\u003c/code\u003e with a function that does what you\nwant with the element.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc PrintAllElementsPush[E comparable](s *Set[E]) {\n    s.Push(func(v E) bool {\n        fmt.Println(v)\n        return true\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"pull-set-elements\"\u003ePull Set elements\u003c/h3\u003e\n\u003cp\u003eAnother approach to looping over the elements of a \u003ccode\u003eSet\u003c/code\u003e is to return\na function.\nEach time the function is called, it will return a value from the\n\u003ccode\u003eSet\u003c/code\u003e, along with a boolean that reports whether the value is valid.\nThe boolean result will be false when the loop has gone through all\nthe elements.\nIn this case we also need a stop function that can be called when no\nmore values are needed.\u003c/p\u003e\n\u003cp\u003eThis implementation uses a pair of channels, one for values in the\nset and one to stop returning values.\nWe use a goroutine to send values on the channel.\nThe \u003ccode\u003enext\u003c/code\u003e function returns an element from the set by reading from\nthe element channel, and the \u003ccode\u003estop\u003c/code\u003e function tells the goroutine to\nexit by closing the stop channel.\nWe need the \u003ccode\u003estop\u003c/code\u003e function to make sure that the goroutine exits when\nno more values are needed.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Pull returns a next function that returns each\n// element of s with a bool for whether the value\n// is valid. The stop function should be called\n// when finished calling the next function.\nfunc (s *Set[E]) Pull() (func() (E, bool), func()) {\n    ch := make(chan E)\n    stopCh := make(chan bool)\n\n    go func() {\n        defer close(ch)\n        for v := range s.m {\n            select {\n            case ch \u0026lt;- v:\n            case \u0026lt;-stopCh:\n                return\n            }\n        }\n    }()\n\n    next := func() (E, bool) {\n        v, ok := \u0026lt;-ch\n        return v, ok\n    }\n\n    stop := func() {\n        close(stopCh)\n    }\n\n    return next, stop\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNothing in the standard library works exactly this way.  Both\n\u003ca href=\"https://pkg.go.dev/runtime#CallersFrames\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eruntime.CallersFrames\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"https://pkg.go.dev/reflect#Value.MapRange\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ereflect.Value.MapRange\u003c/code\u003e\u003c/a\u003e\nare similar, though they return values with methods rather than\nreturning functions directly.\u003c/p\u003e\n\u003cp\u003eThis is what it looks like to use the \u003ccode\u003ePull\u003c/code\u003e method to print all the\nelements of a \u003ccode\u003eSet\u003c/code\u003e.\nYou call \u003ccode\u003ePull\u003c/code\u003e to get a function, and you repeatedly call that\nfunction in a for loop.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc PrintAllElementsPull[E comparable](s *Set[E]) {\n    next, stop := s.Pull()\n    defer stop()\n    for v, ok := next(); ok; v, ok = next() {\n        fmt.Println(v)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"standardize-the-approach\"\u003eStandardize the approach\u003c/h2\u003e\n\u003cp\u003eWe’ve now seen two different approaches to looping over all the\nelements of a set.\nDifferent Go packages use these approaches and several others.\nThat means that when you start using a new Go container package you\nmay have to learn a new looping mechanism.\nIt also means that we can’t write one function that works with several\ndifferent types of containers, as the container types will handle\nlooping differently.\u003c/p\u003e\n\u003cp\u003eWe want to improve the Go ecosystem by developing standard approaches\nfor looping over containers.\u003c/p\u003e\n\u003ch3 id=\"iterators\"\u003eIterators\u003c/h3\u003e\n\u003cp\u003eThis is, of course, an issue that arises in many programming\nlanguages.\u003c/p\u003e\n\u003cp\u003eThe popular \u003ca href=\"https://en.wikipedia.org/wiki/Design_Patterns\" rel=\"noreferrer\" target=\"_blank\"\u003eDesign Patterns\nbook\u003c/a\u003e, first published\nin 1994, describes this as the iterator pattern.\nYou use an iterator to “provide a way to access the elements of an\naggregate object sequentially without exposing its underlying\nrepresentation.”\nWhat this quote calls an aggregate object is what I’ve been calling a\ncontainer.\nAn aggregate object, or container, is just a value that holds other\nvalues, like the \u003ccode\u003eSet\u003c/code\u003e type we’ve been discussing.\u003c/p\u003e\n\u003cp\u003eLike many ideas in programming, iterators date back to Barbara\nLiskov’s \u003ca href=\"https://en.wikipedia.org/wiki/CLU_(programming_language)\" rel=\"noreferrer\" target=\"_blank\"\u003eCLU language\u003c/a\u003e,\ndeveloped in the 1970’s.\u003c/p\u003e\n\u003cp\u003eToday many popular languages provide iterators one way or another,\nincluding, among others, C++, Java, Javascript, Python, and Rust.\u003c/p\u003e\n\u003cp\u003eHowever, Go before version 1.23 did not.\u003c/p\u003e\n\u003ch3 id=\"forrange\"\u003eFor/range\u003c/h3\u003e\n\u003cp\u003eAs we all know, Go has container types that are built in to the\nlanguage: slices, arrays, and maps.\nAnd it has a way to access the elements of those values without\nexposing the underlying representation: the for/range statement.\nThe for/range statement works for Go’s built-in container types (and\nalso for strings, channels, and, as of Go 1.22, int).\u003c/p\u003e\n\u003cp\u003eThe for/range statement is iteration, but it is not iterators as they\nappear in today’s popular languages.\nStill, it would be nice to be able to use for/range to iterate over a\nuser-defined container like the \u003ccode\u003eSet\u003c/code\u003e type.\u003c/p\u003e\n\u003cp\u003eHowever, Go before version 1.23 did not support this.\u003c/p\u003e\n\u003ch3 id=\"improvements-in-this-release\"\u003eImprovements in this release\u003c/h3\u003e\n\u003cp\u003eFor Go 1.23 we’ve decided to support both for/range over user-defined\ncontainer types, and a standardized form of iterators.\u003c/p\u003e\n\u003cp\u003eWe extended the for/range statement to support ranging over function\ntypes.\nWe’ll see below how this helps loop over user-defined containers.\u003c/p\u003e\n\u003cp\u003eWe also added standard library types and functions to support using\nfunction types as iterators.\nA standard definition of iterators lets us write functions that work\nsmoothly with different container types.\u003c/p\u003e\n\u003ch3 id=\"range-over-some-function-types\"\u003eRange over (some) function types\u003c/h3\u003e\n\u003cp\u003eThe improved for/range statement doesn’t support arbitrary function\ntypes.\nAs of Go 1.23 it now supports ranging over functions that take a\nsingle argument.\nThe single argument must itself be a function that takes zero to two\narguments and returns a bool; by convention, we call it the yield\nfunction.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc(yield func() bool)\n\nfunc(yield func(V) bool)\n\nfunc(yield func(K, V) bool)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we speak of an iterator in Go, we mean a function with one of\nthese three types.\nAs we’ll discuss below, there is another kind of iterator in the\nstandard library: a pull iterator.\nWhen it is necessary to distinguish between standard iterators and\npull iterators, we call the standard iterators push iterators.\nThat is because, as we will see, they push out a sequence of values by\ncalling a yield function.\u003c/p\u003e\n\u003ch3 id=\"standard-push-iterators\"\u003eStandard (push) iterators\u003c/h3\u003e\n\u003cp\u003eTo make iterators easier to use, the new standard library package iter\ndefines two types: \u003ccode\u003eSeq\u003c/code\u003e and \u003ccode\u003eSeq2\u003c/code\u003e.\nThese are names for the iterator function types, the types that can be\nused with the for/range statement.\nThe name \u003ccode\u003eSeq\u003c/code\u003e is short for sequence, as iterators loop through a\nsequence of values.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage iter\n\ntype Seq[V any] func(yield func(V) bool)\n\ntype Seq2[K, V any] func(yield func(K, V) bool)\n\n// for now, no Seq0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe difference between \u003ccode\u003eSeq\u003c/code\u003e and \u003ccode\u003eSeq2\u003c/code\u003e is just that \u003ccode\u003eSeq2\u003c/code\u003e is a\nsequence of pairs, such as a key and a value from a map.\nIn this post we’ll focus on \u003ccode\u003eSeq\u003c/code\u003e for simplicity, but most of what we\nsay covers \u003ccode\u003eSeq2\u003c/code\u003e as well.\u003c/p\u003e\n\u003cp\u003eIt’s easiest to explain how iterators work with an example.\nHere the \u003ccode\u003eSet\u003c/code\u003e method \u003ccode\u003eAll\u003c/code\u003e returns a function.\nThe return type of \u003ccode\u003eAll\u003c/code\u003e is \u003ccode\u003eiter.Seq[E]\u003c/code\u003e, so we know that it returns\nan iterator.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// All is an iterator over the elements of s.\nfunc (s *Set[E]) All() iter.Seq[E] {\n    return func(yield func(E) bool) {\n        for v := range s.m {\n            if !yield(v) {\n                return\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe iterator function itself takes another function, the yield\nfunction, as an argument.\nThe iterator calls the yield function with every value in the set.\nIn this case the iterator, the function returned by \u003ccode\u003eSet.All\u003c/code\u003e, is a\nlot like the \u003ccode\u003eSet.Push\u003c/code\u003e function we saw earlier.\u003c/p\u003e\n\u003cp\u003eThis shows how iterators work: for some sequence of values, they call\na yield function with each value in the sequence.\nIf the yield function returns false, no more values are needed, and\nthe iterator can just return, doing any cleanup that may be required.\nIf the yield function never returns false, the iterator can just\nreturn after calling yield with all the values in the sequence.\u003c/p\u003e\n\u003cp\u003eThat’s how they work, but let’s acknowledge that the first time you\nsee one of these, your first reaction is probably “there are a lot of\nfunctions flying around here.”\nYou’re not wrong about that.\nLet’s focus on two things.\u003c/p\u003e\n\u003cp\u003eThe first is that once you get past the first line of this function’s\ncode, the actual implementation of the iterator is pretty simple: call\nyield with every element of the set, stopping if yield returns false.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e        for v := range s.m {\n            if !yield(v) {\n                return\n            }\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe second is that using this is really easy.\nYou call \u003ccode\u003es.All\u003c/code\u003e to get an iterator, and then you use for/range to\nloop over all the elements in \u003ccode\u003es\u003c/code\u003e.\nThe for/range statement supports any iterator, and this shows how easy\nthat is to use.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc PrintAllElements[E comparable](s *Set[E]) {\n    for v := range s.All() {\n        fmt.Println(v)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this kind of code \u003ccode\u003es.All\u003c/code\u003e is a method that returns a function.\nWe are calling \u003ccode\u003es.All\u003c/code\u003e, and then using for/range to range over the\nfunction that it returns.\nIn this case we could have made \u003ccode\u003eSet.All\u003c/code\u003e be an iterator function\nitself, rather than having it return an iterator function.\nHowever, in some cases that won’t work, such as if the function that\nreturns the iterator needs to take an argument, or needs to do some\nset up work.\nAs a matter of convention, we encourage all container types to provide\nan \u003ccode\u003eAll\u003c/code\u003e method that returns an iterator, so that programmers don’t\nhave to remember whether to range over \u003ccode\u003eAll\u003c/code\u003e directly or whether to\ncall \u003ccode\u003eAll\u003c/code\u003e to get a value they can range over.\nThey can always do the latter.\u003c/p\u003e\n\u003cp\u003eIf you think about it, you’ll see that the compiler must be adjusting\nthe loop to create a yield function to pass to the iterator returned\nby \u003ccode\u003es.All\u003c/code\u003e.\nThere’s a fair bit of complexity in the Go compiler and runtime to\nmake this efficient, and to correctly handle things like \u003ccode\u003ebreak\u003c/code\u003e or\n\u003ccode\u003epanic\u003c/code\u003e in the loop.\nWe’re not going to cover any of that in this blog post.\nFortunately the implementation details are not important when it comes\nto actually using this feature.\u003c/p\u003e\n\u003ch3 id=\"pull-iterators\"\u003ePull iterators\u003c/h3\u003e\n\u003cp\u003eWe’ve now seen how to use iterators in a for/range loop.\nBut a simple loop is not the only way to use an iterator.\nFor example, sometimes we may need to iterate over two containers in\nparallel.\nHow do we do that?\u003c/p\u003e\n\u003cp\u003eThe answer is that we use a different kind of iterator: a pull\niterator.\nWe’ve seen that a standard iterator, also known as a push iterator, is\na function that takes a yield function as an argument and pushes each\nvalue in a sequence by calling the yield function.\u003c/p\u003e\n\u003cp\u003eA pull iterator works the other way around: it is a function that is\nwritten such that each time you call it, it returns the next value in\nthe sequence.\u003c/p\u003e\n\u003cp\u003eWe’ll repeat the difference between the two types of iterators to help\nyou remember:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA push iterator pushes each value in a sequence to a yield\nfunction.\nPush iterators are standard iterators in the Go standard library,\nand are supported directly by the for/range statement.\u003c/li\u003e\n\u003cli\u003eA pull iterator works the other way around.\nEach time you call a pull iterator, it pulls another value from a\nsequence and returns it.\nPull iterators are \u003cem\u003enot\u003c/em\u003e supported directly by the for/range\nstatement; however, it’s straightforward to write an ordinary for\nstatement that loops through a pull iterator.\nIn fact, we saw an example earlier when we looked at using the\n\u003ccode\u003eSet.Pull\u003c/code\u003e method.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou could write a pull iterator yourself, but normally you don’t have\nto.\nThe new standard library function\n\u003ca href=\"https://pkg.go.dev/iter#Pull\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eiter.Pull\u003c/code\u003e\u003c/a\u003e takes a standard iterator,\nthat is to say a function that is a push iterator, and returns a pair\nof functions.\nThe first is a pull iterator: a function that returns the next value\nin the sequence each time it is called.\nThe second is a stop function that should be called when we are done\nwith the pull iterator.\nThis is like the \u003ccode\u003eSet.Pull\u003c/code\u003e method we saw earlier.\u003c/p\u003e\n\u003cp\u003eThe first function returned by \u003ccode\u003eiter.Pull\u003c/code\u003e, the pull iterator, returns\na value and a boolean that reports whether that value is valid.\nThe boolean will be false at the end of the sequence.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eiter.Pull\u003c/code\u003e returns a stop function in case we don’t read through the\nsequence to the end.\nIn the general case the push iterator, the argument to \u003ccode\u003eiter.Pull\u003c/code\u003e,\nmay start goroutines, or build new data structures that need to be\ncleaned up when iteration is complete.\nThe push iterator will do any cleanup when the yield function returns\nfalse, meaning that no more values are required.\nWhen used with a for/range statement, the for/range statement will\nensure that if the loop exits early, through a \u003ccode\u003ebreak\u003c/code\u003e statement or\nfor any other reason, then the yield function will return false.\nWith a pull iterator, on the other hand, there is no way to force the\nyield function to return false, so the stop function is needed.\u003c/p\u003e\n\u003cp\u003eAnother way to say this is that calling the stop function will cause\nthe yield function to return false when it is called by the push\niterator.\u003c/p\u003e\n\u003cp\u003eStrictly speaking you don’t need to call the stop function if the pull\niterator returns false to indicate that it has reached the end of the\nsequence, but it’s usually simpler to just always call it.\u003c/p\u003e\n\u003cp\u003eHere is an example of using pull iterators to walk through two\nsequences in parallel.\nThis function reports whether two arbitrary sequences contain the same\nelements in the same order.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// EqSeq reports whether two iterators contain the same\n// elements in the same order.\nfunc EqSeq[E comparable](s1, s2 iter.Seq[E]) bool {\n    next1, stop1 := iter.Pull(s1)\n    defer stop1()\n    next2, stop2 := iter.Pull(s2)\n    defer stop2()\n    for {\n        v1, ok1 := next1()\n        v2, ok2 := next2()\n        if !ok1 {\n            return !ok2\n        }\n        if ok1 != ok2 || v1 != v2 {\n            return false\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function uses \u003ccode\u003eiter.Pull\u003c/code\u003e to convert the two push iterators, \u003ccode\u003es1\u003c/code\u003e\nand \u003ccode\u003es2\u003c/code\u003e, into pull iterators.\nIt uses \u003ccode\u003edefer\u003c/code\u003e statements to make sure that the pull iterators are\nstopped when we are done with them.\u003c/p\u003e\n\u003cp\u003eThen the code loops, calling the pull iterators to retrieve values.\nIf the first sequence is done, it returns true if the second sequence\nis also done, or false if it isn’t.\nIf the values are different, it returns false.\nThen it loops to pull the next two values.\u003c/p\u003e\n\u003cp\u003eAs with push iterators, there is some complexity in the Go runtime to\nmake pull iterators efficient, but this does not affect code that\nactually uses the \u003ccode\u003eiter.Pull\u003c/code\u003e function.\u003c/p\u003e\n\u003ch2 id=\"iterating-on-iterators\"\u003eIterating on iterators\u003c/h2\u003e\n\u003cp\u003eNow you know everything there is to know about range over function\ntypes and about iterators.\nWe hope you enjoy using them!\u003c/p\u003e\n\u003cp\u003eStill, there are a few more things worth mentioning.\u003c/p\u003e\n\u003ch3 id=\"adapters\"\u003eAdapters\u003c/h3\u003e\n\u003cp\u003eAn advantage of a standard definition of iterators is the ability to\nwrite standard adapter functions that use them.\u003c/p\u003e\n\u003cp\u003eFor example, here is a function that filters a sequence of values,\nreturning a new sequence.\nThis \u003ccode\u003eFilter\u003c/code\u003e function takes an iterator as an argument and returns a\nnew iterator.\nThe other argument is a filter function that decides which values\nshould be in the new iterator that \u003ccode\u003eFilter\u003c/code\u003e returns.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Filter returns a sequence that contains the elements\n// of s for which f returns true.\nfunc Filter[V any](f func(V) bool, s iter.Seq[V]) iter.Seq[V] {\n    return func(yield func(V) bool) {\n        for v := range s {\n            if f(v) {\n                if !yield(v) {\n                    return\n                }\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs with the earlier example, the function signatures look complicated\nwhen you first see them.\nOnce you get past the signatures, the implementation is\nstraightforward.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e        for v := range s {\n            if f(v) {\n                if !yield(v) {\n                    return\n                }\n            }\n        }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe code ranges over the input iterator, checks the filter function,\nand calls yield with the values that should go into the output\niterator.\u003c/p\u003e\n\u003cp\u003eWe’ll show an example of using \u003ccode\u003eFilter\u003c/code\u003e below.\u003c/p\u003e\n\u003cp\u003e(There is no version of \u003ccode\u003eFilter\u003c/code\u003e in the Go standard library today, but\none may be added in future releases.)\u003c/p\u003e\n\u003ch3 id=\"binary-tree\"\u003eBinary tree\u003c/h3\u003e\n\u003cp\u003eAs an example of how convenient a push iterator can be to loop over a\ncontainer type, let’s consider this simple binary tree type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Tree is a binary tree.\ntype Tree[E any] struct {\n    val         E\n    left, right *Tree[E]\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe won’t show the code to insert values into the tree, but naturally\nthere should be some way to range over all the values in the tree.\u003c/p\u003e\n\u003cp\u003eIt turns out that the iterator code is easier to write if it returns a\nbool.\nSince the function types supported by for/range don’t return anything,\nthe \u003ccode\u003eAll\u003c/code\u003e method here returns a small function literal that calls the\niterator itself, here called \u003ccode\u003epush\u003c/code\u003e, and ignores the bool result.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// All returns an iterator over the values in t.\nfunc (t *Tree[E]) All() iter.Seq[E] {\n    return func(yield func(E) bool) {\n        t.push(yield)\n    }\n}\n\n// push pushes all elements to the yield function.\nfunc (t *Tree[E]) push(yield func(E) bool) bool {\n    if t == nil {\n        return true\n    }\n    return t.left.push(yield) \u0026amp;\u0026amp;\n        yield(t.val) \u0026amp;\u0026amp;\n        t.right.push(yield)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003epush\u003c/code\u003e method uses recursion to walk over the whole tree, calling\nyield on each element.\nIf the yield function returns false, the method returns false all the\nway up the stack.\nOtherwise it just returns once the iteration is complete.\u003c/p\u003e\n\u003cp\u003eThis shows how straightforward it is to use this iterator approach to\nloop over even complex data structures.\nThere is no need to maintain a separate stack to record the position\nwithin the tree; we can just use the goroutine call stack to do that\nfor us.\u003c/p\u003e\n\u003ch3 id=\"new-iterator-functions\"\u003eNew iterator functions.\u003c/h3\u003e\n\u003cp\u003eAlso new in Go 1.23 are functions in the slices and maps packages that\nwork with iterators.\u003c/p\u003e\n\u003cp\u003eHere are the new functions in the slices package.\n\u003ccode\u003eAll\u003c/code\u003e and \u003ccode\u003eValues\u003c/code\u003e are functions that return iterators over the\nelements of a slice.\n\u003ccode\u003eCollect\u003c/code\u003e fetches the values out of an iterator and returns a slice\nholding those values.\nSee the docs for the others.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#All\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eAll([]E) iter.Seq2[int, E]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Values\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eValues([]E) iter.Seq[E]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Collect\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eCollect(iter.Seq[E]) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#AppendSeq\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eAppendSeq([]E, iter.Seq[E]) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Backward\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eBackward([]E) iter.Seq2[int, E]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Sorted\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSorted(iter.Seq[E]) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#SortedFunc\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSortedFunc(iter.Seq[E], func(E, E) int) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#SortedStableFunc\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSortedStableFunc(iter.Seq[E], func(E, E) int) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Repeat\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eRepeat([]E, int) []E\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/slices#Chunk\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eChunk([]E, int) iter.Seq([]E)\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHere are the new functions in the maps package.\n\u003ccode\u003eAll\u003c/code\u003e, \u003ccode\u003eKeys\u003c/code\u003e, and \u003ccode\u003eValues\u003c/code\u003e returns iterators over the map contents.\n\u003ccode\u003eCollect\u003c/code\u003e fetches the keys and values out of an iterator and returns a\nnew map.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/maps#All\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eAll(map[K]V) iter.Seq2[K, V]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/maps#Keys\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eKeys(map[K]V) iter.Seq[K]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/maps#Values\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eValues(map[K]V) iter.Seq[V]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/maps#Collect\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eCollect(iter.Seq2[K, V]) map[K, V]\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://pkg.go.dev/maps#Insert\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eInsert(map[K, V], iter.Seq2[K, V])\u003c/code\u003e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"standard-library-iterator-example\"\u003eStandard library iterator example\u003c/h3\u003e\n\u003cp\u003eHere is an example of how you might use these new functions along with\nthe \u003ccode\u003eFilter\u003c/code\u003e function we saw earlier.\nThis function takes a map from int to string and returns a slice\nholding just the values in the map that are longer than some argument \u003ccode\u003en\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// LongStrings returns a slice of just the values\n// in m whose length is n or more.\nfunc LongStrings(m map[int]string, n int) []string {\n    isLong := func(s string) bool {\n        return len(s) \u0026gt;= n\n    }\n    return slices.Collect(Filter(isLong, maps.Values(m)))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003emaps.Values\u003c/code\u003e function returns an iterator over the values in \u003ccode\u003em\u003c/code\u003e.\n\u003ccode\u003eFilter\u003c/code\u003e reads that iterator and returns a new iterator that only\ncontains the long strings.\n\u003ccode\u003eslices.Collect\u003c/code\u003e reads from that iterator into a new slice.\u003c/p\u003e\n\u003cp\u003eOf course, you could write a loop to do this easily enough, and in\nmany cases a loop will be clearer.\nWe don’t want to encourage everybody to write code in this style all\nthe time.\nThat said, the advantage of using iterators is that this kind of\nfunction works the same way with any sequence.\nIn this example, notice how Filter is using a map as an input and a\nslice as an output, without having to change the code in Filter at\nall.\u003c/p\u003e\n\u003ch3 id=\"looping-over-lines-in-a-file\"\u003eLooping over lines in a file\u003c/h3\u003e\n\u003cp\u003eAlthough most of the examples we’ve seen have involved containers,\niterators are flexible.\u003c/p\u003e\n\u003cp\u003eConsider this simple code, which doesn’t use iterators, to loop over\nthe lines in a byte slice.\nThis is easy to write and fairly efficient.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    nl := []byte{\u0026#39;\\n\u0026#39;}\n    // Trim a trailing newline to avoid a final empty blank line.\n    for _, line := range bytes.Split(bytes.TrimSuffix(data, nl), nl) {\n        handleLine(line)\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHowever, \u003ccode\u003ebytes.Split\u003c/code\u003e does allocate and return a slice of byte slices\nto hold the lines.\nThe garbage collector will have to do a bit of work to eventually free\nthat slice.\u003c/p\u003e\n\u003cp\u003eHere is a function that returns an iterator over the lines of some\nbyte slice.\nAfter the usual iterator signatures, the function is pretty simple.\nWe keep picking lines out of data until there is nothing left, and we\npass each line to the yield function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Lines returns an iterator over lines in data.\nfunc Lines(data []byte) iter.Seq[[]byte] {\n    return func(yield func([]byte) bool) {\n        for len(data) \u0026gt; 0 {\n            line, rest, _ := bytes.Cut(data, []byte{\u0026#39;\\n\u0026#39;})\n            if !yield(line) {\n                return\n            }\n            data = rest\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow our code to loop over the lines of a byte slice looks like this.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    for line := range Lines(data) {\n        handleLine(line)\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is just as easy to write as the earlier code, and is a bit more\nefficient because it doesn’t have allocate a slice of lines.\u003c/p\u003e\n\u003ch3 id=\"passing-a-function-to-a-push-iterator\"\u003ePassing a function to a push iterator\u003c/h3\u003e\n\u003cp\u003eFor our final example, we’ll see that you don’t have to use a push\niterator in a range statement.\u003c/p\u003e\n\u003cp\u003eEarlier we saw a \u003ccode\u003ePrintAllElements\u003c/code\u003e function that prints out each\nelement of a set.\nHere is another way to print all the elements of a set: call \u003ccode\u003es.All\u003c/code\u003e\nto get an iterator, then pass in a hand-written yield function.\nThis yield function just prints a value and returns true.\nNote that there are two function calls here: we call \u003ccode\u003es.All\u003c/code\u003e to get an\niterator which is itself a function, and we call that function with\nour hand-written yield function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc PrintAllElements[E comparable](s *Set[E]) {\n    s.All()(func(v E) bool {\n        fmt.Println(v)\n        return true\n    })\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere’s no particular reason to write this code this way.\nThis is just an example to show that the yield function isn’t magic.\nIt can be any function you like.\u003c/p\u003e\n\u003ch2 id=\"update-gomod\"\u003eUpdate go.mod\u003c/h2\u003e\n\u003cp\u003eA final note: every Go module specifies the language version that it\nuses.\nThat means that in order to use new language features in an existing\nmodule you may need to update that version.\nThis is true for all new language features; it’s not something\nspecific to range over function types.\nAs range over function types is new in the Go 1.23 release, using it\nrequires specifying at least Go language version 1.23.\u003c/p\u003e\n\u003cp\u003eThere are (at least) four ways to set the language version:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOn the command line, run \u003ccode\u003ego get go@1.23\u003c/code\u003e (or \u003ccode\u003ego mod edit -go=1.23\u003c/code\u003e\nto only edit the \u003ccode\u003ego\u003c/code\u003e directive).\u003c/li\u003e\n\u003cli\u003eManually edit the \u003ccode\u003ego.mod\u003c/code\u003e file and change the \u003ccode\u003ego\u003c/code\u003e line.\u003c/li\u003e\n\u003cli\u003eKeep the older language version for the module as a whole, but use a\n\u003ccode\u003e//go:build go1.23\u003c/code\u003e build tag to permit using range over function\ntypes in a specific file.\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-08-20T00:00:00Z",
  "Author": "Ian Lance Taylor"
}