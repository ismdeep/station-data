{
  "Source": "go.dev",
  "Title": "The Laws of Reflection",
  "Link": "https://go.dev/blog/laws-of-reflection",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/laws-of-reflection\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eThe Laws of Reflection\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      6 September 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eReflection in computing is the ability of a program to examine its own structure,\nparticularly through types;\nit’s a form of metaprogramming.\nIt’s also a great source of confusion.\u003c/p\u003e\n\u003cp\u003eIn this article we attempt to clarify things by explaining how reflection works in Go.\nEach language’s reflection model is different (and many languages don’t support it at all),\nbut this article is about Go, so for the rest of this article the word “reflection”\nshould be taken to mean “reflection in Go”.\u003c/p\u003e\n\u003cp\u003eNote added January 2022: This blog post was written in 2011 and predates\nparametric polymorphism (a.k.a. generics) in Go.\nAlthough nothing important in the article has become incorrect as a result\nof that development in the language,\nit has been tweaked in a few places to avoid\nconfusing someone familiar with modern Go.\u003c/p\u003e\n\u003ch2 id=\"types-and-interfaces\"\u003eTypes and interfaces\u003c/h2\u003e\n\u003cp\u003eBecause reflection builds on the type system, let’s start with a refresher about types in Go.\u003c/p\u003e\n\u003cp\u003eGo is statically typed. Every variable has a static type,\nthat is, exactly one type known and fixed at compile time:\n\u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003efloat32\u003c/code\u003e, \u003ccode\u003e*MyType\u003c/code\u003e, \u003ccode\u003e[]byte\u003c/code\u003e, and so on. If we declare\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype MyInt int\n\nvar i int\nvar j MyInt\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen \u003ccode\u003ei\u003c/code\u003e has type \u003ccode\u003eint\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e has type \u003ccode\u003eMyInt\u003c/code\u003e.\nThe variables \u003ccode\u003ei\u003c/code\u003e and \u003ccode\u003ej\u003c/code\u003e have distinct static types and,\nalthough they have the same underlying type,\nthey cannot be assigned to one another without a conversion.\u003c/p\u003e\n\u003cp\u003eOne important category of type is interface types,\nwhich represent fixed sets of methods.\n(When discussing reflection, we can ignore the use of\ninterface definitions as constraints within polymorphic code.)\nAn interface variable can store any concrete (non-interface) value as long\nas that value implements the interface’s methods.\nA well-known pair of examples is \u003ccode\u003eio.Reader\u003c/code\u003e and \u003ccode\u003eio.Writer\u003c/code\u003e,\nthe types \u003ccode\u003eReader\u003c/code\u003e and \u003ccode\u003eWriter\u003c/code\u003e from the \u003ca href=\"/pkg/io/\"\u003eio package\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Reader is the interface that wraps the basic Read method.\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n\n// Writer is the interface that wraps the basic Write method.\ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAny type that implements a \u003ccode\u003eRead\u003c/code\u003e (or \u003ccode\u003eWrite\u003c/code\u003e) method with this signature\nis said to implement \u003ccode\u003eio.Reader\u003c/code\u003e (or \u003ccode\u003eio.Writer\u003c/code\u003e).\nFor the purposes of this discussion, that means that a variable of type\n\u003ccode\u003eio.Reader\u003c/code\u003e can hold any value whose type has a \u003ccode\u003eRead\u003c/code\u003e method:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar r io.Reader\nr = os.Stdin\nr = bufio.NewReader(r)\nr = new(bytes.Buffer)\n// and so on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s important to be clear that whatever concrete value \u003ccode\u003er\u003c/code\u003e may hold,\n\u003ccode\u003er\u003c/code\u003e’s type is always \u003ccode\u003eio.Reader\u003c/code\u003e:\nGo is statically typed and the static type of \u003ccode\u003er\u003c/code\u003e is \u003ccode\u003eio.Reader\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAn extremely important example of an interface type is the empty interface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor its equivalent alias,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eany\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt represents the empty set of methods and is satisfied by any value at all, since every value has zero or more methods.\u003c/p\u003e\n\u003cp\u003eSome people say that Go’s interfaces are dynamically typed,\nbut that is misleading.\nThey are statically typed: a variable of interface type always has the same static type,\nand even though at run time the value stored in the interface variable may change type,\nthat value will always satisfy the interface.\u003c/p\u003e\n\u003cp\u003eWe need to be precise about all this because reflection and interfaces are closely related.\u003c/p\u003e\n\u003ch2 id=\"the-representation-of-an-interface\"\u003eThe representation of an interface\u003c/h2\u003e\n\u003cp\u003eRuss Cox has written a \u003ca href=\"https://research.swtch.com/2009/12/go-data-structures-interfaces.html\" rel=\"noreferrer\" target=\"_blank\"\u003e detailed blog post\u003c/a\u003e\nabout the representation of interface values in Go.\nIt’s not necessary to repeat the full story here,\nbut a simplified summary is in order.\u003c/p\u003e\n\u003cp\u003eA variable of interface type stores a pair:\nthe concrete value assigned to the variable,\nand that value’s type descriptor.\nTo be more precise, the value is the underlying concrete data item that\nimplements the interface and the type describes the full type of that item. For instance, after\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar r io.Reader\ntty, err := os.OpenFile(\u0026#34;/dev/tty\u0026#34;, os.O_RDWR, 0)\nif err != nil {\n    return nil, err\n}\nr = tty\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003er\u003c/code\u003e contains, schematically, the (value, type) pair,\n(\u003ccode\u003etty\u003c/code\u003e, \u003ccode\u003e*os.File\u003c/code\u003e).\nNotice that the type \u003ccode\u003e*os.File\u003c/code\u003e implements methods other than \u003ccode\u003eRead\u003c/code\u003e;\neven though the interface value provides access only to the \u003ccode\u003eRead\u003c/code\u003e method,\nthe value inside carries all the type information about that value.\nThat’s why we can do things like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar w io.Writer\nw = r.(io.Writer)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe expression in this assignment is a type assertion;\nwhat it asserts is that the item inside \u003ccode\u003er\u003c/code\u003e also implements \u003ccode\u003eio.Writer\u003c/code\u003e,\nand so we can assign it to \u003ccode\u003ew\u003c/code\u003e.\nAfter the assignment, \u003ccode\u003ew\u003c/code\u003e will contain the pair (\u003ccode\u003etty\u003c/code\u003e, \u003ccode\u003e*os.File\u003c/code\u003e).\nThat’s the same pair as was held in \u003ccode\u003er\u003c/code\u003e. The static type of the interface\ndetermines what methods may be invoked with an interface variable,\neven though the concrete value inside may have a larger set of methods.\u003c/p\u003e\n\u003cp\u003eContinuing, we can do this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar empty interface{}\nempty = w\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand our empty interface value \u003ccode\u003eempty\u003c/code\u003e will again contain that same pair,\n(\u003ccode\u003etty\u003c/code\u003e, \u003ccode\u003e*os.File\u003c/code\u003e).\nThat’s handy: an empty interface can hold any value and contains all the\ninformation we could ever need about that value.\u003c/p\u003e\n\u003cp\u003e(We don’t need a type assertion here because it’s known statically that\n\u003ccode\u003ew\u003c/code\u003e satisfies the empty interface.\nIn the example where we moved a value from a \u003ccode\u003eReader\u003c/code\u003e to a \u003ccode\u003eWriter\u003c/code\u003e,\nwe needed to be explicit and use a type assertion because \u003ccode\u003eWriter\u003c/code\u003e’s methods\nare not a subset of \u003ccode\u003eReader\u003c/code\u003e’s.)\u003c/p\u003e\n\u003cp\u003eOne important detail is that the pair inside an interface variable always has the form (value,\nconcrete type) and cannot have the form (value, interface type).\nInterfaces do not hold interface values.\u003c/p\u003e\n\u003cp\u003eNow we’re ready to reflect.\u003c/p\u003e\n\u003ch2 id=\"the-first-law-of-reflection\"\u003eThe first law of reflection\u003c/h2\u003e\n\u003ch2 id=\"1-reflection-goes-from-interface-value-to-reflection-object\"\u003e1. Reflection goes from interface value to reflection object.\u003c/h2\u003e\n\u003cp\u003eAt the basic level, reflection is just a mechanism to examine the type and\nvalue pair stored inside an interface variable.\nTo get started, there are two types we need to know about in \u003ca href=\"/pkg/reflect/\"\u003epackage reflect\u003c/a\u003e:\n\u003ca href=\"/pkg/reflect/#Type\"\u003eType\u003c/a\u003e and \u003ca href=\"/pkg/reflect/#Value\"\u003eValue\u003c/a\u003e.\nThose two types give access to the contents of an interface variable,\nand two simple functions, called \u003ccode\u003ereflect.TypeOf\u003c/code\u003e and \u003ccode\u003ereflect.ValueOf\u003c/code\u003e,\nretrieve \u003ccode\u003ereflect.Type\u003c/code\u003e and \u003ccode\u003ereflect.Value\u003c/code\u003e pieces out of an interface value.\n(Also, from a \u003ccode\u003ereflect.Value\u003c/code\u003e it’s easy to get to the corresponding \u003ccode\u003ereflect.Type\u003c/code\u003e,\nbut let’s keep the \u003ccode\u003eValue\u003c/code\u003e and \u003ccode\u003eType\u003c/code\u003e concepts separate for now.)\u003c/p\u003e\n\u003cp\u003eLet’s start with \u003ccode\u003eTypeOf\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;reflect\u0026#34;\n)\n\nfunc main() {\n    var x float64 = 3.4\n    fmt.Println(\u0026#34;type:\u0026#34;, reflect.TypeOf(x))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis program prints\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype: float64\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou might be wondering where the interface is here,\nsince the program looks like it’s passing the \u003ccode\u003efloat64\u003c/code\u003e variable \u003ccode\u003ex\u003c/code\u003e,\nnot an interface value, to \u003ccode\u003ereflect.TypeOf\u003c/code\u003e.\nBut it’s there; as \u003ca href=\"/pkg/reflect/#TypeOf\"\u003egodoc reports\u003c/a\u003e,\nthe signature of \u003ccode\u003ereflect.TypeOf\u003c/code\u003e includes an empty interface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// TypeOf returns the reflection Type of the value in the interface{}.\nfunc TypeOf(i interface{}) Type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we call \u003ccode\u003ereflect.TypeOf(x)\u003c/code\u003e, \u003ccode\u003ex\u003c/code\u003e is first stored in an empty interface,\nwhich is then passed as the argument;\n\u003ccode\u003ereflect.TypeOf\u003c/code\u003e unpacks that empty interface to recover the type information.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ereflect.ValueOf\u003c/code\u003e function, of course,\nrecovers the value (from here on we’ll elide the boilerplate and focus just\non the executable code):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\nfmt.Println(\u0026#34;value:\u0026#34;, reflect.ValueOf(x).String())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprints\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evalue: \u0026lt;float64 Value\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(We call the \u003ccode\u003eString\u003c/code\u003e method explicitly because by default the \u003ccode\u003efmt\u003c/code\u003e package\ndigs into a \u003ccode\u003ereflect.Value\u003c/code\u003e to show the concrete value inside.\nThe \u003ccode\u003eString\u003c/code\u003e method does not.)\u003c/p\u003e\n\u003cp\u003eBoth \u003ccode\u003ereflect.Type\u003c/code\u003e and \u003ccode\u003ereflect.Value\u003c/code\u003e have lots of methods to let us examine\nand manipulate them.\nOne important example is that \u003ccode\u003eValue\u003c/code\u003e has a \u003ccode\u003eType\u003c/code\u003e method that returns the\n\u003ccode\u003eType\u003c/code\u003e of a \u003ccode\u003ereflect.Value\u003c/code\u003e.\nAnother is that both \u003ccode\u003eType\u003c/code\u003e and \u003ccode\u003eValue\u003c/code\u003e have a \u003ccode\u003eKind\u003c/code\u003e method that returns\na constant indicating what sort of item is stored:\n\u003ccode\u003eUint\u003c/code\u003e, \u003ccode\u003eFloat64\u003c/code\u003e, \u003ccode\u003eSlice\u003c/code\u003e, and so on.\nAlso methods on \u003ccode\u003eValue\u003c/code\u003e with names like \u003ccode\u003eInt\u003c/code\u003e and \u003ccode\u003eFloat\u003c/code\u003e let us grab values\n(as \u003ccode\u003eint64\u003c/code\u003e and \u003ccode\u003efloat64\u003c/code\u003e) stored inside:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\u0026#34;type:\u0026#34;, v.Type())\nfmt.Println(\u0026#34;kind is float64:\u0026#34;, v.Kind() == reflect.Float64)\nfmt.Println(\u0026#34;value:\u0026#34;, v.Float())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprints\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype: float64\nkind is float64: true\nvalue: 3.4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are also methods like \u003ccode\u003eSetInt\u003c/code\u003e and \u003ccode\u003eSetFloat\u003c/code\u003e but to use them we need\nto understand settability,\nthe subject of the third law of reflection, discussed below.\u003c/p\u003e\n\u003cp\u003eThe reflection library has a couple of properties worth singling out.\nFirst, to keep the API simple, the “getter” and “setter” methods of \u003ccode\u003eValue\u003c/code\u003e\noperate on the largest type that can hold the value:\n\u003ccode\u003eint64\u003c/code\u003e for all the signed integers, for instance.\nThat is, the \u003ccode\u003eInt\u003c/code\u003e method of \u003ccode\u003eValue\u003c/code\u003e returns an \u003ccode\u003eint64\u003c/code\u003e and the \u003ccode\u003eSetInt\u003c/code\u003e\nvalue takes an \u003ccode\u003eint64\u003c/code\u003e;\nit may be necessary to convert to the actual type involved:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x uint8 = \u0026#39;x\u0026#39;\nv := reflect.ValueOf(x)\nfmt.Println(\u0026#34;type:\u0026#34;, v.Type())                            // uint8.\nfmt.Println(\u0026#34;kind is uint8: \u0026#34;, v.Kind() == reflect.Uint8) // true.\nx = uint8(v.Uint())                                       // v.Uint returns a uint64.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe second property is that the \u003ccode\u003eKind\u003c/code\u003e of a reflection object describes\nthe underlying type,\nnot the static type.\nIf a reflection object contains a value of a user-defined integer type, as in\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype MyInt int\nvar x MyInt = 7\nv := reflect.ValueOf(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethe \u003ccode\u003eKind\u003c/code\u003e of \u003ccode\u003ev\u003c/code\u003e is still \u003ccode\u003ereflect.Int\u003c/code\u003e,\neven though the static type of \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eMyInt\u003c/code\u003e, not \u003ccode\u003eint\u003c/code\u003e.\nIn other words, the \u003ccode\u003eKind\u003c/code\u003e cannot discriminate an \u003ccode\u003eint\u003c/code\u003e from a \u003ccode\u003eMyInt\u003c/code\u003e even\nthough the \u003ccode\u003eType\u003c/code\u003e can.\u003c/p\u003e\n\u003ch2 id=\"the-second-law-of-reflection\"\u003eThe second law of reflection\u003c/h2\u003e\n\u003ch2 id=\"2-reflection-goes-from-reflection-object-to-interface-value\"\u003e2. Reflection goes from reflection object to interface value.\u003c/h2\u003e\n\u003cp\u003eLike physical reflection, reflection in Go generates its own inverse.\u003c/p\u003e\n\u003cp\u003eGiven a \u003ccode\u003ereflect.Value\u003c/code\u003e we can recover an interface value using the \u003ccode\u003eInterface\u003c/code\u003e method;\nin effect the method packs the type and value information back into an interface\nrepresentation and returns the result:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Interface returns v\u0026#39;s value as an interface{}.\nfunc (v Value) Interface() interface{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs a consequence we can say\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ey := v.Interface().(float64) // y will have type float64.\nfmt.Println(y)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eto print the \u003ccode\u003efloat64\u003c/code\u003e value represented by the reflection object \u003ccode\u003ev\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWe can do even better, though. The arguments to \u003ccode\u003efmt.Println\u003c/code\u003e,\n\u003ccode\u003efmt.Printf\u003c/code\u003e and so on are all passed as empty interface values,\nwhich are then unpacked by the \u003ccode\u003efmt\u003c/code\u003e package internally just as we have\nbeen doing in the previous examples.\nTherefore all it takes to print the contents of a \u003ccode\u003ereflect.Value\u003c/code\u003e correctly\nis to pass the result of the \u003ccode\u003eInterface\u003c/code\u003e method to the formatted print routine:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efmt.Println(v.Interface())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Since this article was first written, a change was made to the \u003ccode\u003efmt\u003c/code\u003e\npackage so that it automatically unpacks a \u003ccode\u003ereflect.Value\u003c/code\u003e like this, so\nwe could just say\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efmt.Println(v)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003efor the same result, but for clarity we’ll keep the \u003ccode\u003e.Interface()\u003c/code\u003e calls\nhere.)\u003c/p\u003e\n\u003cp\u003eSince our value is a \u003ccode\u003efloat64\u003c/code\u003e,\nwe can even use a floating-point format if we want:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efmt.Printf(\u0026#34;value is %7.1e\\n\u0026#34;, v.Interface())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand get in this case\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e3.4e+00\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAgain, there’s no need to type-assert the result of \u003ccode\u003ev.Interface()\u003c/code\u003e to \u003ccode\u003efloat64\u003c/code\u003e;\nthe empty interface value has the concrete value’s type information inside\nand \u003ccode\u003ePrintf\u003c/code\u003e will recover it.\u003c/p\u003e\n\u003cp\u003eIn short, the \u003ccode\u003eInterface\u003c/code\u003e method is the inverse of the \u003ccode\u003eValueOf\u003c/code\u003e function,\nexcept that its result is always of static type \u003ccode\u003einterface{}\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eReiterating: Reflection goes from interface values to reflection objects and back again.\u003c/p\u003e\n\u003ch2 id=\"the-third-law-of-reflection\"\u003eThe third law of reflection\u003c/h2\u003e\n\u003ch2 id=\"3-to-modify-a-reflection-object-the-value-must-be-settable\"\u003e3. To modify a reflection object, the value must be settable.\u003c/h2\u003e\n\u003cp\u003eThe third law is the most subtle and confusing, but it’s easy enough to understand if we start from first principles.\u003c/p\u003e\n\u003cp\u003eHere is some code that does not work, but is worth studying.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\nv := reflect.ValueOf(x)\nv.SetFloat(7.1) // Error: will panic.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you run this code, it will panic with the cryptic message\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epanic: reflect.Value.SetFloat using unaddressable value\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe problem is not that the value \u003ccode\u003e7.1\u003c/code\u003e is not addressable;\nit’s that \u003ccode\u003ev\u003c/code\u003e is not settable.\nSettability is a property of a reflection \u003ccode\u003eValue\u003c/code\u003e,\nand not all reflection \u003ccode\u003eValues\u003c/code\u003e have it.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eCanSet\u003c/code\u003e method of \u003ccode\u003eValue\u003c/code\u003e reports the settability of a \u003ccode\u003eValue\u003c/code\u003e; in our case,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\nv := reflect.ValueOf(x)\nfmt.Println(\u0026#34;settability of v:\u0026#34;, v.CanSet())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprints\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esettability of v: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is an error to call a \u003ccode\u003eSet\u003c/code\u003e method on a non-settable \u003ccode\u003eValue\u003c/code\u003e. But what is settability?\u003c/p\u003e\n\u003cp\u003eSettability is a bit like addressability, but stricter.\nIt’s the property that a reflection object can modify the actual storage\nthat was used to create the reflection object.\nSettability is determined by whether the reflection object holds the original item. When we say\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\nv := reflect.ValueOf(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe pass a copy of \u003ccode\u003ex\u003c/code\u003e to \u003ccode\u003ereflect.ValueOf\u003c/code\u003e,\nso the interface value created as the argument to \u003ccode\u003ereflect.ValueOf\u003c/code\u003e is a\ncopy of \u003ccode\u003ex\u003c/code\u003e, not \u003ccode\u003ex\u003c/code\u003e itself.\nThus, if the statement\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ev.SetFloat(7.1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewere allowed to succeed, it would not update \u003ccode\u003ex\u003c/code\u003e,\neven though \u003ccode\u003ev\u003c/code\u003e looks like it was created from \u003ccode\u003ex\u003c/code\u003e.\nInstead, it would update the copy of \u003ccode\u003ex\u003c/code\u003e stored inside the reflection value\nand \u003ccode\u003ex\u003c/code\u003e itself would be unaffected.\nThat would be confusing and useless, so it is illegal,\nand settability is the property used to avoid this issue.\u003c/p\u003e\n\u003cp\u003eIf this seems bizarre, it’s not. It’s actually a familiar situation in unusual garb.\nThink of passing \u003ccode\u003ex\u003c/code\u003e to a function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe would not expect \u003ccode\u003ef\u003c/code\u003e to be able to modify \u003ccode\u003ex\u003c/code\u003e because we passed a copy\nof \u003ccode\u003ex\u003c/code\u003e’s value, not \u003ccode\u003ex\u003c/code\u003e itself.\nIf we want \u003ccode\u003ef\u003c/code\u003e to modify \u003ccode\u003ex\u003c/code\u003e directly we must pass our function the address\nof \u003ccode\u003ex\u003c/code\u003e (that is, a pointer to \u003ccode\u003ex\u003c/code\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef(\u0026amp;x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is straightforward and familiar, and reflection works the same way.\nIf we want to modify \u003ccode\u003ex\u003c/code\u003e by reflection, we must give the reflection library\na pointer to the value we want to modify.\u003c/p\u003e\n\u003cp\u003eLet’s do that. First we initialize \u003ccode\u003ex\u003c/code\u003e as usual and then create a reflection value that points to it, called \u003ccode\u003ep\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar x float64 = 3.4\np := reflect.ValueOf(\u0026amp;x) // Note: take the address of x.\nfmt.Println(\u0026#34;type of p:\u0026#34;, p.Type())\nfmt.Println(\u0026#34;settability of p:\u0026#34;, p.CanSet())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output so far is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype of p: *float64\nsettability of p: false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reflection object \u003ccode\u003ep\u003c/code\u003e isn’t settable,\nbut it’s not \u003ccode\u003ep\u003c/code\u003e we want to set, it’s (in effect) \u003ccode\u003e*p\u003c/code\u003e.\nTo get to what \u003ccode\u003ep\u003c/code\u003e points to, we call the \u003ccode\u003eElem\u003c/code\u003e method of \u003ccode\u003eValue\u003c/code\u003e,\nwhich indirects through the pointer, and save the result in a reflection \u003ccode\u003eValue\u003c/code\u003e called \u003ccode\u003ev\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ev := p.Elem()\nfmt.Println(\u0026#34;settability of v:\u0026#34;, v.CanSet())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow \u003ccode\u003ev\u003c/code\u003e is a settable reflection object, as the output demonstrates,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003esettability of v: true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand since it represents \u003ccode\u003ex\u003c/code\u003e, we are finally able to use \u003ccode\u003ev.SetFloat\u003c/code\u003e to modify the value of \u003ccode\u003ex\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ev.SetFloat(7.1)\nfmt.Println(v.Interface())\nfmt.Println(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output, as expected, is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e7.1\n7.1\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eReflection can be hard to understand but it’s doing exactly what the language does,\nalbeit through reflection \u003ccode\u003eTypes\u003c/code\u003e and \u003ccode\u003eValues\u003c/code\u003e that can disguise what’s going on.\nJust keep in mind that reflection Values need the address of something in\norder to modify what they represent.\u003c/p\u003e\n\u003ch2 id=\"structs\"\u003eStructs\u003c/h2\u003e\n\u003cp\u003eIn our previous example \u003ccode\u003ev\u003c/code\u003e wasn’t a pointer itself,\nit was just derived from one.\nA common way for this situation to arise is when using reflection to modify\nthe fields of a structure.\nAs long as we have the address of the structure,\nwe can modify its fields.\u003c/p\u003e\n\u003cp\u003eHere’s a simple example that analyzes a struct value, \u003ccode\u003et\u003c/code\u003e.\nWe create the reflection object with the address of the struct because we’ll\nwant to modify it later.\nThen we set \u003ccode\u003etypeOfT\u003c/code\u003e to its type and iterate over the fields using straightforward\nmethod calls (see \u003ca href=\"/pkg/reflect/\"\u003epackage reflect\u003c/a\u003e for details).\nNote that we extract the names of the fields from the struct type,\nbut the fields themselves are regular \u003ccode\u003ereflect.Value\u003c/code\u003e objects.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype T struct {\n    A int\n    B string\n}\nt := T{23, \u0026#34;skidoo\u0026#34;}\ns := reflect.ValueOf(\u0026amp;t).Elem()\ntypeOfT := s.Type()\nfor i := 0; i \u0026lt; s.NumField(); i++ {\n    f := s.Field(i)\n    fmt.Printf(\u0026#34;%d: %s %s = %v\\n\u0026#34;, i,\n        typeOfT.Field(i).Name, f.Type(), f.Interface())\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe output of this program is\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0: A int = 23\n1: B string = skidoo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere’s one more point about settability introduced in passing here:\nthe field names of \u003ccode\u003eT\u003c/code\u003e are upper case (exported) because only exported fields\nof a struct are settable.\u003c/p\u003e\n\u003cp\u003eBecause \u003ccode\u003es\u003c/code\u003e contains a settable reflection object, we can modify the fields of the structure.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es.Field(0).SetInt(77)\ns.Field(1).SetString(\u0026#34;Sunset Strip\u0026#34;)\nfmt.Println(\u0026#34;t is now\u0026#34;, t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd here’s the result:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003et is now {77 Sunset Strip}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we modified the program so that \u003ccode\u003es\u003c/code\u003e was created from \u003ccode\u003et\u003c/code\u003e,\nnot \u003ccode\u003e\u0026amp;t\u003c/code\u003e, the calls to \u003ccode\u003eSetInt\u003c/code\u003e and \u003ccode\u003eSetString\u003c/code\u003e would fail as the fields\nof \u003ccode\u003et\u003c/code\u003e would not be settable.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eHere again are the laws of reflection:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eReflection goes from interface value to reflection object.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eReflection goes from reflection object to interface value.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTo modify a reflection object, the value must be settable.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOnce you understand these laws reflection in Go becomes much easier to use,\nalthough it remains subtle.\nIt’s a powerful tool that should be used with care and avoided unless strictly necessary.\u003c/p\u003e\n\u003cp\u003eThere’s plenty more to reflection that we haven’t covered — sending and\nreceiving on channels,\nallocating memory, using slices and maps,\ncalling methods and functions — but this post is long enough.\nWe’ll cover some of those topics in a later article.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-09-06T00:00:00Z",
  "Author": "Rob Pike"
}