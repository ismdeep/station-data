{
  "Source": "go.dev",
  "Title": "New unique package",
  "Link": "https://go.dev/blog/unique",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/unique\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eNew unique package\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Michael Knyszek\u003cbr/\u003e\n      27 August 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eThe standard library of Go 1.23 now includes the \u003ca href=\"https://pkg.go.dev/unique\" rel=\"noreferrer\" target=\"_blank\"\u003enew \u003ccode\u003eunique\u003c/code\u003e package\u003c/a\u003e.\nThe purpose behind this package is to enable the canonicalization of\ncomparable values.\nIn other words, this package lets you deduplicate values so that they point\nto a single, canonical, unique copy, while efficiently managing the canonical\ncopies under the hood.\nYou might be familiar with this concept already, called\n\u003ca href=\"https://en.wikipedia.org/wiki/Interning_(computer_science)\" rel=\"noreferrer\" target=\"_blank\"\u003e“interning”\u003c/a\u003e.\nLet’s dive in to see how it works, and why it’s useful.\u003c/p\u003e\n\u003ch2 id=\"a-simple-implementation-of-interning\"\u003eA simple implementation of interning\u003c/h2\u003e\n\u003cp\u003eAt a high level, interning is very simple.\nTake the code sample below, which deduplicates strings using just a regular\nmap.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar internPool map[string]string\n\n// Intern returns a string that is equal to s but that may share storage with\n// a string previously passed to Intern.\nfunc Intern(s string) string {\n    pooled, ok := internPool[s]\n    if !ok {\n        // Clone the string in case it\u0026#39;s part of some much bigger string.\n        // This should be rare, if interning is being used well.\n        pooled = strings.Clone(s)\n        internPool[pooled] = pooled\n    }\n    return pooled\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is useful for when you’re constructing a lot of strings that are likely to\nbe duplicates, like when parsing a text format.\u003c/p\u003e\n\u003cp\u003eThis implementation is super simple and works well enough for some cases, but it\nhas a few problems:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIt never removes strings from the pool.\u003c/li\u003e\n\u003cli\u003eIt cannot be safely used by multiple goroutines concurrently.\u003c/li\u003e\n\u003cli\u003eIt only works with strings, even though the idea is quite general.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThere’s also a missed opportunity in this implementation, and it’s subtle.\nUnder the hood, \u003ca href=\"/blog/slices\"\u003estrings are immutable structures consisting of a pointer\nand a length\u003c/a\u003e.\nWhen comparing two strings, if the pointers are not equal, then we must\ncompare their contents to determine equality.\nBut if we know that two strings are canonicalized, then it \u003cem\u003eis\u003c/em\u003e sufficient\nto just check their pointers.\u003c/p\u003e\n\u003ch2 id=\"enter-the-unique-package\"\u003eEnter the \u003ccode\u003eunique\u003c/code\u003e package\u003c/h2\u003e\n\u003cp\u003eThe new \u003ccode\u003eunique\u003c/code\u003e package introduces a function similar to \u003ccode\u003eIntern\u003c/code\u003e called\n\u003ca href=\"https://pkg.go.dev/unique#Make\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eMake\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt works about the same way as \u003ccode\u003eIntern\u003c/code\u003e.\nInternally there’s also a global map (\u003ca href=\"https://pkg.go.dev/internal/concurrent@go1.23.0\" rel=\"noreferrer\" target=\"_blank\"\u003ea fast generic concurrent\nmap\u003c/a\u003e) and \u003ccode\u003eMake\u003c/code\u003e looks up the\nprovided value in that map.\nBut it also differs from \u003ccode\u003eIntern\u003c/code\u003e in two important ways.\nFirstly, it accepts values of any comparable type.\nAnd secondly, it returns a wrapper value, a\n\u003ca href=\"https://pkg.go.dev/unique#Handle\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eHandle[T]\u003c/code\u003e\u003c/a\u003e, from which the canonical value\ncan be retrieved.\u003c/p\u003e\n\u003cp\u003eThis \u003ccode\u003eHandle[T]\u003c/code\u003e is key to the design.\nA \u003ccode\u003eHandle[T]\u003c/code\u003e has the property that two \u003ccode\u003eHandle[T]\u003c/code\u003e values are equal if and\nonly if the values used to create them are equal.\nWhat’s more, the comparison of two \u003ccode\u003eHandle[T]\u003c/code\u003e values is cheap: it comes down\nto a pointer comparison.\nCompared to comparing two long strings, that’s an order of magnitude cheaper!\u003c/p\u003e\n\u003cp\u003eSo far, this is nothing you can’t do in ordinary Go code.\u003c/p\u003e\n\u003cp\u003eBut \u003ccode\u003eHandle[T]\u003c/code\u003e also has a second purpose: as long as a \u003ccode\u003eHandle[T]\u003c/code\u003e exists for\na value, the map will retain the canonical copy of the value.\nOnce all \u003ccode\u003eHandle[T]\u003c/code\u003e values that map to a specific value are gone, the\npackage marks that internal map entry as deletable, to be reclaimed in the near\nfuture.\nThis sets a clear policy for when to remove entries from the map: when the\ncanonical entries are no longer being used, then the garbage collector is free\nto clean them up.\u003c/p\u003e\n\u003cp\u003eIf you’ve used Lisp before, this may all sound quite familiar to you.\nLisp \u003ca href=\"https://en.wikipedia.org/wiki/Symbol_(programming)\" rel=\"noreferrer\" target=\"_blank\"\u003esymbols\u003c/a\u003e are interned\nstrings, but not strings themselves, and all symbols’ string values are\nguaranteed to be in the same pool.\nThis relationship between symbols and strings parallels the relationship\nbetween \u003ccode\u003eHandle[string]\u003c/code\u003e and \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"a-real-world-example\"\u003eA real-world example\u003c/h2\u003e\n\u003cp\u003eSo, how might one use \u003ccode\u003eunique.Make\u003c/code\u003e?\nLook no further than the \u003ccode\u003enet/netip\u003c/code\u003e package in the standard library, which\ninterns values of type \u003ccode\u003eaddrDetail\u003c/code\u003e, part of the\n\u003ca href=\"https://pkg.go.dev/net/netip#Addr\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003enetip.Addr\u003c/code\u003e\u003c/a\u003e structure.\u003c/p\u003e\n\u003cp\u003eBelow is an abridged version of the actual code from \u003ccode\u003enet/netip\u003c/code\u003e that uses\n\u003ccode\u003eunique\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Addr represents an IPv4 or IPv6 address (with or without a scoped\n// addressing zone), similar to net.IP or net.IPAddr.\ntype Addr struct {\n    // Other irrelevant unexported fields...\n\n    // Details about the address, wrapped up together and canonicalized.\n    z unique.Handle[addrDetail]\n}\n\n// addrDetail indicates whether the address is IPv4 or IPv6, and if IPv6,\n// specifies the zone name for the address.\ntype addrDetail struct {\n    isV6   bool   // IPv4 is false, IPv6 is true.\n    zoneV6 string // May be != \u0026#34;\u0026#34; if IsV6 is true.\n}\n\nvar z6noz = unique.Make(addrDetail{isV6: true})\n\n// WithZone returns an IP that\u0026#39;s the same as ip but with the provided\n// zone. If zone is empty, the zone is removed. If ip is an IPv4\n// address, WithZone is a no-op and returns ip unchanged.\nfunc (ip Addr) WithZone(zone string) Addr {\n    if !ip.Is6() {\n        return ip\n    }\n    if zone == \u0026#34;\u0026#34; {\n        ip.z = z6noz\n        return ip\n    }\n    ip.z = unique.Make(addrDetail{isV6: true, zoneV6: zone})\n    return ip\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince many IP addresses are likely to use the same zone and this zone is part\nof their identity, it makes a lot of sense to canonicalize them.\nThe deduplication of zones reduces the average memory footprint of each\n\u003ccode\u003enetip.Addr\u003c/code\u003e, while the fact that they’re canonicalized means \u003ccode\u003enetip.Addr\u003c/code\u003e\nvalues are more efficient to compare, since comparing zone names becomes a\nsimple pointer comparison.\u003c/p\u003e\n\u003ch2 id=\"a-footnote-about-interning-strings\"\u003eA footnote about interning strings\u003c/h2\u003e\n\u003cp\u003eWhile the \u003ccode\u003eunique\u003c/code\u003e package is useful, \u003ccode\u003eMake\u003c/code\u003e is admittedly not quite like\n\u003ccode\u003eIntern\u003c/code\u003e for strings, since the \u003ccode\u003eHandle[T]\u003c/code\u003e is required to keep a string from\nbeing deleted from the internal map.\nThis means you need to modify your code to retain handles as well as strings.\u003c/p\u003e\n\u003cp\u003eBut strings are special in that, although they behave like values, they\nactually contain pointers under the hood, as we mentioned earlier.\nThis means that we could potentially canonicalize just the underlying storage\nof the string, hiding the details of a \u003ccode\u003eHandle[T]\u003c/code\u003e inside the string itself.\nSo, there is still a place in the future for what I’ll call \u003cem\u003etransparent string\ninterning\u003c/em\u003e, in which strings can be interned without the \u003ccode\u003eHandle[T]\u003c/code\u003e type,\nsimilar to the \u003ccode\u003eIntern\u003c/code\u003e function but with semantics more closely resembling\n\u003ccode\u003eMake\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn the meantime, \u003ccode\u003eunique.Make(\u0026#34;my string\u0026#34;).Value()\u003c/code\u003e is one possible workaround.\nEven though failing to retain the handle will allow the string to be deleted\nfrom \u003ccode\u003eunique\u003c/code\u003e’s internal map, map entries are not deleted immediately.\nIn practice, entries will not be deleted until at least the next garbage\ncollection completes, so this workaround still allows for some degree of\ndeduplication in the periods between collections.\u003c/p\u003e\n\u003ch2 id=\"some-history-and-looking-toward-the-future\"\u003eSome history, and looking toward the future\u003c/h2\u003e\n\u003cp\u003eThe truth is that the \u003ccode\u003enet/netip\u003c/code\u003e package actually interned zone strings since\nit was first introduced.\nThe interning package it used was an internal copy of the\n\u003ca href=\"https://pkg.go.dev/go4.org/intern\" rel=\"noreferrer\" target=\"_blank\"\u003ego4.org/intern\u003c/a\u003e package.\nLike the \u003ccode\u003eunique\u003c/code\u003e package, it has a \u003ccode\u003eValue\u003c/code\u003e type (which looks a lot like a\n\u003ccode\u003eHandle[T]\u003c/code\u003e, pre-generics), has the notable property that entries in the\ninternal map are removed once their handles are no longer referenced.\u003c/p\u003e\n\u003cp\u003eBut to achieve this behavior, it has to do some unsafe things.\nIn particular, it makes some assumptions about the garbage collector’s behavior\nto implement \u003ca href=\"https://en.wikipedia.org/wiki/Weak_reference\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eweak pointers\u003c/em\u003e\u003c/a\u003e\noutside the runtime.\nA weak pointer is a pointer that doesn’t prevent the garbage collector from\nreclaiming a variable; when this happens, the pointer automatically becomes\nnil.\nAs it happens, weak pointers are \u003cem\u003ealso\u003c/em\u003e the core abstraction underlying the\n\u003ccode\u003eunique\u003c/code\u003e package.\u003c/p\u003e\n\u003cp\u003eThat’s right: while implementing the \u003ccode\u003eunique\u003c/code\u003e package, we added proper weak\npointer support to the garbage collector.\nAnd after stepping through the minefield of regrettable design decisions that\naccompany weak pointers (like, should weak pointers track \u003ca href=\"https://en.wikipedia.org/wiki/Object_resurrection\" rel=\"noreferrer\" target=\"_blank\"\u003eobject\nresurrection\u003c/a\u003e? No!), we were\nastonished by how simple and straightforward all of it turned out to be.\nAstonished enough that weak pointers are now a \u003ca href=\"/issue/67552\"\u003epublic\nproposal\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis work also led us to reexamine finalizers, resulting in another proposal\nfor an easier-to-use and more efficient \u003ca href=\"/issue/67535\"\u003ereplacement for\nfinalizers\u003c/a\u003e.\nWith \u003ca href=\"/issue/54670\"\u003ea hash function for comparable values\u003c/a\u003e on the way as well,\nthe future of \u003ca href=\"/issue/67552#issuecomment-2200755798\"\u003ebuilding memory-efficient\ncaches\u003c/a\u003e in Go is bright!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-08-27T00:00:00Z",
  "Author": "Michael Knyszek"
}