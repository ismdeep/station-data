{
  "Source": "go.dev",
  "Title": "Module Mirror and Checksum Database Launched",
  "Link": "https://go.dev/blog/module-mirror-launch",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/module-mirror-launch\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eModule Mirror and Checksum Database Launched\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Katie Hockman\u003cbr/\u003e\n      29 August 2019\n      \u003c/p\u003e\n      \n      \u003cp\u003eWe are excited to share that our module \u003ca href=\"https://proxy.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003emirror\u003c/a\u003e,\n\u003ca href=\"https://index.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003eindex\u003c/a\u003e, and\n\u003ca href=\"https://sum.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003echecksum database\u003c/a\u003e are now production ready! The \u003ccode\u003ego\u003c/code\u003e command\nwill use the module mirror and checksum database by default for\n\u003ca href=\"/doc/go1.13#introduction\"\u003eGo 1.13 module users\u003c/a\u003e.  See\n\u003ca href=\"https://proxy.golang.org/privacy\" rel=\"noreferrer\" target=\"_blank\"\u003eproxy.golang.org/privacy\u003c/a\u003e for privacy\ninformation about these services and the\n\u003ca href=\"/cmd/go/#hdr-Module_downloading_and_verification\"\u003ego command documentation\u003c/a\u003e\nfor configuration details, including how to disable the use of these servers or\nuse different ones.  If you depend on non-public modules, see the\n\u003ca href=\"/cmd/go/#hdr-Module_configuration_for_non_public_modules\"\u003edocumentation for configuring your environment\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis post will describe these services and the benefits of using them, and\nsummarizes some of the points from the\n\u003ca href=\"https://youtu.be/KqTySYYhPUE\" rel=\"noreferrer\" target=\"_blank\"\u003eGo Module Proxy: Life of a Query\u003c/a\u003e talk at Gophercon 2019.\nSee the \u003ca href=\"https://youtu.be/KqTySYYhPUE\" rel=\"noreferrer\" target=\"_blank\"\u003erecording\u003c/a\u003e if you are interested in the full talk.\u003c/p\u003e\n\u003ch2 id=\"module-mirror\"\u003eModule Mirror\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/blog/versioning-proposal\"\u003eModules\u003c/a\u003e are sets of Go packages\nthat are versioned together, and the contents of each version are immutable.\nThat immutability provides new opportunities for caching and authentication.\nWhen \u003ccode\u003ego get\u003c/code\u003e runs in module mode, it must fetch the module containing the\nrequested packages, as well as any new dependencies introduced by that module,\nupdating your\n\u003ca href=\"/cmd/go/#hdr-The_go_mod_file\"\u003ego.mod\u003c/a\u003e and\n\u003ca href=\"/cmd/go/#hdr-Module_downloading_and_verification\"\u003ego.sum\u003c/a\u003e\nfiles as needed. Fetching modules from version control can be expensive in terms\nof latency and storage in your system: the \u003ccode\u003ego\u003c/code\u003e command may be forced to pull down\nthe full commit history of a repository containing a transitive dependency, even\none that isn’t being built, just to resolve its version.\u003c/p\u003e\n\u003cp\u003eThe solution is to use a module proxy, which speaks an API that is better suited\nto the \u003ccode\u003ego\u003c/code\u003e command’s needs (see \u003ccode\u003ego help goproxy\u003c/code\u003e). When \u003ccode\u003ego get\u003c/code\u003e runs in\nmodule mode with a proxy, it will work faster by only asking for the specific\nmodule metadata or source code it needs, and not worrying about the rest. Below is\nan example of how the \u003ccode\u003ego\u003c/code\u003e command may use a proxy with \u003ccode\u003ego get\u003c/code\u003e by requesting the list\nof versions, then the info, mod, and zip file for the latest tagged version.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"module-mirror-launch/proxy-protocol.png\" width=\"800\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eA module mirror is a special kind of module proxy that caches metadata and\nsource code in its own storage system, allowing the mirror to continue to serve\nsource code that is no longer available from the original locations. This can\nspeed up downloads and protect you from disappearing dependencies. See\n\u003ca href=\"/blog/modules2019\"\u003eGo Modules in 2019\u003c/a\u003e for more information.\u003c/p\u003e\n\u003cp\u003eThe Go team maintains a module mirror, served at\n\u003ca href=\"https://proxy.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003eproxy.golang.org\u003c/a\u003e, which the \u003ccode\u003ego\u003c/code\u003e command will use by\ndefault for module users as of Go 1.13. If you are running an earlier version of the \u003ccode\u003ego\u003c/code\u003e\ncommand, then you can use this service by setting\n\u003ccode\u003eGOPROXY=https://proxy.golang.org\u003c/code\u003e in your local environment.\u003c/p\u003e\n\u003ch2 id=\"checksum-database\"\u003eChecksum Database\u003c/h2\u003e\n\u003cp\u003eModules introduced the \u003ccode\u003ego.sum\u003c/code\u003e file, which is a list of SHA-256 hashes of the\nsource code and \u003ccode\u003ego.mod\u003c/code\u003e files of each dependency when it was first downloaded.\nThe \u003ccode\u003ego\u003c/code\u003e command can use the hashes to detect misbehavior by an origin server or\nproxy that gives you different code for the same version.\u003c/p\u003e\n\u003cp\u003eThe limitation of this \u003ccode\u003ego.sum\u003c/code\u003e file is that it works entirely by trust on \u003cem\u003eyour\u003c/em\u003e\nfirst use. When you add a version of a dependency that you’ve never seen before\nto your module (possibly by upgrading an existing dependency), the \u003ccode\u003ego\u003c/code\u003e command\nfetches the code and adds lines to the \u003ccode\u003ego.sum\u003c/code\u003e file on the fly. The problem is\nthat those \u003ccode\u003ego.sum\u003c/code\u003e lines aren’t being checked against anyone else’s: they might\nbe different from the \u003ccode\u003ego.sum\u003c/code\u003e lines that the \u003ccode\u003ego\u003c/code\u003e command just generated for\nsomeone else, perhaps because a proxy intentionally served malicious code\ntargeted to you.\u003c/p\u003e\n\u003cp\u003eGo’s solution is a global source of \u003ccode\u003ego.sum\u003c/code\u003e lines, called a\n\u003ca href=\"https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database\" rel=\"noreferrer\" target=\"_blank\"\u003echecksum database\u003c/a\u003e,\nwhich ensures that the \u003ccode\u003ego\u003c/code\u003e command always adds the same lines to everyone’s\n\u003ccode\u003ego.sum\u003c/code\u003e file. Whenever the \u003ccode\u003ego\u003c/code\u003e command receives new source code, it can verify the\nhash of that code against this global database to make sure the hashes match,\nensuring that everyone is using the same code for a given version.\u003c/p\u003e\n\u003cp\u003eThe checksum database is served by \u003ca href=\"https://sum.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003esum.golang.org\u003c/a\u003e, and\nis built on a \u003ca href=\"https://research.swtch.com/tlog\" rel=\"noreferrer\" target=\"_blank\"\u003eTransparent Log\u003c/a\u003e (or “Merkle\ntree”) of hashes backed by \u003ca href=\"https://github.com/google/trillian\" rel=\"noreferrer\" target=\"_blank\"\u003eTrillian\u003c/a\u003e. The\nmain advantage of a Merkle tree is that it is tamper proof and has properties\nthat don’t allow for misbehavior to go undetected, which makes it more\ntrustworthy than a simple database. The \u003ccode\u003ego\u003c/code\u003e command uses this tree to check\n“inclusion” proofs (that a specific record exists in the log) and “consistency”\nproofs (that the tree hasn’t been tampered with) before adding new \u003ccode\u003ego.sum\u003c/code\u003e lines\nto your module’s \u003ccode\u003ego.sum\u003c/code\u003e file. Below is an example of such a tree.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"module-mirror-launch/tree.png\" width=\"800\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe checksum database supports\n\u003ca href=\"https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database\" rel=\"noreferrer\" target=\"_blank\"\u003ea set of endpoints\u003c/a\u003e\nused by the \u003ccode\u003ego\u003c/code\u003e command to request and verify \u003ccode\u003ego.sum\u003c/code\u003e lines. The \u003ccode\u003e/lookup\u003c/code\u003e\nendpoint provides a “signed tree head” (STH) and the requested \u003ccode\u003ego.sum\u003c/code\u003e lines. The\n\u003ccode\u003e/tile\u003c/code\u003e endpoint provides chunks of the tree called \u003cem\u003etiles\u003c/em\u003e which the \u003ccode\u003ego\u003c/code\u003e command\ncan use for proofs. Below is an example of how the \u003ccode\u003ego\u003c/code\u003e command may\ninteract with the checksum database by doing a \u003ccode\u003e/lookup\u003c/code\u003e of a module version, then\nrequesting the tiles required for the proofs.\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"module-mirror-launch/sumdb-protocol.png\" width=\"800\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThis checksum database allows the \u003ccode\u003ego\u003c/code\u003e command to safely use an otherwise\nuntrusted proxy. Because there is an auditable security layer sitting on top of\nit, a proxy or origin server can’t intentionally, arbitrarily, or accidentally\nstart giving you the wrong code without getting caught. Even the author of a\nmodule can’t move their tags around or otherwise change the bits associated with\na specific version from one day to the next without the change being detected.\u003c/p\u003e\n\u003cp\u003eIf you are using Go 1.12 or earlier, you can manually check a \u003ccode\u003ego.sum\u003c/code\u003e file\nagainst the checksum database with\n\u003ca href=\"https://godoc.org/golang.org/x/mod/gosumcheck\" rel=\"noreferrer\" target=\"_blank\"\u003egosumcheck\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get golang.org/x/mod/gosumcheck\n$ gosumcheck /path/to/go.sum\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn addition to verification done by the \u003ccode\u003ego\u003c/code\u003e command, third-party\nauditors can hold the checksum database accountable by iterating over the log\nlooking for bad entries. They can work together and gossip about the state of\nthe tree as it grows to ensure that it remains uncompromised, and we hope that\nthe Go community will run them.\u003c/p\u003e\n\u003ch2 id=\"module-index\"\u003eModule Index\u003c/h2\u003e\n\u003cp\u003eThe module index is served by \u003ca href=\"https://index.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003eindex.golang.org\u003c/a\u003e, and\nis a public feed of new module versions that become available through\n\u003ca href=\"https://proxy.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003eproxy.golang.org\u003c/a\u003e. This is particularly useful for\ntool developers that want to keep their own cache of what’s available in\n\u003ca href=\"https://proxy.golang.org\" rel=\"noreferrer\" target=\"_blank\"\u003eproxy.golang.org\u003c/a\u003e, or keep up-to-date on some of the\nnewest modules that people are using.\u003c/p\u003e\n\u003ch2 id=\"feedback-or-bugs\"\u003eFeedback or bugs\u003c/h2\u003e\n\u003cp\u003eWe hope these services improve your experience with modules, and encourage you\nto \u003ca href=\"/issue/new?title=proxy.golang.org\"\u003efile issues\u003c/a\u003e if you run into\nproblems or have feedback!\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-08-29T00:00:00Z",
  "Author": "Katie Hockman"
}