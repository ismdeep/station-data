{
  "Source": "go.dev",
  "Title": "Go, Open Source, Community",
  "Link": "https://go.dev/blog/open-source",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/open-source\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo, Open Source, Community\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      8 July 2015\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"welcome\"\u003eWelcome\u003c/h2\u003e\n\u003cp\u003e[This is the text of my opening keynote at Gophercon 2015.\n\u003ca href=\"https://www.youtube.com/watch?v=XvZOdpd_9tc\" rel=\"noreferrer\" target=\"_blank\"\u003eThe video is available here\u003c/a\u003e.]\u003c/p\u003e\n\u003cp\u003eThank you all for traveling to Denver to be here,\nand thank you to everyone watching on video.\nIf this is your first Gophercon, welcome.\nIf you were here last year, welcome back.\nThank you to the organizers\nfor all the work it takes\nto make a conference like this happen.\nI am thrilled to be here and to be able to talk to all of you.\u003c/p\u003e\n\u003cp\u003eI am the tech lead for the Go project\nand the Go team at Google.\nI share that role with Rob Pike.\nIn that role, I spend a lot of time thinking about\nthe overall Go open source project,\nin particular the way it runs,\nwhat it means to be open source,\nand the interaction between\ncontributors inside and outside Google.\nToday I want to share with you\nhow I see the Go project as a whole\nand then based on that explain\nhow I see the Go open source project\nevolving.\u003c/p\u003e\n\u003ch2 id=\"why-go\"\u003eWhy Go?\u003c/h2\u003e\n\u003cp\u003eTo get started,\nwe have to go back to the beginning.\nWhy did we start working on Go?\u003c/p\u003e\n\u003cp\u003eGo is an attempt to make programmers more productive.\nWe wanted to improve the software development process\nat Google,\nbut the problems Google has\nare not unique to Google.\u003c/p\u003e\n\u003cp\u003eThere were two overarching goals.\u003c/p\u003e\n\u003cp\u003eThe first goal is to make a better language\nto meet the challenges of scalable concurrency.\nBy scalable concurrency I mean\nsoftware that deals with many concerns simultaneously,\nsuch as coordinating a thousand back end servers\nby sending network traffic back and forth.\u003c/p\u003e\n\u003cp\u003eToday, that kind of software has a shorter name:\nwe call it cloud software.\nIt’s fair to say that Go was designed for the cloud\nbefore clouds ran software.\u003c/p\u003e\n\u003cp\u003eThe larger goal is to make a better environment\nto meet the challenges of scalable software development,\nsoftware worked on and used by many people,\nwith limited coordination between them,\nand maintained for years.\nAt Google we have thousands of engineers\nwriting and sharing their code with each other,\ntrying to get their work done,\nreusing the work of others as much as possible,\nand working in a code base with a history\ndating back over ten years.\nEngineers often work on or at least look at\ncode originally written by someone else,\nor that they wrote years ago,\nwhich often amounts to the same thing.\u003c/p\u003e\n\u003cp\u003eThat situation inside Google\nhas a lot in common with\nlarge scale, modern open source development\nas practiced on sites like GitHub.\nBecause of this,\nGo is a great fit for open source projects,\nhelping them accept and manage\ncontributions from a large community\nover a long period of time.\u003c/p\u003e\n\u003cp\u003eI believe much of Go’s success is explained by the fact that\nGo is a great fit for cloud software,\nGo is a great fit for open source projects,\nand, serendipitously, both of those are\ngrowing in popularity and importance\nin the software industry.\u003c/p\u003e\n\u003cp\u003eOther people have made similar observations.\nHere are two.\nLast year, on RedMonk.com, Donnie Berkholz\nwrote about\n“\u003ca href=\"http://redmonk.com/dberkholz/2014/03/18/go-the-emerging-language-of-cloud-infrastructure/\" rel=\"noreferrer\" target=\"_blank\"\u003eGo as the emerging language of cloud infrastructure\u003c/a\u003e,”\nobserving that\n“[Go’s] marquee projects … are cloud-centric or otherwise\nmade for dealing with distributed systems\nor transient environments.”\u003c/p\u003e\n\u003cp\u003eThis year, on Texlution.com, the author\nwrote an article titled\n“\u003ca href=\"https://texlution.com/post/why-go-is-doomed-to-succeed/\" rel=\"noreferrer\" target=\"_blank\"\u003eWhy Golang is doomed to succeed\u003c/a\u003e,”\npointing out that this focus on large-scale development\nwas possibly even better suited to open source than\nto Google itself: “This open source fitness is why I think\nyou are about to see more and more Go around …”\u003c/p\u003e\n\u003ch2 id=\"the-go-balance\"\u003eThe Go Balance\u003c/h2\u003e\n\u003cp\u003eHow does Go accomplish those things?\u003c/p\u003e\n\u003cp\u003eHow does it make scalable concurrency\nand scalable software development easier?\u003c/p\u003e\n\u003cp\u003eMost people answer this question by talking about\nchannels and goroutines, and interfaces, and fast builds,\nand the go command, and good tool support.\nThose are all important parts of the answer,\nbut I think there is a broader idea behind them.\u003c/p\u003e\n\u003cp\u003eI think of that idea as Go’s balance.\nThere are competing concerns in any software design,\nand there is a very natural tendency to try to solve\nall the problems you foresee.\nIn Go, we have explicitly tried not to solve everything.\nInstead, we’ve tried to do just enough that you can build\nyour own custom solutions easily.\u003c/p\u003e\n\u003cp\u003eThe way I would summarize Go’s chosen balance is this: \u003cstrong\u003eDo Less. Enable More.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eDo less, but enable more.\u003c/p\u003e\n\u003cp\u003eGo can’t do everything.\nWe shouldn’t try.\nBut if we work at it,\nGo can probably do\na few things well.\nIf we select those things carefully,\nwe can lay a foundation\non which developers can \u003cem\u003eeasily\u003c/em\u003e build\nthe solutions and tools they need,\nand ideally can interoperate with\nthe solutions and tools built by others.\u003c/p\u003e\n\u003ch3 id=\"examples\"\u003eExamples\u003c/h3\u003e\n\u003cp\u003eLet me illustrate this with some examples.\u003c/p\u003e\n\u003cp\u003eFirst, the size of the Go language itself.\nWe worked hard to put in as few concepts as possible,\nto avoid the problem of mutually incomprehensible dialects\nforming in different parts of a large developer community.\nNo idea went into Go until\nit had been simplified to its essence\nand then had clear benefits\nthat justified the complexity being added.\u003c/p\u003e\n\u003cp\u003eIn general, if we have 100 things\nwe want Go to do well,\nwe can’t make 100 separate changes.\nInstead, we try to research and understand\nthe design space\nand then identify a few changes\nthat work well together\nand that enable maybe 90 of those things.\nWe’re willing to sacrifice the remaining 10\nto avoid bloating the language,\nto avoid adding complexity\nonly to address specific use cases\nthat seem important today\nbut might be gone tomorrow.\u003c/p\u003e\n\u003cp\u003eKeeping the language small\nenables more important goals.\nBeing small makes Go\neasier to learn,\neasier to understand,\neasier to implement,\neasier to reimplement,\neasier to debug,\neasier to adjust,\nand easier to evolve.\nDoing less enables more.\u003c/p\u003e\n\u003cp\u003eI should point out that\nthis means we say no\nto a lot of other people’s ideas,\nbut I assure you\nwe’ve said no\nto even more of our own ideas.\u003c/p\u003e\n\u003cp\u003eNext, channels and goroutines.\nHow should we structure and coordinate\nconcurrent and parallel computations?\nMutexes and condition variables are very general\nbut so low-level that they’re difficult to use correctly.\nParallel execution frameworks like OpenMP are so high-level\nthat they can only be used to solve a narrow range of problems.\nChannels and goroutines sit between these two extremes.\nBy themselves, they aren’t a solution to much.\nBut they are powerful enough to be easily arranged\nto enable solutions to many common problems\nin concurrent software.\nDoing less—really doing just enough—enables more.\u003c/p\u003e\n\u003cp\u003eNext, types and interfaces.\nHaving static types enables useful compile-time checking,\nsomething lacking in dynamically-typed languages\nlike Python or Ruby.\nAt the same time,\nGo’s static typing avoids\nmuch of the repetition\nof traditional statically typed languages,\nmaking it feel more lightweight,\nmore like the dynamically-typed languages.\nThis was one of the first things people noticed,\nand many of Go’s early adopters came from\ndynamically-typed languages.\u003c/p\u003e\n\u003cp\u003eGo’s interfaces are a key part of that.\nIn particular,\nomitting the ``implements’’ declarations\nof Java or other languages with static hierarchy\nmakes interfaces lighter weight and more flexible.\nNot having that rigid hierarchy\nenables idioms such as test interfaces that describe\nexisting, unrelated production implementations.\nDoing less enables more.\u003c/p\u003e\n\u003cp\u003eNext, testing and benchmarking.\nIs there any shortage of testing\nand benchmarking frameworks in most languages?\nIs there any agreement between them?\u003c/p\u003e\n\u003cp\u003eGo’s testing package is not meant\nto address every possible facet of these topics.\nInstead, it is meant to provide\nthe basic concepts necessary\nfor most higher-level tooling.\nPackages have test cases that pass, fail, or are skipped.\nPackages have benchmarks that run and can be measured\nby various metrics.\u003c/p\u003e\n\u003cp\u003eDoing less here is an attempt\nto reduce these concepts to their essence,\nto create a shared vocabulary\nso that richer tools can interoperate.\nThat agreement enables higher-level testing software\nlike Miki Tebeka’s go2xunit converter,\nor the benchcmp and benchstat\nbenchmark analysis tools.\u003c/p\u003e\n\u003cp\u003eBecause there \u003cem\u003eis\u003c/em\u003e agreement\nabout the representation of the basic concepts,\nthese higher-level tools work for all Go packages,\nnot just ones that make the effort to opt in,\nand they interoperate with each other,\nin that using, say, go2xunit\ndoes not preclude also using benchstat,\nthe way it would if these tools were, say,\nplugins for competing testing frameworks.\nDoing less enables more.\u003c/p\u003e\n\u003cp\u003eNext, refactoring and program analysis.\nBecause Go is for large code bases,\nwe knew it would need to support automatic\nmaintenance and updating of source code.\nWe also knew that this topic was too large\nto build in directly.\nBut we knew one thing that we had to do.\nIn our experience attempting\nautomated program changes in other settings,\nthe most significant barrier we hit\nwas actually writing the modified program out\nin a format that developers can accept.\u003c/p\u003e\n\u003cp\u003eIn other languages,\nit’s common for different teams to use\ndifferent formatting conventions.\nIf an edit by a program uses the wrong convention,\nit either writes a section of the source file that looks nothing\nlike the rest of the file, or it reformats the entire file,\ncausing unnecessary and unwanted diffs.\u003c/p\u003e\n\u003cp\u003eGo does not have this problem.\nWe designed the language to make gofmt possible,\nwe worked hard\nto make gofmt’s formatting acceptable\nfor all Go programs,\nand we made sure gofmt was there\nfrom day one of the original public release.\nGofmt imposes such uniformity that\nautomated changes blend into the rest of the file.\nYou can’t tell whether a particular change\nwas made by a person or a computer.\nWe didn’t build explicit refactoring support.\nEstablishing an agreed-upon formatting algorithm\nwas enough of a shared base\nfor independent tools to develop and to interoperate.\nGofmt enabled gofix, goimports, eg, and other tools.\nI believe the work here is only just getting started.\nEven more can be done.\u003c/p\u003e\n\u003cp\u003eLast, building and sharing software.\nIn the run up to Go 1, we built goinstall,\nwhich became what we all know as “go get”.\nThat tool defined a standard zero-configuration way\nto resolve import paths on sites like github.com,\nand later a way to resolve paths on other sites\nby making HTTP requests.\nThis agreed-upon resolution algorithm\nenabled other tools that work in terms of those paths,\nmost notably Gary Burd’s creation of godoc.org.\nIn case you haven’t used it,\nyou go to godoc.org/the-import-path\nfor any valid “go get” import path,\nand the web site will fetch the code\nand show you the documentation for it.\nA nice side effect of this has been that\ngodoc.org serves as a rough master list\nof the Go packages publicly available.\nAll we did was give import paths a clear meaning.\nDo less, enable more.\u003c/p\u003e\n\u003cp\u003eYou’ll notice that many of these tooling examples\nare about establishing a shared convention.\nSometimes people refer to this as Go being “opinionated,”\nbut there’s something deeper going on.\nAgreeing to the limitations\nof a shared convention\nis a way to enable\na broad class of tools that interoperate,\nbecause they all speak the same base language.\nThis is a very effective way\nto do less but enable more.\nSpecifically, in many cases\nwe can do the minimum required\nto establish a shared understanding\nof a particular concept, like remote imports,\nor the proper formatting of a source file,\nand thereby enable\nthe creation of packages and tools\nthat work together\nbecause they all agree\nabout those core details.\u003c/p\u003e\n\u003cp\u003eI’m going to return to that idea later.\u003c/p\u003e\n\u003ch2 id=\"why-is-go-open-source\"\u003eWhy is Go open source?\u003c/h2\u003e\n\u003cp\u003eBut first, as I said earlier,\nI want to explain how I see\nthe balance of Do Less and Enable More\nguiding our work\non the broader\nGo open source project.\nTo do that, I need to start with\nwhy Go is open source at all.\u003c/p\u003e\n\u003cp\u003eGoogle pays me and others to work on Go, because,\nif Google’s programmers are more productive,\nGoogle can build products faster,\nmaintain them more easily,\nand so on.\nBut why open source Go?\nWhy should Google share this benefit with the world?\u003c/p\u003e\n\u003cp\u003eOf course, many of us\nworked on open source projects before Go,\nand we naturally wanted Go\nto be part of that open source world.\nBut our preferences are not a business justification.\nThe business justification is that\nGo is open source\nbecause that’s the only way\nthat Go can succeed.\nWe, the team that built Go within Google,\nknew this from day one.\nWe knew that Go had to be made available\nto as many people as possible\nfor it to succeed.\u003c/p\u003e\n\u003cp\u003eClosed languages die.\u003c/p\u003e\n\u003cp\u003eA language needs large, broad communities.\u003c/p\u003e\n\u003cp\u003eA language needs lots of people writing lots of software,\nso that when you need a particular tool or library,\nthere’s a good chance it has already been written,\nby someone who knows the topic better than you,\nand who spent more time than you have to make it great.\u003c/p\u003e\n\u003cp\u003eA language needs lots of people reporting bugs,\nso that problems are identified and fixed quickly.\nBecause of the much larger user base,\nthe Go compilers are much more robust and spec-compliant\nthan the Plan 9 C compilers they’re loosely based on ever were.\u003c/p\u003e\n\u003cp\u003eA language needs lots of people using it\nfor lots of different purposes,\nso that the language doesn’t overfit to one use case\nand end up useless when the technology landscape changes.\u003c/p\u003e\n\u003cp\u003eA language needs lots of people who want to learn it,\nso that there is a market for people to write books\nor teach courses,\nor run conferences like this one.\u003c/p\u003e\n\u003cp\u003eNone of this could have happened\nif Go had stayed within Google.\nGo would have suffocated inside Google,\nor inside any single company\nor closed environment.\u003c/p\u003e\n\u003cp\u003eFundamentally,\nGo must be open,\nand Go needs you.\nGo can’t succeed without all of you,\nwithout all the people using Go\nfor all different kinds of projects\nall over the world.\u003c/p\u003e\n\u003cp\u003eIn turn, the Go team at Google\ncould never be large enough\nto support the entire Go community.\nTo keep scaling,\nwe\nneed to enable all this ``more’\u0026#39;\nwhile doing less.\nOpen source is a huge part of that.\u003c/p\u003e\n\u003ch2 id=\"gos-open-source\"\u003eGo’s open source\u003c/h2\u003e\n\u003cp\u003eWhat does open source mean?\nThe minimum requirement is to open the source code,\nmaking it available under an open source license,\nand we’ve done that.\u003c/p\u003e\n\u003cp\u003eBut we also opened our development process:\nsince announcing Go,\nwe’ve done all our development in public,\non public mailing lists open to all.\nWe accept and review\nsource code contributions from anyone.\nThe process is the same\nwhether you work for Google or not.\nWe maintain our bug tracker in public,\nwe discuss and develop proposals for changes in public,\nand we work toward releases in public.\nThe public source tree is the authoritative copy.\nChanges happen there first.\nThey are only brought into\nGoogle’s internal source tree later.\nFor Go, being open source means\nthat this is a collective effort\nthat extends beyond Google, open to all.\u003c/p\u003e\n\u003cp\u003eAny open source project starts with a few people,\noften just one, but with Go it was three:\nRobert Griesemer, Rob Pike, and Ken Thompson.\nThey had a vision of\nwhat they wanted Go to be,\nwhat they thought Go could do better\nthan existing languages, and\nRobert will talk more about that tomorrow morning.\nI was the next person to join the team,\nand then Ian Taylor,\nand then, one by one,\nwe’ve ended up where we are today,\nwith hundreds of contributors.\u003c/p\u003e\n\u003cp\u003eThank You\nto the many people who have contributed\ncode\nor ideas\nor bug reports\nto the Go project so far.\nWe tried to list everyone we could\nin our space in the program today.\nIf your name is not there,\nI apologize,\nbut thank you.\u003c/p\u003e\n\u003cp\u003eI believe\nthe hundreds of contributors so far\nare working toward a shared vision\nof what Go can be.\nIt’s hard to put words to these things,\nbut I did my best\nto explain one part of the vision\nearlier:\nDo Less, Enable More.\u003c/p\u003e\n\u003ch2 id=\"googles-role\"\u003eGoogle’s role\u003c/h2\u003e\n\u003cp\u003eA natural question is:\nWhat is the role\nof the Go team at Google,\ncompared to other contributors?\nI believe that role\nhas changed over time,\nand it continues to change.\nThe general trend is that\nover time\nthe Go team at Google\nshould be doing less\nand enabling more.\u003c/p\u003e\n\u003cp\u003eIn the very early days,\nbefore Go was known to the public,\nthe Go team at Google\nwas obviously working by itself.\nWe wrote the first draft of everything:\nthe specification,\nthe compiler,\nthe runtime,\nthe standard library.\u003c/p\u003e\n\u003cp\u003eOnce Go was open sourced, though,\nour role began to change.\nThe most important thing\nwe needed to do\nwas communicate our vision for Go.\nThat’s difficult,\nand we’re still working at it.\nThe initial implementation\nwas an important way\nto communicate that vision,\nas was the development work we led\nthat resulted in Go 1,\nand the various blog posts,\nand articles,\nand talks we’ve published.\u003c/p\u003e\n\u003cp\u003eBut as Rob said at Gophercon last year,\n“the language is done.”\nNow we need to see how it works,\nto see how people use it,\nto see what people build.\nThe focus now is on\nexpanding the kind of work\nthat Go can help with.\u003c/p\u003e\n\u003cp\u003eGoogle’s primarily role is now\nto enable the community,\nto coordinate,\nto make sure changes work well together,\nand to keep Go true to the original vision.\u003c/p\u003e\n\u003cp\u003eGoogle’s primary role is:\nDo Less. Enable More.\u003c/p\u003e\n\u003cp\u003eI mentioned earlier\nthat we’d rather have a small number of features\nthat enable, say, 90% of the target use cases,\nand avoid the orders of magnitude\nmore features necessary\nto reach 99 or 100%.\nWe’ve been successful in applying that strategy\nto the areas of software that we know well.\nBut if Go is to become useful in many new domains,\nwe need experts in those areas\nto bring their expertise\nto our discussions,\nso that together\nwe can design small adjustments\nthat enable many new applications for Go.\u003c/p\u003e\n\u003cp\u003eThis shift applies not just to design\nbut also to development.\nThe role of the Go team at Google\ncontinues to shift\nmore to one of guidance\nand less of pure development.\nI certainly spend much more time\ndoing code reviews than writing code,\nmore time processing bug reports\nthan filing bug reports myself.\nWe need to do less and enable more.\u003c/p\u003e\n\u003cp\u003eAs design and development shift\nto the broader Go community,\none of the most important things\nwe\nthe original authors of Go\ncan offer\nis consistency of vision,\nto help keep Go\nGo.\nThe balance that we must strike\nis certainly subjective.\nFor example, a mechanism for extensible syntax\nwould be a way to\nenable more\nways to write Go code,\nbut that would run counter to our goal\nof having a consistent language\nwithout different dialects.\u003c/p\u003e\n\u003cp\u003eWe have to say no sometimes,\nperhaps more than in other language communities,\nbut when we do,\nwe aim to do so\nconstructively and respectfully,\nto take that as an opportunity\nto clarify the vision for Go.\u003c/p\u003e\n\u003cp\u003eOf course, it’s not all coordination and vision.\nGoogle still funds Go development work.\nRick Hudson is going to talk later today\nabout his work on reducing garbage collector latency,\nand Hana Kim is going to talk tomorrow\nabout her work on bringing Go to mobile devices.\nBut I want to make clear that,\nas much as possible,\nwe aim to treat\ndevelopment funded by Google\nas equal to\ndevelopment funded by other companies\nor contributed by individuals using their spare time.\nWe do this because we don’t know\nwhere the next great idea will come from.\nEveryone contributing to Go\nshould have the opportunity to be heard.\u003c/p\u003e\n\u003ch3 id=\"examples-1\"\u003eExamples\u003c/h3\u003e\n\u003cp\u003eI want to share some evidence for this claim\nthat, over time,\nthe original Go team at Google\nis focusing more on\ncoordination than direct development.\u003c/p\u003e\n\u003cp\u003eFirst, the sources of funding\nfor Go development are expanding.\nBefore the open source release,\nobviously Google paid for all Go development.\nAfter the open source release,\nmany individuals started contributing their time,\nand we’ve slowly but steadily\nbeen growing the number of contributors\nsupported by other companies\nto work on Go at least part-time,\nespecially as it relates to\nmaking Go more useful for those companies.\nToday, that list includes\nCanonical, Dropbox, Intel, Oracle, and others.\nAnd of course Gophercon and the other\nregional Go conferences are organized\nentirely by people outside Google,\nand they have many corporate sponsors\nbesides Google.\u003c/p\u003e\n\u003cp\u003eSecond, the conceptual depth\nof Go development\ndone outside the original team\nis expanding.\u003c/p\u003e\n\u003cp\u003eImmediately after the open source release,\none of the first large contributions\nwas the port to Microsoft Windows,\nstarted by Hector Chu\nand completed by Alex Brainman and others.\nMore contributors ported Go\nto other operating systems.\nEven more contributors\nrewrote most of our numeric code\nto be faster or more precise or both.\nThese were all important contributions,\nand very much appreciated,\nbut\nfor the most part\nthey did not involve new designs.\u003c/p\u003e\n\u003cp\u003eMore recently,\na group of contributors led by Aram Hăvărneanu\nported Go to the ARM 64 architecture,\nThis was the first architecture port\nby contributors outside Google.\nThis is significant, because\nin general\nsupport for a new architecture\nrequires more design work\nthan support for a new operating system.\nThere is more variation between architectures\nthan between operating systems.\u003c/p\u003e\n\u003cp\u003eAnother example is the introduction\nover the past few releases\nof preliminary support\nfor building Go programs using shared libraries.\nThis feature is important for many Linux distributions\nbut not as important for Google,\nbecause we deploy static binaries.\nWe have been helping guide the overall strategy,\nbut most of the design\nand nearly all of the implementation\nhas been done by contributors outside Google,\nespecially Michael Hudson-Doyle.\u003c/p\u003e\n\u003cp\u003eMy last example is the go command’s\napproach to vendoring.\nI define vendoring as\ncopying source code for external dependencies\ninto your tree\nto make sure that they don’t disappear\nor change underfoot.\u003c/p\u003e\n\u003cp\u003eVendoring is not a problem Google suffers,\nat least not the way the rest of the world does.\nWe copy open source libraries we want to use\ninto our shared source tree,\nrecord what version we copied,\nand only update the copy\nwhen there is a need to do so.\nWe have a rule\nthat there can only be one version\nof a particular library in the source tree,\nand it’s the job of whoever wants to upgrade that library\nto make sure it keeps working as expected\nby the Google code that depends on it.\nNone of this happens often.\nThis is the lazy approach to vendoring.\u003c/p\u003e\n\u003cp\u003eIn contrast, most projects outside Google\ntake a more eager approach,\nimporting and updating code\nusing automated tools\nand making sure that they are\nalways using the latest versions.\u003c/p\u003e\n\u003cp\u003eBecause Google has relatively little experience\nwith this vendoring problem,\nwe left it to users outside Google to develop solutions.\nOver the past five years,\npeople have built a series of tools.\nThe main ones in use today are\nKeith Rarick’s godep,\nOwen Ou’s nut,\nand the gb-vendor plugin for Dave Cheney’s gb,\u003c/p\u003e\n\u003cp\u003eThere are two problems with the current situation.\nThe first is that these tools\nare not compatible\nout of the box\nwith the go command’s “go get”.\nThe second is that the tools\nare not even compatible with each other.\nBoth of these problems\nfragment the developer community by tool.\u003c/p\u003e\n\u003cp\u003eLast fall, we started a public design discussion\nto try to build consensus on\nsome basics about\nhow these tools all operate,\nso that they can work alongside “go get”\nand each other.\u003c/p\u003e\n\u003cp\u003eOur basic proposal was that all tools agree\non the approach of rewriting import paths during vendoring,\nto fit with “go get”’s model,\nand also that all tools agree on a file format\ndescribing the source and version of the copied code,\nso that the different vendoring tools\ncan be used together\neven by a single project.\nIf you use one today,\nyou should still be able to use another tomorrow.\u003c/p\u003e\n\u003cp\u003eFinding common ground in this way\nwas very much in the spirit of Do Less, Enable More.\nIf we could build consensus\nabout these basic semantic aspects,\nthat would enable “go get” and all these tools to interoperate,\nand it would enable switching between tools,\nthe same way that\nagreement about how Go programs\nare stored in text files\nenables the Go compiler and all text editors to interoperate.\nSo we sent out our proposal for common ground.\u003c/p\u003e\n\u003cp\u003eTwo things happened.\u003c/p\u003e\n\u003cp\u003eFirst, Daniel Theophanes\nstarted a vendor-spec project on GitHub\nwith a new proposal\nand took over coordination and design\nof the spec for vendoring metadata.\u003c/p\u003e\n\u003cp\u003eSecond, the community spoke\nwith essentially one voice\nto say that\nrewriting import paths during vendoring\nwas not tenable.\nVendoring works much more smoothly\nif code can be copied without changes.\u003c/p\u003e\n\u003cp\u003eKeith Rarick posted an alternate proposal\nfor a minimal change to the go command\nto support vendoring without rewriting import paths.\nKeith’s proposal was configuration-free\nand fit in well with the rest of the go command’s approach.\nThat proposal will ship\nas an experimental feature in Go 1.5\nand likely enabled by default in Go 1.6.\nAnd I believe that the various vendoring tool authors\nhave agreed to adopt Daniel’s spec once it is finalized.\u003c/p\u003e\n\u003cp\u003eThe result\nis that at the next Gophercon\nwe should have broad interoperability\nbetween vendoring tools and the go command,\nand the design to make that happen\nwas done entirely by contributors\noutside the original Go team.\u003c/p\u003e\n\u003cp\u003eNot only that,\nthe Go team’s proposal for how to do this\nwas essentially completely wrong.\nThe Go community told us that\nvery clearly.\nWe took that advice,\nand now there’s a plan for vendoring support\nthat I believe\neveryone involved is happy with.\u003c/p\u003e\n\u003cp\u003eThis is also a good example\nof our general approach to design.\nWe try not to make any changes to Go\nuntil we feel there is broad consensus\non a well-understood solution.\nFor vendoring,\nfeedback and design\nfrom the Go community\nwas critical to reaching that point.\u003c/p\u003e\n\u003cp\u003eThis general trend\ntoward both code and design\ncoming from the broader Go community\nis important for Go.\nYou, the broader Go community,\nknow what is working\nand what is not\nin the environments where you use Go.\nWe at Google don’t.\nMore and more,\nwe will rely on your expertise,\nand we will try to help you develop\ndesigns and code\nthat extend Go to be useful in more settings\nand fit well with Go’s original vision.\nAt the same time,\nwe will continue to wait\nfor broad consensus\non well-understood solutions.\u003c/p\u003e\n\u003cp\u003eThis brings me to my last point.\u003c/p\u003e\n\u003ch2 id=\"code-of-conduct\"\u003eCode of Conduct\u003c/h2\u003e\n\u003cp\u003eI’ve argued that Go must be open,\nand that Go needs your help.\u003c/p\u003e\n\u003cp\u003eBut in fact Go needs everyone’s help.\nAnd everyone isn’t here.\u003c/p\u003e\n\u003cp\u003eGo needs ideas from as many people as possible.\u003c/p\u003e\n\u003cp\u003eTo make that a reality,\nthe Go community needs to be\nas inclusive,\nwelcoming,\nhelpful,\nand respectful as possible.\u003c/p\u003e\n\u003cp\u003eThe Go community is large enough now that,\ninstead of assuming that everyone involved\nknows what is expected,\nI and others believe that it makes sense\nto write down those expectations explicitly.\nMuch like the Go spec\nsets expectations for all Go compilers,\nwe can write a spec\nsetting expectations for our behavior\nin online discussions\nand in offline meetings like this one.\u003c/p\u003e\n\u003cp\u003eLike any good spec,\nit must be general enough\nto allow many implementations\nbut specific enough\nthat it can identify important problems.\nWhen our behavior doesn’t meet the spec,\npeople can point that out to us,\nand we can fix the problem.\nAt the same time,\nit’s important to understand that\nthis kind of spec\ncannot be as precise as a language spec.\nWe must start with the assumption\nthat we will all be reasonable in applying it.\u003c/p\u003e\n\u003cp\u003eThis kind of spec\nis often referred to as\na Code of Conduct.\nGophercon has one,\nwhich we’ve all agreed to follow\nby being here,\nbut the Go community does not.\nI and others\nbelieve the Go community\nneeds a Code of Conduct.\u003c/p\u003e\n\u003cp\u003eBut what should it say?\u003c/p\u003e\n\u003cp\u003eI believe\nthe most important\noverall statement we can make\nis that\nif you want to use or discuss Go,\nthen you are welcome here,\nin our community.\nThat is the standard\nI believe we aspire to.\u003c/p\u003e\n\u003cp\u003eIf for no other reason\n(and, to be clear, there are excellent other reasons),\nGo needs as large a community as possible.\nTo the extent that behavior\nlimits the size of the community,\nit holds Go back.\nAnd behavior can easily\nlimit the size of the community.\u003c/p\u003e\n\u003cp\u003eThe tech community in general\nand the Go community in particular\nis skewed toward people who communicate bluntly.\nI don’t believe this is fundamental.\nI don’t believe this is necessary.\nBut it’s especially easy to do\nin online discussions like email and IRC,\nwhere plain text is not supplemented\nby the other cues and signals we have\nin face-to-face interactions.\u003c/p\u003e\n\u003cp\u003eFor example, I have learned\nthat when I am pressed for time\nI tend to write fewer words,\nwith the end result that\nmy emails seem not just hurried\nbut blunt, impatient, even dismissive.\nThat’s not how I feel,\nbut it’s how I can come across,\nand that impression can be enough\nto make people think twice\nabout using or contributing\nto Go.\nI realized I was doing this\nwhen some Go contributors\nsent me private email to let me know.\nNow, when I am pressed for time,\nI pay extra attention to what I’m writing,\nand I often write more than I naturally would,\nto make sure\nI’m sending the message I intend.\u003c/p\u003e\n\u003cp\u003eI believe\nthat correcting the parts\nof our everyday interactions,\nintended or not,\nthat drive away potential users and contributors\nis one of the most important things\nwe can all do\nto make sure the Go community\ncontinues to grow.\nA good Code of Conduct can help us do that.\u003c/p\u003e\n\u003cp\u003eWe have no experience writing a Code of Conduct,\nso we have been reading existing ones,\nand we will probably adopt an existing one,\nperhaps with minor adjustments.\nThe one I like the most is the Django Code of Conduct,\nwhich originated with another project called SpeakUp!\nIt is structured as an elaboration of a list of\nreminders for everyday interaction.\u003c/p\u003e\n\u003cp\u003e“Be friendly and patient.\nBe welcoming.\nBe considerate.\nBe respectful.\nBe careful in the words that you choose.\nWhen we disagree, try to understand why.”\u003c/p\u003e\n\u003cp\u003eI believe this captures the tone we want to set,\nthe message we want to send,\nthe environment we want to create\nfor new contributors.\nI certainly want to be\nfriendly,\npatient,\nwelcoming,\nconsiderate,\nand respectful.\nI won’t get it exactly right all the time,\nand I would welcome a helpful note\nif I’m not living up to that.\nI believe most of us\nfeel the same way.\u003c/p\u003e\n\u003cp\u003eI haven’t mentioned\nactive exclusion based on\nor disproportionately affecting\nrace, gender, disability,\nor other personal characteristics,\nand I haven’t mentioned harassment.\nFor me,\nit follows from what I just said\nthat exclusionary behavior\nor explicit harassment\nis absolutely unacceptable,\nonline and offline.\nEvery Code of Conduct says this explicitly,\nand I expect that ours will too.\nBut I believe the SpeakUp! reminders\nabout everyday interactions\nare an equally important statement.\nI believe that\nsetting a high standard\nfor those everyday interactions\nmakes extreme behavior\nthat much clearer\nand easier to deal with.\u003c/p\u003e\n\u003cp\u003eI have no doubts that\nthe Go community can be\none of the most\nfriendly,\nwelcoming,\nconsiderate,\nand\nrespectful communities\nin the tech industry.\nWe can make that happen,\nand it will be\na benefit and credit to us all.\u003c/p\u003e\n\u003cp\u003eAndrew Gerrand\nhas been leading the effort\nto adopt an appropriate Code of Conduct\nfor the Go community.\nIf you have suggestions,\nor concerns,\nor experience with Codes of Conduct,\nor want to be involved,\nplease find Andrew or me\nduring the conference.\nIf you’ll still be here on Friday,\nAndrew and I are going to block off\nsome time for Code of Conduct discussions\nduring Hack Day.\u003c/p\u003e\n\u003cp\u003eAgain, we don’t know\nwhere the next great idea will come from.\nWe need all the help we can get.\nWe need a large, diverse Go community.\u003c/p\u003e\n\u003ch2 id=\"thank-you\"\u003eThank You\u003c/h2\u003e\n\u003cp\u003eI consider the many people\nreleasing software for download using “go get,”\nsharing their insights via blog posts,\nor helping others on the mailing lists or IRC\nto be part of this broad open source effort,\npart of the Go community.\nEveryone here today is also part of that community.\u003c/p\u003e\n\u003cp\u003eThank you in advance\nto the presenters\nwho over the next few days\nwill take time to share their experiences\nusing and extending Go.\u003c/p\u003e\n\u003cp\u003eThank you in advance\nto all of you in the audience\nfor taking the time to be here,\nto ask questions,\nand to let us know\nhow Go is working for you.\nWhen you go back home,\nplease continue to share what you’ve learned.\nEven if you don’t use Go\nfor daily work,\nwe’d love to see what’s working for Go\nadopted in other contexts,\njust as we’re always looking for good ideas\nto bring back into Go.\u003c/p\u003e\n\u003cp\u003eThank you all again\nfor making the effort to be here\nand for being part of the Go community.\u003c/p\u003e\n\u003cp\u003eFor the next few days, please:\ntell us what we’re doing right,\ntell us what we’re doing wrong,\nand help us all work together\nto make Go even better.\u003c/p\u003e\n\u003cp\u003eRemember to\nbe friendly,\npatient,\nwelcoming,\nconsiderate,\nand respectful.\u003c/p\u003e\n\u003cp\u003eAbove all, enjoy the conference.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2015-07-08T00:00:00Z",
  "Author": "Russ Cox"
}