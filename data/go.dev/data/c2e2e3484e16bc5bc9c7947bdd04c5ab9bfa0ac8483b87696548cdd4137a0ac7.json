{
  "Source": "go.dev",
  "Title": "Migrating to Go Modules",
  "Link": "https://go.dev/blog/migrating-to-go-modules",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/migrating-to-go-modules\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eMigrating to Go Modules\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jean de Klerk\u003cbr/\u003e\n      21 August 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis post is part 2 in a series.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePart 1 — \u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePart 2 — Migrating To Go Modules\u003c/strong\u003e (this post)\u003c/li\u003e\n\u003cli\u003ePart 3 — \u003ca href=\"/blog/publishing-go-modules\"\u003ePublishing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 4 — \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 5 — \u003ca href=\"/blog/module-compatibility\"\u003eKeeping Your Modules Compatible\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For documentation, see\n\u003ca href=\"/doc/modules/managing-dependencies\"\u003eManaging dependencies\u003c/a\u003e\nand \u003ca href=\"/doc/modules/developing\"\u003eDeveloping and publishing modules\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGo projects use a wide variety of dependency management strategies.\n\u003ca href=\"/cmd/go/#hdr-Vendor_Directories\"\u003eVendoring\u003c/a\u003e tools such\nas \u003ca href=\"https://github.com/golang/dep\" rel=\"noreferrer\" target=\"_blank\"\u003edep\u003c/a\u003e and \u003ca href=\"https://github.com/Masterminds/glide\" rel=\"noreferrer\" target=\"_blank\"\u003eglide\u003c/a\u003e are popular,\nbut they have wide differences in behavior and don’t always work well together.\nSome projects store their entire GOPATH directory in a single Git repository.\nOthers simply rely on \u003ccode\u003ego get\u003c/code\u003e and expect fairly recent versions of dependencies\nto be installed in GOPATH.\u003c/p\u003e\n\u003cp\u003eGo’s module system, introduced in Go 1.11,\nprovides an official dependency management solution built into the \u003ccode\u003ego\u003c/code\u003e command.\nThis article describes tools and techniques for converting a project to modules.\u003c/p\u003e\n\u003cp\u003ePlease note: if your project is already tagged at v2.0.0 or higher,\nyou will need to update your module path when you add a \u003ccode\u003ego.mod\u003c/code\u003e file.\nWe’ll explain how to do that without breaking your users in a future article\nfocused on v2 and beyond.\u003c/p\u003e\n\u003ch2 id=\"migrating-to-go-modules-in-your-project\"\u003eMigrating to Go modules in your project\u003c/h2\u003e\n\u003cp\u003eA project might be in one of three states when beginning the transition to Go modules:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA brand new Go project.\u003c/li\u003e\n\u003cli\u003eAn established Go project with a non-modules dependency manager.\u003c/li\u003e\n\u003cli\u003eAn established Go project without any dependency manager.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe first case is covered in \u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e;\nwe’ll address the latter two in this post.\u003c/p\u003e\n\u003ch2 id=\"with-a-dependency-manager\"\u003eWith a dependency manager\u003c/h2\u003e\n\u003cp\u003eTo convert a project that already uses a dependency management tool, run the following commands:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git clone https://github.com/my/project\n[...]\n$ cd project\n$ cat Godeps/Godeps.json\n{\n    \u0026#34;ImportPath\u0026#34;: \u0026#34;github.com/my/project\u0026#34;,\n    \u0026#34;GoVersion\u0026#34;: \u0026#34;go1.12\u0026#34;,\n    \u0026#34;GodepVersion\u0026#34;: \u0026#34;v80\u0026#34;,\n    \u0026#34;Deps\u0026#34;: [\n        {\n            \u0026#34;ImportPath\u0026#34;: \u0026#34;rsc.io/binaryregexp\u0026#34;,\n            \u0026#34;Comment\u0026#34;: \u0026#34;v0.2.0-1-g545cabd\u0026#34;,\n            \u0026#34;Rev\u0026#34;: \u0026#34;545cabda89ca36b48b8e681a30d9d769a30b3074\u0026#34;\n        },\n        {\n            \u0026#34;ImportPath\u0026#34;: \u0026#34;rsc.io/binaryregexp/syntax\u0026#34;,\n            \u0026#34;Comment\u0026#34;: \u0026#34;v0.2.0-1-g545cabd\u0026#34;,\n            \u0026#34;Rev\u0026#34;: \u0026#34;545cabda89ca36b48b8e681a30d9d769a30b3074\u0026#34;\n        }\n    ]\n}\n$ go mod init github.com/my/project\ngo: creating new go.mod: module github.com/my/project\ngo: copying requirements from Godeps/Godeps.json\n$ cat go.mod\nmodule github.com/my/project\n\ngo 1.12\n\nrequire rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ego mod init\u003c/code\u003e creates a new go.mod file and automatically imports dependencies from \u003ccode\u003eGodeps.json\u003c/code\u003e,\n\u003ccode\u003eGopkg.lock\u003c/code\u003e, or a number of \u003ca href=\"https://go.googlesource.com/go/+/362625209b6cd2bc059b6b0a67712ddebab312d9/src/cmd/go/internal/modconv/modconv.go#9\" rel=\"noreferrer\" target=\"_blank\"\u003eother supported formats\u003c/a\u003e.\nThe argument to \u003ccode\u003ego mod init\u003c/code\u003e is the module path,\nthe location where the module may be found.\u003c/p\u003e\n\u003cp\u003eThis is a good time to pause and run \u003ccode\u003ego build ./...\u003c/code\u003e and \u003ccode\u003ego test ./...\u003c/code\u003e before continuing.\nLater steps may modify your \u003ccode\u003ego.mod\u003c/code\u003e file,\nso if you prefer to take an iterative approach,\nthis is the closest your \u003ccode\u003ego.mod\u003c/code\u003e file will be to your pre-modules dependency specification.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod tidy\ngo: downloading rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca\ngo: extracting rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca\n$ cat go.sum\nrsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca h1:FKXXXJ6G2bFoVe7hX3kEX6Izxw5ZKRH57DFBJmHCbkU=\nrsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ego mod tidy\u003c/code\u003e finds all the packages transitively imported by packages in your module.\nIt adds new module requirements for packages not provided by any known module,\nand it removes requirements on modules that don’t provide any imported packages.\nIf a module provides packages that are only imported by projects that haven’t\nmigrated to modules yet,\nthe module requirement will be marked with an \u003ccode\u003e// indirect\u003c/code\u003e comment.\nIt is always good practice to run \u003ccode\u003ego mod tidy\u003c/code\u003e before committing a \u003ccode\u003ego.mod\u003c/code\u003e\nfile to version control.\u003c/p\u003e\n\u003cp\u003eLet’s finish by making sure the code builds and tests pass:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go build ./...\n$ go test ./...\n[...]\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that other dependency managers may specify dependencies at the level\nof individual packages or entire repositories (not modules),\nand generally do not recognize the requirements specified in the \u003ccode\u003ego.mod\u003c/code\u003e\nfiles of dependencies.\nConsequently, you may not get exactly the same version of every package as before,\nand there’s some risk of upgrading past breaking changes.\nTherefore, it’s important to follow the above commands with an audit of\nthe resulting dependencies. To do so, run\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go list -m all\ngo: finding rsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca\ngithub.com/my/project\nrsc.io/binaryregexp v0.2.1-0.20190524193500-545cabda89ca\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand compare the resulting versions with your old dependency management file\nto ensure that the selected versions are appropriate.\nIf you find a version that wasn’t what you wanted,\nyou can find out why using \u003ccode\u003ego mod why -m\u003c/code\u003e and/or \u003ccode\u003ego mod graph\u003c/code\u003e,\nand upgrade or downgrade to the correct version using \u003ccode\u003ego get\u003c/code\u003e.\n(If the version you request is older than the version that was previously selected,\n\u003ccode\u003ego get\u003c/code\u003e will downgrade other dependencies as needed to maintain compatibility.) For example,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod why -m rsc.io/binaryregexp\n[...]\n$ go mod graph | grep rsc.io/binaryregexp\n[...]\n$ go get rsc.io/binaryregexp@v0.2.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"without-a-dependency-manager\"\u003eWithout a dependency manager\u003c/h2\u003e\n\u003cp\u003eFor a Go project without a dependency management system, start by creating a \u003ccode\u003ego.mod\u003c/code\u003e file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git clone https://go.googlesource.com/blog\n[...]\n$ cd blog\n$ go mod init golang.org/x/blog\ngo: creating new go.mod: module golang.org/x/blog\n$ cat go.mod\nmodule golang.org/x/blog\n\ngo 1.12\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout a configuration file from a previous dependency manager,\n\u003ccode\u003ego mod init\u003c/code\u003e will create a \u003ccode\u003ego.mod\u003c/code\u003e file with only the \u003ccode\u003emodule\u003c/code\u003e and \u003ccode\u003ego\u003c/code\u003e directives.\nIn this example, we set the module path to \u003ccode\u003egolang.org/x/blog\u003c/code\u003e because that\nis its \u003ca href=\"/cmd/go/#hdr-Remote_import_paths\"\u003ecustom import path\u003c/a\u003e.\nUsers may import packages with this path,\nand we must be careful not to change it.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003emodule\u003c/code\u003e directive declares the module path,\nand the \u003ccode\u003ego\u003c/code\u003e directive declares the expected version of the Go language\nused to compile the code within the module.\u003c/p\u003e\n\u003cp\u003eNext, run \u003ccode\u003ego mod tidy\u003c/code\u003e to add the module’s dependencies:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod tidy\ngo: finding golang.org/x/website latest\ngo: finding gopkg.in/tomb.v2 latest\ngo: finding golang.org/x/net latest\ngo: finding golang.org/x/tools latest\ngo: downloading github.com/gorilla/context v1.1.1\ngo: downloading golang.org/x/tools v0.0.0-20190813214729-9dba7caff850\ngo: downloading golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7\ngo: extracting github.com/gorilla/context v1.1.1\ngo: extracting golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7\ngo: downloading gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637\ngo: extracting gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637\ngo: extracting golang.org/x/tools v0.0.0-20190813214729-9dba7caff850\ngo: downloading golang.org/x/website v0.0.0-20190809153340-86a7442ada7c\ngo: extracting golang.org/x/website v0.0.0-20190809153340-86a7442ada7c\n$ cat go.mod\nmodule golang.org/x/blog\n\ngo 1.12\n\nrequire (\n    github.com/gorilla/context v1.1.1\n    golang.org/x/net v0.0.0-20190813141303-74dc4d7220e7\n    golang.org/x/text v0.3.2\n    golang.org/x/tools v0.0.0-20190813214729-9dba7caff850\n    golang.org/x/website v0.0.0-20190809153340-86a7442ada7c\n    gopkg.in/tomb.v2 v2.0.0-20161208151619-d5d1b5820637\n)\n$ cat go.sum\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ngit.apache.org/thrift.git v0.0.0-20180902110319-2566ecd5d999/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=\ngit.apache.org/thrift.git v0.0.0-20181218151757-9b75e4fe745a/go.mod h1:fPE2ZNJGynbRyZ4dJvy6G277gSllfV2HJqblrnkyeyg=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\n[...]\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ego mod tidy\u003c/code\u003e added module requirements for all the packages transitively\nimported by packages in your module and built a \u003ccode\u003ego.sum\u003c/code\u003e with checksums\nfor each library at a specific version.\nLet’s finish by making sure the code still builds and tests still pass:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go build ./...\n$ go test ./...\nok      golang.org/x/blog   0.335s\n?       golang.org/x/blog/content/appengine [no test files]\nok      golang.org/x/blog/content/cover 0.040s\n?       golang.org/x/blog/content/h2push/server [no test files]\n?       golang.org/x/blog/content/survey2016    [no test files]\n?       golang.org/x/blog/content/survey2017    [no test files]\n?       golang.org/x/blog/support/racy  [no test files]\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that when \u003ccode\u003ego mod tidy\u003c/code\u003e adds a requirement,\nit adds the latest version of the module.\nIf your \u003ccode\u003eGOPATH\u003c/code\u003e included an older version of a dependency that subsequently\npublished a breaking change,\nyou may see errors in \u003ccode\u003ego mod tidy\u003c/code\u003e, \u003ccode\u003ego build\u003c/code\u003e, or \u003ccode\u003ego test\u003c/code\u003e.\nIf this happens, try downgrading to an older version with \u003ccode\u003ego get\u003c/code\u003e (for example,\n\u003ccode\u003ego get github.com/broken/module@v1.1.0\u003c/code\u003e),\nor take the time to make your module compatible with the latest version of each dependency.\u003c/p\u003e\n\u003ch3 id=\"tests-in-module-mode\"\u003eTests in module mode\u003c/h3\u003e\n\u003cp\u003eSome tests may need tweaks after migrating to Go modules.\u003c/p\u003e\n\u003cp\u003eIf a test needs to write files in the package directory,\nit may fail when the package directory is in the module cache, which is read-only.\nIn particular, this may cause \u003ccode\u003ego test all\u003c/code\u003e to fail.\nThe test should copy files it needs to write to a temporary directory instead.\u003c/p\u003e\n\u003cp\u003eIf a test relies on relative paths (\u003ccode\u003e../package-in-another-module\u003c/code\u003e) to locate\nand read files in another package,\nit will fail if the package is in another module,\nwhich will be located in a versioned subdirectory of the module cache or\na path specified in a \u003ccode\u003ereplace\u003c/code\u003e directive.\nIf this is the case, you may need to copy the test inputs into your module,\nor convert the test inputs from raw files to data embedded in \u003ccode\u003e.go\u003c/code\u003e source files.\u003c/p\u003e\n\u003cp\u003eIf a test expects \u003ccode\u003ego\u003c/code\u003e commands within the test to run in GOPATH mode, it may fail.\nIf this is the case, you may need to add a \u003ccode\u003ego.mod\u003c/code\u003e file to the source tree to be tested,\nor set \u003ccode\u003eGO111MODULE=off\u003c/code\u003e explicitly.\u003c/p\u003e\n\u003ch2 id=\"publishing-a-release\"\u003ePublishing a release\u003c/h2\u003e\n\u003cp\u003eFinally, you should tag and publish a release version for your new module.\nThis is optional if you haven’t released any versions yet,\nbut without an official release, downstream users will depend on specific\ncommits using \u003ca href=\"/cmd/go/#hdr-Pseudo_versions\"\u003epseudo-versions\u003c/a\u003e,\nwhich may be more difficult to support.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git tag v1.2.0\n$ git push origin v1.2.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYour new \u003ccode\u003ego.mod\u003c/code\u003e file defines a canonical import path for your module and adds\nnew minimum version requirements. If your users are already using the correct\nimport path, and your dependencies haven’t made breaking changes, then adding\nthe \u003ccode\u003ego.mod\u003c/code\u003e file is backwards-compatible — but it’s a significant change, and\nmay expose existing problems. If you have existing version tags, you should\nincrement the \u003ca href=\"https://semver.org/#spec-item-7\" rel=\"noreferrer\" target=\"_blank\"\u003eminor version\u003c/a\u003e. See\n\u003ca href=\"/blog/publishing-go-modules\"\u003ePublishing Go Modules\u003c/a\u003e to learn how to increment and\npublish versions.\u003c/p\u003e\n\u003ch2 id=\"imports-and-canonical-module-paths\"\u003eImports and canonical module paths\u003c/h2\u003e\n\u003cp\u003eEach module declares its module path in its \u003ccode\u003ego.mod\u003c/code\u003e file.\nEach \u003ccode\u003eimport\u003c/code\u003e statement that refers to a package within the module must\nhave the module path as a prefix of the package path.\nHowever, the \u003ccode\u003ego\u003c/code\u003e command may encounter a repository containing the module\nthrough many different \u003ca href=\"/cmd/go/#hdr-Remote_import_paths\"\u003eremote import paths\u003c/a\u003e.\nFor example, both \u003ccode\u003egolang.org/x/lint\u003c/code\u003e and \u003ccode\u003egithub.com/golang/lint\u003c/code\u003e resolve\nto repositories containing the code hosted at \u003ca href=\"https://go.googlesource.com/lint\" rel=\"noreferrer\" target=\"_blank\"\u003ego.googlesource.com/lint\u003c/a\u003e.\nThe \u003ca href=\"https://go.googlesource.com/lint/+/refs/heads/master/go.mod\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003ego.mod\u003c/code\u003e file\u003c/a\u003e\ncontained in that repository declares its path to be \u003ccode\u003egolang.org/x/lint\u003c/code\u003e,\nso only that path corresponds to a valid module.\u003c/p\u003e\n\u003cp\u003eGo 1.4 provided a mechanism for declaring canonical import paths using \u003ca href=\"/cmd/go/#hdr-Import_path_checking\"\u003e\u003ccode\u003e// import\u003c/code\u003e comments\u003c/a\u003e,\nbut package authors did not always provide them.\nAs a result, code written prior to modules may have used a non-canonical\nimport path for a module without surfacing an error for the mismatch.\nWhen using modules, the import path must match the canonical module path,\nso you may need to update \u003ccode\u003eimport\u003c/code\u003e statements:\nfor example, you may need to change \u003ccode\u003eimport \u0026#34;github.com/golang/lint\u0026#34;\u003c/code\u003e to\n\u003ccode\u003eimport \u0026#34;golang.org/x/lint\u0026#34;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnother scenario in which a module’s canonical path may differ from its\nrepository path occurs for Go modules at major version 2 or higher.\nA Go module with a major version above 1 must include a major-version suffix in its module path:\nfor example, version \u003ccode\u003ev2.0.0\u003c/code\u003e must have the suffix \u003ccode\u003e/v2\u003c/code\u003e.\nHowever, \u003ccode\u003eimport\u003c/code\u003e statements may have referred to the packages within the\nmodule \u003cem\u003ewithout\u003c/em\u003e that suffix.\nFor example, non-module users of \u003ccode\u003egithub.com/russross/blackfriday/v2\u003c/code\u003e at\n\u003ccode\u003ev2.0.1\u003c/code\u003e may have imported it as \u003ccode\u003egithub.com/russross/blackfriday\u003c/code\u003e instead,\nand will need to update the import path to include the \u003ccode\u003e/v2\u003c/code\u003e suffix.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eConverting to Go modules should be a straightforward process for most users.\nOccasional issues may arise due to non-canonical import paths or breaking\nchanges within a dependency.\nFuture posts will explore \u003ca href=\"/blog/publishing-go-modules\"\u003epublishing new versions\u003c/a\u003e,\nv2 and beyond, and ways to debug strange situations.\u003c/p\u003e\n\u003cp\u003eTo provide feedback and help shape the future of dependency management in Go,\nplease send us \u003ca href=\"/issue/new\"\u003ebug reports\u003c/a\u003e or \u003ca href=\"/wiki/ExperienceReports\"\u003eexperience reports\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThanks for all your feedback and help improving modules.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-08-21T00:00:00Z",
  "Author": "Jean de Klerk"
}