{
  "Source": "go.dev",
  "Title": "Routing Enhancements for Go 1.22",
  "Link": "https://go.dev/blog/routing-enhancements",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/routing-enhancements\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eRouting Enhancements for Go 1.22\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jonathan Amsterdam, on behalf of the Go team\u003cbr/\u003e\n      13 February 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eGo 1.22 brings two enhancements to the \u003ccode\u003enet/http\u003c/code\u003e package’s router: method\nmatching and wildcards. These features let you express common routes as\npatterns instead of Go code. Although they are simple to explain and use,\nit was a challenge to come up with the right rules for selecting the winning\npattern when several match a request.\u003c/p\u003e\n\u003cp\u003eWe made these changes as part of our continuing effort to make Go a great\nlanguage for building production systems. We studied many third-party web\nframeworks, extracted what we felt were the most used features, and integrated\nthem into \u003ccode\u003enet/http\u003c/code\u003e. Then we validated our choices and improved our design by\ncollaborating with the community in a \u003ca href=\"https://github.com/golang/go/discussions/60227\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub discussion\u003c/a\u003e and a \u003ca href=\"/issue/61410\"\u003eproposal issue\u003c/a\u003e.\nAdding these features to the standard library means one fewer dependency for\nmany projects. But third-party web frameworks remain a fine choice for current\nusers or programs with advanced routing needs.\u003c/p\u003e\n\u003ch2 id=\"enhancements\"\u003eEnhancements\u003c/h2\u003e\n\u003cp\u003eThe new routing features almost exclusively affect the pattern string passed\nto the two \u003ccode\u003enet/http.ServeMux\u003c/code\u003e methods \u003ccode\u003eHandle\u003c/code\u003e and \u003ccode\u003eHandleFunc\u003c/code\u003e, and the\ncorresponding top-level functions \u003ccode\u003ehttp.Handle\u003c/code\u003e and \u003ccode\u003ehttp.HandleFunc\u003c/code\u003e. The only\nAPI changes are two new methods on \u003ccode\u003enet/http.Request\u003c/code\u003e for working with wildcard\nmatches.\u003c/p\u003e\n\u003cp\u003eWe’ll illustrate the changes with a hypothetical blog server in which every post\nhas an integer identifier. A request like \u003ccode\u003eGET /posts/234\u003c/code\u003e retrieves the post with\nID 234. Before Go 1.22, the code for handling those requests would start with a\nline like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp.Handle(\u0026#34;/posts/\u0026#34;, handlePost)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe trailing slash routes all requests beginning \u003ccode\u003e/posts/\u003c/code\u003e to the \u003ccode\u003ehandlePost\u003c/code\u003e\nfunction, which would have to check that the HTTP method was GET, extract\nthe identifier, and retrieve the post. Since the method check isn’t strictly\nnecessary to satisfy the request, it would be a natural mistake to omit it. That\nwould mean that a request like \u003ccode\u003eDELETE /posts/234\u003c/code\u003e would fetch the post, which\nis surprising at the least.\u003c/p\u003e\n\u003cp\u003eIn Go 1.22, the existing code will continue to work, or you could instead write this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehttp.Handle(\u0026#34;GET /posts/{id}\u0026#34;, handlePost2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis pattern matches a GET request whose path begins “/posts/” and has two\nsegments. (As a special case, GET also matches HEAD; all the other methods match\nexactly.) The \u003ccode\u003ehandlePost2\u003c/code\u003e function no longer needs to check the method, and\nextracting the identifier string can be written using the new \u003ccode\u003ePathValue\u003c/code\u003e method\non \u003ccode\u003eRequest\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eidString := req.PathValue(\u0026#34;id\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe rest of \u003ccode\u003ehandlePost2\u003c/code\u003e would behave like \u003ccode\u003ehandlePost\u003c/code\u003e, converting the string\nidentifier to an integer and fetching the post.\u003c/p\u003e\n\u003cp\u003eRequests like \u003ccode\u003eDELETE /posts/234\u003c/code\u003e will fail if no other matching pattern is\nregistered. In accordance with \u003ca href=\"https://httpwg.org/specs/rfc9110.html#status.405\" rel=\"noreferrer\" target=\"_blank\"\u003eHTTP semantics\u003c/a\u003e, a \u003ccode\u003enet/http\u003c/code\u003e server will reply\nto such a request with a \u003ccode\u003e405 Method Not Allowed\u003c/code\u003e error that lists the available methods\nin an \u003ccode\u003eAllow\u003c/code\u003e header.\u003c/p\u003e\n\u003cp\u003eA wildcard can match an entire segment, like \u003ccode\u003e{id}\u003c/code\u003e in the example above, or if\nit ends in \u003ccode\u003e...\u003c/code\u003e it can match all the remaining segments of the path, as in the\npattern \u003ccode\u003e/files/{pathname...}\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThere is one last bit of syntax. As we showed above, patterns ending in a slash,\nlike \u003ccode\u003e/posts/\u003c/code\u003e, match all paths beginning with that string. To match only the\npath with the trailing slash, you can write \u003ccode\u003e/posts/{$}\u003c/code\u003e. That will match\n\u003ccode\u003e/posts/\u003c/code\u003e but not \u003ccode\u003e/posts\u003c/code\u003e or \u003ccode\u003e/posts/234\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eAnd there is one last bit of API: \u003ccode\u003enet/http.Request\u003c/code\u003e has a \u003ccode\u003eSetPathValue\u003c/code\u003e method\nso that routers outside the standard library can make the results of their own\npath parsing available via \u003ccode\u003eRequest.PathValue\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"precedence\"\u003ePrecedence\u003c/h2\u003e\n\u003cp\u003eEvery HTTP router must deal with overlapping patterns, like \u003ccode\u003e/posts/{id}\u003c/code\u003e and\n\u003ccode\u003e/posts/latest\u003c/code\u003e. Both of these patterns match the path “posts/latest”, but at most\none can serve the request. Which pattern takes precedence?\u003c/p\u003e\n\u003cp\u003eSome routers disallow overlaps; others use the pattern that was registered last.\nGo has always allowed overlaps, and has chosen the longer pattern regardless\nof registration order. Preserving order-independence was important to us (and\nnecessary for backwards compatibility), but we needed a better rule than\n“longest wins.” That rule would select \u003ccode\u003e/posts/latest\u003c/code\u003e over \u003ccode\u003e/posts/{id}\u003c/code\u003e, but\nwould choose \u003ccode\u003e/posts/{identifier}\u003c/code\u003e over both. That seems wrong: the wildcard\nname shouldn’t matter. It feels like \u003ccode\u003e/posts/latest\u003c/code\u003e should always win this\ncompetition, because it matches a single path instead of many.\u003c/p\u003e\n\u003cp\u003eOur quest for a good precedence rule led us to consider many properties of\npatterns. For example, we considered preferring the pattern with the longest\nliteral (non-wildcard) prefix. That would choose \u003ccode\u003e/posts/latest\u003c/code\u003e over \u003ccode\u003e/posts/ {id}\u003c/code\u003e. But it wouldn’t distinguish between \u003ccode\u003e/users/{u}/posts/latest\u003c/code\u003e and\n\u003ccode\u003e/users/{u}/posts/{id}\u003c/code\u003e, and it seems like the former should take precedence.\u003c/p\u003e\n\u003cp\u003eWe eventually chose a rule based on what the patterns mean instead of how they\nlook. Every valid pattern matches a set of requests. For example,\n\u003ccode\u003e/posts/latest\u003c/code\u003e matches requests with the path \u003ccode\u003e/posts/latest\u003c/code\u003e, while \u003ccode\u003e/posts/{id}\u003c/code\u003e\nmatches requests with any two-segment path whose first segment is “posts”. We\nsay that one pattern is \u003cem\u003emore specific\u003c/em\u003e than another if it matches a strict subset\nof requests. The pattern \u003ccode\u003e/posts/latest\u003c/code\u003e is more specific than \u003ccode\u003e/posts/{id}\u003c/code\u003e\nbecause the latter matches every request that the former does, and more.\u003c/p\u003e\n\u003cp\u003eThe precedence rule is simple: the most specific pattern wins. This rule\nmatches our intuition that \u003ccode\u003eposts/latests\u003c/code\u003e should be preferred to \u003ccode\u003eposts/{id}\u003c/code\u003e,\nand \u003ccode\u003e/users/{u}/posts/latest\u003c/code\u003e should be preferred to \u003ccode\u003e/users/{u}/posts/{id}\u003c/code\u003e.\nIt also makes sense for methods. For example, \u003ccode\u003eGET /posts/{id}\u003c/code\u003e takes\nprecedence over \u003ccode\u003e/posts/{id}\u003c/code\u003e because the first only matches GET and HEAD\nrequests, while the second matches requests with any method.\u003c/p\u003e\n\u003cp\u003eThe “most specific wins” rule generalizes the original “longest wins” rule for\nthe path parts of original patterns, those without wildcards or \u003ccode\u003e{$}\u003c/code\u003e. Such\npatterns only overlap when one is a prefix of the other, and the longer is the\nmore specific.\u003c/p\u003e\n\u003cp\u003eWhat if two patterns overlap but neither is more specific? For example, \u003ccode\u003e/posts/{id}\u003c/code\u003e\nand \u003ccode\u003e/{resource}/latest\u003c/code\u003e both match \u003ccode\u003e/posts/latest\u003c/code\u003e. There is no obvious answer to\nwhich takes precedence, so we consider these patterns to conflict with each other.\nRegistering both of them (in either order!) will panic.\u003c/p\u003e\n\u003cp\u003eThe precedence rule works exactly as above for methods and paths, but we had to\nmake one exception for hosts to preserve compatibility: if two patterns would\notherwise conflict and one has a host while the other does not, then the pattern\nwith the host takes precedence.\u003c/p\u003e\n\u003cp\u003eStudents of computer science may recall the beautiful theory of regular\nexpressions and regular languages. Each regular expression picks out a regular\nlanguage, the set of strings matched by the expression. Some questions are\neasier to pose and answer by talking about languages rather than expressions.\nOur precedence rule was inspired by this theory. Indeed, each routing pattern\ncorresponds to a regular expression, and sets of matching requests play the role of\nregular languages.\u003c/p\u003e\n\u003cp\u003eDefining precedence by languages instead of expressions makes it easy to state\nand understand. But there is a downside to having a rule based on potentially\ninfinite sets: it isn’t clear how to implement it efficiently. It turns out we\ncan determine whether two patterns conflict by walking them segment by segment.\nRoughly speaking, if one pattern has a literal segment wherever the other has a\nwildcard, it is more specific; but if literals align with wildcards in both\ndirections, the patterns conflict.\u003c/p\u003e\n\u003cp\u003eAs new patterns are registered on a \u003ccode\u003eServeMux\u003c/code\u003e, it checks for conflicts with previously\nregistered patterns. But checking every pair of patterns would take quadratic\ntime. We use an index to skip patterns that cannot conflict with a new pattern;\nin practice, it works quite well. In any case, this check happens when\npatterns are registered, usually at server startup. The time to match incoming\nrequests in Go 1.22 hasn’t changed much from previous versions.\u003c/p\u003e\n\u003ch2 id=\"compatibility\"\u003eCompatibility\u003c/h2\u003e\n\u003cp\u003eWe made every effort to keep the new functionality compatible with older\nversions of Go. The new pattern syntax is a superset of the old, and the new\nprecedence rule generalizes the old one. But there are a few edge cases. For\nexample, previous versions of Go accepted patterns with braces and treated\nthem literally, but Go 1.22 uses braces for wildcards. The GODEBUG setting\n\u003ccode\u003ehttpmuxgo121\u003c/code\u003e restores the old behavior.\u003c/p\u003e\n\u003cp\u003eFor more details about these routing enhancements, see the \u003ca href=\"/pkg/net/http#ServeMux\"\u003e\u003ccode\u003enet/http.ServeMux\u003c/code\u003e\ndocumentation\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-02-13T00:00:00Z",
  "Author": "Jonathan Amsterdam, on behalf of the Go team"
}