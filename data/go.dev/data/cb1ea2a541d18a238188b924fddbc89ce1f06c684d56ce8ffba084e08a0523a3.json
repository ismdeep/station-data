{
  "Source": "go.dev",
  "Title": "Generating code",
  "Link": "https://go.dev/blog/generate",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/generate\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGenerating code\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      22 December 2014\n      \u003c/p\u003e\n      \n      \u003cp\u003eA property of universal computation—Turing completeness—is that a computer program can write a computer program.\nThis is a powerful idea that is not appreciated as often as it might be, even though it happens frequently.\nIt’s a big part of the definition of a compiler, for instance.\nIt’s also how the \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003etest\u003c/code\u003e command works: it scans the packages to be tested,\nwrites out a Go program containing a test harness customized for the package,\nand then compiles and runs it.\nModern computers are so fast this expensive-sounding sequence can complete in a fraction of a second.\u003c/p\u003e\n\u003cp\u003eThere are lots of other examples of programs that write programs.\n\u003ca href=\"https://godoc.org/golang.org/x/tools/cmd/goyacc\" rel=\"noreferrer\" target=\"_blank\"\u003eYacc\u003c/a\u003e, for instance, reads in a description of a grammar and writes out a program to parse that grammar.\nThe protocol buffer “compiler” reads an interface description and emits structure definitions,\nmethods, and other support code.\nConfiguration tools of all sorts work like this too, examining metadata or the environment\nand emitting scaffolding customized to the local state.\u003c/p\u003e\n\u003cp\u003ePrograms that write programs are therefore important elements in software engineering,\nbut programs like Yacc that produce source code need to be integrated into the build\nprocess so their output can be compiled.\nWhen an external build tool like Make is being used, this is usually easy to do.\nBut in Go, whose go tool gets all necessary build information from the Go source, there is a problem.\nThere is simply no mechanism to run Yacc from the go tool alone.\u003c/p\u003e\n\u003cp\u003eUntil now, that is.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/blog/go1.4\"\u003elatest Go release\u003c/a\u003e, 1.4,\nincludes a new command that makes it easier to run such tools.\nIt’s called \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e, and it works by scanning for special comments in Go source code\nthat identify general commands to run.\nIt’s important to understand that \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e is not part of \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003ebuild\u003c/code\u003e.\nIt contains no dependency analysis and must be run explicitly before running \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003ebuild\u003c/code\u003e.\nIt is intended to be used by the author of the Go package, not its clients.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e command is easy to use.\nAs a warmup, here’s how to use it to generate a Yacc grammar.\u003c/p\u003e\n\u003cp\u003eFirst, install Go’s Yacc tool:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego get golang.org/x/tools/cmd/goyacc\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSay you have a Yacc input file called \u003ccode\u003egopher.y\u003c/code\u003e that defines a grammar for your new language.\nTo produce the Go source file implementing the grammar,\nyou would normally invoke the command like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egoyacc -o gopher.go -p parser gopher.y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003e-o\u003c/code\u003e option names the output file while \u003ccode\u003e-p\u003c/code\u003e specifies the package name.\u003c/p\u003e\n\u003cp\u003eTo have \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e drive the process, in any one of the regular (non-generated) \u003ccode\u003e.go\u003c/code\u003e files\nin the same directory, add this comment anywhere in the file:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//go:generate goyacc -o gopher.go -p parser gopher.y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis text is just the command above prefixed by a special comment recognized by \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e.\nThe comment must start at the beginning of the line and have no spaces between the \u003ccode\u003e//\u003c/code\u003e and the \u003ccode\u003ego:generate\u003c/code\u003e.\nAfter that marker, the rest of the line specifies a command for \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e to run.\u003c/p\u003e\n\u003cp\u003eNow run it. Change to the source directory and run \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e, then \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003ebuild\u003c/code\u003e and so on:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cd $GOPATH/myrepo/gopher\n$ go generate\n$ go build\n$ go test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s it.\nAssuming there are no errors, the \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e command will invoke \u003ccode\u003eyacc\u003c/code\u003e to create \u003ccode\u003egopher.go\u003c/code\u003e,\nat which point the directory holds the full set of Go source files, so we can build, test, and work normally.\nEvery time \u003ccode\u003egopher.y\u003c/code\u003e is modified, just rerun \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e to regenerate the parser.\u003c/p\u003e\n\u003cp\u003eFor more details about how \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e works, including options, environment variables,\nand so on, see the \u003ca href=\"/s/go1.4-generate\"\u003edesign document\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eGo generate does nothing that couldn’t be done with Make or some other build mechanism,\nbut it comes with the \u003ccode\u003ego\u003c/code\u003e tool—no extra installation required—and fits nicely into the Go ecosystem.\nJust keep in mind that it is for package authors, not clients,\nif only for the reason that the program it invokes might not be available on the target machine.\nAlso, if the containing package is intended for import by \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003eget\u003c/code\u003e,\nonce the file is generated (and tested!) it must be checked into the\nsource code repository to be available to clients.\u003c/p\u003e\n\u003cp\u003eNow that we have it, let’s use it for something new.\nAs a very different example of how \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e can help, there is a new program available in the\n\u003ccode\u003egolang.org/x/tools\u003c/code\u003e repository called \u003ccode\u003estringer\u003c/code\u003e.\nIt automatically writes string methods for sets of integer constants.\nIt’s not part of the released distribution, but it’s easy to install:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go get golang.org/x/tools/cmd/stringer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s an example from the documentation for\n\u003ca href=\"https://godoc.org/golang.org/x/tools/cmd/stringer\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003estringer\u003c/code\u003e\u003c/a\u003e.\nImagine we have some code that contains a set of integer constants defining different types of pills:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage painkiller\n\ntype Pill int\n\nconst (\n    Placebo Pill = iota\n    Aspirin\n    Ibuprofen\n    Paracetamol\n    Acetaminophen = Paracetamol\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor debugging, we’d like these constants to pretty-print themselves, which means we want a method with signature,\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (p Pill) String() string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt’s easy to write one by hand, perhaps like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (p Pill) String() string {\n    switch p {\n    case Placebo:\n        return \u0026#34;Placebo\u0026#34;\n    case Aspirin:\n        return \u0026#34;Aspirin\u0026#34;\n    case Ibuprofen:\n        return \u0026#34;Ibuprofen\u0026#34;\n    case Paracetamol: // == Acetaminophen\n        return \u0026#34;Paracetamol\u0026#34;\n    }\n    return fmt.Sprintf(\u0026#34;Pill(%d)\u0026#34;, p)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere are other ways to write this function, of course.\nWe could use a slice of strings indexed by Pill, or a map, or some other technique.\nWhatever we do, we need to maintain it if we change the set of pills, and we need to make sure it’s correct.\n(The two names for paracetamol make this trickier than it might otherwise be.)\nPlus the very question of which approach to take depends on the types and values:\nsigned or unsigned, dense or sparse, zero-based or not, and so on.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003estringer\u003c/code\u003e program takes care of all these details.\nAlthough it can be run in isolation, it is intended to be driven by \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e.\nTo use it, add a generate comment to the source, perhaps near the type definition:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e//go:generate stringer -type=Pill\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis rule specifies that \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e should run the \u003ccode\u003estringer\u003c/code\u003e tool to generate a \u003ccode\u003eString\u003c/code\u003e method for type \u003ccode\u003ePill\u003c/code\u003e.\nThe output is automatically written to \u003ccode\u003epill_string.go\u003c/code\u003e (a default we could override with the\n\u003ccode\u003e-output\u003c/code\u003e flag).\u003c/p\u003e\n\u003cp\u003eLet’s run it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go generate\n$ cat pill_string.go\n// Code generated by stringer -type Pill pill.go; DO NOT EDIT.\n\npackage painkiller\n\nimport \u0026#34;fmt\u0026#34;\n\nconst _Pill_name = \u0026#34;PlaceboAspirinIbuprofenParacetamol\u0026#34;\n\nvar _Pill_index = [...]uint8{0, 7, 14, 23, 34}\n\nfunc (i Pill) String() string {\n    if i \u0026lt; 0 || i+1 \u0026gt;= Pill(len(_Pill_index)) {\n        return fmt.Sprintf(\u0026#34;Pill(%d)\u0026#34;, i)\n    }\n    return _Pill_name[_Pill_index[i]:_Pill_index[i+1]]\n}\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEvery time we change the definition of \u003ccode\u003ePill\u003c/code\u003e or the constants, all we need to do is run\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go generate\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eto update the \u003ccode\u003eString\u003c/code\u003e method.\nAnd of course if we’ve got multiple types set up this way in the same package,\nthat single command will update all their \u003ccode\u003eString\u003c/code\u003e methods with a single command.\u003c/p\u003e\n\u003cp\u003eThere’s no question the generated method is ugly.\nThat’s OK, though, because humans don’t need to work on it; machine-generated code is often ugly.\nIt’s working hard to be efficient.\nAll the names are smashed together into a single string,\nwhich saves memory (only one string header for all the names, even if there are zillions of them).\nThen an array, \u003ccode\u003e_Pill_index\u003c/code\u003e, maps from value to name by a simple, efficient technique.\nNote too that \u003ccode\u003e_Pill_index\u003c/code\u003e is an array (not a slice; one more header eliminated) of \u003ccode\u003euint8\u003c/code\u003e,\nthe smallest integer sufficient to span the space of values.\nIf there were more values, or there were negatives ones,\nthe generated type of \u003ccode\u003e_Pill_index\u003c/code\u003e might change to \u003ccode\u003euint16\u003c/code\u003e or \u003ccode\u003eint8\u003c/code\u003e: whatever works best.\u003c/p\u003e\n\u003cp\u003eThe approach used by the methods printed by \u003ccode\u003estringer\u003c/code\u003e varies according to the properties of the constant set.\nFor instance, if the constants are sparse, it might use a map.\nHere’s a trivial example based on a constant set representing powers of two:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst _Power_name = \u0026#34;p0p1p2p3p4p5...\u0026#34;\n\nvar _Power_map = map[Power]string{\n    1:    _Power_name[0:2],\n    2:    _Power_name[2:4],\n    4:    _Power_name[4:6],\n    8:    _Power_name[6:8],\n    16:   _Power_name[8:10],\n    32:   _Power_name[10:12],\n    ...,\n}\n\nfunc (i Power) String() string {\n    if str, ok := _Power_map[i]; ok {\n        return str\n    }\n    return fmt.Sprintf(\u0026#34;Power(%d)\u0026#34;, i)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn short, generating the method automatically allows us to do a better job than we would expect a human to do.\u003c/p\u003e\n\u003cp\u003eThere are lots of other uses of \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e already installed in the Go tree.\nExamples include generating Unicode tables in the \u003ccode\u003eunicode\u003c/code\u003e package,\ncreating efficient methods for encoding and decoding arrays in \u003ccode\u003eencoding/gob\u003c/code\u003e,\nproducing time zone data in the \u003ccode\u003etime\u003c/code\u003e package, and so on.\u003c/p\u003e\n\u003cp\u003ePlease use \u003ccode\u003ego\u003c/code\u003e \u003ccode\u003egenerate\u003c/code\u003e creatively.\nIt’s there to encourage experimentation.\u003c/p\u003e\n\u003cp\u003eAnd even if you don’t, use the new \u003ccode\u003estringer\u003c/code\u003e tool to write your \u003ccode\u003eString\u003c/code\u003e methods for your integer constants.\nLet the machine do the work.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-12-22T00:00:00Z",
  "Author": "Rob Pike"
}