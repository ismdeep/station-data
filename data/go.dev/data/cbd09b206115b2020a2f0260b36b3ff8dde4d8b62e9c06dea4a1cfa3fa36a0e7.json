{
  "Source": "go.dev",
  "Title": "Go Concurrency Patterns: Timing out, moving on",
  "Link": "https://go.dev/blog/concurrency-timeouts",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/concurrency-timeouts\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Concurrency Patterns: Timing out, moving on\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      23 September 2010\n      \u003c/p\u003e\n      \n      \u003cp\u003eConcurrent programming has its own idioms.\nA good example is timeouts. Although Go’s channels do not support them directly,\nthey are easy to implement.\nSay we want to receive from the channel \u003ccode\u003ech\u003c/code\u003e,\nbut want to wait at most one second for the value to arrive.\nWe would start by creating a signalling channel and launching a goroutine\nthat sleeps before sending on the channel:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etimeout := make(chan bool, 1)\ngo func() {\n    time.Sleep(1 * time.Second)\n    timeout \u0026lt;- true\n}()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can then use a \u003ccode\u003eselect\u003c/code\u003e statement to receive from either \u003ccode\u003ech\u003c/code\u003e or \u003ccode\u003etimeout\u003c/code\u003e.\nIf nothing arrives on \u003ccode\u003ech\u003c/code\u003e after one second,\nthe timeout case is selected and the attempt to read from ch is abandoned.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eselect {\ncase \u0026lt;-ch:\n    // a read from ch has occurred\ncase \u0026lt;-timeout:\n    // the read from ch has timed out\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003etimeout\u003c/code\u003e channel is buffered with space for 1 value,\nallowing the timeout goroutine to send to the channel and then exit.\nThe goroutine doesn’t know (or care) whether the value is received.\nThis means the goroutine won’t hang around forever if the \u003ccode\u003ech\u003c/code\u003e receive happens\nbefore the timeout is reached.\nThe \u003ccode\u003etimeout\u003c/code\u003e channel will eventually be deallocated by the garbage collector.\u003c/p\u003e\n\u003cp\u003e(In this example we used \u003ccode\u003etime.Sleep\u003c/code\u003e to demonstrate the mechanics of goroutines and channels.\nIn real programs you should use \u003ccode\u003e [time.After](/pkg/time/#After)\u003c/code\u003e,\na function that returns a channel and sends on that channel after the specified duration.)\u003c/p\u003e\n\u003cp\u003eLet’s look at another variation of this pattern.\nIn this example we have a program that reads from multiple replicated databases simultaneously.\nThe program needs only one of the answers,\nand it should accept the answer that arrives first.\u003c/p\u003e\n\u003cp\u003eThe function \u003ccode\u003eQuery\u003c/code\u003e takes a slice of database connections and a \u003ccode\u003equery\u003c/code\u003e string.\nIt queries each of the databases in parallel and returns the first response it receives:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Query(conns []Conn, query string) Result {\n    ch := make(chan Result)\n    for _, conn := range conns {\n        go func(c Conn) {\n            select {\n            case ch \u0026lt;- c.DoQuery(query):\n            default:\n            }\n        }(conn)\n    }\n    return \u0026lt;-ch\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this example, the closure does a non-blocking send,\nwhich it achieves by using the send operation in \u003ccode\u003eselect\u003c/code\u003e statement with a \u003ccode\u003edefault\u003c/code\u003e case.\nIf the send cannot go through immediately the default case will be selected.\nMaking the send non-blocking guarantees that none of the goroutines launched\nin the loop will hang around.\nHowever, if the result arrives before the main function has made it to the receive,\nthe send could fail since no one is ready.\u003c/p\u003e\n\u003cp\u003eThis problem is a textbook example of what is known as a \u003ca href=\"https://en.wikipedia.org/wiki/Race_condition\" rel=\"noreferrer\" target=\"_blank\"\u003erace condition\u003c/a\u003e,\nbut the fix is trivial.\nWe just make sure to buffer the channel \u003ccode\u003ech\u003c/code\u003e (by adding the buffer length\nas the second argument to \u003ca href=\"/pkg/builtin/#make\"\u003emake\u003c/a\u003e),\nguaranteeing that the first send has a place to put the value.\nThis ensures the send will always succeed,\nand the first value to arrive will be retrieved regardless of the order of execution.\u003c/p\u003e\n\u003cp\u003eThese two examples demonstrate the simplicity with which Go can express complex interactions between goroutines.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-09-23T00:00:00Z",
  "Author": "Andrew Gerrand"
}