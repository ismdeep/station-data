{
  "Source": "go.dev",
  "Title": "Everything You Always Wanted to Know About Type Inference - And a Little Bit More",
  "Link": "https://go.dev/blog/type-inference",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/type-inference\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eEverything You Always Wanted to Know About Type Inference - And a Little Bit More\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Robert Griesemer\u003cbr/\u003e\n      9 October 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eThis is the blog version of my talk on type inference at GopherCon 2023 in San Diego,\nslightly expanded and edited for clarity.\u003c/p\u003e\n\u003ch2 id=\"what-is-type-inference\"\u003eWhat is type inference?\u003c/h2\u003e\n\u003cp\u003eWikipedia defines type inference as follows:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eType inference is the ability to automatically deduce, either partially or fully,\nthe type of an expression at compile time.\nThe compiler is often able to infer the type of a variable or the type signature of\na function, without explicit type annotations having been given.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe key phrase here is ‚Äúautomatically deduce ‚Ä¶ the type of an expression‚Äù.\nGo supported a basic form of type inference from the start:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003econst x = expr  // the type of x is the type of expr\nvar x = expr\nx := expr\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNo explicit types are given in these declarations,\nand therefore the types of the constant and variables \u003ccode\u003ex\u003c/code\u003e on the left of \u003ccode\u003e=\u003c/code\u003e and \u003ccode\u003e:=\u003c/code\u003e\nare the types of the respective initialization expressions, on the right.\nWe say that the types are \u003cem\u003einferred\u003c/em\u003e from (the types of) their initialization expressions.\nWith the introduction of generics in Go 1.18, Go‚Äôs type inference abilities\nwere significantly expanded.\u003c/p\u003e\n\u003ch3 id=\"why-type-inference\"\u003eWhy type inference?\u003c/h3\u003e\n\u003cp\u003eIn non-generic Go code, the effect of leaving away types is most pronounced in a short variable declaration.\nSuch a declaration combines type inference and a little bit of syntactic\nsugar‚Äîthe ability to leave away the \u003ccode\u003evar\u003c/code\u003e keyword‚Äîinto one very compact statement.\nConsider the following map variable declaration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar m map[string]int = map[string]int{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003evs\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003em := map[string]int{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOmitting the type on the left of \u003ccode\u003e:=\u003c/code\u003e removes repetition and at the same time increases readability.\u003c/p\u003e\n\u003cp\u003eGeneric Go code has the potential to significantly increase the number of types appearing in code:\nwithout type inference, each generic function and type instantiation requires type arguments.\nBeing able to omit them becomes even more important.\nConsider using the following two functions from the new\n\u003ca href=\"https://pkg.go.dev/slices\" rel=\"noreferrer\" target=\"_blank\"\u003eslices package\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003epackage slices\nfunc BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)\nfunc Sort[S ~[]E, E cmp.Ordered](x S)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWithout type inference, calling \u003ccode\u003eBinarySearch\u003c/code\u003e and \u003ccode\u003eSort\u003c/code\u003e requires explicit type arguments:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003etype List []int\nvar list List\nslices.Sort[List, int](list)\nindex, found := slices.BinarySearch[List, int](list, 42)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe‚Äôd rather not repeat \u003ccode\u003e[List, int]\u003c/code\u003e with each such generic function call.\nWith type inference the code simplifies to:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003etype List []int\nvar list List\nslices.Sort(list)\nindex, found := slices.BinarySearch(list, 42)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is both cleaner and more compact.\nIn fact it looks exactly like non-generic code,\nand type inference makes this possible.\u003c/p\u003e\n\u003cp\u003eImportantly, type inference is an optional mechanism:\nif type arguments make code clearer, by all means, write them down.\u003c/p\u003e\n\u003ch2 id=\"type-inference-is-a-form-of-type-pattern-matching\"\u003eType inference is a form of type pattern matching\u003c/h2\u003e\n\u003cp\u003eInference compares type patterns,\nwhere a type pattern is a type containing type parameters.\nFor reasons that will become obvious in a bit, type parameters\nare sometimes also called \u003cem\u003etype variables\u003c/em\u003e.\nType pattern matching allows us to infer the types that need\nto go into these type variables.\nLet‚Äôs consider a short example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func Sort[S ~[]E, E cmp.Ordered](x S)\n\ntype List []int\nvar list List\nslices.Sort(list)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eSort\u003c/code\u003e function call passes the \u003ccode\u003elist\u003c/code\u003e variable as function argument for the parameter \u003ccode\u003ex\u003c/code\u003e\nof \u003ca href=\"https://pkg.go.dev/slices#Sort\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eslices.Sort\u003c/code\u003e\u003c/a\u003e.\nTherefore the type of \u003ccode\u003elist\u003c/code\u003e, which is \u003ccode\u003eList\u003c/code\u003e, must match the type of \u003ccode\u003ex\u003c/code\u003e, which is type parameter \u003ccode\u003eS\u003c/code\u003e.\nIf \u003ccode\u003eS\u003c/code\u003e has the type \u003ccode\u003eList\u003c/code\u003e, this assignment becomes valid.\nIn reality, the \u003ca href=\"/ref/spec#Assignability\"\u003erules for assignments\u003c/a\u003e are complicated,\nbut for now it‚Äôs good enough to assume that the types must be identical.\u003c/p\u003e\n\u003cp\u003eOnce we have inferred the type for \u003ccode\u003eS\u003c/code\u003e, we can look at the\n\u003ca href=\"/ref/spec#Type_constraints\"\u003etype constraint\u003c/a\u003e for \u003ccode\u003eS\u003c/code\u003e.\nIt says‚Äîbecause of the tilde \u003ccode\u003e~\u003c/code\u003e symbol‚Äîthat the\n\u003ca href=\"/ref/spec#Underlying_types\"\u003e\u003cem\u003eunderlying type\u003c/em\u003e\u003c/a\u003e of \u003ccode\u003eS\u003c/code\u003e\nmust be the slice \u003ccode\u003e[]E\u003c/code\u003e.\nThe underlying type of \u003ccode\u003eS\u003c/code\u003e is \u003ccode\u003e[]int\u003c/code\u003e, therefore \u003ccode\u003e[]int\u003c/code\u003e must match \u003ccode\u003e[]E\u003c/code\u003e,\nand with that we can conclude that \u003ccode\u003eE\u003c/code\u003e must be \u003ccode\u003eint\u003c/code\u003e.\nWe‚Äôve been able to find types for \u003ccode\u003eS\u003c/code\u003e and \u003ccode\u003eE\u003c/code\u003e such that corresponding types match.\nInference has succeeded!\u003c/p\u003e\n\u003cp\u003eHere‚Äôs a more complicated scenario where we have a lot of type parameters:\n\u003ccode\u003eS1\u003c/code\u003e, \u003ccode\u003eS2\u003c/code\u003e, \u003ccode\u003eE1\u003c/code\u003e, and \u003ccode\u003eE2\u003c/code\u003e from \u003ccode\u003eslices.EqualFunc\u003c/code\u003e, and \u003ccode\u003eE1\u003c/code\u003e and \u003ccode\u003eE2\u003c/code\u003e from the generic function \u003ccode\u003eequal\u003c/code\u003e.\nThe local function \u003ccode\u003efoo\u003c/code\u003e calls \u003ccode\u003eslices.EqualFunc\u003c/code\u003e with the \u003ccode\u003eequal\u003c/code\u003e function as an argument:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool\n\n// Local code\nfunc equal[E1, E2 comparable](E1, E2) bool { ‚Ä¶ }\n\nfunc foo(list1 []int, list2 []float64) {\n    ‚Ä¶\n    if slices.EqualFunc(list1, list2, equal) {\n        ‚Ä¶\n    }\n    ‚Ä¶\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is an example where type inference really shines as we can potentially leave away six type arguments,\none for each of the type parameters.\nThe type pattern matching approach still works, but we can see how it may get complicated quickly\nbecause the number of type relationships is proliferating.\nWe need a systematic approach to determine which type parameters and which types get involved with which patterns.\u003c/p\u003e\n\u003cp\u003eIt helps to look at type inference in a slightly different way.\u003c/p\u003e\n\u003ch2 id=\"type-equations\"\u003eType equations\u003c/h2\u003e\n\u003cp\u003eWe can reframe type inference as a problem of solving type equations.\nSolving equations is something that we are all familiar with from high school algebra.\nLuckily, solving type equations is a simpler problem as we will see shortly.\u003c/p\u003e\n\u003cp\u003eLet‚Äôs look again at our earlier example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func Sort[S ~[]E, E cmp.Ordered](x S)\n\ntype List []int\nvar list List\nslices.Sort(list)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eInference succeeds if the type equations below can be solved.\nHere \u003ccode\u003e‚â°\u003c/code\u003e stands for \u003ca href=\"/ref/spec#Type_identity\"\u003e\u003cem\u003eis identical to\u003c/em\u003e\u003c/a\u003e,\nand \u003ccode\u003eunder(S)\u003c/code\u003e represents\nthe \u003ca href=\"/ref/spec#Underlying_types\"\u003eunderlying type\u003c/a\u003e\nof \u003ccode\u003eS\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eS ‚â° List        // find S such that S ‚â° List is true\nunder(S) ‚â° []E  // find E such that under(S) ‚â° []E is true\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe type parameters are the \u003cem\u003evariables\u003c/em\u003e in the equations.\nSolving the equations means finding values (type arguments) for these variables\n(type parameters), such that the equations become true.\nThis view makes the type inference problem more tractable because\nit gives us a formal framework that allows us to write down the information that\nflows into inference.\u003c/p\u003e\n\u003ch3 id=\"being-precise-with-type-relations\"\u003eBeing precise with type relations\u003c/h3\u003e\n\u003cp\u003eUntil now we have simply talked about types having to be\n\u003ca href=\"/ref/spec#Type_identity\"\u003eidentical\u003c/a\u003e.\nBut for actual Go code that is too strong a requirement.\nIn the previous example, \u003ccode\u003eS\u003c/code\u003e need not be identical to \u003ccode\u003eList\u003c/code\u003e,\nrather \u003ccode\u003eList\u003c/code\u003e must be \u003ca href=\"/ref/spec#Assignability\"\u003eassignable\u003c/a\u003e to \u003ccode\u003eS\u003c/code\u003e.\nSimilarly, \u003ccode\u003eS\u003c/code\u003e must \u003ca href=\"/ref/spec#Satisfying_a_type_constraint\"\u003esatisfy\u003c/a\u003e\nits corresponding type constraint.\nWe can formulate our type equations more precisely by using specific operators that\nwe write as \u003ccode\u003e:‚â°\u003c/code\u003e and \u003ccode\u003e‚àà\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eS :‚â° List         // List is assignable to S\nS ‚àà ~[]E          // S satisfies constraint ~[]E\nE ‚àà cmp.Ordered   // E satisfies constraint cmp.Ordered\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGenerally, we can say that type equations come in three forms:\ntwo types must be identical, one type must be assignable to the other type,\nor one type must satisfy a type constraint:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eX ‚â° Y             // X and Y must be identical\nX :‚â° Y            // Y is assignable to X\nX ‚àà Y             // X satisfies constraint Y\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(Note: In the GopherCon talk we used the symbols \u003ccode\u003e‚â°\u003c/code\u003e\u003csub\u003eA\u003c/sub\u003e for \u003ccode\u003e:‚â°\u003c/code\u003e and\n\u003ccode\u003e‚â°\u003c/code\u003e\u003csub\u003eC\u003c/sub\u003e for \u003ccode\u003e‚àà\u003c/code\u003e.\nWe believe \u003ccode\u003e:‚â°\u003c/code\u003e more clearly evokes an assignment relation;\nand \u003ccode\u003e‚àà\u003c/code\u003e directly expresses that the type represented by a type parameter must\nbe an element of its constraint‚Äôs \u003ca href=\"/ref/spec#Interface_types\"\u003etype set\u003c/a\u003e.)\u003c/p\u003e\n\u003ch3 id=\"sources-of-type-equations\"\u003eSources of type equations\u003c/h3\u003e\n\u003cp\u003eIn a generic function call we may have explicit type arguments,\nthough most of the time we hope that they can be inferred.\nTypically we also have ordinary function arguments.\nEach explicit type argument contributes a (trivial) type equation:\nthe type parameter must be identical to the type argument because the code says so.\nEach ordinary function argument contributes another type equation:\nthe function argument must be assignable to its corresponding function parameter.\nAnd finally, each type constraint provides a type equation as well\nby constraining what types satisfy the constraint.\u003c/p\u003e\n\u003cp\u003eAltogether, this produces \u003ccode\u003en\u003c/code\u003e type parameters and \u003ccode\u003em\u003c/code\u003e type equations.\nIn contrast to basic high school algebra, \u003ccode\u003en\u003c/code\u003e and \u003ccode\u003em\u003c/code\u003e don‚Äôt have to be the same for\ntype equations to be solvable.\nFor instance, the single equation below allows us to infer the type arguments for\ntwo type parameters:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003emap[K]V ‚â° map[int]string  // K ‚ûû int, V ‚ûû string (n = 2, m = 1)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet‚Äôs look at each of these sources of type equations in turn:\u003c/p\u003e\n\u003ch4 id=\"1-type-equations-from-type-arguments\"\u003e1. Type equations from type arguments\u003c/h4\u003e\n\u003cp\u003eFor each type parameter declaration\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc f[‚Ä¶, P constraint, ‚Ä¶]‚Ä¶\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand explicitly provided type argument\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003ef[‚Ä¶, A, ‚Ä¶]‚Ä¶\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe get the type equation\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eP ‚â° A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe can trivially solve this for \u003ccode\u003eP\u003c/code\u003e: \u003ccode\u003eP\u003c/code\u003e must be \u003ccode\u003eA\u003c/code\u003e and we write \u003ccode\u003eP ‚ûû A\u003c/code\u003e.\nIn other words, there is nothing to do here.\nWe could still write down the respective type equation for completeness,\nbut in this case, the Go compiler simply substitutes the type arguments\nfor their type parameters throughout and then those type parameters are\ngone and we can forget about them.\u003c/p\u003e\n\u003ch4 id=\"2-type-equations-from-assignments\"\u003e2. Type equations from assignments\u003c/h4\u003e\n\u003cp\u003eFor each function argument \u003ccode\u003ex\u003c/code\u003e passed to a function parameter \u003ccode\u003ep\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003ef(‚Ä¶, x, ‚Ä¶)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003ep\u003c/code\u003e or \u003ccode\u003ex\u003c/code\u003e contain type parameters,\nthe type of \u003ccode\u003ex\u003c/code\u003e must be assignable to the type of the parameter \u003ccode\u003ep\u003c/code\u003e.\nWe can express this with the equation\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(p) :‚â° ùëª(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003eùëª(x)\u003c/code\u003e means ‚Äúthe type of \u003ccode\u003ex\u003c/code\u003e‚Äù.\nIf neither \u003ccode\u003ep\u003c/code\u003e nor \u003ccode\u003ex\u003c/code\u003e contains type parameters, there is no type variable to solve for:\nthe equation is either true because the assignment is valid Go code,\nor false if the code is invalid.\nFor this reason, type inference only considers types that contain type parameters of the\ninvolved function (or functions).\u003c/p\u003e\n\u003cp\u003eStarting with Go 1.21, an uninstantiated or partially instantiated function\n(but not a function call) may also be assigned to a function-typed variable, as in:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func Sort[S ~[]E, E cmp.Ordered](x S)\n\nvar intSort func([]int) = slices.Sort\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnalogous to parameter passing, such assignments lead to a corresponding\ntype equation. For this example it would be\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(intSort) :‚â° ùëª(slices.Sort)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eor simplified\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc([]int) :‚â° func(S)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etogether with equations for the constraints for \u003ccode\u003eS\u003c/code\u003e and \u003ccode\u003eE\u003c/code\u003e from \u003ccode\u003eslices.Sort\u003c/code\u003e\n(see below).\u003c/p\u003e\n\u003ch4 id=\"3-type-equations-from-constraints\"\u003e3. Type equations from constraints\u003c/h4\u003e\n\u003cp\u003eFinally, for each type parameter \u003ccode\u003eP\u003c/code\u003e for which we want to infer a type argument,\nwe can extract a type equation from its constraint because the type parameter\nmust satisfy the constraint. Given the declaration\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc f[‚Ä¶, P constraint, ‚Ä¶]‚Ä¶\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewe can write down the equation\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eP ‚àà constraint\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere, the \u003ccode\u003e‚àà\u003c/code\u003e means ‚Äúmust satisfy constraint‚Äù which is (almost) the same as\nbeing a type element of the constraint‚Äôs type set.\nWe will see later that some constraints (such as \u003ccode\u003eany\u003c/code\u003e) are not useful or\ncurrently cannot be used due to limitations of the implementation.\nInference simply ignores the respective equations in those cases.\u003c/p\u003e\n\u003ch3 id=\"type-parameters-and-equations-may-be-from-multiple-functions\"\u003eType parameters and equations may be from multiple functions\u003c/h3\u003e\n\u003cp\u003eIn Go 1.18, inferred type parameters had to all be from the same function.\nSpecifically, it was not possible to pass a generic, uninstantiated or partially instantiated\nfunction as a function argument,\nor assign it to a (function-typed) variable.\u003c/p\u003e\n\u003cp\u003eAs mentioned earlier, in Go 1.21 type inference also works in these cases.\nFor instance, the generic function\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc myEq[P comparable](x, y P) bool { return x == y }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ecan be assigned to a variable of function type\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003evar strEq func(x, y string) bool = myEq  // same as using myEq[string]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewithout \u003ccode\u003emyEq\u003c/code\u003e being fully instantiated,\nand type inference will infer that the type argument for \u003ccode\u003eP\u003c/code\u003e must be \u003ccode\u003estring\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eFurthermore, a generic function may be used uninstantiated or partially instantiated as\nan argument to another, possibly generic function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S\n\ntype List []int\nvar list List\nresult := slices.CompactFunc(list, myEq)  // same as using slices.CompactFunc[List, int](list, myEq[int])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this last example, type inference determines the type arguments for \u003ccode\u003eCompactFunc\u003c/code\u003e\nand \u003ccode\u003emyEq\u003c/code\u003e.\nMore generally, type parameters from arbitrarily many functions may need to be inferred.\nWith multiple functions involved, type equations may also be from or involve multiple functions.\nIn the \u003ccode\u003eCompactFunc\u003c/code\u003e example we end up with three type parameters and five type equations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eType parameters and constraints:\n    S ~[]E\n    E any\n    P comparable\n\nExplicit type arguments:\n    none\n\nType equations:\n    S :‚â° List\n    func(E, E) bool :‚â° func(P, P) bool\n    S ‚àà ~[]E\n    E ‚àà any\n    P ‚àà comparable\n\nSolution:\n    S ‚ûû List\n    E ‚ûû int\n    P ‚ûû int\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"bound-vs-free-type-parameters\"\u003eBound vs free type parameters\u003c/h3\u003e\n\u003cp\u003eAt this point we have a clearer understanding of the various source of type equations,\nbut we have not been very precise about which type parameters to solve the equations for.\nLet‚Äôs consider another example.\nIn the code below, the function body of \u003ccode\u003esortedPrint\u003c/code\u003e calls \u003ccode\u003eslices.Sort\u003c/code\u003e for the sorting part.\n\u003ccode\u003esortedPrint\u003c/code\u003e and \u003ccode\u003eslices.Sort\u003c/code\u003e are generic functions as both declare type parameters.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e// From the slices package\n// func Sort[S ~[]E, E cmp.Ordered](x S)\n\n// sortedPrint prints the elements of the provided list in sorted order.\nfunc sortedPrint[F any](list []F) {\n    slices.Sort(list)  // ùëª(list) is []F\n    ‚Ä¶                  // print list\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWe want to infer the type argument for the \u003ccode\u003eslices.Sort\u003c/code\u003e call.\nPassing \u003ccode\u003elist\u003c/code\u003e to parameter \u003ccode\u003ex\u003c/code\u003e of \u003ccode\u003eslices.Sort\u003c/code\u003e gives rise to the equation\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(x) :‚â° ùëª(list)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich is the same as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eS :‚â° []F\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this equation we have two type parameters, \u003ccode\u003eS\u003c/code\u003e and \u003ccode\u003eF\u003c/code\u003e.\nWhich one do we need to solve the type equation for?\nBecause the invoked function is \u003ccode\u003eSort\u003c/code\u003e, we care about its type parameter \u003ccode\u003eS\u003c/code\u003e,\nnot the type parameter \u003ccode\u003eF\u003c/code\u003e.\nWe say that \u003ccode\u003eS\u003c/code\u003e is \u003cem\u003ebound\u003c/em\u003e to \u003ccode\u003eSort\u003c/code\u003e because it is declared by \u003ccode\u003eSort\u003c/code\u003e.\n\u003ccode\u003eS\u003c/code\u003e is the relevant type variable in this equation.\nBy contrast, \u003ccode\u003eF\u003c/code\u003e is bound to (declared by) \u003ccode\u003esortedPrint\u003c/code\u003e.\nWe say that \u003ccode\u003eF\u003c/code\u003e is \u003cem\u003efree\u003c/em\u003e with respect to \u003ccode\u003eSort\u003c/code\u003e.\nIt has its own, already given type.\nThat type is \u003ccode\u003eF\u003c/code\u003e, whatever that is (determined at instantiation time).\nIn this equation, \u003ccode\u003eF\u003c/code\u003e is already given, it is a \u003cem\u003etype constant\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eWhen solving type equations we always solve for the type parameters\nbound to the function we are calling\n(or assigning in case of a generic function assignment).\u003c/p\u003e\n\u003ch2 id=\"solving-type-equations\"\u003eSolving type equations\u003c/h2\u003e\n\u003cp\u003eThe missing piece, now that we have established how to collect the relevant\ntype parameters and type equations, is of course the algorithm that allows\nus to solve the equations.\nAfter the various examples, it probably has become obvious that solving\n\u003ccode\u003eX ‚â° Y\u003c/code\u003e simply means comparing the types \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e recursively against\neach other, and in the process determining suitable type arguments for\ntype parameters that may occur in \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e.\nThe goal is to make the types \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e \u003cem\u003eidentical\u003c/em\u003e.\nThis matching process is called \u003ca href=\"https://en.wikipedia.org/wiki/Unification_(computer_science)\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cem\u003eunification\u003c/em\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe rules for \u003ca href=\"/ref/spec#Type_identity\"\u003etype identity\u003c/a\u003e tell\nus how to compare types.\nSince \u003cem\u003ebound\u003c/em\u003e type parameters play the role of type variables, we need\nto specify how they are matched against other types.\nThe rules are as follows:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIf type parameter \u003ccode\u003eP\u003c/code\u003e has an inferred type, \u003ccode\u003eP\u003c/code\u003e stands for that type.\u003c/li\u003e\n\u003cli\u003eIf type parameter \u003ccode\u003eP\u003c/code\u003e doesn‚Äôt have an inferred type and is matched against another type\n\u003ccode\u003eT\u003c/code\u003e, \u003ccode\u003eP\u003c/code\u003e is set to that type: \u003ccode\u003eP ‚ûû T\u003c/code\u003e.\nWe say that the type \u003ccode\u003eT\u003c/code\u003e was inferred for \u003ccode\u003eP\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eIf \u003ccode\u003eP\u003c/code\u003e matches against another type parameter \u003ccode\u003eQ\u003c/code\u003e, and neither \u003ccode\u003eP\u003c/code\u003e nor \u003ccode\u003eQ\u003c/code\u003e\nhave an inferred type yet, \u003ccode\u003eP\u003c/code\u003e and \u003ccode\u003eQ\u003c/code\u003e are \u003cem\u003eunified\u003c/em\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUnification of two type parameters means that they are joined together such\nthat going forward they both denote the same type parameter value:\nif one of \u003ccode\u003eP\u003c/code\u003e or \u003ccode\u003eQ\u003c/code\u003e is matched against a type \u003ccode\u003eT\u003c/code\u003e, both \u003ccode\u003eP\u003c/code\u003e and \u003ccode\u003eQ\u003c/code\u003e are\nset to \u003ccode\u003eT\u003c/code\u003e simultaneously\n(in general, any number of type parameters may be unified this way).\u003c/p\u003e\n\u003cp\u003eFinally, if two types \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e are different, the equation cannot be made\ntrue and solving it fails.\u003c/p\u003e\n\u003ch3 id=\"unifying-types-for-type-identity\"\u003eUnifying types for type identity\u003c/h3\u003e\n\u003cp\u003eA few concrete examples should make this algorithm clear.\nConsider two types \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e containing three bound type parameters \u003ccode\u003eA\u003c/code\u003e, \u003ccode\u003eB\u003c/code\u003e, and \u003ccode\u003eC\u003c/code\u003e,\nall appearing in the type equation \u003ccode\u003eX ‚â° Y\u003c/code\u003e.\nThe goal is to the solve this equation for the type parameters; i.e., find suitable\ntype arguments for them such that \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e become identical and thus the equation\nbecomes true.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eX: map[A]struct{i int; s []B}\nY: map[string]struct{i C; s []byte}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnification proceeds by comparing the structure of \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e recursively, starting at the top.\nSimply looking at the structure of the two types we have\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003emap[‚Ä¶]‚Ä¶ ‚â° map[‚Ä¶]‚Ä¶\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewith the \u003ccode\u003e‚Ä¶\u003c/code\u003e representing the respective map key and value types that we‚Äôre\nignoring at this step.\nSince we have a map on both sides, the types are identical so far.\nUnification proceeds recursively, first with the key types which are \u003ccode\u003eA\u003c/code\u003e for the \u003ccode\u003eX\u003c/code\u003e map,\nand \u003ccode\u003estring\u003c/code\u003e for the \u003ccode\u003eY\u003c/code\u003e map.\nCorresponding key types must be identical, and from that we can immediately infer that\nthe type argument for \u003ccode\u003eA\u003c/code\u003e must be \u003ccode\u003estring\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eA ‚â° string =\u0026gt; A ‚ûû string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eContinuing with the map element types, we arrive at\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003estruct{i int; s []B} ‚â° struct{i C; s []byte}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBoth sides are structs so unification proceeds with the struct fields.\nThey are identical if they are in the same order, with the same names, and identical types.\nThe first field pair is \u003ccode\u003ei int\u003c/code\u003e and \u003ccode\u003ei C\u003c/code\u003e.\nThe names match and because \u003ccode\u003eint\u003c/code\u003e must unify with \u003ccode\u003eC\u003c/code\u003e, thus\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eint ‚â° C =\u0026gt; C ‚ûû int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis recursive type matching continues until the tree structure of the two types is fully\ntraversed, or until a conflict appears.\nIn this example, eventually we end up with\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e[]B ‚â° []byte =\u0026gt; B ‚â° byte =\u0026gt; B ‚ûû byte\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEverything works out fine and unification infers the type arguments\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eA ‚ûû string\nB ‚ûû byte\nC ‚ûû int\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"unifying-types-with-different-structures\"\u003eUnifying types with different structures\u003c/h3\u003e\n\u003cp\u003eNow, let‚Äôs consider a slight variation of the previous example:\nhere \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e don‚Äôt have the same type structure.\nWhen the type trees are compared recursively, unification still successfully infers the type argument for \u003ccode\u003eA\u003c/code\u003e.\nBut the value types of the maps are different and unification fails.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eX: map[A]struct{i int; s []B}\nY: map[string]bool\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBoth \u003ccode\u003eX\u003c/code\u003e and \u003ccode\u003eY\u003c/code\u003e are map types, so unification proceeds recursively as before, starting with the key types.\nWe arrive at\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eA ‚â° string =\u0026gt; A ‚ûû string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ealso as before.\nBut when we proceed with the map‚Äôs value types we have\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003estruct{‚Ä¶} ‚â° bool\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003estruct\u003c/code\u003e type doesn‚Äôt match \u003ccode\u003ebool\u003c/code\u003e; we have different types and unification (and thus type inference) fails.\u003c/p\u003e\n\u003ch3 id=\"unifying-types-with-conflicting-type-arguments\"\u003eUnifying types with conflicting type arguments\u003c/h3\u003e\n\u003cp\u003eAnother kind of conflict appears when different types match against the same type parameter.\nHere we have again a version of our initial example but now the type parameter \u003ccode\u003eA\u003c/code\u003e appears twice in \u003ccode\u003eX\u003c/code\u003e,\nand \u003ccode\u003eC\u003c/code\u003e appears twice in \u003ccode\u003eY\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eX: map[A]struct{i int; s []A}\nY: map[string]struct{i C; s []C}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe recursive type unification works out fine at first and we have the following pairings of type\nparameters and types:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003eA   ‚â° string =\u0026gt; A ‚ûû string  // map key type\nint ‚â° C      =\u0026gt; C ‚ûû int     // first struct field type\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen we get to the second struct field type we have\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003e[]A ‚â° []C =\u0026gt; A ‚â° C\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince both \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eC\u003c/code\u003e have a type argument inferred for them, they stand for those type arguments,\nwhich are \u003ccode\u003estring\u003c/code\u003e and \u003ccode\u003eint\u003c/code\u003e respectively.\nThese are different types, so \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eC\u003c/code\u003e can‚Äôt possibly match.\nUnification and thus type inference fails.\u003c/p\u003e\n\u003ch3 id=\"other-type-relations\"\u003eOther type relations\u003c/h3\u003e\n\u003cp\u003eUnification solves type equations of the form \u003ccode\u003eX ‚â° Y\u003c/code\u003e where the goal is \u003cem\u003etype identity\u003c/em\u003e.\nBut what about \u003ccode\u003eX :‚â° Y\u003c/code\u003e or \u003ccode\u003eX ‚àà Y\u003c/code\u003e?\u003c/p\u003e\n\u003cp\u003eA couple of observations help us out here:\nThe job of type inference is solely to find the types of omitted type arguments.\nType inference is always followed by type or function\n\u003ca href=\"/ref/spec#Instantiations\"\u003einstantiation\u003c/a\u003e which\nchecks that each type argument actually satisfies its respective type constraint.\nFinally, in case of a generic function call, the compiler also checks that\nfunction arguments are assignable to their corresponding function parameters.\nAll of these steps must succeed for the code to be valid.\u003c/p\u003e\n\u003cp\u003eIf type inference is not precise enough it may infer an (incorrect) type argument\nwhere no type may exist.\nIf that is the case, either instantiation or argument passing will fail.\nEither way, the compiler will produce an error message.\nIt‚Äôs just that the error message may be slightly different.\u003c/p\u003e\n\u003cp\u003eThis insight allows us to play a bit loose with the type relations \u003ccode\u003e:‚â°\u003c/code\u003e and \u003ccode\u003e‚àà\u003c/code\u003e.\nSpecifically, it allows us to simplify them such that they can be treated\nalmost the same as \u003ccode\u003e‚â°\u003c/code\u003e.\nThe goal of the simplifications is to extract as much type information as\npossible from a type equation, and thus to infer type arguments where a\nprecise implementation may fail, because we can.\u003c/p\u003e\n\u003ch3 id=\"simplifying-x--y\"\u003eSimplifying X :‚â° Y\u003c/h3\u003e\n\u003cp\u003eGo‚Äôs assignability rules are pretty complicated, but most of the time we can actually\nget by with type identity, or a slight variation of it.\nAs long as we find potential type arguments, we‚Äôre happy, exactly because type inference\nis still followed by type instantiation and function invocation.\nIf inference finds a type argument where it shouldn‚Äôt, it‚Äôll be caught later.\nThus, when matching for assignability, we make the following adjustments to the\nunfication algorithm:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWhen a named (defined) type is matched against a type literal,\ntheir underlying types are compared instead.\u003c/li\u003e\n\u003cli\u003eWhen comparing channel types, channel directions are ignored.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFurthermore, the assignment direction is ignored: \u003ccode\u003eX :‚â° Y\u003c/code\u003e is treated like \u003ccode\u003eY :‚â° X\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThese adjustments apply only at the top level of a type structure:\nfor instance, per Go‚Äôs \u003ca href=\"/ref/spec#Assignability\"\u003eassignability rules\u003c/a\u003e,\na named map type may be assigned to an unnamed map type, but the key and element types\nmust still be identical.\nWith these changes, unification for assignability becomes a (minor) variation\nof unification for type identity.\nThe following example illustrates this.\u003c/p\u003e\n\u003cp\u003eLet‚Äôs assume we are passing a value of our earlier \u003ccode\u003eList\u003c/code\u003e type (defined as \u003ccode\u003etype List []int\u003c/code\u003e)\nto a function parameter of type \u003ccode\u003e[]E\u003c/code\u003e where \u003ccode\u003eE\u003c/code\u003e is a bound type parameter (i.e., \u003ccode\u003eE\u003c/code\u003e is declared\nby the generic function that is being called).\nThis leads to the type equation \u003ccode\u003e[]E :‚â° List\u003c/code\u003e.\nAttempting to unify these two types requires comparing \u003ccode\u003e[]E\u003c/code\u003e with \u003ccode\u003eList\u003c/code\u003e\nThese two types are not identical, and without any changes to how unification works,\nit will fail.\nBut because we are unifying for assignability, this initial match doesn‚Äôt need to be exact.\nThere‚Äôs no harm in continuing with the underlying type of the named type \u003ccode\u003eList\u003c/code\u003e:\nin the worst case we may infer an incorrect type argument, but that will lead to an error\nlater, when assignments are checked.\nIn the best case, we find a useful and correct type argument.\nIn our example, inexact unification succeeds and we correctly infer \u003ccode\u003eint\u003c/code\u003e for \u003ccode\u003eE\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"simplifying-x--y-1\"\u003eSimplifying X ‚àà Y\u003c/h3\u003e\n\u003cp\u003eBeing able to simplify the constraint satisfaction relation is even more important as\nconstraints can be very complex.\u003c/p\u003e\n\u003cp\u003eAgain, constraint satisfaction is checked at instantiation time, so the goal here is\nto help type inference where we can.\nThese are typically situations where we know the structure of a type parameter;\nfor instance we know that it must be a\nslice type and we care about the slice‚Äôs element type.\nFor example, a type parameter list of the form \u003ccode\u003e[P ~[]E]\u003c/code\u003e tells us that whatever \u003ccode\u003eP\u003c/code\u003e is,\nits underlying type must be of the form \u003ccode\u003e[]E\u003c/code\u003e.\nThese are exactly the situations where the constraint has a\n\u003ca href=\"/ref/spec#Core_types\"\u003ecore type\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eTherefore, if we have an equation of the form\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eP ‚àà constraint               // or\nP ‚àà ~constraint\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand if \u003ccode\u003ecore(constraint)\u003c/code\u003e (or \u003ccode\u003ecore(~constraint)\u003c/code\u003e, respectively) exists, the equation\ncan be simplified to\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eP        ‚â° core(constraint)\nunder(P) ‚â° core(~constraint)  // respectively\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn all other cases, type equations involving constraints are ignored.\u003c/p\u003e\n\u003ch3 id=\"expanding-inferred-types\"\u003eExpanding inferred types\u003c/h3\u003e\n\u003cp\u003eIf unification is successful it produces a mapping from type parameters\nto inferred type arguments.\nBut unification alone doesn‚Äôt ensure that the inferred types are free\nof bound type parameters.\nTo see why this is the case, consider the generic function \u003ccode\u003eg\u003c/code\u003e below\nwhich is invoked with a single argument \u003ccode\u003ex\u003c/code\u003e of type \u003ccode\u003eint\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc g[A any, B []C, C *A](x A) { ‚Ä¶ }\n\nvar x int\ng(x)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe type constraint for \u003ccode\u003eA\u003c/code\u003e is \u003ccode\u003eany\u003c/code\u003e which doesn‚Äôt have a core type, so we\nignore it. The remaining type constraints have core types and they are \u003ccode\u003e[]C\u003c/code\u003e\nand \u003ccode\u003e*A\u003c/code\u003e respectively. Together with the argument passed to \u003ccode\u003eg\u003c/code\u003e, after minor\nsimplifications, the type equations are:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    A :‚â° int\n    B ‚â° []C\n    C ‚â° *A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSince each equation pits a type parameter against a non-type parameter type,\nunification has little to do and immediately infers\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    A ‚ûû int\n    B ‚ûû []C\n    C ‚ûû *A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut that leaves the type parameters \u003ccode\u003eA\u003c/code\u003e and \u003ccode\u003eC\u003c/code\u003e in the inferred types, which\nis not helpful.\nLike in high school algebra, once an equation is solved for a variable \u003ccode\u003ex\u003c/code\u003e,\nwe need to substitute \u003ccode\u003ex\u003c/code\u003e with its value throughout the remaining equations.\nIn our example, in a first step, the \u003ccode\u003eC\u003c/code\u003e in \u003ccode\u003e[]C\u003c/code\u003e is substituted with the\ninferred type (the ‚Äúvalue‚Äù) for \u003ccode\u003eC\u003c/code\u003e, which is \u003ccode\u003e*A\u003c/code\u003e, and we arrive at\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    A ‚ûû int\n    B ‚ûû []*A    // substituted *A for C\n    C ‚ûû *A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn two more steps we replace the \u003ccode\u003eA\u003c/code\u003e in the inferred types \u003ccode\u003e[]*A\u003c/code\u003e and \u003ccode\u003e*A\u003c/code\u003e\nwith the inferred type for \u003ccode\u003eA\u003c/code\u003e, which is \u003ccode\u003eint\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    A ‚ûû int\n    B ‚ûû []*int  // substituted int for A\n    C ‚ûû *int    // substituted int for A\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnly now inference is done.\nAnd like in high school algebra, sometimes this doesn‚Äôt work.\nIt‚Äôs possible to arrive at a situation such as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    X ‚ûû Y\n    Y ‚ûû *X\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAfter one round of substitutions we have\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    X ‚ûû *X\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we keep going, the inferred type for \u003ccode\u003eX\u003c/code\u003e keeps growing:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    X ‚ûû **X     // substituted *X for X\n    X ‚ûû ***X    // substituted *X for X\n    etc.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eType inference detects such cycles during expansion and reports\nan error (and thus fails).\u003c/p\u003e\n\u003ch2 id=\"untyped-constants\"\u003eUntyped constants\u003c/h2\u003e\n\u003cp\u003eBy now we have seen how type inference works by solving type equations\nwith unification, followed by expansion of the result.\nBut what if there are no types?\nWhat if the function arguments are untyped constants?\u003c/p\u003e\n\u003cp\u003eAnother example helps us shed light on this situation.\nLet‚Äôs consider a function \u003ccode\u003efoo\u003c/code\u003e which takes an arbitrary number of arguments,\nall of which must have the same type.\n\u003ccode\u003efoo\u003c/code\u003e is called with a variety of untyped constant arguments, including a variable\n\u003ccode\u003ex\u003c/code\u003e of type \u003ccode\u003eint\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc foo[P any](...P) {}\n\nvar x int\nfoo(x)         // P ‚ûû int, same as foo[int](x)\nfoo(x, 2.0)    // P ‚ûû int, 2.0 converts to int without loss of precision\nfoo(x, 2.1)    // P ‚ûû int, but parameter passing fails: 2.1 is not assignable to int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor type inference, typed arguments take precedence over untyped arguments.\nAn untyped constant is considered for inference only if the type parameter it‚Äôs assigned\nto doesn‚Äôt have an inferred type yet.\nIn these first three calls to \u003ccode\u003efoo\u003c/code\u003e, the variable \u003ccode\u003ex\u003c/code\u003e determines the inferred type for \u003ccode\u003eP\u003c/code\u003e:\nit‚Äôs the type of \u003ccode\u003ex\u003c/code\u003e which is \u003ccode\u003eint\u003c/code\u003e.\nUntyped constants are ignored for type inference in this case and the calls behave exactly\nas if \u003ccode\u003efoo\u003c/code\u003e was explicitly instantiated with \u003ccode\u003eint\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIt gets more interesting if \u003ccode\u003efoo\u003c/code\u003e is called with untyped constant arguments only.\nIn this case, type inference considers the \u003ca href=\"/ref/spec#Constants\"\u003edefault types\u003c/a\u003e\nof the untyped constants.\nAs a quick reminder, here are the possible default types in Go:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eExample     Constant kind              Default type    Order\n\ntrue        boolean constant           bool\n42          integer constant           int             earlier in list\n\u0026#39;x\u0026#39;         rune constant              rune               |\n3.1416      floating-point constant    float64            v\n-1i         complex constant           complex128      later in list\n\u0026#34;gopher\u0026#34;    string constant            string\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this information in hand, let‚Äôs consider the function call\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efoo(1, 2)    // P ‚ûû int (default type for 1 and 2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe untyped constant arguments \u003ccode\u003e1\u003c/code\u003e and \u003ccode\u003e2\u003c/code\u003e are both integer constants, their default type is\n\u003ccode\u003eint\u003c/code\u003e and thus it‚Äôs \u003ccode\u003eint\u003c/code\u003e that is inferred for the type parameter \u003ccode\u003eP\u003c/code\u003e of \u003ccode\u003efoo\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf different constants‚Äîsay untyped integer and floating-point constants‚Äîcompete\nfor the same type variable, we have different default types.\nBefore Go 1.21, this was considered a conflict and led to an error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efoo(1, 2.0)    // Go 1.20: inference error: default types int, float64 don\u0026#39;t match\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis behavior was not very ergonomic in use and also different from the behavior of untyped constants\nin expressions. For instance, Go permits the constant expression \u003ccode\u003e1 + 2.0\u003c/code\u003e;\nthe result is the floating-point constant \u003ccode\u003e3.0\u003c/code\u003e with default type \u003ccode\u003efloat64\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIn Go 1.21 the behavior was changed accordingly.\nNow, if multiple untyped numeric constants are matched against the same type parameter,\nthe default type that appears later in the list of \u003ccode\u003eint\u003c/code\u003e, \u003ccode\u003erune\u003c/code\u003e, \u003ccode\u003efloat64\u003c/code\u003e, \u003ccode\u003ecomplex\u003c/code\u003e is\nselected, matching the rules for \u003ca href=\"/ref/spec#Constant_expressions\"\u003econstant expressions\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efoo(1, 2.0)    // Go 1.21: P ‚ûû float64 (larger default type of 1 and 2.0; behavior like in 1 + 2.0)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"special-situations\"\u003eSpecial situations\u003c/h2\u003e\n\u003cp\u003eBy now we‚Äôve got the big picture about type inference.\nBut there are a couple of important special situations that deserve some attention.\u003c/p\u003e\n\u003ch3 id=\"parameter-order-dependencies\"\u003eParameter order dependencies\u003c/h3\u003e\n\u003cp\u003eThe first one has to do with parameter order dependencies.\nAn important property we want from type inference is that the same types are inferred\nirrespective of the order of the function parameters (and corresponding argument\norder in each call of that function).\u003c/p\u003e\n\u003cp\u003eLet‚Äôs reconsider our variadic \u003ccode\u003efoo\u003c/code\u003e function:\nthe type inferred for \u003ccode\u003eP\u003c/code\u003e should be the same irrespective of the order in which\nwe pass the arguments \u003ccode\u003es\u003c/code\u003e and \u003ccode\u003et\u003c/code\u003e (\u003ca href=\"/play/p/sOlWutKnDFc\"\u003eplayground\u003c/a\u003e).\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc foo[P any](...P) (x P) {}\n\ntype T struct{}\n\nfunc main() {\n    var s struct{}\n    var t T\n    fmt.Printf(\u0026#34;%T\\n\u0026#34;, foo(s, t))\n    fmt.Printf(\u0026#34;%T\\n\u0026#34;, foo(t, s)) // expect same result independent of parameter order\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFrom the calls to \u003ccode\u003efoo\u003c/code\u003e we can extract the relevant type equations:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(x) :‚â° ùëª(s) =\u0026gt; P :‚â° struct{}    // equation 1\nùëª(x) :‚â° ùëª(t) =\u0026gt; P :‚â° T           // equation 2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSadly, the simplified implementation for \u003ccode\u003e:‚â°\u003c/code\u003e produces an order dependency:\u003c/p\u003e\n\u003cp\u003eIf unification starts with equation 1, it matches \u003ccode\u003eP\u003c/code\u003e against \u003ccode\u003estruct\u003c/code\u003e; \u003ccode\u003eP\u003c/code\u003e doesn‚Äôt have a type inferred for it yet\nand thus unification infers \u003ccode\u003eP ‚ûû struct{}\u003c/code\u003e.\nWhen unification sees type \u003ccode\u003eT\u003c/code\u003e later in equation 2, it proceeds with the underlying type of \u003ccode\u003eT\u003c/code\u003e which is \u003ccode\u003estruct{}\u003c/code\u003e,\n\u003ccode\u003eP\u003c/code\u003e and \u003ccode\u003eunder(T)\u003c/code\u003e unify, and unification and thus inference succeeds.\u003c/p\u003e\n\u003cp\u003eVice versa, if unification starts with equation 2, it matches \u003ccode\u003eP\u003c/code\u003e against \u003ccode\u003eT\u003c/code\u003e; \u003ccode\u003eP\u003c/code\u003e doesn‚Äôt have a type inferred for it yet\nand thus unification infers \u003ccode\u003eP ‚ûû T\u003c/code\u003e.\nWhen unification sees \u003ccode\u003estruct{}\u003c/code\u003e later in equation 1, it proceeds with the underlying type of the type \u003ccode\u003eT\u003c/code\u003e inferred for \u003ccode\u003eP\u003c/code\u003e.\nThat underlying type is \u003ccode\u003estruct{}\u003c/code\u003e, which matches \u003ccode\u003estruct\u003c/code\u003e in equation 1, and unification and thus inference succeeds.\u003c/p\u003e\n\u003cp\u003eAs a consequence, depending on the order in which unification solves the two type equations,\nthe inferred type is either \u003ccode\u003estruct{}\u003c/code\u003e or \u003ccode\u003eT\u003c/code\u003e.\nThis is of course unsatisfying: a program may suddenly stop compiling simply because arguments\nmay have been shuffled around during a code refactoring or cleanup.\u003c/p\u003e\n\u003ch3 id=\"restoring-order-independence\"\u003eRestoring order independence\u003c/h3\u003e\n\u003cp\u003eLuckily, the remedy is fairly simple.\nAll we need is a small correction in some situations.\u003c/p\u003e\n\u003cp\u003eSpecifically, if unification is solving \u003ccode\u003eP :‚â° T\u003c/code\u003e and\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eP\u003c/code\u003e is a type parameter which already has inferred a type \u003ccode\u003eA\u003c/code\u003e: \u003ccode\u003eP ‚ûû A\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eA :‚â° T\u003c/code\u003e is true\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eT\u003c/code\u003e is a named type\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003ethen set the inferred type for \u003ccode\u003eP\u003c/code\u003e to \u003ccode\u003eT\u003c/code\u003e: \u003ccode\u003eP ‚ûû T\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThis ensures that \u003ccode\u003eP\u003c/code\u003e is the named type if there is choice, no matter at which point the named type\nappeared in a match against \u003ccode\u003eP\u003c/code\u003e (i.e., no matter in which order the type equations are solved).\nNote that if different named types match against the same type parameter, we always have a unfication\nfailure because different named types are not identical by definition.\u003c/p\u003e\n\u003cp\u003eBecause we made similar simplifications for channels and interfaces, they also need similar special\nhandling. For instance, we ignore channel directions when unifying for assignability and as a result\nmay infer a directed or bidirectional channel depending on argument order. Similar problems occur\nwith interfaces. We‚Äôre not going to discuss these here.\u003c/p\u003e\n\u003cp\u003eGoing back to our example, if unification starts with equation 1, it infers \u003ccode\u003eP ‚ûû struct{}\u003c/code\u003e as before.\nWhen it proceeds with equation 2, as before, unification succeeds, but now we have exactly the\ncondition that calls for a correction: \u003ccode\u003eP\u003c/code\u003e is a type parameter which already has a type (\u003ccode\u003estruct{}\u003c/code\u003e),\n\u003ccode\u003estruct{}\u003c/code\u003e, \u003ccode\u003estruct{} :‚â° T\u003c/code\u003e is true (because \u003ccode\u003estruct{} ‚â° under(T)\u003c/code\u003e is true), and \u003ccode\u003eT\u003c/code\u003e is a named type.\nThus, unification makes the correction and sets \u003ccode\u003eP ‚ûû T\u003c/code\u003e.\nAs a result, irrespective of the unification order, the result is the same (\u003ccode\u003eT\u003c/code\u003e) in both cases.\u003c/p\u003e\n\u003ch3 id=\"self-recursive-functions\"\u003eSelf-recursive functions\u003c/h3\u003e\n\u003cp\u003eAnother scenario that causes problems in a naive implementation of inference is self-recursive functions.\nLet‚Äôs consider a generic factorial function \u003ccode\u003efact\u003c/code\u003e, defined such that it also works for floating-point arguments\n(\u003ca href=\"/play/p/s3wXpgHX6HQ\"\u003eplayground\u003c/a\u003e).\nNote that this is not a mathematically correct implementation of the\n\u003ca href=\"https://en.wikipedia.org/wiki/Gamma_function\" rel=\"noreferrer\" target=\"_blank\"\u003egamma function\u003c/a\u003e,\nit is simply a convenient example.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc fact[P ~int | ~float64](n P) P {\n    if n \u0026lt;= 1 {\n        return 1\n    }\n    return fact(n-1) * n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe point here is not the factorial function but rather that \u003ccode\u003efact\u003c/code\u003e calls itself with the\nargument \u003ccode\u003en-1\u003c/code\u003e which is of the same type \u003ccode\u003eP\u003c/code\u003e as the incoming parameter \u003ccode\u003en\u003c/code\u003e.\nIn this call, the type parameter \u003ccode\u003eP\u003c/code\u003e is simultaneously a bound and a free type parameter:\nit is bound because it is declared by \u003ccode\u003efact\u003c/code\u003e, the function that we are calling recursively.\nBut it is also free because it is declared by the function enclosing the call, which happens\nto also be \u003ccode\u003efact\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe equation resulting from passing the argument \u003ccode\u003en-1\u003c/code\u003e to parameter \u003ccode\u003en\u003c/code\u003e pits \u003ccode\u003eP\u003c/code\u003e against itself:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(n) :‚â° ùëª(n-1) =\u0026gt; P :‚â° P\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnification sees the same \u003ccode\u003eP\u003c/code\u003e on either side of the equation.\nUnification succeeds since both types are identical but there‚Äôs no information gained and \u003ccode\u003eP\u003c/code\u003e\nremains without an inferred type. As a consequence, type inference fails.\u003c/p\u003e\n\u003cp\u003eLuckily, the trick to address this is simple:\nBefore type inference is invoked, and for (temporary) use by type inference only,\nthe compiler renames the type parameters in the signatures (but not the bodies)\nof all functions involved in the respective call.\nThis doesn‚Äôt change the meaning of the function signatures:\nthey denote the same generic functions irrespective of what the names of the type parameters are.\u003c/p\u003e\n\u003cp\u003eFor the purpose of this example, let‚Äôs assume the \u003ccode\u003eP\u003c/code\u003e in the signature of \u003ccode\u003efact\u003c/code\u003e got renamed to \u003ccode\u003eQ\u003c/code\u003e.\nThe effect is as if the recursive call was done indirectly through a \u003ccode\u003ehelper\u003c/code\u003e function\n(\u003ca href=\"/play/p/TLpo-0auWwC\"\u003eplayground\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc fact[P ~int | ~float64](n P) P {\n    if n \u0026lt;= 1 {\n        return 1\n    }\n    return helper(n-1) * n\n}\n\nfunc helper[Q ~int | ~float64](n Q) Q {\n    return fact(n)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith the renaming, or with the \u003ccode\u003ehelper\u003c/code\u003e function, the equation resulting from passing\n\u003ccode\u003en-1\u003c/code\u003e to the recursive call of \u003ccode\u003efact\u003c/code\u003e (or the \u003ccode\u003ehelper\u003c/code\u003e function, respectively) changes\nto\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eùëª(n) :‚â° ùëª(n-1) =\u0026gt; Q :‚â° P\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis equation has two type parameters: the bound type parameter \u003ccode\u003eQ\u003c/code\u003e, declared by the\nfunction that is being called, and the free type parameter \u003ccode\u003eP\u003c/code\u003e, declared by the enclosing\nfunction. This type equation is trivially solved for \u003ccode\u003eQ\u003c/code\u003e and results in the inference\n\u003ccode\u003eQ ‚ûû P\u003c/code\u003e\nwhich is of course what we‚Äôd expect, and which we can verify by explicitly instantiating\nthe recursive call (\u003ca href=\"/play/p/zkUFvwJ54lC\"\u003eplayground\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003efunc fact[P ~int | ~float64](n P) P {\n    if n \u0026lt;= 1 {\n        return 1\n    }\n    return fact[P](n-1) * n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"whats-missing\"\u003eWhat‚Äôs missing?\u003c/h2\u003e\n\u003cp\u003eConspicuously absent from our description is type inference for generic types:\ncurrently generic types must always be explicitly instantiated.\u003c/p\u003e\n\u003cp\u003eThere are a couple of reasons for this. First of all, for type instantiation, type inference\nonly has type arguments to work with; there are no other arguments as is the case for\nfunction calls. As a consequence, at least one type argument must always be provided\n(except for pathological cases where type constraints prescribe exactly one possible\ntype argument for all type parameters).\nThus, type inference for types is only useful to complete a partially\ninstantiated type where all the omitted type arguments can be inferred from the\nequations resulting from type constraints; i.e., where there are at least two type\nparameters. We believe this is not a very common scenario.\u003c/p\u003e\n\u003cp\u003eSecond, and more pertinent, type parameters allow an entirely new kind of recursive\ntypes. Consider the hypothetical type\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-Go\"\u003etype T[P T[P]] interface{ ‚Ä¶ }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere the constraint for \u003ccode\u003eP\u003c/code\u003e is the type being declared.\nCombined with the ablity to have multiple type parameters that may refer to each other\nin complex recursive fashion, type inference becomes much more complicated and we don‚Äôt\nfully understand all the implications of that at the moment.\nThat said, we believe it shouldn‚Äôt be too hard to detect cycles and proceed with\ntype inference where no such cycles exist.\u003c/p\u003e\n\u003cp\u003eFinally, there are situations where type inference is simply not strong enough to make\nan inference, typically because unification works with certain simplifying assumptions\nsuch as the ones described earlier in this post.\nThe primary example here is constraints which have no core type,\nbut where a more sophisticated approach might be able to infer type information anyway.\u003c/p\u003e\n\u003cp\u003eThese are all areas where we may see incremental improvements in future Go releases.\nImportantly, we believe that cases where inference currently fails are either rare\nor unimportant in production code, and that our current implementation covers a large\nmajority of all useful code scenarios.\u003c/p\u003e\n\u003cp\u003eThat said, if you run into a situation where you believe type inference should work or\nwent astray, please \u003ca href=\"/issue/new\"\u003efile an issue\u003c/a\u003e!\nAs always, the Go team loves to hear from you, especially when it helps us making Go\neven better.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-10-09T00:00:00Z",
  "Author": "Robert Griesemer"
}