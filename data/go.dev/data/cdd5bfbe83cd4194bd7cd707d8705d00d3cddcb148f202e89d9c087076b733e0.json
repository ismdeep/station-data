{
  "Source": "go.dev",
  "Title": "Go Developer Survey 2023 Q1 Results",
  "Link": "https://go.dev/blog/survey2023-q1-results",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/survey2023-q1-results\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Developer Survey 2023 Q1 Results\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Alice Merrick\u003cbr/\u003e\n      11 May 2023\n      \u003c/p\u003e\n      \n      \u003cstyle type=\"text/css\" scoped=\"\"\u003e\n  .chart {\n    margin-left: 1.5rem;\n    margin-right: 1.5rem;\n    width: 800px;\n  }\n  .quote {\n    margin-left: 2rem;\n    margin-right: 2rem;\n    color: #999;\n    font-style: italic;\n    font-size: 120%;\n  }\n  @media (prefers-color-scheme: dark) {\n    .chart {\n      border-radius: 8px;\n    }\n  }\n\u003c/style\u003e\n\u003ch2 id=\"thank-you-respondents-for-bringing-us-these-insights\"\u003eThank you respondents for bringing us these insights!\u003c/h2\u003e\n\u003cp\u003eWe’re excited to share with you the results of the 2023 January edition of the\nGo Developer Survey. Thank you to the 5,844 respondents who shared with us how\nthey’re using Go, their biggest challenges in using Go, and their top\npriorities for future improvements. These results help the Go team focus our\nefforts on areas that matter most to the community, and we hope these insights\nalso help inform others who contribute to and support the Go ecosystem.\u003c/p\u003e\n\u003ch3 id=\"key-findings\"\u003eKey findings\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNovice Go developers are interested in web development\u003c/strong\u003e. We introduced a\nnew segmentation this year based on self-identified experience levels.\nNovices expressed some interesting differences from other experience levels.\nMost notably they showed greater interest in using Go for web development.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eError handling and learning are respondents’ top challenges\u003c/strong\u003e.\nHistorically, lack of generics was the biggest challenge to using Go, but\nsince the introduction of generics, we’ve seen comments about generics\ndecline. Comments about error handling (with respect to readability and\nverbosity) and difficulty learning best practices are now the most commonly\nreported challenges.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eAn optimization guide was the most valued way to improve Go’s\nperformance\u003c/strong\u003e. When asked how they would spend resources on various\nimprovements to Go’s compile and runtime, respondents spent the most on an\noptimization guide rather than specific performance improvements,\ndemonstrating how much documentation is valued in this area.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eManaging dependencies and versioning are the top challenges for open\nsource Go module maintainers\u003c/strong\u003e. Open source module maintainers face\nchallenges in keeping their dependencies up to date and avoiding disruptions\ndue to versioning and breaking changes. This is an area we’ll explore\nfurther to help maintainers provide a stable and healthy ecosystem.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"how-to-read-these-results\"\u003eHow to read these results\u003c/h3\u003e\n\u003cp\u003eThroughout this post, we use charts of survey responses to provide supporting\nevidence for our findings. All of these charts use a similar format. The title\nis the exact question that survey respondents saw. Unless otherwise noted,\nquestions were multiple choice and participants could only select a single\nresponse choice; each chart’s subtitle will tell you if the question allowed\nmultiple response choices or was an open-ended text box instead of a multiple\nchoice question. For charts of open-ended text responses, a Go team member\nread and manually categorized all of the responses. Many open-ended questions\nelicited a wide variety of responses; to keep the chart sizes reasonable, we\ncondensed them to the top 10-15 themes, with additional themes all grouped\nunder “Other”. We also included a category for “None” where applicable.\u003c/p\u003e\n\u003cp\u003eTo help readers understand the weight of evidence underlying each finding, we\ninclude error bars showing the 95% confidence interval for responses; narrower\nbars indicate increased confidence. Sometimes two or more responses have\noverlapping error bars, which means the relative order of those responses is\nnot statistically meaningful (i.e., the responses are effectively tied). The\nlower right of each chart shows the number of people whose responses are\nincluded in the chart, in the form “\u003cem\u003en = [number of respondents]\u003c/em\u003e”.\u003c/p\u003e\n\u003ch3 id=\"a-note-on-methodology\"\u003eA note on methodology\u003c/h3\u003e\n\u003cp\u003eMost survey respondents “self-selected” to take the survey by accessing it\nthrough a link on \u003ca href=\"/blog\"\u003ethe Go blog\u003c/a\u003e, \u003ca href=\"https://twitter.com/golang\" rel=\"noreferrer\" target=\"_blank\"\u003e@golang on\nTwitter\u003c/a\u003e, or other social Go channels. People who\ndon’t follow these channels might respond differently from people who \u003cem\u003edo\u003c/em\u003e\nclosely follow them. About a quarter of respondents were randomly sampled,\nmeaning they responded to the survey after seeing a prompt for it in VS Code\n(everyone using the VS Code Go plugin between Jan 18 - Feb 8, 2023 had a 10%\nchance of receiving this random prompt). This randomly sampled group helps us\ngeneralize these findings to the larger community of Go developers. Most\nsurvey questions showed no meaningful difference between these groups, but in\nthe few cases with important differences, readers will see charts that break\ndown responses into “Random sample” and “Self-selected” groups.\u003c/p\u003e\n\u003ch2 id=\"taking-a-closer-look-at-different-groups-of-respondents\"\u003eTaking a closer look at different groups of respondents\u003c/h2\u003e\n\u003cp\u003eOur respondent demographics did not change significantly from \u003ca href=\"/blog/survey2022-q2-results\"\u003eour last\nsurvey\u003c/a\u003e. Consistent with previous\ncycles, Go is primarily used in the tech industry, and about 80% of\nrespondents said they program in Go at work. Overall, survey respondents\ntended to be satisfied with Go over the past year, with 92% saying they were\nsomewhat or very satisfied.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/where.svg\" alt=\"Bar chart\nshowing where respondents use Go\" class=\"chart\"/\u003e \u003cimg src=\"survey2023q1/csat.svg\" alt=\"Bar chart showing proportion of satisfied\nrespondents\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eOur respondents spend a lot of time programming in Go compared to other\nlanguages. About a third of respondents even maintain an open source Go\nmodule. We recognize that our survey audience is made up of those who\nsuccessfully adopted Go, use Go often, and are mostly satisfied using Go. To\nidentify potential gaps in meeting community needs, we look at different\nsub-groups of respondents to see how they might be using Go differently or\nhave different priorities. For example, this year we looked at how responses\ndiffer between different sample sources (i.e., the Go Blog or through the VS\nCode plugin), different job roles, organization sizes, and levels of Go\nexperience. The most interesting differences were between experience levels.\u003c/p\u003e\n\u003ch2 id=\"insights-from-novice-respondents\"\u003eInsights from novice respondents\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/go_exp.svg\" alt=\"Bar chart of years of experience using\nGo\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003ePreviously, we used how much time (in months / years) respondents have used Go\nas a proxy to gain insight into how results vary between levels of experience.\nThis year we experimented with a new segmentation question, “What is your\nlevel of experience with Go?”, to see if self-identification might be a more\nuseful way of examining Go experience than lumping together various intervals\nof time. Since categorical terms like “novice” or “expert” might vary from\nperson to person, we provided a description to help make these buckets more\nobjective. The options were:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAwareness: I’m aware of Go, but could not write a simple Go program without\nassistance\u003c/li\u003e\n\u003cli\u003eNovice: I can complete simple programming projects in Go, possibly with\nassistance\u003c/li\u003e\n\u003cli\u003eIntermediate: I can complete significant programming projects in Go with\nsome assistance\u003c/li\u003e\n\u003cli\u003eAdvanced: I can complete significant programming projects in Go without\nassistance\u003c/li\u003e\n\u003cli\u003eExpert: I can provide guidance, troubleshoot, and answer questions related\nto Go from other engineers\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/exp_level.svg\" alt=\"Bar chart of levels of experience\nusing Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe found a moderate correlation (⍴ = .66) between how long respondents had\nbeen using Go and their self-identified experience level. This means that the\nexperience level scale, although similar to the time scale, may give us some\nnew insights into how respondents differ by experience. For instance, the\nproportion of time that a respondent spends writing in Go compared to how much\ntime they spend writing in other languages is more strongly correlated with\ntheir self-identified experience level than with how long they’ve been using\nGo.\u003c/p\u003e\n\u003cp\u003eIn analyses where we use this segmentation we typically exclude the Awareness\ncategory since they wouldn’t be considered to have the experience necessary to\nanswer the question and only represented about 1% of respondents.\u003c/p\u003e\n\u003ch3 id=\"novice-respondents-are-more-likely-to-prefer-windows-than-more-experienced-respondents\"\u003eNovice respondents are more likely to prefer Windows than more experienced respondents\u003c/h3\u003e\n\u003cp\u003eOur randomly sampled group had a higher proportion of novice respondents than\nthe self-selected group, suggesting that there are more new Gophers out there\nthat we don’t tend to hear from as often. Because they are sampled through the\nGo VS Code plugin, we might expect this group to be more likely to prefer\nusing VS Code or to develop on Windows more than other experience levels.\nWhile this is true, novices are also more likely to develop on Windows than\nother experience levels, regardless of whether they responded through the VS\nCode plugin.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/exp_level_s.svg\" alt=\"Bar chart of levels of experience\nusing Go for self-selected and random samples\" class=\"chart\"/\u003e \u003cimg src=\"survey2023q1/editor_self_select_exp.svg\" alt=\"Bar chart of editor\npreference broken down by experience levels for self-selected group only\" class=\"chart\"/\u003e \u003cimg src=\"survey2023q1/os_dev_exp_s.svg\" alt=\"Bar chart of\nlevels of experience using Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThere could be a number of reasons why we don’t see higher proportions of\nWindows users at higher experience levels. For example, Windows users may be\nmore likely to experience difficulties and stop using Go, or there could be\nwider trends in OS usage that have nothing to do with Go. In any case, we\nshould include more Windows users in future research around getting started\nwith Go to make sure we provide an inclusive onboarding experience.\u003c/p\u003e\n\u003ch3 id=\"how-different-experience-levels-currently-use-go-and-other-areas-where-they-would-like-to\"\u003eHow different experience levels currently use Go (and other areas where they would like to)\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/go_app.svg\" alt=\"Bar chart of use cases\" class=\"chart\"/\u003e \u003cimg src=\"survey2023q1/go_app_exp.svg\" alt=\"Bar chart of use\ncases broken down by experience level\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eAccording to how respondents use Go right now, more experienced Gophers tend\nto be using Go for more types of applications. For example, the average expert\nused Go in at least four areas while the average novice used Go in only two\nareas. That’s why there are large differences in the proportion of novices and\nexperts using Go for each use case. The top two uses, API / RPC services and\nCLIs, however, are the top use cases across all experience levels.\u003c/p\u003e\n\u003cp\u003eWe see more interesting trends for GUIs and Website / Web services (returning\nHTML). All experience levels used Go for Desktop / GUI apps at about the same\nrate.  This gives us evidence the desire for GUIs isn’t just coming from new\nGophers looking for a fun starter project, but from across the experience\nspectrum.\u003c/p\u003e\n\u003cp\u003eWebsites / services returning HTML show a similar trend. One explanation could\nbe that this is a common use case early in someone’s Go journey (since it is\nin the top 3 most common for novices), or that novices are more likely to be\ndoing work on websites or web services returning HTML. Later in the survey, we\nasked respondents, “In which area (if any) are you not using Go, but would\nmost like to?” Although many respondents (29%) said they already use Go\neverywhere they would like to, the top two areas for expanding usage were GUI\n/ Desktop and AI / ML applications. This was consistent across groups at\ndifferent organization sizes and job roles, but not experience levels. The\nnumber one area where novices would like to use Go more is for websites / web\nservices returning HTML.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/app_opportunities_exp.svg\" alt=\"Bar chart of levels of\nexperience using Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eIn an open text question, 12 out of 29 respondents who said they would like to\nuse Go for websites / web services returning HTML said they were blocked\nbecause other languages had frameworks to better support this use case. It\ncould be that more experienced Go developers don’t try or expect to use Go for\nthis use case when other languages already have frameworks that meet those\nneeds. As one respondent put it,\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“It’s usually easier to accomplish this in other languages such as PHP or\nRuby. Partly due to the excellent frameworks that exist in those languages.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eAnother contributing explanation for novices’ interest in web development may\nbe related to their usage of JavaScript / TypeScript. Novices spend more of\ntheir time writing in JavaScript / TypeScript than more experienced\nrespondents. The higher interest in web could have something to do with what\nnovice respondents currently work on in other languages or could indicate a\ngeneral interest in web technologies. In the future we’d like to learn more\nabout this use case and how we can help new Gophers get started using Go in\nareas most useful to them.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/language_time_exp.svg\" alt=\"Bar chart of levels of\nexperience using Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"respondents-face-a-long-tail-of-challenges\"\u003eRespondents face a long tail of challenges\u003c/h2\u003e\n\u003cp\u003eEvery survey cycle we ask respondents what their biggest challenge is when\nusing Go. Historically, lack of generics was the most commonly cited\nchallenge—for example, it was the most common response in 2020, and mentioned\nby about 18% of respondents. Since the introduction of generics, error\nhandling (12%) and learning / best practices / docs (11%) have emerged at the\nfront of a long tail of issues rather than any single issue becoming more\nfrequent.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/text_biggest_challenge.svg\" alt=\"Bar chart of\nbiggest challenges\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"why-is-error-handling-such-a-challenge\"\u003eWhy is error handling such a challenge?\u003c/h3\u003e\n\u003cp\u003eFeedback on error handling often describes the problem as verbosity. On the\nsurface, this could reflect that writing repetitive code is boring or\nannoying. More than just an annoyance of writing boilerplate, however, error\nhandling may also impact respondents’ ability to debug.\u003c/p\u003e\n\u003cp\u003eOne respondent succinctly illustrated this issue:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Error handling creates clutter and easily masks problems if not done\ncorrectly (no stack traces)”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"the-struggle-to-learn-best-practices\"\u003eThe struggle to learn best practices\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Using Go effectively. Easy to learn, hard to master.”\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe’ve heard that Go is easy to learn, and a \u003ca href=\"/blog/survey2020-results#TOC_6.2\"\u003eprevious survey showed that over\n70%\u003c/a\u003e of respondents feel\nproductive using Go within their first year, but learning Go best practices\ncame up as one of the biggest challenges to using Go. Respondents this year\ntold us that best practices around \u003cstrong\u003ecode structure\u003c/strong\u003e and \u003cstrong\u003erecommended tools\nand libraries\u003c/strong\u003e aren’t well documented, creating challenges for beginners and\nteams to keep code consistent. Learning to write idiomatic Go can be\nespecially challenging to those coming from other programming paradigms.\nRespondents who were more experienced with Go attested that when developers\ndon’t follow best practices for writing idiomatic Go, it hurts the consistency\nand quality of shared projects.\u003c/p\u003e\n\u003ch2 id=\"the-biggest-challenges-for-module-maintainers\"\u003eThe biggest challenges for module maintainers\u003c/h2\u003e\n\u003cp\u003eGo module maintainers are critical members of the Go community, helping to\ngrow and sustain the health of our package ecosystem. This year we plan to\nconduct research with module maintainers to identify opportunities to support\nstability and growth of the package ecosystem and help grow Go adoption within\norganizations. To inform this research, we introduced a question on the survey\nto get an idea of the current top challenges for open source maintainers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/text_maintainer_challenge.svg\" alt=\"Bar chart of\nchallenges for open source module maintainers\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe top challenges for maintainers are keeping dependencies up to date and\ndifficulties around versioning, including avoiding, identifying, or knowing\nwhen to introduce breaking changes. These insights, along with the results of\nfuture research, will help inform strategies to support maintainers in keeping\nthe Go ecosystem stable and secure.\u003c/p\u003e\n\u003ch2 id=\"the-biggest-challenges-when-deploying-go-code\"\u003eThe biggest challenges when deploying Go code\u003c/h2\u003e\n\u003cp\u003eThis year we asked what respondents’ biggest challenge was when deploying Go\ncode. Being “easy to deploy” is often cited as a reason for using Go, but we\nreceived conflicting feedback during a recent study that prompted us to\nexplore potential issues when deploying Go code. In our open text responses,\nby far the most common theme was difficulty cross-compiling with cgo (16%),\nand support for WebAssembly or WASI was a distant second (7%).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/text_deploy_challenge.svg\" alt=\"Bar chart of challenges\nfor open source module maintainers\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"community-priorities-what-respondents-want-most\"\u003eCommunity priorities: what respondents want most\u003c/h2\u003e\n\u003cp\u003eThis year we used a prioritization question we’ve used in previous surveys\nbased on the buy-a-feature method of prioritization. Respondents were given 10\n“gophercoins” and asked to distribute them to areas where they want to see\nimprovements. Respondents were randomly assigned one of three possible\nquestions, each containing seven items related to tooling, security, or\ncompiler \u0026amp; runtime. This approach allowed us to ask about items relevant to\neach focus area without overburdening respondents with three sets of\ncognitively-demanding prioritization questions.\u003c/p\u003e\n\u003cp\u003eAt the end of the exercise, we gave respondents an open text prompt to tell us\nabout any area they thought should be the Go team’s top priority in the next\nyear, regardless of which items they spent their coins on. For example, if a\nrespondent was shown the security section, but they didn’t care all that much\nabout security, they still had the opportunity to tell us that in the open\ntext area.\u003c/p\u003e\n\u003ch3 id=\"security\"\u003eSecurity\u003c/h3\u003e\n\u003cp\u003eWe chose these items to test assumptions we held on the relative importance of\nsecurity practices to the community. These were the seven items as described\nto participants:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003epkg.go.dev identifies packages that are poorly maintained (e.g.,\nunresponsive to issues, fail to keep their dependencies updated, remain\nvulnerable for long periods of time)\u003c/li\u003e\n\u003cli\u003epkg.go.dev identifies packages that make breaking API changes (i.e.,\nrequires fixing uses of those APIs when upgrading those packages to newer\nversions)\u003c/li\u003e\n\u003cli\u003eSupport for suppressing vulnerabilities in govulncheck\u003c/li\u003e\n\u003cli\u003eA tool to track how sensitive data flows through a Go program (detect PII\nleaks)\u003c/li\u003e\n\u003cli\u003eA security best practices guide (e.g., how to choose and update\ndependencies; how to set up fuzzing, vulnerability checking, and thread\nsanitizer; how to use crypto)\u003c/li\u003e\n\u003cli\u003eSecure-by-default Web \u0026amp; SQL libraries that help users avoid introducing\nvulnerabilities in web server code\u003c/li\u003e\n\u003cli\u003eFIPS-140-compliant cryptographic libraries\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/prioritization_security.svg\" alt=\"Bar chart of where\nrespondents spent the most on security issues\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe highest funded security feature was for web \u0026amp; SQL libraries to be secure\nby default to avoid introducing vulnerabilities in web server code, but the\ntop four features all relate to avoiding the introduction of vulnerabilities.\nThe desire for secure defaults is consistent with previous security research\nthat showed developers want to “shift left” on security: development teams\noften don’t have time or resources to spend on addressing security issues, and\nthus value tooling that reduces the likelihood of introducing them in the\nfirst place. The second most common item was a security best practices guide,\nhighlighting the high value of best practices documentation compared to new\ntools or features to the majority of respondents.\u003c/p\u003e\n\u003ch3 id=\"tools\"\u003eTools\u003c/h3\u003e\n\u003cp\u003eItems we included in this question were inspired by feedback from VS Code\nplugin users. We wanted to know which tooling and IDE improvements would be\nmost helpful to a wider audience who may use other IDEs or editors.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBetter refactoring tools (e.g., support for automatic code transformation:\nrenamings, function extraction, API migration, etc.)\u003c/li\u003e\n\u003cli\u003eBetter support for testing in your code editor/IDE (e.g., robust and\nscalable Test Explorer UI, 3rd party test framework, subtest support, code\ncoverage)\u003c/li\u003e\n\u003cli\u003eBetter support for working on multiple modules in your code editor/IDE\n(e.g., editing modules A and B, where module A depends on module B)\u003c/li\u003e\n\u003cli\u003eDependency insights in pkg.go.dev (e.g., vulnerabilities, breaking changes,\nscorecards)\u003c/li\u003e\n\u003cli\u003eDependency insights in your code editor/IDE (e.g., vulnerabilities, breaking\nchanges, scorecards)\u003c/li\u003e\n\u003cli\u003eSupport for publishing modules with new module paths (e.g., repo ownership\nhandoff)\u003c/li\u003e\n\u003cli\u003eSupport finding types that implement an interface \u0026amp; interfaces implemented\nby a type in your code editor/IDE\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/prioritization_tooling.svg\" alt=\"Bar chart of where\nrespondents spent the most on tooling\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe most funded editor feature was \u003cem\u003esupport for finding types that implement\nan interface and interfaces implemented by a type\u003c/em\u003e and \u003cem\u003erefactoring tools\u003c/em\u003e. We\nalso saw an interesting difference in how respondents spent their gophercoins\naccording to preferred editor usage. Most notably, VS Code users spent more\ngophercoins on refactoring than GoLand users, suggesting that automatic code\ntransformations are currently better supported in GoLand than in VS Code.\u003c/p\u003e\n\u003ch3 id=\"compiler--runtime\"\u003eCompiler \u0026amp; runtime\u003c/h3\u003e\n\u003cp\u003eOur key question for this section was to determine whether respondents wanted\nbetter performance by default, better optimization tooling, or just a better\nunderstanding of how to write performant Go code.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eReduce compute costs\u003c/li\u003e\n\u003cli\u003eReduce memory use\u003c/li\u003e\n\u003cli\u003eReduce binary size\u003c/li\u003e\n\u003cli\u003eReduce build times\u003c/li\u003e\n\u003cli\u003eBetter performance debugging tools\u003c/li\u003e\n\u003cli\u003eAn optimization guide (how to improve performance and reduce costs, covering\nGo’s implementation and performance debugging tools)\u003c/li\u003e\n\u003cli\u003eBetter support for using cgo when cross-compiling\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"survey2023q1/prioritization_core.svg\" alt=\"Bar chart of where\nrespondents spent the most on compiler and runtime improvements\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eBy far the most funded item in this list was an optimization guide. This was\nconsistent across organization size, job role, and experience level. We asked\nan additional question about whether respondents had resource costs concerns.\nMost respondents (55%) said they did not have any cost concerns, but those who\nhad concerns about resource costs spent more gophercoins (on average, 2.0) on\nreducing compute costs and memory costs than those who did not. However, even\nthose who were concerned about resource costs still spent about as much on the\noptimization guide (on average 1.9 gophercoins). This is a strong signal that\nproviding guidance for Go developers to understand and optimize Go performance\nis currently more valuable than additional compiler and runtime performance\nimprovements.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThank you for joining us in reviewing the results of our first developer\nsurvey of 2023! Understanding developers’ experiences and challenges helps us\nprioritize how to best serve the Go community. Some takeaways we found\nparticularly useful:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eNovice Go developers have more of an affinity for web development than\nrespondents of other levels of experience. This is an area we’d like to\nexplore further to make sure we’re meeting the needs of new Go developers.\u003c/li\u003e\n\u003cli\u003eSecure defaults, best practice guidance on security and optimization, and\nmore refactoring assistance in IDEs would be valuable additions to the\ncommunity.\u003c/li\u003e\n\u003cli\u003eError handling is a high priority issue for the community and creates\nchallenges in terms of verbosity and debuggability. The Go team doesn’t have\na public proposal to share at this time but is continuing to explore options\nto improve error handling.\u003c/li\u003e\n\u003cli\u003eOnboarding and learning best practices are among the top challenges for\nrespondents and will be areas of future research.\u003c/li\u003e\n\u003cli\u003eFor Go module maintainers, keeping dependencies up to date, module\nversioning, and identifying or avoiding breaking changes are the biggest\nchallenges. Helping maintainers provide a stable and healthy ecosystem is\nanother topic of interest for further UX research.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThanks again to everyone who responded and contributed to this survey—we\ncouldn’t have done it without you. We hope to see you later this year for the\nnext survey.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-05-11T00:00:00Z",
  "Author": "Alice Merrick"
}