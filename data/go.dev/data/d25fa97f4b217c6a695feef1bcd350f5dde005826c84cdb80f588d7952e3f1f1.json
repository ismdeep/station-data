{
  "Source": "go.dev",
  "Title": "Evolving the Go Standard Library with math/rand/v2",
  "Link": "https://go.dev/blog/randv2",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/randv2\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eEvolving the Go Standard Library with math/rand/v2\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      1 May 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eSince Go 1 was \u003ca href=\"/blog/go1\"\u003ereleased in March 2012\u003c/a\u003e,\nchanges to the standard library have been\nconstrained by Go’s \u003ca href=\"/doc/go1compat\"\u003ecompatibility promise\u003c/a\u003e.\nOverall, compatibility has been a boon for Go users,\nproviding a stable base for production systems,\ndocumentation, tutorials, books, and more.\nOver time, however, we’ve realized mistakes in the original APIs\nthat cannot be fixed compatibly; in other cases,\nbest practices and convention have changed.\nWe need a plan for making important, breaking changes too.\u003c/p\u003e\n\u003cp\u003eThis blog post is about Go 1.22’s new \u003ca href=\"/pkg/math/rand/v2/\"\u003e\u003ccode\u003emath/rand/v2\u003c/code\u003e\u003c/a\u003e package,\nthe first “v2” in the standard library.\nIt brings needed improvements to the \u003ca href=\"/pkg/math/rand/\"\u003e\u003ccode\u003emath/rand\u003c/code\u003e\u003c/a\u003e API,\nbut more importantly it sets an example for how we can\nrevise other standard library packages as the need arises.\u003c/p\u003e\n\u003cp\u003e(In Go, \u003ccode\u003emath/rand\u003c/code\u003e and \u003ccode\u003emath/rand/v2\u003c/code\u003e are two different packages\nwith different import paths.\nGo 1 and every release after it have included \u003ccode\u003emath/rand\u003c/code\u003e; Go 1.22 added \u003ccode\u003emath/rand/v2\u003c/code\u003e.\nA Go program can import either package, or both.)\u003c/p\u003e\n\u003cp\u003eThis post discusses the specific rationale for the changes in \u003ccode\u003emath/rand/v2\u003c/code\u003e\nand then \u003ca href=\"#principles\"\u003ereflects on the general principles\u003c/a\u003e that will guide\nnew versions of other packages.\u003c/p\u003e\n\u003ch2 id=\"pseudo\"\u003ePseudorandom Number Generators\u003c/h2\u003e\n\u003cp\u003eBefore we look at \u003ccode\u003emath/rand\u003c/code\u003e, which is an API for a pseudorandom number generator,\nlet’s take a moment to understand what that means.\u003c/p\u003e\n\u003cp\u003eA pseudorandom number generator is a deterministic program\nthat generates a long sequence of\nseemingly random numbers from a small seed input,\nalthough the numbers are not in fact random at all.\nIn the case of \u003ccode\u003emath/rand\u003c/code\u003e, the seed is a single int64,\nand the algorithm produces a sequence of int64s\nusing a variant of a\n\u003ca href=\"https://en.wikipedia.org/wiki/Linear-feedback_shift_register\" rel=\"noreferrer\" target=\"_blank\"\u003elinear-feedback shift register (LFSR)\u003c/a\u003e.\nThe algorithm is based on an idea by George Marsaglia,\ntweaked by Don Mitchell and Jim Reeds,\nand further customized by Ken Thompson for Plan 9 and then Go.\nIt has no official name, so this post calls it the Go 1 generator.\u003c/p\u003e\n\u003cp\u003eThe goal is for these generators to be fast,\nrepeatable, and random enough to support simulations,\nshuffling, and other non-cryptographic use cases.\nRepeatability is particularly important for uses like\nnumerical simulations or randomized testing.\nFor example, a randomized tester might pick a seed\n(perhaps based on the current time), generate\na large random test input, and repeat.\nWhen the tester finds a failure, it only needs to print the seed\nto allow repeating the test with that specific large input.\u003c/p\u003e\n\u003cp\u003eRepeatability also matters over time: given a particular\nseed, a new version of Go needs to generate the same\nsequence of values that an older version did.\nWe didn’t realize this when we released Go 1;\ninstead, we discovered it the hard way,\nwhen we tried to make a change in Go 1.2\nand got reports that we had broken certain tests\nand other use cases.\nAt that point, we decided Go 1 compatibility included\nthe specific random outputs for a given seed\nand \u003ca href=\"/change/5aca0514941ce7dd0f3cea8d8ffe627dbcd542ca\"\u003eadded a test\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIt is not a goal for these kinds of generators to produce\nrandom numbers suitable for deriving cryptographic keys\nor other important secrets.\nBecause the seed is only 63 bits,\nany output drawn from the generator, no matter how long,\nwill also only contain 63 bits of entropy.\nFor example, using \u003ccode\u003emath/rand\u003c/code\u003e to generate a 128-bit or 256-bit AES key\nwould be a serious mistake,\nsince the key would be easier to brute force.\nFor that kind of use, you need a cryptographically strong\nrandom number generator, as provided by \u003ca href=\"/pkg/crypto/rand/\"\u003e\u003ccode\u003ecrypto/rand\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThat’s enough background that we can move on to what needed\nfixing in the \u003ccode\u003emath/rand\u003c/code\u003e package.\u003c/p\u003e\n\u003ch2 id=\"problems\"\u003eProblems with \u003ccode\u003emath/rand\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eOver time, we noticed more and more problems with \u003ccode\u003emath/rand\u003c/code\u003e.\nThe most serious were the following.\u003c/p\u003e\n\u003ch3 id=\"problem.generator\"\u003eGenerator Algorithm\u003c/h3\u003e\n\u003cp\u003eThe generator itself needed replacement.\u003c/p\u003e\n\u003cp\u003eThe initial implementation of Go, while production ready, was in many ways a “pencil sketch”\nof the entire system, working well enough to serve as a base for future development:\nthe compiler and runtime were written in C; the garbage collector was a conservative, single-threaded,\nstop-the-world collector; and the libraries used basic implementations throughout.\nFrom Go 1 through around Go 1.5, we went back and drew the “fully inked”\nversion of each of these: we converted the compiler and runtime to Go; we wrote a new, precise, parallel,\nconcurrent garbage collection with microsecond pause times; and we replaced\nstandard library implementations with more sophisticated, optimized algorithms\nas needed.\u003c/p\u003e\n\u003cp\u003eUnfortunately, the repeatability requirement in \u003ccode\u003emath/rand\u003c/code\u003e\nmeant that we couldn’t replace the generator there without\nbreaking compatibility.\nWe were stuck with the Go 1 generator,\nwhich is reasonably fast (about 1.8ns per number on my M3 Mac)\nbut maintains an internal state of almost 5 kilobytes.\nIn contrast, Melissa O’Neill’s \u003ca href=\"https://www.pcg-random.org/\" rel=\"noreferrer\" target=\"_blank\"\u003ePCG family of generators\u003c/a\u003e\ngenerates better random numbers in about 2.1ns per number\nwith only 16 bytes of internal state.\nWe also wanted to explore using\nDaniel J. Bernstein’s \u003ca href=\"https://cr.yp.to/chacha.html\" rel=\"noreferrer\" target=\"_blank\"\u003eChaCha stream cipher\u003c/a\u003e\nas a generator.\nA \u003ca href=\"/blog/chacha8rand\"\u003efollow-up post\u003c/a\u003e discusses that generator specifically.\u003c/p\u003e\n\u003ch3 id=\"problem.source\"\u003eSource Interface\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/math/rand/#Source\"\u003e\u003ccode\u003erand.Source\u003c/code\u003e interface\u003c/a\u003e was wrong.\nThat interface defines the\nconcept of a low-level random number generator that generates\nnon-negative \u003ccode\u003eint64\u003c/code\u003e values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e% go doc -src math/rand.Source\npackage rand // import \u0026#34;math/rand\u0026#34;\n\n// A Source represents a source of uniformly-distributed\n// pseudo-random int64 values in the range [0, 1\u0026lt;\u0026lt;63).\n//\n// A Source is not safe for concurrent use by multiple goroutines.\ntype Source interface {\n    Int63() int64\n    Seed(seed int64)\n}\n\nfunc NewSource(seed int64) Source\n%\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(In the doc comment, “[0, N)” denotes a\n\u003ca href=\"https://en.wikipedia.org/wiki/Interval_(mathematics)#Definitions_and_terminology\" rel=\"noreferrer\" target=\"_blank\"\u003ehalf-open interval\u003c/a\u003e,\nmeaning the range includes 0 but ends just before 2⁶³.)\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/math/rand/#Rand\"\u003e\u003ccode\u003erand.Rand\u003c/code\u003e type\u003c/a\u003e wraps a \u003ccode\u003eSource\u003c/code\u003e\nto implement a richer set of operations, such as\ngenerating \u003ca href=\"/pkg/math/rand/#Rand.Intn\"\u003ean integer between 0 and N\u003c/a\u003e,\ngenerating \u003ca href=\"/pkg/math/rand/#Rand.Float64\"\u003efloating-point numbers\u003c/a\u003e, and so on.\u003c/p\u003e\n\u003cp\u003eWe defined the \u003ccode\u003eSource\u003c/code\u003e interface to return a shortened 63-bit value\ninstead of a uint64 because that’s what the Go 1 generator and\nother widely-used generators produce,\nand it matches the convention set by the C standard library.\nBut this was a mistake: more modern generators produce full-width uint64s,\nwhich is a more convenient interface.\u003c/p\u003e\n\u003cp\u003eAnother problem is the \u003ccode\u003eSeed\u003c/code\u003e method hard-coding an \u003ccode\u003eint64\u003c/code\u003e seed:\nsome generators are seeded by larger values,\nand the interface provides no way to handle that.\u003c/p\u003e\n\u003ch3 id=\"problem.seed\"\u003eSeeding Responsibility\u003c/h3\u003e\n\u003cp\u003eA bigger problem with \u003ccode\u003eSeed\u003c/code\u003e is that responsibility for seeding the global generator was unclear.\nMost users don’t use \u003ccode\u003eSource\u003c/code\u003e and \u003ccode\u003eRand\u003c/code\u003e directly.\nInstead, the \u003ccode\u003emath/rand\u003c/code\u003e package provides a global generator\naccessed by top-level functions like \u003ca href=\"/pkg/math/rand/#Intn\"\u003e\u003ccode\u003eIntn\u003c/code\u003e\u003c/a\u003e.\nFollowing the C standard library, the global generator defaults to\nbehaving as if \u003ccode\u003eSeed(1)\u003c/code\u003e is called at startup.\nThis is good for repeatability but bad for programs that want\ntheir random outputs to be different from one run to the next.\nThe package documentation suggests using \u003ccode\u003erand.Seed(time.Now().UnixNano())\u003c/code\u003e in that case,\nto make the generator’s output time-dependent,\nbut what code should do this?\u003c/p\u003e\n\u003cp\u003eProbably the main package should be in charge of how \u003ccode\u003emath/rand\u003c/code\u003e is seeded:\nit would be unfortunate for imported libraries to configure global state themselves,\nsince their choices might conflict with other libraries or the main package.\nBut what happens if a library needs some random data and wants to use \u003ccode\u003emath/rand\u003c/code\u003e?\nWhat if the main package doesn’t even know \u003ccode\u003emath/rand\u003c/code\u003e is being used?\nWe found that in practice many libraries add init functions\nthat seed the global generator with the current time, “just to be sure”.\u003c/p\u003e\n\u003cp\u003eLibrary packages seeding the global generator themselves causes a new problem.\nSuppose package main imports two packages that both use \u003ccode\u003emath/rand\u003c/code\u003e:\npackage A assumes the global generator will be seeded by package main,\nbut package B seeds it in an \u003ccode\u003einit\u003c/code\u003e func.\nAnd suppose that package main doesn’t seed the generator itself.\nNow package A’s correct operation depends on the coincidence that package B is also\nimported in the program.\nIf package main stops importing package B, package A will stop getting random values.\nWe observed this happening in practice in large codebases.\u003c/p\u003e\n\u003cp\u003eIn retrospect, it was clearly a mistake to follow the C standard library here:\nseeding the global generator automatically would remove the confusion\nabout who seeds it, and users would stop being surprised by repeatable\noutput when they didn’t want that.\u003c/p\u003e\n\u003ch3 id=\"problem.scale\"\u003eScalability\u003c/h3\u003e\n\u003cp\u003eThe global generator also did not scale well.\nBecause top-level functions like \u003ca href=\"/pkg/math/rand/#Intn\"\u003e\u003ccode\u003erand.Intn\u003c/code\u003e\u003c/a\u003e\ncan be called simultaneously from multiple goroutines,\nthe implementation needed a lock protecting the shared generator state.\nIn parallel usage, acquiring and releasing this lock was more expensive\nthan the actual generation.\nIt would make sense instead to have a per-thread generator state,\nbut doing so would break repeatability\nin programs without concurrent use of \u003ccode\u003emath/rand\u003c/code\u003e.\u003c/p\u003e\n\u003ch3 id=\"problem.rand\"\u003eThe \u003ccode\u003eRand\u003c/code\u003e implementation was missing important optimizations\u003c/h3\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/math/rand/#Rand\"\u003e\u003ccode\u003erand.Rand\u003c/code\u003e type\u003c/a\u003e wraps a \u003ccode\u003eSource\u003c/code\u003e\nto implement a richer set of operations.\nFor example, here is the Go 1 implementation of \u003ccode\u003eInt63n\u003c/code\u003e, which returns\na random integer in the range [0, \u003ccode\u003en\u003c/code\u003e).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (r *Rand) Int63n(n int64) int64 {\n    if n \u0026lt;= 0 {\n        panic(\u0026#34;invalid argument to Int63n\u0026#34;)\n    }\n    max := int64((1\u0026lt;\u0026lt;63 - 1)  - (1\u0026lt;\u0026lt;63)%uint64(n))\n    v := r.src.Int63()\n    for v \u0026gt; max {\n        v = r.Int63()\n    }\n    return v % n\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe actual conversion is easy: \u003ccode\u003ev % n\u003c/code\u003e.\nHowever, no algorithm can convert 2⁶³ equally likely values\ninto \u003ccode\u003en\u003c/code\u003e equally likely values unless 2⁶³ is a multiple of \u003ccode\u003en\u003c/code\u003e:\notherwise some outputs will necessarily happen more often\nthan others. (As a simpler example, try converting 4 equally likely values into 3.)\nThe code computes \u003ccode\u003emax\u003c/code\u003e such that\n\u003ccode\u003emax+1\u003c/code\u003e is the largest multiple of \u003ccode\u003en\u003c/code\u003e less than or equal to 2⁶³,\nand then the loop rejects random values greater than or equal to \u003ccode\u003emax+1\u003c/code\u003e.\nRejecting these too-large values ensures that all \u003ccode\u003en\u003c/code\u003e outputs are equally likely.\nFor small \u003ccode\u003en\u003c/code\u003e, needing to reject any value at all is rare;\nrejection becomes more common and more important for larger values.\nEven without the rejection loop, the two (slow) modulus operations\ncan make the conversion more expensive than generating the random value \u003ccode\u003ev\u003c/code\u003e\nin the first place.\u003c/p\u003e\n\u003cp\u003eIn 2018, \u003ca href=\"https://arxiv.org/abs/1805.10941\" rel=\"noreferrer\" target=\"_blank\"\u003eDaniel Lemire found an algorithm\u003c/a\u003e\nthat avoids the divisions nearly all the time\n(see also his \u003ca href=\"https://lemire.me/blog/2019/06/06/nearly-divisionless-random-integer-generation-on-various-systems/\" rel=\"noreferrer\" target=\"_blank\"\u003e2019 blog post\u003c/a\u003e).\nIn \u003ccode\u003emath/rand\u003c/code\u003e, adopting Lemire’s algorithm would make \u003ccode\u003eIntn(1000)\u003c/code\u003e 20-30% faster,\nbut we can’t: the faster algorithm generates different values than the standard conversion,\nbreaking repeatability.\u003c/p\u003e\n\u003cp\u003eOther methods are also slower than they could be, constrained by repeatability.\nFor example, the \u003ccode\u003eFloat64\u003c/code\u003e method could easily be sped up by about 10%\nif we could change the generated value stream.\n(This was the change we tried to make in Go 1.2 and rolled back, mentioned earlier.)\u003c/p\u003e\n\u003ch3 id=\"problem.read\"\u003eThe \u003ccode\u003eRead\u003c/code\u003e Mistake\u003c/h3\u003e\n\u003cp\u003eAs mentioned earlier, \u003ccode\u003emath/rand\u003c/code\u003e is not intended for\nand not suitable for generating cryptographic secrets.\nThe \u003ccode\u003ecrypto/rand\u003c/code\u003e package does that, and its fundamental\nprimitive is its \u003ca href=\"/pkg/crypto/rand/#Read\"\u003e\u003ccode\u003eRead\u003c/code\u003e function\u003c/a\u003e\nand \u003ca href=\"/pkg/crypto/rand/#Reader\"\u003e\u003ccode\u003eReader\u003c/code\u003e\u003c/a\u003e variable.\u003c/p\u003e\n\u003cp\u003eIn 2015, we accepted a proposal to make\n\u003ccode\u003erand.Rand\u003c/code\u003e implement \u003ccode\u003eio.Reader\u003c/code\u003e as well,\nalong with \u003ca href=\"/pkg/math/rand/#Read\"\u003eadding a top-level \u003ccode\u003eRead\u003c/code\u003e function\u003c/a\u003e.\nThis seemed reasonable at the time,\nbut in retrospect we did not pay enough attention to the\nsoftware engineering aspects of this change.\nNow, if you want to read random data, you have\ntwo choices: \u003ccode\u003emath/rand.Read\u003c/code\u003e and \u003ccode\u003ecrypto/rand.Read\u003c/code\u003e.\nIf the data is going to be used for key material,\nit is very important to use \u003ccode\u003ecrypto/rand\u003c/code\u003e,\nbut now it is possible to use \u003ccode\u003emath/rand\u003c/code\u003e instead,\npotentially with disastrous consequences.\u003c/p\u003e\n\u003cp\u003eTools like \u003ccode\u003egoimports\u003c/code\u003e and \u003ccode\u003egopls\u003c/code\u003e have a special case\nto make sure they prefer to use \u003ccode\u003erand.Read\u003c/code\u003e from\n\u003ccode\u003ecrypto/rand\u003c/code\u003e instead of \u003ccode\u003emath/rand\u003c/code\u003e, but that’s not a complete fix.\nIt would be better to remove \u003ccode\u003eRead\u003c/code\u003e entirely.\u003c/p\u003e\n\u003ch2 id=\"fix.v1\"\u003eFixing \u003ccode\u003emath/rand\u003c/code\u003e directly\u003c/h2\u003e\n\u003cp\u003eMaking a new, incompatible major version of a package is never our first choice:\nthat new version only benefits programs that switch to it,\nleaving all existing usage of the old major version behind.\nIn contrast, fixing a problem in the existing package has much more impact,\nsince it fixes all the existing usage.\nWe should never create a \u003ccode\u003ev2\u003c/code\u003e without doing as much as possible to fix \u003ccode\u003ev1\u003c/code\u003e.\nIn the case of \u003ccode\u003emath/rand\u003c/code\u003e, we were able to partly address\na few of the problems described above:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGo 1.8 introduced an optional \u003ca href=\"/pkg/math/rand/#Uint64\"\u003e\u003ccode\u003eSource64\u003c/code\u003e interface\u003c/a\u003e with a \u003ccode\u003eUint64\u003c/code\u003e method.\nIf a \u003ccode\u003eSource\u003c/code\u003e also implements \u003ccode\u003eSource64\u003c/code\u003e, then \u003ccode\u003eRand\u003c/code\u003e uses that method\nwhen appropriate.\nThis “extension interface” pattern provides a compatible (if slightly awkward)\nway to revise an interface after the fact.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGo 1.20 automatically seeded the top-level generator and\ndeprecated \u003ca href=\"/pkg/math/rand/#Seed\"\u003e\u003ccode\u003erand.Seed\u003c/code\u003e\u003c/a\u003e.\nAlthough this may seem like an incompatible change\ngiven our focus on repeatability of the output stream,\n\u003ca href=\"/issue/56319\"\u003ewe reasoned\u003c/a\u003e that any imported package that called \u003ca href=\"/pkg/math/rand/#Int\"\u003e\u003ccode\u003erand.Int\u003c/code\u003e\u003c/a\u003e\nat init time or inside any computation would also\nvisibly change the output stream, and surely adding or removing\nsuch a call cannot be considered a breaking change.\nAnd if that’s true, then auto-seeding is no worse,\nand it would eliminate this source of fragility for future programs.\nWe also added a \u003ca href=\"/doc/godebug\"\u003eGODEBUG setting\u003c/a\u003e to opt\nback into the old behavior.\nThen we marked the top-level \u003ccode\u003erand.Seed\u003c/code\u003e as \u003ca href=\"/wiki/Deprecated\"\u003edeprecated\u003c/a\u003e.\n(Programs that need seeded repeatability can still use\n\u003ccode\u003erand.New(rand.NewSource(seed))\u003c/code\u003e to obtain a local generator\ninstead of using the global one.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eHaving eliminated repeatability of the global output stream,\nGo 1.20 was also able to make the global generator scale better\nin programs that don’t call \u003ccode\u003erand.Seed\u003c/code\u003e,\nreplacing the Go 1 generator with a very cheap per-thread\n\u003ca href=\"https://github.com/wangyi-fudan/wyhash\" rel=\"noreferrer\" target=\"_blank\"\u003ewyrand generator\u003c/a\u003e\nalready used inside the Go runtime. This removed the global mutex\nand made the top-level functions scale much better.\nPrograms that do call \u003ccode\u003erand.Seed\u003c/code\u003e fall back to the\nmutex-protected Go 1 generator.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe were able to adopt Lemire’s optimization in the Go runtime,\nand we also used it inside \u003ca href=\"/pkg/math/rand/#Shuffle\"\u003e\u003ccode\u003erand.Shuffle\u003c/code\u003e\u003c/a\u003e,\nwhich was implemented after Lemire’s paper was published.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAlthough we couldn’t remove \u003ca href=\"/pkg/math/rand/#Read\"\u003e\u003ccode\u003erand.Read\u003c/code\u003e\u003c/a\u003e entirely,\nGo 1.20 marked it \u003ca href=\"/wiki/Deprecated\"\u003edeprecated\u003c/a\u003e in favor of\n\u003ccode\u003ecrypto/rand\u003c/code\u003e.\nWe have since heard from people who discovered that they were accidentally\nusing \u003ccode\u003emath/rand.Read\u003c/code\u003e in cryptographic contexts when their editors\nflagged the use of the deprecated function.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese fixes are imperfect and incomplete but also real improvements\nthat helped all users of the existing \u003ccode\u003emath/rand\u003c/code\u003e package.\nFor more complete fixes, we needed to turn our attention to \u003ccode\u003emath/rand/v2\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"fix.v2\"\u003eFixing the rest in \u003ccode\u003emath/rand/v2\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eDefining \u003ccode\u003emath/rand/v2\u003c/code\u003e took\nsignificant planning,\nthen a \u003ca href=\"/issue/60751\"\u003eGitHub Discussion\u003c/a\u003e\nand then a \u003ca href=\"/issue/61716\"\u003eproposal discussion\u003c/a\u003e.\nIt is the same\nas \u003ccode\u003emath/rand\u003c/code\u003e with the following breaking changes\naddressing the problems outlined above:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eWe removed the Go 1 generator entirely, replacing it with two new generators,\n\u003ca href=\"/pkg/math/rand/v2/#PCG\"\u003ePCG\u003c/a\u003e and \u003ca href=\"/pkg/math/rand/v2/#ChaCha8\"\u003eChaCha8\u003c/a\u003e.\nThe new types are named for their algorithms (avoiding the generic name \u003ccode\u003eNewSource\u003c/code\u003e)\nso that if another important algorithm needs to be added, it will fit well into the\nnaming scheme.\u003c/p\u003e\n\u003cp\u003eAdopting a suggestion from the proposal discussion, the new types implement the\n\u003ca href=\"/pkg/encoding/#BinaryMarshaler\"\u003e\u003ccode\u003eencoding.BinaryMarshaler\u003c/code\u003e\u003c/a\u003e\nand\n\u003ca href=\"/pkg/encoding/#BinaryUnmarshaler\"\u003e\u003ccode\u003eencoding.BinaryUnmarshaler\u003c/code\u003e\u003c/a\u003e\ninterfaces.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe changed the \u003ccode\u003eSource\u003c/code\u003e interface, replacing the \u003ccode\u003eInt63\u003c/code\u003e method with a \u003ccode\u003eUint64\u003c/code\u003e method\nand deleting the \u003ccode\u003eSeed\u003c/code\u003e method. Implementations that support seeding can provide\ntheir own concrete methods, like \u003ca href=\"/pkg/math/rand/v2/#PCG.Seed\"\u003e\u003ccode\u003ePCG.Seed\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/math/rand/v2/#ChaCha8.Seed\"\u003e\u003ccode\u003eChaCha8.Seed\u003c/code\u003e\u003c/a\u003e.\nNote that the two take different seed types, and neither is a single \u003ccode\u003eint64\u003c/code\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe removed the top-level \u003ccode\u003eSeed\u003c/code\u003e function: the global functions like \u003ccode\u003eInt\u003c/code\u003e can only be used\nin auto-seeded form now.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRemoving the top-level \u003ccode\u003eSeed\u003c/code\u003e also let us hard-code the use of scalable,\nper-thread generators by the top-level methods,\navoiding a GODEBUG check at each use.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe implemented Lemire’s optimization for \u003ccode\u003eIntn\u003c/code\u003e and related functions.\nThe concrete \u003ccode\u003erand.Rand\u003c/code\u003e API is now locked in to that value stream,\nso we will not be able to take advantage of any optimizations yet to be discovered,\nbut at least we are up to date once again.\nWe also implemented the \u003ccode\u003eFloat32\u003c/code\u003e and \u003ccode\u003eFloat64\u003c/code\u003e optimizations we wanted to use back in Go 1.2.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDuring the proposal discussion, a contributor pointed out detectable bias in the\nimplementations of \u003ccode\u003eExpFloat64\u003c/code\u003e and \u003ccode\u003eNormFloat64\u003c/code\u003e.\nWe fixed that bias and locked in the new value streams.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003ePerm\u003c/code\u003e and \u003ccode\u003eShuffle\u003c/code\u003e used different shuffling algorithms and produced different value streams,\nbecause \u003ccode\u003eShuffle\u003c/code\u003e happened second and used a faster algorithm.\nDeleting \u003ccode\u003ePerm\u003c/code\u003e entirely would have made migration harder for users.\nInstead we implemented \u003ccode\u003ePerm\u003c/code\u003e in terms of \u003ccode\u003eShuffle\u003c/code\u003e, which still lets us\ndelete an implementation.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe renamed \u003ccode\u003eInt31\u003c/code\u003e, \u003ccode\u003eInt63\u003c/code\u003e, \u003ccode\u003eIntn\u003c/code\u003e, \u003ccode\u003eInt31n\u003c/code\u003e, and \u003ccode\u003eInt63n\u003c/code\u003e to\n\u003ccode\u003eInt32\u003c/code\u003e, \u003ccode\u003eInt64\u003c/code\u003e, \u003ccode\u003eIntN\u003c/code\u003e, \u003ccode\u003eInt32N\u003c/code\u003e, and \u003ccode\u003eInt64N\u003c/code\u003e.\nThe 31 and 63 in the names were unnecessarily pedantic\nand confusing, and the capitalized N is more idiomatic for a second\n“word” in the name in Go.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eWe added \u003ccode\u003eUint\u003c/code\u003e, \u003ccode\u003eUint32\u003c/code\u003e, \u003ccode\u003eUint64\u003c/code\u003e, \u003ccode\u003eUintN\u003c/code\u003e, \u003ccode\u003eUint32N\u003c/code\u003e, and \u003ccode\u003eUint64N\u003c/code\u003e\ntop-level functions and methods.\nWe needed to add \u003ccode\u003eUint64\u003c/code\u003e to provide direct access to the core \u003ccode\u003eSource\u003c/code\u003e\nfunctionality, and it seemed inconsistent not to add the others.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eAdopting another suggestion from the proposal discussion,\nwe added a new top-level, generic function \u003ccode\u003eN\u003c/code\u003e that is like\n\u003ccode\u003eInt64N\u003c/code\u003e or \u003ccode\u003eUint64N\u003c/code\u003e but works for any integer type.\nIn the old API, to create a random duration of up to 5 seconds,\nit was necessary to write:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ed := time.Duration(rand.Int63n(int64(5*time.Second)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUsing \u003ccode\u003eN\u003c/code\u003e, the equivalent code is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ed := rand.N(5 * time.Second)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eN\u003c/code\u003e is only a top-level function; there is no \u003ccode\u003eN\u003c/code\u003e method on \u003ccode\u003erand.Rand\u003c/code\u003e\nbecause there are no generic methods in Go.\n(Generic methods are not likely in the future, either;\nthey conflict badly with interfaces, and a complete implementation\nwould require either run-time code generation or slow execution.)\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTo ameliorate misuse of \u003ccode\u003emath/rand\u003c/code\u003e in cryptographic contexts,\nwe made \u003ccode\u003eChaCha8\u003c/code\u003e the default generator used in global functions,\nand we also changed the Go runtime to use it (replacing wyrand).\nPrograms are still strongly encouraged to use \u003ccode\u003ecrypto/rand\u003c/code\u003e\nto generate cryptographic secrets,\nbut accidentally using \u003ccode\u003emath/rand/v2\u003c/code\u003e is not as catastrophic\nas using \u003ccode\u003emath/rand\u003c/code\u003e would be.\nEven in \u003ccode\u003emath/rand\u003c/code\u003e, the global functions now use the \u003ccode\u003eChaCha8\u003c/code\u003e generator when not explicitly seeded.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"principles\"\u003ePrinciples for evolving the Go standard library\u003c/h2\u003e\n\u003cp\u003eAs mentioned at the start this post, one of the goals for this work\nwas to establish principles and a pattern for how we approach all\nv2 packages in the standard library.\nThere will not be a glut of v2 packages\nin the next few Go releases.\nInstead, we will handle one package\nat a time, making sure we set a quality bar that will last for another decade.\nMany packages will not need a v2 at all.\nBut for those that do, our approach boils down to three principles.\u003c/p\u003e\n\u003cp\u003eFirst, a new, incompatible version of a package will use\n\u003ccode\u003ethat/package/v2\u003c/code\u003e as its import path,\nfollowing\n\u003ca href=\"https://research.swtch.com/vgo-import\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic import versioning\u003c/a\u003e\njust like a v2 module outside the standard library would.\nThis allows uses of the original package and the v2 package\nto coexist in a single program,\nwhich is critical for a\n\u003ca href=\"/talks/2016/refactor.article\"\u003egradual conversion\u003c/a\u003e to the new API.\u003c/p\u003e\n\u003cp\u003eSecond, all changes must be rooted in\nrespect for existing usage and users:\nwe must not introduce needless churn,\nwhether in the form of unnecessary changes to an existing package or\nan entirely new package that must be learned instead.\nIn practice, that means we take the existing package\nas the starting point\nand only make changes that are well motivated\nand provide a value that justifies the cost to users of updating.\u003c/p\u003e\n\u003cp\u003eThird, the v2 package must not leave v1 users behind.\nIdeally, the v2 package should be able to do everything the v1 package\ncould do,\nand when v2 is released, the v1 package should be rewritten\nto be a thin wrapper around v2.\nThis would ensure that existing uses of v1 continue to benefit\nfrom bug fixes and performance optimizations in v2.\nOf course, given that v2 is introducing breaking changes,\nthis is not always possible, but it is always something to consider carefully.\nFor \u003ccode\u003emath/rand/v2\u003c/code\u003e, we arranged for the auto-seeded v1 functions to\ncall the v2 generator, but we were unable to share other code\ndue to the repeatability violations.\nUltimately \u003ccode\u003emath/rand\u003c/code\u003e is not a lot of code and does not require\nregular maintenance, so the duplication is manageable.\nIn other contexts, more work to avoid duplication could be worthwhile.\nFor example, in the\n\u003ca href=\"/issue/63397\"\u003eencoding/json/v2 design (still in progress)\u003c/a\u003e,\nalthough the default semantics and the API are changed,\nthe package provides configuration knobs that\nmake it possible to implement the v1 API.\nWhen we eventually ship \u003ccode\u003eencoding/json/v2\u003c/code\u003e,\n\u003ccode\u003eencoding/json\u003c/code\u003e (v1) will become a thin wrapper around it,\nensuring that users who don’t migrate from v1 still\nbenefit from optimizations and security fixes in v2.\u003c/p\u003e\n\u003cp\u003eA \u003ca href=\"/blog/chacha8rand\"\u003efollow-up blog post\u003c/a\u003e presents the \u003ccode\u003eChaCha8\u003c/code\u003e generator in more detail.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-05-01T00:00:00Z",
  "Author": "Russ Cox"
}