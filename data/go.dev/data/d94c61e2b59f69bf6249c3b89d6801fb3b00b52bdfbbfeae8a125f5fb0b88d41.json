{
  "Source": "go.dev",
  "Title": "Go maps in action",
  "Link": "https://go.dev/blog/maps",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/maps\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo maps in action\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      6 February 2013\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eOne of the most useful data structures in computer science is the hash table.\nMany hash table implementations exist with varying properties,\nbut in general they offer fast lookups, adds, and deletes.\nGo provides a built-in map type that implements a hash table.\u003c/p\u003e\n\u003ch2 id=\"declaration-and-initialization\"\u003eDeclaration and initialization\u003c/h2\u003e\n\u003cp\u003eA Go map type looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emap[KeyType]ValueType\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhere \u003ccode\u003eKeyType\u003c/code\u003e may be any type that is \u003ca href=\"/ref/spec#Comparison_operators\"\u003ecomparable\u003c/a\u003e\n(more on this later),\nand \u003ccode\u003eValueType\u003c/code\u003e may be any type at all, including another map!\u003c/p\u003e\n\u003cp\u003eThis variable \u003ccode\u003em\u003c/code\u003e is a map of string keys to int values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar m map[string]int\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMap types are reference types, like pointers or slices,\nand so the value of \u003ccode\u003em\u003c/code\u003e above is \u003ccode\u003enil\u003c/code\u003e;\nit doesn’t point to an initialized map.\nA nil map behaves like an empty map when reading,\nbut attempts to write to a nil map will cause a runtime panic; don’t do that.\nTo initialize a map, use the built in \u003ccode\u003emake\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em = make(map[string]int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003emake\u003c/code\u003e function allocates and initializes a hash map data structure\nand returns a map value that points to it.\nThe specifics of that data structure are an implementation detail of the\nruntime and are not specified by the language itself.\nIn this article we will focus on the \u003cem\u003euse\u003c/em\u003e of maps,\nnot their implementation.\u003c/p\u003e\n\u003ch2 id=\"working-with-maps\"\u003eWorking with maps\u003c/h2\u003e\n\u003cp\u003eGo provides a familiar syntax for working with maps. This statement sets the key \u003ccode\u003e\u0026#34;route\u0026#34;\u003c/code\u003e to the value \u003ccode\u003e66\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em[\u0026#34;route\u0026#34;] = 66\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis statement retrieves the value stored under the key \u003ccode\u003e\u0026#34;route\u0026#34;\u003c/code\u003e and assigns it to a new variable i:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ei := m[\u0026#34;route\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf the requested key doesn’t exist, we get the value type’s \u003cem\u003ezero value\u003c/em\u003e.\nIn this case the value type is \u003ccode\u003eint\u003c/code\u003e, so the zero value is \u003ccode\u003e0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ej := m[\u0026#34;root\u0026#34;]\n// j == 0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe built in \u003ccode\u003elen\u003c/code\u003e function returns on the number of items in a map:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003en := len(m)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe built in \u003ccode\u003edelete\u003c/code\u003e function removes an entry from the map:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edelete(m, \u0026#34;route\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003edelete\u003c/code\u003e function doesn’t return anything, and will do nothing if the specified key doesn’t exist.\u003c/p\u003e\n\u003cp\u003eA two-value assignment tests for the existence of a key:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ei, ok := m[\u0026#34;route\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn this statement, the first value (\u003ccode\u003ei\u003c/code\u003e) is assigned the value stored under the key \u003ccode\u003e\u0026#34;route\u0026#34;\u003c/code\u003e.\nIf that key doesn’t exist, \u003ccode\u003ei\u003c/code\u003e is the value type’s zero value (\u003ccode\u003e0\u003c/code\u003e).\nThe second value (\u003ccode\u003eok\u003c/code\u003e) is a \u003ccode\u003ebool\u003c/code\u003e that is \u003ccode\u003etrue\u003c/code\u003e if the key exists in\nthe map, and \u003ccode\u003efalse\u003c/code\u003e if not.\u003c/p\u003e\n\u003cp\u003eTo test for a key without retrieving the value, use an underscore in place of the first value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e_, ok := m[\u0026#34;route\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo iterate over the contents of a map, use the \u003ccode\u003erange\u003c/code\u003e keyword:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efor key, value := range m {\n    fmt.Println(\u0026#34;Key:\u0026#34;, key, \u0026#34;Value:\u0026#34;, value)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo initialize a map with some data, use a map literal:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecommits := map[string]int{\n    \u0026#34;rsc\u0026#34;: 3711,\n    \u0026#34;r\u0026#34;:   2138,\n    \u0026#34;gri\u0026#34;: 1908,\n    \u0026#34;adg\u0026#34;: 912,\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe same syntax may be used to initialize an empty map, which is functionally identical to using the \u003ccode\u003emake\u003c/code\u003e function:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003em = map[string]int{}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"exploiting-zero-values\"\u003eExploiting zero values\u003c/h2\u003e\n\u003cp\u003eIt can be convenient that a map retrieval yields a zero value when the key is not present.\u003c/p\u003e\n\u003cp\u003eFor instance, a map of boolean values can be used as a set-like data structure\n(recall that the zero value for the boolean type is false).\nThis example traverses a linked list of \u003ccode\u003eNodes\u003c/code\u003e and prints their values.\nIt uses a map of \u003ccode\u003eNode\u003c/code\u003e pointers to detect cycles in the list.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    type Node struct {\n        Next  *Node\n        Value interface{}\n    }\n    var first *Node\n\n    \u003cspan class=\"highlight\"\u003evisited := make(map[*Node]bool)\u003c/span\u003e\n    for n := first; n != nil; n = n.Next {\n        \u003cspan class=\"highlight\"\u003eif visited[n] {\u003c/span\u003e\n            fmt.Println(\u0026#34;cycle detected\u0026#34;)\n            break\n        }\n        \u003cspan class=\"highlight\"\u003evisited[n] = true\u003c/span\u003e\n        fmt.Println(n.Value)\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe expression \u003ccode\u003evisited[n]\u003c/code\u003e is \u003ccode\u003etrue\u003c/code\u003e if \u003ccode\u003en\u003c/code\u003e has been visited,\nor \u003ccode\u003efalse\u003c/code\u003e if \u003ccode\u003en\u003c/code\u003e is not present.\nThere’s no need to use the two-value form to test for the presence of \u003ccode\u003en\u003c/code\u003e in the map;\nthe zero value default does it for us.\u003c/p\u003e\n\u003cp\u003eAnother instance of helpful zero values is a map of slices.\nAppending to a nil slice just allocates a new slice,\nso it’s a one-liner to append a value to a map of slices;\nthere’s no need to check if the key exists.\nIn the following example, the slice people is populated with \u003ccode\u003ePerson\u003c/code\u003e values.\nEach \u003ccode\u003ePerson\u003c/code\u003e has a \u003ccode\u003eName\u003c/code\u003e and a slice of Likes.\nThe example creates a map to associate each like with a slice of people that like it.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    type Person struct {\n        Name  string\n        Likes []string\n    }\n    var people []*Person\n\n    \u003cspan class=\"highlight\"\u003elikes := make(map[string][]*Person)\u003c/span\u003e\n    for _, p := range people {\n        for _, l := range p.Likes {\n            \u003cspan class=\"highlight\"\u003elikes[l] = append(likes[l], p)\u003c/span\u003e\n        }\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eTo print a list of people who like cheese:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    for _, p := range likes[\u0026#34;cheese\u0026#34;] {\n        fmt.Println(p.Name, \u0026#34;likes cheese.\u0026#34;)\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eTo print the number of people who like bacon:\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    fmt.Println(len(likes[\u0026#34;bacon\u0026#34;]), \u0026#34;people like bacon.\u0026#34;)\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eNote that since both range and len treat a nil slice as a zero-length slice,\nthese last two examples will work even if nobody likes cheese or bacon (however\nunlikely that may be).\u003c/p\u003e\n\u003ch2 id=\"key-types\"\u003eKey types\u003c/h2\u003e\n\u003cp\u003eAs mentioned earlier, map keys may be of any type that is comparable.\nThe \u003ca href=\"/ref/spec#Comparison_operators\"\u003elanguage spec\u003c/a\u003e\ndefines this precisely,\nbut in short, comparable types are boolean,\nnumeric, string, pointer, channel, and interface types,\nand structs or arrays that contain only those types.\nNotably absent from the list are slices, maps, and functions;\nthese types cannot be compared using \u003ccode\u003e==\u003c/code\u003e,\nand may not be used as map keys.\u003c/p\u003e\n\u003cp\u003eIt’s obvious that strings, ints, and other basic types should be available as map keys,\nbut perhaps unexpected are struct keys.\nStruct can be used to key data by multiple dimensions.\nFor example, this map of maps could be used to tally web page hits by country:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehits := make(map[string]map[string]int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is map of string to (map of \u003ccode\u003estring\u003c/code\u003e to \u003ccode\u003eint\u003c/code\u003e).\nEach key of the outer map is the path to a web page with its own inner map.\nEach inner map key is a two-letter country code.\nThis expression retrieves the number of times an Australian has loaded the documentation page:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003en := hits[\u0026#34;/doc/\u0026#34;][\u0026#34;au\u0026#34;]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eUnfortunately, this approach becomes unwieldy when adding data,\nas for any given outer key you must check if the inner map exists,\nand create it if needed:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc add(m map[string]map[string]int, path, country string) {\n    mm, ok := m[path]\n    if !ok {\n        mm = make(map[string]int)\n        m[path] = mm\n    }\n    mm[country]++\n}\nadd(hits, \u0026#34;/doc/\u0026#34;, \u0026#34;au\u0026#34;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn the other hand, a design that uses a single map with a struct key does away with all that complexity:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype Key struct {\n    Path, Country string\n}\nhits := make(map[Key]int)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen a Vietnamese person visits the home page,\nincrementing (and possibly creating) the appropriate counter is a one-liner:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ehits[Key{\u0026#34;/\u0026#34;, \u0026#34;vn\u0026#34;}]++\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd it’s similarly straightforward to see how many Swiss people have read the spec:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003en := hits[Key{\u0026#34;/ref/spec\u0026#34;, \u0026#34;ch\u0026#34;}]\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"concurrency\"\u003eConcurrency\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"/doc/faq#atomic_maps\"\u003eMaps are not safe for concurrent use\u003c/a\u003e:\nit’s not defined what happens when you read and write to them simultaneously.\nIf you need to read from and write to a map from concurrently executing goroutines,\nthe accesses must be mediated by some kind of synchronization mechanism.\nOne common way to protect maps is with \u003ca href=\"/pkg/sync/#RWMutex\"\u003esync.RWMutex\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis statement declares a \u003ccode\u003ecounter\u003c/code\u003e variable that is an anonymous struct\ncontaining a map and an embedded \u003ccode\u003esync.RWMutex\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar counter = struct{\n    sync.RWMutex\n    m map[string]int\n}{m: make(map[string]int)}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo read from the counter, take the read lock:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecounter.RLock()\nn := counter.m[\u0026#34;some_key\u0026#34;]\ncounter.RUnlock()\nfmt.Println(\u0026#34;some_key:\u0026#34;, n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo write to the counter, take the write lock:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecounter.Lock()\ncounter.m[\u0026#34;some_key\u0026#34;]++\ncounter.Unlock()\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"iteration-order\"\u003eIteration order\u003c/h2\u003e\n\u003cp\u003eWhen iterating over a map with a range loop,\nthe iteration order is not specified and is not guaranteed to be the same\nfrom one iteration to the next.\nIf you require a stable iteration order you must maintain a separate data structure that specifies that order.\nThis example uses a separate sorted slice of keys to print a \u003ccode\u003emap[int]string\u003c/code\u003e in key order:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport \u0026#34;sort\u0026#34;\n\nvar m map[int]string\nvar keys []int\nfor k := range m {\n    keys = append(keys, k)\n}\nsort.Ints(keys)\nfor _, k := range keys {\n    fmt.Println(\u0026#34;Key:\u0026#34;, k, \u0026#34;Value:\u0026#34;, m[k])\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n    \u003c/div\u003e",
  "Date": "2013-02-06T00:00:00Z",
  "Author": "Andrew Gerrand"
}