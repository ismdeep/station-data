{
  "Source": "go.dev",
  "Title": "Forward Compatibility and Toolchain Management in Go 1.21",
  "Link": "https://go.dev/blog/toolchain",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/toolchain\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eForward Compatibility and Toolchain Management in Go 1.21\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      14 August 2023\n      \u003c/p\u003e\n      \n      \u003cp\u003eBeyond Go 1.21’s \u003ca href=\"compat\"\u003eexpanded commitment to backward compatibility\u003c/a\u003e,\nGo 1.21 also introduces better forward compatibility for Go code,\nmeaning that Go 1.21 and later will take better care not to miscompile\ncode that requires an even newer version of Go.\nSpecifically, the \u003ccode\u003ego\u003c/code\u003e line in \u003ccode\u003ego.mod\u003c/code\u003e now specifies a\nminimum required Go toolchain version,\nwhile in previous releases it was a mostly unenforced suggestion.\u003c/p\u003e\n\u003cp\u003eTo make it easier to keep up with these requirements,\nGo 1.21 also introduces toolchain management,\nso that different modules can use different\nGo toolchains just as they can use different\nversions of a required module.\nAfter installing Go 1.21, you’ll never have to manually\ndownload and install a Go toolchain again.\nThe \u003ccode\u003ego\u003c/code\u003e command can do it for you.\u003c/p\u003e\n\u003cp\u003eThe rest of this post describes both of these Go 1.21 changes in more detail.\u003c/p\u003e\n\u003ch2 id=\"forward\"\u003eForward Compatibility\u003c/h2\u003e\n\u003cp\u003eForward compatibility refers to what happens when a Go toolchain\nattempts to build Go code intended for a newer version of Go.\nIf my program depends on a module M and needs a bug\nfix added in M v1.2.3, I can add \u003ccode\u003erequire M v1.2.3\u003c/code\u003e to my \u003ccode\u003ego.mod\u003c/code\u003e,\nguaranteeing that my program won’t be compiled against older versions of M.\nBut if my program requires a particular version of Go, there\nhasn’t been any way to express that: in particular, the \u003ccode\u003ego.mod\u003c/code\u003e \u003ccode\u003ego\u003c/code\u003e line\ndid not express that.\u003c/p\u003e\n\u003cp\u003eFor example, if I write code that uses the new generics\nadded in Go 1.18, I can write \u003ccode\u003ego 1.18\u003c/code\u003e in my \u003ccode\u003ego.mod\u003c/code\u003e file,\nbut that won’t stop earlier versions of Go from trying to compile the code,\nproducing errors like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go.mod\ngo 1.18\nmodule example\n\n$ go version\ngo version go1.17\n\n$ go build\n# example\n./x.go:2:6: missing function body\n./x.go:2:7: syntax error: unexpected [, expecting (\nnote: module requires Go 1.18\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe two compiler errors are misleading noise.\nThe real problem is printed by the \u003ccode\u003ego\u003c/code\u003e command as a hint:\nthe program failed to compile, so the \u003ccode\u003ego\u003c/code\u003e command points\nout the potential version mismatch.\u003c/p\u003e\n\u003cp\u003eIn this example, we’re lucky the build failed.\nIf I write code that only runs correctly in Go 1.19 or later,\nbecause it depends on a bug fixed in that patch release,\nbut I’m not using any Go 1.19-specific language features\nor packages in the code, earlier versions of Go will compile\nit and silently succeed.\u003c/p\u003e\n\u003cp\u003eStarting in Go 1.21, Go toolchains will treat the \u003ccode\u003ego\u003c/code\u003e line in\n\u003ccode\u003ego.mod\u003c/code\u003e not as a guideline but as a rule, and the line can\nlist specific point releases or release candidates.\nThat is, Go 1.21.0 understands that it cannot even build code\nthat says \u003ccode\u003ego 1.21.1\u003c/code\u003e in its \u003ccode\u003ego.mod\u003c/code\u003e file,\nnot to mention code that says much later versions like \u003ccode\u003ego 1.22.0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe main reason we allowed older versions of Go to try to\ncompile newer code was to avoid unnecessary build failures.\nIt’s very frustrating to be told that your version of Go is too\nold to build a program, especially if it might work anyway\n(maybe the requirement is unnecessarily conservative),\nand especially when updating to a newer Go version is a bit\nof a chore.\nTo reduce the impact of enforcing the \u003ccode\u003ego\u003c/code\u003e line as a requirement,\nGo 1.21 adds toolchain management to the core distribution as well.\u003c/p\u003e\n\u003ch2 id=\"toolchain-management\"\u003eToolchain Management\u003c/h2\u003e\n\u003cp\u003eWhen you need a new version of a Go module, the \u003ccode\u003ego\u003c/code\u003e command\ndownloads it for you.\nStarting in Go 1.21, when you need a newer Go toolchain,\nthe \u003ccode\u003ego\u003c/code\u003e command downloads that for you too.\nThis functionality is like Node’s \u003ccode\u003envm\u003c/code\u003e or Rust’s \u003ccode\u003erustup\u003c/code\u003e, but built in to\nthe core \u003ccode\u003ego\u003c/code\u003e command instead of being a separate tool.\u003c/p\u003e\n\u003cp\u003eIf you are running Go 1.21.0 and you run a \u003ccode\u003ego\u003c/code\u003e command, say, \u003ccode\u003ego build\u003c/code\u003e,\nin a module with a \u003ccode\u003ego.mod\u003c/code\u003e that says \u003ccode\u003ego 1.21.1\u003c/code\u003e,\nthe Go 1.21.0 \u003ccode\u003ego\u003c/code\u003e command will notice that you need Go 1.21.1,\ndownload it, and re-invoke that version’s \u003ccode\u003ego\u003c/code\u003e command to finish the build.\nWhen the \u003ccode\u003ego\u003c/code\u003e command downloads and runs these other toolchains,\nit doesn’t install them in your PATH or overwrite the current installation.\nInstead, it downloads them as Go modules, inheriting all the\n\u003ca href=\"/blog/module-mirror-launch\"\u003esecurity and privacy benefits of modules\u003c/a\u003e,\nand then it runs them from the module cache.\u003c/p\u003e\n\u003cp\u003eThere is also a new \u003ccode\u003etoolchain\u003c/code\u003e line in \u003ccode\u003ego.mod\u003c/code\u003e that specifies the\nminimum Go toolchain to use when working in a particular module.\nIn contrast to the \u003ccode\u003ego\u003c/code\u003e line, \u003ccode\u003etoolchain\u003c/code\u003e does not impose a requirement\non other modules.\nFor example, a \u003ccode\u003ego.mod\u003c/code\u003e might say:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodule m\ngo 1.21.0\ntoolchain go1.21.4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis says that other modules requiring \u003ccode\u003em\u003c/code\u003e need to provide at least Go 1.21.0,\nbut when we are working in \u003ccode\u003em\u003c/code\u003e itself, we want an even newer toolchain,\nat least Go 1.21.4.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ego\u003c/code\u003e and \u003ccode\u003etoolchain\u003c/code\u003e requirements can be updated using \u003ccode\u003ego get\u003c/code\u003e\nlike ordinary module requirements. For example, if you’re using one\nof the Go 1.21 release candidates, you can start using Go 1.21.0\nin a particular module by running:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego get go@1.21.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat will download and run Go 1.21.0 to update the \u003ccode\u003ego\u003c/code\u003e line,\nand future invocations of the \u003ccode\u003ego\u003c/code\u003e command will see the line\n\u003ccode\u003ego 1.21.0\u003c/code\u003e and automatically re-invoke that version.\u003c/p\u003e\n\u003cp\u003eOr if you want to start using Go 1.21.0 in a module but leave\nthe \u003ccode\u003ego\u003c/code\u003e line set to an older version, to help maintain compatibility with\nusers of earlier versions of Go, you can update the \u003ccode\u003etoolchain\u003c/code\u003e line:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego get toolchain@go1.21.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf you’re ever wondering which Go version is running in a particular\nmodule, the answer is the same as before: run \u003ccode\u003ego version\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eYou can force the use of a specific Go toolchain version using\nthe GOTOOLCHAIN environment variable.\nFor example, to test code with Go 1.20.4:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGOTOOLCHAIN=go1.20.4 go test\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally, a GOTOOLCHAIN setting of the form \u003ccode\u003eversion+auto\u003c/code\u003e means to\nuse \u003ccode\u003eversion\u003c/code\u003e by default but allow upgrades to newer versions as well.\nIf you have Go 1.21.0 installed, then when Go 1.21.1 is released,\nyou can change your system default by setting a default GOTOOLCHAIN:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego env -w GOTOOLCHAIN=go1.21.1+auto\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou’ll never have to manually download and install a Go toolchain again.\nThe \u003ccode\u003ego\u003c/code\u003e command will take care of it for you.\u003c/p\u003e\n\u003cp\u003eSee “\u003ca href=\"/doc/toolchain\"\u003eGo Toolchains\u003c/a\u003e” for more details.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-08-14T00:00:00Z",
  "Author": "Russ Cox"
}