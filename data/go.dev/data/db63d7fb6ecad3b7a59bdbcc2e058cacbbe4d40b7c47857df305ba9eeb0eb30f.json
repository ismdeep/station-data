{
  "Source": "go.dev",
  "Title": "Go Developer Survey 2023 H2 Results",
  "Link": "https://go.dev/blog/survey2023-h2-results",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/survey2023-h2-results\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Developer Survey 2023 H2 Results\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Todd Kulesza\u003cbr/\u003e\n      5 December 2023\n      \u003c/p\u003e\n      \n      \u003cstyle type=\"text/css\" scoped=\"\"\u003e\n  .chart {\n    margin-left: 1.5rem;\n    margin-right: 1.5rem;\n    width: 800px;\n  }\n  blockquote p {\n    color: var(--color-text-subtle) !important;\n  }\n\n  .quote_source {\n    font-style: italic;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    .chart {\n      border-radius: 8px;\n    }\n  }\n\u003c/style\u003e\n\u003ch2 id=\"background\"\u003eBackground\u003c/h2\u003e\n\u003cp\u003eIn August 2023, the Go team at Google conducted our bi-annual survey of Go\ndevelopers. We recruited participants via a public post on the Go blog and a\nrandomized prompt in VS Code, resulting in 4,005 responses. We primarily\nfocused survey questions around a few topics: general sentiment and feedback\nabout developing with Go, technology stacks used alongside Go, how developers\nstart new Go projects, recent experiences with toolchain error messages, and\nunderstanding developer interest around ML/AI.\u003c/p\u003e\n\u003cp\u003eThank you to everyone who participated in this survey! This report shares what\nwe learned from your feedback.\u003c/p\u003e\n\u003ch2 id=\"tldr\"\u003etl;dr\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003eGo developers said they are \u003cstrong\u003emore interested in AI/ML tooling that\nimproves the quality, reliability, and performance of code they write\u003c/strong\u003e,\nrather than writing code for them. An always-awake, never-busy expert\n“reviewer” might be one of the more helpful forms of AI developer\nassistance.\u003c/li\u003e\n\u003cli\u003eThe top requests for improving toolchain warnings and errors were to \u003cstrong\u003emake\nthe messages more comprehensible and actionable\u003c/strong\u003e; this sentiment was\nshared by developers of all experience levels, but was particularly strong\namong newer Go developers.\u003c/li\u003e\n\u003cli\u003eOur experiment with project templates (\u003ccode\u003egonew\u003c/code\u003e) appears to solve critical\nproblems for Go developers (especially developers new to Go) and does so in\na way that matches their existing workflows for starting a new project.\nBased on these findings, we believe \u003cstrong\u003e\u003ccode\u003egonew\u003c/code\u003e can substantially reduce\nonboarding barriers for new Go developers and ease adoption of Go in\norganizations\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eThree out of every four respondents work on Go software that also uses\ncloud services; this is evidence that \u003cstrong\u003edevelopers see Go as a language for\nmodern, cloud-based development\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDeveloper sentiment towards Go remains extremely positive\u003c/strong\u003e, with 90% of\nsurvey respondents saying they felt satisfied while working with Go during\nthe prior year.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"contents\"\u003eContents\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"#sentiment\"\u003eDeveloper sentiment\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#devenv\"\u003eDeveloper environments\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#stacks\"\u003eTech stacks\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#gonew\"\u003eHow developers start new Go projects\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#err_handling\"\u003eDeveloper goals for error handling\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#mlai\"\u003eUnderstanding ML/AI use cases\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#err_msgs\"\u003eToolchain error messages\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#microservices\"\u003eMicroservices\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#modules\"\u003eModule authorship and maintenance\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#demographics\"\u003eDemographics\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#firmographics\"\u003eFirmographics\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#methodology\"\u003eMethodology\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"#closing\"\u003eClosing\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"sentiment\"\u003eDeveloper sentiment\u003c/h2\u003e\n\u003cp\u003eGo developers continue to report high levels of satisfaction with the Go\necosystem. A large majority of respondents said they felt satisfied while\nworking with Go over the past year (90% satisfied, 6% dissatisfied), and a\nmajority (52%) went further and said they were “very satisfied”, the highest\nrating. Longtime readers have likely noticed that this number doesn’t change\nmuch from year to year. This is expected for a large, stable project like Go;\nwe view this metric as a \u003ca href=\"https://en.wikipedia.org/wiki/Economic_indicator#Lagging_indicators\" rel=\"noreferrer\" target=\"_blank\"\u003elagging\nindicator\u003c/a\u003e\nthat can help confirm widespread issues in the Go ecosystem, but isn’t where\nwe expect to first learn about potential problems.\u003c/p\u003e\n\u003cp\u003eWe typically find that the longer someone has worked with Go, the more likely\nthey are to report being satisfied with it. This trend continued in 2023;\namong respondents with less than one year of Go experience, 82% reported\nsatisfaction with the Go development experience, compared to the 94% of Go\ndevelopers with five or more years of experience. There are likely a mix of\nfactors contributing to this, such as some respondents developing an\nappreciation for Go’s design choices over time, or deciding Go isn’t a good\nfit for their work and so not returning to this survey in following years\n(i.e., \u003ca href=\"https://en.wikipedia.org/wiki/Survivorship_bias\" rel=\"noreferrer\" target=\"_blank\"\u003esurvivorship bias\u003c/a\u003e).\nStill, this data helps us quantify the current getting started experience for\nGo developers, and it seems clear we could do more to help emerging Gophers\nfind their footing and enjoy early successes developing with Go.\u003c/p\u003e\n\u003cp\u003eThe key takeaway is that a large majority of people who chose to work with Go\nduring the past year were happy with their experience. Further, the number of\npeople working with Go continues to increase; we see evidence of this from\nexternal research like \u003ca href=\"https://survey.stackoverflow.co/2023/#most-popular-technologies-language-prof\" rel=\"noreferrer\" target=\"_blank\"\u003eStack Overflow’s Developer\nSurvey\u003c/a\u003e\n(which found 14% of professional developers worked with Go during the past\nyear, a roughly 15% year-over-year increase), as well as analytics for\n\u003ca href=\"/\"\u003ego.dev\u003c/a\u003e (which show an 8% rise in visitors year-over-year).\nCombining this growth with a high satisfaction score is evidence that Go\ncontinues to appeal to developers, and suggests that many developers who\nchoose to learn the language feel good about their decision long afterwards.\nIn their own words:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“After 30+ years of development in C, C++, Java, and now seven years of\nprogramming in Go, it is still the most productive language by far. It’s not\nperfect (no language is), but it has the best balance of productivity,\ncomplexity, and performance.” \u003cspan class=\"quote_source\"\u003e— Professional Go\ndeveloper w/ 5 – 9 years of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“This is currently the best language I know, and I’ve tried many. The\ntooling is awesome, compile times are great, and I can be really productive.\nI’m glad I have Go as a tool, and I don’t need to use TypeScript\nserver-side. Thanks.” \u003cspan class=\"quote_source\"\u003e— Open source Go\ndeveloper w/ 3 – 4 years of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/csat.svg\" alt=\"Chart of developer satisfaction with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"devenv\"\u003eDeveloper environments\u003c/h2\u003e\n\u003cp\u003eAs in prior years, the majority of survey respondents told us they work with\nGo on Linux (63%) and macOS (58%) systems. Small variations in these numbers\nfrom year to year are most likely dependent upon who finds and responds to\nthis survey (particularly on the Go blog), as we don’t see consistent\nyear-over-year trends in the random sample coming from VS Code.\u003c/p\u003e\n\u003cp\u003eWe do continue to see that newer members of the Go community are more likely\nto be working with Windows than more experienced Go developers. We interpret\nthis as a signal that Windows-based development is important for onboarding\nnew developers to the Go ecosystem, and is a topic our team hopes to focus on\nmore in 2024.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/os_dev.svg\" alt=\"Chart of operating systems respondents\nuse when developing Go software\" class=\"chart\"/\u003e \u003cimg src=\"survey2023h2/os_dev_exp.svg\" alt=\"Chart of operating systems respondents\nuse when developing Go software, split by duration of experience\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eRespondents continue to be heavily focused on Linux deployments. Given the\nprevalence of Go for cloud development and containerized workloads, this is\nnot surprising but is still an important confirmation. We found few meaningful\ndifferences based on factors such as organization size or experience level;\nindeed, while novice Go developers appear more likely to \u003cem\u003edevelop\u003c/em\u003e on Windows,\n92% still \u003cem\u003edeploy\u003c/em\u003e to Linux systems. Perhaps the most interesting finding from\nthis breakdown is that more experienced Go developers said they deploy to a\nwider variety of systems (most notably WebAssembly and IoT), though it’s\nunclear if this is because such deployments are challenging for newer Go\ndevelopers or the result of experienced Go developers using Go in a broader\nrange of contexts. We also observed that both IoT and WebAssembly have\nsteadily increased in recent years, with each rising from 3% in 2021 to 6% and\n5% in 2023, respectively.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/os_deploy.svg\" alt=\"Chart of platforms respondents\ndeploy Go software to\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe computing architecture landscape has changed over the past few years, and\nwe see that reflected in the current architectures Go developers say they work\nwith. While x86-compatible systems still account for the majority of\ndevelopment (89%), ARM64 is also now used by a majority of respondents (56%).\nThis adoption appears to be partly driven by Apple Silicon; macOS developers\nare now more likely to say they develop for ARM64 than for x86-based\narchitectures (76% vs. 71%). However, Apple hardware isn’t the only factor\ndriving ARM64 adoption: among respondents who don’t develop on macOS at all,\n29% still say they develop for ARM64.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/arch.svg\" alt=\"Chart of architectures respondents use\nwith Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe most common code editors among Go Developer Survey respondents continue to\nbe \u003ca href=\"https://code.visualstudio.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eVS Code\u003c/a\u003e (44%) and\n\u003ca href=\"https://www.jetbrains.com/go/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoLand\u003c/a\u003e (31%). Both of these proportions\nticked down slightly from 2023 H1 (46% and 33%, respectively), but remain\nwithin this survey’s margin of error. Among the “Other” category,\n\u003ca href=\"https://helix-editor.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eHelix\u003c/a\u003e accounted for the majority of responses.\nSimilar to the results for operating systems above, we don’t believe this\nrepresents a meaningful shift in code editor usage, but rather shows some of\nthe variability we expect to see in a community survey such as this. In\nparticular, we exclude the randomly sampled respondents from VS Code for this\nquestion, as we know that group is heavily biased towards VS Code. However,\nthat has the side effect of making these results more susceptible to variation\neach year.\u003c/p\u003e\n\u003cp\u003eWe also looked at respondents’ level of satisfaction with Go based on the\neditor they prefer using. After controlling for length of experience, we found\nno differences: we don’t believe people enjoy working with Go more or less\nbased on which code editor they use. That doesn’t necessarily mean all Go\neditors are equal, but may reflect that people find the editor that is best\nfor their own needs. This would suggest the Go ecosystem has a healthy\ndiversity of different editors geared towards different use cases and\ndeveloper preferences.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/editor_self_select.svg\" alt=\"Chart of code editors\nrespondents prefer to use with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"stacks\"\u003eTech stacks\u003c/h2\u003e\n\u003cp\u003eTo better understand the web of software and services that Go developers\ninteract with, we asked several questions about tech stacks. We’re sharing\nthese results with the community to show which tools and platforms are in\ncommon use today, but we believe everyone should consider their own needs and\nuse cases when selecting a tech stack. More plainly: we neither intend for\nreaders to use this data to select components of their tech stack because they\nare popular, nor to avoid components because they are not commonly used.\u003c/p\u003e\n\u003cp\u003eFirst, we can say with confidence that Go is a language for modern cloud-based\ndevelopment. Indeed, 75% of respondents work on Go software that integrates\nwith cloud services. For nearly half of respondents, this involved AWS (48%),\nand almost one-third used GCP (29%) for their Go development and deployments.\nFor both AWS and GCP, usage is equally balanced among large enterprises and\nsmaller organizations. Microsoft Azure is the only cloud provider that is\nsignificantly more likely to be used in large organizations (companies with \u0026gt;\n1,000 employees) than smaller shops; other providers show no meaningful\ndifferences in usage based on the size of the organization.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/cloud.svg\" alt=\"Chart of cloud platforms respondents\nuse with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eDatabases are extremely common components of software systems, and we found\nthat 91% of respondents said the Go services they work on use at least one.\nMost frequently this was PostgreSQL (59%), but with double digits of\nrespondents reporting use of six additional databases, it’s safe to say there\nare not just a couple of standard DBs for Go developers to consider. We again\nsee differences based on organization size, with respondents from smaller\norganizations more likely to report using PostgreSQL and Redis, while\ndevelopers from large organizations are somewhat more likely to use a database\nspecific to their cloud provider.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/db.svg\" alt=\"Chart of databases respondents use with\nGo\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eAnother common component respondents reported using were caches or key-value\nstores; 68% of respondents said they work on Go software incorporating at\nleast one of these. Redis was clearly the most common (57%), followed at a\ndistance by etcd (10%) and memcached (7%).\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/cache.svg\" alt=\"Chart of caches respondents use with\nGo\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eSimilar to databases, survey respondents told us they use a range of different\nobservability systems. Prometheus and Grafana were the most commonly cited\n(both at 43%), but Open Telemetry, Datadog, and Sentry were all in double\ndigits.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/metrics.svg\" alt=\"Chart of metric systems respondents\nuse with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eLest anyone wonder “Have we JSON’d all the things?”… yes, yes we have.\nNearly every respondent (96%!) said their Go software uses the JSON data\nformat; that’s about as close to universal as you’ll see with self-reported\ndata. YAML, CSV, and protocol buffers are also all used by roughly half of\nrespondents, and double-digit proportions work with TOML and XML as well.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/data.svg\" alt=\"Chart of data formats respondents use\nwith Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eFor authentication and authorization services, we found most respondents are\nbuilding upon the foundations provided by standards such as\n\u003ca href=\"https://jwt.io/introduction\" rel=\"noreferrer\" target=\"_blank\"\u003eJWT\u003c/a\u003e and \u003ca href=\"https://oauth.net/2/\" rel=\"noreferrer\" target=\"_blank\"\u003eOAuth2\u003c/a\u003e. This\nalso appears to be an area where an organization’s cloud provider’s solution\nis about as likely to be used as most turn-key alternatives.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/auth.svg\" alt=\"Chart of authentication systems\nrespondents use with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eFinally, we have a bit of a grab bag of other services that don’t neatly fit\ninto the above categories. We found that nearly half of respondents work with\ngRPC in their Go software (47%). For infrastructure-as-code needs, Terraform\nwas the tool of choice for about ¼ of respondents. Other fairly common\ntechnologies used alongside Go included Apache Kafka, ElasticSearch, GraphQL,\nand RabbitMQ.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/other_tech.svg\" alt=\"Chart of authentication systems\nrespondents use with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe also looked at which technologies tended to be used together. While nothing\nclearly analogous to the classic \u003ca href=\"https://en.wikipedia.org/wiki/LAMP_(software_bundle)\" rel=\"noreferrer\" target=\"_blank\"\u003eLAMP\nstack\u003c/a\u003e emerged from this\nanalysis, we did identify some interesting patterns:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAll or nothing: Every category (except data formats) showed a strong\ncorrelation where if a respondent answered “None” to one category, they\nlikely answered “None” for all of the others. We interpret this as evidence\nthat a minority of use cases require none of these tech stack components,\nbut once the use case requires any one of them, it likely requires (or is at\nleast simplified by) more than just one.\u003c/li\u003e\n\u003cli\u003eA bias towards cross-platform technologies: Provider-specific solutions\n(i.e., services that are unique to a single cloud platform) were not\ncommonly adopted. However, if respondents used one provider-specific\nsolution (e.g., for metrics), they were substantially more likely to also\nsay they used cloud-specific solutions in order areas (e.g., databases,\nauthentication, caching, etc.).\u003c/li\u003e\n\u003cli\u003eMulticloud: The three biggest cloud platforms were most likely to be\ninvolved in multicloud setups. For example, if an organization is using any\nnon-AWS cloud provider, they’re probably also using AWS. This pattern was\nclearest for Amazon Web Services, but was also apparent (to a lesser extent)\nfor Google Cloud Platform and Microsoft Azure.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"gonew\"\u003eHow developers start new Go projects\u003c/h2\u003e\n\u003cp\u003eAs part of our \u003ca href=\"/blog/gonew\"\u003eexperimentation with project\ntemplates\u003c/a\u003e, we wanted to understand how Go\ndevelopers get started with new projects today. Respondents told us their\nbiggest challenges were choosing an appropriate way to structure their project\n(54%) and learning how to write idiomatic Go (47%). As two respondents phrased\nit:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Finding an appropriate structure and the right abstraction levels for a new\nproject can be quite tedious; looking at high-profile community and\nenterprise projects for inspiration can be quite confusing as everyone\nstructures their project differently” \u003cspan class=\"quote_source\"\u003e—\nProfessional Go developer w/ 5 – 9 years of Go experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“It would be great if [Go had a] toolchain to create [a project’s] basic\nstructure for web or CLI like `go init \u0026lt;project name\u0026gt;`” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 3 – 4 years of\nexperience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eNewer Go developers were even more likely to encounter these challenges: the\nproportions increased to 59% and 53% for respondents with less than two years\nof experience with Go, respectively. These are both areas we hope to improve\nvia our \u003ccode\u003egonew\u003c/code\u003e prototype: templates can provide new Go developers with\nwell-tested project structures and design patterns, with initial\nimplementations written in idiomatic Go. These survey results have helped our\nteam to keep the purpose of \u003ccode\u003egonew\u003c/code\u003e focused on tasks the Go community most\nstruggle with.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/new_challenge.svg\" alt=\"Chart of challenges respondents\nfaced when starting new Go projects\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eA majority of respondents told us they either use templates or copy+paste code\nfrom existing projects when starting a new Go project (58%). Among respondents\nwith less than five years of Go experience, this proportion increased to\nnearly ⅔ (63%). This was an important confirmation that the template-based\napproach in \u003ccode\u003egonew\u003c/code\u003e seems to meet developers where they already are, aligning\na common, informal approach with \u003ccode\u003ego\u003c/code\u003e command-style tooling. This is further\nsupported by the common feature requests for project templates: a majority of\nrespondents requested 1) a pre-configured directory structure to organize\ntheir project and 2) sample code for common tasks in the project domain. These\nresults are well-aligned with the challenges developers said they faced in the\nprevious section. The responses to this question also help tease apart the\ndifference between project structure and design patterns, with nearly twice as\nmany respondents saying they want Go project templates to provide the former\nthan the latter.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/new_approach.svg\" alt=\"Chart of approaches respondents\nused when starting new Go projects\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/templates.svg\" alt=\"Chart of functionality respondents\nrequested when starting new Go projects\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eA majority of respondents told us the ability to make changes to a template\n\u003cem\u003eand\u003c/em\u003e have those changes propagate to projects based on that template was of\nat least moderate importance. Anecdotally, we haven’t spoken with any\ndevelopers who \u003cem\u003ecurrently\u003c/em\u003e have this functionality with home-grown template\napproaches, but it suggests this is an interesting avenue for future\ndevelopment.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/template_updates.svg\" alt=\"Chart of respondent interest\nin updatable templates\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"err_handling\"\u003eDeveloper goals for error handling\u003c/h2\u003e\n\u003cp\u003eA perennial topic of discussion among Go developers is potential improvements\nto error handling. As one respondent summarized:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Error handling adds too much boilerplate (I know, you probably heard this\nbefore)” \u003cspan class=\"quote_source\"\u003e— Open source Go developer w/ 1 – 2\nyears of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eBut, we also hear from numerous developers that they appreciate Go’s approach\nto error handling:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Go error handling is simple and effective. As I have backends in Java and\nC# and exploring Rust and Zig now, I am always pleased to go back to write\nGo code. And one of the reasons is, believe it or not, error handling. It is\nreally simple, plain and effective. Please leave it that way.” \u003cspan class=\"quote_source\"\u003e— Open source Go developer w/ 5 – 9 years of\nexperience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eRather than ask about specific modifications to error handling in Go, we\nwanted to better understand developers’ higher-level goals and whether Go’s\ncurrent approach has proven useful and usable. We found that a majority of\nrespondents appreciate Go’s approach to error handling (55%) and say it helps\nthem know when to check for errors (50%). Both of these outcomes were stronger\nfor respondents with more Go experience, suggesting that either developers\ngrow to appreciate Go’s approach to error handling over time, or that this is\none factor leading developers to eventually leave the Go ecosystem (or at\nleast stop responding to Go-related surveys). Many survey respondents also\nfelt that Go requires a lot of tedious, boilerplate code to check for errors\n(43%); this remained true regardless of how much prior Go experience\nrespondents had. Interestingly, when respondents said they appreciate Go’s\nerror handling, they were unlikely to say it also results in lots of\nboilerplate code—our team had a hypothesis that Go developers can both\nappreciate the language’s approach to error handling and feel it’s too\nverbose, but only 14% of respondents agreed with both statements.\u003c/p\u003e\n\u003cp\u003eSpecific issues that respondents cited include challenges knowing which error\ntypes to check for (28%), wanting to easily show a stack trace along with the\nerror message (28%), and the ease with which errors can be entirely ignored\n(19%). About ⅓ of respondents were also interested in adopting concepts from\nother languages, such as Rust’s \u003ccode\u003e?\u003c/code\u003e operator (31%).\u003c/p\u003e\n\u003cp\u003eThe Go team has no plans to add exceptions to the language, but since this is\nanecdotally a common request, we included it as a response choice. Only 1 in\n10 respondents said they wished they could use exceptions in Go, and this was\ninversely related to experience—more veteran Go developers were less likely\nto be interested in exceptions than respondents newer to the Go community.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/error_handling.svg\" alt=\"Chart of respondents\u0026#39; thoughts\nabout Go\u0026#39;s error handling approach\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"mlai\"\u003eUnderstanding ML/AI use cases\u003c/h2\u003e\n\u003cp\u003eThe Go team is considering how the unfolding landscape of new ML/AI\ntechnologies may impact software development in two distinct veins: 1) how\nmight ML/AI tooling help engineers write better software, and 2) how might Go\nhelp engineers bring ML/AI support to their applications and services? Below,\nwe delve into each of these areas.\u003c/p\u003e\n\u003ch3 id=\"helping-engineers-write-better-software\"\u003eHelping engineers write better software\u003c/h3\u003e\n\u003cp\u003eThere’s little denying we’re in \u003ca href=\"https://www.gartner.com/en/articles/what-s-new-in-artificial-intelligence-from-the-2023-gartner-hype-cycle\" rel=\"noreferrer\" target=\"_blank\"\u003ea hype cycle around the possibilities for\nAI/ML\u003c/a\u003e.\nWe wanted to take a step back to focus on the broader challenges developers\nface and where they think AI might prove useful in their regular work. The\nanswers were a bit surprising, especially given the industry’s current focus\non coding assistants.\u003c/p\u003e\n\u003cp\u003eFirst, we see a few AI use cases that about half of respondents thought could\nbe helpful: generating tests (49%), suggesting best practices in-situ (47%),\nand catching likely mistakes early in the development process (46%). A\nunifying theme of these top use cases is that each could help improve the\nquality and reliability of code an engineer is writing. A fourth use case\n(help writing documentation) garnered interest from about ⅓ of respondents.\nThe remaining cases comprise a long tail of potentially fruitful ideas, but\nthese are of significantly less general interest than the top four.\u003c/p\u003e\n\u003cp\u003eWhen we look at developers’ duration of experience with Go, we find that\nnovice respondents are interested in help resolving compiler errors and\nexplaining what a piece of Go code does more than veteran Go developers. These\nmight be areas where AI could help improve the getting started experience for\nnew Gophers; for example, an AI assistant could help explain in natural\nlanguage what an undocumented block of code does, or suggest common solutions\nto specific error messages. Conversely, we see no differences between\nexperience levels for topics like “catch common mistakes”—both novice and\nveteran Go developers say they would appreciate tooling to help with this.\u003c/p\u003e\n\u003cp\u003eOne can squint at this data and see three broad trends:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eRespondents voiced interest in getting feedback from “expert reviewers” in\nreal-time, not just during review time.\u003c/li\u003e\n\u003cli\u003eGenerally, respondents appeared most interested in tooling that saves them\nfrom potentially less-enjoyable tasks (e.g., writing tests or documenting\ncode).\u003c/li\u003e\n\u003cli\u003eWholesale writing or translating of code was of fairly low interest,\nespecially to developers with more than a year or two of experience.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eTaken together, it appears that today, developers are less excited by the\nprospect of machines doing the fun (e.g., creative, enjoyable, appropriately\nchallenging) parts of software development, but do see value in another set of\n“eyes” reviewing their code and potentially handling dull or repetitive tasks\nfor them. As one respondent phrased it:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“I’m specifically interested in using AI/ML to improve my productivity with\nGo. Having a system that is trained in Go best practices, can catch\nanti-patterns, bugs, generate tests, with a low rate of hallucination, would\nbe killer.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 5 –\n9 years of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThis survey, however, is just one data point in a quickly-evolving research\nfield, so it’s best to keep these results in context.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/ml_use_cases.svg\" alt=\"Chart of respondents\u0026#39; interest\nin AI/ML support for development tasks\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"bringing-ai-features-to-applications-and-services\"\u003eBringing AI features to applications and services\u003c/h3\u003e\n\u003cp\u003eIn addition to looking at how Go developers might benefit from AI/ML-powered\ntooling, we explored their plans for building AI-powered applications and\nservices (or supporting infrastructure) with Go. We found that we’re still\nearly in \u003ca href=\"https://en.wikipedia.org/wiki/Technology_adoption_life_cycle\" rel=\"noreferrer\" target=\"_blank\"\u003ethe adoption\ncurve\u003c/a\u003e: most\nrespondents have not yet tried to use Go in these areas, though every topic\nsaw some level of interest from roughly half of respondents. For example, a\nmajority of respondents reported interest in integrating the Go services they\nwork on with LLMs (49%), but only 13% have already done so or are currently\nevaluating this use case. At the time of this survey, responses gently suggest\nthat developers may be most interested in using Go to call LLMs directly,\nbuild the data pipelines needed to power ML/AI systems, and for creating API\nendpoints other services can call to interact with ML/AI models. As one\nexample, this respondent described the benefits they hoped to gain by using Go\nin their data pipelines:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“I want to integrate the ETL [extract, transform, and load] part using Go,\nto keep a consistent, robust, reliable codebase.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 3 – 4 years of\nexperience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/ml_adoption.svg\" alt=\"Chart of respondents\u0026#39; current use\nof (and interest in) Go for AI/ML systems\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"err_msgs\"\u003eToolchain error messages\u003c/h2\u003e\n\u003cp\u003eMany developers can relate to the frustrating experience of seeing an error\nmessage, thinking they know what it means and how to resolve it, but after\nhours of fruitless debugging realize it meant something else entirely. One\nrespondent explained their frustration as follows:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“So often the printed complaints wind up having nothing to do with the\nproblem, but it can take an hour before I discover that that’s the case. The\nerror messages are unnervingly terse, and don’t seem to go out of their way\nto guess as to what the user might be trying to do or [explain what they’re]\ndoing wrong.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 10+\nyears of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eWe believe the warnings and errors emitted by developer tooling should be\nbrief, understandable, and actionable: the human reading them should be able\nto accurately understand what went wrong and what they can do to resolve the\nissue. This is an admittedly high bar to strive for, and with this survey we\ntook some measurements to understand how developers perceive Go’s current\nwarning and error messages.\u003c/p\u003e\n\u003cp\u003eWhen thinking about the most recent Go error message they worked through,\nrespondents told us there was much room for improvement. Only a small majority\nunderstood what the problem was from the error message alone (54%), and even\nfewer knew what to do next to resolve the issue (41%). It appears a relatively\nsmall amount of additional information could meaningfully increase these\nproportions, as ¼ of respondents said they mostly knew how to fix the problem,\nbut needed to see an example first. Further, with 11% of respondents saying\nthey couldn’t make sense of the error message, we now have a baseline for\ncurrent understandability of the Go toolchain’s error messages.\u003c/p\u003e\n\u003cp\u003eImprovements to Go’s toolchain error messages would especially benefit\nless-experienced Gophers. Respondents with up to two years of experience were\nless likely than veteran Gophers to say they understood the problem (47% vs.\n61%) or knew how to fix it (29% vs. 52%), and were twice as likely to need to\nsearch online to fix the issue (21% vs. 9%) or even make sense of what the\nerror meant (15% vs. 7%).\u003c/p\u003e\n\u003cp\u003eWe hope to focus on improving toolchain error messages during 2024. These\nsurvey results suggest this is an area of frustration for developers of all\nexperience levels, and will particularly help newer developers get started\nwith Go.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/err_exp.svg\" alt=\"Chart of error handling experiences\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/err_exp_exp.svg\" alt=\"Chart of error handling\nexperiences, split by duration of Go experience\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eTo understand \u003cem\u003ehow\u003c/em\u003e these messages might be improved, we asked survey\nrespondents an open-ended question: “If you could make a wish and improve one\nthing about error messages in the Go toolchain, what would you change?”. The\nresponses largely align with our hypothesis that good error messages are both\nunderstandable and actionable. The most common response was some form of “Help\nme understand what led to this error” (36%), 21% of respondents explicitly\nasked for guidance to fix the problem, and 14% of respondents called out\nlanguages such as Rust or Elm as exemplars which strive to do both of these\nthings. In the words of one respondent:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“For compilation errors, Elm or Rust-style output pinpointing exact issue in\nthe source code. Errors should include suggestions to fix them where\npossible… I think a general policy of ‘optimize error output to be read by\nhumans’ with ‘provide suggestions where possible’ would be very welcome\nhere.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 5 – 9\nyears of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eUnderstandably, there is a fuzzy conceptual boundary between toolchain error\nmessages and runtime error messages. For example, one of the top requests\ninvolved improved stack traces or other approaches to assist debugging runtime\ncrashes (22%). Similarly, a surprising theme in 4% of the feedback was about\nchallenges with getting help from the \u003ccode\u003ego\u003c/code\u003e command itself. These are great\nexamples of the Go community helping us identify related pain points that\nweren’t otherwise on our radar. We started this investigation focused on\nimproving compile-time errors, but one of the core areas Go developers would\nlike to see improved actually relates to run-time errors, while another was\nabout the \u003ccode\u003ego\u003c/code\u003e command’s help system.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“When an error is thrown, the call stack can be huge and includes a bunch of\nfiles I don’t care about. I just want to know where the problem is in MY\ncode, not the library I’m using, or how the panic was handled.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 1 – 2 years of\nexperience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Getting help via `go help run` dumps a wall of text, with links to\nfurther readings to find the available command-line flags. Or the fact that\nit understands `go run –help` but instead of showing the help, it says\n‘please run go help run instead’. Just show me list of flags in `go run\n–help`.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 3 –\n4 years of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/text_err_wish.svg\" alt=\"Chart of potential improvements\nfor Go\u0026#39;s error messages\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"microservices\"\u003eMicroservices\u003c/h2\u003e\n\u003cp\u003eWe commonly hear that developers find Go to be a great fit for microservices,\nbut we have never tried to quantify how many Go developers have adopted this\ntype of service architecture, understand how those services communicate with\none another, or the challenges developers encounter when working on them. This\nyear we added a few questions to better understand this space.\u003c/p\u003e\n\u003cp\u003eA plurality of respondents said they work mostly on microservices (43%), with\nanother ¼ saying they work on a mix of both microservices and monoliths. Only\nabout ⅕ of respondents work mostly on monolithic Go applications. This is one\nof the few areas where we see differences based on the size of organization\nrespondents work at—large organizations seem more likely to have adopted a\nmicroservice architecture than smaller companies. Respondents from large\norganizations (\u0026gt;1,000 employees) were most likely to say they work on\nmicroservices (55%), with only 11% of these respondents working primarily on\nmonoliths.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/service_arch.svg\" alt=\"Chart of respondents\u0026#39; primary\nservice architecture\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe see some bifurcation in the number of microservices comprising Go\nplatforms. One group is composed of a handful (2 to 5) of services (40%),\nwhile the other consists of larger collections, with a minimum of 10 component\nservices (37%). The number of microservices involved does not appear to be\ncorrelated with organization size.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/service_num.svg\" alt=\"Chart of the number of\nmicroservices respondents\u0026#39; systems involve\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eA large majority of respondents use some form of direct response request\n(e.g., RPC, HTTP, etc.) for microservice communication (72%). A smaller\nproportion use message queues (14%) or a pub/sub approach (9%); again, we see\nno differences here based on organization size.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/service_comm.svg\" alt=\"Chart of how microservices\ncommunicate with one another\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eA majority of respondents build microservices in a polyglot of languages, with\nonly about ¼ exclusively using Go. Python is the most common companion\nlanguage (33%), alongside Node.js (28%) and Java (26%). We again see\ndifferences based on organization size, with larger organizations more likely\nto be integrating Python (43%) and Java (36%) microservices, while smaller\norganizations are a bit more likely to only use Go (30%). Other languages\nappeared to be used equally based on organization size.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/service_lang.svg\" alt=\"Chart of other languages that Go\nmicroservices interact with\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eOverall, respondents told us testing and debugging were their biggest\nchallenge when writing microservice-based applications, followed by\noperational complexity. Many other challenges occupy the long tail on this\ngraph, though “portability” stands out as a non-issue for most respondents. We\ninterpret this to mean that such services aren’t intended to be portable\n(beyond basic containerization); for example, if an organization’s\nmicroservices are initially powered by PostgreSQL databases, developers aren’t\nconcerned with potentially porting this to an Oracle database in the near\nfuture.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/service_challenge.svg\" alt=\"Chart of challenges\nrespondents face when writing microservice-based applications\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"modules\"\u003eModule authorship and maintenance\u003c/h2\u003e\n\u003cp\u003eGo has a vibrant ecosystem of community-driven modules, and we want to\nunderstand the motivations and challenges faced by developers who maintain\nthese modules. We found that about ⅕ of respondents maintain (or used to\nmaintain) an open-source Go module. This was a surprisingly high proportion,\nand may be biased due to how we share this survey: module maintainers may be\nmore likely to closely follow the Go blog (where this survey is announced)\nthan other Go developers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/mod_maintainer.svg\" alt=\"Chart of how many respondents\nhave served as a maintainer for a public Go module\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eModule maintainers appear to be largely self-motivated—they report working\non modules that they need for personal (58%) or work (56%) projects, that they\ndo so because they enjoy working on these modules (63%) and being part of the\npublic Go community (44%), and that they learn useful skills from their module\nmaintainership (44%). More external motivations, such as receiving recognition\n(15%), career advancement (36%), or cash money (20%) are towards the bottom of\nthe list.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/mod_motivation.svg\" alt=\"Chart of the motivations of\npublic module maintainers\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eGiven the forms of \u003ca href=\"https://en.wikipedia.org/wiki/Motivation#Intrinsic_and_extrinsic\" rel=\"noreferrer\" target=\"_blank\"\u003eintrinsic\nmotivation\u003c/a\u003e identified above, it\nfollows that a key challenge for module maintainers is finding time to devote\nto their module (41%). While this might not seem like an actionable finding in\nitself (we can’t give Go developers an extra hour or two each day, right?),\nit’s a helpful lens through which to view module tooling and\ndevelopment—these tasks are most likely occurring while the developer is\nalready pressed for time, and perhaps it’s been weeks or months since they\nlast had an opportunity to work on it, so things aren’t fresh in their memory.\nThus, aspects like understandable and actionable error messages can be\nparticularly helpful: rather than require someone to once again search for\nspecific \u003ccode\u003ego\u003c/code\u003e command syntax, perhaps the error output could provide the\nsolution they need right in their terminal.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/mod_challenge.svg\" alt=\"Chart of challenges respondents\nface when maintaining public Go modules\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"demographics\"\u003eDemographics\u003c/h2\u003e\n\u003cp\u003eMost survey respondents reported using Go for their primary job (78%), and a\nmajority (59%) said they use it for personal or open-source projects. In fact,\nit’s common for respondents to use Go for \u003cem\u003eboth\u003c/em\u003e work and personal/OSS\nprojects, with 43% of respondents saying they use Go in each of these\nsituations.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/where.svg\" alt=\"Chart of situations in which\nrespondents recently used Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe majority of respondents have been working with Go for under five years\n(68%). As we’ve seen in \u003ca href=\"/blog/survey2023-q1-results#novice-respondents-are-more-likely-to-prefer-windows-than-more-experienced-respondents\"\u003eprior\nyears\u003c/a\u003e,\npeople who found this survey via VS Code tended to be less experienced than\npeople who found the survey via other channels.\u003c/p\u003e\n\u003cp\u003eWhen we break down where people use Go by their experience level, two findings\nstand out. First, a majority of respondents from all experience levels said\nthey’re using Go professionally; indeed, for people with over two years of\nexperience, the vast majority use Go at work (85% – 91%). A similar trend\nexists for open-source development. The second finding is that developers with\nless Go experience are more likely to be using Go to expand their skill set\n(38%) or to evaluate it for use at work (13%) than more experienced Go\ndevelopers. We interpret this to mean that many Gophers initially view Go as\npart of “upskilling” or expanding their understanding of software development,\nbut that within a year or two, they look to Go as more of a tool for doing\nthan learning.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/go_exp.svg\" alt=\"Chart of how long respondents have\nbeen working with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/where_exp.svg\" alt=\"Chart of situations in which\nrespondents recently used Go, split by their level of Go experience\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe most common use cases for Go continue to be API/RPC services (74%) and\ncommand line tools (62%). People tell us Go is a great choice for these types\nof software for several reasons, including its built-in HTTP server and\nconcurrency primitives, ease of cross-compilation, and single-binary\ndeployments.\u003c/p\u003e\n\u003cp\u003eThe intended audience for much of this tooling is in business settings (62%),\nwith 17% of respondents reporting that they develop primarily for more\nconsumer-oriented applications. This isn’t surprising given the low use of Go\nfor consumer-focused applications such as desktop, mobile, or gaming, vs. its\nvery high use for backend services, CLI tooling, and cloud development, but it\nis a useful confirmation of how heavily Go is used in B2B settings.\u003c/p\u003e\n\u003cp\u003eWe also looked for differences based on respondents’ level of experience with\nGo and organization size. More experienced Go developers reported building a\nwider variety of different things in Go; this trend was consistent across\nevery category of app or service. We did not find any notable differences in\nwhat respondents are building based on their organization size.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/what.svg\" alt=\"Chart of the types of things respondents\nare building with Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/enduser.svg\" alt=\"Chart of the audience using the\nsoftware respondents build\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eRespondents were about equally likely to say this was the first time they’ve\nresponded to the Go Developer Survey vs. saying they had taken this survey\nbefore. There is a meaningful difference between people who learned about this\nsurvey via the Go blog, where 61% reported taking this survey previously, vs.\npeople who learned about this survey via a notification in VS Code, where only\n31% said they’ve previously taken this survey. We don’t expect people to\nperfectly recall every survey they’ve responded to on the internet, but this\ngives us some confidence that we’re hearing from a balanced mix of new and\nrepeat respondents with each survey. Further, this tells us our combination of\nsocial media posts and random in-editor sampling are both necessary for\nhearing from a diverse set of Go developers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/return_respondent.svg\" alt=\"Chart of how many\nrespondents said they have taken this survey before\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"firmographics\"\u003eFirmographics\u003c/h2\u003e\n\u003cp\u003eRespondents to this survey reported working at a mix of different\norganizations, from thousand-person-plus enterprises (27%), to midsize\nbusinesses (25%) and smaller organizations with \u0026lt; 100 employees (44%). About\nhalf of respondents work in the technology industry (50%), a large increase\nover the next most-common industry—financial services—at 13%.\u003c/p\u003e\n\u003cp\u003eThis is statistically unchanged from the past few Go Developer Surveys—we\ncontinue to hear from people in different countries and in organizations of\ndifferent sizes and industries at consistent rates year after year.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/org_size.svg\" alt=\"Chart of the different organization\nsizes where respondents use Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/industry.svg\" alt=\"Chart of the different industries\nwhere respondents use Go\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/location.svg\" alt=\"Chart of countries or regions where\nrespondents are located\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"methodology\"\u003eMethodology\u003c/h2\u003e\n\u003cp\u003eMost survey respondents “self-selected” to take this survey, meaning they\nfound it on the Go blog or other social Go channels. A potential problem with\nthis approach is that people who don’t follow these channels are less likely\nto learn about the survey, and might respond differently than people who do\nclosely follow them. About 40% of respondents were randomly sampled, meaning\nthey responded to the survey after seeing a prompt for it in VS Code (everyone\nusing the VS Code Go plugin between mid-July – mid-August 2023 had a 10% of\nreceiving this random prompt). This randomly sampled group helps us generalize\nthese findings to the larger community of Go developers.\u003c/p\u003e\n\u003ch3 id=\"how-to-read-these-results\"\u003eHow to read these results\u003c/h3\u003e\n\u003cp\u003eThroughout this report we use charts of survey responses to provide supporting\nevidence for our findings. All of these charts use a similar format. The title\nis the exact question that survey respondents saw. Unless otherwise noted,\nquestions were multiple choice and participants could only select a single\nresponse choice; each chart’s subtitle will tell the reader if the question\nallowed multiple response choices or was an open-ended text box instead of a\nmultiple choice question. For charts of open-ended text responses, a Go team\nmember read and manually categorized the responses. Many open-ended questions\nelicited a wide variety of responses; to keep the chart sizes reasonable, we\ncondensed them to a maximum of the top 10 themes, with additional themes all\ngrouped under “Other”. The percentage labels shown in charts are rounded to\nthe nearest integer (e.g., 1.4% and 0.8% will both be displayed as 1%), but\nthe length of each bar and row ordering are based on the unrounded values.\u003c/p\u003e\n\u003cp\u003eTo help readers understand the weight of evidence underlying each finding, we\nincluded error bars showing the 95% \u003ca href=\"https://en.wikipedia.org/wiki/Confidence_interval\" rel=\"noreferrer\" target=\"_blank\"\u003econfidence\ninterval\u003c/a\u003e for responses;\nnarrower bars indicate increased confidence. Sometimes two or more responses\nhave overlapping error bars, which means the relative order of those responses\nis not statistically meaningful (i.e., the responses are effectively tied).\nThe lower right of each chart shows the number of people whose responses are\nincluded in the chart, in the form “n = [number of respondents]”.\u003c/p\u003e\n\u003cp\u003eWe include select quotes from respondents to help clarify many of our\nfindings. These quotes include the length of times the respondent has used Go.\nIf the respondent said they use Go at work, we refer to them as a\n“professional Go developer”; if they don’t use Go at work but do use Go for\nopen-source development, we refer to them as an “open-source Go developer”.\u003c/p\u003e\n\u003ch2 id=\"closing\"\u003eClosing\u003c/h2\u003e\n\u003cp\u003eThe final question on our survey always asks respondents whether there’s\nanything else they’d like to share with us about Go. The most common piece of\nfeedback people provide is “thanks!”, and this year was no different (33%). In\nterms of requested language improvements, we see a three-way statistical tie\nbetween improved expressivity (12%), improved error handling (12%), and\nimproved type safety or reliability (9%). Respondents had a variety of ideas\nfor improving expressivity, with the general trend of this feedback being\n“Here’s a specific thing I write frequently, and I wish it were easier to\nexpress this in Go”. The issues with error handling continue to be complaints\nabout the verbosity of this code today, while feedback about type safety most\ncommonly touched on \u003ca href=\"https://en.wikipedia.org/wiki/Tagged_union\" rel=\"noreferrer\" target=\"_blank\"\u003esum types\u003c/a\u003e.\nThis type of high-level feedback is extremely useful when the Go team tries to\nplan focus areas for the coming year, as it tells us general directions in\nwhich the community is hoping to steer the ecosystem.\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“I know about Go’s attitude towards simplicity and I appreciate it. I just\nwish there [were] slightly more features. For me it would be better error\nhandling (not exceptions though), and maybe some common creature comforts\nlike map/reduce/filter and ternary operators. Anything not too obscure\nthat’ll save me some ‘if’ statements.” \u003cspan class=\"quote_source\"\u003e—\nProfessional Go developer w/ 1 – 2 years of experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e“Please keep Go in line with the long term values Go established so long ago\n— language and library stability. […] It is an environment I can\nrely on to not break my code after 2 or 3 years. For that, thank you very\nmuch.” \u003cspan class=\"quote_source\"\u003e— Professional Go developer w/ 10+ years\nof experience\u003c/span\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"survey2023h2/text_anything_else.svg\" alt=\"Chart of other topics\nrespondents shared with us\" class=\"chart\"/\u003e\u003c/p\u003e\n\u003cp\u003eThat’s all for this bi-annual iteration of the Go Developer Survey. Thanks to\neveryone who shared their feedback about Go—we have immense gratitude for\ntaking your time to help shape Go’s future, and we hope you see some of your\nown feedback reflected in this report. 🩵\u003c/p\u003e\n\u003cp\u003e— Todd (on behalf of the Go team at Google)\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-12-05T00:00:00Z",
  "Author": "Todd Kulesza"
}