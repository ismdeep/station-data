{
  "Source": "go.dev",
  "Title": "Fourteen Years of Go",
  "Link": "https://go.dev/blog/14years",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/14years\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eFourteen Years of Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox, for the Go team\u003cbr/\u003e\n      10 November 2023\n      \u003c/p\u003e\n      \n      \u003cimg src=\"/doc/gopher/gopherdrink.png\" height=\"219\" width=\"223\" align=\"right\" style=\"margin: 0 0 1em 1em;\"/\u003e\n\u003cp\u003eToday we celebrate the fourteenth birthday of the Go open source release!\nGo has had a great year, with two feature-filled releases and other important milestones.\u003c/p\u003e\n\u003cp\u003eWe released \u003ca href=\"/blog/go1.20\"\u003eGo 1.20 in February\u003c/a\u003e\nand \u003ca href=\"/blog/go1.21\"\u003eGo 1.21 in August\u003c/a\u003e,\nfocusing more on implementation improvements\nthan new language changes.\u003c/p\u003e\n\u003cp\u003eProfile-guided optimization (PGO),\n\u003ca href=\"/blog/pgo-preview\"\u003epreviewed in Go 1.20\u003c/a\u003e\nand\n\u003ca href=\"/blog/pgo\"\u003ereleased in Go 1.21\u003c/a\u003e,\nallows the Go compiler to read a profile of your program\nand then spend more time optimizing the parts\nof your program that run most often.\nIn Go 1.21, workloads typically get between\n2% and 7% CPU usage improvements from enabling PGO.\nSee “\u003ca href=\"/blog/pgo\"\u003eProfile-guided optimization in Go 1.21\u003c/a\u003e” for an overview\nand the \u003ca href=\"/doc/pgo\"\u003eprofile-guided optimization user guide\u003c/a\u003e\nfor complete documentation.\u003c/p\u003e\n\u003cp\u003eGo has provided support for gathering coverage profiles during \u003ccode\u003ego test\u003c/code\u003e\n\u003ca href=\"/blog/cover\"\u003esince Go 1.2\u003c/a\u003e.\nGo 1.20 added support for gathering coverage profiles in binaries\nbuilt by \u003ccode\u003ego build\u003c/code\u003e,\nallowing you to gather coverage during larger integration tests as well.\nSee “\u003ca href=\"/blog/integration-test-coverage\"\u003eCode coverage for Go integration tests\u003c/a\u003e” for details.\u003c/p\u003e\n\u003cp\u003eCompatibility has been an important part of Go since\n“\u003ca href=\"/doc/go1compat\"\u003eGo 1 and the Future of Go Programs\u003c/a\u003e”.\nGo 1.21 improved compatibility further\nby expanding the conventions for use of GODEBUG\nin situations where we need to make a change,\nsuch as an important bug fix,\nthat must be permitted but may still break existing programs.\nSee the blog post\n“\u003ca href=\"/blog/compat\"\u003eBackward Compatibility, Go 1.21, and Go 2\u003c/a\u003e”\nfor an overview and\nthe documentation\n“\u003ca href=\"/doc/godebug\"\u003eGo, Backwards Compatibility, and GODEBUG\u003c/a\u003e” for details.\u003c/p\u003e\n\u003cp\u003eGo 1.21 also shipped support for built-in toolchain management,\nallowing you to change which version of the\nGo toolchain you use in a specific module\nas easily as you change the versions of other dependencies.\nSee the blog post\n“\u003ca href=\"/blog/toolchain\"\u003eForward Compatibility and Toolchain Management in Go 1.21\u003c/a\u003e”\nfor an overview and the documentation\n“\u003ca href=\"/doc/toolchain\"\u003eGo Toolchains\u003c/a\u003e”\nfor details.\u003c/p\u003e\n\u003cp\u003eAnother important tooling achievement was the\nintegration of on-disk indexes into\ngopls, the Go LSP server.\nThis cut gopls’s startup latency and memory usage by 3-5X\nin typical use cases.\n“\u003ca href=\"/blog/gopls-scalability\"\u003eScaling gopls for the growing Go ecosystem\u003c/a\u003e”\nexplains the technical details.\nYou can make sure you’re running the latest gopls by running:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ego install golang.org/x/tools/gopls@latest\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eGo 1.21 introduced new\n\u003ca href=\"/pkg/cmp/\"\u003ecmp\u003c/a\u003e,\n\u003ca href=\"/pkg/maps/\"\u003emaps\u003c/a\u003e,\nand\n\u003ca href=\"/pkg/slices/\"\u003eslices\u003c/a\u003e\npackages — Go’s first generic standard libraries —\nas well as expanding the set of comparable types.\nFor details about that, see the blog post\n“\u003ca href=\"/blog/comparable\"\u003eAll your comparable types\u003c/a\u003e”.\u003c/p\u003e\n\u003cp\u003eOverall, we continue to refine generics\nand to write talks and blog posts explaining\nimportant details.\nTwo notable posts this year were\n“\u003ca href=\"/blog/deconstructing-type-parameters\"\u003eDeconstructing Type Parameters\u003c/a\u003e”,\nand\n“\u003ca href=\"/blog/type-inference\"\u003eEverything You Always Wanted to Know About Type Inference – And a Little Bit More\u003c/a\u003e”.\u003c/p\u003e\n\u003cp\u003eAnother important new package in Go 1.21 is\n\u003ca href=\"/pkg/log/slog/\"\u003elog/slog\u003c/a\u003e,\nwhich adds an official API for\nstructured logging to the standard library.\nSee “\u003ca href=\"/blog/slog\"\u003eStructured logging with slog\u003c/a\u003e” for an overview.\u003c/p\u003e\n\u003cp\u003eFor the WebAssembly (Wasm) port, Go 1.21 shipped support\nfor running on WebAssembly System Interface (WASI) preview 1.\nWASI preview 1 is a new “operating system” interface for Wasm\nthat is supported by most server-side Wasm environments.\nSee “\u003ca href=\"/blog/wasi\"\u003eWASI support in Go\u003c/a\u003e” for a walkthrough.\u003c/p\u003e\n\u003cp\u003eOn the security side, we are continuing to make sure\nGo leads the way in helping developers understand their\ndependencies and vulnerabilities,\nwith \u003ca href=\"/blog/govulncheck\"\u003eGovulncheck 1.0 launching in July\u003c/a\u003e.\nIf you use VS Code, you can run govulncheck directly in your\neditor using the Go extension:\nsee \u003ca href=\"/doc/tutorial/govulncheck-ide\"\u003ethis tutorial\u003c/a\u003e to get started.\nAnd if you use GitHub, you can run govulncheck as part of\nyour CI/CD, with the\n\u003ca href=\"https://github.com/marketplace/actions/golang-govulncheck-action\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub Action for govulncheck\u003c/a\u003e.\nFor more about checking your dependencies for vulnerability problems,\nsee this year’s Google I/O talk,\n“\u003ca href=\"https://www.youtube.com/watch?v=HSt6FhsPT8c\u0026amp;ab_channel=TheGoProgrammingLanguage\" rel=\"noreferrer\" target=\"_blank\"\u003eBuild more secure apps with Go and Google\u003c/a\u003e”.)\u003c/p\u003e\n\u003cp\u003eAnother important security milestone was\nGo 1.21’s highly reproducible toolchain builds.\nSee “\u003ca href=\"/blog/rebuild\"\u003ePerfectly Reproducible, Verified Go Toolchains\u003c/a\u003e” for details,\nincluding a demonstration of reproducing an Ubuntu Linux Go toolchain\non a Mac without using any Linux tools at all.\u003c/p\u003e\n\u003cp\u003eIt has been a busy year!\u003c/p\u003e\n\u003cp\u003eIn Go’s 15th year, we’ll keep working to make Go the best environment\nfor software engineering at scale.\nOne change we’re particularly excited about is\nredefining for loop \u003ccode\u003e:=\u003c/code\u003e semantics to remove the\npotential for accidental aliasing bugs.\nSee “\u003ca href=\"/blog/loopvar-preview\"\u003eFixing For Loops in Go 1.22\u003c/a\u003e”\nfor details,\nincluding instructions for previewing this change in Go 1.21.\u003c/p\u003e\n\u003ch2 id=\"thank-you\"\u003eThank You!\u003c/h2\u003e\n\u003cp\u003eThe Go project has always been far more than just us on the Go team at Google.\nThank you to all our contributors and everyone in the Go community for\nmaking Go what it is today.\nWe wish you all the best in the year ahead.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-11-10T00:00:00Z",
  "Author": "Russ Cox, for the Go team"
}