{
  "Source": "go.dev",
  "Title": "Package names",
  "Link": "https://go.dev/blog/package-names",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/package-names\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003ePackage names\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Sameer Ajmani\u003cbr/\u003e\n      4 February 2015\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo code is organized into packages.\nWithin a package, code can refer to any identifier (name) defined within, while\nclients of the package may only reference the package’s exported types,\nfunctions, constants, and variables.\nSuch references always include the package name as a prefix: \u003ccode\u003efoo.Bar\u003c/code\u003e refers to\nthe exported name \u003ccode\u003eBar\u003c/code\u003e in the imported package named \u003ccode\u003efoo\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eGood package names make code better.\nA package’s name provides context for its contents, making it easier for clients\nto understand what the package is for and how to use it.\nThe name also helps package maintainers determine what does and does not belong\nin the package as it evolves.\nWell-named packages make it easier to find the code you need.\u003c/p\u003e\n\u003cp\u003eEffective Go provides\n\u003ca href=\"/doc/effective_go.html#names\"\u003eguidelines\u003c/a\u003e for naming\npackages, types, functions, and variables.\nThis article expands on that discussion and surveys names found in the standard\nlibrary.\nIt also discusses bad package names and how to fix them.\u003c/p\u003e\n\u003ch2 id=\"package-names\"\u003ePackage names\u003c/h2\u003e\n\u003cp\u003eGood package names are short and clear.\nThey are lower case, with no \u003ccode\u003eunder_scores\u003c/code\u003e or \u003ccode\u003emixedCaps\u003c/code\u003e.\nThey are often simple nouns, such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003etime\u003c/code\u003e (provides functionality for measuring and displaying time)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elist\u003c/code\u003e (implements a doubly linked list)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehttp\u003c/code\u003e (provides HTTP client and server implementations)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe style of names typical of another language might not be idiomatic in a Go\nprogram.\nHere are two examples of names that might be good style in other languages but\ndo not fit well in Go:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecomputeServiceClient\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epriority_queue\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eA Go package may export several types and functions.\nFor example, a \u003ccode\u003ecompute\u003c/code\u003e package could export a \u003ccode\u003eClient\u003c/code\u003e type with methods for\nusing the service as well as functions for partitioning a compute task across\nseveral clients.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAbbreviate judiciously.\u003c/strong\u003e\nPackage names may be abbreviated when the abbreviation is familiar to the\nprogrammer.\nWidely-used packages often have compressed names:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estrconv\u003c/code\u003e (string conversion)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esyscall\u003c/code\u003e (system call)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efmt\u003c/code\u003e (formatted I/O)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOn the other hand, if abbreviating a package name makes it ambiguous or unclear,\ndon’t do it.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDon’t steal good names from the user.\u003c/strong\u003e\nAvoid giving a package a name that is commonly used in client code.\nFor example, the buffered I/O package is called \u003ccode\u003ebufio\u003c/code\u003e, not \u003ccode\u003ebuf\u003c/code\u003e, since \u003ccode\u003ebuf\u003c/code\u003e\nis a good variable name for a buffer.\u003c/p\u003e\n\u003ch2 id=\"naming-package-contents\"\u003eNaming package contents\u003c/h2\u003e\n\u003cp\u003eA package name and its contents’ names are coupled, since client code uses them\ntogether.\nWhen designing a package, take the client’s point of view.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid repetition.\u003c/strong\u003e\nSince client code uses the package name as a prefix when referring to the\npackage contents, the names for those contents need not repeat the package name.\nThe HTTP server provided by the \u003ccode\u003ehttp\u003c/code\u003e package is called \u003ccode\u003eServer\u003c/code\u003e, not\n\u003ccode\u003eHTTPServer\u003c/code\u003e.\nClient code refers to this type as \u003ccode\u003ehttp.Server\u003c/code\u003e, so there is no ambiguity.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eSimplify function names.\u003c/strong\u003e\nWhen a function in package pkg returns a value of type \u003ccode\u003epkg.Pkg\u003c/code\u003e (or\n\u003ccode\u003e*pkg.Pkg\u003c/code\u003e), the function name can often omit the type name without confusion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estart := time.Now()                                  // start is a time.Time\nt, err := time.Parse(time.Kitchen, \u0026#34;6:06PM\u0026#34;)         // t is a time.Time\nctx = context.WithTimeout(ctx, 10*time.Millisecond)  // ctx is a context.Context\nip, ok := userip.FromContext(ctx)                    // ip is a net.IP\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA function named \u003ccode\u003eNew\u003c/code\u003e in package \u003ccode\u003epkg\u003c/code\u003e returns a value of type \u003ccode\u003epkg.Pkg\u003c/code\u003e.\nThis is a standard entry point for client code using that type:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e q := list.New()  // q is a *list.List\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWhen a function returns a value of type \u003ccode\u003epkg.T\u003c/code\u003e, where \u003ccode\u003eT\u003c/code\u003e is not \u003ccode\u003ePkg\u003c/code\u003e, the\nfunction name may include \u003ccode\u003eT\u003c/code\u003e to make client code easier to understand.\nA common situation is a package with multiple New-like functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ed, err := time.ParseDuration(\u0026#34;10s\u0026#34;)  // d is a time.Duration\nelapsed := time.Since(start)         // elapsed is a time.Duration\nticker := time.NewTicker(d)          // ticker is a *time.Ticker\ntimer := time.NewTimer(d)            // timer is a *time.Timer\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTypes in different packages can have the same name, because from the client’s\npoint of view such names are discriminated by the package name.\nFor example, the standard library includes several types named \u003ccode\u003eReader\u003c/code\u003e,\nincluding \u003ccode\u003ejpeg.Reader\u003c/code\u003e, \u003ccode\u003ebufio.Reader\u003c/code\u003e, and \u003ccode\u003ecsv.Reader\u003c/code\u003e.\nEach package name fits with \u003ccode\u003eReader\u003c/code\u003e to yield a good type name.\u003c/p\u003e\n\u003cp\u003eIf you cannot come up with a package name that’s a meaningful prefix for the\npackage’s contents, the package abstraction boundary may be wrong.\nWrite code that uses your package as a client would, and restructure your\npackages if the result seems poor.\nThis approach will yield packages that are easier for clients to understand and\nfor the package developers to maintain.\u003c/p\u003e\n\u003ch2 id=\"package-paths\"\u003ePackage paths\u003c/h2\u003e\n\u003cp\u003eA Go package has both a name and a path.\nThe package name is specified in the package statement of its source files;\nclient code uses it as the prefix for the package’s exported names.\nClient code uses the package path when importing the package.\nBy convention, the last element of the package path is the package name:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eimport (\n    \u0026#34;context\u0026#34;                // package context\n    \u0026#34;fmt\u0026#34;                    // package fmt\n    \u0026#34;golang.org/x/time/rate\u0026#34; // package rate\n    \u0026#34;os/exec\u0026#34;                // package exec\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBuild tools map package paths onto directories.\nThe go tool uses the \u003ca href=\"/doc/code.html#GOPATH\"\u003eGOPATH\u003c/a\u003e\nenvironment variable to find the source files for path \u003ccode\u003e\u0026#34;github.com/user/hello\u0026#34;\u003c/code\u003e\nin directory \u003ccode\u003e$GOPATH/src/github.com/user/hello\u003c/code\u003e.\n(This situation should be familiar, of course, but it’s important to be clear\nabout the terminology and structure of packages.)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDirectories.\u003c/strong\u003e\nThe standard library uses directories like \u003ccode\u003ecrypto\u003c/code\u003e, \u003ccode\u003econtainer\u003c/code\u003e, \u003ccode\u003eencoding\u003c/code\u003e,\nand \u003ccode\u003eimage\u003c/code\u003e to group packages for related protocols and algorithms.\nThere is no actual relationship among the packages in one of these directories;\na directory just provides a way to arrange the files.\nAny package can import any other package provided the import does not create a\ncycle.\u003c/p\u003e\n\u003cp\u003eJust as types in different packages can have the same name without ambiguity,\npackages in different directories can have the same name.\nFor example,\n\u003ca href=\"/pkg/runtime/pprof\"\u003eruntime/pprof\u003c/a\u003e provides profiling data\nin the format expected by the \u003ca href=\"https://github.com/google/pprof\" rel=\"noreferrer\" target=\"_blank\"\u003epprof\u003c/a\u003e\nprofiling tool, while \u003ca href=\"/pkg/net/http/pprof\"\u003enet/http/pprof\u003c/a\u003e\nprovides HTTP endpoints to present profiling data in this format.\nClient code uses the package path to import the package, so there is no\nconfusion.\nIf a source file needs to import both \u003ccode\u003epprof\u003c/code\u003e packages, it can\n\u003ca href=\"/ref/spec#Import_declarations\"\u003erename\u003c/a\u003e one or both locally.\nWhen renaming an imported package, the local name should follow the same\nguidelines as package names (lower case, no \u003ccode\u003eunder_scores\u003c/code\u003e or \u003ccode\u003emixedCaps\u003c/code\u003e).\u003c/p\u003e\n\u003ch2 id=\"bad-package-names\"\u003eBad package names\u003c/h2\u003e\n\u003cp\u003eBad package names make code harder to navigate and maintain.\nHere are some guidelines for recognizing and fixing bad names.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid meaningless package names.\u003c/strong\u003e\nPackages named \u003ccode\u003eutil\u003c/code\u003e, \u003ccode\u003ecommon\u003c/code\u003e, or \u003ccode\u003emisc\u003c/code\u003e provide clients with no sense of what\nthe package contains.\nThis makes it harder for clients to use the package and makes it harder for\nmaintainers to keep the package focused.\nOver time, they accumulate dependencies that can make compilation significantly\nand unnecessarily slower, especially in large programs.\nAnd since such package names are generic, they are more likely to collide with\nother packages imported by client code, forcing clients to invent names to\ndistinguish them.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBreak up generic packages.\u003c/strong\u003e\nTo fix such packages, look for types and functions with common name elements and\npull them into their own package.\nFor example, if you have\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage util\nfunc NewStringSet(...string) map[string]bool {...}\nfunc SortStringSet(map[string]bool) []string {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen client code looks like\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eset := util.NewStringSet(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)\nfmt.Println(util.SortStringSet(set))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePull these functions out of \u003ccode\u003eutil\u003c/code\u003e into a new package, choosing a name that fits\nthe contents:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage stringset\nfunc New(...string) map[string]bool {...}\nfunc Sort(map[string]bool) []string {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen the client code becomes\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eset := stringset.New(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)\nfmt.Println(stringset.Sort(set))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce you’ve made this change, it’s easier to see how to improve the new package:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage stringset\ntype Set map[string]bool\nfunc New(...string) Set {...}\nfunc (s Set) Sort() []string {...}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ewhich yields even simpler client code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eset := stringset.New(\u0026#34;c\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;)\nfmt.Println(set.Sort())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe name of the package is a critical piece of its design.\nWork to eliminate meaningless package names from your projects.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDon’t use a single package for all your APIs.\u003c/strong\u003e\nMany well-intentioned programmers put all the interfaces exposed by their\nprogram into a single package named \u003ccode\u003eapi\u003c/code\u003e, \u003ccode\u003etypes\u003c/code\u003e, or \u003ccode\u003einterfaces\u003c/code\u003e, thinking it\nmakes it easier to find the entry points to their code base.\nThis is a mistake.\nSuch packages suffer from the same problems as those named \u003ccode\u003eutil\u003c/code\u003e or \u003ccode\u003ecommon\u003c/code\u003e,\ngrowing without bound, providing no guidance to users, accumulating\ndependencies, and colliding with other imports.\nBreak them up, perhaps using directories to separate public packages from\nimplementation.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAvoid unnecessary package name collisions.\u003c/strong\u003e\nWhile packages in different directories may have the same name, packages that\nare frequently used together should have distinct names.\nThis reduces confusion and the need for local renaming in client code.\nFor the same reason, avoid using the same name as popular standard packages like\n\u003ccode\u003eio\u003c/code\u003e or \u003ccode\u003ehttp\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003ePackage names are central to good naming in Go programs.\nTake the time to choose good package names and organize your code well.\nThis helps clients understand and use your packages and helps maintainers to\ngrow them gracefully.\u003c/p\u003e\n\u003ch2 id=\"further-reading\"\u003eFurther reading\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/doc/effective_go.html\"\u003eEffective Go\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/doc/code.html\"\u003eHow to Write Go Code\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/blog/organizing-go-code\"\u003eOrganizing Go Code (2012 blog post)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/talks/2014/organizeio.slide\"\u003eOrganizing Go Code (2014 Google I/O talk)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2015-02-04T00:00:00Z",
  "Author": "Sameer Ajmani"
}