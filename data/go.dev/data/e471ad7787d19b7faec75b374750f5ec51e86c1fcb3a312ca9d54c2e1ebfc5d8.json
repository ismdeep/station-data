{
  "Source": "go.dev",
  "Title": "A GIF decoder: an exercise in Go interfaces",
  "Link": "https://go.dev/blog/gif-decoder",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/gif-decoder\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eA GIF decoder: an exercise in Go interfaces\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      25 May 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eAt the Google I/O conference in San Francisco on May 10,\n2011, we announced that the Go language is now available on Google App Engine.\nGo is the first language to be made available on App Engine that compiles\ndirectly to machine code,\nwhich makes it a good choice for CPU-intensive tasks such as image manipulation.\u003c/p\u003e\n\u003cp\u003eIn that vein, we demonstrated a program called \u003ca href=\"http://moustach-io.appspot.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eMoustachio\u003c/a\u003e\nthat makes it easy to improve a picture such as this one:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"gif-decoder/image00.jpg\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eby adding a moustache and sharing the result:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"gif-decoder/image02.jpg\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eAll the graphical processing, including rendering the antialiased moustache,\nis done by a Go program running on App Engine.\n(The source is available at \u003ca href=\"http://code.google.com/p/appengine-go/source/browse/example/moustachio/\" rel=\"noreferrer\" target=\"_blank\"\u003ethe appengine-go project\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eAlthough most images on the web—at least those likely to be moustachioed—are JPEGs,\nthere are countless other formats floating around,\nand it seemed reasonable for Moustachio to accept uploaded images in a few of them.\nJPEG and PNG decoders already existed in the Go image library,\nbut the venerable GIF format was not represented,\nso we decided to write a GIF decoder in time for the announcement.\nThat decoder contains a few pieces that demonstrate how Go’s interfaces\nmake some problems easier to solve.\nThe rest of this blog post describes a couple of instances.\u003c/p\u003e\n\u003ch2 id=\"the-gif-format\"\u003eThe GIF format\u003c/h2\u003e\n\u003cp\u003eFirst, a quick tour of the GIF format.  A GIF image file is \u003cem\u003epaletted\u003c/em\u003e,\nthat is, each pixel value is an index into a fixed color map that is included in the file.\nThe GIF format dates from a time when there were usually no more than 8\nbits per pixel on the display,\nand a color map was used to convert the limited set of values into the RGB (red,\ngreen, blue) triples needed to light the screen.\n(This is in contrast to a JPEG, for example,\nwhich has no color map because the encoding represents the distinct color\nsignals separately.)\u003c/p\u003e\n\u003cp\u003eA GIF image can contain anywhere from 1 to 8 bits per pixel, inclusive, but 8 bits per pixel is the most common.\u003c/p\u003e\n\u003cp\u003eSimplifying somewhat, a GIF file contains a header defining the pixel depth\nand image dimensions,\na color map (256 RGB triples for an 8-bit image),\nand then the pixel data.\nThe pixel data is stored as a one-dimensional bit stream,\ncompressed using the LZW algorithm, which is quite effective for computer-generated\ngraphics although not so good for photographic imagery.\nThe compressed data is then broken into length-delimited blocks with a one-byte\ncount (0-255) followed by that many bytes:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"gif-decoder/image03.gif\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003ch2 id=\"deblocking-the-pixel-data\"\u003eDeblocking the pixel data\u003c/h2\u003e\n\u003cp\u003eTo decode GIF pixel data in Go, we can use the LZW decompressor from the\n\u003ccode\u003ecompress/lzw\u003c/code\u003e package.\nIt has a NewReader function that returns an object that,\nas \u003ca href=\"/pkg/compress/lzw/#NewReader\"\u003ethe documentation\u003c/a\u003e says,\n“satisfies reads by decompressing the data read from r”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc NewReader(r io.Reader, order Order, litWidth int) io.ReadCloser\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere \u003ccode\u003eorder\u003c/code\u003e defines the bit-packing order and \u003ccode\u003elitWidth\u003c/code\u003e is the word size in bits,\nwhich for a GIF file corresponds to the pixel depth, typically 8.\u003c/p\u003e\n\u003cp\u003eBut we can’t just give \u003ccode\u003eNewReader\u003c/code\u003e the input file as its first argument\nbecause the decompressor needs a stream of bytes but the GIF data is a stream\nof blocks that must be unpacked.\nTo address this problem, we can wrap the input \u003ccode\u003eio.Reader\u003c/code\u003e with some code to deblock it,\nand make that code again implement \u003ccode\u003eReader\u003c/code\u003e.\nIn other words, we put the deblocking code into the \u003ccode\u003eRead\u003c/code\u003e method of a new type,\nwhich we call \u003ccode\u003eblockReader\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eHere’s the data structure for a \u003ccode\u003eblockReader\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype blockReader struct {\n   r     reader    // Input source; implements io.Reader and io.ByteReader.\n   slice []byte    // Buffer of unread data.\n   tmp   [256]byte // Storage for slice.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe reader, \u003ccode\u003er\u003c/code\u003e, will be the source of the image data,\nperhaps a file or HTTP connection.\nThe \u003ccode\u003eslice\u003c/code\u003e and \u003ccode\u003etmp\u003c/code\u003e fields will be used to manage the deblocking.\nHere’s the \u003ccode\u003eRead\u003c/code\u003e method in its entirety.\nIt’s a nice example of the use of slices and arrays in Go.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1  func (b *blockReader) Read(p []byte) (int, os.Error) {\n2      if len(p) == 0 {\n3          return 0, nil\n4      }\n5      if len(b.slice) == 0 {\n6          blockLen, err := b.r.ReadByte()\n7          if err != nil {\n8              return 0, err\n9          }\n10          if blockLen == 0 {\n11              return 0, os.EOF\n12          }\n13          b.slice = b.tmp[0:blockLen]\n14          if _, err = io.ReadFull(b.r, b.slice); err != nil {\n15              return 0, err\n16          }\n17      }\n18      n := copy(p, b.slice)\n19      b.slice = b.slice[n:]\n20      return n, nil\n21  }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLines 2-4 are just a sanity check: if there’s no place to put data, return zero.\nThat should never happen, but it’s good to be safe.\u003c/p\u003e\n\u003cp\u003eLine 5 asks if there’s data left over from a previous call by checking the\nlength of \u003ccode\u003eb.slice\u003c/code\u003e.\nIf there isn’t, the slice will have length zero and we need to read the\nnext block from \u003ccode\u003er\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eA GIF block starts with a byte count, read on line 6.\nIf the count is zero, GIF defines this to be a terminating block,\nso we return \u003ccode\u003eEOF\u003c/code\u003e on line 11.\u003c/p\u003e\n\u003cp\u003eNow we know we should read \u003ccode\u003eblockLen\u003c/code\u003e bytes,\nso we point \u003ccode\u003eb.slice\u003c/code\u003e to the first \u003ccode\u003eblockLen\u003c/code\u003e bytes of \u003ccode\u003eb.tmp\u003c/code\u003e and then\nuse the helper function \u003ccode\u003eio.ReadFull\u003c/code\u003e to read that many bytes.\nThat function will return an error if it can’t read exactly that many bytes,\nwhich should never happen.\nOtherwise we have \u003ccode\u003eblockLen\u003c/code\u003e bytes ready to read.\u003c/p\u003e\n\u003cp\u003eLines 18-19 copy the data from \u003ccode\u003eb.slice\u003c/code\u003e to the caller’s buffer.\nWe are implementing \u003ccode\u003eRead\u003c/code\u003e, not \u003ccode\u003eReadFull\u003c/code\u003e,\nso we are allowed to return fewer than the requested number of bytes.\nThat makes it easy: we just copy the data from \u003ccode\u003eb.slice\u003c/code\u003e to the caller’s buffer (\u003ccode\u003ep\u003c/code\u003e),\nand the return value from copy is the number of bytes transferred.\nThen we reslice \u003ccode\u003eb.slice\u003c/code\u003e to drop the first \u003ccode\u003en\u003c/code\u003e bytes,\nready for the next call.\u003c/p\u003e\n\u003cp\u003eIt’s a nice technique in Go programming to couple a slice (\u003ccode\u003eb.slice\u003c/code\u003e) to an array (\u003ccode\u003eb.tmp\u003c/code\u003e).\nIn this case, it means \u003ccode\u003eblockReader\u003c/code\u003e type’s \u003ccode\u003eRead\u003c/code\u003e method never does any allocations.\nIt also means we don’t need to keep a count around (it’s implicit in the slice length),\nand the built-in \u003ccode\u003ecopy\u003c/code\u003e function guarantees we never copy more than we should.\n(For more about slices, see \u003ca href=\"/blog/go-slices-usage-and-internals\"\u003ethis post from the Go Blog\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eGiven the \u003ccode\u003eblockReader\u003c/code\u003e type, we can unblock the image data stream just\nby wrapping the input reader,\nsay a file, like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003edeblockingReader := \u0026amp;blockReader{r: imageFile}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis wrapping turns a block-delimited GIF image stream into a simple stream\nof bytes accessible by calls to the \u003ccode\u003eRead\u003c/code\u003e method of the \u003ccode\u003eblockReader\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"connecting-the-pieces\"\u003eConnecting the pieces\u003c/h2\u003e\n\u003cp\u003eWith \u003ccode\u003eblockReader\u003c/code\u003e implemented and the LZW compressor available from the library,\nwe have all the pieces we need to decode the image data stream.\nWe stitch them together with this thunderclap,\nstraight from the code:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elzwr := lzw.NewReader(\u0026amp;blockReader{r: d.r}, lzw.LSB, int(litWidth))\nif _, err = io.ReadFull(lzwr, m.Pix); err != nil {\n   break\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThat’s it.\u003c/p\u003e\n\u003cp\u003eThe first line creates a \u003ccode\u003eblockReader\u003c/code\u003e and passes it to \u003ccode\u003elzw.NewReader\u003c/code\u003e\nto create a decompressor.\nHere \u003ccode\u003ed.r\u003c/code\u003e is the \u003ccode\u003eio.Reader\u003c/code\u003e holding the image data,\n\u003ccode\u003elzw.LSB\u003c/code\u003e defines the byte order in the LZW decompressor,\nand \u003ccode\u003elitWidth\u003c/code\u003e is the pixel depth.\u003c/p\u003e\n\u003cp\u003eGiven the decompressor, the second line calls \u003ccode\u003eio.ReadFull\u003c/code\u003e to decompress\nthe data and store it in the image, \u003ccode\u003em.Pix\u003c/code\u003e.\nWhen \u003ccode\u003eReadFull\u003c/code\u003e returns, the image data is decompressed and stored in the image,\n\u003ccode\u003em\u003c/code\u003e, ready to be displayed.\u003c/p\u003e\n\u003cp\u003eThis code worked first time. Really.\u003c/p\u003e\n\u003cp\u003eWe could avoid the temporary variable \u003ccode\u003elzwr\u003c/code\u003e by placing the \u003ccode\u003eNewReader\u003c/code\u003e\ncall into the argument list for \u003ccode\u003eReadFull\u003c/code\u003e,\njust as we built the \u003ccode\u003eblockReader\u003c/code\u003e inside the call to \u003ccode\u003eNewReader\u003c/code\u003e,\nbut that might be packing too much into a single line of code.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eGo’s interfaces make it easy to construct software by assembling piece parts\nlike this to restructure data.\nIn this example, we implemented GIF decoding by chaining together a deblocker\nand a decompressor using the \u003ccode\u003eio.Reader\u003c/code\u003e interface,\nanalogous to a type-safe Unix pipeline.\nAlso, we wrote the deblocker as an (implicit) implementation of a \u003ccode\u003eReader\u003c/code\u003e interface,\nwhich then required no extra declaration or boilerplate to fit it into the\nprocessing pipeline.\nIt’s hard to implement this decoder so compactly yet cleanly and safely in most languages,\nbut the interface mechanism plus a few conventions make it almost natural in Go.\u003c/p\u003e\n\u003cp\u003eThat deserves another picture, a GIF this time:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"gif-decoder/image01.gif\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe GIF format is defined at \u003ca href=\"http://www.w3.org/Graphics/GIF/spec-gif89a.txt\" rel=\"noreferrer\" target=\"_blank\"\u003ehttp://www.w3.org/Graphics/GIF/spec-gif89a.txt\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-05-25T00:00:00Z",
  "Author": "Rob Pike"
}