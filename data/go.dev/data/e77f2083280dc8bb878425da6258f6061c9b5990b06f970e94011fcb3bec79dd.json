{
  "Source": "go.dev",
  "Title": "Organizing Go code",
  "Link": "https://go.dev/blog/organizing-go-code",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/organizing-go-code\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eOrganizing Go code\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      16 August 2012\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eGo code is organized differently to that of other languages.\nThis post discusses how to name and package the elements of your Go program\nto best serve its users.\u003c/p\u003e\n\u003ch2 id=\"choose-good-names\"\u003eChoose good names\u003c/h2\u003e\n\u003cp\u003eThe names you choose affect how you think about your code,\nso take care when naming your package and its exported identifiers.\u003c/p\u003e\n\u003cp\u003eA package’s name provides context for its contents.\nFor instance, the \u003ca href=\"/pkg/bytes/\"\u003ebytes package\u003c/a\u003e from\nthe standard library exports the \u003ccode\u003eBuffer\u003c/code\u003e type.\nOn its own, the name \u003ccode\u003eBuffer\u003c/code\u003e isn’t very descriptive,\nbut when combined with its package name its meaning becomes clear: \u003ccode\u003ebytes.Buffer\u003c/code\u003e.\nIf the package had a less descriptive name,\nlike \u003ccode\u003eutil\u003c/code\u003e, the buffer would likely acquire the longer and clumsier name \u003ccode\u003eutil.BytesBuffer\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eDon’t be shy about renaming things as you work.\nAs you spend time with your program you will better understand how its pieces fit together and,\ntherefore, what their names should be.\nThere’s no need to lock yourself into early decisions.\n(The \u003ca href=\"/cmd/gofmt/\"\u003egofmt command\u003c/a\u003e has a \u003ccode\u003e-r\u003c/code\u003e flag that\nprovides a syntax-aware search and replace,\nmaking large-scale refactoring easier.)\u003c/p\u003e\n\u003cp\u003eA good name is the most important part of a software interface:\nthe name is the first thing every client of the code will see.\nA well-chosen name is therefore the starting point for good documentation.\nMany of the following practices result organically from good naming.\u003c/p\u003e\n\u003ch2 id=\"choose-a-good-import-path-make-your-package-go-get-able\"\u003eChoose a good import path (make your package “go get”-able)\u003c/h2\u003e\n\u003cp\u003eAn import path is the string with which users import a package.\nIt specifies the directory (relative to \u003ccode\u003e$GOROOT/src/pkg\u003c/code\u003e or \u003ccode\u003e$GOPATH/src\u003c/code\u003e)\nin which the package’s source code resides.\u003c/p\u003e\n\u003cp\u003eImport paths should be globally unique, so use the path of your source repository as its base.\nFor instance, the \u003ccode\u003ewebsocket\u003c/code\u003e package from the \u003ccode\u003ego.net\u003c/code\u003e sub-repository has\nan import path of \u003ccode\u003e\u0026#34;golang.org/x/net/websocket\u0026#34;\u003c/code\u003e.\nThe Go project owns the path \u003ccode\u003e\u0026#34;github.com/golang\u0026#34;\u003c/code\u003e,\nso that path cannot be used by another author for a different package.\nBecause the repository URL and import path are one and the same,\nthe \u003ccode\u003ego get\u003c/code\u003e command can fetch and install the package automatically.\u003c/p\u003e\n\u003cp\u003eIf you don’t use a hosted source repository,\nchoose some unique prefix such as a domain,\ncompany, or project name.\nAs an example, the import path of all Google’s internal Go code starts with\nthe string \u003ccode\u003e\u0026#34;google\u0026#34;\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe last element of the import path is typically the same as the package name.\nFor instance, the import path \u003ccode\u003e\u0026#34;net/http\u0026#34;\u003c/code\u003e contains package \u003ccode\u003ehttp\u003c/code\u003e.\nThis is not a requirement - you can make them different if you like - but\nyou should follow the convention for predictability’s sake:\na user might be surprised that import \u003ccode\u003e\u0026#34;foo/bar\u0026#34;\u003c/code\u003e introduces the identifier\n\u003ccode\u003equux\u003c/code\u003e into the package name space.\u003c/p\u003e\n\u003cp\u003eSometimes people set \u003ccode\u003eGOPATH\u003c/code\u003e to the root of their source repository and\nput their packages in directories relative to the repository root,\nsuch as \u003ccode\u003e\u0026#34;src/my/package\u0026#34;\u003c/code\u003e.\nOn one hand, this keeps the import paths short (\u003ccode\u003e\u0026#34;my/package\u0026#34;\u003c/code\u003e instead of\n\u003ccode\u003e\u0026#34;github.com/me/project/my/package\u0026#34;\u003c/code\u003e),\nbut on the other it breaks \u003ccode\u003ego get\u003c/code\u003e and forces users to re-set their \u003ccode\u003eGOPATH\u003c/code\u003e\nto use the package. Don’t do this.\u003c/p\u003e\n\u003ch2 id=\"minimize-the-exported-interface\"\u003eMinimize the exported interface\u003c/h2\u003e\n\u003cp\u003eYour code is likely composed of many small pieces of useful code,\nand so it is tempting to expose much of that functionality in your package’s\nexported interface. Resist that urge!\u003c/p\u003e\n\u003cp\u003eThe larger the interface you provide, the more you must support.\nUsers will quickly come to depend on every type,\nfunction, variable, and constant you export,\ncreating an implicit contract that you must honor in perpetuity or risk\nbreaking your users’ programs.\nIn preparing Go 1 we carefully reviewed the standard library’s exported\ninterfaces and removed the parts we weren’t ready to commit to.\nYou should take similar care when distributing your own libraries.\u003c/p\u003e\n\u003cp\u003eIf in doubt, leave it out!\u003c/p\u003e\n\u003ch2 id=\"what-to-put-into-a-package\"\u003eWhat to put into a package\u003c/h2\u003e\n\u003cp\u003eIt is easy to just throw everything into a “grab bag” package,\nbut this dilutes the meaning of the package name (as it must encompass a\nlot of functionality) and forces the users of small parts of the package\nto compile and link a lot of unrelated code.\u003c/p\u003e\n\u003cp\u003eOn the other hand, it is also easy to go overboard in splitting your code\ninto small packages,\nin which case you will likely become bogged down in interface design,\nrather than just getting the job done.\u003c/p\u003e\n\u003cp\u003eLook to the Go standard libraries as a guide.\nSome of its packages are large and some are small.\nFor instance, the \u003ca href=\"/pkg/net/http/\"\u003ehttp package\u003c/a\u003e comprises\n17 go source files (excluding tests) and exports 109 identifiers,\nand the \u003ca href=\"/pkg/hash/\"\u003ehash package\u003c/a\u003e consists of one file\nthat exports just three declarations.\nThere is no hard and fast rule; both approaches are appropriate given their context.\u003c/p\u003e\n\u003cp\u003eWith that said, package main is often larger than other packages.\nComplex commands contain a lot of code that is of little use outside the\ncontext of the executable,\nand often it’s simpler to just keep it all in the one place.\nFor instance, the go tool is more than 12000 lines spread across \u003ca href=\"/src/cmd/go/\"\u003e34 files\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"document-your-code\"\u003eDocument your code\u003c/h2\u003e\n\u003cp\u003eGood documentation is an essential quality of usable and maintainable code.\nRead the \u003ca href=\"/doc/articles/godoc_documenting_go_code.html\"\u003eGodoc: documenting Go code\u003c/a\u003e\narticle to learn how to write good doc comments.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2012-08-16T00:00:00Z",
  "Author": "Andrew Gerrand"
}