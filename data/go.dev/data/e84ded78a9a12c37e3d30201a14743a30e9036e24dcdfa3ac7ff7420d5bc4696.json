{
  "Source": "go.dev",
  "Title": "Toward Go 2",
  "Link": "https://go.dev/blog/toward-go2",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/toward-go2\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eToward Go 2\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Russ Cox\u003cbr/\u003e\n      13 July 2017\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003e[This is the text of\n\u003ca href=\"https://www.youtube.com/watch?v=0Zbh_vmAKvk\" rel=\"noreferrer\" target=\"_blank\"\u003emy talk today\u003c/a\u003e\nat Gophercon 2017, asking for the entire Go community’s\nhelp as we discuss and plan Go 2.]\u003c/p\u003e\n\u003cp\u003eOn September 25, 2007, after Rob Pike, Robert Griesemer, and Ken\nThompson had been discussing a new programming language for a few\ndays, Rob suggested the name “Go.”\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/mail.png\" width=\"446\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eThe next year, Ian Lance Taylor and I joined the team, and together\nthe five of us built two compilers and a standard library, leading up\nto the \u003ca href=\"https://opensource.googleblog.com/2009/11/hey-ho-lets-go.html\" rel=\"noreferrer\" target=\"_blank\"\u003eopen-source release\u003c/a\u003e on November 10, 2009.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/tweet.png\" width=\"467\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eFor the next two years, with the help of the new Go open source\ncommunity, we experimented with changes large and small, refining Go\nand leading to the \u003ca href=\"/blog/preview-of-go-version-1\"\u003eplan for Go 1\u003c/a\u003e, proposed on October 5, 2011.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/go1-preview.png\" width=\"560\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eWith more help from the Go community, we revised and implemented that\nplan, eventually \u003ca href=\"/blog/go1\"\u003ereleasing Go 1\u003c/a\u003e on March 28, 2012.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/go1-release.png\" width=\"556\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eThe release of Go 1 marked the culmination of nearly five years of\ncreative, frenetic effort that took us from a name and a list of ideas\nto a stable, production language. It also marked an explicit shift\nfrom change and churn to stability.\u003c/p\u003e\n\u003cp\u003eIn the years leading to Go 1, we changed Go and broke everyone’s Go\nprograms nearly every week. We understood that this was keeping Go\nfrom use in production settings, where programs could not be rewritten\nweekly to keep up with language changes.\nAs the \u003ca href=\"/blog/go1\"\u003eblog post announcing Go 1\u003c/a\u003e says, the driving motivation was to provide a stable foundation\nfor creating reliable products, projects, and publications (blogs,\ntutorials, conference talks, and books), to make users confident that\ntheir programs would continue to compile and run without change for\nyears to come.\u003c/p\u003e\n\u003cp\u003eAfter Go 1 was released, we knew that we needed to spend time using Go\nin the production environments it was designed for. We shifted\nexplicitly away from making language changes toward using Go in our\nown projects and improving the implementation: we ported Go to many\nnew systems, we rewrote nearly every performance-critical piece to\nmake Go run more efficiently, and we added key tools like the\n\u003ca href=\"/blog/race-detector\"\u003erace detector\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eNow we have five years of experience using Go to build large,\nproduction-quality systems. We have developed a sense of what works\nand what does not. Now it is time to begin the next step in Go’s\nevolution and growth, to plan the future of Go. I’m here today to ask\nall of you in the Go community, whether you’re in the audience at\nGopherCon or watching on video or reading the Go blog later today, to\nwork with us as we plan and implement Go 2.\u003c/p\u003e\n\u003cp\u003eIn the rest of this talk, I’m going to explain our goals for Go 2; our\nconstraints and limitations; the overall process; the importance of\nwriting about our experiences using Go, especially as they relate to\nproblems we might try to solve; the possible kinds of solutions; how\nwe will deliver Go 2; and how all of you can help.\u003c/p\u003e\n\u003ch2 id=\"goals\"\u003eGoals\u003c/h2\u003e\n\u003cp\u003eThe goals we have for Go today are the same as in 2007. We want to\nmake programmers more effective at managing two kinds of scale:\nproduction scale, especially concurrent systems interacting with many\nother servers, exemplified today by cloud software; and development\nscale, especially large codebases worked on by many engineers\ncoordinating only loosely, exemplified today by modern open-source\ndevelopment.\u003c/p\u003e\n\u003cp\u003eThese kinds of scale show up at companies of all sizes. Even a\nfive-person startup may use large cloud-based API services provided by\nother companies and use more open-source software than software they\nwrite themselves. Production scale and development scale are just as\nrelevant at that startup as they are at Google.\u003c/p\u003e\n\u003cp\u003eOur goal for Go 2 is to fix the most significant ways Go fails to\nscale.\u003c/p\u003e\n\u003cp\u003e(For more about these goals, see\nRob Pike’s 2012 article “\u003ca href=\"/talks/2012/splash.article\"\u003eGo at Google: Language Design in the Service of Software Engineering\u003c/a\u003e”\nand my GopherCon 2015 talk “\u003ca href=\"/blog/open-source\"\u003eGo, Open Source, Community\u003c/a\u003e.”)\u003c/p\u003e\n\u003ch2 id=\"constraints\"\u003eConstraints\u003c/h2\u003e\n\u003cp\u003eThe goals for Go have not changed since the beginning, but the\nconstraints on Go certainly have. The most important constraint is\nexisting Go usage. We estimate that there are at least\n\u003ca href=\"https://research.swtch.com/gophercount\" rel=\"noreferrer\" target=\"_blank\"\u003ehalf a million Go developers worldwide\u003c/a\u003e,\nwhich means there are millions of Go source files and at\nleast a billion of lines of Go code. Those programmers and that source\ncode represent Go’s success, but they are also the main constraint on\nGo 2.\u003c/p\u003e\n\u003cp\u003eGo 2 must bring along all those developers. We must ask them to\nunlearn old habits and learn new ones only when the reward is great.\nFor example, before Go 1, the method implemented by error types was\nnamed \u003ccode\u003eString\u003c/code\u003e. In Go 1, we renamed it \u003ccode\u003eError\u003c/code\u003e, to distinguish error types\nfrom other types that can format themselves. The other day I was\nimplementing an error type, and without thinking I named its method\n\u003ccode\u003eString\u003c/code\u003e instead of \u003ccode\u003eError\u003c/code\u003e, which of course did not compile. After five\nyears I still have not completely unlearned the old way. That kind of\nclarifying renaming was an important change to make in Go 1 but would\nbe too disruptive for Go 2 without a very good reason.\u003c/p\u003e\n\u003cp\u003eGo 2 must also bring along all the existing Go 1 source code. We must\nnot split the Go ecosystem. Mixed programs, in which packages written\nin Go 2 import packages written in Go 1 and vice versa, must work\neffortlessly during a transition period of multiple years. We’ll have\nto figure out exactly how to do that; automated tooling like go fix\nwill certainly play a part.\u003c/p\u003e\n\u003cp\u003eTo minimize disruption, each change will require careful thought,\nplanning, and tooling, which in turn limits the number of changes we\ncan make. Maybe we can do two or three, certainly not more than five.\u003c/p\u003e\n\u003cp\u003eI’m not counting minor housekeeping changes like maybe allowing identifiers\nin more spoken languages or adding binary integer literals. Minor\nchanges like these are also important, but they are easier to get\nright. I’m focusing today on possible major changes, such as\nadditional support for error handling, or introducing immutable or\nread-only values, or adding some form of generics, or other important\ntopics not yet suggested. We can do only a few of those major changes.\nWe will have to choose carefully.\u003c/p\u003e\n\u003ch2 id=\"process\"\u003eProcess\u003c/h2\u003e\n\u003cp\u003eThat raises an important question. What is the process for developing\nGo?\u003c/p\u003e\n\u003cp\u003eIn the early days of Go, when there were just five of us, we worked in\na pair of adjacent shared offices separated by a glass wall. It was\neasy to pull everyone into one office to discuss some problem and then\ngo back to our desks to implement a solution. When some wrinkle arose\nduring the implementation, it was easy to gather everyone again. Rob\nand Robert’s office had a small couch and a whiteboard, so typically\none of us went in and started writing an example on the board. Usually\nby the time the example was up, everyone else had reached a good\nstopping point in their own work and was ready to sit down and discuss\nit. That informality obviously doesn’t scale to the global Go\ncommunity of today.\u003c/p\u003e\n\u003cp\u003ePart of the work since the open-source release of Go has been porting\nour informal process into the more formal world of mailing lists and\nissue trackers and half a million users, but I don’t think we’ve ever\nexplicitly described our overall process. It’s possible we never\nconsciously thought about it. Looking back, though, I think this is\nthe basic outline of our work on Go, the process we’ve been following\nsince the first prototype was running.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/process.png\" width=\"410\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eStep 1 is to use Go, to accumulate experience with it.\u003c/p\u003e\n\u003cp\u003eStep 2 is to identify a problem with Go that might need solving and to\narticulate it, to explain it to others, to write it down.\u003c/p\u003e\n\u003cp\u003eStep 3 is to propose a solution to that problem, discuss it with\nothers, and revise the solution based on that discussion.\u003c/p\u003e\n\u003cp\u003eStep 4 is to implement the solution, evaluate it, and refine it based\non that evaluation.\u003c/p\u003e\n\u003cp\u003eFinally, step 5 is to ship the solution, adding it to the language, or\nthe library, or the set of tools that people use from day to day.\u003c/p\u003e\n\u003cp\u003eThe same person does not have to do all these steps for a particular\nchange. In fact, usually many people collaborate on any given step,\nand many solutions may be proposed for a single problem. Also, at any\npoint we may realize we don’t want to go further with a particular\nidea and circle back to an earlier step.\u003c/p\u003e\n\u003cp\u003eAlthough I don’t believe we’ve ever talked about this process as a\nwhole, we have explained parts of it. In 2012, when we released Go 1\nand said that it was time now to use Go and stop changing it, we were\nexplaining step 1. In 2015, when we introduced the Go change proposal\nprocess, we were explaining steps 3, 4, and 5. But we’ve never\nexplained step 2 in detail, so I’d like to do that now.\u003c/p\u003e\n\u003cp\u003e(For more about the development of Go 1 and the shift away from\nlanguage changes, see Rob Pike and Andrew Gerrand’s\nOSCON 2012 talk “\u003ca href=\"/blog/the-path-to-go-1\"\u003eThe Path to Go 1\u003c/a\u003e.”\nFor more about the proposal process, see\nAndrew Gerrand’s GopherCon 2015 talk “\u003ca href=\"https://www.youtube.com/watch?v=0ht89TxZZnk\" rel=\"noreferrer\" target=\"_blank\"\u003eHow Go was Made\u003c/a\u003e” and the\n\u003ca href=\"/s/proposal\"\u003eproposal process documentation\u003c/a\u003e.)\u003c/p\u003e\n\u003ch2 id=\"explaining-problems\"\u003eExplaining Problems\u003c/h2\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/process2.png\" width=\"410\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eThere are two parts to explaining a problem. The first part—the easier\npart—is stating exactly what the problem is. We developers are\ndecently good at this. After all, every test we write is a statement\nof a problem to be solved, in language so precise that even a computer\ncan understand it. The second part—the harder part—is describing the\nsignificance of the problem well enough that everyone can understand\nwhy we should spend time solving it and maintaining a solution. In\ncontrast to stating a problem precisely, we don’t need to describe a\nproblem’s significance very often, and we’re not nearly as good at it.\nComputers never ask us “why is this test case important? Are you sure\nthis is the problem you need to solve? Is solving this problem the\nmost important thing you can be doing?” Maybe they will someday, but\nnot today.\u003c/p\u003e\n\u003cp\u003eLet’s look at an old example from 2011. Here is what I wrote about\nrenaming os.Error to error.Value while we were planning Go 1.\u003c/p\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/error.png\" width=\"495\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eIt begins with a precise, one-line statement of the problem: in very\nlow-level libraries everything imports “os” for os.Error. Then there\nare five lines, which I’ve underlined here, devoted to describing the\nsignificance of the problem: the packages that “os” uses cannot\nthemselves present errors in their APIs, and other packages depend on\n“os” for reasons having nothing to do with operating system services.\u003c/p\u003e\n\u003cp\u003eDo these five lines convince \u003cem\u003eyou\u003c/em\u003e that this problem is significant?\nIt depends on how well you can fill in the context I’ve left out:\nbeing understood requires anticipating what others need to know. For\nmy audience at the time—the ten other people on the Go team at Google\nwho were reading that document—those fifty words were enough. To\npresent the same problem to the audience at GothamGo last fall—an\naudience with much more varied backgrounds and areas of expertise—I\nneeded to provide more context, and I used about two hundred words,\nalong with real code examples and a diagram. It is a fact of today’s\nworldwide Go community that describing the significance of any problem\nrequires adding context, especially illustrated by concrete examples,\nthat you would leave out when talking to coworkers.\u003c/p\u003e\n\u003cp\u003eConvincing others that a problem is significant is an essential step.\nWhen a problem appears insignificant, almost every solution will seem\ntoo expensive. But for a significant problem, there are usually many\nsolutions of reasonable cost. When we disagree about whether to adopt\na particular solution, we’re often actually disagreeing about the\nsignificance of the problem being solved. This is so important that I\nwant to look at two recent examples that show this clearly, at least\nin hindsight.\u003c/p\u003e\n\u003ch3 id=\"example-leap-seconds\"\u003eExample: Leap seconds\u003c/h3\u003e\n\u003cp\u003eMy first example is about time.\u003c/p\u003e\n\u003cp\u003eSuppose you want to time how long an event takes. You write down the\nstart time, run the event, write down the end time, and then subtract\nthe start time from the end time. If the event took ten milliseconds,\nthe subtraction gives a result of ten milliseconds, perhaps plus or\nminus a small measurement error.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estart := time.Now()       // 3:04:05.000\nevent()\nend := time.Now()         // 3:04:05.010\n\nelapsed := end.Sub(start) // 10 ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis obvious procedure can fail during a \u003ca href=\"https://en.wikipedia.org/wiki/Leap_second\" rel=\"noreferrer\" target=\"_blank\"\u003eleap second\u003c/a\u003e. When our clocks\nare not quite in sync with the daily rotation of the Earth, a leap\nsecond—officially 11:59pm and 60 seconds—is inserted just before\nmidnight. Unlike leap years, leap seconds follow no predictable\npattern, which makes them hard to fit into programs and APIs. Instead\nof trying to represent the occasional 61-second minute, operating\nsystems typically implement a leap second by turning the clock back\none second just before what would have been midnight, so that 11:59pm\nand 59 seconds happens twice. This clock reset makes time appear to\nmove backward, so that our ten-millisecond event might be timed as\ntaking negative 990 milliseconds.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003estart := time.Now()       // 11:59:59.995\nevent()\nend := time.Now()         // 11:59:59.005 (really 11:59:60.005)\n\nelapsed := end.Sub(start) // –990 ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBecause the time-of-day clock is inaccurate for timing events across\nclock resets like this, operating systems now provide a second clock,\nthe monotonic clock, which has no absolute meaning but counts seconds\nand is never reset.\u003c/p\u003e\n\u003cp\u003eExcept during the odd clock reset, the monotonic clock is no better\nthan the time-of-day clock, and the time-of-day clock has the added\nbenefit of being useful for telling time, so for simplicity Go 1’s\ntime APIs expose only the time-of-day clock.\u003c/p\u003e\n\u003cp\u003eIn October 2015, a \u003ca href=\"/issue/12914\"\u003ebug report\u003c/a\u003e noted that Go programs could not time\nevents correctly across clock resets, especially a typical leap second.\nThe suggested fix was also the original issue title: “add a new API to access a\nmonotonic clock source.” I argued that this problem was not\nsignificant enough to justify new API. A few months earlier, for the\nmid-2015 leap second, Akamai, Amazon, and Google had slowed their\nclocks a tiny amount for the entire day, absorbing the extra second\nwithout turning their clocks backward. It seemed like eventual\nwidespread adoption of this “\u003ca href=\"https://developers.google.com/time/smear\" rel=\"noreferrer\" target=\"_blank\"\u003eleap smear\u003c/a\u003e” approach would eliminate\nleap-second clock resets as a problem on production systems. In\ncontrast, adding new API to Go would add new problems: we would have\nto explain the two kinds of clocks, educate users about when to use\neach, and convert many lines of existing code, all for an issue that\nrarely occurred and might plausibly go away on its own.\u003c/p\u003e\n\u003cp\u003eWe did what we always do when there’s a problem without a clear\nsolution: we waited. Waiting gives us more time to add experience and\nunderstanding of the problem and also more time to find a good\nsolution. In this case, waiting added to our understanding of the\nsignificance of the problem, in the form of a thankfully\n\u003ca href=\"https://www.theregister.co.uk/2017/01/04/cloudflare_trips_over_leap_second/\" rel=\"noreferrer\" target=\"_blank\"\u003eminor outage at Cloudflare\u003c/a\u003e.\nTheir Go code timed DNS requests during the end-of-2016\nleap second as taking around negative 990 milliseconds, which caused\nsimultaneous panics across their servers, breaking 0.2% of DNS queries\nat peak.\u003c/p\u003e\n\u003cp\u003eCloudflare is exactly the kind of cloud system Go was intended for,\nand they had a production outage based on Go not being able to time\nevents correctly. Then, and this is the key point, Cloudflare reported\ntheir experience in a blog post by John Graham-Cumming titled\n“\u003ca href=\"https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/\" rel=\"noreferrer\" target=\"_blank\"\u003eHow and why the leap second affected Cloudflare DNS\u003c/a\u003e.” By sharing concrete\ndetails of their experience with Go in production, John and Cloudflare helped us\nunderstand that the problem of accurate timing across leap second\nclock resets was too significant to leave unfixed. Two months after\nthat article was published, we had designed and implemented a solution\nthat will \u003ca href=\"https://beta.golang.org/doc/go1.9#monotonic-time\" rel=\"noreferrer\" target=\"_blank\"\u003eship in Go 1.9\u003c/a\u003e\n(and in fact we did it with \u003ca href=\"/design/12914-monotonic\"\u003eno new API\u003c/a\u003e).\u003c/p\u003e\n\u003ch3 id=\"example-alias-declarations\"\u003eExample: Alias declarations\u003c/h3\u003e\n\u003cp\u003eMy second example is support for alias declarations in Go.\u003c/p\u003e\n\u003cp\u003eOver the past few years, Google has established a team focused on\nlarge-scale code changes, meaning API migration and bug fixes applied\nacross our\n\u003ca href=\"http://cacm.acm.org/magazines/2016/7/204032-why-google-stores-billions-of-lines-of-code-in-a-single-repository/pdf\" rel=\"noreferrer\" target=\"_blank\"\u003ecodebase of millions of source files and billions of lines of code\u003c/a\u003e\nwritten in C++, Go, Java, Python, and other languages. One\nthing I’ve learned from that team’s work is the importance, when\nchanging an API from using one name to another, of being able to\nupdate client code in multiple steps, not all at once. To do this, it\nmust be possible to write a declaration forwarding uses of the old\nname to the new name. C++ has #define, typedef, and using declarations\nto enable this forwarding, but Go has nothing. Of course, one of Go’s\ngoals is to scale well to large codebases, and as the amount of Go\ncode at Google grew, it became clear both that we needed some kind of\nforwarding mechanism and also that other projects and companies would\nrun into this problem as their Go codebases grew.\u003c/p\u003e\n\u003cp\u003eIn March 2016, I started talking with Robert Griesemer and Rob Pike\nabout how Go might handle gradual codebase updates, and we arrived at\nalias declarations, which are exactly the needed forwarding mechanism.\nAt this point, I felt very good about the way Go was evolving. We’d\ntalked about aliases since the early days of Go—in fact, the first\nspec draft has \u003ca href=\"https://go.googlesource.com/go/+/18c5b488a3b2e218c0e0cf2a7d4820d9da93a554/doc/go_spec#1182\" rel=\"noreferrer\" target=\"_blank\"\u003ean example using alias declarations\u003c/a\u003e—but each time we’d\ndiscussed aliases, and later type aliases, we had no clear use case\nfor them, so we left them out. Now we were proposing to add aliases\nnot because they were an elegant concept but because they solved a\nsignificant practical problem with Go meeting its goal of scalable\nsoftware development. I hoped this would serve as a model for future\nchanges to Go.\u003c/p\u003e\n\u003cp\u003eLater in the spring, Robert and Rob wrote \u003ca href=\"/design/16339-alias-decls\"\u003ea proposal\u003c/a\u003e,\nand Robert presented it in a \u003ca href=\"https://www.youtube.com/watch?v=t-w6MyI2qlU\" rel=\"noreferrer\" target=\"_blank\"\u003eGophercon 2016 lightning talk\u003c/a\u003e. The next few months\ndid not go smoothly, and they were definitely not a model for future\nchanges to Go. One of the many lessons we learned was the importance\nof describing the significance of a problem.\u003c/p\u003e\n\u003cp\u003eA minute ago, I explained the problem to you, giving some background\nabout how it can arise and why, but with no concrete examples that\nmight help you evaluate whether the problem might affect you at some\npoint. Last summer’s proposal and the lightning talk gave an abstract\nexample, involving packages C, L, L1, and C1 through Cn, but no\nconcrete examples that developers could relate to. As a result, most\nof the feedback from the community was based on the idea that aliases\nonly solved a problem for Google, not for everyone else.\u003c/p\u003e\n\u003cp\u003eJust as we at Google did not at first understand the significance of\nhandling leap second time resets correctly, we did not effectively\nconvey to the broader Go community the significance of handling\ngradual code migration and repair during large-scale changes.\u003c/p\u003e\n\u003cp\u003eIn the fall we started over. I gave a \u003ca href=\"https://www.youtube.com/watch?v=h6Cw9iCDVcU\" rel=\"noreferrer\" target=\"_blank\"\u003etalk\u003c/a\u003e and wrote\n\u003ca href=\"/talks/2016/refactor.article\"\u003ean article presenting the problem\u003c/a\u003e\nusing multiple concrete examples drawn from\nopen source codebases, showing how this problem arises everywhere, not\njust inside Google. Now that more people understood the problem and\ncould see its significance, we had a \u003ca href=\"/issue/18130\"\u003eproductive discussion\u003c/a\u003e about what\nkind of solution would be best. The outcome is that \u003ca href=\"/design/18130-type-alias\"\u003etype aliases\u003c/a\u003e will\nbe \u003ca href=\"https://beta.golang.org/doc/go1.9#language\" rel=\"noreferrer\" target=\"_blank\"\u003eincluded in Go 1.9\u003c/a\u003e and will help Go scale to ever-larger codebases.\u003c/p\u003e\n\u003ch3 id=\"experience-reports\"\u003eExperience reports\u003c/h3\u003e\n\u003cp\u003eThe lesson here is that it is difficult but essential to describe the\nsignificance of a problem in a way that someone working in a different\nenvironment can understand. To discuss major changes to Go as a\ncommunity, we will need to pay particular attention to describing the\nsignificance of any problem we want to solve. The clearest way to do\nthat is by showing how the problem affects real programs and real\nproduction systems, like in\n\u003ca href=\"https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/\" rel=\"noreferrer\" target=\"_blank\"\u003eCloudflare’s blog post\u003c/a\u003e and in\n\u003ca href=\"/talks/2016/refactor.article\"\u003emy refactoring article\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eExperience reports like these turn an abstract problem into a concrete\none and help us understand its significance. They also serve as test\ncases: any proposed solution can be evaluated by examining its effect\non the actual, real-world problems the reports describe.\u003c/p\u003e\n\u003cp\u003eFor example, I’ve been examining generics recently, but I don’t have\nin my mind a clear picture of the detailed, concrete problems that Go\nusers need generics to solve. As a result, I can’t answer a design\nquestion like whether to support generic methods, which is to say\nmethods that are parameterized separately from the receiver. If we had\na large set of real-world use cases, we could begin to answer a\nquestion like this by examining the significant ones.\u003c/p\u003e\n\u003cp\u003eAs another example, I’ve seen proposals to extend the error interface\nin various ways, but I haven’t seen any experience reports showing how\nlarge Go programs attempt to understand and handle errors at all, much\nless showing how the current error interface hinders those attempts.\nThese reports would help us all better understand the details and\nsignificance of the problem, which we must do before solving it.\u003c/p\u003e\n\u003cp\u003eI could go on. Every major potential change to Go should be motivated\nby one or more experience reports documenting how people use Go today\nand why that’s not working well enough. For the obvious major changes\nwe might consider for Go, I’m not aware of many such reports,\nespecially not reports illustrated with real-world examples.\u003c/p\u003e\n\u003cp\u003eThese reports are the raw material for the Go 2 proposal process, and\nwe need all of you to write them, to help us understand your\nexperiences with Go. There are half a million of you, working in a\nbroad range of environments, and not that many of us.\nWrite a post on your own blog,\nor write a \u003ca href=\"https://www.medium.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eMedium\u003c/a\u003e post,\nor write a \u003ca href=\"https://gist.github.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eGitHub Gist\u003c/a\u003e (add a \u003ccode\u003e.md\u003c/code\u003e file extension for Markdown),\nor write a \u003ca href=\"https://docs.google.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eGoogle doc\u003c/a\u003e,\nor use any other publishing mechanism you like.\nAfter you’ve posted, please add the post to our new wiki page,\n\u003ca href=\"/wiki/ExperienceReports\"\u003egolang.org/wiki/ExperienceReports\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"solutions\"\u003eSolutions\u003c/h2\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/process34.png\" width=\"410\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eNow that we know how we’re going to identify and explain problems that\nneed to be solved, I want to note briefly that not all problems are\nbest solved by language changes, and that’s fine.\u003c/p\u003e\n\u003cp\u003eOne problem we might want to solve is that computers can often compute\nadditional results during basic arithmetic operations, but Go does not\nprovide direct access to those results. In 2013, Robert proposed that\nwe might extend the idea of two-result (“comma-ok”) expressions to\nbasic arithmetic. For example, if x and y are, say, uint32 values,\n\u003ccode\u003elo, hi = x * y\u003c/code\u003e\nwould return not only the usual low 32 bits but also the high 32 bits\nof the product. This problem didn’t seem particularly significant, so\nwe \u003ca href=\"/issue/6815\"\u003erecorded the potential solution\u003c/a\u003e but didn’t implement it. We waited.\u003c/p\u003e\n\u003cp\u003eMore recently, we designed for Go 1.9 a \u003ca href=\"https://beta.golang.org/doc/go1.9#math-bits\" rel=\"noreferrer\" target=\"_blank\"\u003emath/bits package\u003c/a\u003e that\ncontains various bit manipulation functions:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage bits // import \u0026#34;math/bits\u0026#34;\n\nfunc LeadingZeros32(x uint32) int\nfunc Len32(x uint32) int\nfunc OnesCount32(x uint32) int\nfunc Reverse32(x uint32) uint32\nfunc ReverseBytes32(x uint32) uint32\nfunc RotateLeft32(x uint32, k int) uint32\nfunc TrailingZeros32(x uint32) int\n...\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe package has good Go\nimplementations of each function, but the compilers also substitute\nspecial hardware instructions when available. Based on this experience\nwith math/bits, both Robert and I now believe that making the\nadditional arithmetic results available by changing the language is\nunwise, and that instead we should define appropriate functions in a\npackage like math/bits. Here the best solution is a library change,\nnot a language change.\u003c/p\u003e\n\u003cp\u003eA different problem we might have wanted to solve, after Go 1.0, was\nthe fact that goroutines and shared memory make it too easy to\nintroduce races into Go programs, causing crashes and other\nmisbehavior in production. The language-based solution would have been\nto find some way to disallow data races, to make it impossible to\nwrite or at least to compile a program with a data race. How to fit\nthat into a language like Go is still an open question in the\nprogramming language world. Instead we added a tool to the main\ndistribution and made it trivial to use: that tool, the \u003ca href=\"/blog/race-detector\"\u003erace detector\u003c/a\u003e, has become\nan indispensable part of the Go experience. Here the best solution was\na runtime and tooling change, not a language change.\u003c/p\u003e\n\u003cp\u003eThere will be language changes as well, of course, but not all\nproblems are best solved in the language.\u003c/p\u003e\n\u003ch2 id=\"shipping-go-2\"\u003eShipping Go 2\u003c/h2\u003e\n\u003cdiv style=\"margin-left: 2em;\"\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"toward-go2/process5.png\" width=\"410\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003eFinally, how will we ship and deliver Go 2?\u003c/p\u003e\n\u003cp\u003eI think the best plan would be to ship the \u003ca href=\"/doc/go1compat\"\u003ebackwards-compatible parts\u003c/a\u003e\nof Go 2 incrementally, feature by feature, as part of the Go 1 release\nsequence. This has a few important properties. First, it keeps the Go\n1 releases on the \u003ca href=\"/wiki/Go-Release-Cycle\"\u003eusual schedule\u003c/a\u003e, to continue the timely bug fixes and\nimprovements that users now depend on. Second, it avoids splitting\ndevelopment effort between Go 1 and Go 2. Third, it avoids divergence\nbetween Go 1 and Go 2, to ease everyone’s eventual migration. Fourth,\nit allows us to focus on and deliver one change at a time, which\nshould help maintain quality. Fifth, it will encourage us to design\nfeatures to be backwards-compatible.\u003c/p\u003e\n\u003cp\u003eWe will need time to discuss and plan before any changes start landing in\nGo 1 releases, but it seems plausible to me that we might start seeing\nminor changes about a year from now, for Go 1.12 or so. That also\ngives us time to land package management support first.\u003c/p\u003e\n\u003cp\u003eOnce all the backwards-compatible work is done, say in Go 1.20, then\nwe can make the backwards-incompatible changes in Go 2.0. If there\nturn out to be no backwards-incompatible changes, maybe we just\ndeclare that Go 1.20 \u003cem\u003eis\u003c/em\u003e Go 2.0. Either way, at that point we will\ntransition from working on the Go 1.X release sequence to working on\nthe Go 2.X sequence, perhaps with an extended support window for the\nfinal Go 1.X release.\u003c/p\u003e\n\u003cp\u003eThis is all a bit speculative, and the specific release numbers\nI just mentioned are placeholders for ballpark estimates,\nbut I want to make clear that we’re not\nabandoning Go 1, and that in fact we will bring Go 1 along to the\ngreatest extent possible.\u003c/p\u003e\n\u003ch2 id=\"help-wanted\"\u003eHelp Wanted\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eWe need your help.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eThe conversation for Go 2 starts today, and it’s one that will happen\nin the open, in public forums like the mailing list and the issue\ntracker. Please help us at every step along the way.\u003c/p\u003e\n\u003cp\u003eToday, what we need most is experience reports. Please tell us how Go\nis working for you, and more importantly not working for you. Write a\nblog post, include real examples, concrete detail, and real\nexperience. And link it on our \u003ca href=\"/wiki/ExperienceReports\"\u003ewiki page\u003c/a\u003e.\nThat’s how we’ll start talking about what we, the Go community,\nmight want to change about Go.\u003c/p\u003e\n\u003cp\u003eThank you.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-07-13T00:00:00Z",
  "Author": "Russ Cox"
}