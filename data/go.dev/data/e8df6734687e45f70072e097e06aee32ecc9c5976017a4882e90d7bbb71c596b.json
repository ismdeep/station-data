{
  "Source": "go.dev",
  "Title": "How Go Mitigates Supply Chain Attacks",
  "Link": "https://go.dev/blog/supply-chain",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/supply-chain\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eHow Go Mitigates Supply Chain Attacks\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Filippo Valsorda\u003cbr/\u003e\n      31 March 2022\n      \u003c/p\u003e\n      \n      \u003cp\u003eModern software engineering is collaborative, and based on reusing Open Source\nsoftware.\nThat exposes targets to supply chain attacks, where software projects are\nattacked by compromising their dependencies.\u003c/p\u003e\n\u003cp\u003eDespite any process or technical measure, every dependency is unavoidably a\ntrust relationship.\nHowever, the Go tooling and design help mitigate risk at various stages.\u003c/p\u003e\n\u003ch2 id=\"all-builds-are-locked\"\u003eAll builds are “locked”\u003c/h2\u003e\n\u003cp\u003eThere is no way for changes in the outside world—such as a new version of a\ndependency being published—to automatically affect a Go build.\u003c/p\u003e\n\u003cp\u003eUnlike most other package managers files, Go modules don’t have a separate list\nof constraints and a lock file pinning specific versions.\nThe version of every dependency contributing to any Go build is fully determined\nby the \u003ca href=\"/ref/mod#go-mod-file\"\u003e\u003ccode\u003ego.mod\u003c/code\u003e file\u003c/a\u003e of the main module.\u003c/p\u003e\n\u003cp\u003eSince Go 1.16, this determinism is enforced by default, and build commands (\u003ccode\u003ego build\u003c/code\u003e, \u003ccode\u003ego test\u003c/code\u003e, \u003ccode\u003ego install\u003c/code\u003e, \u003ccode\u003ego run\u003c/code\u003e, …) \u003ca href=\"/ref/mod#go-mod-file-updates\"\u003ewill fail if the go.mod is\nincomplete\u003c/a\u003e.\nThe only commands that will change the \u003ccode\u003ego.mod\u003c/code\u003e (and therefore the build) are\n\u003ccode\u003ego get\u003c/code\u003e and \u003ccode\u003ego mod tidy\u003c/code\u003e.\nThese commands are not expected to be run automatically or in CI, so changes to\ndependency trees must be made deliberately and have the opportunity to go\nthrough code review.\u003c/p\u003e\n\u003cp\u003eThis is very important for security, because when a CI system or new machine\nruns \u003ccode\u003ego build\u003c/code\u003e, the checked-in source is the ultimate and complete source of\ntruth for what will get built.\nThere is no way for third parties to affect that.\u003c/p\u003e\n\u003cp\u003eMoreover, when a dependency is added with \u003ccode\u003ego get\u003c/code\u003e, its transitive dependencies\nare added at the version specified in the dependency’s \u003ccode\u003ego.mod\u003c/code\u003e file, not at\ntheir latest versions, thanks to\n\u003ca href=\"/ref/mod#minimal-version-selection\"\u003eMinimal version selection\u003c/a\u003e.\nThe same happens for invocations of\n\u003ccode\u003ego install example.com/cmd/devtoolx@latest\u003c/code\u003e, \u003ca href=\"https://research.swtch.com/npm-colors\" rel=\"noreferrer\" target=\"_blank\"\u003ethe equivalents of which in some\necosystems bypass pinning\u003c/a\u003e.\nIn Go, the latest version of \u003ccode\u003eexample.com/cmd/devtoolx\u003c/code\u003e will be fetched, but\nthen all the dependencies will be set by its \u003ccode\u003ego.mod\u003c/code\u003e file.\u003c/p\u003e\n\u003cp\u003eIf a module gets compromised and a new malicious version is published, no one\nwill be affected until they explicitly update that dependency, providing the\nopportunity to review the changes and time for the ecosystem to detect the\nevent.\u003c/p\u003e\n\u003ch2 id=\"version-contents-never-change\"\u003eVersion contents never change\u003c/h2\u003e\n\u003cp\u003eAnother key property necessary to ensure third parties can’t affect builds is\nthat the contents of a module version are immutable.\nIf an attacker that compromises a dependency could re-upload an existing\nversion, they could automatically compromise all projects that depend on it.\u003c/p\u003e\n\u003cp\u003eThat’s what the \u003ca href=\"/ref/mod#go-sum-files\"\u003e\u003ccode\u003ego.sum\u003c/code\u003e file\u003c/a\u003e is for.\nIt contains a list of cryptographic hashes of each dependency that contributes\nto the build.\nAgain, an incomplete \u003ccode\u003ego.sum\u003c/code\u003e causes an error, and only \u003ccode\u003ego\nget\u003c/code\u003e and \u003ccode\u003ego mod tidy\u003c/code\u003e will modify it, so any changes to it\nwill accompany a deliberate dependency change.\nOther builds are guaranteed to have a full set of checksums.\u003c/p\u003e\n\u003cp\u003eThis is a common feature of most lock files.\nGo goes beyond it with the\n\u003ca href=\"/ref/mod#checksum-database\"\u003eChecksum Database\u003c/a\u003e (sumdb for short),\na global append-only cryptographically-verifiable list of go.sum entries.\nWhen \u003ccode\u003ego get\u003c/code\u003e needs to add an entry to the \u003ccode\u003ego.sum\u003c/code\u003e file, it fetches it from the\nsumdb along with cryptographic proof of the sumdb integrity.\nThis ensures that not only every build of a certain module uses the same\ndependency contents, but that every module out there uses the same dependency\ncontents!\u003c/p\u003e\n\u003cp\u003eThe sumdb makes it impossible for compromised dependencies or even\nGoogle-operated Go infrastructure to target specific dependents with modified\n(e.g. backdoored) source.\nYou’re guaranteed to be using the exact same code that everyone else who’s using\ne.g. v1.9.2 of \u003ccode\u003eexample.com/modulex\u003c/code\u003e is using and has reviewed.\u003c/p\u003e\n\u003cp\u003eFinally, my favorite features of the sumdb: it doesn’t require any key\nmanagement on the part of module authors, and it works seamlessly with the\ndecentralized nature of Go modules.\u003c/p\u003e\n\u003ch2 id=\"the-vcs-is-the-source-of-truth\"\u003eThe VCS is the source of truth\u003c/h2\u003e\n\u003cp\u003eMost projects are developed through some version control system (VCS) and then,\nin other ecosystems, uploaded to the package repository.\nThis means there are two accounts that could be compromised, the VCS host and\nthe package repository, the latter of which is used more rarely and more likely\nto be overlooked.\nIt also means it’s easier to hide malicious code in the version uploaded to the\nrepository, especially if the source is routinely modified as part of the\nupload, for example to minimize it.\u003c/p\u003e\n\u003cp\u003eIn Go, there is no such thing as a package repository account.\nThe import path of a package embeds the information that \u003ccode\u003ego mod download\u003c/code\u003e\n\u003ca href=\"https://pkg.go.dev/cmd/go#hdr-Remote_import_paths\" rel=\"noreferrer\" target=\"_blank\"\u003eneeds in order to fetch its\nmodule\u003c/a\u003e directly from the\nVCS, where tags define versions.\u003c/p\u003e\n\u003cp\u003eWe do have the \u003ca href=\"/blog/module-mirror-launch\"\u003eGo Module Mirror\u003c/a\u003e, but\nthat’s only a proxy.\nModule authors don’t register an account and don’t upload versions to the proxy.\nThe proxy uses the same logic that the \u003ccode\u003ego\u003c/code\u003e tool uses (in fact, the proxy runs\n\u003ccode\u003ego mod download\u003c/code\u003e) to fetch and cache a version.\nSince the Checksum Database guarantees that there can be only one source tree\nfor a given module version, everyone using the proxy will see the same result as\neveryone bypassing it and fetching directly from the VCS.\n(If the version is not available anymore in the VCS or if its contents changed,\nfetching directly will lead to an error, while fetching from the proxy might\nstill work, improving availability and protecting the ecosystem from \u003ca href=\"https://blog.npmjs.org/post/141577284765/kik-left-pad-and-npm\" rel=\"noreferrer\" target=\"_blank\"\u003e“left-pad”\nissues\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003eRunning VCS tools on the client exposes a pretty large attack surface.\nThat’s another place the Go Module Mirror helps: the \u003ccode\u003ego\u003c/code\u003e tool on the proxy runs\ninside a robust sandbox and is configured to support every VCS tool, while\n\u003ca href=\"/ref/mod#vcs-govcs\"\u003ethe default is to only support the two major VCS\nsystems\u003c/a\u003e (git and Mercurial).\nAnyone using the proxy can still fetch code published using off-by-default VCS\nsystems, but attackers can’t reach that code in most installations.\u003c/p\u003e\n\u003ch2 id=\"building-code-doesnt-execute-it\"\u003eBuilding code doesn’t execute it\u003c/h2\u003e\n\u003cp\u003eIt is an explicit security design goal of the Go toolchain that neither fetching\nnor building code will let that code execute, even if it is untrusted and\nmalicious.\nThis is different from most other ecosystems, many of which have first-class\nsupport for running code at package fetch time.\nThese “post-install” hooks have been used in the past as the most convenient way\nto turn a compromised dependency into compromised developer machines, and to\n\u003ca href=\"https://en.wikipedia.org/wiki/Computer_worm\" rel=\"noreferrer\" target=\"_blank\"\u003eworm\u003c/a\u003e through module authors.\u003c/p\u003e\n\u003cp\u003eTo be fair, if you’re fetching some code it’s often to execute it shortly\nafterwards, either as part of tests on a developer machine or as part of a\nbinary in production, so lacking post-install hooks is only going to slow down\nattackers.\n(There is no security boundary within a build: any package that contributes to a\nbuild can define an \u003ccode\u003einit\u003c/code\u003e function.)\nHowever, it can be a meaningful risk mitigation, since you might be executing a\nbinary or testing a package that only uses a subset of the module’s\ndependencies.\nFor example, if you build and execute \u003ccode\u003eexample.com/cmd/devtoolx\u003c/code\u003e on macOS there\nis no way for a Windows-only dependency or a dependency of\n\u003ccode\u003eexample.com/cmd/othertool\u003c/code\u003e to compromise your machine.\u003c/p\u003e\n\u003cp\u003eIn Go, modules that don’t contribute code to a specific build have no security\nimpact on it.\u003c/p\u003e\n\u003ch2 id=\"a-little-copying-is-better-than-a-little-dependency\"\u003e“A little copying is better than a little dependency”\u003c/h2\u003e\n\u003cp\u003eThe final and maybe most important software supply chain risk mitigation in the\nGo ecosystem is the least technical one: Go has a culture of rejecting large\ndependency trees, and of preferring a bit of copying to adding a new dependency.\nIt goes all the way back to one of the Go proverbs: \u003ca href=\"https://youtube.com/clip/UgkxWCEmMJFW0-TvSMzcMEAHZcpt2FsVXP65\" rel=\"noreferrer\" target=\"_blank\"\u003e“a little copying is better\nthan a little dependency”\u003c/a\u003e.\nThe label “zero dependencies” is proudly worn by high-quality reusable Go\nmodules.\nIf you find yourself in need of a library, you’re likely to find it will not\ncause you to take on a dependency on dozens of other modules by other authors\nand owners.\u003c/p\u003e\n\u003cp\u003eThat’s enabled also by the rich standard library and additional modules (the\n\u003ccode\u003egolang.org/x/...\u003c/code\u003e ones), which provide commonly used high-level building blocks\nsuch as an HTTP stack, a TLS library, JSON encoding, etc.\u003c/p\u003e\n\u003cp\u003eAll together this means it’s possible to build rich, complex applications with\njust a handful of dependencies.\nNo matter how good the tooling is, it can’t eliminate the risk involved in\nreusing code, so the strongest mitigation will always be a small dependency\ntree.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2022-03-31T00:00:00Z",
  "Author": "Filippo Valsorda"
}