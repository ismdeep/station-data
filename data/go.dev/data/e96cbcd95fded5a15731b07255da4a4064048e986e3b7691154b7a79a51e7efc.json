{
  "Source": "go.dev",
  "Title": "Defer, Panic, and Recover",
  "Link": "https://go.dev/blog/defer-panic-and-recover",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/defer-panic-and-recover\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eDefer, Panic, and Recover\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      4 August 2010\n      \u003c/p\u003e\n      \n      \u003cp\u003eGo has the usual mechanisms for control flow:\nif, for, switch, goto.\nIt also has the go statement to run code in a separate goroutine.\nHere I’d like to discuss some of the less common ones:\ndefer, panic, and recover.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003edefer statement\u003c/strong\u003e pushes a function call onto a list.\nThe list of saved calls is executed after the surrounding function returns.\nDefer is commonly used to simplify functions that perform various clean-up actions.\u003c/p\u003e\n\u003cp\u003eFor example, let’s look at a function that opens two files and copies the contents of one file to the other:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc CopyFile(dstName, srcName string) (written int64, err error) {\n    src, err := os.Open(srcName)\n    if err != nil {\n        return\n    }\n\n    dst, err := os.Create(dstName)\n    if err != nil {\n        return\n    }\n\n    written, err = io.Copy(dst, src)\n    dst.Close()\n    src.Close()\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis works, but there is a bug. If the call to os.Create fails,\nthe function will return without closing the source file.\nThis can be easily remedied by putting a call to src.Close before the second return statement,\nbut if the function were more complex the problem might not be so easily\nnoticed and resolved.\nBy introducing defer statements we can ensure that the files are always closed:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc CopyFile(dstName, srcName string) (written int64, err error) {\n    src, err := os.Open(srcName)\n    if err != nil {\n        return\n    }\n    defer src.Close()\n\n    dst, err := os.Create(dstName)\n    if err != nil {\n        return\n    }\n    defer dst.Close()\n\n    return io.Copy(dst, src)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eDefer statements allow us to think about closing each file right after opening it,\nguaranteeing that, regardless of the number of return statements in the function,\nthe files \u003cem\u003ewill\u003c/em\u003e be closed.\u003c/p\u003e\n\u003cp\u003eThe behavior of defer statements is straightforward and predictable. There are three simple rules:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cem\u003eA deferred function’s arguments are evaluated when the defer statement is evaluated.\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn this example, the expression “i” is evaluated when the Println call is deferred.\nThe deferred call will print “0” after the function returns.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc a() {\n    i := 0\n    defer fmt.Println(i)\n    i++\n    return\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e\u003cem\u003eDeferred function calls are executed in Last In First Out order after the surrounding function returns.\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis function prints “3210”:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc b() {\n    for i := 0; i \u0026lt; 4; i++ {\n        defer fmt.Print(i)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e\u003cem\u003eDeferred functions may read and assign to the returning function’s named return values.\u003c/em\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eIn this example, a deferred function increments the return value i \u003cem\u003eafter\u003c/em\u003e\nthe surrounding function returns.\nThus, this function returns 2:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc c() (i int) {\n    defer func() { i++ }()\n    return 1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is convenient for modifying the error return value of a function; we will see an example of this shortly.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003ePanic\u003c/strong\u003e is a built-in function that stops the ordinary flow of control and begins \u003cem\u003epanicking\u003c/em\u003e.\nWhen the function F calls panic, execution of F stops,\nany deferred functions in F are executed normally,\nand then F returns to its caller.\nTo the caller, F then behaves like a call to panic.\nThe process continues up the stack until all functions in the current goroutine have returned,\nat which point the program crashes.\nPanics can be initiated by invoking panic directly.\nThey can also be caused by runtime errors,\nsuch as out-of-bounds array accesses.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eRecover\u003c/strong\u003e is a built-in function that regains control of a panicking goroutine.\nRecover is only useful inside deferred functions.\nDuring normal execution, a call to recover will return nil and have no other effect.\nIf the current goroutine is panicking, a call to recover will capture the\nvalue given to panic and resume normal execution.\u003c/p\u003e\n\u003cp\u003eHere’s an example program that demonstrates the mechanics of panic and defer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage main\n\nimport \u0026#34;fmt\u0026#34;\n\nfunc main() {\n    f()\n    fmt.Println(\u0026#34;Returned normally from f.\u0026#34;)\n}\n\nfunc f() {\n    defer func() {\n        if r := recover(); r != nil {\n            fmt.Println(\u0026#34;Recovered in f\u0026#34;, r)\n        }\n    }()\n    fmt.Println(\u0026#34;Calling g.\u0026#34;)\n    g(0)\n    fmt.Println(\u0026#34;Returned normally from g.\u0026#34;)\n}\n\nfunc g(i int) {\n    if i \u0026gt; 3 {\n        fmt.Println(\u0026#34;Panicking!\u0026#34;)\n        panic(fmt.Sprintf(\u0026#34;%v\u0026#34;, i))\n    }\n    defer fmt.Println(\u0026#34;Defer in g\u0026#34;, i)\n    fmt.Println(\u0026#34;Printing in g\u0026#34;, i)\n    g(i + 1)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe function g takes the int i, and panics if i is greater than 3,\nor else it calls itself with the argument i+1.\nThe function f defers a function that calls recover and prints the recovered\nvalue (if it is non-nil).\nTry to picture what the output of this program might be before reading on.\u003c/p\u003e\n\u003cp\u003eThe program will output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCalling g.\nPrinting in g 0\nPrinting in g 1\nPrinting in g 2\nPrinting in g 3\nPanicking!\nDefer in g 3\nDefer in g 2\nDefer in g 1\nDefer in g 0\nRecovered in f 4\nReturned normally from f.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIf we remove the deferred function from f the panic is not recovered and\nreaches the top of the goroutine’s call stack,\nterminating the program.\nThis modified program will output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCalling g.\nPrinting in g 0\nPrinting in g 1\nPrinting in g 2\nPrinting in g 3\nPanicking!\nDefer in g 3\nDefer in g 2\nDefer in g 1\nDefer in g 0\npanic: 4\n\npanic PC=0x2a9cd8\n[stack trace omitted]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFor a real-world example of \u003cstrong\u003epanic\u003c/strong\u003e and \u003cstrong\u003erecover\u003c/strong\u003e,\nsee the \u003ca href=\"/pkg/encoding/json/\"\u003ejson package\u003c/a\u003e from the\nGo standard library.\nIt encodes an interface with a set of recursive functions.\nIf an error occurs when traversing the value,\npanic is called to unwind the stack to the top-level function call,\nwhich recovers from the panic and returns an appropriate error value (see\nthe ’error’ and ‘marshal’ methods of the encodeState type in \u003ca href=\"/src/pkg/encoding/json/encode.go\"\u003eencode.go\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eThe convention in the Go libraries is that even when a package uses panic internally,\nits external API still presents explicit error return values.\u003c/p\u003e\n\u003cp\u003eOther uses of \u003cstrong\u003edefer\u003c/strong\u003e (beyond the file.Close example given earlier) include releasing a mutex:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emu.Lock()\ndefer mu.Unlock()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eprinting a footer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eprintHeader()\ndefer printFooter()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand more.\u003c/p\u003e\n\u003cp\u003eIn summary, the defer statement (with or without panic and recover) provides\nan unusual and powerful mechanism for control flow.\nIt can be used to model a number of features implemented by special-purpose\nstructures in other programming languages. Try it out.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2010-08-04T00:00:00Z",
  "Author": "Andrew Gerrand"
}