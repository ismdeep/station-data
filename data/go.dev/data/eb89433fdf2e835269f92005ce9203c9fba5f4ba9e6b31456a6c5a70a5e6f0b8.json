{
  "Source": "go.dev",
  "Title": "Go Modules: v2 and Beyond",
  "Link": "https://go.dev/blog/v2-go-modules",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/v2-go-modules\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eGo Modules: v2 and Beyond\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jean de Klerk and Tyler Bui-Palsulich\u003cbr/\u003e\n      7 November 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis post is part 4 in a series.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePart 1 — \u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 2 — \u003ca href=\"/blog/migrating-to-go-modules\"\u003eMigrating To Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 3 — \u003ca href=\"/blog/publishing-go-modules\"\u003ePublishing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePart 4 — Go Modules: v2 and Beyond\u003c/strong\u003e (this post)\u003c/li\u003e\n\u003cli\u003ePart 5 — \u003ca href=\"/blog/module-compatibility\"\u003eKeeping Your Modules Compatible\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For documentation on developing modules, see\n\u003ca href=\"/doc/modules/developing\"\u003eDeveloping and publishing modules\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAs a successful project matures and new requirements are added, past features\nand design decisions might stop making sense. Developers may want to integrate\nlessons they’ve learned by removing deprecated functions, renaming types, or\nsplitting complicated packages into manageable pieces. These kinds of changes\nrequire effort by downstream users to migrate their code to the new API, so they\nshould not be made without careful consideration that the benefits outweigh the\ncosts.\u003c/p\u003e\n\u003cp\u003eFor projects that are still experimental — at major version \u003ccode\u003ev0\u003c/code\u003e — occasional\nbreaking changes are expected by users. For projects which are declared stable\n— at major version \u003ccode\u003ev1\u003c/code\u003e or higher — breaking changes must be done in a new major\nversion. This post explores major version semantics, how to create and publish a new\nmajor version, and how to maintain multiple major versions of a module.\u003c/p\u003e\n\u003ch2 id=\"major-versions-and-module-paths\"\u003eMajor versions and module paths\u003c/h2\u003e\n\u003cp\u003eModules formalized an important principle in Go, the\n\u003ca href=\"https://research.swtch.com/vgo-import\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003cstrong\u003eimport compatibility rule\u003c/strong\u003e\u003c/a\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eIf an old package and a new package have the same import path,\nthe new package must be backwards compatible with the old package.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBy definition, a new major version of a package is not backwards compatible with\nthe previous version. This means a new major version of a module must have a\ndifferent module path than the previous version. Starting with \u003ccode\u003ev2\u003c/code\u003e, the major\nversion must appear at the end of the module path (declared in the \u003ccode\u003emodule\u003c/code\u003e\nstatement in the \u003ccode\u003ego.mod\u003c/code\u003e file). For example, when the authors of the module\n\u003ccode\u003egithub.com/googleapis/gax-go\u003c/code\u003e developed \u003ccode\u003ev2\u003c/code\u003e, they used the new module path\n\u003ccode\u003egithub.com/googleapis/gax-go/v2\u003c/code\u003e. Users who wanted to use \u003ccode\u003ev2\u003c/code\u003e had to change\ntheir package imports and module requirements to \u003ccode\u003egithub.com/googleapis/gax-go/v2\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe need for major version suffixes is one of the ways Go modules differs from\nmost other dependency management systems. Suffixes are needed to solve\nthe \u003ca href=\"https://research.swtch.com/vgo-import#dependency_story\" rel=\"noreferrer\" target=\"_blank\"\u003ediamond dependency problem\u003c/a\u003e.\nBefore Go modules, \u003ca href=\"http://gopkg.in\" rel=\"noreferrer\" target=\"_blank\"\u003egopkg.in\u003c/a\u003e allowed package maintainers to\nfollow what we now refer to as the import compatibility rule. With gopkg.in, if\nyou depend on a package that imports \u003ccode\u003egopkg.in/yaml.v1\u003c/code\u003e and another package that\nimports \u003ccode\u003egopkg.in/yaml.v2\u003c/code\u003e, there is no conflict because the two \u003ccode\u003eyaml\u003c/code\u003e packages\nhave different import paths — they use a version suffix, as with Go modules.\nSince gopkg.in shares the same version suffix methodology as Go modules, the Go\ncommand accepts the \u003ccode\u003e.v2\u003c/code\u003e in \u003ccode\u003egopkg.in/yaml.v2\u003c/code\u003e as a valid major version suffix.\nThis is a special case for compatibility with gopkg.in: modules hosted at other\ndomains need a slash suffix like \u003ccode\u003e/v2\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"major-version-strategies\"\u003eMajor version strategies\u003c/h2\u003e\n\u003cp\u003eThe recommended strategy is to develop \u003ccode\u003ev2+\u003c/code\u003e modules in a directory named after\nthe major version suffix.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003egithub.com/googleapis/gax-go @ master branch\n/go.mod    → module github.com/googleapis/gax-go\n/v2/go.mod → module github.com/googleapis/gax-go/v2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis approach is compatible with tools that aren’t aware of modules: file paths\nwithin the repository match the paths expected by \u003ccode\u003ego get\u003c/code\u003e in \u003ccode\u003eGOPATH\u003c/code\u003e mode.\nThis strategy also allows all major versions to be developed together in\ndifferent directories.\u003c/p\u003e\n\u003cp\u003eOther strategies may keep major versions on separate branches. However, if\n\u003ccode\u003ev2+\u003c/code\u003e source code is on the repository’s default branch (usually \u003ccode\u003emaster\u003c/code\u003e),\ntools that are not version-aware — including the \u003ccode\u003ego\u003c/code\u003e command in \u003ccode\u003eGOPATH\u003c/code\u003e mode\n— may not distinguish between major versions.\u003c/p\u003e\n\u003cp\u003eThe examples in this post will follow the major version subdirectory strategy,\nsince it provides the most compatibility. We recommend that module authors\nfollow this strategy as long as they have users developing in \u003ccode\u003eGOPATH\u003c/code\u003e mode.\u003c/p\u003e\n\u003ch2 id=\"publishing-v2-and-beyond\"\u003ePublishing v2 and beyond\u003c/h2\u003e\n\u003cp\u003eThis post uses \u003ccode\u003egithub.com/googleapis/gax-go\u003c/code\u003e as an example:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ pwd\n/tmp/gax-go\n$ ls\nCODE_OF_CONDUCT.md  call_option.go  internal\nCONTRIBUTING.md     gax.go          invoke.go\nLICENSE             go.mod          tools.go\nREADME.md           go.sum          RELEASING.md\nheader.go\n$ cat go.mod\nmodule github.com/googleapis/gax-go\n\ngo 1.9\n\nrequire (\n    github.com/golang/protobuf v1.3.1\n    golang.org/x/exp v0.0.0-20190221220918-438050ddec5e\n    golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3\n    golang.org/x/tools v0.0.0-20190114222345-bf090417da8b\n    google.golang.org/grpc v1.19.0\n    honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099\n)\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo start development on \u003ccode\u003ev2\u003c/code\u003e of \u003ccode\u003egithub.com/googleapis/gax-go\u003c/code\u003e, we’ll create a\nnew \u003ccode\u003ev2/\u003c/code\u003e directory and copy our package into it.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ mkdir v2\n$ cp -v *.go v2\n\u0026#39;call_option.go\u0026#39; -\u0026gt; \u0026#39;v2/call_option.go\u0026#39;\n\u0026#39;gax.go\u0026#39; -\u0026gt; \u0026#39;v2/gax.go\u0026#39;\n\u0026#39;header.go\u0026#39; -\u0026gt; \u0026#39;v2/header.go\u0026#39;\n\u0026#39;invoke.go\u0026#39; -\u0026gt; \u0026#39;v2/invoke.go\u0026#39;\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let’s create a v2 \u003ccode\u003ego.mod\u003c/code\u003e file by copying the current \u003ccode\u003ego.mod\u003c/code\u003e file and\nadding a \u003ccode\u003e/v2\u003c/code\u003e suffix to the module path:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cp go.mod v2/go.mod\n$ go mod edit -module github.com/googleapis/gax-go/v2 v2/go.mod\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNote that the \u003ccode\u003ev2\u003c/code\u003e version is treated as a separate module from the \u003ccode\u003ev0 / v1\u003c/code\u003e\nversions: both may coexist in the same build. So, if your \u003ccode\u003ev2+\u003c/code\u003e module has\nmultiple packages, you should update them to use the new \u003ccode\u003e/v2\u003c/code\u003e import path:\notherwise, your \u003ccode\u003ev2+\u003c/code\u003e module will depend on your \u003ccode\u003ev0 / v1\u003c/code\u003e module. For example,\nto update all \u003ccode\u003egithub.com/my/project\u003c/code\u003e references to \u003ccode\u003egithub.com/my/project/v2\u003c/code\u003e,\nyou can use \u003ccode\u003efind\u003c/code\u003e and \u003ccode\u003esed\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ find . -type f \\\n    -name \u0026#39;*.go\u0026#39; \\\n    -exec sed -i -e \u0026#39;s,github.com/my/project,github.com/my/project/v2,g\u0026#39; {} \\;\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow we have a \u003ccode\u003ev2\u003c/code\u003e module, but we want to experiment and make changes before\npublishing a release. Until we release \u003ccode\u003ev2.0.0\u003c/code\u003e (or any version without a\npre-release suffix), we can develop and make breaking changes as we decide on\nthe new API. If we want users to be able to experiment with the new API before\nwe officially make it stable, we can publish a \u003ccode\u003ev2\u003c/code\u003e pre-release version:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git tag v2.0.0-alpha.1\n$ git push origin v2.0.0-alpha.1\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOnce we are happy with our \u003ccode\u003ev2\u003c/code\u003e API and are sure we don’t need any other breaking\nchanges, we can tag \u003ccode\u003ev2.0.0\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git tag v2.0.0\n$ git push origin v2.0.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt that point, there are now two major versions to maintain. Backwards\ncompatible changes and bug fixes will lead to new minor and patch releases\n(for example, \u003ccode\u003ev1.1.0\u003c/code\u003e, \u003ccode\u003ev2.0.1\u003c/code\u003e, etc.).\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eMajor version changes result in development and maintenance overhead and\nrequire investment from downstream users to migrate. The larger the project,\nthe larger these overheads tend to be. A major version change should only come\nafter identifying a compelling reason. Once a compelling reason has been\nidentified for a breaking change, we recommend developing multiple major\nversions in the master branch because it is compatible with a wider variety of\nexisting tools.\u003c/p\u003e\n\u003cp\u003eBreaking changes to a \u003ccode\u003ev1+\u003c/code\u003e module should always happen in a new, \u003ccode\u003evN+1\u003c/code\u003e module.\nWhen a new module is released, it means additional work for the maintainers and\nfor the users who need to migrate to the new package. Maintainers should\ntherefore validate their APIs before making a stable release, and consider\ncarefully whether breaking changes are really necessary beyond \u003ccode\u003ev1\u003c/code\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-11-07T00:00:00Z",
  "Author": "Jean de Klerk and Tyler Bui-Palsulich"
}