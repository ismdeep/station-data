{
  "Source": "go.dev",
  "Title": "Publishing Go Modules",
  "Link": "https://go.dev/blog/publishing-go-modules",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/publishing-go-modules\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003ePublishing Go Modules\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Tyler Bui-Palsulich\u003cbr/\u003e\n      26 September 2019\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eThis post is part 3 in a series.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePart 1 — \u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 2 — \u003ca href=\"/blog/migrating-to-go-modules\"\u003eMigrating To Go Modules\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ePart 3 — Publishing Go Modules\u003c/strong\u003e (this post)\u003c/li\u003e\n\u003cli\u003ePart 4 — \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003ePart 5 — \u003ca href=\"/blog/module-compatibility\"\u003eKeeping Your Modules Compatible\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e For documentation on developing modules, see\n\u003ca href=\"/doc/modules/developing\"\u003eDeveloping and publishing modules\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis post discusses how to write and publish modules so other modules can depend\non them.\u003c/p\u003e\n\u003cp\u003ePlease note: this post covers development up to and including \u003ccode\u003ev1\u003c/code\u003e. If you are\ninterested in \u003ccode\u003ev2\u003c/code\u003e, please see \u003ca href=\"/blog/v2-go-modules\"\u003eGo Modules: v2 and Beyond\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThis post uses \u003ca href=\"https://git-scm.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eGit\u003c/a\u003e in examples.\n\u003ca href=\"https://www.mercurial-scm.org/\" rel=\"noreferrer\" target=\"_blank\"\u003eMercurial\u003c/a\u003e,\n\u003ca href=\"http://wiki.bazaar.canonical.com/\" rel=\"noreferrer\" target=\"_blank\"\u003eBazaar\u003c/a\u003e, and others are supported as well.\u003c/p\u003e\n\u003ch2 id=\"project-setup\"\u003eProject setup\u003c/h2\u003e\n\u003cp\u003eFor this post, you’ll need an existing project to use as an example. So, start\nwith the files from the end of the\n\u003ca href=\"/blog/using-go-modules\"\u003eUsing Go Modules\u003c/a\u003e article:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ cat go.mod\nmodule example.com/hello\n\ngo 1.12\n\nrequire rsc.io/quote/v3 v3.1.0\n\n$ cat go.sum\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\nrsc.io/quote/v3 v3.1.0 h1:9JKUTTIUgS6kzR9mK1YuGKv6Nl+DijDNIc0ghT58FaY=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n\n$ cat hello.go\npackage hello\n\nimport \u0026#34;rsc.io/quote/v3\u0026#34;\n\nfunc Hello() string {\n    return quote.HelloV3()\n}\n\nfunc Proverb() string {\n    return quote.Concurrency()\n}\n\n$ cat hello_test.go\npackage hello\n\nimport (\n    \u0026#34;testing\u0026#34;\n)\n\nfunc TestHello(t *testing.T) {\n    want := \u0026#34;Hello, world.\u0026#34;\n    if got := Hello(); got != want {\n        t.Errorf(\u0026#34;Hello() = %q, want %q\u0026#34;, got, want)\n    }\n}\n\nfunc TestProverb(t *testing.T) {\n    want := \u0026#34;Concurrency is not parallelism.\u0026#34;\n    if got := Proverb(); got != want {\n        t.Errorf(\u0026#34;Proverb() = %q, want %q\u0026#34;, got, want)\n    }\n}\n\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext, create a new \u003ccode\u003egit\u003c/code\u003e repository and add an initial commit. If you’re\npublishing your own project, be sure to include a \u003ccode\u003eLICENSE\u003c/code\u003e file. Change to the\ndirectory containing the \u003ccode\u003ego.mod\u003c/code\u003e then create the repo:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ git init\n$ git add LICENSE go.mod go.sum hello.go hello_test.go\n$ git commit -m \u0026#34;hello: initial commit\u0026#34;\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"semantic-versions-and-modules\"\u003eSemantic versions and modules\u003c/h2\u003e\n\u003cp\u003eEvery required module in a \u003ccode\u003ego.mod\u003c/code\u003e has a\n\u003ca href=\"https://semver.org\" rel=\"noreferrer\" target=\"_blank\"\u003esemantic version\u003c/a\u003e, the minimum version of that dependency\nto use to build the module.\u003c/p\u003e\n\u003cp\u003eA semantic version has the form \u003ccode\u003evMAJOR.MINOR.PATCH\u003c/code\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIncrement the \u003ccode\u003eMAJOR\u003c/code\u003e version when you make a \u003ca href=\"/doc/go1compat\"\u003ebackwards incompatible\u003c/a\u003e\nchange to the public API of your module.\nThis should only be done when absolutely necessary.\u003c/li\u003e\n\u003cli\u003eIncrement the \u003ccode\u003eMINOR\u003c/code\u003e version when you make a backwards compatible change to the API,\nlike changing dependencies or adding a new function,\nmethod, struct field, or type.\u003c/li\u003e\n\u003cli\u003eIncrement the \u003ccode\u003ePATCH\u003c/code\u003e version after making minor changes that don’t affect\nyour module’s public API or dependencies, like fixing a bug.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eYou can specify pre-release versions by appending a hyphen and dot separated\nidentifiers (for example, \u003ccode\u003ev1.0.1-alpha\u003c/code\u003e or \u003ccode\u003ev2.2.2-beta.2\u003c/code\u003e). Normal releases\nare preferred by the \u003ccode\u003ego\u003c/code\u003e command over pre-release versions, so users must ask\nfor pre-release versions explicitly (for example,\n\u003ccode\u003ego get example.com/hello@v1.0.1-alpha\u003c/code\u003e) if your module has any normal releases.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ev0\u003c/code\u003e major versions and pre-release versions do not guarantee backwards\ncompatibility. They let you refine your API before making stability commitments\nto your users. However, \u003ccode\u003ev1\u003c/code\u003e major versions and beyond require backwards\ncompatibility within that major version.\u003c/p\u003e\n\u003cp\u003eThe version referenced in a \u003ccode\u003ego.mod\u003c/code\u003e may be an explicit release tagged in the\nrepository (for example, \u003ccode\u003ev1.5.2\u003c/code\u003e), or it may be a\n\u003ca href=\"/ref/mod#pseudo-versions\"\u003epseudo-version\u003c/a\u003e based on a\nspecific commit (for example, \u003ccode\u003ev0.0.0-20170915032832-14c0d48ead0c\u003c/code\u003e).\nPseudo-versions are a special type of pre-release version. Pseudo-versions are\nuseful when a user needs to depend on a project that has not published any\nsemantic version tags, or develop against a commit that hasn’t been tagged yet,\nbut users should not assume that pseudo-versions provide a stable or well-tested\nAPI. Tagging your modules with explicit versions signals to your users that\nspecific versions are fully tested and ready to use.\u003c/p\u003e\n\u003cp\u003eOnce you start tagging your repo with versions, it’s important to keep tagging\nnew releases as you develop your module. When users request a new version of\nyour module (with \u003ccode\u003ego get -u\u003c/code\u003e or \u003ccode\u003ego get example.com/hello\u003c/code\u003e), the \u003ccode\u003ego\u003c/code\u003e command\nwill choose the greatest semantic release version available, even if that\nversion is several years old and many changes behind the primary branch.\nContinuing to tag new releases will make your ongoing improvements available to\nyour users.\u003c/p\u003e\n\u003cp\u003eDo not delete version tags from your repo. If you find a bug or a security issue\nwith a version, release a new version. If people depend on a version that you\nhave deleted, their builds may fail. Similarly, once you release a version, do\nnot change or overwrite it. The\n\u003ca href=\"/blog/module-mirror-launch\"\u003emodule mirror and checksum database\u003c/a\u003e\nstore modules, their versions, and signed cryptographic hashes to ensure that\nthe build of a given version remains reproducible over time.\u003c/p\u003e\n\u003ch2 id=\"v0-the-initial-unstable-version\"\u003ev0: the initial, unstable version\u003c/h2\u003e\n\u003cp\u003eLet’s tag the module with a \u003ccode\u003ev0\u003c/code\u003e semantic version. A \u003ccode\u003ev0\u003c/code\u003e version does not make\nany stability guarantees, so nearly all projects should start with \u003ccode\u003ev0\u003c/code\u003e as they\nrefine their public API.\u003c/p\u003e\n\u003cp\u003eTagging a new version has a few steps:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eRun \u003ccode\u003ego mod tidy\u003c/code\u003e, which removes any dependencies the module might have accumulated that are no longer necessary.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eRun \u003ccode\u003ego test ./...\u003c/code\u003e a final time to make sure everything is working.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eTag the project with a new version using \u003ca href=\"https://git-scm.com/docs/git-tag\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003egit tag\u003c/code\u003e\u003c/a\u003e.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ePush the new tag to the origin repository.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod tidy\n$ go test ./...\nok      example.com/hello       0.015s\n$ git add go.mod go.sum hello.go hello_test.go\n$ git commit -m \u0026#34;hello: changes for v0.1.0\u0026#34;\n$ git tag v0.1.0\n$ git push origin v0.1.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow other projects can depend on \u003ccode\u003ev0.1.0\u003c/code\u003e of \u003ccode\u003eexample.com/hello\u003c/code\u003e. For your own\nmodule, you can run \u003ccode\u003ego list -m example.com/hello@v0.1.0\u003c/code\u003e to confirm the latest\nversion is available (this example module does not exist, so no versions are\navailable). If you don’t see the latest version immediately and you’re using the\nGo module proxy (the default since Go 1.13), try again in a few minutes to give\nthe proxy time to load the new version.\u003c/p\u003e\n\u003cp\u003eIf you add to the public API, make a breaking change to a \u003ccode\u003ev0\u003c/code\u003e module, or\nupgrade the minor or version of one of your dependencies,  increment the \u003ccode\u003eMINOR\u003c/code\u003e\nversion for your next release. For example, the next release after \u003ccode\u003ev0.1.0\u003c/code\u003e\nwould be \u003ccode\u003ev0.2.0\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eIf you fix a bug in an existing version, increment the \u003ccode\u003ePATCH\u003c/code\u003e version. For\nexample, the next release after \u003ccode\u003ev0.1.0\u003c/code\u003e would be \u003ccode\u003ev0.1.1\u003c/code\u003e.\u003c/p\u003e\n\u003ch2 id=\"v1-the-first-stable-version\"\u003ev1: the first stable version\u003c/h2\u003e\n\u003cp\u003eOnce you are absolutely sure your module’s API is stable, you can release\n\u003ccode\u003ev1.0.0\u003c/code\u003e. A \u003ccode\u003ev1\u003c/code\u003e major version communicates to users that no incompatible\nchanges will be made to the module’s API. They can upgrade to new \u003ccode\u003ev1\u003c/code\u003e minor and\npatch releases, and their code should not break. Function and method signatures\nwill not change, exported types will not be removed, and so on. If there are\nchanges to the API, they will be backwards compatible (for example, adding a new\nfield to a struct) and will be included in a new minor release. If there are bug\nfixes (for example, a security fix), they will be included in a patch release\n(or as part of a minor release).\u003c/p\u003e\n\u003cp\u003eSometimes, maintaining backwards compatibility can lead to awkward APIs. That’s\nOK. An imperfect API is better than breaking users’ existing code.\u003c/p\u003e\n\u003cp\u003eThe standard library’s \u003ccode\u003estrings\u003c/code\u003e package is a prime example of maintaining\nbackwards compatibility at the cost of API consistency.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://godoc.org/strings#Split\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSplit\u003c/code\u003e\u003c/a\u003e slices a string into all\nsubstrings separated by a separator and returns a slice of the substrings\nbetween those separators.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://godoc.org/strings#SplitN\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eSplitN\u003c/code\u003e\u003c/a\u003e can be used to control the number of substrings to return.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHowever, \u003ca href=\"https://godoc.org/strings#Replace\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eReplace\u003c/code\u003e\u003c/a\u003e took a count of how\nmany instances of the string to replace from the beginning (unlike \u003ccode\u003eSplit\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eGiven \u003ccode\u003eSplit\u003c/code\u003e and \u003ccode\u003eSplitN\u003c/code\u003e, you would expect functions like \u003ccode\u003eReplace\u003c/code\u003e and\n\u003ccode\u003eReplaceN\u003c/code\u003e. But, we couldn’t change the existing \u003ccode\u003eReplace\u003c/code\u003e without breaking\ncallers, which we promised not to do. So, in Go 1.12, we added a new function,\n\u003ca href=\"https://godoc.org/strings#ReplaceAll\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003eReplaceAll\u003c/code\u003e\u003c/a\u003e. The resulting API is a\nlittle odd, since \u003ccode\u003eSplit\u003c/code\u003e and \u003ccode\u003eReplace\u003c/code\u003e behave differently, but that\ninconsistency is better than a breaking change.\u003c/p\u003e\n\u003cp\u003eLet’s say you’re happy with the API of \u003ccode\u003eexample.com/hello\u003c/code\u003e and you want to\nrelease \u003ccode\u003ev1\u003c/code\u003e as the first stable version.\u003c/p\u003e\n\u003cp\u003eTagging \u003ccode\u003ev1\u003c/code\u003e uses the same process as tagging a \u003ccode\u003ev0\u003c/code\u003e version: run \u003ccode\u003ego mod tidy\u003c/code\u003e\nand \u003ccode\u003ego test ./...\u003c/code\u003e, tag the version, and push the tag to the origin repository:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e$ go mod tidy\n$ go test ./...\nok      example.com/hello       0.015s\n$ git add go.mod go.sum hello.go hello_test.go\n$ git commit -m \u0026#34;hello: changes for v1.0.0\u0026#34;\n$ git tag v1.0.0\n$ git push origin v1.0.0\n$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAt this point, the \u003ccode\u003ev1\u003c/code\u003e API of \u003ccode\u003eexample.com/hello\u003c/code\u003e is solidified. This\ncommunicates to everyone that our API is stable and they should feel comfortable\nusing it.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThis post walked through the process of tagging a module with semantic versions\nand when to release \u003ccode\u003ev1\u003c/code\u003e. A future post will cover how to maintain and publish\nmodules at \u003ccode\u003ev2\u003c/code\u003e and beyond.\u003c/p\u003e\n\u003cp\u003eTo provide feedback and help shape the future of dependency management in Go,\nplease send us \u003ca href=\"/issue/new\"\u003ebug reports\u003c/a\u003e or\n\u003ca href=\"/wiki/ExperienceReports\"\u003eexperience reports\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThanks for all your feedback and help improving Go modules.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-09-26T00:00:00Z",
  "Author": "Tyler Bui-Palsulich"
}