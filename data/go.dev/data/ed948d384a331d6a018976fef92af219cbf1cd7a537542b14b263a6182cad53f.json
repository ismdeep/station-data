{
  "Source": "go.dev",
  "Title": "Error handling and Go",
  "Link": "https://go.dev/blog/error-handling-and-go",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/error-handling-and-go\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eError handling and Go\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Andrew Gerrand\u003cbr/\u003e\n      12 July 2011\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIf you have written any Go code you have probably encountered the built-in \u003ccode\u003eerror\u003c/code\u003e type.\nGo code uses \u003ccode\u003eerror\u003c/code\u003e values to indicate an abnormal state.\nFor example, the \u003ccode\u003eos.Open\u003c/code\u003e function returns a non-nil \u003ccode\u003eerror\u003c/code\u003e value when\nit fails to open a file.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Open(name string) (file *File, err error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe following code uses \u003ccode\u003eos.Open\u003c/code\u003e to open a file.\nIf an error occurs it calls \u003ccode\u003elog.Fatal\u003c/code\u003e to print the error message and stop.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef, err := os.Open(\u0026#34;filename.ext\u0026#34;)\nif err != nil {\n    log.Fatal(err)\n}\n// do something with the open *File f\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can get a lot done in Go knowing just this about the \u003ccode\u003eerror\u003c/code\u003e type,\nbut in this article we’ll take a closer look at \u003ccode\u003eerror\u003c/code\u003e and discuss some\ngood practices for error handling in Go.\u003c/p\u003e\n\u003ch2 id=\"the-error-type\"\u003eThe error type\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eerror\u003c/code\u003e type is an interface type. An \u003ccode\u003eerror\u003c/code\u003e variable represents any\nvalue that can describe itself as a string.\nHere is the interface’s declaration:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype error interface {\n    Error() string\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eerror\u003c/code\u003e type, as with all built in types,\nis \u003ca href=\"/doc/go_spec.html#Predeclared_identifiers\"\u003epredeclared\u003c/a\u003e\nin the \u003ca href=\"/doc/go_spec.html#Blocks\"\u003euniverse block\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe most commonly-used \u003ccode\u003eerror\u003c/code\u003e implementation is the \u003ca href=\"/pkg/errors/\"\u003eerrors\u003c/a\u003e\npackage’s unexported \u003ccode\u003eerrorString\u003c/code\u003e type.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// errorString is a trivial implementation of error.\ntype errorString struct {\n    s string\n}\n\nfunc (e *errorString) Error() string {\n    return e.s\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eYou can construct one of these values with the \u003ccode\u003eerrors.New\u003c/code\u003e function.\nIt takes a string that it converts to an \u003ccode\u003eerrors.errorString\u003c/code\u003e and returns\nas an \u003ccode\u003eerror\u003c/code\u003e value.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// New returns an error that formats as the given text.\nfunc New(text string) error {\n    return \u0026amp;errorString{text}\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHere’s how you might use \u003ccode\u003eerrors.New\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Sqrt(f float64) (float64, error) {\n    if f \u0026lt; 0 {\n        return 0, errors.New(\u0026#34;math: square root of negative number\u0026#34;)\n    }\n    // implementation\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA caller passing a negative argument to \u003ccode\u003eSqrt\u003c/code\u003e receives a non-nil \u003ccode\u003eerror\u003c/code\u003e\nvalue (whose concrete representation is an \u003ccode\u003eerrors.errorString\u003c/code\u003e value).\nThe caller can access the error string (“math:\nsquare root of…”) by calling the \u003ccode\u003eerror\u003c/code\u003e’s \u003ccode\u003eError\u003c/code\u003e method,\nor by just printing it:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ef, err := Sqrt(-1)\nif err != nil {\n    fmt.Println(err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/fmt/\"\u003efmt\u003c/a\u003e package formats an \u003ccode\u003eerror\u003c/code\u003e value by calling its \u003ccode\u003eError() string\u003c/code\u003e method.\u003c/p\u003e\n\u003cp\u003eIt is the error implementation’s responsibility to summarize the context.\nThe error returned by \u003ccode\u003eos.Open\u003c/code\u003e formats as “open /etc/passwd:\npermission denied,” not just “permission denied.”  The error returned by\nour \u003ccode\u003eSqrt\u003c/code\u003e is missing information about the invalid argument.\u003c/p\u003e\n\u003cp\u003eTo add that information, a useful function is the \u003ccode\u003efmt\u003c/code\u003e package’s \u003ccode\u003eErrorf\u003c/code\u003e.\nIt formats a string according to \u003ccode\u003ePrintf\u003c/code\u003e’s rules and returns it as an \u003ccode\u003eerror\u003c/code\u003e\ncreated by \u003ccode\u003eerrors.New\u003c/code\u003e.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif f \u0026lt; 0 {\n    return 0, fmt.Errorf(\u0026#34;math: square root of negative number %g\u0026#34;, f)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIn many cases \u003ccode\u003efmt.Errorf\u003c/code\u003e is good enough,\nbut since \u003ccode\u003eerror\u003c/code\u003e is an interface, you can use arbitrary data structures as error values,\nto allow callers to inspect the details of the error.\u003c/p\u003e\n\u003cp\u003eFor instance, our hypothetical callers might want to recover the invalid\nargument passed to \u003ccode\u003eSqrt\u003c/code\u003e.\nWe can enable that by defining a new error implementation instead of using\n\u003ccode\u003eerrors.errorString\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype NegativeSqrtError float64\n\nfunc (f NegativeSqrtError) Error() string {\n    return fmt.Sprintf(\u0026#34;math: square root of negative number %g\u0026#34;, float64(f))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eA sophisticated caller can then use a \u003ca href=\"/doc/go_spec.html#Type_assertions\"\u003etype assertion\u003c/a\u003e\nto check for a \u003ccode\u003eNegativeSqrtError\u003c/code\u003e and handle it specially,\nwhile callers that just pass the error to \u003ccode\u003efmt.Println\u003c/code\u003e or \u003ccode\u003elog.Fatal\u003c/code\u003e will\nsee no change in behavior.\u003c/p\u003e\n\u003cp\u003eAs another example, the \u003ca href=\"/pkg/encoding/json/\"\u003ejson\u003c/a\u003e\npackage specifies a \u003ccode\u003eSyntaxError\u003c/code\u003e type that the \u003ccode\u003ejson.Decode\u003c/code\u003e function returns\nwhen it encounters a syntax error parsing a JSON blob.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype SyntaxError struct {\n    msg    string // description of error\n    Offset int64  // error occurred after reading Offset bytes\n}\n\nfunc (e *SyntaxError) Error() string { return e.msg }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eOffset\u003c/code\u003e field isn’t even shown in the default formatting of the error,\nbut callers can use it to add file and line information to their error messages:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err := dec.Decode(\u0026amp;val); err != nil {\n    if serr, ok := err.(*json.SyntaxError); ok {\n        line, col := findLine(f, serr.Offset)\n        return fmt.Errorf(\u0026#34;%s:%d:%d: %v\u0026#34;, f.Name(), line, col, err)\n    }\n    return err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(This is a slightly simplified version of some \u003ca href=\"https://github.com/camlistore/go4/blob/03efcb870d84809319ea509714dd6d19a1498483/jsonconfig/eval.go#L123-L135\" rel=\"noreferrer\" target=\"_blank\"\u003eactual code\u003c/a\u003e\nfrom the \u003ca href=\"http://camlistore.org\" rel=\"noreferrer\" target=\"_blank\"\u003eCamlistore\u003c/a\u003e project.)\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eerror\u003c/code\u003e interface requires only a \u003ccode\u003eError\u003c/code\u003e method;\nspecific error implementations might have additional methods.\nFor instance, the \u003ca href=\"/pkg/net/\"\u003enet\u003c/a\u003e package returns errors of type \u003ccode\u003eerror\u003c/code\u003e,\nfollowing the usual convention, but some of the error implementations have\nadditional methods defined by the \u003ccode\u003enet.Error\u003c/code\u003e interface:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epackage net\n\ntype Error interface {\n    error\n    Timeout() bool   // Is the error a timeout?\n    Temporary() bool // Is the error temporary?\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eClient code can test for a \u003ccode\u003enet.Error\u003c/code\u003e with a type assertion and then distinguish\ntransient network errors from permanent ones.\nFor instance, a web crawler might sleep and retry when it encounters a temporary\nerror and give up otherwise.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif nerr, ok := err.(net.Error); ok \u0026amp;\u0026amp; nerr.Temporary() {\n    time.Sleep(1e9)\n    continue\n}\nif err != nil {\n    log.Fatal(err)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"simplifying-repetitive-error-handling\"\u003eSimplifying repetitive error handling\u003c/h2\u003e\n\u003cp\u003eIn Go, error handling is important. The language’s design and conventions\nencourage you to explicitly check for errors where they occur (as distinct\nfrom the convention in other languages of throwing exceptions and sometimes catching them).\nIn some cases this makes Go code verbose,\nbut fortunately there are some techniques you can use to minimize repetitive error handling.\u003c/p\u003e\n\u003cp\u003eConsider an \u003ca href=\"https://cloud.google.com/appengine/docs/go/\" rel=\"noreferrer\" target=\"_blank\"\u003eApp Engine\u003c/a\u003e\napplication with an HTTP handler that retrieves a record from the datastore\nand formats it with a template.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc init() {\n    http.HandleFunc(\u0026#34;/view\u0026#34;, viewRecord)\n}\n\nfunc viewRecord(w http.ResponseWriter, r *http.Request) {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \u0026#34;Record\u0026#34;, r.FormValue(\u0026#34;id\u0026#34;), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        http.Error(w, err.Error(), 500)\n        return\n    }\n    if err := viewTemplate.Execute(w, record); err != nil {\n        http.Error(w, err.Error(), 500)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis function handles errors returned by the \u003ccode\u003edatastore.Get\u003c/code\u003e function and\n\u003ccode\u003eviewTemplate\u003c/code\u003e’s \u003ccode\u003eExecute\u003c/code\u003e method.\nIn both cases, it presents a simple error message to the user with the HTTP\nstatus code 500 (“Internal Server Error”).\nThis looks like a manageable amount of code,\nbut add some more HTTP handlers and you quickly end up with many copies\nof identical error handling code.\u003c/p\u003e\n\u003cp\u003eTo reduce the repetition we can define our own HTTP \u003ccode\u003eappHandler\u003c/code\u003e type that includes an \u003ccode\u003eerror\u003c/code\u003e return value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype appHandler func(http.ResponseWriter, *http.Request) error\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThen we can change our \u003ccode\u003eviewRecord\u003c/code\u003e function to return errors:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc viewRecord(w http.ResponseWriter, r *http.Request) error {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \u0026#34;Record\u0026#34;, r.FormValue(\u0026#34;id\u0026#34;), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        return err\n    }\n    return viewTemplate.Execute(w, record)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is simpler than the original version,\nbut the \u003ca href=\"/pkg/net/http/\"\u003ehttp\u003c/a\u003e package doesn’t understand\nfunctions that return \u003ccode\u003eerror\u003c/code\u003e.\nTo fix this we can implement the \u003ccode\u003ehttp.Handler\u003c/code\u003e interface’s \u003ccode\u003eServeHTTP\u003c/code\u003e\nmethod on \u003ccode\u003eappHandler\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if err := fn(w, r); err != nil {\n        http.Error(w, err.Error(), 500)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe \u003ccode\u003eServeHTTP\u003c/code\u003e method calls the \u003ccode\u003eappHandler\u003c/code\u003e function and displays the\nreturned error (if any) to the user.\nNotice that the method’s receiver, \u003ccode\u003efn\u003c/code\u003e, is a function.\n(Go can do that!) The method invokes the function by calling the receiver\nin the expression \u003ccode\u003efn(w, r)\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eNow when registering \u003ccode\u003eviewRecord\u003c/code\u003e with the http package we use the \u003ccode\u003eHandle\u003c/code\u003e\nfunction (instead of \u003ccode\u003eHandleFunc\u003c/code\u003e) as \u003ccode\u003eappHandler\u003c/code\u003e is an \u003ccode\u003ehttp.Handler\u003c/code\u003e\n(not an \u003ccode\u003ehttp.HandlerFunc\u003c/code\u003e).\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc init() {\n    http.Handle(\u0026#34;/view\u0026#34;, appHandler(viewRecord))\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWith this basic error handling infrastructure in place,\nwe can make it more user friendly.\nRather than just displaying the error string,\nit would be better to give the user a simple error message with an appropriate HTTP status code,\nwhile logging the full error to the App Engine developer console for debugging purposes.\u003c/p\u003e\n\u003cp\u003eTo do this we create an \u003ccode\u003eappError\u003c/code\u003e struct containing an \u003ccode\u003eerror\u003c/code\u003e and some other fields:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype appError struct {\n    Error   error\n    Message string\n    Code    int\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNext we modify the appHandler type to return \u003ccode\u003e*appError\u003c/code\u003e values:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype appHandler func(http.ResponseWriter, *http.Request) *appError\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(It’s usually a mistake to pass back the concrete type of an error rather than \u003ccode\u003eerror\u003c/code\u003e,\nfor reasons discussed in \u003ca href=\"/doc/go_faq.html#nil_error\"\u003ethe Go FAQ\u003c/a\u003e,\nbut it’s the right thing to do here because \u003ccode\u003eServeHTTP\u003c/code\u003e is the only place\nthat sees the value and uses its contents.)\u003c/p\u003e\n\u003cp\u003eAnd make \u003ccode\u003eappHandler\u003c/code\u003e’s \u003ccode\u003eServeHTTP\u003c/code\u003e method display the \u003ccode\u003eappError\u003c/code\u003e’s \u003ccode\u003eMessage\u003c/code\u003e\nto the user with the correct HTTP status \u003ccode\u003eCode\u003c/code\u003e and log the full \u003ccode\u003eError\u003c/code\u003e\nto the developer console:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (fn appHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    if e := fn(w, r); e != nil { // e is *appError, not os.Error.\n        c := appengine.NewContext(r)\n        c.Errorf(\u0026#34;%v\u0026#34;, e.Error)\n        http.Error(w, e.Message, e.Code)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eFinally, we update \u003ccode\u003eviewRecord\u003c/code\u003e to the new function signature and have it\nreturn more context when it encounters an error:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc viewRecord(w http.ResponseWriter, r *http.Request) *appError {\n    c := appengine.NewContext(r)\n    key := datastore.NewKey(c, \u0026#34;Record\u0026#34;, r.FormValue(\u0026#34;id\u0026#34;), 0, nil)\n    record := new(Record)\n    if err := datastore.Get(c, key, record); err != nil {\n        return \u0026amp;appError{err, \u0026#34;Record not found\u0026#34;, 404}\n    }\n    if err := viewTemplate.Execute(w, record); err != nil {\n        return \u0026amp;appError{err, \u0026#34;Can\u0026#39;t display record\u0026#34;, 500}\n    }\n    return nil\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis version of \u003ccode\u003eviewRecord\u003c/code\u003e is the same length as the original,\nbut now each of those lines has specific meaning and we are providing a\nfriendlier user experience.\u003c/p\u003e\n\u003cp\u003eIt doesn’t end there; we can further improve the error handling in our application. Some ideas:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003egive the error handler a pretty HTML template,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003emake debugging easier by writing the stack trace to the HTTP response when the user is an administrator,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003ewrite a constructor function for \u003ccode\u003eappError\u003c/code\u003e that stores the stack trace for easier debugging,\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003erecover from panics inside the \u003ccode\u003eappHandler\u003c/code\u003e,\nlogging the error to the console as “Critical,” while telling the user “a\nserious error has occurred.” This is a nice touch to avoid exposing the\nuser to inscrutable error messages caused by programming errors.\nSee the \u003ca href=\"/doc/articles/defer_panic_recover.html\"\u003eDefer, Panic, and Recover\u003c/a\u003e\narticle for more details.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eProper error handling is an essential requirement of good software.\nBy employing the techniques described in this post you should be able to\nwrite more reliable and succinct Go code.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2011-07-12T00:00:00Z",
  "Author": "Andrew Gerrand"
}