{
  "Source": "go.dev",
  "Title": "Errors are values",
  "Link": "https://go.dev/blog/errors-are-values",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/errors-are-values\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eErrors are values\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Rob Pike\u003cbr/\u003e\n      12 January 2015\n      \u003c/p\u003e\n      \n      \u003cp\u003eA common point of discussion among Go programmers,\nespecially those new to the language, is how to handle errors.\nThe conversation often turns into a lament at the number of times the sequence\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil {\n    return err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eshows up.\nWe recently scanned all the open source projects we could find and\ndiscovered that this snippet occurs only once per page or two,\nless often than some would have you believe.\nStill, if the perception persists that one must type\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eall the time, something must be wrong, and the obvious target is Go itself.\u003c/p\u003e\n\u003cp\u003eThis is unfortunate, misleading, and easily corrected.\nPerhaps what is happening is that programmers new to Go ask,\n“How does one handle errors?”, learn this pattern, and stop there.\nIn other languages, one might use a try-catch block or other such mechanism to handle errors.\nTherefore, the programmer thinks, when I would have used a try-catch\nin my old language, I will just type \u003ccode\u003eif\u003c/code\u003e \u003ccode\u003eerr\u003c/code\u003e \u003ccode\u003e!=\u003c/code\u003e \u003ccode\u003enil\u003c/code\u003e in Go.\nOver time the Go code collects many such snippets, and the result feels clumsy.\u003c/p\u003e\n\u003cp\u003eRegardless of whether this explanation fits,\nit is clear that these Go programmers miss a fundamental point about errors:\n\u003cem\u003eErrors are values.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eValues can be programmed, and since errors are values, errors can be programmed.\u003c/p\u003e\n\u003cp\u003eOf course a common statement involving an error value is to test whether it is nil,\nbut there are countless other things one can do with an error value,\nand application of some of those other things can make your program better,\neliminating much of the boilerplate that arises if every error is checked with a rote if statement.\u003c/p\u003e\n\u003cp\u003eHere’s a simple example from the \u003ccode\u003ebufio\u003c/code\u003e package’s\n\u003ca href=\"/pkg/bufio/#Scanner\"\u003e\u003ccode\u003eScanner\u003c/code\u003e\u003c/a\u003e type.\nIts \u003ca href=\"/pkg/bufio/#Scanner.Scan\"\u003e\u003ccode\u003eScan\u003c/code\u003e\u003c/a\u003e method performs the underlying I/O,\nwhich can of course lead to an error.\nYet the \u003ccode\u003eScan\u003c/code\u003e method does not expose an error at all.\nInstead, it returns a boolean, and a separate method, to be run at the end of the scan,\nreports whether an error occurred.\nClient code looks like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escanner := bufio.NewScanner(input)\nfor scanner.Scan() {\n    token := scanner.Text()\n    // process token\n}\nif err := scanner.Err(); err != nil {\n    // process the error\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSure, there is a nil check for an error, but it appears and executes only once.\nThe \u003ccode\u003eScan\u003c/code\u003e method could instead have been defined as\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (s *Scanner) Scan() (token []byte, error)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand then the example user code might be (depending on how the token is retrieved),\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003escanner := bufio.NewScanner(input)\nfor {\n    token, err := scanner.Scan()\n    if err != nil {\n        return err // or maybe break\n    }\n    // process token\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis isn’t very different, but there is one important distinction.\nIn this code, the client must check for an error on every iteration,\nbut in the real \u003ccode\u003eScanner\u003c/code\u003e API, the error handling is abstracted away from the key API element,\nwhich is iterating over tokens.\nWith the real API, the client’s code therefore feels more natural:\nloop until done, then worry about errors.\nError handling does not obscure the flow of control.\u003c/p\u003e\n\u003cp\u003eUnder the covers what’s happening, of course,\nis that as soon as \u003ccode\u003eScan\u003c/code\u003e encounters an I/O error, it records it and returns \u003ccode\u003efalse\u003c/code\u003e.\nA separate method, \u003ca href=\"/pkg/bufio/#Scanner.Err\"\u003e\u003ccode\u003eErr\u003c/code\u003e\u003c/a\u003e,\nreports the error value when the client asks.\nTrivial though this is, it’s not the same as putting\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eif err != nil\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eeverywhere or asking the client to check for an error after every token.\nIt’s programming with error values.\nSimple programming, yes, but programming nonetheless.\u003c/p\u003e\n\u003cp\u003eIt’s worth stressing that whatever the design,\nit’s critical that the program check the errors however they are exposed.\nThe discussion here is not about how to avoid checking errors,\nit’s about using the language to handle errors with grace.\u003c/p\u003e\n\u003cp\u003eThe topic of repetitive error-checking code arose when I attended the autumn 2014 GoCon in Tokyo.\nAn enthusiastic gopher, who goes by \u003ca href=\"https://twitter.com/jxck_\" rel=\"noreferrer\" target=\"_blank\"\u003e\u003ccode\u003e@jxck_\u003c/code\u003e\u003c/a\u003e on Twitter,\nechoed the familiar lament about error checking.\nHe had some code that looked schematically like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e_, err = fd.Write(p0[a:b])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p1[c:d])\nif err != nil {\n    return err\n}\n_, err = fd.Write(p2[e:f])\nif err != nil {\n    return err\n}\n// and so on\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is very repetitive.\nIn the real code, which was longer,\nthere is more going on so it’s not easy to just refactor this using a helper function,\nbut in this idealized form, a function literal closing over the error variable would help:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003evar err error\nwrite := func(buf []byte) {\n    if err != nil {\n        return\n    }\n    _, err = w.Write(buf)\n}\nwrite(p0[a:b])\nwrite(p1[c:d])\nwrite(p2[e:f])\n// and so on\nif err != nil {\n    return err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis pattern works well, but requires a closure in each function doing the writes;\na separate helper function is clumsier to use because the \u003ccode\u003eerr\u003c/code\u003e variable\nneeds to be maintained across calls (try it).\u003c/p\u003e\n\u003cp\u003eWe can make this cleaner, more general, and reusable by borrowing the idea from the\n\u003ccode\u003eScan\u003c/code\u003e method above.\nI mentioned this technique in our discussion but \u003ccode\u003e@jxck_\u003c/code\u003e didn’t see how to apply it.\nAfter a long exchange, hampered somewhat by a language barrier,\nI asked if I could just borrow his laptop and show him by typing some code.\u003c/p\u003e\n\u003cp\u003eI defined an object called an \u003ccode\u003eerrWriter\u003c/code\u003e, something like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003etype errWriter struct {\n    w   io.Writer\n    err error\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eand gave it one method, \u003ccode\u003ewrite.\u003c/code\u003e\nIt doesn’t need to have the standard \u003ccode\u003eWrite\u003c/code\u003e signature,\nand it’s lower-cased in part to highlight the distinction.\nThe \u003ccode\u003ewrite\u003c/code\u003e method calls the \u003ccode\u003eWrite\u003c/code\u003e method of the underlying \u003ccode\u003eWriter\u003c/code\u003e\nand records the first error for future reference:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc (ew *errWriter) write(buf []byte) {\n    if ew.err != nil {\n        return\n    }\n    _, ew.err = ew.w.Write(buf)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs soon as an error occurs, the \u003ccode\u003ewrite\u003c/code\u003e method becomes a no-op but the error value is saved.\u003c/p\u003e\n\u003cp\u003eGiven the \u003ccode\u003eerrWriter\u003c/code\u003e type and its \u003ccode\u003ewrite\u003c/code\u003e method, the code above can be refactored:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eew := \u0026amp;errWriter{w: fd}\new.write(p0[a:b])\new.write(p1[c:d])\new.write(p2[e:f])\n// and so on\nif ew.err != nil {\n    return ew.err\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThis is cleaner, even compared to the use of a closure,\nand also makes the actual sequence of writes being done easier to see on the page.\nThere is no clutter anymore.\nProgramming with error values (and interfaces) has made the code nicer.\u003c/p\u003e\n\u003cp\u003eIt’s likely that some other piece of code in the same package can build on this idea,\nor even use \u003ccode\u003eerrWriter\u003c/code\u003e directly.\u003c/p\u003e\n\u003cp\u003eAlso, once \u003ccode\u003eerrWriter\u003c/code\u003e exists, there’s more it could do to help,\nespecially in less artificial examples.\nIt could accumulate the byte count.\nIt could coalesce writes into a single buffer that can then be transmitted atomically.\nAnd much more.\u003c/p\u003e\n\u003cp\u003eIn fact, this pattern appears often in the standard library.\nThe \u003ca href=\"/pkg/archive/zip/\"\u003e\u003ccode\u003earchive/zip\u003c/code\u003e\u003c/a\u003e and\n\u003ca href=\"/pkg/net/http/\"\u003e\u003ccode\u003enet/http\u003c/code\u003e\u003c/a\u003e packages use it.\nMore salient to this discussion, the \u003ca href=\"/pkg/bufio/\"\u003e\u003ccode\u003ebufio\u003c/code\u003e package’s \u003ccode\u003eWriter\u003c/code\u003e\u003c/a\u003e\nis actually an implementation of the \u003ccode\u003eerrWriter\u003c/code\u003e idea.\nAlthough \u003ccode\u003ebufio.Writer.Write\u003c/code\u003e returns an error,\nthat is mostly about honoring the \u003ca href=\"/pkg/io/#Writer\"\u003e\u003ccode\u003eio.Writer\u003c/code\u003e\u003c/a\u003e interface.\nThe \u003ccode\u003eWrite\u003c/code\u003e method of \u003ccode\u003ebufio.Writer\u003c/code\u003e behaves just like our \u003ccode\u003eerrWriter.write\u003c/code\u003e\nmethod above, with \u003ccode\u003eFlush\u003c/code\u003e reporting the error, so our example could be written like this:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eb := bufio.NewWriter(fd)\nb.Write(p0[a:b])\nb.Write(p1[c:d])\nb.Write(p2[e:f])\n// and so on\nif b.Flush() != nil {\n    return b.Flush()\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThere is one significant drawback to this approach, at least for some applications:\nthere is no way to know how much of the processing completed before the error occurred.\nIf that information is important, a more fine-grained approach is necessary.\nOften, though, an all-or-nothing check at the end is sufficient.\u003c/p\u003e\n\u003cp\u003eWe’ve looked at just one technique for avoiding repetitive error handling code.\nKeep in mind that the use of \u003ccode\u003eerrWriter\u003c/code\u003e or \u003ccode\u003ebufio.Writer\u003c/code\u003e isn’t the only way to simplify error handling,\nand this approach is not suitable for all situations.\nThe key lesson, however, is that errors are values and the full power of\nthe Go programming language is available for processing them.\u003c/p\u003e\n\u003cp\u003eUse the language to simplify your error handling.\u003c/p\u003e\n\u003cp\u003eBut remember: Whatever you do, always check your errors!\u003c/p\u003e\n\u003cp\u003eFinally, for the full story of my interaction with @jxck_, including a little video he recorded,\nvisit \u003ca href=\"http://jxck.hatenablog.com/entry/golang-error-handling-lesson-by-rob-pike\" rel=\"noreferrer\" target=\"_blank\"\u003ehis blog\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2015-01-12T00:00:00Z",
  "Author": "Rob Pike"
}