{
  "Source": "go.dev",
  "Title": "Robust generic functions on slices",
  "Link": "https://go.dev/blog/generic-slice-functions",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/generic-slice-functions\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eRobust generic functions on slices\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Valentin Deleplace\u003cbr/\u003e\n      22 February 2024\n      \u003c/p\u003e\n      \n      \u003cp\u003eThe \u003ca href=\"/pkg/slices\"\u003eslices\u003c/a\u003e package provides functions that work for slices of any type.\nIn this blog post we’ll discuss how you can use these functions more effectively by understanding how slices are represented in memory and how that affects the garbage collector, and we’ll cover how we recently adjusted these functions to make them less surprising.\u003c/p\u003e\n\u003cp\u003eWith \u003ca href=\"/blog/deconstructing-type-parameters\"\u003eType parameters\u003c/a\u003e we can write functions like \u003ca href=\"/pkg/slices#Index\"\u003eslices.Index\u003c/a\u003e once for all types of slices of comparable elements:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Index returns the index of the first occurrence of v in s,\n// or -1 if not present.\nfunc Index[S ~[]E, E comparable](s S, v E) int {\n    for i := range s {\n        if v == s[i] {\n            return i\n        }\n    }\n    return -1\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIt is no longer necessary to implement \u003ccode\u003eIndex\u003c/code\u003e again for each different type of element.\u003c/p\u003e\n\u003cp\u003eThe \u003ca href=\"/pkg/slices\"\u003eslices\u003c/a\u003e package contains many such helpers to perform common operations on slices:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    s := []string{\u0026#34;Bat\u0026#34;, \u0026#34;Fox\u0026#34;, \u0026#34;Owl\u0026#34;, \u0026#34;Fox\u0026#34;}\n    s2 := slices.Clone(s)\n    slices.Sort(s2)\n    fmt.Println(s2) // [Bat Fox Fox Owl]\n    s2 = slices.Compact(s2)\n    fmt.Println(s2)                  // [Bat Fox Owl]\n    fmt.Println(slices.Equal(s, s2)) // false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSeveral new functions (\u003ccode\u003eInsert\u003c/code\u003e, \u003ccode\u003eReplace\u003c/code\u003e, \u003ccode\u003eDelete\u003c/code\u003e, etc.) modify the slice. To understand how they work, and how to properly use them, we need to examine the underlying structure of slices.\u003c/p\u003e\n\u003cp\u003eA slice is a view of a portion of an array. \u003ca href=\"/blog/slices-intro\"\u003eInternally\u003c/a\u003e, a slice contains a pointer, a length, and a capacity. Two slices can have the same underlying array, and can view overlapping portions.\u003c/p\u003e\n\u003cp\u003eFor example, this slice \u003ccode\u003es\u003c/code\u003e is a view on 4 elements of an array of size 6:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"generic-slice-functions/1_sample_slice_4_6.svg\" width=\"450\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eIf a function changes the length of a slice passed as a parameter, then it needs to return a new slice to the caller. The underlying array may remain the same if it doesn’t have to grow. This explains why \u003ca href=\"/blog/slices\"\u003eappend\u003c/a\u003e and \u003ccode\u003eslices.Compact\u003c/code\u003e return a value, but \u003ccode\u003eslices.Sort\u003c/code\u003e, which merely reorders the elements, does not.\u003c/p\u003e\n\u003cp\u003eConsider the task of deleting a portion of a slice. Prior to generics, the standard way to delete the portion \u003ccode\u003es[2:5]\u003c/code\u003e from the slice \u003ccode\u003es\u003c/code\u003e was to call the \u003ca href=\"/ref/spec#Appending_and_copying_slices\"\u003eappend\u003c/a\u003e function to copy the end portion over the middle portion:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es = append(s[:2], s[5:]...)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe syntax was complex and error-prone, involving subslices and a variadic parameter. We added \u003ca href=\"/pkg/slices#Delete\"\u003eslices.Delete\u003c/a\u003e to make it easier to delete elements:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunc Delete[S ~[]E, E any](s S, i, j int) S {\n       return append(s[:i], s[j:]...)\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe one-line function \u003ccode\u003eDelete\u003c/code\u003e more clearly expresses the programmer’s intent. Let’s consider a slice \u003ccode\u003es\u003c/code\u003e of length 6 and capacity 8, containing pointers:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"generic-slice-functions/2_sample_slice_6_8.svg\" width=\"600\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThis call deletes the elements at \u003ccode\u003es[2]\u003c/code\u003e, \u003ccode\u003es[3]\u003c/code\u003e, \u003ccode\u003es[4]\u003c/code\u003e  from the slice \u003ccode\u003es\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es = slices.Delete(s, 2, 5)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"generic-slice-functions/3_delete_s_2_5.svg\" width=\"600\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe gap at the indices 2, 3, 4 is filled by shifting the element \u003ccode\u003es[5]\u003c/code\u003e to the left, and setting the new length to \u003ccode\u003e3\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDelete\u003c/code\u003e need not allocate a new array, as it shifts the elements in place. Like \u003ccode\u003eappend\u003c/code\u003e, it returns a new slice. Many other functions in the \u003ccode\u003eslices\u003c/code\u003e package follow this pattern, including \u003ccode\u003eCompact\u003c/code\u003e, \u003ccode\u003eCompactFunc\u003c/code\u003e, \u003ccode\u003eDeleteFunc\u003c/code\u003e, \u003ccode\u003eGrow\u003c/code\u003e, \u003ccode\u003eInsert\u003c/code\u003e, and \u003ccode\u003eReplace\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eWhen calling these functions we must consider the original slice invalid, because the underlying array has been modified. It would be a mistake to call the function but ignore the return value:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    slices.Delete(s, 2, 5) // incorrect!\n    // s still has the same length, but modified contents\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"a-problem-of-unwanted-liveness\"\u003eA problem of unwanted liveness\u003c/h2\u003e\n\u003cp\u003eBefore Go 1.22, \u003ccode\u003eslices.Delete\u003c/code\u003e didn’t modify the elements between the new and original lengths of the slice. While the returned slice wouldn’t include these elements, the “gap” created at the end of the original, now-invalidated slice continued to hold onto them. These elements could contain pointers to large objects (a 20MB image), and the garbage collector would not release the memory associated with these objects. This resulted in a memory leak that could lead to significant performance issues.\u003c/p\u003e\n\u003cp\u003eIn this above example, we’re successfully deleting the pointers \u003ccode\u003ep2\u003c/code\u003e, \u003ccode\u003ep3\u003c/code\u003e, \u003ccode\u003ep4\u003c/code\u003e from \u003ccode\u003es[2:5]\u003c/code\u003e, by shifting one element to the left. But \u003ccode\u003ep3\u003c/code\u003e and \u003ccode\u003ep4\u003c/code\u003e are still present in the underlying array, beyond the new length of \u003ccode\u003es\u003c/code\u003e. The garbage collector won’t reclaim them. Less obviously, \u003ccode\u003ep5\u003c/code\u003e is not one of the deleted elements, but its memory may still leak because of the \u003ccode\u003ep5\u003c/code\u003e pointer kept in the gray part of the array.\u003c/p\u003e\n\u003cp\u003eThis could be confusing for developers, if they were not aware that “invisible” elements were still using memory.\u003c/p\u003e\n\u003cp\u003eSo we had two options:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eEither keep the efficient implementation of \u003ccode\u003eDelete\u003c/code\u003e. Let users set obsolete pointers to \u003ccode\u003enil\u003c/code\u003e themselves, if they want to make sure the values pointed to can be freed.\u003c/li\u003e\n\u003cli\u003eOr change \u003ccode\u003eDelete\u003c/code\u003e to always set the obsolete elements to zero. This is extra work, making \u003ccode\u003eDelete\u003c/code\u003e slightly less efficient. Zeroing pointers (setting them to \u003ccode\u003enil\u003c/code\u003e) enables the garbage collection of the objects, when they become otherwise unreachable.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIt was not obvious which option was best. The first one provided performance by default, and the second one provided memory frugality by default.\u003c/p\u003e\n\u003ch2 id=\"the-fix\"\u003eThe fix\u003c/h2\u003e\n\u003cp\u003eA key observation is that “setting the obsolete pointers to \u003ccode\u003enil\u003c/code\u003e” is not as easy as it seems. In fact, this task is so error-prone that we should not put the burden on the user to write it. Out of pragmatism, we chose to modify the implementation of the five functions \u003ccode\u003eCompact\u003c/code\u003e, \u003ccode\u003eCompactFunc\u003c/code\u003e, \u003ccode\u003eDelete\u003c/code\u003e, \u003ccode\u003eDeleteFunc\u003c/code\u003e, \u003ccode\u003eReplace\u003c/code\u003e to “clear the tail”. As a nice side effect, the cognitive load is reduced and users now don’t need to worry about these memory leaks.\u003c/p\u003e\n\u003cp\u003eIn Go 1.22, this is what the memory looks like after calling Delete:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"generic-slice-functions/4_delete_s_2_5_nil.svg\" width=\"600\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe code changed in the five functions uses the new built-in function \u003ca href=\"/pkg/builtin#clear\"\u003eclear\u003c/a\u003e (Go 1.21) to set the obsolete elements to the zero value of the element type of \u003ccode\u003es\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"image\"\u003e\n  \u003cimg src=\"generic-slice-functions/5_Delete_diff.png\" width=\"800\" alt=\"\"/\u003e\n\u003c/div\u003e\n\u003cp\u003eThe zero value of \u003ccode\u003eE\u003c/code\u003e is \u003ccode\u003enil\u003c/code\u003e when \u003ccode\u003eE\u003c/code\u003e is a type of pointer, slice, map, chan, or interface.\u003c/p\u003e\n\u003ch2 id=\"tests-failing\"\u003eTests failing\u003c/h2\u003e\n\u003cp\u003eThis change has led to some tests that passed in Go 1.21 now failing in Go 1.22, when the slices functions are used incorrectly. This is good news. When you have a bug, tests should let you know.\u003c/p\u003e\n\u003cp\u003eIf you ignore the return value of \u003ccode\u003eDelete\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslices.Delete(s, 2, 3)  // !! INCORRECT !!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen you may incorrectly assume that \u003ccode\u003es\u003c/code\u003e does not contain any nil pointer. \u003ca href=\"/play/p/NDHuO8vINHv\"\u003eExample in the Go Playground\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIf you ignore the return value of \u003ccode\u003eCompact\u003c/code\u003e:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eslices.Sort(s) // correct\nslices.Compact(s) // !! INCORRECT !!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen you may incorrectly assume that \u003ccode\u003es\u003c/code\u003e is properly sorted and compacted. \u003ca href=\"/play/p/eFQIekiwlnu\"\u003eExample\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIf you assign the return value of \u003ccode\u003eDelete\u003c/code\u003e to another variable, and keep using the original slice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eu := slices.Delete(s, 2, 3)  // !! INCORRECT, if you keep using s !!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen you may incorrectly assume that \u003ccode\u003es\u003c/code\u003e does not contain any nil pointer. \u003ca href=\"/play/p/rDxWmJpLOVO\"\u003eExample\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eIf you accidentally shadow the slice variable, and keep using the original slice:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003es := slices.Delete(s, 2, 3)  // !! INCORRECT, using := instead of = !!\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ethen you may incorrectly assume that \u003ccode\u003es\u003c/code\u003e does not contain any nil pointer. \u003ca href=\"/play/p/KSpVpkX8sOi\"\u003eExample\u003c/a\u003e.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eThe API of the \u003ccode\u003eslices\u003c/code\u003e package is a net improvement over the traditional pre-generics syntax to delete or insert elements.\u003c/p\u003e\n\u003cp\u003eWe encourage developers to use the new functions, while avoiding the “gotchas” listed above.\u003c/p\u003e\n\u003cp\u003eThanks to the recent changes in the implementation, a class of memory leaks is automatically avoided, without any change to the API, and with no extra work for the developers.\u003c/p\u003e\n\u003ch2 id=\"further-reading\"\u003eFurther reading\u003c/h2\u003e\n\u003cp\u003eThe signature of the functions in the \u003ccode\u003eslices\u003c/code\u003e package is heavily influenced by the specifics of the representation of slices in memory. We recommend reading\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/blog/slices-intro\"\u003eGo Slices: usage and internals\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/blog/slices\"\u003eArrays, slices: The mechanics of ‘append’\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eThe \u003ca href=\"https://en.wikipedia.org/wiki/Dynamic_array\" rel=\"noreferrer\" target=\"_blank\"\u003edynamic array\u003c/a\u003e data structure\u003c/li\u003e\n\u003cli\u003eThe \u003ca href=\"/pkg/slices\"\u003edocumentation\u003c/a\u003e of the package slices\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe \u003ca href=\"/issue/63393\"\u003eoriginal proposal\u003c/a\u003e about zeroing obsolete elements contains many details and comments.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2024-02-22T00:00:00Z",
  "Author": "Valentin Deleplace"
}