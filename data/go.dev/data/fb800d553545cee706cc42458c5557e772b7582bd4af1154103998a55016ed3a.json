{
  "Source": "go.dev",
  "Title": "Introducing HTTP Tracing",
  "Link": "https://go.dev/blog/http-tracing",
  "Content": "\u003cdiv class=\"Article\" data-slug=\"/blog/http-tracing\"\u003e\n    \n    \u003ch1 class=\"small\"\u003e\u003ca href=\"/blog/\"\u003eThe Go Blog\u003c/a\u003e\u003c/h1\u003e\n    \n\n    \u003ch1\u003eIntroducing HTTP Tracing\u003c/h1\u003e\n      \n      \u003cp class=\"author\"\u003e\n      Jaana Burcu Dogan\u003cbr/\u003e\n      4 October 2016\n      \u003c/p\u003e\n      \n      \u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eIn Go 1.7 we introduced HTTP tracing, a facility to gather fine-grained\ninformation throughout the lifecycle of an HTTP client request.\nSupport for HTTP tracing is provided by the \u003ca href=\"/pkg/net/http/httptrace/\"\u003e\u003ccode\u003enet/http/httptrace\u003c/code\u003e\u003c/a\u003e\npackage. The collected information can be used for debugging latency issues,\nservice monitoring, writing adaptive systems, and more.\u003c/p\u003e\n\u003ch2 id=\"http-events\"\u003eHTTP events\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003ehttptrace\u003c/code\u003e package provides a number of hooks to gather information\nduring an HTTP round trip about a variety of events. These events include:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eConnection creation\u003c/li\u003e\n\u003cli\u003eConnection reuse\u003c/li\u003e\n\u003cli\u003eDNS lookups\u003c/li\u003e\n\u003cli\u003eWriting the request to the wire\u003c/li\u003e\n\u003cli\u003eReading the response\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"tracing-events\"\u003eTracing events\u003c/h2\u003e\n\u003cp\u003eYou can enable HTTP tracing by putting an\n\u003ca href=\"/pkg/net/http/httptrace/#ClientTrace\"\u003e\u003ccode\u003e*httptrace.ClientTrace\u003c/code\u003e\u003c/a\u003e\ncontaining hook functions into a request’s \u003ca href=\"/pkg/context/#Context\"\u003e\u003ccode\u003econtext.Context\u003c/code\u003e\u003c/a\u003e.\nVarious \u003ca href=\"/pkg/net/http/#RoundTripper\"\u003e\u003ccode\u003ehttp.RoundTripper\u003c/code\u003e\u003c/a\u003e\nimplementations report the internal events by\nlooking for context’s \u003ccode\u003e*httptrace.ClientTrace\u003c/code\u003e and calling the relevant hook functions.\u003c/p\u003e\n\u003cp\u003eThe tracing is scoped to the request’s context and users should\nput a \u003ccode\u003e*httptrace.ClientTrace\u003c/code\u003e to the request context before they start a request.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003e    req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;http://example.com\u0026#34;, nil)\n    trace := \u0026amp;httptrace.ClientTrace{\n        DNSDone: func(dnsInfo httptrace.DNSDoneInfo) {\n            fmt.Printf(\u0026#34;DNS Info: %+v\\n\u0026#34;, dnsInfo)\n        },\n        GotConn: func(connInfo httptrace.GotConnInfo) {\n            fmt.Printf(\u0026#34;Got Conn: %+v\\n\u0026#34;, connInfo)\n        },\n    }\n    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))\n    if _, err := http.DefaultTransport.RoundTrip(req); err != nil {\n        log.Fatal(err)\n    }\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eDuring a round trip, \u003ccode\u003ehttp.DefaultTransport\u003c/code\u003e will invoke each hook\nas an event happens. The program above will print the DNS\ninformation as soon as the DNS lookup is complete. It will similarly print\nconnection information when a connection is established to the request’s host.\u003c/p\u003e\n\u003ch2 id=\"tracing-with-httpclient\"\u003eTracing with http.Client\u003c/h2\u003e\n\u003cp\u003eThe tracing mechanism is designed to trace the events in the lifecycle\nof a single \u003ccode\u003ehttp.Transport.RoundTrip\u003c/code\u003e. However, a client may\nmake multiple round trips to complete an HTTP request. For example, in the case\nof a URL redirection, the registered hooks will be called as many times as the\nclient follows HTTP redirects, making multiple requests.\nUsers are responsible for recognizing such events at the \u003ccode\u003ehttp.Client\u003c/code\u003e level.\nThe program below identifies the current request by using an\n\u003ccode\u003ehttp.RoundTripper\u003c/code\u003e wrapper.\u003c/p\u003e\n\u003cdiv class=\"code\"\u003e\n\u003cpre\u003epackage main\n\nimport (\n    \u0026#34;fmt\u0026#34;\n    \u0026#34;log\u0026#34;\n    \u0026#34;net/http\u0026#34;\n    \u0026#34;net/http/httptrace\u0026#34;\n)\n\n\u003cspan class=\"comment\"\u003e// transport is an http.RoundTripper that keeps track of the in-flight\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// request and implements hooks to report HTTP tracing events.\u003c/span\u003e\ntype transport struct {\n    current *http.Request\n}\n\n\u003cspan class=\"comment\"\u003e// RoundTrip wraps http.DefaultTransport.RoundTrip to keep track\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// of the current request.\u003c/span\u003e\nfunc (t *transport) RoundTrip(req *http.Request) (*http.Response, error) {\n    t.current = req\n    return http.DefaultTransport.RoundTrip(req)\n}\n\n\u003cspan class=\"comment\"\u003e// GotConn prints whether the connection has been used previously\u003c/span\u003e\n\u003cspan class=\"comment\"\u003e// for the current request.\u003c/span\u003e\nfunc (t *transport) GotConn(info httptrace.GotConnInfo) {\n    fmt.Printf(\u0026#34;Connection reused for %v? %v\\n\u0026#34;, t.current.URL, info.Reused)\n}\n\nfunc main() {\n    t := \u0026amp;transport{}\n\n    req, _ := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://google.com\u0026#34;, nil)\n    trace := \u0026amp;httptrace.ClientTrace{\n        GotConn: t.GotConn,\n    }\n    req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))\n\n    client := \u0026amp;http.Client{Transport: t}\n    if _, err := client.Do(req); err != nil {\n        log.Fatal(err)\n    }\n}\n\u003c/pre\u003e\n\u003c/div\u003e\n\u003cp\u003eThe program will follow the redirect of google.com to \u003ca href=\"http://www.google.com\" rel=\"noreferrer\" target=\"_blank\"\u003ewww.google.com\u003c/a\u003e and will output:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eConnection reused for https://google.com? false\nConnection reused for https://www.google.com/? false\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eThe Transport in the \u003ccode\u003enet/http\u003c/code\u003e package supports tracing of both HTTP/1\nand HTTP/2 requests.\u003c/p\u003e\n\u003cp\u003eIf you are an author of a custom \u003ccode\u003ehttp.RoundTripper\u003c/code\u003e implementation,\nyou can support tracing by checking the request context for an\n\u003ccode\u003e*httptest.ClientTrace\u003c/code\u003e and invoking the relevant hooks as the events occur.\u003c/p\u003e\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\u003cp\u003eHTTP tracing is a valuable addition to Go for those who are interested\nin debugging HTTP request latency and writing tools for network debugging\nfor outbound traffic.\nBy enabling this new facility, we hope to see HTTP debugging, benchmarking\nand visualization tools from the community — such as\n\u003ca href=\"https://github.com/davecheney/httpstat\" rel=\"noreferrer\" target=\"_blank\"\u003ehttpstat\u003c/a\u003e.\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-10-04T00:00:00Z",
  "Author": "Jaana Burcu Dogan"
}