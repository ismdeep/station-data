{
  "Source": "io-meter",
  "Title": "写个 Icon Font Viewer: 终",
  "Link": "https://io-meter.com/2014/05/04/iconfontr-export-images/",
  "Content": "\u003cdiv class=\"entry\"\u003e\n      \u003cp\u003e终于到了 Icon Fontr 最重要的一部分了。这一次要把已经读入为\u003ccode\u003eNSBezierPath\u003c/code\u003e\n的 Icon 导出成 SVG 和图片，以便于在桌面和移动应用或者 UI 设计软件当中使用。\u003c/p\u003e\n\u003ca id=\"more\"\u003e\u003c/a\u003e\n\u003ch1 id=\"NSBezierPath_To_SVG_Path\"\u003e\u003ca href=\"#NSBezierPath_To_SVG_Path\" class=\"headerlink\" title=\"NSBezierPath To SVG Path\"\u003e\u003c/a\u003eNSBezierPath To SVG Path\u003c/h1\u003e\u003cp\u003e首先是将\u003ccode\u003eNSBezierPath\u003c/code\u003e转换为 SVG 中的 Path 的方法。这一部分实际上是相当容易的。\u003c/p\u003e\n\u003cp\u003e我们先来了解一下 SVG Path 的基础知识，根据 MDN 上的\u003ca href=\"https://developer.mozilla.org/en/docs/Web/SVG/Tutorial/Paths\" target=\"_blank\" rel=\"noopener\"\u003e介绍\u003c/a\u003e\n对于一个\u003ccode\u003e\u0026lt;path\u0026gt;\u0026lt;/path\u0026gt;\u003c/code\u003e标签，由名为\u003ccode\u003ed\u003c/code\u003e的属性来指定了遗传\n一串简写的图形绘制命令。其可用参数可以总结如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eM\u003c/code\u003e: Move To，移动光标到某一位置，接受一组 x y 参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eL\u003c/code\u003e: Line To，从光标位置起始绘制一条直线到目标点，接受一组 x y 参数\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eH\u003c/code\u003e, \u003ccode\u003eV\u003c/code\u003e: \u003ccode\u003eL\u003c/code\u003e 的变形，在水平和竖直方向绘制，只接受一个参数，分别是 x, y \u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eZ\u003c/code\u003e: Close Path，闭合曲线。只有将曲线闭合之后才能对 Path 进行颜色填充\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eC\u003c/code\u003e: Cubic Curve To，绘制三阶 Bezier 曲线，接受三组 x y 参数，分别是两个控制点和一个结束点的位置\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eQ\u003c/code\u003e: Quadratic Curve To，绘制二阶 Bezier 曲线，接受两组 x y 参数，分别是一个控制点和一个结束点的位置\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eA\u003c/code\u003e: Arc To, 绘制圆弧，这个命令的参数比较复杂，这里就不赘述了。在一些绘制 SVG 的实现中使用 A 可以\n绘制出比较完美的圆弧。但是大多绘制 API （包括 Cocoa Drawing）都是使用 Bezier 曲线来拟合圆弧的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e除了以上的绘制命令，SVG 还提供两个用来续接 SVG 曲线的命令，\u003ccode\u003eS\u003c/code\u003e和\u003ccode\u003eT\u003c/code\u003e，分别对应的是\u003ccode\u003eC\u003c/code\u003e和\u003ccode\u003eQ\u003c/code\u003e。\n接受比\u003ccode\u003eC\u003c/code\u003e和\u003ccode\u003eQ\u003c/code\u003e少一组 x y 的参数。这两个命令用于在原来的 SVG 上续接 G2 平滑的曲线\n(在衔接点一阶导数连续)。\u003c/p\u003e\n\u003cp\u003e对于所有这些大写字母组成的命令，其参数都是相对于画布的绝对值。此外还分别有一套与之对应的小写字母组成的命令。\n接受相同数量的参数，区别在于所有参数的意义都是增量值。此外需要注意的是，\n这些命令都省略了第一个控制点。比如说，对于一条三阶 Bezier 曲线，是需要 4 个控制点才能定义出来的，\n而命令\u003ccode\u003eC\u003c/code\u003e只有三组参数，省略的第一个控制点就是画布光标的当前位置(也就是\u003ccode\u003eM\u003c/code\u003e命令指定的点)。\u003c/p\u003e\n\u003cp\u003e一个 SVG 绘制曲线的例子如下：\n\u003c/p\u003e\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; standalone=\u0026#34;no\u0026#34;?\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003esvg\u003c/span\u003e \u003cspan class=\"attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;190px\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eheight\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;160px\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eversion\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;1.1\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003exmlns\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;http://www.w3.org/2000/svg\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003epath\u003c/span\u003e \u003cspan class=\"attr\"\u003ed\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003estroke\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;black\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003efill\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;transparent\u0026#34;\u003c/span\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003esvg\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e直接使用内联 SVG 显示出来就是下面的效果(需支持 SVG 的浏览器支持才能显示)。\u003c/p\u003e\n\u003csvg style=\"border:#eee 1px solid;margin:1em 0;\" width=\"100%\" height=\"160px\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"\u003e\n  \u003cpath d=\"M10 80 C 40 10, 65 10, 95 80 S 150 150, 180 80\" stroke=\"black\" fill=\"transparent\"\u003e\u003c/path\u003e\n\u003c/svg\u003e\n\n\u003cp\u003e接下来回到\u003ccode\u003eNSBezierPath\u003c/code\u003e这边，阅读\n\u003ccode\u003eNSBezierPath\u003c/code\u003e的\u003ca href=\"https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ApplicationKit/Classes/NSBezierPath_Class/Reference/Reference.html#//apple_ref/doc/c_ref/NSBezierPathElement\" target=\"_blank\" rel=\"noopener\"\u003e文档\u003c/a\u003e\n可以发现，其绘制的命令与 SVG 基本上是对应的。\n比如说它包含如下一组函数:\n\u003c/p\u003e\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e– (\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e)moveToPoint:(\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e)point;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e– (\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e)lineToPoint:(\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e)point\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e– (\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e)curveToPoint:(\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e)point controlPoint1:(\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e)point1 controlPoint2:(\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e)point2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e– (\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e)closePath\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e基本上就对应了 SVG 中的\u003ccode\u003eM\u003c/code\u003e、\u003ccode\u003eL\u003c/code\u003e、\u003ccode\u003eC\u003c/code\u003e和\u003ccode\u003eZ\u003c/code\u003e了。因此，只要能够将\u003ccode\u003eNSBezierPath\u003c/code\u003e当中储存的信息，\n按照这种命令方式取出一个序列，我们就可以将其转化为 SVG 的绘制命令了。\u003c/p\u003e\n\u003cp\u003e这当然是一件可以实现的事情咯，我们需要做的就是使用下面两个\u003ccode\u003eNSBezierPath\u003c/code\u003e的对象方法:\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"built_in\"\u003eNSInteger\u003c/span\u003e)elementCount;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"built_in\"\u003eNSBezierPathElement\u003c/span\u003e)elementAtIndex:(\u003cspan class=\"built_in\"\u003eNSInteger\u003c/span\u003e)index associatedPoints:(\u003cspan class=\"built_in\"\u003eNSPointArray\u003c/span\u003e)points\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e其中第一个方法可以得到\u003ccode\u003eNSBezierPath\u003c/code\u003e对象包含的元素个数，而第二个方法提供了取出元素及其相关的控制点的方法。\n\u003ccode\u003eNSBezierPathElement\u003c/code\u003e的定义是：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etypedef\u003c/span\u003e \u003cspan class=\"keyword\"\u003eenum\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   \u003cspan class=\"built_in\"\u003eNSMoveToBezierPathElement\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   \u003cspan class=\"built_in\"\u003eNSLineToBezierPathElement\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   \u003cspan class=\"built_in\"\u003eNSCurveToBezierPathElement\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   \u003cspan class=\"built_in\"\u003eNSClosePathBezierPathElement\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e} \u003cspan class=\"built_in\"\u003eNSBezierPathElement\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e看到这里就应该明白了，\u003ccode\u003eNSBezierPath\u003c/code\u003e包含的元素就是控制的命令，而且这些控制命令是 SVG 的控制命令的子集。\n因此我们能很方便的将元素分别映射到\u003ccode\u003eM\u003c/code\u003e、\u003ccode\u003eL\u003c/code\u003e、\u003ccode\u003eC\u003c/code\u003e和\u003ccode\u003eZ\u003c/code\u003e上。\u003c/p\u003e\n\u003cp\u003e这里需要注意两个地方:\u003c/p\u003e\n\u003cp\u003e其一，\u003ccode\u003eNSPointArray\u003c/code\u003e其实是一个指向\u003ccode\u003eNSPoint\u003c/code\u003e的指针，在\u003ccode\u003eNSBezierPath\u003c/code\u003e里，一个元素的控制点最多有三个。\n因此可以\u003ccode\u003emalloc\u003c/code\u003e三倍\u003ccode\u003eNSPoint\u003c/code\u003e的长度的空间，并将指针传入\u003ccode\u003eassociatedPoints:\u003c/code\u003e中，\n最后的控制点数据将会借由指针传出。\u003c/p\u003e\n\u003cp\u003e其二，SVG 的坐标系统和\u003ccode\u003eNSBezierPath\u003c/code\u003e的坐标系统是不一样的，对于 SVG 来说，原点在左上角，Y 轴朝下。因此需要进行坐标变换。\n关于坐标系统的问题\u003ca href=\"https://io-meter.com/2014/04/24/iconfontr-make-your-nscontrol/\"\u003e上一篇文章\u003c/a\u003e曾经讨论过。\u003c/p\u003e\n\u003cp\u003eOK，有了这些基础知识，将\u003ccode\u003eNSBezierPath\u003c/code\u003e曲线转换为 SVG 也就不在话下了。\n我的实现代码在\u003ca href=\"https://github.com/shanzi/iconfontr/blob/master/iconfontr/NSBezierPath%2BSVGPathString.m#L21\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e。\n其实有了这些知识，将 SVG 转换为\u003ccode\u003eNSBezierPath\u003c/code\u003e也基本足够了。要点就在于要把\u003ccode\u003eNSBezierPath\u003c/code\u003e不支持的一些控制命令，\n如\u003ccode\u003eQ\u003c/code\u003e、\u003ccode\u003eH\u003c/code\u003e等转换为原来的\u003ccode\u003eC\u003c/code\u003e和\u003ccode\u003eL\u003c/code\u003e等。这部分就等以后有机会再详细说明吧。\u003c/p\u003e\n\u003ch1 id=\"NSBezierPath_To_PNG\"\u003e\u003ca href=\"#NSBezierPath_To_PNG\" class=\"headerlink\" title=\"NSBezierPath To PNG\"\u003e\u003c/a\u003eNSBezierPath To PNG\u003c/h1\u003e\u003cp\u003e将\u003ccode\u003eNSBezierPath\u003c/code\u003e转为 PNG 位图输出也很容易，之前在\u003ca href=\"https://io-meter.com/2014/04/12/iconfontr-1/\"\u003e这里\u003c/a\u003e\n里给出了在 View 中绘制图标的代码。得益于\u003ccode\u003eCocoa Drawing\u003c/code\u003e框架的良好设计，我们可以直接复用这些代码来绘制到图片甚至PDF。\n绘制到图片的方法有很多。主要包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先绘制到 View，再从 View 中获得绘制出的位图图像\u003c/li\u003e\n\u003cli\u003e绘制到一个 Off Screen 的 GraphicContext 再从 GraphicContext 中抽出图像，好处是不需要在屏幕中显示出来\u003c/li\u003e\n\u003cli\u003e使用\u003ccode\u003eNSBitmapImageRep\u003c/code\u003e创建一个\u003ccode\u003eNSGraphicContext\u003c/code\u003e，再在这个 Context 上进行绘制。\n和上一种方法的区别是绘制完成后不需要再手动抽取图像。因为图像已经被直接写入对应\u003ccode\u003eNSBitmapImageRep\u003c/code\u003e了\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们使用最后一种方法来绘制，创建一个\u003ccode\u003eNSImageRep\u003c/code\u003e的函数参数比较复杂，如下所示：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSBitmapImageRep\u003c/span\u003e *rep = [[\u003cspan class=\"built_in\"\u003eNSBitmapImageRep\u003c/span\u003e alloc] initWithBitmapDataPlanes:\u003cspan class=\"literal\"\u003eNULL\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                  pixelsWide:width\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                  pixelsHigh:height\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                               bitsPerSample:\u003cspan class=\"number\"\u003e8\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                             samplesPerPixel:\u003cspan class=\"number\"\u003e4\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                    hasAlpha:\u003cspan class=\"literal\"\u003eYES\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                    isPlanar:\u003cspan class=\"literal\"\u003eNO\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                              colorSpaceName:\u003cspan class=\"built_in\"\u003eNSCalibratedRGBColorSpace\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                 bytesPerRow:\u003cspan class=\"number\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                                                bitsPerPixel:\u003cspan class=\"number\"\u003e32\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e接下来详细介绍下这些参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebitmapDataPlanes\u003c/code\u003e：指定图片的色彩通道，这个参数可以理解为事先指定一部分空间用来存储产生的像素数据。\n如果指定为\u003ccode\u003eNULL\u003c/code\u003e，函数会通过其他参数来估计空间以分配内存。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epixelsWide\u003c/code\u003e, \u003ccode\u003epixelsHigh\u003c/code\u003e: 这两个参数指定位图的像素宽和高\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebitsPerSample\u003c/code\u003e: 每个\u003ccode\u003eSample\u003c/code\u003e的位宽，这里的\u003ccode\u003eSample\u003c/code\u003e可以翻译为位图色彩的采样或者分量，对于我们通常用的\u003ccode\u003eRGB\u003c/code\u003e\n色彩空间，红色分量\u003ccode\u003eR\u003c/code\u003e就是一个\u003ccode\u003eSample\u003c/code\u003e。常用的 RGB 颜色值，每个分量的大小最高是\u003ccode\u003e255\u003c/code\u003e，\n这就代表这样一个\u003ccode\u003eSample\u003c/code\u003e是一个 8 bits 的数，因此这里我们把位宽设为 8。 \u003ccode\u003eNSBitmapImageRep\u003c/code\u003e最高支持 16 bits 的位宽\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehasAlpha\u003c/code\u003e: 是否支持透明度\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eisPlanar\u003c/code\u003e: Plane 这个概念和 PhotoShop 中的通道类似。如果这个参数为\u003ccode\u003eYES\u003c/code\u003e，那么色彩值将会分通道储存。\n如果参数为\u003ccode\u003eNO\u003c/code\u003e，那么同一个像素的颜色分量将会紧挨着存储在一起。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecolorSpaceName\u003c/code\u003e: 颜色空间的名称，这里使用的是 RGB 色彩空间，可选的还有 CMYK 色彩空间、灰度色彩空间等。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebytesPerRow\u003c/code\u003e: 一行像素需要的空间，这个值可以依据\u003ccode\u003ebitsPerSample\u003c/code\u003e和\u003ccode\u003epixelsWide\u003c/code\u003e来计算出来，\n但是如果在实际使用中分配的空间不够，那么超出的部分将会被截断。这里我取了零，让程序自己确定。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebitsPerPixel\u003c/code\u003e: 这个参数其实也可以不指定，它指的是一个像素的位宽，我们前面指定了每个颜色分量的位宽是8，\n每个像素有 4 个分量，那么这个值就应该是32\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e总体来说，初始化一个\u003ccode\u003eNSBitmapImageRep\u003c/code\u003e虽然参数很多，但是其中大多是为了保证安全和某些特殊情况而要求指定的。\n大概了解这些参数的含义，在必要的时候指定正确的值即可。\u003c/p\u003e\n\u003cp\u003e创建了\u003ccode\u003eNSBitmapImageRep\u003c/code\u003e对象之后，可以再从这个对象创建一个\u003ccode\u003eNSGraphicContext\u003c/code\u003e，并把后者指定为\u003ccode\u003ecurrentContext\u003c/code\u003e。\n此后就可以像在 View 里一样绘制图形了。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e saveGraphicsState];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e *g = [\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e graphicsContextWithBitmapImageRep:rep];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e setCurrentContext:g];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// drawing code here\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e restoreGraphicsState];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e如何将绘制完成的\u003ccode\u003eNSBitmapImageRep\u003c/code\u003e转换为 PNG 文件的格式呢？只需要调用\u003ccode\u003eRep\u003c/code\u003e对象的入下方法即可。\n这个函数返回的是一个可以直接写入文件的\u003ccode\u003eNSData\u003c/code\u003e类型的对象。\nCocoa 支持的文件格式，除了 PNG 以外，还有 TIFF、JPG 等等。\n\u003c/p\u003e\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[rep representationUsingType:\u003cspan class=\"built_in\"\u003eNSPNGFileType\u003c/span\u003e properties:\u003cspan class=\"literal\"\u003enil\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e至此，图像的输出功能的核心就完成了。\u003c/p\u003e\n\u003ch1 id=\"u81EA_u98DF_u72D7_u7CAE_uFF0C_u4E3A_Icon_Fontr__u8BBE_u8BA1_u4E00_u4E2A_u56FE_u6807\"\u003e\u003ca href=\"#u81EA_u98DF_u72D7_u7CAE_uFF0C_u4E3A_Icon_Fontr__u8BBE_u8BA1_u4E00_u4E2A_u56FE_u6807\" class=\"headerlink\" title=\"自食狗粮，为 Icon Fontr 设计一个图标\"\u003e\u003c/a\u003e自食狗粮，为 Icon Fontr 设计一个图标\u003c/h1\u003e\u003cp\u003e所谓自食狗粮，就是要自己用自己开发的东西来帮助自己开发。具体到这里，\n就是要用 IconFontr 导出来的图标为它自己设计一个图标。我从 \u003ca href=\"http://ionicons.com\" target=\"_blank\" rel=\"noopener\"\u003eionicons\u003c/a\u003e\n中选取了四个图标，稍加处理，最后得到了下面的样子\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/iconfontr/iconfontr256.png\" alt=\"Icon\"/\u003e\u003c/p\u003e\n\u003ch1 id=\"u7ED3_u8BED\"\u003e\u003ca href=\"#u7ED3_u8BED\" class=\"headerlink\" title=\"结语\"\u003e\u003c/a\u003e结语\u003c/h1\u003e\u003cp\u003e至此，一个完整功能的 Icon Viewer 就完成啦。其实 IconFontr 还有很多可以改进的地方，\n比如说可以有一个批量输出 Icon 的功能，下图是我实现出来的样子:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/iconfontr/resolutions.png\" alt=\"Multiple Resolutions\"/\u003e\u003c/p\u003e\n\u003cp\u003e我还提供了几种预设的分辨率，比如 iOS 的 Tabbar 图标的尺寸等等。\n这样就比较方便在 Desktop 和 iOS 应用里使用，也可以用来画原型图等等。\u003c/p\u003e\n\u003cp\u003e有一些文章(\u003ca href=\"https://css-tricks.com/icon-fonts-vs-svg/\" target=\"_blank\" rel=\"noopener\"\u003e1\u003c/a\u003e,\u003ca href=\"http://ianfeather.co.uk/ten-reasons-we-switched-from-an-icon-font-to-svg/\" target=\"_blank\" rel=\"noopener\"\u003e2\u003c/a\u003e\n认为，我们应该尽量使用内联 SVG 而不是 Icon Font 在网页中显示图标。Icon Fontr 也为这种需求提供了方便。\n我为其添加了一个复制 SVG 的功能:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/iconfontr/copysvg.png\" alt=\"Copy SVG\"/\u003e\u003c/p\u003e\n\u003cp\u003e这个系列的文章今天就告一段落了，不过在接下来的时间里，我还会继续维护 Icon Fontr，为其添加各种好用的功能，\n各位看官如果有什么需求，欢迎在 Comment 里告诉我。\n也欢迎点击\u003ca href=\"http://cl.ly/2N3i0U0G402k\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e下载一份目前的测试版本试用，并反馈 Bug。\nIconFontr的代码托管在 Github 上，别忘了来\u003ca href=\"https://github.com/shanzi/iconfontr/\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e Star 一下。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-05-04T07:49:49Z",
  "Author": "Chase Zhang"
}