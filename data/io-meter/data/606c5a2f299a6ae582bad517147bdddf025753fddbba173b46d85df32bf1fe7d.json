{
  "Source": "io-meter",
  "Title": "写个 Icon Font Viewer : 叁",
  "Link": "https://io-meter.com/2014/04/24/iconfontr-make-your-nscontrol/",
  "Content": "\u003cdiv class=\"entry\"\u003e\n      \u003cp\u003e紧接着\u003ca href=\"https://io-meter.com/2014/04/18/seperate-codes-and-zoom-icon/\"\u003e上一篇文章\u003c/a\u003e，\n这次来实战一下自定义 NSControl 实现一个选择颜色组合的功能。\n此外还会更详细的讲解一下 NSView 的绘制方法。\u003c/p\u003e\n\u003ca id=\"more\"\u003e\u003c/a\u003e\n\u003cp\u003e首先新建一个 NSControl 子类吧，这里起名叫\u003ccode\u003eIFColorPicker\u003c/code\u003e，在\u003ccode\u003eIFColorPicker.h\u003c/code\u003e\n里，我们先作如下定义：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eIFColorPicker\u003c/span\u003e : \u003cspan class=\"title\"\u003eNSControl\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@property\u003c/span\u003e(\u003cspan class=\"keyword\"\u003enonatomic\u003c/span\u003e, \u003cspan class=\"keyword\"\u003ereadonly\u003c/span\u003e) \u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *foregroundColor;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@property\u003c/span\u003e(\u003cspan class=\"keyword\"\u003enonatomic\u003c/span\u003e, \u003cspan class=\"keyword\"\u003ereadonly\u003c/span\u003e) \u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *backgroundColor;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@property\u003c/span\u003e(\u003cspan class=\"keyword\"\u003enonatomic\u003c/span\u003e) \u003cspan class=\"built_in\"\u003eNSInteger\u003c/span\u003e pickedIndex;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e注意我们定义了两个只读的属性，\u003ccode\u003eforegroundColor\u003c/code\u003e和\u003ccode\u003ebackgroundColor\u003c/code\u003e，\n当用户在选色器上点击一种颜色组合的时候，在视图里就通过访问这两个属性来获取当前的前景和背景色。\n\u003ccode\u003epickedIndex\u003c/code\u003e则是一个可读可写的属性，允许从外部写入选择的颜色 Index。\u003c/p\u003e\n\u003cp\u003e所谓颜色的 Index，是指我们事先指定了一部分颜色组合，按顺序给分配一个 Index，选色是只能从这些组合里选，\nIndex 其实也是到色彩组合在 Control 中出现顺序。\u003c/p\u003e\n\u003ch2 id=\"u9009_u53D6_u989C_u8272_u7EC4_u5408\"\u003e\u003ca href=\"#u9009_u53D6_u989C_u8272_u7EC4_u5408\" class=\"headerlink\" title=\"选取颜色组合\"\u003e\u003c/a\u003e选取颜色组合\u003c/h2\u003e\u003cp\u003e怎么样能方便的构造这些颜色组合呢？\n对于 NSColor，我们有一些方便的类函数可以快速的构造出想要的颜色。比如\u003ccode\u003e[NSColor blackColor]\u003c/code\u003e\n或\u003ccode\u003e[NSColor controlColor]\u003c/code\u003e等。\u003ccode\u003eNSColor\u003c/code\u003e大概定义了数十个这样的函数，但是在此之外的函数就要通过下面的方法来生成了。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e+ (\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *)colorWithDeviceRed:(\u003cspan class=\"built_in\"\u003eCGFloat\u003c/span\u003e)red green:(\u003cspan class=\"built_in\"\u003eCGFloat\u003c/span\u003e)green blue:(\u003cspan class=\"built_in\"\u003eCGFloat\u003c/span\u003e)blue alpha:(\u003cspan class=\"built_in\"\u003eCGFloat\u003c/span\u003e)alpha;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e的确有一些选色软件(比如我所用的 \u003ca href=\"http://colormaker.cescobaz.com/\" target=\"_blank\" rel=\"noopener\"\u003eColor Maker\u003c/a\u003e)是支持直接生成这个代码，\n但是仍然过于冗长了，而且调出好看的颜色也不容易，还好我们有一些\u003ccode\u003eNSColor\u003c/code\u003e的第三方扩展可以解决这个问题:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/magtory/FPBrandColors\" target=\"_blank\" rel=\"noopener\"\u003eFPBrandColors\u003c/a\u003e 提供了返回各种品牌的主颜色的函数，\n比如导入头文件之后可以用\u003ccode\u003e[NSColor amazon]\u003c/code\u003e调用返回亚马逊的 Logo 的色调。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/CaptainRedmuff/NSColor-Crayola\" target=\"_blank\" rel=\"noopener\"\u003eNSColor-Crayola\u003c/a\u003e\n和 \u003ca href=\"https://github.com/CaptainRedmuff/NSColor-Pantone\" target=\"_blank\" rel=\"noopener\"\u003eNSColor-Pantone\u003c/a\u003e\n是两套色彩集合，使用和上面基本一致，都是为\u003ccode\u003eNSColor\u003c/code\u003e添加了诸多类函数用来方便构造颜色。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里我们从 \u003ca href=\"https://github.com/CaptainRedmuff/NSColor-Crayola\" target=\"_blank\" rel=\"noopener\"\u003eNSColor-Crayola\u003c/a\u003e 来选择几种好看的颜色作为背景色。\n在\u003ccode\u003eIFColorPicker.m\u003c/code\u003e里添加下面的函数。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *)backgroundColorAtIndex:(\u003cspan class=\"built_in\"\u003eNSInteger\u003c/span\u003e)index\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eswitch\u003c/span\u003e (index) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaCeruleanColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e2\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaAquamarineColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e3\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaBananaColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e4\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaBittersweetColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e5\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaBurntOrangeColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e6\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaFernColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e7\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaInchwormColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e8\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e crayolaRedColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003edefault\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e whiteColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e对于前景色，只选择黑白两种，因此函数如下所示：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *)foregroundColorAtIndex:(\u003cspan class=\"built_in\"\u003eNSInteger\u003c/span\u003e)index\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eswitch\u003c/span\u003e (index) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ecase\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e blackColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003edefault\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e whiteColor];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003ch2 id=\"u7ED8_u5236_u63A7_u4EF6\"\u003e\u003ca href=\"#u7ED8_u5236_u63A7_u4EF6\" class=\"headerlink\" title=\"绘制控件\"\u003e\u003c/a\u003e绘制控件\u003c/h2\u003e\u003cp\u003e这里更详细的介绍一下在 Cocoa 中的图形绘制技术。首先我们知道\u003ccode\u003eNSControl\u003c/code\u003e其实是\u003ccode\u003eNSView\u003c/code\u003e\n的子类，所以绘制\u003ccode\u003eNSControl\u003c/code\u003e本质上就是绘制\u003ccode\u003eNSView\u003c/code\u003e。要自定义\u003ccode\u003eNSControl\u003c/code\u003e的绘制操作，需要重载\u003ccode\u003edrawRect:(NSRect)dirtyRect\u003c/code\u003e\n方法，这里的\u003ccode\u003edirtyRect\u003c/code\u003e不一定是 View 的 Frame，而是系统认为需要重绘的区域。\n应该避免完全在这个区域外的绘制工作以提高性能。\u003c/p\u003e\n\u003cp\u003e绘制所用的 API 其实有两套，一套是 Objective-C 风格的 Cocoa API，一套是 C 风格的 CoreGraphic API。\n通常来说，后者的性能更高一点，更底层点。在\u003ccode\u003edrawRect:\u003c/code\u003e中两种 API 都可以使用。\n此外\u003ccode\u003eNSView\u003c/code\u003e还有另外一种基于\u003ccode\u003eCALayer\u003c/code\u003e的绘制模式，这种绘制模式是基于\u003ccode\u003eCore Animation\u003c/code\u003e的。\n使用 Layer 进行绘制可以充分利用 \u003ccode\u003eCore Animation\u003c/code\u003e 和 \u003ccode\u003eQuatz\u003c/code\u003e \n封装好的\u003ccode\u003eOpenGL\u003c/code\u003e的性能，特别适合包含动画或模糊等特殊效果或需要频繁重绘的 View。\u003c/p\u003e\n\u003cp\u003e想要使一个 View 使用\u003ccode\u003eCALayer\u003c/code\u003e绘制需要先执行\u003ccode\u003e[view setWantsLayer:YES]\u003c/code\u003e，之后重载下面的函数。\n可以看出，这个函数传入了一个\u003ccode\u003eCGContextRef\u003c/code\u003e指针，绘制就需要针对这个\u003ccode\u003eCGContextRef\u003c/code\u003e执行，\n这同时也意味着绘制\u003ccode\u003eCALayer\u003c/code\u003e只能使用 C 风格的 CoreGraphic API。重载这个函数后，\u003ccode\u003edrawRect:\u003c/code\u003e就不会再被调用了。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e)drawLayer:(\u003cspan class=\"built_in\"\u003eCALayer\u003c/span\u003e *)layer inContext:(\u003cspan class=\"built_in\"\u003eCGContextRef\u003c/span\u003e)ctx;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e因为我们设计的控件并不需要频繁的重绘，也不包含动画，因此采取较为简单的 Cocoa API 来完成。\n\u003ccode\u003eCoreGraphic\u003c/code\u003e风格的 API 以后有机会再谈。\u003c/p\u003e\n\u003ch3 id=\"Drawing_Context\"\u003e\u003ca href=\"#Drawing_Context\" class=\"headerlink\" title=\"Drawing Context\"\u003e\u003c/a\u003eDrawing Context\u003c/h3\u003e\u003cp\u003e在使用 Cocoa API 进行绘图时，我们要明确一个概念：绘图实际上一定是针对于一个 Context 进行的，\n在 Cocoa API 中是\u003ccode\u003eNSGraphicContext\u003c/code\u003e，CoreGraphic API 中是\u003ccode\u003eCGContextRef\u003c/code\u003e。\n本质上来说，Cocoa API 是对 CoreGraphic 的封装(这也是它稍慢的原因)，但是在使用 Cocoa API \n的时候，我们一般不需要获取到这个 Context 对象的指针，原因是 Cocoa 会为我们设定好当前的上下文信息。\u003c/p\u003e\n\u003cp\u003e具体来讲，在每次绘制时会有一个全局的变量指代当前的图形 Context，可以使用\u003ccode\u003e[NSGraphicContext currentContext]\u003c/code\u003e\n函数获取到这个对象。这个对象由 Cocoa 自动指定，开发者不需要了解它具体是什么对象(它有可能来自屏幕上可显示的 View，\n也有可能是一份 PDF 文档或者位图图像等等)。于此同时，Cocoa API 的各个部分也会使用这个 Context 进行各种操作。\n比如对于\u003ccode\u003eNSColor\u003c/code\u003e来说，下面的代码就把当前 Context 的填充颜色设定为黑色：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e *black = [\u003cspan class=\"built_in\"\u003eNSColor\u003c/span\u003e black];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[black setFill];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e\u003ccode\u003eNSBezierPath\u003c/code\u003e的绘制操作，也是自动应用于当前的 Context 的。譬如，在上面的代码执行后，\n执行下面的代码就会填充出一个黑色的矩形：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSBezierPath\u003c/span\u003e *box = [\u003cspan class=\"built_in\"\u003eNSBezierPath\u003c/span\u003e bezierPathWithRect:\u003cspan class=\"built_in\"\u003eNSMakeRect\u003c/span\u003e(\u003cspan class=\"number\"\u003e0\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, \u003cspan class=\"number\"\u003e100\u003c/span\u003e, \u003cspan class=\"number\"\u003e200\u003c/span\u003e)];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[box fill];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e这种实现方式看起来比较优雅，但是同时也存在一个问题，那就是绘制必须运行在程序的主线程(主 RunLoop)上，\n因为在多线程的状态下这个全局的 Context 可能在执行过程中被改变，从而导致绘制混乱。\n在辅助线程中进行绘制是可能的，但是必须非常小心，而且不适合使用 Cocoa API。\u003c/p\u003e\n\u003ch3 id=\"Axis_and_Transform\"\u003e\u003ca href=\"#Axis_and_Transform\" class=\"headerlink\" title=\"Axis and Transform\"\u003e\u003c/a\u003eAxis and Transform\u003c/h3\u003e\u003cp\u003e接下来需要注意的绘制图形的坐标系统。如果有 Windows 或者 Qt 等图形库的使用经验，\n可能知道对于他们来说，窗口和视图的坐标系统是以左上角为原点，Y 轴的指向朝下。\nCocoa 与之不同，他的坐标系是和一般的几何坐标系一致的：原点在左下角，Y 轴正向朝上(其实 Cocoa\n的坐标系统也存在 API 不统一的问题，比如在 iOS 开发中 UIKit 的坐标就是是原点左上\n还好 OSX 在最新的 API 下已经统一为左下了)。\u003c/p\u003e\n\u003cp\u003e我们之前提到过，在绘制的时候存在一个全局的 currentContext。同样，使用\u003ccode\u003eNSAffineTransform\u003c/code\u003e\n进行坐标变换的时候也是针对这个 currentContext 进行的。需要注意的是，\u003ccode\u003eNSAffineTransform\u003c/code\u003e \n的坐标变换操作需要通过调用\u003ccode\u003econcat\u003c/code\u003e方法才会作用于 Context，而且这种作用是累加的。\n且看下面的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSAffineTransform\u003c/span\u003e *transform = [\u003cspan class=\"built_in\"\u003eNSAffineTransform\u003c/span\u003e transform];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[transform translateXBy: \u003cspan class=\"number\"\u003e10.0\u003c/span\u003e YBy: \u003cspan class=\"number\"\u003e0.0\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[transform concat] \u003cspan class=\"comment\"\u003e// the first time\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[transform concat] \u003cspan class=\"comment\"\u003e// the second time\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e上文中，Context 的坐标系被向右移动了两次，每次 10.0 个单位，所以最后坐标系被移动了 20.0 个单位。\n另外需要注意的是，在移动坐标系的时候原来已经被绘制在 Context 上的图形并不会被影响。，\u003c/p\u003e\n\u003cp\u003e如果在绘制中需要使用坐标系变换，为了保险起见应该在变换之前保存 Context 的变换矩阵状态，\n在绘制完之后再恢复。如下面的示例代码所示：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e saveGraphicsState];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// transforming and drawing code\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"built_in\"\u003eNSGraphicsContext\u003c/span\u003e restoreGraphicsState];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e了解完以上的知识，绘制 UIControl 就不成问题了。在我的实现中，只生成了一个 BezierPath 对象，\n然后通过不断的 Transform 和改变 Context 的当前填充颜色来绘制出多个选色点出来。具体的代码见\n\u003ca href=\"https://github.com/shanzi/iconfontr/blob/master/iconfontr/IFColorPicker.m#L44\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"u9F20_u6807_u70B9_u51FB_u7684_u5904_u7406\"\u003e\u003ca href=\"#u9F20_u6807_u70B9_u51FB_u7684_u5904_u7406\" class=\"headerlink\" title=\"鼠标点击的处理\"\u003e\u003c/a\u003e鼠标点击的处理\u003c/h2\u003e\u003cp\u003e接下来要处理鼠标点击，这里的需求是鼠标左键应用前景和背景色、右键点击互换前景色和背景色。\u003c/p\u003e\n\u003cp\u003e之前的文章已经提到过，处理鼠标点击可以重载\u003ccode\u003emouseUp:\u003c/code\u003e和\u003ccode\u003erightMouseUp:\u003c/code\u003e函数。\n接下来还有一项重要的任务就是确定用户点击的到底是哪个颜色组合。\u003c/p\u003e\n\u003cp\u003e简单来说，就是要通过用户点击的位置来计算用户选择的 Index。计算 Index 并不复杂，\n因为在绘制的时候我们实际上是计算过一次选色点所在的位置，按照相同的原理计算一下偏移位置就可以了。\n这里要强调的是鼠标点击位置的获取。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emouseUp:\u003c/code\u003e和\u003ccode\u003erightMouseUp:\u003c/code\u003e方法都有一个\u003ccode\u003eNSEvent\u003c/code\u003e类型的参数，对于鼠标事件来讲，\n我们可以通过下面的函数获得鼠标相对于所在 View 的坐标。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e locationInWindow = theEvent.locationInWindow;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSPoint\u003c/span\u003e locationInView = [theView convertPoint:locationInWindow fromView:\u003cspan class=\"literal\"\u003enil\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e\u003ccode\u003elocationInWindow\u003c/code\u003e属性顾名思义，就是鼠标点击在窗口中的位置，\n可以用用\u003ccode\u003eNSView\u003c/code\u003e的\u003ccode\u003econvertPoint: fromView:\u003c/code\u003e方法把它坐标变换自己的坐标空间中，\n\u003ccode\u003eNSView\u003c/code\u003e其实有一系列类似的方法，不但可以变换点的坐标，还可以变换矩形。\n同时也存在\u003ccode\u003efromView:\u003c/code\u003e和\u003ccode\u003etoView:\u003c/code\u003e两套方法。这两套方法中，如果 From 或 To\n的 View 是 nil 的话，计算的是相对 Window 的变换。\u003c/p\u003e\n\u003cp\u003e坐标变换之后就可以计算出用户点击的是哪种颜色组合了。\u003c/p\u003e\n\u003ch2 id=\"u53D1_u9001_Action\"\u003e\u003ca href=\"#u53D1_u9001_Action\" class=\"headerlink\" title=\"发送 Action\"\u003e\u003c/a\u003e发送 Action\u003c/h2\u003e\u003cp\u003e一个好的 NSControl 还要能够发送事件，最好还能够用 Interface Builder 来绑定事件。\n发送一个事件的调用是：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// IFColorPicker.m\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[\u003cspan class=\"keyword\"\u003eself\u003c/span\u003e sendAction:\u003cspan class=\"keyword\"\u003eself\u003c/span\u003e.action to:\u003cspan class=\"keyword\"\u003eself\u003c/span\u003e.target];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e\u003ccode\u003eself.action\u003c/code\u003e和\u003ccode\u003eself.target\u003c/code\u003e都是\u003ccode\u003eNSControl\u003c/code\u003e定义的属性，IB 在绑定 Action 的时候也会设定这些值。\n而我们可以用\u003ccode\u003eIBAction\u003c/code\u003e定义一个可以在 IB 里连接的回调接口，在\u003ccode\u003eIFDocumentWindowController.h\u003c/code\u003e\n中加入下面的定义\n(函数实现见\u003ca href=\"https://github.com/shanzi/iconfontr/blob/master/iconfontr/IFDocumentWindowController.m#L53\" target=\"_blank\" rel=\"noopener\"\u003e这里\u003c/a\u003e)：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e- (\u003cspan class=\"keyword\"\u003eIBAction\u003c/span\u003e)changeColor:(\u003cspan class=\"keyword\"\u003eid\u003c/span\u003e)sender;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e这时在 Interface Builder 中绑定好后运行，却会发现并没有起到效果。\n其实是因为\u003ccode\u003eNSControl\u003c/code\u003e默认认为自己内部有一个\u003ccode\u003eNSActionCell\u003c/code\u003e的，它的\u003ccode\u003eaction\u003c/code\u003e以及\u003ccode\u003etarget\u003c/code\u003e\n属性也是映射到自己的\u003ccode\u003eNSActionCell\u003c/code\u003e上的。这里我们并没有添加\u003ccode\u003eNSActionCell\u003c/code\u003e\n因此这两个属性将总是\u003ccode\u003enil\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e我们的控件没有必要定义自己的 ActionCell，为了能让代码正常工作，只好复写这两个属性，\n自己定义两个变量来保存他们。\u003c/p\u003e\n\u003ch2 id=\"u603B_u7ED3\"\u003e\u003ca href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h2\u003e\u003cp\u003eOK，我们的 ColorPicker 控件就这么写好了，修改下图标绘制的代码我们就可以改变图标的预览颜色了。\n鼠标左键和右键效果就如下所示，还是蛮不错的吧。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/iconfontr/leftmouse-lightgreen.png\" alt=\"Left Mouse, Light Green\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/iconfontr/rightmouse-darkgreen.png\" alt=\"Right Mouse, Dark Green\"/\u003e\u003c/p\u003e\n\u003cp\u003e下一篇文章，就来到我们整个项目的最重点了，我们要实现 Icon 导出图片和 SVG 的功能，\n最后还要“自食狗粮”，用自己导出的素材为 IconFontr 制作一个图标，可不要错过哦。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-04-24T10:48:48Z",
  "Author": "Chase Zhang"
}