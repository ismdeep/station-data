{
  "Source": "io-meter",
  "Title": "Go 语言的包依赖管理",
  "Link": "https://io-meter.com/2014/07/30/go's-package-management/",
  "Content": "\u003cdiv class=\"entry\"\u003e\n      \u003cp\u003e对于从 Ruby、Python 或者 Node 等编程语言转向 Go 语言的开发者，可能会有一个疑问：\nGo 语言中的包依赖关系是怎么管理的？有没有什么方便使用的工具呢？\n我最近研究了一下这个问题，以下是我的研究报告。\u003c/p\u003e\n\u003ca id=\"more\"\u003e\u003c/a\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/go-package.jpg\" alt=\"(图片来源：nathany.com)\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"Go__u8BED_u8A00_u672C_u8EAB_u63D0_u4F9B_u7684_u5305_u7BA1_u7406_u673A_u5236\"\u003e\u003ca href=\"#Go__u8BED_u8A00_u672C_u8EAB_u63D0_u4F9B_u7684_u5305_u7BA1_u7406_u673A_u5236\" class=\"headerlink\" title=\"Go 语言本身提供的包管理机制\"\u003e\u003c/a\u003eGo 语言本身提供的包管理机制\u003c/h2\u003e\u003cp\u003e在 Go 语言中，我们可以使用\u003ccode\u003ego get\u003c/code\u003e命令安装远程仓库中托管的代码，不同于 Ruby Gem、pypi 等集中式的包管理机制，\nGo 语言的包管理系统是去中心化的。简单来讲，\u003ccode\u003ego get\u003c/code\u003e命令支持任何一个位置托管的 Git 或 Mercurial\n的仓库，无论是 Github 还是 Google Code 上的包，都可以通过这个命令安装。\u003c/p\u003e\n\u003cp\u003e我们知道，在 Go 语言中的\u003ccode\u003eimport\u003c/code\u003e语句对于已经使用\u003ccode\u003ego get\u003c/code\u003e安装到本地的包，依然要使用其去绝对路径引入。\n比如对于从 Github 上安装的 \u003ca href=\"https://goji.io/\" target=\"_blank\" rel=\"noopener\"\u003egoji\u003c/a\u003e，其在 Github 上的路径 URL 是\n\u003ccode\u003ehttps://github.com/zenazn/goji\u003c/code\u003e，因此在\u003ccode\u003eimport\u003c/code\u003e它的时候需要使用下面的代码：\n\u003c/p\u003e\u003cfigure class=\"highlight go\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;github.com/zenazn/goji\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e正因为如此，Go 语言可以通过直接分析代码中的\u003ccode\u003eimport\u003c/code\u003e语句来查询依赖关系。\n\u003ccode\u003ego get\u003c/code\u003e命令在执行时，就会自动解析\u003ccode\u003eimport\u003c/code\u003e来安装所有的依赖。\u003c/p\u003e\n\u003cp\u003e除了\u003ccode\u003ego get\u003c/code\u003e，Go 语言还提供了一个 Workspace 的机制，这个机制也是很容易让人困惑的设计。简单来说就是通过设定\n\u003ccode\u003eGOPATH\u003c/code\u003e环境变量，指定除了\u003ccode\u003eGOROOT\u003c/code\u003e所指定的目录之外，Go 代码所在的位置(也就是 Workspace 的位置)。\n一般来说，\u003ccode\u003eGOPATH\u003c/code\u003e目录下会包含\u003ccode\u003epkg\u003c/code\u003e、\u003ccode\u003esrc\u003c/code\u003e和\u003ccode\u003ebin\u003c/code\u003e三个子目录，这三个目录各有用处。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebin\u003c/code\u003e 目录用来放置编译好的可执行文件，为了使得这里的可执行文件可以方便的运行，\n在 shell 中设置\u003ccode\u003ePATH\u003c/code\u003e变量。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003esrc\u003c/code\u003e 目录用来放置代码源文件，在进行\u003ccode\u003eimport\u003c/code\u003e时，是使用这个位置作为根目录的。自己编写的代码也应该放在这下面。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epkg\u003c/code\u003e 用来放置安装的包的链接对象(Object)的。这个概念有点类似于链接库，Go 会将编译出的可连接库放在这里，\n方便编译时链接。不同的系统和处理器架构的对象会在\u003ccode\u003epkg\u003c/code\u003e存放在不同的文件夹中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我的\u003ccode\u003eGOPATH\u003c/code\u003e目录树如下所示：\n\u003c/p\u003e\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e├── bin\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e├── pkg\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e│   └── darwin_amd64\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e│       └── github.com\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e│           └── zenazn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e│               └── goji\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e└── src\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ├── code.google.com\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    │   └── p\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    │       └── go.crypto\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    └── github.com\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        └── zenazn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            └── goji\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e一般来说，你自己的代码不应该直接放置在\u003ccode\u003esrc\u003c/code\u003e目录下，而应该为其建立对应的项目文件夹。\n\u003ccode\u003ego get\u003c/code\u003e也会把第三方包的源代码放到这个目录下，因此一般推荐设置两个\u003ccode\u003eGOPATH\u003c/code\u003e，比如：\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eexport\u003c/span\u003e GOPATH=\u003cspan class=\"string\"\u003e\u0026#34;/usr/local/share/go:\u003cspan class=\"variable\"\u003e$HOME\u003c/span\u003e/codes/go\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e这样第三方包就会默认放置在第一个路径中，而你可以在第二个路径下编写自己的代码。\n虽然 Go 语言本身已经提供了相当强大的包管理方式了，但是仍然有一些不足：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e不能很方便地隔离不同项目的环境\u003c/li\u003e\n\u003cli\u003e不能很方便地控制某个依赖包的版本\u003c/li\u003e\n\u003cli\u003e不能管理 Go 本身的版本\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e因此我们还需要一些第三方的工具来弥补这些缺陷。\u003c/p\u003e\n\u003ch2 id=\"u7B2C_u4E09_u65B9_u7684_u7BA1_u7406_u5DE5_u5177\"\u003e\u003ca href=\"#u7B2C_u4E09_u65B9_u7684_u7BA1_u7406_u5DE5_u5177\" class=\"headerlink\" title=\"第三方的管理工具\"\u003e\u003c/a\u003e第三方的管理工具\u003c/h2\u003e\u003ch3 id=\"GOPATH__u7BA1_u7406_u548C_u5305_u7BA1_u7406\"\u003e\u003ca href=\"#GOPATH__u7BA1_u7406_u548C_u5305_u7BA1_u7406\" class=\"headerlink\" title=\"GOPATH 管理和包管理\"\u003e\u003c/a\u003eGOPATH 管理和包管理\u003c/h3\u003e\u003cp\u003e由于存在\u003ccode\u003eGOPATH\u003c/code\u003e的机制，我们可以使用多个\u003ccode\u003eGOPATH\u003c/code\u003e来实现项目隔离的方法。\n譬如，对于每个项目，都分配一个不同的路径作为\u003ccode\u003eGOPATH\u003c/code\u003e。\n可以实现这样的目的的工具有\u003ca href=\"https://github.com/pote/gvp\" target=\"_blank\" rel=\"noopener\"\u003egvp\u003c/a\u003e等。\u003c/p\u003e\n\u003cp\u003e对于 gvp 来说，想要针对当前目录建立一个\u003ccode\u003eGOPATH\u003c/code\u003e，只需要执行\u003ccode\u003egvp init\u003c/code\u003e即可。\ngvp 会在当前项目的目录下新建一个隐藏的文件夹作为\u003ccode\u003eGOPATH\u003c/code\u003e指向的位置。\n切换环境时使用下面两个命令来修改环境变量。这种做法跟 Python\n中的\u003ca href=\"https://pypi.python.org/pypi/virtualenv\" target=\"_blank\" rel=\"noopener\"\u003evirtualenv\u003c/a\u003e比较类似。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003esource\u003c/span\u003e gvp \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e   \u003cspan class=\"comment\"\u003e# 进入当前目录对应的 GOPATH 环境\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003esource\u003c/span\u003e gvp out  \u003cspan class=\"comment\"\u003e# 登出当前目录对应的 GOPATH 环境\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e至于对依赖包更版本更细致的管理，可以配合的工具还有 \u003ca href=\"https://github.com/pote/gpm\" target=\"_blank\" rel=\"noopener\"\u003egpm\u003c/a\u003e。\n\u003ccode\u003egpm\u003c/code\u003e有点类似于 Python 中的\u003ca href=\"http://pip.readthedocs.org/en/latest/\" target=\"_blank\" rel=\"noopener\"\u003epip\u003c/a\u003e工具。他可以生成一个名为 \u003ccode\u003eGodeps\u003c/code\u003e 的文件，\n其中记录了每个依赖包的 URL 以及使用的版本(hash tag)。\n之前的\u003ca href=\"http://dev.af83.com/2013/09/14/a-journey-in-golang-package-manager.html\" target=\"_blank\" rel=\"noopener\"\u003e一篇文章\u003c/a\u003e提到\n\u003ccode\u003egpm\u003c/code\u003e只能管理来自 Github 的依赖，不过当前的版本已经支持了非 Git 方式托管的依赖包了。\u003c/p\u003e\n\u003cp\u003e基于同样原理管理依赖包版本的工具还有\u003ca href=\"https://github.com/tools/godep\" target=\"_blank\" rel=\"noopener\"\u003eGodep\u003c/a\u003e。\n这个工具在 Github 上具有相当高的关注度。它所生成的\u003ccode\u003eGodeps\u003c/code\u003e文件采用 JSON 格式储存，\n是一个跟 Node.js 中 \u003ca href=\"https://www.npmjs.org://www.npmjs.org/\" target=\"_blank\" rel=\"noopener\"\u003eNPM\u003c/a\u003e 相仿的工具。\u003c/p\u003e\n\u003cp\u003e总体来说以上几个工具已经可以解决隔离项目环境和控制依赖包版本的问题了。但是使用上还不算方便，\n为了能在我们 cd 到某个目录时自动的切换环境变量，我们可能还需要在 shell\n做一些配置使其在\u003ccode\u003ecd\u003c/code\u003e到项目目录下时自动切换环境变量。\u003c/p\u003e\n\u003cp\u003e这方面做的比较好的一个选择是 \u003ca href=\"https://github.com/mattn/gom\" target=\"_blank\" rel=\"noopener\"\u003eGo Manager(gom)\u003c/a\u003e，\n它生成的\u003ccode\u003eGomfile\u003c/code\u003e格式上几乎跟 Ruby Gem 一样。gom 可能是这些工具当中使用最方便的一个，\n只要使用\u003ccode\u003egom build\u003c/code\u003e命令代替原来的\u003ccode\u003ego build\u003c/code\u003e命令进行编译，你基本不需要配置 Shell 或者和环境变量打交道。\u003c/p\u003e\n\u003ch3 id=\"Go__u8BED_u8A00_u7248_u672C_u7BA1_u7406\"\u003e\u003ca href=\"#Go__u8BED_u8A00_u7248_u672C_u7BA1_u7406\" class=\"headerlink\" title=\"Go 语言版本管理\"\u003e\u003c/a\u003eGo 语言版本管理\u003c/h3\u003e\u003cp\u003e对于 Go 语言，一般来说并没有使多个语言版本并存的需求。Go 语言现在还没有经历过类似 Python 2.x 到 3.x\n或者 Ruby 1.x 到 2.x 这样破坏性的版本升级。旧的代码在新的语言版本当中一般是能够正确运行的。\n不过若遇到非要并存多个版本的时候，\u003ca href=\"https://github.com/moovweb/gvm\" target=\"_blank\" rel=\"noopener\"\u003egvm\u003c/a\u003e就是一个不错的选择。\u003c/p\u003e\n\u003cp\u003egvm 的使用跟 \u003ca href=\"https://rvm.io/\" target=\"_blank\" rel=\"noopener\"\u003ervm\u003c/a\u003e 比较类似。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003egvm install go1 \u003cspan class=\"comment\"\u003e# 安装 go1 版本\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003egvm use go1     \u003cspan class=\"comment\"\u003e# 修改环境变量使用 go1 版本的 Go\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003ch2 id=\"u603B_u7ED3\"\u003e\u003ca href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h2\u003e\u003cp\u003e是否有必要使用多个 Workspace 仍然具有争议，譬如这个 StackOverflow\n上的\u003ca href=\"http://stackoverflow.com/questions/20722502/whats-a-good-best-practice-with-go-workspaces\" target=\"_blank\" rel=\"noopener\"\u003e相关问答\u003c/a\u003e中，\n就有人提出只使用一个 Workspace 就可以应付大多数情况了。\u003c/p\u003e\n\u003cp\u003e在研究相关问题的时候，我发现很多 Go 语言的用户都还带着原来编程语言的思维，\n这点从上面介绍的多个工具的特点当中就可以很容易看出来：\u003ccode\u003egvp\u003c/code\u003e和\u003ccode\u003egpm\u003c/code\u003e就是典型的 Python 的包管理模式，\n\u003ccode\u003egvp\u003c/code\u003e对应着\u003ccode\u003evirtualenv\u003c/code\u003e，\u003ccode\u003egpm\u003c/code\u003e对应着\u003ccode\u003epip\u003c/code\u003e；如果你之前是 Node.js 和 NPM 的用户，\n那么\u003ccode\u003eGoDeps\u003c/code\u003e肯定会让你有种熟悉的感觉；更不用说最后介绍的\u003ccode\u003egom\u003c/code\u003e了，它从名称到文件格式都在模仿 Ruby Gem。\u003c/p\u003e\n\u003cp\u003e不同编程背景的开发者来到 Go 语言之后各自带来了自己的依赖包管理方式，而且形成了各自的社区。\n这种现象虽然使得各自圈子的开发者免去了选择恐惧症，但是造成的解决方案分裂和互不兼容的情况也需要正视。\n这时我们不禁要问，Go 自己的解决方式应该是什么样的？Go 语言为何没有一个官方标准的解决方案呢？\u003c/p\u003e\n\u003cp\u003e从\u003ca href=\"https://golang.org/doc/faq#get_version\" target=\"_blank\" rel=\"noopener\"\u003eGo FAQ\u003c/a\u003e的一段文字当中我们可以得到部分答案：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eVersioning is a source of significant complexity, especially in large code bases, \nand we are unaware of any approach that works well at scale in a large enough variety\nof situations to be appropriate to force on all Go users.\n(依赖包的版本管理是一个非常复杂的问题，特别是在代码量比较大的时候。\n我们一直没有找到任何一种方式能够在各种情形下都能良好工作，\n因此也没有一种方式足够好到应该强迫所有的 Go 用户使用它)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e因此现阶段来看，对于 Go 语言的包管理解决方案，我们也就只能“仁者见仁，智者见智”了。\u003c/p\u003e\n\u003cp\u003e最后，对于想要了解 Go 语言的包管理以及更多可用的工具的读者，这里再推荐两篇相关的文章：\n\u003ca href=\"http://nathany.com/go-packages/\" target=\"_blank\" rel=\"noopener\"\u003eGo Package Management\u003c/a\u003e 和\n\u003ca href=\"http://dev.af83.com/2013/09/14/a-journey-in-golang-package-manager.html\" target=\"_blank\" rel=\"noopener\"\u003eA Journey in Golang Package Manager\u003c/a\u003e\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-07-30T08:11:44Z",
  "Author": "Chase Zhang"
}