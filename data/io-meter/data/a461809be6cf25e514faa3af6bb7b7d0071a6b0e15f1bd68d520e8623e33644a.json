{
  "Source": "io-meter",
  "Title": "Develop for Yosemite: 几个小技巧",
  "Link": "https://io-meter.com/2014/10/24/develop-for-yosemite-some-tips/",
  "Content": "\u003cdiv class=\"entry\"\u003e\n      \u003cp\u003eApple 终于发布了 Xcode 6.1，带来了 Swift for OSX 等多个更新，\n这几天我简单研究了下在 Yosemite 下实现一些新的小需求的方法，\n这里使用 Swift 语言描述总结一下。\u003c/p\u003e\n\u003ca id=\"more\"\u003e\u003c/a\u003e\n\u003ch1 id=\"Unified_Toolbar\"\u003e\u003ca href=\"#Unified_Toolbar\" class=\"headerlink\" title=\"Unified Toolbar\"\u003e\u003c/a\u003eUnified Toolbar\u003c/h1\u003e\u003cp\u003e在 Yosemite 中，包括 Safari、系统偏好设置等多个应用都采取了 Unified Toolbar\n设计。Toolbar 和左上角控制窗口关闭、最小化和全屏的三个按钮在同一行。如下所示\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/unified-toolbar.png\" alt=\"Unified Toolbar\"/\u003e\u003c/p\u003e\n\u003cp\u003e实现这样的功能很简单，只要把 Window 的 Title 隐藏掉就好了。在 Window 对应的 WindowController\n中复写\u003ccode\u003ewindowDidLoad\u003c/code\u003e函数，将\u003ccode\u003etitleVisibility\u003c/code\u003e设置为\u003ccode\u003e.Hidden\u003c/code\u003e即可。\n\u003c/p\u003e\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eoverride func windowDidLoad() {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  super.windowDidLoad()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  self.window?.titleVisibility = .Hidden // NSWindowTitleHidden in ObjC\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003ch1 id=\"Translucent_View\"\u003e\u003ca href=\"#Translucent_View\" class=\"headerlink\" title=\"Translucent View\"\u003e\u003c/a\u003eTranslucent View\u003c/h1\u003e\u003cp\u003eYosemite 视觉设计上的一大特点就是引入了大量模糊透明的效果，\n特别是工具栏、菜单和侧边栏的模糊效果非常明显。这些模糊效果都是\u003ccode\u003eNSVisualEffectView\u003c/code\u003e提供的。\n这里演示一下将整个窗口的 ContentView 都加上透明效果的方法。\u003c/p\u003e\n\u003cp\u003e首先在 Interface Builder 中选中窗口的 ContentView，并将其 Class 类型设置为 \u003ccode\u003eNSVisualEffectView\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/content-view-class.png\" alt=\"ContentView Class\"/\u003e\u003c/p\u003e\n\u003cp\u003e此后，为此 View 添加一个 ViewController，并在其\u003ccode\u003eviewDidLoad\u003c/code\u003e函数中，设置view的\u003ccode\u003eblendingMode\u003c/code\u003e属性。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eoverride func viewDidLoad() {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  super.viewDidLoad()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  if let view = self.view as? NSVisualEffectView {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      // Make view translucent\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      view.blendingMode = .BehindWindow\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e得到的效果如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/translucent-view.png\" alt=\"Translucent View\"/\u003e\u003c/p\u003e\n\u003cp\u003e这里的\u003ccode\u003eblendingMode\u003c/code\u003e有两种选择。\u003ccode\u003e.BehindWindow\u003c/code\u003e是将窗口后面的内容模糊显示，\n此外还有一个\u003ccode\u003e.WithinWindow\u003c/code\u003e选项，用来实现同一窗口不同View下，类似于Toolbar那样的模糊效果。\u003c/p\u003e\n\u003ch1 id=\"u68C0_u67E5_Dark_Mode\"\u003e\u003ca href=\"#u68C0_u67E5_Dark_Mode\" class=\"headerlink\" title=\"检查 Dark Mode\"\u003e\u003c/a\u003e检查 Dark Mode\u003c/h1\u003e\u003cp\u003eYosemite 新增的 Dark Mode 是我的最爱，检查 Dark Mode 的状态也有很多应用。\n一个最直接的应用就是在右上角显示的状态栏图标，需要使这些图标能根据黑白模式的不同而改变配色。\u003c/p\u003e\n\u003cp\u003e直接获得系统 Dark Mode 属性的方法我们稍后介绍，这里先介绍一下 Yosemite 为解决图标颜色问题给出的官方解决方案。\u003c/p\u003e\n\u003cp\u003eYosemite 推荐的方法是使用\u003ccode\u003eNSImage\u003c/code\u003e新增的\u003ccode\u003esetTemplate\u003c/code\u003e方法。简单来说，\u003ccode\u003esetTemplate\u003c/code\u003e\n就是将其代表透明度的\u003ccode\u003ealpha\u003c/code\u003e通道拿出来作为其形状，这样系统就可以自动地根据黑白的 Mode 来将其填充为黑色或者白色。\u003c/p\u003e\n\u003cp\u003e为了演示这一特性，我实现选择了两个图片作为图标。因为 Template 下需要用到图片的透明度，因此 PNG 格式是很好的选择。\n如下图所示，这两个图标分别用在状态栏的图标选中和未选中的模式中。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/statusitem-icons.png\" alt=\"StatusItem Icons\"/\u003e\u003c/p\u003e\n\u003cp\u003e我在主窗口的\u003ccode\u003eWindowController\u003c/code\u003e下使用下面的代码来设置 StatusItem，注意其中两行\u003ccode\u003eNSImage\u003c/code\u003e对象\u003ccode\u003esetTemplate\u003c/code\u003e方法的调用。\n\u003c/p\u003e\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eclass AppWindowController: NSWindowController {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  var statusItem: NSStatusItem!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  var statusItemMenu: NSMenu!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  override func windowDidLoad() {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItemMenu = NSMenu()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItemMenu.addItemWithTitle(\u0026#34;Testing Menu\u0026#34;, action: nil, keyEquivalent: \u0026#34;\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    let statusBar = NSStatusBar.systemStatusBar()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    self.statusItem = statusBar.statusItemWithLength(statusBar.thickness)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItem.image = NSImage(named: \u0026#34;light-bubble\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItem.alternateImage = NSImage(named: \u0026#34;dark-bubble\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItem.image?.setTemplate(true) // set image to template\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItem.alternateImage?.setTemplate(true) // set image to template\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    statusItem.menu = statusItemMenu\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\u003cp\u003e\u003c/p\u003e\n\u003cp\u003e最后，在 Dark Mode 下看到的图标效果为：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/darkmode-images.png\" alt=\"Dark Mode Icons\"/\u003e\u003c/p\u003e\n\u003cp\u003e值得注意的是，在 Dark 模式下被标记为\u003ccode\u003eTemplate\u003c/code\u003e的图标，其本身的颜色会被忽略，但是在普通模式下，其颜色还是会生效，\n因此对于\u003ccode\u003eStatusItem\u003c/code\u003e的\u003ccode\u003ealternateImage\u003c/code\u003e，直接使用白色图标是一个很好的选择(这样在普通模式下显示为蓝底白图标)。\u003c/p\u003e\n\u003cp\u003e上面给出了一般地使用\u003ccode\u003eNSImage\u003c/code\u003e的\u003ccode\u003esetTemplate\u003c/code\u003e函数让系统自动为图标改变颜色的方法。\n但是有些时候我们仍不得不切实地检查系统是不是真的在 Dark Mode 下。比如说\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e你的 StatusItem 是使用 View 显示，而非直接使用图片\u003c/li\u003e\n\u003cli\u003e你希望根据系统是否在 Dark Mode，而调整你整个 App 的 UI 色调\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这时就必须使用一些侧面的方法来实现了。目前提出来的比较有效的方法是直接读取系统偏好设置。写成函数如下\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efunc isDarkMode() -\u0026gt; Bool {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  let systemUserDefaults:Dictionary = NSUserDefaults.standardUserDefaults().persistentDomainForName(NSGlobalDomain)!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  let style:AnyObject? = systemUserDefaults[\u0026#34;AppleInterfaceStyle\u0026#34;]?\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  if let styleString = style as? String {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return styleString.lowercaseString == \u0026#34;dark\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return false\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e监听 Dark Mode 的改变，则通过监听\u003ccode\u003eAppleInterfaceThemeChangedNotification\u003c/code\u003e这个系统 Notification 来实现。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eNSDistributedNotificationCenter.defaultCenter().addObserver(\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      self, selector: \u0026#34;darkModeChanged:\u0026#34;, name: \u0026#34;AppleInterfaceThemeChangedNotification\u0026#34;, object: nil)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e需要注意的是，这些方法对于运行在沙盒中的 OSX 应用可能不可用。\u003c/p\u003e\n\u003ch1 id=\"Storyboard\"\u003e\u003ca href=\"#Storyboard\" class=\"headerlink\" title=\"Storyboard\"\u003e\u003c/a\u003eStoryboard\u003c/h1\u003e\u003cp\u003e在 Xcode 6.1 中新增的一个大特性就是为 OSX 应用开发提供了 Storyboard 支持。\u003c/p\u003e\n\u003cp\u003eiOS 开发者对 Storyboard 应该很熟悉了，那么 OSX 的 Storyboard 的使用起来如何呢？\n首先就是 TabView 使用起来比原来方便多了，而弹出 Sheet 和 Popover 也可以直接在 Interface Builder\n中完成，不需要再写一些冗余的代码。\u003c/p\u003e\n\u003cp\u003e这里稍微介绍一下在 Storyboard 里弹出 Popover 的方法，其基本思路和 iOS 上很相似。\u003c/p\u003e\n\u003cp\u003e如下图，首先在主 View 中添加一个 Pushup Button 和一个新的 ViewController (右边)。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/add-button-and-view.png\" alt=\"Add Button and View\"/\u003e\u003c/p\u003e\n\u003cp\u003e然后将 Button 的 Action 拖到新的 View 上，并选择 Popover 连接起来。如图\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/binding-popover.png\" alt=\"Binding Popover\"/\u003e\u003c/p\u003e\n\u003cp\u003eOK，Popover 就完成了，效果如下图。这种方法可以说比原来方便很多。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/popover.png\" alt=\"Popover\"/\u003e\u003c/p\u003e\n\u003cp\u003e此时从我们的主 View 会有一条线连接到我们 Popover 的 View 上，\n这个就是新生成的 Segue，选中它还可以进一步设置 Popover 的效果，也可以选择其他的弹出方式。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/img/posts/segue-osx.png\" alt=\"Segue\"/\u003e\u003c/p\u003e\n\u003ch1 id=\"u603B_u7ED3\"\u003e\u003ca href=\"#u603B_u7ED3\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h1\u003e\u003cp\u003eOK，这几天使用 Swift 编写 OSX 应用时探索出来东西大概就是这么多了。\u003c/p\u003e\n\u003cp\u003e作为一个曾经的 Objective-C 非专业写者，我算是满心欢喜地投入了 Swift 的怀抱，\n而同时 Apple 在这次 Yosemite 当中为 OSX 提供的新特性也没有让人失望。\u003c/p\u003e\n\u003cp\u003e当然 Xcode 6 和 Yosemite 提供的新玩意还有很多，也还要继续慢慢挖掘才好！\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2014-10-24T07:02:02Z",
  "Author": "Chase Zhang"
}