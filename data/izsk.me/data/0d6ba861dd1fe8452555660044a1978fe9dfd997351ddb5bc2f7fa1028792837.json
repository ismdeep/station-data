{
  "Source": "izsk.me",
  "Title": "mysql学习(redo,undo)",
  "Link": "https://izsk.me/2017/11/30/mysql%E5%AD%A6%E4%B9%A0%E4%B8%89(redo,undo)/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003eredo跟undo是很多数据库都支持的特性,不同的数据库redo跟undo可能有点细节上的不同,整个方向几乎都起着同样的效果.\u003c/p\u003e\n\u003cp\u003eundo: 撤销,也就是取消之前的操作.\u003c/p\u003e\n\u003cp\u003eredo: 重做,重新执行一遍之前的操作.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e这里主要以mysql常用的且支持事务特性的innodb存储引擎为例,myisam不在这之列.\u003c/p\u003e\n\u003ch3 id=\"redo\"\u003e\u003ca href=\"#redo\" class=\"headerlink\" title=\"redo\"\u003e\u003c/a\u003e\u003cstrong\u003eredo\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eredo,从字面上来理解,就是\u003cstrong\u003e重新执行一次之前做的操作,我们一般叫做前滚(rollforward)\u003c/strong\u003e,是一种事务日志(transaction logs),可分为online和archived,以\u003cstrong\u003e恢复\u003c/strong\u003e为目的,保证事务的\u003cstrong\u003e持久性\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eRedo Log记录的是\u003cstrong\u003e新数据\u003c/strong\u003e的备份.在事务提交前,只要将Redo Log持久化即可,不需要将数据持久化(当然这需要根据配置而定具体什么时候数据文件持久化).当系统崩溃时,虽然数据没有持久化,但是Redo Log已经持久化.系统可以根据Redo Log的内容,将所有数据恢复到最新的状态.\u003c/p\u003e\n\u003cp\u003e一般的,redo log 都是会以日志组的形式出现,以顺序的方式写入文件文件,这就是 online redo log(在线重做日志),写满时则回溯到第一个文件,在进行覆盖写之前,有些数据库如Oracle则会把之前的redo log文件打包到特定目录下存档,这种文件就叫做archived redo log(归档重做日志).\u003c/p\u003e\n\u003cp\u003eredo log 其实由两部分组成,:\u003cstrong\u003eredo log buffer 跟redo log file\u003c/strong\u003e.redo log buffer 跟redo log file.buffer pool中把数据修改情况记录到redo log buffer,出现以下情况,再把redo log刷下到redo log file:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eRedo log buffer空间不足\u003c/li\u003e\n\u003cli\u003e事务提交（依赖innodb_flush_log_at_trx_commit参数设置）\u003c/li\u003e\n\u003cli\u003e后台线程\u003c/li\u003e\n\u003cli\u003e做checkpoint\u003c/li\u003e\n\u003cli\u003e实例shutdown\u003c/li\u003e\n\u003cli\u003ebinlog切换\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这里有个重要的参数需要解释一下\u003c/p\u003e\n\u003ch4 id=\"innodb-flush-log-at-trx-commit\"\u003e\u003ca href=\"#innodb-flush-log-at-trx-commit\" class=\"headerlink\" title=\"innodb_flush_log_at_trx_commit\"\u003e\u003c/a\u003e\u003cstrong\u003einnodb_flush_log_at_trx_commit\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e官方的解释请看\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit\"\u003e这里\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003einnodb_flush_log_at_trx_commit=1,每次事务提交时,log buffer 会被写入到日志文件并刷写到磁盘.这也是默认值.这是最安全的配置,但由于每次事务都需要进行磁盘I/O,所以也最慢.\u003c/li\u003e\n\u003cli\u003einnodb_flush_log_at_trx_commit=2,每次事务提交会写入日志文件,但并不会立即刷写到磁盘,日志文件会每秒刷写一次到磁盘.这时如果 mysqld 进程崩溃,由于日志已经写入到系统缓存,所以并不会丢失数据；在操作系统崩溃的情况下,通常会导致最后 1s 的日志丢失\u003c/li\u003e\n\u003cli\u003einnodb_flush_log_at_trx_commit=0,log buffer 会 每秒写入到日志文件并刷写（flush）到磁盘.但每次事务提交不会有任何影响,也就是 log buffer 的刷写操作和事务提交操作没有关系.在这种情况下,MySQL性能最好,但如果 mysqld 进程崩溃,通常会导致最后 1s 的日志丢失.\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e注意:由于进程调度策略问题,这个“每秒执行一次 flush(刷到磁盘)操作”并不是保证100%的“每秒”.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_flush_log_at_trx_commit\"\u003e官网\u003c/a\u003e上还有这么一句话:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eInnoDB log flushing frequency is controlled by innodb_flush_log_at_timeout, which allows you to set log flushing frequency to N seconds (where N is 1 ... 2700, with a default value of 1). However, any mysqld process crash can erase up to N seconds of transactions\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003einnodb log 的从buffer刷新到log的频率还受\u003ccode\u003einnodb_flush_log_at_timeout\u003c/code\u003e这个参数的控制,这个参数允许你设置1-2700秒中的任何一个秒数,但是当mysql宕机的时候,会损失这N秒内的数据\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eDDL changes and other internal InnoDB activities flush the InnoDB log independent of the innodb_flush_log_at_trx_commit setting.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于DDL的改变和一些innodb内部的一些刷新机制不依赖于\u003ccode\u003einnodb_flush_log_at_trx_commit \u003c/code\u003e参数\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eInnoDB crash recovery works regardless of the innodb_flush_log_at_trx_commit setting. Transactions are either applied entirely or erased entirely.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003einnodb的宕机恢复不受\u003ccode\u003einnodb_flush_log_at_trx_commit\u003c/code\u003e参数影响,事务要么全部应用要么全部擦除.\u003c/p\u003e\n\u003cp\u003e借用网上\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.cnblogs.com/xinysu/p/6555082.html\"\u003e一张图\u003c/a\u003e来解释这个日志流向过程:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"http://zskgithubblog.oss-cn-beijing.aliyuncs.com/blogpic/mysqlredoundo.png\" alt=\"mysqlredoundo\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"redo恢复\"\u003e\u003ca href=\"#redo恢复\" class=\"headerlink\" title=\"redo恢复\"\u003e\u003c/a\u003e\u003cstrong\u003eredo恢复\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e从上面我们知道的redo 日志的数据流向, 那么redo是如何恢复数据的呢?\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在设置innodb_flush_log_at_trx_commit=1的情况下,如果只在redo log buffer中写入了日志,还没来的及写到redo log file中,此时mysql数据库宕机,再启动mysql时 redo log buffer内的记录肯定都不复存在,没有关系,也无需恢复,就相当于该事务还没发生一样,因为数据库的datafile并没有改变.\u003c/li\u003e\n\u003cli\u003e在设置innodb_flush_log_at_trx_commit=1的情况下,如果日志已经写进了redo log file中(或者说从redo log file中刷数据到datafile刷到一半),此时mysql数据库宕机,再启动mysql时,mysql会自动的把redo log file中的记录执行一次到宕机的失败点,这样就能保证事务完整执行,这就是所谓的\u003cstrong\u003e前滚\u003c/strong\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"undo\"\u003e\u003ca href=\"#undo\" class=\"headerlink\" title=\"undo\"\u003e\u003c/a\u003e\u003cstrong\u003eundo\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eundo,从字面上来理解就是\u003cstrong\u003e撤销这次操作,我们一般叫做回滚(rollback)\u003c/strong\u003e,它也是一种事务日志(transaction logs).它主要是保证事务的\u003cstrong\u003e原子性\u003c/strong\u003e及提供\u003cstrong\u003e读一致性\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eUndo Log的原理很简单,为了满足事务的原子性,在操作任何数据之前,首先将数据备份到一个地方(这个存储数据备份的地方称为Undo Log).然后进行数据的修改.如果出现了错误或者用户执行了\u003cstrong\u003eROLLBACK\u003c/strong\u003e语句,系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态.\u003c/p\u003e\n\u003ch4 id=\"回滚\"\u003e\u003ca href=\"#回滚\" class=\"headerlink\" title=\"回滚\"\u003e\u003c/a\u003e\u003cstrong\u003e回滚\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e这个就不用说了,就是撤销到事务开始之前的状态.\u003c/p\u003e\n\u003ch4 id=\"MVCC\"\u003e\u003ca href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"\u003e\u003c/a\u003e\u003cstrong\u003eMVCC\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003emvcc(Multiversion Concurrency Control,多版本并发控制),mvcc+undo一同为mysql提供\u003cstrong\u003e一致性非锁定读\u003c/strong\u003e的机制,提供更高的并发.\u003c/p\u003e\n\u003cp\u003e我们知道MySQL中的InnoDB存储引擎的默认隔离级别REPEATABLE READ(RR), 行级锁(在不能确定范围的情况下使用表级锁),当有一个事务正在更新某些数据时(写操作),同时另一个事务还能读取这些数据(读操作),确切的说是历史数据据,这就是mvcc与undo的作用,这里涉及到mysql的隔离级别,先不在这篇讨论,会另起一篇.\u003c/p\u003e\n\u003ch3 id=\"redo-undo\"\u003e\u003ca href=\"#redo-undo\" class=\"headerlink\" title=\"redo+undo\"\u003e\u003c/a\u003e\u003cstrong\u003eredo+undo\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e假设有A、B两个数据,值分别为1,2,开始一个事务,事务的操作内容为:把1修改为3,2修改为4,那么实际的记录如下(简化):\u003c/p\u003e\n\u003cfigure class=\"highlight shell\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eA.事务开始.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eB.记录A=1到undo log.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eC.修改A=3.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eD.记录A=3到redo log.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eE.记录B=2到undo log.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eF.修改B=4.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eG.记录B=4到redo log.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eH.将redo log写入磁盘.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eI.事务提交\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eUndo + Redo的设计主要考虑的是提升IO性能,增大数据库吞吐量.可以看出,B D E G H,均是新增操作,但是B D E G 是缓冲到buffer区,\u003cstrong\u003e只有H是真正的增加了IO操作\u003c/strong\u003e,为了保证Redo Log能够有比较好的IO性能,InnoDB 的 Redo Log的设计有以下几个特点:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eA.尽量保持Redo Log存储在一段连续的空间上.因此在系统第一次启动时就会将日志文件的空间完全分配. 以顺序追加的方式记录Redo Log,通过顺序IO来改善性能.\u003c/li\u003e\n\u003cli\u003eB. 批量写入日志.日志并不是直接写入文件,而是先写入redo log buffer.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.\u003c/li\u003e\n\u003cli\u003eC. 并发的事务共享Redo Log的存储空间,它们的Redo Log按语句的执行顺序,依次交替的记录在一起,\u003c/li\u003e\n\u003cli\u003eD. 因为C的原因,当一个事务将Redo Log写入磁盘时,也会将其他未提交的事务的日志写入磁盘.\u003c/li\u003e\n\u003cli\u003eE. Redo Log上只进行顺序追加的操作,当一个事务需要回滚时,它的Redo Log记录也不会从Redo Log中删除掉,对于 回滚事务先执行redo,再从undo中回滚.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cfigure class=\"highlight shell\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e以减少日志占用的空间.例如,Redo Log中的记录内容可能是这样的：\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e记录1: \u0026lt;trx1, insert …\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e记录2: \u0026lt;trx2, update …\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e记录3: \u0026lt;trx1, delete …\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e记录4: \u0026lt;trx3, update …\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e记录5: \u0026lt;trx2, insert …\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e  一次提交IO,会将其它日志一同提交,这样便提高了IO性能.\u003c/p\u003e\n\u003ch3 id=\"恢复\"\u003e\u003ca href=\"#恢复\" class=\"headerlink\" title=\"恢复\"\u003e\u003c/a\u003e\u003cstrong\u003e恢复\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e有2种不同的恢复策略:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eA.进行恢复时,只重做已经提交了的事务.\u003c/li\u003e\n\u003cli\u003eB.进行恢复时,重做所有事务包括未提交的事务和回滚了的事务.然后通过Undo Log回滚那些\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e在重做Redo Log时,并不关心事务性. 恢复时,没有BEGIN,也没有COMMIT,ROLLBACK的行为.也不关心每个日志是哪个事务的.尽管事务ID等事务相关的内容会记入Redo Log,这些内容只是被当作要操作的数据的一部分\u003c/li\u003e\n\u003cli\u003e使用B策略就必须要将Undo Log持久化,而且必须要在写Redo Log之前将对应的Undo Log写入磁盘.Undo和Redo Log的这种关联,使得持久化变得复杂起来.为了降低复杂度,InnoDB将Undo Log看作数据,因此记录Undo Log的操作也会记录到redo log中.这样undo log就可以象数据一样缓存起来,而不用在redo log之前写入磁盘了\u003c/li\u003e\n\u003cli\u003eInnodb也会将事务回滚时的操作记录到redo log中.回滚操作本质上也是对数据进行修改,因此回滚时对数据的操作也会记录到Redo Log中\u003c/li\u003e\n\u003cli\u003e一个被回滚了的事务在恢复时的操作就是先redo再undo,因此不会破坏数据的一致性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e简言之就是:mysql恢复时会执行所有的redo(包含了回滚的事务), 对于那些被回滚的事务再应用undo操作.\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"总结\"\u003e\u003ca href=\"#总结\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e\u003cstrong\u003e总结\u003c/strong\u003e\u003c/h3\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eUNDO\u003c/th\u003e\n\u003cth\u003eREDO\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eRecord of\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eHow to undo a change\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eHow to reproduce a change\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eUsed for\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eRollback, Read-Consistency\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eRolling forward DB Changes\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eStored in\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eUndo segments\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eRedo log files\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003cstrong\u003eProtect Against\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eInconsistent reads in multiuser systems\u003c/strong\u003e\u003c/td\u003e\n\u003ctd\u003e\u003cstrong\u003eData loss\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.cnblogs.com/xinysu/p/6555082.html\"\u003e说说MySQL中的Redo log Undo log都在干啥\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://oraclenz.wordpress.com/2008/06/22/differences-between-undo-and-redo/\"\u003eDifferences between UNDO and REDO\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\u003chr/\u003e\n\n      \n    \u003c/div\u003e",
  "Date": "2017-11-30T20:50:53+08:00",
  "Author": "Z.S.K."
}