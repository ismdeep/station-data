{
  "Source": "izsk.me",
  "Title": "合并K个有序数组(python)",
  "Link": "https://izsk.me/2019/03/02/%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84(python)/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e题目是: 给定K个有序数组,将它们合并成一个数组并且有序, 需要考虑时间复杂度.\u003c/p\u003e\n\u003cp\u003e这也是leetcode上的第23道题,由合并两个数组延生而来. \u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch3 id=\"K个数组合并\"\u003e\u003ca href=\"#K个数组合并\" class=\"headerlink\" title=\"K个数组合并\"\u003e\u003c/a\u003e\u003cstrong\u003eK个数组合并\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e这里做个假设, 有序数组的个数为 L\u003c/p\u003e\n\u003cp\u003e所有数组中, 最长数组的长度为 N, 每个数组中的元素个数可以不等\u003c/p\u003e\n\u003cp\u003e很正常的会想到写二层for循环相邻两两进行合并,但时间复杂度肯定过不去\u003c/p\u003e\n\u003cp\u003e可以使用最小堆, python中很少情况会想到使用堆, 开始还以为python中没有, 顺便研究了下\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.python.org/3/library/heapq.html\"\u003eheap\u003c/a\u003e,具体思路为: \u003c/p\u003e\n\u003cblockquote\u003e\n\u003col\u003e\n\u003cli\u003e维护一个最小堆, 堆的个数等于链表个数, 为L\u003c/li\u003e\n\u003cli\u003e维护一个新链表,为D\u003c/li\u003e\n\u003cli\u003e初始化堆中的元素为每个链表的第一个元素\u003c/li\u003e\n\u003cli\u003e由最小堆的特性,堆的最顶层元素为最小值,每次取该最小值并记录该最小值所在有序链表的索引\u003c/li\u003e\n\u003cli\u003e将该最小值添加到D中\u003c/li\u003e\n\u003cli\u003e再把该最小值所在的链表的下一个元素入堆(如果存在的话)\u003c/li\u003e\n\u003cli\u003e循环4-6直到所有元素都已添加到D中\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg src=\"http://zskgithubblog.oss-cn-beijing.aliyuncs.com/blogpic/merge_list_python.jpg\" alt=\"merge_list_python\"/\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e heapq\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efrom\u003c/span\u003e collections \u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e deque\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003elist_merge\u003c/span\u003e(\u003cspan class=\"params\"\u003e*lists\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e#入参判断, 这里直接pass\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e#将所有链表转化为deque,方便使用popleft获取链表的最左元素及根据索引返回该索引对应的剩余链表\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    queues = [queue \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e queue \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"built_in\"\u003emap\u003c/span\u003e(deque, lists)]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    heap = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e#初始化链表,该链表中的元素为元组, 各个链表的第一个元素及链表所在索引\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e i, lst \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"built_in\"\u003eenumerate\u003c/span\u003e(queues):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        heap.append((lst.popleft(), i))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e#将链表转换成最小堆\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    heapq.heapify(heap)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e#链表: 用于存放每次获取的堆顶层元素\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    result = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e heap:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e#将堆顶层元素出堆\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        value, index = heapq.heappop(heap)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e#将顶层元素追加\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        result.append(value)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"comment\"\u003e#根据索引获取对应链表的剩余元素\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e queues[index]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e             \u003cspan class=\"comment\"\u003e#如果存在下一个元素,则将该元素及索引入堆\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            heapq.heappush(heap, (queues[index].popleft(), index))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e result\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eprint\u003c/span\u003e list_merge(*[[\u003cspan class=\"number\"\u003e4\u003c/span\u003e, \u003cspan class=\"number\"\u003e8\u003c/span\u003e, \u003cspan class=\"number\"\u003e20\u003c/span\u003e], [\u003cspan class=\"number\"\u003e100\u003c/span\u003e, \u003cspan class=\"number\"\u003e200\u003c/span\u003e, \u003cspan class=\"number\"\u003e350\u003c/span\u003e, \u003cspan class=\"number\"\u003e370\u003c/span\u003e], [\u003cspan class=\"number\"\u003e5\u003c/span\u003e, \u003cspan class=\"number\"\u003e8\u003c/span\u003e, \u003cspan class=\"number\"\u003e350\u003c/span\u003e, \u003cspan class=\"number\"\u003e500\u003c/span\u003e, \u003cspan class=\"number\"\u003e1000\u003c/span\u003e]])\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e通过索引来获取对应数组的下一个元素, 使用的非常巧妙\u003c/p\u003e\n\u003cp\u003e这里主要使用到了heapq跟deque,大家可以到官网查看这两个的用法\u003c/p\u003e\n\u003ch3 id=\"复杂度分析\"\u003e\u003ca href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"\u003e\u003c/a\u003e\u003cstrong\u003e复杂度分析\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e时间复杂度: 由于每个元素都需要读取一次, 即最大次数为L*N, 将每一个元素插入最小堆中的复杂度为O(logL),即总的复杂度为O(L*NlogL)\u003c/li\u003e\n\u003cli\u003e空间复杂度为: 维护最小堆的大小,即 O(L)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"在实际中的运用\"\u003e\u003ca href=\"#在实际中的运用\" class=\"headerlink\" title=\"在实际中的运用\"\u003e\u003c/a\u003e\u003cstrong\u003e在实际中的运用\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e在分布式任务聚合后需要按照时间顺序统一排序的场景下会有这个需要,linux下也有一些实现,可参照\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/dog250/article/details/80234049\"\u003e这篇文章\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.python.org/3/library/heapq.html\"\u003ehttps://docs.python.org/3/library/heapq.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.python.org/3/library/collections.html#deque-objects\"\u003ehttps://docs.python.org/3/library/collections.html#deque-objects\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://leetcode.com/problems/merge-k-sorted-lists/solution/\"\u003ehttps://leetcode.com/problems/merge-k-sorted-lists/solution/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/dog250/article/details/80234049\"\u003e合并N个有序链表与FQ公平调度\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\u003chr/\u003e\n\n      \n    \u003c/div\u003e",
  "Date": "2019-03-02T17:30:51+08:00",
  "Author": "Z.S.K."
}