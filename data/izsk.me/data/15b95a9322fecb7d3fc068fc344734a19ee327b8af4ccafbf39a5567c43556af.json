{
  "Source": "izsk.me",
  "Title": "Kubernetes学习(什么, 宿主机根目录被容器coredump打爆了?)",
  "Link": "https://izsk.me/2023/07/29/Kubernetes-OutofDisk-CoreDump/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e最近在生产Kubernetes集群容器中的进程频繁地出现coredump从而导致宿主机的根目录被打到100%, 在排查的过程中发现一些技术盲区, 记录一下\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\u003ch3 id=\"问题现象\"\u003e\u003ca href=\"#问题现象\" class=\"headerlink\" title=\"问题现象\"\u003e\u003c/a\u003e问题现象\u003c/h3\u003e\u003cp\u003e某晚突然收到磁盘告警, 提示某台机器的/路径被占用100%(所有机器的根目录都是统一规格不算大),打开监控大图发现这台机器的根目录出现很有频率地打到100%降下后又100%的趋势.\u003cbr/\u003e由于计算集群将docker及kubelet的volume都配置到独立的disk上，因此除了根被打满的告警外，没有收到其它的报警, \u003cstrong\u003e即不会引影响上面已有容器的正常运行\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"问题排查\"\u003e\u003ca href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"\u003e\u003c/a\u003e问题排查\u003c/h3\u003e\u003cp\u003e由于计算节点只有集群管理员才能登录, 因此不存在是哪个开发同学直接在上面操作引起的，那么排查思路如下:\u003c/p\u003e\n\u003ch4 id=\"df-x2F-du\"\u003e\u003ca href=\"#df-x2F-du\" class=\"headerlink\" title=\"df/du\"\u003e\u003c/a\u003edf/du\u003c/h4\u003e\u003cp\u003e根被打满，第一反应得查一下是不是在根目录下生成了大文件，du没发现问题,\u003cstrong\u003e监控数据不会骗人\u003c/strong\u003e, 多次执行df之后发现确认会到100%, 但是du又没找到是哪个大文件, 那么就可能是时间上很短，du没有抓到\u003c/p\u003e\n\u003ch4 id=\"dmesg\"\u003e\u003ca href=\"#dmesg\" class=\"headerlink\" title=\"dmesg\"\u003e\u003c/a\u003edmesg\u003c/h4\u003e\u003cp\u003e使用\u003ccode\u003eDmesg -T|less\u003c/code\u003e 相关内核日志，发现有很多如下错误:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ekernel: Pid 38693(python) over core_pipe_limit\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel: Skipping core dump\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel: systemd-coredump[11718]: Core file was truncated to 2147483648 bytes.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e显然，这跟一个Pid 为38693的python进程有关, 同时出现了coredump,dmesg里多次出现，那肯定不正常\u003c/p\u003e\n\u003ch4 id=\"coredump\"\u003e\u003ca href=\"#coredump\" class=\"headerlink\" title=\"coredump\"\u003e\u003c/a\u003ecoredump\u003c/h4\u003e\u003cp\u003e关于coredump在这里不展开描述，只提一下它的作用:\u003c/p\u003e\n\u003cp\u003e当程序发生内存越界访问等行为时，会触发OS的保护机制，此时OS会产生一个信号(signal)发送给对应的进程。当进程从内核态到用户态切换时，该进程会处理这个信号。此类信号（比如SEGV）的默认处理行为生成一个coredump文件\u003cbr/\u003e由于coredump会占用大量磁盘资源，所以计算节点应该都默认关闭了coredump功能, 通过以下命令确认:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eulimit\u003c/span\u003e -c\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# ulimit -c unlimited 不限制\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# ulimit -c 1024      限制大小为1024\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# ulimit -c 0         限制大小为0，即不输出core dump文件\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e返回的是0, 说明coredump确认是关闭的,那奇怪为何会出现coredump呢? \u003cstrong\u003e内核日志同样不会骗人\u003c/strong\u003e, 从日志本身入手,\u003cbr/\u003e从日志中可以看到是个python进程，有pid,那么就可以查到是属于哪个容器的了，由于宿主机上跑的容器很多，所以更快的方法是: 使用coredumpctl命令查看发生coredump的进程信息,返回如下:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# coredumpctl info\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ePID: 38693 (python)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eUID: xxxx (xxxx)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eGID: xxxx (xxxx)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eSignal: 11 (SEGV)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTimestamp: Wed 2023-07-28 19:58:05 CST\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCommand Line: python xxx\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eExecutable: python \u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eControl Group: /kubepods.slice/...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 省略...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e信息非常详细, 很容易拿到是哪个容器触发的coredump，\u003cstrong\u003e由于都发生了coredump, 大概率这个python程序已经跑跪了\u003c/strong\u003e，为了更快的地验证是不是这个容器导致宿主机根被打满，让相应的用户先将容器stop掉，发现宿主机的根目录果然降下来了且稳定在低水位。\u003c/p\u003e\n\u003ch3 id=\"问题延伸\"\u003e\u003ca href=\"#问题延伸\" class=\"headerlink\" title=\"问题延伸\"\u003e\u003c/a\u003e问题延伸\u003c/h3\u003e\u003cp\u003e虽然快速地”解决了问题”,但产生了几个疑问:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e为什么宿主机上禁用了coredump还是发生了？\u003c/li\u003e\n\u003cli\u003e就算问题1成立，为什么占用的是宿主机上磁盘容量且是根目录?\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e经过一篇追踪及搜索后, 领了几个技术盲区后能够解释上述问题\u003c/p\u003e\n\u003ch4 id=\"为什么宿主机上禁用了coredump还是发生了？\"\u003e\u003ca href=\"#为什么宿主机上禁用了coredump还是发生了？\" class=\"headerlink\" title=\"为什么宿主机上禁用了coredump还是发生了？\"\u003e\u003c/a\u003e为什么宿主机上禁用了coredump还是发生了？\u003c/h4\u003e\u003cp\u003e首先, 虽然宿主机上禁用了coredump, 并不代表容器中就不能coredump,相反在容器中也是可以设置内核参数的,\u003c/p\u003e\n\u003cp\u003e所以, 给pod中的容器设置ulimit参数，可以通过以下方法:\u003cbr/\u003e\u003cstrong\u003e是在镜像中的初始化程序中调用setrlimit()系统调用来进行设置。子进程会继承父进程的ulimit参数\u003c/strong\u003e\u003cbr/\u003e这个很好排查，拿出现coredump问题的镜像，直接使用\u003ccode\u003edocker run\u003c/code\u003e 后发现\u003ccode\u003eulimit -c\u003c/code\u003e返回的是\u003ccode\u003eunlimited\u003c/code\u003e,与宿主机不一样。\u003c/p\u003e\n\u003cp\u003e所以可以回答问题1, 即\u003cstrong\u003e容器中能够使用coredump的原因是由于在容器中设置了\u003ccode\u003eulimit -c\u003c/code\u003e参数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e根据问题1又衍生出了另一个问题: \u003cstrong\u003ekubernetes中给容器设置某些内核参数，哪些是会与主机冲突？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e从上面的验证来看，至少\u003ccode\u003eulimit -c\u003c/code\u003e不会覆盖宿主机的，要不然不存在问题1\u003c/p\u003e\n\u003cp\u003e其实，linux内核方面做了大量的工作，把一部分sysctl内核参数进行了namespace化(namespaced)。 也就是多个容器和主机可以各自独立设置某些内核参数。例如，可以通过\u003ccode\u003enet.ipv4.ip_local_port_range\u003c/code\u003e，在不同容器中设置不同的端口范围。\u003cbr/\u003e那如何判断一个参数是不是namespaced? \u003c/p\u003e\n\u003cp\u003e方式很简单: 运行一个具有privileged权限的容器，然后在容器中修改该参数，看一下在host上能否看到容器在中所做的修改。如果看不到， 那就是namespaced， 否则不是。\u003c/p\u003e\n\u003cp\u003ek8s还进一步把syctl参数分为safe和unsafe, safe的条件：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003emust not have any influence on any other pod on the node\u003c/li\u003e\n\u003cli\u003emust not allow to harm the node’s health\u003c/li\u003e\n\u003cli\u003emust not allow to gain CPU or memory resources outside of the resource limits of a pod.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e非namespaced的参数肯定是unsafe。namespaced参数也只有一部分被认为是safe的。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e由于sysctl是由kubelet设置的\u003c/strong\u003e，从kubelet的源码\u003ccode\u003epkg/kubelet/sysctl/namespace.go\u003c/code\u003e来看，目前已经namespace化的sysctl内核参数如下\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ekernel.shm*,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel.msg*,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel.sem,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efs.mqueue.*,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003enet.*.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意: vm并没有namespace化, 比如\u003ccode\u003evm.max_map_count\u003c/code\u003e 在宿主机或者一个容器中设置它,其他所有容器都会受影响，都会看到最新的值。\u003c/p\u003e\n\u003cp\u003e在\u003ccode\u003epkg/kubelet/sysctl/safe_sysctls.go\u003c/code\u003e中维护了safe sysctl参数的名单。目前只有三个参数被认为是safe的:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ekernel.shm_rmid_forced,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003enet.ipv4.ip_local_port_range,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003enet.ipv4.tcp_syncookies\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"为什么占用的是宿主机上磁盘容量且是根目录\"\u003e\u003ca href=\"#为什么占用的是宿主机上磁盘容量且是根目录\" class=\"headerlink\" title=\"为什么占用的是宿主机上磁盘容量且是根目录?\"\u003e\u003c/a\u003e为什么占用的是宿主机上磁盘容量且是根目录?\u003c/h4\u003e\u003cp\u003e搞清了问题1, 那为什么是占用的是宿主机上的根目录容量呢, 接着查.\u003cbr/\u003e通过排查coredump发现, coredump可以有好几种方式, 在使用了systemd的系统上, 默认使用的是systemd-coredump,\u003cbr/\u003e关于systemd-coredump在这里不展开描述，只提一下它的作用:\u003c/p\u003e\n\u003cp\u003esystemd-coredump可收集并显示内核核心转储，用于分析应用程序崩溃问题。当某个进程（或属于应用程序的所有进程）崩溃时，此工具默认会将核心转储记录到 systemd 日记（如有可能还包括回溯），并将核心转储储存在\u003ccode\u003e/var/lib/systemd/coredump\u003c/code\u003e(默认路径) 中的某个文件内.\u003c/p\u003e\n\u003cp\u003e查看宿主机的\u003ccode\u003e/var/lib/systemd/coredump\u003c/code\u003e目录，果然发现有几个产生的core文件，且size很大.\u003cbr/\u003esystemd-coredump有如下几个重要配置文件,默认配置如下:\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# /etc/systemd/coredump.conf\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[Coredump]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#Storage=external\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#Compress=yes\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#ProcessSizeMax=2G\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#ExternalSizeMax=2G\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#JournalSizeMax=767M\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#MaxUse=\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#KeepFree=\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eStorage可以有如下值:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003enone: 在日记中记录核心转储，但不储存。这样做有助于尽量减少敏感信息的收集与储存，例如，出于符合一般数据保护条例 (GDPR) 的目的。\u003c/li\u003e\n\u003cli\u003eexternal: 将核心储存在/var/lib/systemd/coredump中\u003c/li\u003e\n\u003cli\u003ejournal: 将核心储存在 systemd 日记中\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这里使用的是默认值external, 因此core文件存储在了/var/lib/systemd/coredump\u003c/p\u003e\n\u003cp\u003e另一个配置文件:\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# /usr/lib/sysctl.d/50-coredusmp.conf\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel.core_pattern=|/usr/lib/systemd/systemd-coredump %P %u %g %s %t %c %h %e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel.core_pipe_limit=16\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e第一行表明使用了\u003ccode\u003e|\u003c/code\u003e(管道,内核2.6.19就已支持)的方式.\u003cbr/\u003e第二行表示可以并发运行coredump的上限是16个, dmesg中看到的\u003ccode\u003eover core_pipe_limit\u003c/code\u003e就是超过了这个参数直接给skip了.\u003c/p\u003e\n\u003cp\u003e总结几个很重要的信息:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e使用管道的时候，内核会将 core 内容作为管道后程序的 stdin，然后通过新起一个内核线程来调用管道后的程序，此时，\u003cstrong\u003e是以root用户来运行管道后的程序\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e使用管道时，dump的path目录解析是在系统初始化namespace中发生的，也就是宿主机的global ns 中，所以默认会将文件生成在宿主机的path目录中\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e同时由于kernel.core_pattern是一个未做隔离的变量，容器中和宿主机共享此值\u003c/strong\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e所有配置结合起来就导致在容器中产生的coredump事件最后产生的core文件却生成了在宿主机上了\u003cbr/\u003e问题2的疑惑解决\u003c/p\u003e\n\u003ch3 id=\"问题解决\"\u003e\u003ca href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"\u003e\u003c/a\u003e问题解决\u003c/h3\u003e\u003cp\u003e那需要不需要将在容器中产生的coredump直接保存在容器里呢?\u003cbr/\u003e答案是不建议，因为本身开启coredump的原因就是为了debug问题，在出现coredump时一般容器也可能就挂了，如果这时候coredump文件还保存在容器中,那也没办法拿到,开启coredump的初衷就不存在。\u003cbr/\u003e由于业务方需要开启coredump来定位问题这个情况客观存在, 也不能说一棒子打死就直接不给开放了,优雅一点通过以下几种方式解决:\u003c/p\u003e\n\u003ch4 id=\"限制容器中ulimit参数\"\u003e\u003ca href=\"#限制容器中ulimit参数\" class=\"headerlink\" title=\"限制容器中ulimit参数\"\u003e\u003c/a\u003e限制容器中ulimit参数\u003c/h4\u003e\u003cp\u003e这次问题的本质是产生的coredump太大将宿主机根目录打满，那么可以在容器中限制一下ulimit的大小\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eulimit\u003c/span\u003e -c \u003cspan class=\"comment\"\u003e# 降低到128M\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch4 id=\"调整宿主机上systemd-coredump配置\"\u003e\u003ca href=\"#调整宿主机上systemd-coredump配置\" class=\"headerlink\" title=\"调整宿主机上systemd-coredump配置\"\u003e\u003c/a\u003e调整宿主机上systemd-coredump配置\u003c/h4\u003e\u003cp\u003e同时, 调整systemd-coredump的配置，限制并发数(\u003ccode\u003e/usr/lib/sysctl.d/50-coredusmp.conf中的kernel.core_pipe_limit\u003c/code\u003e参数), 同时将存储core文件的路径从根目录下迁移到大盘上或者直接设置为none\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# /etc/systemd/coredump.conf\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[Coredump]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eStorage=none # 或者是大盘路径\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#Compress=yes\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eProcessSizeMax=0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#ExternalSizeMax=2G\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#JournalSizeMax=767M\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#MaxUse=\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e#KeepFree=\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意: 内核转储文件所占用的磁盘资源受两种不同方式的约束： (1)占用磁盘空间的大小受 /etc/systemd/coredump.conf 配置文件以及对应的配置片段的约束； (2)占用磁盘时间的长短受 systemd-tmpfiles 配置的约束(对应的配置文件默认位于 /usr/lib/tmpfiles.d/systemd.conf)。\u003c/p\u003e\n\u003ch3 id=\"问题总结\"\u003e\u003ca href=\"#问题总结\" class=\"headerlink\" title=\"问题总结\"\u003e\u003c/a\u003e问题总结\u003c/h3\u003e\u003cp\u003e这次出现的问题虽没有产生实质的影响,但还是发现不少可以提高稳定性的点, 这类问题不亲身遇到, 平时也没什么机会可以关注到,从点到线及面, \u003cstrong\u003e出现问题不可怕, 解决能力很重要, 而且要快\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/\"\u003ehttps://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.jinbuguo.com/systemd/systemd-coredump.html\"\u003ehttps://www.jinbuguo.com/systemd/systemd-coredump.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://cloud.tencent.com/developer/article/1583736\"\u003ehttps://cloud.tencent.com/developer/article/1583736\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zhuanlan.zhihu.com/p/29135840\"\u003ehttps://zhuanlan.zhihu.com/p/29135840\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/kubernetes/kubernetes/issues/98106\"\u003ehttps://github.com/kubernetes/kubernetes/issues/98106\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/kubernetes/kubernetes/issues/3595\"\u003ehttps://github.com/kubernetes/kubernetes/issues/3595\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://cloud.redhat.com/blog/a-guide-to-core-dump-handling-in-openshift\"\u003ehttps://cloud.redhat.com/blog/a-guide-to-core-dump-handling-in-openshift\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\n      \n    \u003c/div\u003e",
  "Date": "2023-07-29T11:30:53+08:00",
  "Author": "Z.S.K."
}