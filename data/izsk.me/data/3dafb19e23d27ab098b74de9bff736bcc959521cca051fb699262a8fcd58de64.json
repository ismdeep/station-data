{
  "Source": "izsk.me",
  "Title": "Prometheus学习(PromSQL常用函数)",
  "Link": "https://izsk.me/2020/01/05/prometheus-functions/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003eprometheus从某种程序上也算是一种数据库, 使用的是promSQL语言, 既然做为一种数据库查询语言, 自然也跟其它数据库一样内置各种查询函数, prometheus中内置的函数比较多, 完整的函数列表在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/prometheus/latest/querying/functions/\"\u003e这里\u003c/a\u003e, 这里会记录在工作中常用到的一些函数.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003ch3 id=\"时间区间\"\u003e\u003ca href=\"#时间区间\" class=\"headerlink\" title=\"时间区间\"\u003e\u003c/a\u003e时间区间\u003c/h3\u003e\u003cp\u003e首先要了解的是, 在prometheus中，不能直接指定时间区间，不过可以使用如\u003ccode\u003e[180m]、offset 5m\u003c/code\u003e等方式来表示距当前时间的一段时间内, 这种方式在prometheus中叫做\u003ccode\u003e范围向量选择器(range-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 返回当前五分钟之前http_requests_total的数据\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ehttp_requests_total{job=\u003cspan class=\"string\"\u003e\u0026#34;prometheus\u0026#34;\u003c/span\u003e}[5m]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# offset 允许在单个即时向量或范围向量查询中设置相对于当前时间的时间偏移\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 返回http_requests_total5分钟前的值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003esum\u003c/span\u003e(http_requests_total{method=\u003cspan class=\"string\"\u003e\u0026#34;GET\u0026#34;\u003c/span\u003e} offset 5m)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003ch3 id=\"速率函数\"\u003e\u003ca href=\"#速率函数\" class=\"headerlink\" title=\"速率函数\"\u003e\u003c/a\u003e速率函数\u003c/h3\u003e\u003ch4 id=\"increase-增长量\"\u003e\u003ca href=\"#increase-增长量\" class=\"headerlink\" title=\"increase(增长量)\"\u003e\u003c/a\u003eincrease(增长量)\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eincrease(v range-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e获取时间区间内的第一个样本与最后一个样本，返回之间的增长量\u003c/p\u003e\n\u003cp\u003e这个比较容易理解，就是在时间区间内的最后一个值减去第一个值, 获得差值\u003c/p\u003e\n\u003cp\u003e比如: 计算http get类型的请求在5m内增长数\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eincrease(http_requests_total{instance=\u0026#34;10.42.6.52:9100\u0026#34;, method=\u0026#34;get\u0026#34;}[5m])\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409144657.png\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"rate-增长率\"\u003e\u003ca href=\"#rate-增长率\" class=\"headerlink\" title=\"rate(增长率)\"\u003e\u003c/a\u003erate(增长率)\u003c/h4\u003e\u003cp\u003e\u003ccode\u003erate(v range-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e计算范围向量中时间序列的每秒, 第一个点及最后一个点来平均增长率，然后求平均增长率\u003c/p\u003e\n\u003cp\u003e比如： 计算http get类型的请求在5m内增长率\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erate(http_requests_total{instance=\u0026#34;10.42.6.52:9100\u0026#34;, method=\u0026#34;get\u0026#34;}[5m])\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409144842.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e可以发现value=0.05, 恰恰是在5m内增的15除于300所得到的\u003c/p\u003e\n\u003cp\u003e因此\u003cstrong\u003erate所得到的增长率就是rate=increase/range\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"irate-增长率\"\u003e\u003ca href=\"#irate-增长率\" class=\"headerlink\" title=\"irate(增长率)\"\u003e\u003c/a\u003eirate(增长率)\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eirate(v range-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e计算范围向量中时间序列的每秒, 最后两个点来计算瞬时增加率，用增长量/时间区间来计算增长率\u003c/p\u003e\n\u003cp\u003e同样，比如： 计算http get类型的请求在5m内增长率\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eirate(http_requests_total{instance=\u0026#34;10.42.6.52:9100\u0026#34;, method=\u0026#34;get\u0026#34;}[5m])\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409145217.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们能够发现, irate得到的数据跟rate得到的数据是一样, 那为何同时存在这两个函数呢?\u003c/p\u003e\n\u003cp\u003e先回答下为何这两个值是一样的, 因为这个测试环境没多少请求, 请求数增长才几十个, 在量小的情况下对于使用rate与irate的并别不会很明显\u003c/p\u003e\n\u003cp\u003e如果这里换个例子, 用rate/irate来计算某机器在1m内网卡的增长率，就能看出点区别了\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409145907.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e所以变化越快的场合这两者的差别越大, 那两者到底有啥区别呢\u003c/p\u003e\n\u003ch4 id=\"rate与irate区别\"\u003e\u003ca href=\"#rate与irate区别\" class=\"headerlink\" title=\"rate与irate区别\"\u003e\u003c/a\u003erate与irate区别\u003c/h4\u003e\u003cp\u003eirate和rate都会用于计算某个指标在一定时间间隔内的变化速率。但是它们的计算方法有所不同：irate取的是在指定时间范围内的最近两个数据点来算速率，而rate会取指定时间范围内所有数据点，算出一组速率，然后取平均值作为结果。\u003c/p\u003e\n\u003cp\u003e所以官网文档说：\u003cstrong\u003eirate适合快速变化的计数器（counter），而rate适合缓慢变化的计数器（counter）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e根据以上算法我们也可以理解，对于快速变化的计数器，如果使用rate，因为使用了平均值，很容易把峰值削平.而irate则是在范围向量中每个时间序列的两个最近数据点的增长率.\u003c/p\u003e\n\u003ch3 id=\"计算函数\"\u003e\u003ca href=\"#计算函数\" class=\"headerlink\" title=\"计算函数:\"\u003e\u003c/a\u003e计算函数:\u003c/h3\u003e\u003ch4 id=\"sum\"\u003e\u003ca href=\"#sum\" class=\"headerlink\" title=\"sum\"\u003e\u003c/a\u003esum\u003c/h4\u003e\u003cp\u003e很简单, 直接求和\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409151117.png\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"count\"\u003e\u003ca href=\"#count\" class=\"headerlink\" title=\"count\"\u003e\u003c/a\u003ecount\u003c/h4\u003e\u003cp\u003e很简单, 直接请记录数\u003c/p\u003e\n\u003cp\u003e![image-20200409151152568](/Users/zhoushuke/Library/Application Support/typora-user-images/image-20200409151152568.png)\u003c/p\u003e\n\u003ch4 id=\"ceil\"\u003e\u003ca href=\"#ceil\" class=\"headerlink\" title=\"ceil\"\u003e\u003c/a\u003eceil\u003c/h4\u003e\u003cp\u003e四舍五入，将所有元素的样本值四舍五入\u003ccode\u003ev\u003c/code\u003e到最接近的整数\u003c/p\u003e\n\u003ch4 id=\"abs\"\u003e\u003ca href=\"#abs\" class=\"headerlink\" title=\"abs\"\u003e\u003c/a\u003eabs\u003c/h4\u003e\u003cp\u003e返回绝对值\u003c/p\u003e\n\u003ch4 id=\"round\"\u003e\u003ca href=\"#round\" class=\"headerlink\" title=\"round\"\u003e\u003c/a\u003eround\u003c/h4\u003e\u003cp\u003e保留小数点位数\u003c/p\u003e\n\u003cp\u003e后面这几个的意思都比较明确, 在这就不贴图了, 这些计算函数一般都会跟\u003ccode\u003eby\u003c/code\u003e结合使用.\u003c/p\u003e\n\u003ch3 id=\"排序函数\"\u003e\u003ca href=\"#排序函数\" class=\"headerlink\" title=\"排序函数\"\u003e\u003c/a\u003e排序函数\u003c/h3\u003e\u003ch4 id=\"sort-x2F-sort-desc\"\u003e\u003ca href=\"#sort-x2F-sort-desc\" class=\"headerlink\" title=\"sort/sort_desc\"\u003e\u003c/a\u003esort/sort_desc\u003c/h4\u003e\u003cp\u003e\u003ccode\u003esort(v instant-vector)/sort_desc(v instant-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e将结果按升序/降序排列\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esort(sum(nginx_ingress_controller_response_duration_seconds_bucket{path=~\u0026#34;/sensego/v2.0/mingyuan\u0026#34;,status=\u0026#34;200\u0026#34;}) by (le))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409151642.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e####topk\u003c/p\u003e\n\u003cp\u003ek表示按照某种排列只保留K条记录\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etopk(3, sort(sum(nginx_ingress_controller_response_duration_seconds_bucket{path=~\u0026#34;/sensego/v2.0/mingyuan\u0026#34;,status=\u0026#34;200\u0026#34;}) by (le)))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409151827.png\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"标签函数\"\u003e\u003ca href=\"#标签函数\" class=\"headerlink\" title=\"标签函数\"\u003e\u003c/a\u003e标签函数\u003c/h3\u003e\u003ch4 id=\"label-join\"\u003e\u003ca href=\"#label-join\" class=\"headerlink\" title=\"label_join\"\u003e\u003c/a\u003elabel_join\u003c/h4\u003e\u003cp\u003e将多个 src_label 拼接成一个新的 dst_label，用分隔符 separator 连接\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elabel_join(v instant-vector, dst_label string, separator string, src_label_1 string, src_label_2 string, ...)\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003ev: 表示需要操作记录\u003c/li\u003e\n\u003cli\u003edst_label： 添加/覆盖的label, 如果指定的label不存在，则添加\u003c/li\u003e\n\u003cli\u003eseparator:  分隔符\u003c/li\u003e\n\u003cli\u003esrc_label_1: 源label \u003c/li\u003e\n\u003cli\u003e可以有N个标签\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e比如， 想在以下记录中添加一个foo 标签, 这个标签的值来自instance与job\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409154244.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elabel_join(up{instance=\u0026#34;localhost:9090\u0026#34;,job=\u0026#34;prometheus\u0026#34;}, \u0026#34;foo\u0026#34;, \u0026#34;,\u0026#34;, \u0026#34;instance\u0026#34;, \u0026#34;job\u0026#34;)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409154700.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e最终的结果会出现多了个\u003ccode\u003efoo=\u0026#34;localhost:9090,prometheus\u0026#34;\u003c/code\u003e,达到目的.\u003c/p\u003e\n\u003ch4 id=\"lable-replace\"\u003e\u003ca href=\"#lable-replace\" class=\"headerlink\" title=\"lable_replace\"\u003e\u003c/a\u003elable_replace\u003c/h4\u003e\u003cp\u003e用于给监控项添加/覆盖label\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elabel_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003ev: 表示需要操作记录\u003c/li\u003e\n\u003cli\u003edst_label： 添加/被覆盖的label, 如果指定的label不存在，则添加\u003c/li\u003e\n\u003cli\u003ereplacement:  匹配到的string ,使用$1,$2…引用\u003c/li\u003e\n\u003cli\u003esrc_label: regex表达式匹配的源label \u003c/li\u003e\n\u003cli\u003eregex: 正则表达式，可使用$1,$2…引用\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e比如: \u003c/p\u003e\n\u003cp\u003e\u003ccode\u003elabel_replace(kubelet_running_pod_count,\u0026#34;node\u0026#34;, \u0026#34;$1\u0026#34;, \u0026#34;kubernetes_io_hostname\u0026#34;,\u0026#34;(.*)\u0026#34;)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e原kubelet_running_pod_count 结果集如下，可以看出集中没有node 标签\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/410B432A-94C5-4EBB-9BFA-FFB0DDFA71C1.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e通过以上语句添加一个node label：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/99BC5562-4B2F-4136-860E-637FF147BF29.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e覆盖label:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/EA4D8213-3E13-41B4-B2E2-AD651B577D43.png\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"分位函数\"\u003e\u003ca href=\"#分位函数\" class=\"headerlink\" title=\"分位函数\"\u003e\u003c/a\u003e分位函数\u003c/h3\u003e\u003ch4 id=\"histogram-quantile\"\u003e\u003ca href=\"#histogram-quantile\" class=\"headerlink\" title=\"histogram_quantile\"\u003e\u003c/a\u003ehistogram_quantile\u003c/h4\u003e\u003cp\u003e用于计算通过histogram获取数据的分位数\u003c/p\u003e\n\u003cp\u003e假如，要计算nginx_ingress中95%的响应时间落在哪个区间可以使用以下命令\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehistogram_quantile(0.95, sum(rate(nginx_ingress_controller_response_duration_seconds_bucket{path=~\u0026#34;/sensego/v2.0/mingyuan\u0026#34;,status=\u0026#34;200\u0026#34;}[1800m])) by (le))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409115919.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e当然正常情况下都是在grafana中对Prometheus的数据进行查询, grafana本身也有一些常用的函数, 有机会也学习记录下.\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/prometheus/prometheus/blob/master/promql/quantile.go\"\u003ehttps://github.com/prometheus/prometheus/blob/master/promql/quantile.go\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/prometheus/latest/querying/functions/\"\u003ehttps://prometheus.io/docs/prometheus/latest/querying/functions/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://my.oschina.net/54188zz/blog/3070582\"\u003ehttps://my.oschina.net/54188zz/blog/3070582\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2020-01-05T12:30:53+08:00",
  "Author": "Z.S.K."
}