{
  "Source": "izsk.me",
  "Title": "Flask学习(flask应用)",
  "Link": "https://izsk.me/2017/08/12/flask%E5%AD%A6%E4%B9%A0%E4%BA%8C(flask%E5%BA%94%E7%94%A8)/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e距离\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/2017/08/12/falsk%E5%AD%A6%E4%B9%A0(-)\"\u003e上一篇\u003c/a\u003e有一段时间了,上次扯了点跟flask相关的内容,这次抽空记录下flask的机制.flask之所于上手容易,是因为我们对python语言稍微了解的话,简单几步就可以把一个小应用跑起来,不需要搭建额外的东西,所以对于并发量没有要求的话flask可以轻松应对.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch3 id=\"flask单应用\"\u003e\u003ca href=\"#flask单应用\" class=\"headerlink\" title=\"flask单应用\"\u003e\u003c/a\u003e\u003cstrong\u003eflask单应用\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e我们在网上看到的flask教程基本都会有这样一句代码\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eapp = Flask(__name__)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e每个 Flask 应用必须创建一个Flask类的实例,并且把模块的名称传递给该实例,\u003cstrong\u003eflask支持多应用共存,甚至是可以跟django实例共存\u003c/strong\u003e这个后续再说,这里只是指定了一个flask实例,并不能运行起来.\u003c/p\u003e\n\u003cp\u003eFlask()更多的参数请见\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://flask.pocoo.org/docs/0.12/api/#application-object\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eapp.run(host=\u003cspan class=\"string\"\u003e\u0026#34;0.0.0.0\u0026#34;\u003c/span\u003e, port=\u003cspan class=\"number\"\u003e19090\u003c/span\u003e, debug=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e, passthrough_errors=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e, threaded=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e有了上面这句话之后,flask实例才真正的运行起来,有几个重要的参数这里要说下:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003ehost=0.0.0.0:表示其它主机都能访问\u003c/li\u003e\n\u003cli\u003edebug=True:开启调度模式,一般用于测试环境\u003c/li\u003e\n\u003cli\u003epassthrough_errors=True: 禁用错误捕获\u003c/li\u003e\n\u003cli\u003ethreaded=True: 则是开启多线程模式,让应用能够同时处理多个请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e更多的参数请见\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://werkzeug.pocoo.org/docs/0.11/serving/#werkzeug.serving.run_simple\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e最基本的例子:\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efrom\u003c/span\u003e flask \u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e Flask,render_template\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eapp = Flask(__name__)  \u003cspan class=\"comment\"\u003e#Flask的一个对象,是一个app,flask支持多app共存\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e@app.route(\u003cspan class=\"params\"\u003e\u003cspan class=\"string\"\u003e\u0026#34;/\u0026#34;\u003c/span\u003e,methods=[\u003cspan class=\"string\"\u003e\u0026#34;GET\u0026#34;\u003c/span\u003e]\u003c/span\u003e) \u003c/span\u003e\u003cspan class=\"comment\"\u003e#@是装饰器的语法糖,route则是上面说的路由转发模块\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003eindex\u003c/span\u003e():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e render_template(\u003cspan class=\"string\"\u003e\u0026#34;index.html\u0026#34;\u003c/span\u003e,pass_to_template=\u003cspan class=\"string\"\u003e\u0026#34;index\u0026#34;\u003c/span\u003e) \u003cspan class=\"comment\"\u003e#把pass_to_template变量传递给index.html模板\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"string\"\u003e\u0026#34;__main__\u0026#34;\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    app.run(host=\u003cspan class=\"string\"\u003e\u0026#34;0.0.0.0\u0026#34;\u003c/span\u003e, port=\u003cspan class=\"number\"\u003e19090\u003c/span\u003e, passthrough_errors=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e, threaded=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e) \u003cspan class=\"comment\"\u003e#使用flask自带的wsgi-server,监听本机的19090端口,threaded=True则开启多线程模式,自带的wsgi-server性能不好,生产环境不会这么用,一般都使用并发量更大的wsgi架构如uwsgi,tornado等\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e现在,打开浏览器输入\u003ccode\u003ehttp://ip:19090/index.html\u003c/code\u003e即可访问index页面\u003c/p\u003e\n\u003cp\u003e面对多个请求时 ,flask是如何做到请求隔离的呢,这里要提一个flask的两个上下文机制\u003c/p\u003e\n\u003ch3 id=\"两个上下文\"\u003e\u003ca href=\"#两个上下文\" class=\"headerlink\" title=\"两个上下文\"\u003e\u003c/a\u003e\u003cstrong\u003e两个上下文\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e这里不深入源代码一探究竟,一句话:\u003cstrong\u003e临时全局变量\u003c/strong\u003e,flask很机智的实现了thread.local类似\u003ccode\u003e线程隔离\u003c/code\u003e功能,并配置\u003ccode\u003e栈\u003c/code\u003e这种数据结构让其很轻松的可以将对象推入、弹出、快速获取栈顶对象,当然这些操作也是线程隔离的.\u003c/p\u003e\n\u003cp\u003e也就是说,\u003cstrong\u003e在一次请求的一个线程中可以将其设置为全局变量,但是仅限于请求的这个线程内部,不同线程通过“线程标识符”来区别,这样就不会影响到其他线程的请求.\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"请求上下文\"\u003e\u003ca href=\"#请求上下文\" class=\"headerlink\" title=\"请求上下文\"\u003e\u003c/a\u003e\u003cstrong\u003e请求上下文\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e实现线程隔离后,为了在一个线程中更加方便使用这些变量,flask中还有一种堆栈的数据结构(通过werkzeug的LocalStack实现),可以处理这些变量,但是并不直接处理这些变量.假如有一个程序得到一个请求,那么flask会将这个请求的所有相关信息进行打包,打包形成的东西就是处理请求的一个环境.flask将这种环境称为\u003ccode\u003e请求上下文\u003c/code\u003e(request context),之后flask会将这个请求上下文对象放到堆栈中.\u003c/p\u003e\n\u003cp\u003e这样,请求发生时,我们一般都会指向堆栈中的“请求上下文”对象,这样可以通过请求上下文获取相关对象并直接访问,例如\u003ccode\u003erequest、session、current_app,g\u003c/code\u003e(后两者为应用上下文).还可以通过调用对象的方法或者属性获取其他信息,例如request.method,等请求结束后,请求上下文会被销毁,堆栈重新等待新的请求上下文对象被放入.\u003c/p\u003e\n\u003ch4 id=\"应用上下文\"\u003e\u003ca href=\"#应用上下文\" class=\"headerlink\" title=\"应用上下文\"\u003e\u003c/a\u003e\u003cstrong\u003e应用上下文\u003c/strong\u003e\u003c/h4\u003e\u003cp\u003e\u003ccode\u003e应用上下文的概念是在flask 0.9中增加的\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当在一个应用的请求上下文环境中,需要嵌套处理另一个应用的相关操作时(这种情况更多的是用于测试或者在console中对多个应用进行相关处理),“请求上下文”显然就不能很好地解决问题了,因为魔法current_app无法确定当前处理的到底是哪个应用.如何让请求找到“正确”的应用呢？我们可能会想到,可以再增加一个请求上下文环境,并将其推入栈中.由于两个上下文环境的运行是独立的,不会相互干扰,所以通过调用栈顶对象的app属性或者调用current_app(current_app一直指向栈顶的对象)也可以获得当前上下文环境正在处理哪个应用.这种办法在一定程度上可行,但是如果说对第二个应用的处理不涉及到相关请求,那也就无从谈起“请求上下文”,更不可能建立请求上下文环境了.为了应对这个问题,Flask中将应用相关的信息单独拿出来,形成一个“应用上下文”对象.这个对象可以和“请求上下文”一起使用,也可以单独拿出来使用.不过有一点需要注意的是：在创建“请求上下文”时一定要创建一个“应用上下文”对象.有了“应用上下文”对象,便可以很容易地确定当前处理哪个应用,这就是魔法\u003ccode\u003ecurrent_app\u003c/code\u003e.在0.1版本中,current_app是对_request_ctx_stack.top.app的引用,而在0.9版本中current_app是对_app_ctx_stack.top.app的引用.其中_request_ctx_stack和_app_ctx_stack分别是存储请求上下文和应用上下文的栈\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e请求上下文: request、session\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e应用上下文: g、current_app\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"实现高并发\"\u003e\u003ca href=\"#实现高并发\" class=\"headerlink\" title=\"实现高并发\"\u003e\u003c/a\u003e\u003cstrong\u003e实现高并发\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e上面说了flask自带的wsgi的性能不好,一般都会选择其它能够实现高并发的http server,如gunicorn,greenlet,uswgi.\u003c/p\u003e\n\u003cp\u003e其中\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://gunicorn.org/\"\u003egunicorn\u003c/a\u003e几乎不需要什么配置就可直接整合到flask项目中,但是gunicorn只支持unix,而uswgi的配置比较复杂,但是性能比gunicorn稍好.\u003c/p\u003e\n\u003cp\u003e上面启动flask是直接在主函数中使用app.run(),这里我们结合gunicorn启动app(假设已pip install gunicorn)\u003c/p\u003e\n\u003cp\u003egunicorn基于‘pre-fork worker’模型,意味着有一个中心主控master进程,用它来管理一组worker进程.\u003c/p\u003e\n\u003cp\u003eworker进程可以支持不同的IO方式（sync,gevent,eventlet,tornado等）\u003c/p\u003e\n\u003cp\u003e命令非常简洁:\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003egunicorn -D -w \u003cspan class=\"number\"\u003e4\u003c/span\u003e -b \u003cspan class=\"number\"\u003e127.0\u003c/span\u003e\u003cspan class=\"number\"\u003e.0\u003c/span\u003e\u003cspan class=\"number\"\u003e.1\u003c/span\u003e:\u003cspan class=\"number\"\u003e4000\u003c/span\u003e myproject:app\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e其中:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e-D: 以deamon形式后台运行\u003c/li\u003e\n\u003cli\u003e-w: 指定work进程数为4\u003c/li\u003e\n\u003cli\u003e-b: 指定ip 和端口\u003c/li\u003e\n\u003cli\u003emyproject:app 程序入口,前为工程入口文件,后为flask启动的应用\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这样flask就以gunicorn的方式启动了,并发数也大大提高.\u003c/p\u003e\n\u003cp\u003egunicorn处理静态资源的能力不是很好,所以一般都会在前面再部署个nginx,只需要将proxy_pass 指向gunicorn的监听端口即可,可以参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.cnblogs.com/Ray-liang/p/4837850.html\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e更多的flask实现高并发部署方式请见\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://flask.pocoo.org/docs/0.12/deploying/#deployment\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.zhihu.com/question/33970027\"\u003eflask框架中应用上下文跟请求上下文是什么意思\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://flask.pocoo.org/docs/0.12/\"\u003eflask-docs\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.cnblogs.com/Ray-liang/p/4837850.html\"\u003eFlask + Gunicorn + Nginx 部署\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\u003chr/\u003e\n\n      \n    \u003c/div\u003e",
  "Date": "2017-08-12T22:50:53+08:00",
  "Author": "Z.S.K."
}