{
  "Source": "izsk.me",
  "Title": "Kubernetes学习(Docker)",
  "Link": "https://izsk.me/2019/11/15/Kubernetes-docker-arch/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e在使用kubernetes的时候，常常不太会关注docker这层, 在Node节点查看docker的进程, 会发现在docker-client、dockerd、containerd、containerd-shim、runC, 傻傻分不清楚这几个跟docker相关的进程到底扮演着什么角色.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003ch3 id=\"CRI\"\u003e\u003ca href=\"#CRI\" class=\"headerlink\" title=\"CRI\"\u003e\u003c/a\u003eCRI\u003c/h3\u003e\u003cp\u003e在docker的最初版本, docker就是client+daemonset架构, 非常简洁\u003c/p\u003e\n\u003cp\u003e只不过到后来Kubernetes的兴起, 容器厂商的技术对战也变得非常激烈, 再到后来Kubernetes取得完全的胜利, 再到后来几家大佬公司一起制定了CRI(container runtime interface), docker为了适配才成了今天所看到的架构\u003c/p\u003e\n\u003cp\u003e关于容器时代几家大佬公司之间的竞争, 有兴趣的可以看下\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zhuanlan.zhihu.com/p/87602649\"\u003e这篇文章\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eCRI在Kubernetes的架构中也是个很重要的部分, 至于为何需要这个, 不再这里详细, 今天只学一学docker(这里说的docker会存在歧义)做为CRI\u003c/p\u003e\n\u003cp\u003e先来看看CRI在Kubernetes的位置\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200422155644.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eKubernetes中的docker那层的架构分为以下几层:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200422163423.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e而ContainerRuntime(docker)的结构如下\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200414141636.png\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"Client\"\u003e\u003ca href=\"#Client\" class=\"headerlink\" title=\"Client\"\u003e\u003c/a\u003eClient\u003c/h4\u003e\u003cp\u003e最上面那一层是个client，就是我们经常使用的docker ps等命令行的时候, 相当于我们做为client去请求docker的服务端, 那必须存在一个daemonset的进程一直来监听主机上发出的命令\u003c/p\u003e\n\u003ch4 id=\"dockerEngine\"\u003e\u003ca href=\"#dockerEngine\" class=\"headerlink\" title=\"dockerEngine\"\u003e\u003c/a\u003edockerEngine\u003c/h4\u003e\u003cp\u003e这个其实就相当于是docker daemon, 负责监听主机上docker相关的命令,将相关命令发送给containerd.\u003c/p\u003e\n\u003ch4 id=\"containerd\"\u003e\u003ca href=\"#containerd\" class=\"headerlink\" title=\"containerd\"\u003e\u003c/a\u003econtainerd\u003c/h4\u003e\u003cp\u003e先看下官方的说明:\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003econtainerd is available as a daemon for Linux and Windows. It manages the complete container lifecycle of its host system, from image transfer and storage to container execution and supervision to low-level storage to network attachments and beyond.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e翻译一下: \u003cstrong\u003econtainerd\u003c/strong\u003e在linux跟windows是一个守护进程我, 通过它管理容器的生命周期, 从图像传输和存储到容器执行和监督，再到低级存储再到网络附件等等\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200422164159.png\"/\u003e\u003c/p\u003e\n\u003cp\u003econtainerd 向上为 Docker Daemon 提供了 gRPC 接口，使得 Docker Daemon 屏蔽下面的结构变化，确保原有接口向下兼容。向下通过 containerd-shim 结合 runC，使得引擎可以独立升级，避免之前 Docker Daemon 升级会导致所有容器不可用的问题\u003c/p\u003e\n\u003cp\u003e其实 \u003ccode\u003econtainerd\u003c/code\u003e 就包含了我们常用的 \u003ccode\u003edocker\u003c/code\u003e 的命令， 所以可以通过Client不经过docker daemon直接与containerd进行通信\u003c/p\u003e\n\u003ch4 id=\"containerd-shim\"\u003e\u003ca href=\"#containerd-shim\" class=\"headerlink\" title=\"containerd-shim\"\u003e\u003c/a\u003econtainerd-shim\u003c/h4\u003e\u003cp\u003econtainerd 通过 shim 调用 runc 的包函数来启动容器， 也就是说containerd通过shim操作runc，runc真正控制容器生命周期\u003c/p\u003e\n\u003cp\u003e启动一个容器就会启动一个shim进程，因此会在Node上看到大量的shim进程\u003c/p\u003e\n\u003cp\u003e引入shim, 主要有以下几点考虑.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e允许runc在创建\u0026amp;运行容器之后退出\u003c/li\u003e\n\u003cli\u003e用shim作为容器的父进程，而不是直接用containerd作为容器的父进程，是为了防止这种情况：当containerd挂掉的时候，shim还在，因此可以保证容器打开的文件描述符不会被关掉\u003c/li\u003e\n\u003cli\u003e依靠shim来收集\u0026amp;报告容器的退出状态，这样就不需要containerd来wait子进程\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"runC\"\u003e\u003ca href=\"#runC\" class=\"headerlink\" title=\"runC\"\u003e\u003c/a\u003erunC\u003c/h3\u003e\u003cp\u003e runc是OCI(Open Container Initiative, 开放容器标准)的一个参考实现. 于是, containerd-shim 在这一步需要调用 runc 这个命令行工具, 来启动容器;\u003c/p\u003e\n\u003cp\u003erunc 启动完容器后本身会直接退出, containerd-shim 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程\u003c/p\u003e\n\u003cp\u003e平时也不怎么去关注docker， 都不知道一个docker居然涉及到这么多的东西\u003c/p\u003e\n\u003cp\u003e不过由于containerd的发展, 现在已经完全有能力跟client直接交互,\u003c/p\u003e\n\u003cp\u003e相信不久以后,containerd很可能马上就会替代docker，成为Kubernetes首选的容器运行时, 这样架构上相对简洁一点.\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://containerd.io/\"\u003ehttps://containerd.io/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.pyfdtic.com/2018/03/16/docker-%E5%86%85%E9%83%A8%E7%BB%84%E4%BB%B6%E7%BB%93%E6%9E%84-docker-daemon-container-runC/\"\u003ehttps://www.pyfdtic.com/2018/03/16/docker-内部组件结构-docker-daemon-container-runC/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.csdn.net/u013812710/article/details/79001463\"\u003ehttps://blog.csdn.net/u013812710/article/details/79001463\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zhuanlan.zhihu.com/p/87602649\"\u003ehttps://zhuanlan.zhihu.com/p/87602649\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2019-11-15T17:30:53+08:00",
  "Author": "Z.S.K."
}