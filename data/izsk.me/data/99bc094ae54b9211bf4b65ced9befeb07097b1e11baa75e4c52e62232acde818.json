{
  "Source": "izsk.me",
  "Title": "Kong学习(kong介绍)",
  "Link": "https://izsk.me/2020/08/15/Kong-introdution/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003eKong是一个Mashape开源的高性能高可用的API网关和API服务管理层，基于OpenResty,进行API管理，并提供了插件实现了API的AOP功能, 官方更是有这样的描述: \u003ccode\u003eNext-Generation API Platform for Multi-Cloud and Hybrid Organizations\u003c/code\u003e,可见kong的野心还是非常大的，也确实非常受欢迎,目前的Kong的版本为2.1.\u003c/p\u003e\n\u003cp\u003e这里简单提一下, 如果看过视频的都会发现，kong其实应该读康，而不是读空.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003ekong使用也有一段时间了，这里把相关的使用心得记录一下.\u003c/p\u003e\n\u003ch3 id=\"主要特性\"\u003e\u003ca href=\"#主要特性\" class=\"headerlink\" title=\"主要特性\"\u003e\u003c/a\u003e主要特性\u003c/h3\u003e\u003cp\u003ekong做为API网关,总结起来有有以下特性:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e云原生: 与平台无关，Kong 可以从裸机运行到 Kubernetes\u003c/li\u003e\n\u003cli\u003e高性能 : 背靠非阻塞通信的 nginx，性能自不用说\u003c/li\u003e\n\u003cli\u003e插件机制 : 提供众多开箱即用的插件，且有易于扩展的自定义插件接口，用户可以使用 Lua 自行开发插件\u003c/li\u003e\n\u003cli\u003e熔断：可以通过插件实现熔断，避免系统雪崩\u003c/li\u003e\n\u003cli\u003e日志: 可以记录通过 Kong 的 HTTP，TCP，UDP 请求和响应。\u003c/li\u003e\n\u003cli\u003e鉴权: 权限控制，IP 黑白名单，同样是 OpenResty 的特性\u003c/li\u003e\n\u003cli\u003eSSL: Setup a Specific SSL Certificate for an underlying service or API.\u003c/li\u003e\n\u003cli\u003e监控: Kong 提供了实时监控插件\u003c/li\u003e\n\u003cli\u003e认证: 如数支持 HMAC, JWT, Basic, OAuth 2.0 等常用协议\u003c/li\u003e\n\u003cli\u003e限流：可以通过插件实现单个服务某些接口的限流，避免服务过载导致不可用\u003c/li\u003e\n\u003cli\u003eREST API: 通过 Rest API 进行配置管理，从繁琐的配置文件中解放\u003c/li\u003e\n\u003cli\u003e健康检查：自动检查，被动检查；节点不可用同步到所有的kong节点需要 1 - 2 秒\u003c/li\u003e\n\u003cli\u003e动态路由：Kong 的背后是 OpenResty+Lua，所以从 OpenResty 继承了动态路由的特性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然，从上面这些概括可以看到:一方面，插件化的形式让kong可以很方便地提供了各种功能，对API层的管理有天然的粘合性\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200611144926.png\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"资源对象\"\u003e\u003ca href=\"#资源对象\" class=\"headerlink\" title=\"资源对象\"\u003e\u003c/a\u003e资源对象\u003c/h3\u003e\u003cp\u003e当然对于一款API网关软件来说, 有一些重要的资源对象，先来熟悉一下名词:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eUpstream\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eUpstream 对象表示虚拟主机名，可用于通过多个服务（目标）对传入请求进行负载均衡。例如：service.v1.xyz 为Service对象命名的上游host是service.v1.xyz对此服务的请求将代理到上游定义的目标。\u003cstrong\u003e可以不存在upstream, 相当于没有负载均衡\u003c/strong\u003e.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eTarget\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e目标IP地址/主机名，其端口表示后端服务的实例。每个上游都可以有多个target,并且可以动态添加Target。\u003c/p\u003e\n\u003cp\u003e由于上游维护Target的更改历史记录，因此无法删除或者修改Target。要禁用目标，请发布一个新的Targer weight=0,或者使用DELETE来完成相同的操作。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eService\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e顾名思义，服务实体是每个上游服务的抽象。服务的示例是数据转换微服务，计费API等。\u003c/p\u003e\n\u003cp\u003e服务的主要属性是它的URL（其中，Kong应该代理流量），其可以被设置为单个串或通过指定其protocol， host，port和path。\u003c/p\u003e\n\u003cp\u003e服务与路由相关联（服务可以有许多与之关联的路由）。路由是Kong的入口点，并定义匹配客户端请求的规则。一旦匹配路由，Kong就会将请求代理到其关联的服务。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eRoute\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e路由实体定义规则以匹配客户端的请求。\u003cstrong\u003e每个Route与一个Service相关联\u003c/strong\u003e，一个服务可能有多个与之关联的路由。与给定路由匹配的每个请求都将代理到其关联的Service上。\u003c/p\u003e\n\u003cp\u003eService 和 Route 的组合（以及它们之间的关注点分离）提供了一种强大的路由机制，通过它可以在Kong中定义细粒度的入口点，从而使基础架构路由到不同上游服务。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eConsumer\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConsumer 对象表示服务的使用者或者用户。您可以依靠Kong作为主数据库存储，也可以将使用者列表与数据库映射，以保持Kong与现有的主数据存储之间的一致性。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePlugin\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e插件实体表示将在HTTP请求/响应生命周期期间执行的插件配置。它是如何为在Kong后面运行的服务添加功能的，例如身份验证或速率限制。\u003c/p\u003e\n\u003cp\u003e将插件配置添加到服务时，客户端向该服务发出的每个请求都将运行所述插件。如果某个特定消费者需要将插件调整为不同的值，您可以通过创建一个单独的插件实例，通过service和consumer字段指定服务和消费者 。\u003c/p\u003e\n\u003cp\u003e上述总结引用\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnkirito.moe/kong-introduction/\"\u003ekong-introduction\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e说实话，在CloudNavi中的很多软件都或多或少的会引入一些名词，特别尴尬的是有些名词名字相同但是所表达的意思却完全不一样，比如上面的service，在Kubernetes也有service这个对象，但是表达的是两种不相同的事项，到后来这类东西学的越多，就越容器混淆.\u003c/p\u003e\n\u003cp\u003e详解可以参考官网\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.konghq.com/2.1.x/admin-api/\"\u003eadmin-api\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e总结起来流量的走向,\u003cstrong\u003eclient –\u0026gt; router –\u0026gt; service –\u0026gt; [upstream] –\u0026gt; target\u003c/strong\u003e, 可以使用下面的图来表示,非常清晰:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200107141102186.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e后面会重点围绕这些资源对象来测试kong的使用\u003c/p\u003e\n\u003ch3 id=\"API使用\"\u003e\u003ca href=\"#API使用\" class=\"headerlink\" title=\"API使用\"\u003e\u003c/a\u003eAPI使用\u003c/h3\u003e\u003cp\u003ekong做为一个基于openresty实现的api网关, 可以通过API直接管理对象，比如要生成以下的一段nginx配置\u003c/p\u003e\n\u003cfigure class=\"highlight yaml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eupstream\u003c/span\u003e \u003cspan class=\"string\"\u003ehello\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003eserver\u003c/span\u003e \u003cspan class=\"string\"\u003elocalhost:3000\u003c/span\u003e \u003cspan class=\"string\"\u003eweight=100;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003eserver\u003c/span\u003e \u003cspan class=\"string\"\u003elocalhost:3001\u003c/span\u003e \u003cspan class=\"string\"\u003eweight=50;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eserver\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003elisten\u003c/span\u003e  \u003cspan class=\"number\"\u003e80\u003c/span\u003e\u003cspan class=\"string\"\u003e;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003elocation\u003c/span\u003e \u003cspan class=\"string\"\u003e/hello\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"string\"\u003eproxy_pass\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://hello;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e上面的nginx规则如果使用kong的api实现的话,对应以下接口\u003c/p\u003e\n\u003cfigure class=\"highlight yaml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 8001为kong admin的http监听端口\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 创建upstream,名字为hello\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003e-X\u003c/span\u003e \u003cspan class=\"string\"\u003ePOST\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8001/upstreams\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;name=hello\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 为upstream, 创建两个target,分别设置权重\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003e-X\u003c/span\u003e \u003cspan class=\"string\"\u003ePOST\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8001/upstreams/hello/targets\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;target=localhost:3000\u0026#34;\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;weight=100\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003e-X\u003c/span\u003e \u003cspan class=\"string\"\u003ePOST\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8001/upstreams/hello/targets\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;target=localhost:3001\u0026#34;\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;weight=50\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 创建service\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003e-X\u003c/span\u003e \u003cspan class=\"string\"\u003ePOST\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8001/services\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;name=hello\u0026#34;\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;host=hello\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 成功后会返回service.id\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e8695cc65-16c1-43b1-95a1-5d30d0a50409\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 为service创建路由\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003e-X\u003c/span\u003e \u003cspan class=\"string\"\u003ePOST\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8001/routes\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;paths[]=/hello\u0026#34;\u003c/span\u003e \u003cspan class=\"string\"\u003e--data\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#34;service.id=8695cc65-16c1-43b1-95a1-5d30d0a50409\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 测试路由\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003ecurl\u003c/span\u003e \u003cspan class=\"string\"\u003ehttp://localhost:8000/hello/hi\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里只是展示一下kong admin的使用，在实际使用中， 并不会直接通过api来生成对象，更多的是\u003ccode\u003e动态场景\u003c/code\u003e，要不然效率太差.\u003c/p\u003e\n\u003cp\u003ekong admin API还可以通过UI工具来直接管理, 比如最常用的\u003ccode\u003ekonga\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"关于service\"\u003e\u003ca href=\"#关于service\" class=\"headerlink\" title=\"关于service\"\u003e\u003c/a\u003e关于service\u003c/h3\u003e\u003cp\u003e上面简单介绍了下kong的常用对象，做为api网关，一般都处于流量的最前端，那自然少不了路由的匹配, 因此Route这个对象还是比较好理解的。\u003c/p\u003e\n\u003cp\u003eRoute匹配之后那要转到哪个服务进行响应呢? 这就是service, 但是这个service并不是真正相应请求的实体，以官方的说法，service是每个上游服务(upstream)的抽象，是个抽象的概念.\u003c/p\u003e\n\u003cp\u003etarget才是真正对请求进行响应的, 在kubernetes就是部署在pods中的程序\u003c/p\u003e\n\u003cp\u003e而upstream则是个loadbalance，对多个target进行lb, 可以指定多种lb方式，健康检查机制等.\u003c/p\u003e\n\u003cp\u003e对于kong service与kubernetes service的区别, 以官方的一张图\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Kong/kubernetes-ingress-controller/blob/main/docs/concepts/design.md\"\u003e解释\u003c/a\u003e: \u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200811213605.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s go through how Kubernetes resources are being mapped to Kong’s configuration:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eAn \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/services-networking/ingress/\"\u003eIngress\u003c/a\u003e resource in Kubernetes defines a set of rules for proxying traffic. These rules corresponds to the concept of Route in Kong.\u003c/p\u003e\n\u003cp\u003ekubernetes中的ingress定义了流量转发规则，这些规则对kong中的路由进行响应\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eA \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/services-networking/service/\"\u003eService\u003c/a\u003e inside Kubernetes is a way to abstract an application that is running on a set of pods. This maps to two objects in Kong: Service and Upstream. The service object in Kong holds the information on the protocol to use to talk to the upstream service and various other protocol specific settings. The Upstream object defines load balancing and healthchecking behavior.\u003c/p\u003e\n\u003cp\u003eKubernetes内的\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/services-networking/service/\"\u003eService\u003c/a\u003e是在一组Pod上运行的应用程序的方法的抽象。这映射到Kong中的两个对象：服务和上游。 Kong中的服务对象保存有关用于与上游服务进行通信的协议信息以及各种其他特定于协议的设置。上游对象定义负载平衡和运行状况检查行为\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ePods associated with a Service in Kubernetes map as a Target belonging to the Upstream (the upstream corresponding to the Kubernetes Service) in Kong. Kong load balances across the Pods of your service. \u003cstrong\u003eThis means that all requests flowing through Kong are not directed via kube-proxy but directly to the pod\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eKubernetes中与服务相关联的Pod映射为Kong中上游（与Kubernetes Service对应的上游）的目标。 Kong在您的服务Pod中平衡负载。这意味着所有流经Kong的请求都不会通过kube-proxy定向，而是直接定向到pod\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里有个重点是: kong中的请求到达最终的端点target并没有通过Kube-proxy，因此不存在需要遍历iptables规则，因此会对kubernetes原生的service效率会高\u003c/p\u003e\n\u003cp\u003e另一个疑问是: kong是否可以不需要service？从route匹配后直接到upstream?\u003c/p\u003e\n\u003cp\u003ekong中的service还是包含了一些信息的, 比如\u003ccode\u003eprotocol, host, port and path\u003c/code\u003e等信息，如果没有这层信息, 请求从route直接到达upstream后是不知道到底是http还是https的，就相当需要把这段代码:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eserver {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    listen  80; \u003cspan class=\"comment\"\u003e#\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e加到upstream中\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eupstream hello {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    server localhost:3000 weight=100;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    server localhost:3001 weight=50;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e而kong又是基于nginx的，这样调整的话就与nginx的语法不相符了,因此service是有必要的.\u003c/p\u003e\n\u003cp\u003ekong还是比较强大的，比如在Kubernetes中做为ingress使用、如何集成插件化对流量进行管理等等，这里只是简单介绍了一下kong，有个整体的理解.\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Kong/kubernetes-ingress-controller/blob/main/docs/concepts/design.md\"\u003ehttps://github.com/Kong/kubernetes-ingress-controller/blob/main/docs/concepts/design.md\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnkirito.moe/kong-introduction/\"\u003ehttps://www.cnkirito.moe/kong-introduction/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.konghq.com/2.1.x/admin-api/\"\u003ehttps://docs.konghq.com/2.1.x/admin-api/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2020-08-15T20:10:53+08:00",
  "Author": "Z.S.K."
}