{
  "Source": "izsk.me",
  "Title": "Prometheus学习(MetricTypes)",
  "Link": "https://izsk.me/2019/12/28/prometheus-4-types/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e在学习prometheus的时候，相信大家也会对prometheus里的各种数据类型及内置函数有很多疑惑, 为了加深印象来记录下工作中常用到的函数，在这之前, 先来温故下prometheus中的4种metric types.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003ch3 id=\"数据模型\"\u003e\u003ca href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"\u003e\u003c/a\u003e数据模型\u003c/h3\u003e\u003cp\u003eprometheus中所有的数据都是时序流, 我们在prometheus的ui中看到的数据虽然没有看到时间戳, 但在prometheus底层存储中是存在时间戳与之对应, 简单来说, prometheus的数据模型就是\u003ccode\u003eMetrics+labels+timestamp\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200408212749.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ealertmanager_alerts\u003c/code\u003e为\u003ccode\u003emetrics key\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003einstance\u003c/code\u003e、\u003ccode\u003ejob\u003c/code\u003e等这些都是\u003ccode\u003elabels\u003c/code\u003e，可以理解为查询时的条件\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalue\u003c/code\u003e为这条metric的值\u003c/p\u003e\n\u003cp\u003e注意: \u003cstrong\u003e在prometheus中value只能是float类型的数值, 不可以是其它值\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"监控项类型\"\u003e\u003ca href=\"#监控项类型\" class=\"headerlink\" title=\"监控项类型\"\u003e\u003c/a\u003e监控项类型\u003c/h3\u003e\u003cp\u003e虽然prometheus的value只能是float类型的数值, 但是这个value是有一种数据类型与之对应的, prometheus中存在4种监控项类型, 官方文档在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/concepts/metric_types/\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003ch4 id=\"gauge\"\u003e\u003ca href=\"#gauge\" class=\"headerlink\" title=\"gauge\"\u003e\u003c/a\u003egauge\u003c/h4\u003e\u003cp\u003egauge表示\u003cstrong\u003e可以任意波动的单一值, 没有规律\u003c/strong\u003e, 直观的例子就是可以表示机器的网卡流量, 因为你无法预料在下一秒的有多少入口流量 或多或少.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200408213836.png\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"counter\"\u003e\u003ca href=\"#counter\" class=\"headerlink\" title=\"counter\"\u003e\u003c/a\u003ecounter\u003c/h4\u003e\u003cp\u003ecounter为\u003cstrong\u003e计数器,只增不减\u003c/strong\u003e 用于只增不减的场合,直观的例子机器的开机时t、长nginx的请求数等, 在某个时刻之后, 这个数只会一直增长而不会减少, 但是可以允许被重置为0\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200408214317.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e上面两个类型比较好理解, 难理解的histogram与summary.\u003c/p\u003e\n\u003ch4 id=\"histogram\"\u003e\u003ca href=\"#histogram\" class=\"headerlink\" title=\"histogram\"\u003e\u003c/a\u003ehistogram\u003c/h4\u003e\u003cp\u003ehistogram表示\u003cstrong\u003e累积直方图\u003c/strong\u003e， 主要用于表示一段时间范围内对数据进行采样（通常是请求持续时间或响应大小),并将其计入可配置的存储桶（bucket）中，并能够对其指定区间以及总数进行统计\u003c/p\u003e\n\u003cp\u003e所以, 在很多的metric key中如果看到xxx_bucket时, 大部分表示这条记录的类型为histogram.\u003c/p\u003e\n\u003cp\u003e很直观的一个例子, 统计ingress_nginx中请求的响应时间(单位:秒)\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enginx_ingress_controller_response_duration_seconds_bucket\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200408215430.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e看到这可能会有人问, 这个结果是不是有问题, 这个\u003ccode\u003ele\u003c/code\u003e是什么意思?\u003c/p\u003e\n\u003cp\u003e首先说一下这个\u003ccode\u003ele\u003c/code\u003e,它并不是一个单位,而是表示bucket的一个区间, 这个le是在ingress_nginx的代码中定义的.\u003c/p\u003e\n\u003cp\u003e另一个要明白的是, histogram是\u003ccode\u003e累积直方图\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e因此上图就很容易理解了\u003c/p\u003e\n\u003cp\u003eIngress_nginx代码中定义了所有bucket的区间值(当然，作者可以随便定义), 所有请求产生的响应时间都会落在这些区间之内。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e响应时间\u0026lt;0.005的请求个数为24\u003c/li\u003e\n\u003cli\u003e响应时间\u0026lt;0.01的请求个数为24, 包括\u0026lt;0.005,也就是说没有请求的响应时间在 0.005与0.01之间\u003c/li\u003e\n\u003cli\u003e响应时间\u0026lt;0.025的请求个数为24,包含\u0026lt;0.01的区间, 也就是说没有请求的响应时间在0.01与0.025之间\u003c/li\u003e\n\u003cli\u003e响应时间\u0026lt;0.05的请求个数为30, 包含\u0026lt;0.025的区间, 也就是说请求的响应时间有6个落在0.025与0.05之间\u003c/li\u003e\n\u003cli\u003e…\u003c/li\u003e\n\u003cli\u003e响应时间\u0026lt;0.25的请求个数为27034, 包含\u0026lt;0.1的区间\u003c/li\u003e\n\u003cli\u003e…\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e从这个过程就可以知道为什么叫\u003ccode\u003e累积直方图了\u003c/code\u003e, 从上面的例子来总结,\u003cstrong\u003e大部分的请求都落在0.1s到0.25s之间\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这里要注意一下\u003ccode\u003ele=+lnf\u003c/code\u003e这条记录, 这个其实表示所有的记录, \u003ccode\u003elnf\u003c/code\u003e表示最大的bucket的往上, 这里是10s以上的记录,从上图可以看到, 不存在响应时间大于10s, 正常也不应该有\u003c/p\u003e\n\u003cp\u003e同时histogram也提供\u0026lt;basename\u0026gt;_sum，\u0026lt;basename\u0026gt;_count这两个指标\u003c/p\u003e\n\u003cp\u003e总结来就: \u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026lt;basename\u0026gt;_count就是一个计数器, 它只会增加,表示次数\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u0026lt;basename\u0026gt;_sum也可以是一个计数器,它表示监控项对应的值的总和\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e先来看一下\u003ccode\u003enginx_ingress_controller_response_duration_seconds_count\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/image-20200409111003966.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e 会发现这3条记录value之和与\u003ccode\u003ele={+lnf}\u003c/code\u003e的值是相等的, 因此count表示\u003ccode\u003e对采样点的次数累计和\u003c/code\u003e,这里也就是请求总数\u003c/p\u003e\n\u003cp\u003e而``nginx_ingress_controller_response_duration_seconds_sum`\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409112322.png\"/\u003e\u003c/p\u003e\n\u003cp\u003esum表示的是\u003ccode\u003e所有value的总和\u003c/code\u003e,这个很好理解\u003c/p\u003e\n\u003cp\u003e因此，如果想计算最近5分钟内的平均请求持续时间\u003c/p\u003e\n\u003cp\u003e可以使用以下表达式:\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003erate(nginx_ingress_controller_response_duration_seconds_sum[5m]) / rate(nginx_ingress_controller_response_duration_seconds_count[5m])\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\n\n\u003cp\u003e同时 histogram也是可以计算分位数, 使用\u003ccode\u003ehistogram_quantile\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ePrometheus 通过 \u003ccode\u003ehistogram_quantile\u003c/code\u003e 函数来计算分位数（quantile），而且是一个预估值，并不完全准确，因为这个函数是假定每个区间内的样本分布是线性分布来计算结果值的。预估的准确度取决于 bucket 区间划分的粒度，粒度越大，准确度越低\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehistogram_quantile(φ float, b instant-vector)\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e假如，要计算95%的响应时间落在哪个区间可以使用以下命令\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ehistogram_quantile(0.95, sum(rate(nginx_ingress_controller_response_duration_seconds_bucket{path=~\u0026#34;/sensego/v2.0/mingyuan\u0026#34;,status=\u0026#34;200\u0026#34;}[1800m])) by (le))\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409115919.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e会发现大约在0.23s\u003c/p\u003e\n\u003cp\u003e注意: 在数据量大的情况下，\u003ccode\u003ehistogram_quantile\u003c/code\u003e计算可能会消耗大量CPU, 因为它是在服务端实时计算的.\u003c/p\u003e\n\u003cp\u003e这个函数的源码在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/prometheus/prometheus/blob/master/promql/quantile.go\"\u003e这里\u003c/a\u003e\u003c/p\u003e\n\u003ch4 id=\"summary\"\u003e\u003ca href=\"#summary\" class=\"headerlink\" title=\"summary\"\u003e\u003c/a\u003esummary\u003c/h4\u003e\u003cp\u003esummary表示摘要数据, 这个跟histogram比较想像, 反映的都是统计类数据\u003c/p\u003e\n\u003cp\u003esummary主要用于表示一段时间内数据采样结果（通常是请求持续时间或响应大小），\u003ccode\u003e它直接存储了 quantile 数据，而不是根据统计区间计算出来的\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprometheus_target_interval_length_seconds\u003c/code\u003e表示目标抓取所用时间\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409112817.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e很大的一个区别是\u003ccode\u003equantile\u003c/code\u003e, 翻译过来就是分位数, 这个区间也是在源码里定义\u003c/p\u003e\n\u003cp\u003e上面的图表示的含义是:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e有1%的目标抓取时间为19.936946996\u003c/li\u003e\n\u003cli\u003e有5%的目标抓取时间为19.999956628\u003c/li\u003e\n\u003cli\u003e有50%的目标抓取时间为20.000021361\u003c/li\u003e\n\u003cli\u003e有90%的目标抓取时间为20.00006137\u003c/li\u003e\n\u003cli\u003e有99%的目标抓取时间为20.071892568\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e从这里可以看出,99%的时间都是20s内, 跟设置的interval=20s基本符合.\u003c/p\u003e\n\u003cp\u003e同时summary也提供\u0026lt;basename\u0026gt;_sum，\u0026lt;basename\u0026gt;_count这两个指标,这个跟histogram差不多\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprometheus_target_interval_length_seconds_sum\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409114922.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eprometheus_target_interval_length_seconds_count\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200409114941.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e需要注意的是: \u003cstrong\u003e不能对Summary产生的quantile值进行aggregation运算（例如sum, avg等）\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"summary与histogram区别\"\u003e\u003ca href=\"#summary与histogram区别\" class=\"headerlink\" title=\"summary与histogram区别\"\u003e\u003c/a\u003esummary与histogram区别\u003c/h4\u003e\u003cp\u003e从上面可以发现Summary和histogram是比较类似，在使用上要如何区分呢？prometheus上有篇post专门解释了这两个的区别, \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/practices/histograms/\"\u003e详情\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e首先要明白是Summary的quantile计算是在数据上报的时候(简单来说就是在客户端就计算好的)就已经计算好的，需要在定义数据指标的时候就指定quantile的值，因为是数据上报计算的quantile，所以不支持包含数据过滤和聚合的quantile计算\u003c/p\u003e\n\u003cp\u003e因此对于分位数的计算而言，Summary在通过PromQL进行查询时有更好的性能表现，而Histogram则会消耗更多的资源。反之对于客户端而言Histogram消耗的资源更少。在选择这两种方式时用户应该按照自己的实际场景进行选择.  Summary 结构有频繁的全局锁操作，对高并发程序性能存在一定影响。histogram仅仅是给每个桶做一个原子变量的计数就可以了，而summary要每次执行算法计算出最新的X分位value是多少，算法需要并发保护。会占用客户端的cpu和内存\u003c/p\u003e\n\u003cp\u003ehistogram不能得到精确的分为数，设置的bucket不合理的话，误差会非常大\u003c/p\u003e\n\u003cp\u003e两条经验法则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e如果需要汇总，请选择直方图。\u003c/li\u003e\n\u003cli\u003e否则，如果您对将要观察的值的范围和分布有所了解，请选择直方图。无论值的范围和分布如何，如果需要准确的分位数，请选择摘要\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/concepts/metric_types/\"\u003ehttps://prometheus.io/docs/concepts/metric_types/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://prometheus.io/docs/practices/histograms/\"\u003ehttps://prometheus.io/docs/practices/histograms/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.yangcs.net/posts/prometheus-histograms/\"\u003ehttps://www.yangcs.net/posts/prometheus-histograms/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://cloud.tencent.com/developer/news/319419\"\u003ehttps://cloud.tencent.com/developer/news/319419\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/prometheus/prometheus/blob/master/promql/quantile.go\"\u003ehttps://github.com/prometheus/prometheus/blob/master/promql/quantile.go\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2019-12-28T19:30:53+08:00",
  "Author": "Z.S.K."
}