{
  "Source": "izsk.me",
  "Title": "Opentelemetry调研实践二(opentelemetry架构及名词介绍)",
  "Link": "https://izsk.me/2021/10/27/OpenTelemetry-Introduct/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e历史文章:\u003c/p\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/2021/10/19/OpenTelemetry-what-is-observability/\"\u003e可观测性到底在说什么\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/2021/10/19/OpenTelemetry-what-is-observability/\"\u003e上文\u003c/a\u003e简单说了下可观测性，然后引出了\u003cstrong\u003e主角: opentelemetry\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e可观测性一个很重要的领域\u003ccode\u003eTrace\u003c/code\u003e有两个业界标杆: 一个是\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opentracing.io/\"\u003eOpenTracing\u003c/a\u003e，另一个\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opencensus.io/\"\u003eOpenCensus\u003c/a\u003e，OpenTracing其实是一个规范，jeager就是基于opentracing实现的开源工具，而OpenCensus则是由google开源的度量工具，简单来说，这两者在可观测性领域功能高度重合，因此，在CNCF主导下进行了合并形成opentelemetry项目，OpenTracing跟penCensus共同推进opentelemetry，两者的官网也赫赫表达基本不再维护，同时opentelemetry也致力于trace、logging、metrics间的关联性.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003ch3 id=\"OpenTelemetry核心工作\"\u003e\u003ca href=\"#OpenTelemetry核心工作\" class=\"headerlink\" title=\"OpenTelemetry核心工作\"\u003e\u003c/a\u003eOpenTelemetry核心工作\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e1.规范的制定和协议的统一，规范包含数据传输、API的规范，协议的统一包含：HTTP W3C的标准支持及GRPC等框架的协议标准\u003c/li\u003e\n\u003cli\u003e2.多语言SDK的实现和集成，用户可以使用SDK进行代码自动注入和手动埋点，同时对其他三方库（Log4j、LogBack等）进行集成支持\u003c/li\u003e\n\u003cli\u003e3.数据收集系统的实现，当前是基于OpenCensus Service的收集系统，包括Agent和Collector。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e由此可见，OpenTelemetry的自身定位很明确：数据采集和标准规范的统一，对于数据如何去使用、存储、展示、告警，官方是不涉及的\u003c/p\u003e\n\u003ch3 id=\"OpenTelemetry状态\"\u003e\u003ca href=\"#OpenTelemetry状态\" class=\"headerlink\" title=\"OpenTelemetry状态\"\u003e\u003c/a\u003eOpenTelemetry状态\u003c/h3\u003e\u003cp\u003eOpenTelemetry要解决的\u003cstrong\u003e是对可观测性的大一统\u003c/strong\u003e，它提供了一组API和SDK来标准化遥测数据的采集和传输，opentelemetry并不想对所有的组件都进行重写，而是最大程度复用目前业界在各大领域常用工具，通过提供了一个安全，厂商中立的能用协议、组件，这样就可以按照需要形成pipeline将数据发往不同的后端。\u003c/p\u003e\n\u003cp\u003e由于opentelemetry提出时间并不长，大家可以从\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opentelemetry.io/status/\"\u003estatus\u003c/a\u003e中可以看到最新的状态，可以看到，目前只有Tracing实现了1.0的release，而Metrics处于\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/document-status.md#feature-freeze\"\u003efeature-freeze\u003c/a\u003e，这个状态说的是metrics目前暂不接受在metrics中添加新的功能，以便技术委员会优先实现其它功能，还未达到stable状态，而在Logging则还处于草案阶段，opentelemetry官方的解释是日志相对存在体量大，延时高的问题，相对棘手且优先级对比另两者不高。\u003c/p\u003e\n\u003cp\u003etracing已经在2021上半年实现了stable,目前官方给出的时间线是在2021下半年实现metrics的stable，在2022实现logging的stable.\u003c/p\u003e\n\u003cp\u003e为什么tracing是首先stable的，作者个人感觉可能是tracing目前在业界普及度还不够吧，而像metrics方面，prometheus早已成了业务标准\u003c/p\u003e\n\u003ch3 id=\"OpenTelemetry架构\"\u003e\u003ca href=\"#OpenTelemetry架构\" class=\"headerlink\" title=\"OpenTelemetry架构\"\u003e\u003c/a\u003eOpenTelemetry架构\u003c/h3\u003e\u003cp\u003e这里作者还要重点说明的是，就算是Service Mesh中对于链路追踪也普遍有一个问题: 就是无论你在数据平面如何做流量劫持，如何透传信息，以及如何生成或者继承Span，\u003cstrong\u003e入口流量和出口流量之间的链路都存在无法串联的问题\u003c/strong\u003e， 这个问题要解决还是需要服务来埋点透传，将链路信息透传到下一次请求当中去，这个问题是无法避免的，而OpenTelemetry的后续推行，可以解决这方面的标准化问题。\u003c/p\u003e\n\u003cp\u003e来看一张图:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20210930101301.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e注: 由于logging还处于草案状态，这里没有描述出来。\u003c/p\u003e\n\u003cp\u003eopentelemetry也是个插件式的架构，针对不同的开发语言会有相应的Client组件，叫\u003cstrong\u003eInstrumenttation\u003c/strong\u003e，也就是在代码中埋点调用的api/sdk采集telemetry数据\u003c/p\u003e\n\u003cp\u003e将获取到的数据pull/push到上图中定义好的\u003cstrong\u003epipeline\u003c/strong\u003e中,这部分是可高度定制的, opentelemetry提供统一的\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-specification\"\u003eSpecification\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003epipeline\u003c/strong\u003e就是\u003cstrong\u003eCollection\u003c/strong\u003e的实现，大概分为3部分，这里简单介绍一下，后期在详解collection的配置文件时再进行展开:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003ereceivers(接收者): 定义从client端的数据要以何种数据模型进行接收, 支持很多种数据模型.\u003c/li\u003e\n\u003cli\u003eprocessors: 将receivers的数据进行某些处理，比如批量、性能分析等.\u003c/li\u003e\n\u003cli\u003eexporters: 将processors后的数据导出到特定的后端，比如metrics数据存储到prometheus中.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e整个流程是pipeline式的,可以根据实际情况自定义pipeline,所以说collector定制性很高.\u003c/p\u003e\n\u003cp\u003e这里要说明的是receivers、processors、exporters有官方的定义\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-collector\"\u003eopentelemetry-collector\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e但是也有很多开源产品基于opentelemetry-collector提供相应的实现,详细列表参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-collector-contrib\"\u003eopentelemetry-collector-contrib\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e总结一下，opentelemetry按功能分层来说,可以分为：采集器（Instrument）、发送器（TransPort）、收集器（Collector）、存储（Srotage）、展示（API\u0026amp;UI）,这跟其它APM系统是类似的，只是opentelemetry在很多组件上选择了利用而不是重新造轮子.\u003c/p\u003e\n\u003cp\u003e在opentelemetry里面的名词也是非常多的，有必要把一些常用的名词给大家解释一下.\u003c/p\u003e\n\u003cp\u003e建议大家多多阅读官方文档，也可参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://jckling.github.io/2021/04/02/Jaeger/OpenTelemetry%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB/\"\u003eOpenTelemetry 规范阅读\u003c/a\u003e，里面详细介绍了各个名词的含义，对大家理解有帮助\u003c/p\u003e\n\u003ch3 id=\"OpenTelemetry核心概念\"\u003e\u003ca href=\"#OpenTelemetry核心概念\" class=\"headerlink\" title=\"OpenTelemetry核心概念\"\u003e\u003c/a\u003eOpenTelemetry核心概念\u003c/h3\u003e\u003cp\u003e以下名词引用官方文档\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opentelemetry.io/docs/concepts/components/\"\u003ecomponents\u003c/a\u003e的翻译\u003c/p\u003e\n\u003ch4 id=\"Proto\"\u003e\u003ca href=\"#Proto\" class=\"headerlink\" title=\"Proto\"\u003e\u003c/a\u003eProto\u003c/h4\u003e\u003cp\u003e语言无关的接口类型。描述很多下文组件的定义。\u003c/p\u003e\n\u003cp\u003e####Client\u003c/p\u003e\n\u003cp\u003e其实就是client, 应用调用OpenTelemetry API的client, 语言相关的代码封装库，引入trace、metrics、log等\u003c/p\u003e\n\u003ch4 id=\"API-x2F-SDK\"\u003e\u003ca href=\"#API-x2F-SDK\" class=\"headerlink\" title=\"API/SDK\"\u003e\u003c/a\u003eAPI/SDK\u003c/h4\u003e\u003cp\u003eAPI 包由用于检测的横切公共接口组成，导入到第三方库和应用程序代码的 OpenTelemetry 客户端的任何部分都被认为是 API 的一部分,\u003c/p\u003e\n\u003cp\u003e而SDK是API的具体实现，这部分是语言相关的.\u003c/p\u003e\n\u003ch4 id=\"Specification\"\u003e\u003ca href=\"#Specification\" class=\"headerlink\" title=\"Specification\"\u003e\u003c/a\u003eSpecification\u003c/h4\u003e\u003cp\u003eSpecification则是定义了API/SDK及数据模型，所有包含第三方实现的都需要遵循spec定义的规范\u003c/p\u003e\n\u003ch4 id=\"Semantic-Conventions\"\u003e\u003ca href=\"#Semantic-Conventions\" class=\"headerlink\" title=\"Semantic Conventions\"\u003e\u003c/a\u003eSemantic Conventions\u003c/h4\u003e\u003cp\u003eOpenTelemetry 项目保证所有的instrumentation(不论任何语言)都包含相同的语义信息\u003c/p\u003e\n\u003ch4 id=\"Resource\"\u003e\u003ca href=\"#Resource\" class=\"headerlink\" title=\"Resource\"\u003e\u003c/a\u003eResource\u003c/h4\u003e\u003cp\u003eresource附加于某个process产生的所有trace的键值对，在初始化阶段指定并传递到collector中\u003c/p\u003e\n\u003ch4 id=\"Baggage\"\u003e\u003ca href=\"#Baggage\" class=\"headerlink\" title=\"Baggage\"\u003e\u003c/a\u003eBaggage\u003c/h4\u003e\u003cp\u003e为添加在metrics、log、traces中的注解信息，键值对需要唯一，无法更改\u003c/p\u003e\n\u003ch4 id=\"Propagators\"\u003e\u003ca href=\"#Propagators\" class=\"headerlink\" title=\"Propagators\"\u003e\u003c/a\u003ePropagators\u003c/h4\u003e\u003cp\u003e传播器，比如在多进程的调用中，开启传播器用于跨服务传播spanContext\u003c/p\u003e\n\u003ch4 id=\"Attributes\"\u003e\u003ca href=\"#Attributes\" class=\"headerlink\" title=\"Attributes\"\u003e\u003c/a\u003eAttributes\u003c/h4\u003e\u003cp\u003e其实就是tag, 可以给span添加metadata数据,\u003ccode\u003eSetAttributes\u003c/code\u003e属性可以多次添加，不存在就添加，存在就覆盖\u003c/p\u003e\n\u003ch4 id=\"Events\"\u003e\u003ca href=\"#Events\" class=\"headerlink\" title=\"Events\"\u003e\u003c/a\u003eEvents\u003c/h4\u003e\u003cp\u003e类似于日志, 比如在trace中嵌入请求体跟响应体\u003c/p\u003e\n\u003ch4 id=\"Collector\"\u003e\u003ca href=\"#Collector\" class=\"headerlink\" title=\"Collector\"\u003e\u003c/a\u003eCollector\u003c/h4\u003e\u003cp\u003e虽然Collector翻译过来叫接收，但它负责遥测数据源的接收、处理和导出三部分，提供了与供应商无关的实现\u003c/p\u003e\n\u003cp\u003ecollector是个实体组件，有两个部署方案，可以ds进行部署，各个host负责该host上的遥测数据\u003c/p\u003e\n\u003cp\u003e或者以deployment的方式部署，接收所有遥测数据\u003c/p\u003e\n\u003cp\u003e其中，Metrics、Logging、Trace、Baggage叫\u003cstrong\u003eSignal\u003c/strong\u003e,以上的对象中除了\u003cstrong\u003eCollector\u003c/strong\u003e,其它几个由于没有具体部署对象，名词一多理解起来还是比较费劲，需要多翻官方文档\u003c/p\u003e\n\u003cp\u003e这里重点介绍Collector，在介绍Collector前，先来介绍一个协议。\u003c/p\u003e\n\u003ch3 id=\"OpenTelemetry协议-OTLP\"\u003e\u003ca href=\"#OpenTelemetry协议-OTLP\" class=\"headerlink\" title=\"OpenTelemetry协议-OTLP\"\u003e\u003c/a\u003eOpenTelemetry协议-OTLP\u003c/h3\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/protocol\"\u003eOTLP(OpenTelemetry Protocol)\u003c/a\u003e是一种协议，该此协议用于将应用产生的遥感数据发送到 OpenTelemetry Collector.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.github.com/open-telemetry/opentelemetry.io/main/iconography/Otel_Collector.svg\"/\u003e\u003c/p\u003e\n\u003cp\u003eotlp是opentelemetry中比较核心的存在，在遥测数据及Collector之间制定了包括编码(encoding)、传输(transport)、传递(delivery)等协议\u003c/p\u003e\n\u003cp\u003e目前OTLP协议在数据源的状态也是不一样的.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTracing: \u003cstrong\u003eStable\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eMetrics: \u003cstrong\u003eStable\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003eLogs: \u003cstrong\u003eBeta\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eotlp也对http、grpc进行了较好的开箱即用的封装.\u003c/p\u003e\n\u003cp\u003e另外，OTEP(OpenTelemetry Enhancement Proposal)是加强版的otlp, 目前处于不稳定状态，这里不展开.\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e参考文章:\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://codingnote.cc/p/246692\"\u003ehttps://codingnote.cc/p/246692\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opentelemetry.io/registry\"\u003ehttps://opentelemetry.io/registry\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://opentelemetry.io/docs/concepts/components\"\u003ehttps://opentelemetry.io/docs/concepts/components\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://signoz.io/blog/opentelemetry-kubernetes\"\u003ehttps://signoz.io/blog/opentelemetry-kubernetes\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.infoq.cn/article/pky4szfhbvifxrcriqcr\"\u003ehttps://www.infoq.cn/article/pky4szfhbvifxrcriqcr\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-collector\"\u003ehttps://github.com/open-telemetry/opentelemetry-collector\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-collector-contrib\"\u003ehttps://github.com/open-telemetry/opentelemetry-collector-contrib\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://tech.ipalfish.com/blog/2020/12/29/design-dimensions-of-tracing-systems\"\u003ehttps://tech.ipalfish.com/blog/2020/12/29/design-dimensions-of-tracing-systems\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/protocol\"\u003ehttps://github.com/open-telemetry/opentelemetry-specification/tree/main/specification/protocol\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://jckling.github.io/2021/04/02/Jaeger/OpenTelemetry%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB\"\u003ehttps://jckling.github.io/2021/04/02/Jaeger/OpenTelemetry%20%E8%A7%84%E8%8C%83%E9%98%85%E8%AF%BB\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2021-10-27T16:30:53+08:00",
  "Author": "Z.S.K."
}