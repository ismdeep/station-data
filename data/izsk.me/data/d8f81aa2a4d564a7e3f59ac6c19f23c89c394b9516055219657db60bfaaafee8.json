{
  "Source": "izsk.me",
  "Title": "Kubernetes学习(kubectl的工作机制分析)",
  "Link": "https://izsk.me/2021/01/10/Kubernetes-how-does-kubectl-work/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e看到一篇关于kubectl运行的机制，觉得写得非常不错，图文并茂很形象，就翻译成了中文记录一下，原文地址: \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://erkanerol.github.io/post/how-kubectl-exec-works/\"\u003ehttps://erkanerol.github.io/post/how-kubectl-exec-works/\u003c/a\u003e\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003cp\u003e上周五，我的一位同事问了一个有关如何使用go-client在pod中执行命令的问题。我不知道答案，我注意到我从未想过“ kubectl exec”中的机制。我有一些想法，但是我不100％确定。我需要通过实践来找到答案，在阅读了一些博客，文档和源代码后，我学到了很多东西。在这篇博客中，我将分享我的理解和发现。\u003c/p\u003e\n\u003cp\u003e如果出现问题，可在以下频道找到我 :\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/erkan_erol\"\u003ehttps://twitter.com/erkan_erol\u003c/a\u003e_\u003c/p\u003e\n\u003ch2 id=\"Setup\"\u003e\u003ca href=\"#Setup\" class=\"headerlink\" title=\"Setup\"\u003e\u003c/a\u003eSetup\u003c/h2\u003e\u003cp\u003e我克隆了\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/ecomm-integration-ballerina/kubernetes-cluster%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8MacBook%E4%B8%AD%E5%88%9B%E5%BB%BAk8s%E9%9B%86%E7%BE%A4%E3%80%82%E6%88%91%E4%BF%AE%E6%94%B9kubelet%E9%85%8D%E7%BD%AE%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84IP%E5%9C%B0%E5%9D%80%EF%BC%8C%E5%9B%A0%E4%B8%BA%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E4%B8%8D%E5%85%81%E8%AE%B8%E6%88%91%E8%BF%90%E8%A1%8C%60kubectl\"\u003ehttps://github.com/ecomm-integration-ballerina/kubernetes-cluster，以便在MacBook中创建k8s集群。我修改kubelet配置中节点的IP地址，因为默认配置不允许我运行`kubectl\u003c/a\u003e exec`。您可以在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706\"\u003e这里\u003c/a\u003e找到根本原因。\u003c/p\u003e\n\u003cp\u003e下文提到的关于机器的对应关系如下:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eany machine = MacBook\u003c/li\u003e\n\u003cli\u003emaster IP = 192.168.205.10\u003c/li\u003e\n\u003cli\u003ework IP = 192.168.205.11\u003c/li\u003e\n\u003cli\u003eAPI server端口 = 6443\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"Component\"\u003e\u003ca href=\"#Component\" class=\"headerlink\" title=\"Component\"\u003e\u003c/a\u003eComponent\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/components.png\" alt=\"组件\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ekubectl exec：当我们在机器上运行“ kubectl exec…”时，可以在任何有权限访问k8s api服务器上运行。\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver\"\u003eapi server\u003c/a\u003e：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/overview/components/#kube-apiserver\"\u003eapi server\u003c/a\u003e上的组件，用于公开Kubernetes API。它是Kubernetes控制平面的前端。\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/overview/components/#kubelet\"\u003ekubelet\u003c/a\u003e：在集群中每个节点上运行的代理。确保容器在容器中运行。\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/overview/components/#container-runtime\"\u003econtainer runtime\u003c/a\u003e：负责运行容器的软件。例如：docker，cri-o，containerd…\u003c/li\u003e\n\u003cli\u003ekernel：工作节点中操作系统的内核，负责管理进程。\u003c/li\u003e\n\u003cli\u003etarget container：作为Pod的一部分并在其中一个工作程序节点上运行的容器。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"Findings\"\u003e\u003ca href=\"#Findings\" class=\"headerlink\" title=\"Findings\"\u003e\u003c/a\u003eFindings\u003c/h2\u003e\u003ch3 id=\"1-Client端\"\u003e\u003ca href=\"#1-Client端\" class=\"headerlink\" title=\"1. Client端\"\u003e\u003c/a\u003e1. Client端\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003cp\u003e在默认名称空间中创建容器\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ kubectl run exec-test-nginx --image=nginx\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e然后运行exec命令并\u003ccode\u003esleep 5000\u003c/code\u003e进行观察\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ kubectl exec -it exec-test-nginx-6558988d5-fgxgg -- sh\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# sleep 5000\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e我们可以观察到kubectl过程（在这种情况下为pid = 8507）\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ps -ef |grep kubectl\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e501  8507  8409   0  7:19PM ttys000    0:00.13 kubectl exec -it exec-test-nginx-6558988d5-fgxgg -- sh\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e当我们检查该进程的网络活动时，我们可以看到它与api-server（192.168.205.10.6443）有连接\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ netstat -atnv |grep 8507\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etcp4       0      0  192.168.205.1.51673    192.168.205.10.6443    ESTABLISHED 131072 131768   8507      0 0x0102 0x00000020\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etcp4       0      0  192.168.205.1.51672    192.168.205.10.6443    ESTABLISHED 131072 131768   8507      0 0x0102 0x00000028\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e让我们检查一下代码。kubectl使用子资源创建一个POST请求,\u003ccode\u003eexec\u003c/code\u003e并发送一个rest请求。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/rest-request.png\" alt=\"休息请求\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"2-apiserver端\"\u003e\u003ca href=\"#2-apiserver端\" class=\"headerlink\" title=\"2. apiserver端\"\u003e\u003c/a\u003e2. apiserver端\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e\u003cp\u003e我们可以在api服务器端观察请求。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ehandler.go:143] kube-apiserver: POST \u0026#34;/api/v1/namespaces/default/pods/exec-test-nginx-6558988d5-fgxgg/exec\u0026#34; satisfied by gorestful with webservice /api/v1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eupgradeaware.go:261] Connecting to backend proxy (intercepting redirects) https://192.168.205.11:10250/exec/default/exec-test-nginx-6558988d5-fgxgg/exec-test-nginx?command=sh\u0026amp;input=1\u0026amp;output=1\u0026amp;tty=1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eHeaders: map[Connection:[Upgrade] Content-Length:[0] Upgrade:[SPDY/3.1] User-Agent:[kubectl/v1.12.10 (darwin/amd64) kubernetes/e3c1340] X-Forwarded-For:[192.168.205.1] X-Stream-Protocol-Version:[v4.channel.k8s.io v3.channel.k8s.io v2.channel.k8s.io channel.k8s.io]]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e请注意，http请求包括协议升级请求。\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.wikiwand.com/en/SPDY\"\u003eSPDY\u003c/a\u003e允许将单独的stdin / stdout / stderr / spdy-error流通过单个TCP连接进行多路复用。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eApi服务器收到请求并将其绑定到 \u003ccode\u003ePodExecOptions\u003c/code\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e为了能够采取必要的措施，api-server需要知道应该请求哪个node。\u003c/p\u003e\n\u003cp\u003e当然，端点是从节点信息派生的。\u003c/p\u003e\n\u003cp\u003e发现了，KUBELET具有可\u003ccode\u003enode.Status.DaemonEndpoints.KubeletEndpoint.Port\u003c/code\u003e连接API服务器的端口。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://kubernetes.io/docs/concepts/architecture/master-node-communication/#apiserver-to-kubelet\"\u003emaster/node之间的通信\u0026gt; master集群通信 \u0026gt; apiserver到kubelet\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e这些连接在kubelet的HTTPS端点处终止。默认情况下，API服务器不验证kubelet的服务证书，这使得连接容易遭受中间人攻击，不安全的公共网络。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e现在，api服务器知道了端点并打开了连接。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e让我们检查master上发生了什么。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，得到worker节点的ip。正是\u003ccode\u003e192.168.205.11\u003c/code\u003e在这种情况下。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ kubectl get nodes k8s-node-1 -o wide\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eNAME         STATUS   ROLES    AGE   VERSION   INTERNAL-IP      EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION      CONTAINER-RUNTIME\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ek8s-node-1   Ready    \u0026lt;none\u0026gt;   9h    v1.15.3   192.168.205.11   \u0026lt;none\u0026gt;        Ubuntu 16.04.6 LTS   4.4.0-159-generic   docker://17.3.3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e然后获取kubelet端口。在这个例子中是\u003ccode\u003e10250\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// any machine\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ kubectl get nodes k8s-node-1 -o jsonpath=\u0026#39;{.status.daemonEndpoints.kubeletEndpoint}\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emap[Port:10250]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e然后检查网络。是否存在到工作节点（192.168.205.11）的连接？可以看到，当我杀死exec进程时，它消失了，所以我知道它正是由于exec命令而由api-server设置的\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// master node\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ netstat -atn |grep 192.168.205.11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etcp        0      0 192.168.205.10:37870    192.168.205.11:10250    ESTABLISHED\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/api-server-to-kubelet.png\" alt=\"api服务器到kubelet\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e现在，kubectl和api-server之间的连接仍然打开，并且api-server和kubelet之间还有另一个连接。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"3-work节点\"\u003e\u003ca href=\"#3-work节点\" class=\"headerlink\" title=\"3. work节点\"\u003e\u003c/a\u003e3. work节点\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e让我们通过连接到work节点并检查正在发生的事情。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e首先，我们也可以在此处观察连接。第二行。\u003ccode\u003e192.168.205.10\u003c/code\u003e是master的IP。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// worker node\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ netstat -atn |grep 10250\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etcp6       0      0 :::10250                :::*                    LISTEN\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etcp6       0      0 192.168.205.11:10250    192.168.205.10:37870    ESTABLISHED\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e那我们的sleep命令呢？可以通过ps命令找到！！！\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// worker node\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ps -afx\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31463 ?        Sl     0:00      \\_ docker-containerd-shim 7d974065bbb3107074ce31c51f5ef40aea8dcd535ae11a7b8f2dd180b8ed583a /var/run/docker/libcontainerd/7d974065bbb3107074ce31c51\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31478 pts/0    Ss     0:00          \\_ sh\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31485 pts/0    S+     0:00              \\_ sleep 5000\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003ekubelet如何做到的？\u003c/li\u003e\n\u003cli\u003ekubelet有一个守护程序，该守护程序通过10250端口与api server通信。\u003c/li\u003e\n\u003cli\u003ekubelet计算执行请求的响应端点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不要混淆。它不返回命令的结果。它返回一个通信端点。\u003c/p\u003e\n\u003cp\u003ekubelet实现的\u003ccode\u003eRuntimeServiceClient\u003c/code\u003e接口是Container Runtime Interface的一部分。\u003c/p\u003e\n\u003cp\u003e它仅使用gRPC通过Container Runtime Interface调用方法。\u003c/p\u003e\n\u003cp\u003econtainer runtime 负责实施 \u003ccode\u003eRuntimeServiceServer\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/kubelet-to-container-runtime.png\" alt=\"Kubelet到容器的运行时\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果是这样，我们需要观察kubelet与容器运行时之间的联系。对？让我们检查。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在运行exec命令之前和之后运行此命令，并检查diff。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// worker node\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ss -a -p |grep kubelet\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eu_str  ESTAB      0      0       * 157937                * 157387                users:((\u0026#34;kubelet\u0026#34;,pid=5714,fd=33))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e嗯 在kubelet（pid = 5714）与某个组件通过UNIX套接字建立了新连接。正是DOCKER（pid = 1186）。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// worker node\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ss -a -p |grep 157387\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eu_str  ESTAB      0      0       * 157937                * 157387                users:((\u0026#34;kubelet\u0026#34;,pid=5714,fd=33))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eu_str  ESTAB      0      0      /var/run/docker.sock 157387                * 157937                users:((\u0026#34;dockerd\u0026#34;,pid=1186,fd=14))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这是运行我们的命令的docker守护进程（pid = 1186）。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e// worker node.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ps -afx\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e 1186 ?        Ssl    0:55 /usr/bin/dockerd -H fd://\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17784 ?        Sl     0:00      \\_ docker-containerd-shim 53a0a08547b2f95986402d7f3b3e78702516244df049ba6c5aa012e81264aa3c /var/run/docker/libcontainerd/53a0a08547b2f95986402d7f3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17801 pts/2    Ss     0:00          \\_ sh\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17827 pts/2    S+     0:00              \\_ sleep 5000\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"4-Docker-runtime\"\u003e\u003ca href=\"#4-Docker-runtime\" class=\"headerlink\" title=\"4. Docker runtime\"\u003e\u003c/a\u003e4. Docker runtime\u003c/h3\u003e\u003cul\u003e\n\u003cli\u003e让我们检查cri-o的源代码以了解它如何发生。逻辑在docker中相似。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e它具有一个实现RuntimeServiceServer的服务器。\u003c/p\u003e\n\u003cp\u003e在链的最后, container runtime在work 节点中执行命令。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/container-runtime-to-kernel.png\" alt=\"容器运行时到内核\"/\u003e\u003c/p\u003e\n\u003cp\u003e最后，kernel执行命令\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://erkanerol.github.io/img/kubectl-exec/kernel-puts.png\" alt=\"内核输入\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"注意事项\"\u003e\u003ca href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"\u003e\u003c/a\u003e注意事项\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003eapi-server也可以初始化与kubelet的连接。\u003c/li\u003e\n\u003cli\u003e这些连接将一直持续到交互式执行程序结束。\u003cul\u003e\n\u003cli\u003ekubectl和api server之间的连接\u003c/li\u003e\n\u003cli\u003eapi server和kubelet之间的连接\u003c/li\u003e\n\u003cli\u003ekubelet与container runtime之间的连接\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003ekubectl或api-server无法在work节点中运行任何内容。kubelet可以运行，但也可以与container runtime时交互以进行此类操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"参考\"\u003e\u003ca href=\"#参考\" class=\"headerlink\" title=\"参考\"\u003e\u003c/a\u003e参考\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://groups.google.com/forum/#!topic/kubernetes-dev/Cjia36v39vM\"\u003ehttps://groups.google.com/forum/#!topic/kubernetes-dev/Cjia36v39vM\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706\"\u003ehttps://medium.com/@joatmon08/playing-with-kubeadm-in-vagrant-machines-part-2-bac431095706\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://serverfault.com/questions/252723/how-to-find-other-end-of-unix-socket-connection\"\u003ehttps://serverfault.com/questions/252723/how-to-find-other-end-of-unix-socket-connection\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n      \n    \u003c/div\u003e",
  "Date": "2021-01-10T14:30:53+08:00",
  "Author": "Z.S.K."
}