{
  "Source": "izsk.me",
  "Title": "Multi-Active Availability vs High Availability",
  "Link": "https://izsk.me/2019/07/16/HA-MA/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003e当我们在讨论系统架构的时候经常听到HA(High Availability 高可用)如何如何保证, 在调研CockRoachDB时看到个MA(Multi-Active Availability 多活可用)的概念, 头一次听说, 比较新颖, 所以网上查了一上, 说到底还是CAP那一套.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\n\n\u003ch3 id=\"High-Availability\"\u003e\u003ca href=\"#High-Availability\" class=\"headerlink\" title=\"High Availability\"\u003e\u003c/a\u003eHigh Availability\u003c/h3\u003e\u003cp\u003e我们经常会错误的认为高可用就是一致性，其实并不然.\u003c/p\u003e\n\u003cp\u003e高可用性，是指应用程序在其中一个服务的宿主系统发生故障的时候，仍然能够不停地运行。这是通过水平拓展应用程序服务的方式来实现的（例如在多台机器和系统上部署相同的服务）。如果它们当中的其中一个服务发生故障，其他服务能够接替并提供相同的服务内容\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e高可用强调的是在节点发生故障时, 系统仍然可以提供服务, 并不关心数据一致性的问题.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e两种使用最频繁的高可用性设计方案：\u003cstrong\u003eActive-Passive和Active-Active系统\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"Active-Passive\"\u003e\u003ca href=\"#Active-Passive\" class=\"headerlink\" title=\"Active-Passive\"\u003e\u003c/a\u003eActive-Passive\u003c/h4\u003e\u003cp\u003e在Active-Passive系统中，所有流量会路由到一个“Active“的主副本。这个副本上状态的变化将同步到备份的“Passive”的从副本，系统尽可能地保证“Passive”副本与“Active”副本之间的一致性。\u003c/p\u003e\n\u003cp\u003e很典型的是Oracle数据库.\u003c/p\u003e\n\u003cp\u003e然而这种设计存在以下缺点：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e如果用户使用异步复制策略，将无法保证所有数据成功地同步到“Passive”的从副本。这就意味着用户可能丢失数据，在特定的应用场景下这可能导致非常可怕的后果。\u003c/li\u003e\n\u003cli\u003e如果用户使用同步复制策略，在“Passive”的从副本出现故障的时候，用户不得不牺牲整个应用系统的可用性，否则将面临不一致的风险\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch4 id=\"Active-Active\"\u003e\u003ca href=\"#Active-Active\" class=\"headerlink\" title=\"Active-Active\"\u003e\u003c/a\u003eActive-Active\u003c/h4\u003e\u003cp\u003e在Active-Active系统中，多个副本各自运行着独立的服务。负载被路由到所有副本上。如果一个副本出现故障，其他副本可以继续处理原本应该路由到故障副本上的负载。\u003c/p\u003e\n\u003cp\u003e对于数据库而言，Active-Active的系统对于大多数工作负载来说是难以实现的。例如：如果用户想让多个副本处理同一份数据的写操作，如何保证它们的一致性？\u003c/p\u003e\n\u003cp\u003e打个比说:\u003c/p\u003e\n\u003cp\u003e在Active-Active设计的高可用性集群当中有2个副本（\u003cstrong\u003eA\u003c/strong\u003e和\u003cstrong\u003eB\u003c/strong\u003e）。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eA\u003c/strong\u003e确认键\u003ccode\u003exyz\u003c/code\u003e的写请求，值为\u003ccode\u003e\u0026#39;123\u0026#39;\u003c/code\u003e，随后发生故障。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eB\u003c/strong\u003e确认键\u003ccode\u003exyz\u003c/code\u003e的读请求，因为没找到匹配键值对，返回\u003ccode\u003eNULL\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eB\u003c/strong\u003e确认键\u003ccode\u003exyz\u003c/code\u003e的写请求，值为\u003ccode\u003e\u0026#39;456\u0026#39;\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eA\u003c/strong\u003e重启并尝试再次与\u003cstrong\u003eB\u003c/strong\u003e连接，此时如何处理\u003ccode\u003exyz\u003c/code\u003e值的不同？在系统里面没有一个清晰的方式去处理这种数据不一致的情况。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e在这个例子当中，集群在整个生命周期内保持Active状态。根据\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/CAP_theorem\"\u003eCAP理论\u003c/a\u003e，这是AP系统，它能够在分区发生时保证可用性，而不能保证一致性。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"Multi-Active-Availability\"\u003e\u003ca href=\"#Multi-Active-Availability\" class=\"headerlink\" title=\"Multi-Active Availability\"\u003e\u003c/a\u003eMulti-Active Availability\u003c/h3\u003e\u003cp\u003e像Active-Ative设计模式，具备多活可用性的系统当中的所有副本，都处理读和写的负载。CockroachDB在此基础上做了改进，使用“一致性副本”实现了数据之间一致性。在这种设计里，同步请求将发送到至少3个副本，且只有绝大多数副本响应了该请求，才能视作同步完成。这就意味着用户在系统不满足可用条件时仍然会遇到系统故障。\u003c/p\u003e\n\u003cp\u003e为了避免冲突，保证数据的一致性，集群如果丢失了绝大多数副本，将停止响应。这是因为在故障系统里的副本丧失了使数据达成一致的能力。待到绝大多数副本重启以后，数据库将恢复可用。\u003c/p\u003e\n\u003cp\u003e在一个多活可用的集群中有3个CockroachDB节点（\u003cstrong\u003eA\u003c/strong\u003e、\u003cstrong\u003eB\u003c/strong\u003e、\u003cstrong\u003eC\u003c/strong\u003e）。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eA\u003c/strong\u003e接收到键\u003ccode\u003exyz\u003c/code\u003e的写请求，值为\u003ccode\u003e\u0026#39;123\u0026#39;\u003c/code\u003e。它与节点\u003cstrong\u003eB\u003c/strong\u003e和\u003cstrong\u003eC\u003c/strong\u003e同步写请求结果，确保它们确认了写请求结果。一旦\u003cstrong\u003eA\u003c/strong\u003e收到第一个确认，写请求完成。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eA\u003c/strong\u003e随后发生故障。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eB\u003c/strong\u003e接收到键\u003ccode\u003exyz\u003c/code\u003e的读请求，返回值\u003ccode\u003e\u0026#39;123\u0026#39;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eC\u003c/strong\u003e接收到键\u003ccode\u003exyz\u003c/code\u003e的更新请求，修改值为\u003ccode\u003e\u0026#39;456\u0026#39;\u003c/code\u003e。它与节点\u003cstrong\u003eB\u003c/strong\u003e同步写请求结果，确保\u003cstrong\u003eB\u003c/strong\u003e确认了写请求结果。在\u003cstrong\u003eC\u003c/strong\u003e接收到来自节点\u003cstrong\u003eB\u003c/strong\u003e的确认之后，写请求完成。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eA\u003c/strong\u003e重启，再次加入集群。它接收到了键\u003ccode\u003exyz\u003c/code\u003e的最新值，将旧值更新为\u003ccode\u003e\u0026#39;456\u0026#39;\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cstrong\u003e在这个例子当中，如果在A故障以后B或C发生故障，集群将停止响应。根据\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/CAP_theorem\"\u003eCAP理论\u003c/a\u003e，这是一个CP系统，它能够在分区发生时保证一致性，而不是保证可用性。\u003c/strong\u003e\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/CAP_theorem\"\u003eCAP理论\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://doc.cockroachchina.baidu.com/#faqs/cockroachdb-features/multi-active-availability/\"\u003ecockroach.doc\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2019-07-16T21:10:53+08:00",
  "Author": "Z.S.K."
}