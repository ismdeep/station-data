{
  "Source": "izsk.me",
  "Title": "Flannel Vxlan封包原理剖析",
  "Link": "https://izsk.me/2022/03/25/Kubernetes-Flannel-Vxlan/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n      \n\n      \n        \u003cp\u003eflannel在kubernetes中算是比较常用的cni, 其中vxlan又是flannel中常用的模式,最近又详细地看了一遍vxlan的实现方式, 每看一次都会发现新大陆，听的太多人说flannel的vxlan需要封包解包，但并不是所有的人都知道到底是把什么封到包里，\u003cstrong\u003e包\u003c/strong\u003e指的又是什么？ \u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e本文主要来解析vxlan的封包解包过程，flannel的一些基础概念,可参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/2020/01/05/Kubernetes-flannel-details/\"\u003eKubernetes学习(flannel深入学习)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e先简单说一下flannel支持的三种模式:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eUdp: 模式性能最差,现在几乎已不再使用，不再过多解释\u003c/li\u003e\n\u003cli\u003ehost-gw: host-gw则是个纯三层的解决方案，直接把host当成是容器通信路径里的\u003cstrong\u003e网关\u003c/strong\u003e进行路由，为了达到这个目的，需要集群宿主机之间二层是互通的, 虽host-gw在三种模式中性能最好，但不是所有的集群都可以做到二层互通，还是有一定的局限\u003c/li\u003e\n\u003cli\u003evxlan:\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e关于这三者之间的比较也不是本文的重点，感兴趣的同学可以参考\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/zlw-xyz/p/14968730.html\"\u003eFlannel的三种工作模式\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e接下来请出本次的主角: vxlan, 但在说这之前，还是需要先提一下vlan\u003c/p\u003e\n\u003ch3 id=\"vlan\"\u003e\u003ca href=\"#vlan\" class=\"headerlink\" title=\"vlan\"\u003e\u003c/a\u003evlan\u003c/h3\u003e\u003cp\u003e由于篇幅有限，不打算过多地去解释vlan技术,很大程度上这属于网络领域范畴，这里作者用一张图来说明vlan技术要解决的问题\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20220322214144.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e从这张图可以看到，vlan用于将一个物理的LAN在逻辑上划分成多个虚拟广播域的通信技术, 通过划分不同的vlan起到网络隔离，vlan内的主机间可以直接通信，而vlan间不能直接互通，从而将广播报文限制在一个vlan内\u003c/p\u003e\n\u003cp\u003e但是vlan有个很大的局限就是它能够划分的虚拟局域网个数非常有限，数量只有4000个左右，无法满足大二层网络的租户间隔离需求，因此诞生了vxlan\u003c/p\u003e\n\u003ch3 id=\"vxlan\"\u003e\u003ca href=\"#vxlan\" class=\"headerlink\" title=\"vxlan\"\u003e\u003c/a\u003evxlan\u003c/h3\u003e\u003cp\u003eVxlan: (Virtual Extensible LAN 虚拟可扩展局域网），是在vlan的基础之上进行的扩展, 可以划分的vlan个数扩大到16M个\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003evxlan通过构建虚拟隧道达到大二层网络互通的目的\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e为了更好地理解flannel中使用vxlan实现跨主机通信的原理，跟vxlan相关的几个关键名词还是需要好好地介绍一下\u003c/p\u003e\n\u003ch4 id=\"VTEP\"\u003e\u003ca href=\"#VTEP\" class=\"headerlink\" title=\"VTEP\"\u003e\u003c/a\u003eVTEP\u003c/h4\u003e\u003cp\u003eVTEP（VXLAN Tunnel Endpoints，VXLAN隧道端点），它可以是个物理设备，也可以是虚拟设备，flannel创建的flannel.1就是vtep设备,flannel中vxlan所说的封包解包就是由这个设备完成\u003c/p\u003e\n\u003cp\u003evtep设置即有ip地址，也有mac地址.\u003c/p\u003e\n\u003ch4 id=\"VNI\"\u003e\u003ca href=\"#VNI\" class=\"headerlink\" title=\"VNI\"\u003e\u003c/a\u003eVNI\u003c/h4\u003e\u003cp\u003eVNI（VXLAN Network Identifier，VXLAN 网络标识符），VNI是一种类似于VLAN ID的用户标识，一个VNI代表了一个租户\u003c/p\u003e\n\u003cp\u003e在flannel中，vni默认都是1, 所以这就是为什么flannel创建的vtep设备的名称叫做flannel.1的原因\u003c/p\u003e\n\u003cp\u003evxlan还有很多其它的技术细节，作者着实觉得不是网络专业出身的真的很难看懂，如果感兴趣的可以看看华为论坛的一篇文章，\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/VXLAN.htm\"\u003e什么是VXLAN\u003c/a\u003e，看不懂也不影响接下来的理解，让我们回到flannel的vxlan模式\u003c/p\u003e\n\u003ch3 id=\"节点通信\"\u003e\u003ca href=\"#节点通信\" class=\"headerlink\" title=\"节点通信\"\u003e\u003c/a\u003e节点通信\u003c/h3\u003e\u003cp\u003e重点说明的是，\u003cstrong\u003e以下只讨论pod间通信，不涉及service的ClusterIP，如果是ClusterIP的话，那还涉及到怎么通过ClusterIP找到目的pod的IP,这属于coreDNS、Kube-proxy的范畴，不在此处讨论\u003c/strong\u003e\u003c/p\u003e\n\u003ch4 id=\"同pod\"\u003e\u003ca href=\"#同pod\" class=\"headerlink\" title=\"同pod\"\u003e\u003c/a\u003e同pod\u003c/h4\u003e\u003cp\u003e同pod通信最为简单, 由于pod内部的多个container通过\u003cstrong\u003epause容器\u003c/strong\u003e共享一个网络，自然通过localhost通信即可\u003c/p\u003e\n\u003ch4 id=\"同节点\"\u003e\u003ca href=\"#同节点\" class=\"headerlink\" title=\"同节点\"\u003e\u003c/a\u003e同节点\u003c/h4\u003e\u003cp\u003e对于在一个节点上的两个pod进行通信, 是不需要经过CNI的, 这其实跟是不是flannel没有关系,由于部署完flannel后，flanneld进程会为每个节点都分配一段IP,IP信息存储在etcd中并保证节点间不会重复\u003c/p\u003e\n\u003cp\u003e由于同节点上的pod分配到的ip都在一个网段, 且cni0充当了node上所有pod的网桥，所有pod的veth一头都插在cni0上，那自然是可以直接通信的，因此，当请求从源pod的eth0网口出来后，到达cni0， cni0发现其目的地址与自己同属一个网络，就直接转到目的pod中去了.\u003c/p\u003e\n\u003ch4 id=\"跨节点\"\u003e\u003ca href=\"#跨节点\" class=\"headerlink\" title=\"跨节点\"\u003e\u003c/a\u003e跨节点\u003c/h4\u003e\u003cp\u003e来看\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.kancloud.cn/pshizhsysu/network/2202538\"\u003e一张图\u003c/a\u003e，如果你能看明白，那基本不需要再往下看了，请直接滑走\u003c/p\u003e\n\u003cp\u003e假如node1上的pod1 \u003cstrong\u003e10.224.1.2\u003c/strong\u003e ，要访问node2上的pod3 \u003cstrong\u003e10.224.2.2\u003c/strong\u003e,那么这条访问是怎样的呢?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200413173855.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e首先数据包从pod1内的eth0出来到达cni0网桥，cni0网桥接收到数据包后发现目的IP跟自己不在一个网段,那么自然需要转发出去，而Linux Bridge有个特殊规则： \u003cstrong\u003e网桥不会将这个数据包转发给任何设备，而是直接转交给主机的三层协议栈进行处理\u003c/strong\u003e, 因此通过本机的route得知，目的地址为10.224.1.0段的数据包都将转到flannel.1\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[node1]\u003cspan class=\"comment\"\u003e# route -n\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eKernel IP routing table\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10.224.0.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10.224.1.0      10.224.1.0      255.255.255.0   UG    0      0        0 flannel.1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们抛开所有因素不谈，先说一个前提，\u003cstrong\u003e两台节点通信，不管虚拟网络上怎么实现，最终还是需要通过物理网卡进行\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eflannel为\u003ccode\u003eoverlay\u003c/code\u003e的容器网络，是个\u003cstrong\u003e大二层\u003c/strong\u003e互通的解决方案， 但最终网络包还是要借助物理网卡出去\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e任何一个VXLAN设备创建时都会指定一个三层物理网络设备作为VTEP\u003c/strong\u003e,flannel.1也不例外, 可通过以下命令进行查看\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eip -d \u003cspan class=\"built_in\"\u003elink\u003c/span\u003e show flannel.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# 在输出中可看到flannel.1是基于eth0上\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e当数据包到达flannel.1后, 它如果要将这个包转到目的节点上去，它需要对\u003ccode\u003evxlan报文进行填充\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e在源节点上flannel填充这些信息的过程就叫封包，在目标节点上解开这些信息就叫解包\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e先来看一下vxlan的报文形式\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20220324225909.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://raw.githubusercontent.com/zhoushuke/BlogPhoto/master/githuboss/20200413193513.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e右边的为原始报文，左边的即为vxlan封装报文,我们一一来介绍一下.\u003c/p\u003e\n\u003ch5 id=\"Original-Ethernet-Frame\"\u003e\u003ca href=\"#Original-Ethernet-Frame\" class=\"headerlink\" title=\"Original Ethernet Frame\"\u003e\u003c/a\u003eOriginal Ethernet Frame\u003c/h5\u003e\u003cp\u003e首先， Original Ethernet Frame是原始的报文，也就是pod1访问pod2的报文，因为是个正常网络报文，包含IP header、Ethernet header、及playload。\u003c/p\u003e\n\u003cp\u003eplayload不多说，就是数据\u003c/p\u003e\n\u003cp\u003eIP header 很自然也就是pod1及pod2的ip地址信息\u003c/p\u003e\n\u003cp\u003e而Ethernet header需要注意的是，不是pod1及pod2的MAC地址，而应该是\u003cstrong\u003e两端flannel.1的MAC地址\u003c/strong\u003e,因为报文到flannel.1后通过\u003ccode\u003eroute -n\u003c/code\u003e得到下一跳的地址为\u003ccode\u003e10.224.2.0/32\u003c/code\u003e，需要得到10.224.2.0的mac地址，这部分信息在\u003cstrong\u003eflanneld中进行维护，叫ARP表\u003c/strong\u003e，即通过IP可得到对应的MAC地址，如下：\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[node1]\u003cspan class=\"comment\"\u003e# ip neigh show dev flannel.1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10.224.2.0 lladdr 92:8d:c4:85:16:ad PERMANENT\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch5 id=\"Vxlan-Header\"\u003e\u003ca href=\"#Vxlan-Header\" class=\"headerlink\" title=\"Vxlan Header\"\u003e\u003c/a\u003eVxlan Header\u003c/h5\u003e\u003cp\u003eVxlan header这里只需要关注一个字段，那就是VNI,前文简单提到过, 在目标node上的flannel.1上会对这个VNI字段进行check，看是否与自己的VNI一致，一致的话才会进行处理.\u003c/p\u003e\n\u003ch5 id=\"UDP-Header\"\u003e\u003ca href=\"#UDP-Header\" class=\"headerlink\" title=\"UDP Header\"\u003e\u003c/a\u003eUDP Header\u003c/h5\u003e\u003cp\u003e从上图中的颜色可以看出, UDP是把整个Original Ethernet Frame及Vxlan Header都囊括在一起了，我们知道，udp header中包含有源端口，目的端口，如图所示\u003c/p\u003e\n\u003cp\u003e所以很自然Src.port为node1上的flannel.1的端口，该端口是根据封装的内部数据帧计算出的一个哈希值\u003c/p\u003e\n\u003cp\u003eDst.port(上面也显示为VxlanPort)为node2上flannel.1的端口，Linux内核中默认为VXLAN分配的UDP监听端口为8472\u003c/p\u003e\n\u003ch5 id=\"Outer-IP-header\"\u003e\u003ca href=\"#Outer-IP-header\" class=\"headerlink\" title=\"Outer IP header\"\u003e\u003c/a\u003eOuter IP header\u003c/h5\u003e\u003cp\u003e上面的信息其实还都是在flannel中, 上面说过任何虚拟出来的网络最终都是要经过实体网卡设备出去,目前封装出来的udp header是不能在宿主机网络中传递的，只能进一步把udp再封装成正常的网络包通过节点物理网络发送出去，根据tcp/ip协议，有了UDP header自然是需要封装在ip报文中，所以有ip header\u003c/p\u003e\n\u003cp\u003eip header中包含有源ip及目的ip，源ip即为flannel.1所绑定的物理ip,即node1节点的eth0 ip\u003c/p\u003e\n\u003cp\u003e而目标ip，那肯定是node2的eth0 ip了, 这个ip是需要根据目标flannel.1的mac地址获得，这部分信息同样维护在flanneld中的，可通过以下命令查询\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[node1 ~]\u003cspan class=\"comment\"\u003e# bridge fdb show dev flannel.1 | grep 92:8d:c4:85:16:ad\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e92:8d:c4:85:16:ad dev flannel.1 dst 192.168.2.91 self permanent\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e192.168.2.19即为目标ip\u003c/p\u003e\n\u003cp\u003e可以总结一下，flanneld中维护了这两部分信息:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eflannel.1的ip与mac地址对应关系，通过flannel.1的ip可以查询到flannel.1 的mac地址\u003c/li\u003e\n\u003cli\u003eflannel.1的mac地址及其所在node ip对应关系，通过flannel.1的mac地址可以查询到node ip\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch5 id=\"Outer-MAC-Header\"\u003e\u003ca href=\"#Outer-MAC-Header\" class=\"headerlink\" title=\"Outer MAC Header\"\u003e\u003c/a\u003eOuter MAC Header\u003c/h5\u003e\u003cp\u003e而ip header则又需要由封装在mac header中，通过上面的查询，mac header 自然就是两台node的mac信息了\u003c/p\u003e\n\u003cp\u003e这样的话，整个封装包组成了标准的tcp/ip协议包，可以在物理网络上传递了\u003c/p\u003e\n\u003ch5 id=\"解包\"\u003e\u003ca href=\"#解包\" class=\"headerlink\" title=\"解包\"\u003e\u003c/a\u003e解包\u003c/h5\u003e\u003cp\u003e当数据包到达node2的8472端口后（实际上就是VXLAN模块），VXLAN模块就会比较这个VXLAN Header中的VNI和本机的VTEP（VXLAN Tunnel End Point，就是flannel.1）的VNI是否一致，然后比较Inner Ethernet Header中的目的MAC地址与本机的flannel.1是否一致，都一致后，则去掉数据包的VXLAN Header和Inner Ethernet Header，然后把数据包从flannel.1网卡进行发送。\u003c/p\u003e\n\u003cp\u003e然后，在node2上会有如下的路由（由flanneld维护），根据路由判断要把数据包发送到cni0网卡上\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[node2 ~]# route -n\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eKernel IP routing table\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10.224.2.0      0.0.0.0         255.255.255.0   U     0      0        0 cni0\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e最后通过 inner ip header中的ip知道需要由10.224.2.2的pod进行响应.\u003c/p\u003e\n\u003cp\u003evxlan在内核中进行封装、解封装的过程，致使flannel vxlan的性能有所下降.\u003c/p\u003e\n\u003cp\u003e\u0026lt;完\u0026gt;\u003c/p\u003e\n\u003ch3 id=\"参考文章\"\u003e\u003ca href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"\u003e\u003c/a\u003e\u003cstrong\u003e参考文章:\u003c/strong\u003e\u003c/h3\u003e\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/2020/01/05/Kubernetes-flannel-details/\"\u003ehttps://izsk.me/2020/01/05/Kubernetes-flannel-details/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.kancloud.cn/pshizhsysu/network/2202538\"\u003ehttps://www.kancloud.cn/pshizhsysu/network/2202538\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.cnblogs.com/zlw-xyz/p/14968730.html\"\u003ehttps://www.cnblogs.com/zlw-xyz/p/14968730.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://support.huawei.com/enterprise/zh/doc/EDOC1100177391/2845c625\"\u003ehttps://support.huawei.com/enterprise/zh/doc/EDOC1100177391/2845c625\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://info.support.huawei.com/info-finder/encyclopedia/zh/VXLAN.html\"\u003ehttps://info.support.huawei.com/info-finder/encyclopedia/zh/VXLAN.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"转载请注明原作者-周淑科-https-izsk-me\"\u003e\u003ca href=\"#转载请注明原作者-周淑科-https-izsk-me\" class=\"headerlink\" title=\"转载请注明原作者: 周淑科(https://izsk.me)\"\u003e\u003c/a\u003e\u003cstrong\u003e转载请注明原作者: 周淑科(\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://izsk.me/\"\u003ehttps://izsk.me\u003c/a\u003e)\u003c/strong\u003e\u003c/h3\u003e\n      \n    \u003c/div\u003e",
  "Date": "2022-03-25T20:10:53+08:00",
  "Author": "Z.S.K."
}