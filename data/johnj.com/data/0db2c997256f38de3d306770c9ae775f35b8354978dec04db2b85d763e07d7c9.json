{
  "Source": "johnj.com",
  "Title": "A Two Bit Decoder",
  "Link": "http://johnj.com/posts/a-two-bit-decoder/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eA Two Bit Decoder\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/clojure\"\u003e\u003cspan class=\"clojure-tag\"\u003eclojure\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/genomics\"\u003e\u003cspan class=\"genomics-tag\"\u003egenomics\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2013-07-06T00:00:00Z\"\u003e\n      July 6, 2013\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/validating-the-genome-decoder/\"\u003eValidating the Genome Decoder\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/exploratory-genomics-with-clojure/\"\u003eExploratory Genomics with Clojure\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003cp\u003e\nThe entire human genome is available as a single .2bit file \u003ca href=\"http://hgdownload.cse.ucsc.edu/downloads.html#human\"\u003ehere\u003c/a\u003e\n(click on “Full Data Set”, then download \u003ccode class=\"verbatim\"\u003ehg19.2bit\u003c/code\u003e). Unlike the\nstellar signal in \u003cem\u003eHis Master’s Voice\u003c/em\u003e, \u003ca href=\"http://genome.ucsc.edu/FAQ/FAQformat#format7\"\u003ethe 2bit format\u003c/a\u003e is reasonably\nclearly documented.\u003c/p\u003e\n\u003cp\u003e\nWe want to write Clojure code to:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eProvide base pairs in symbolic (rather than raw binary) form as\nlazy sequences – i.e., sequences which need not all fit in memory\nat once, but can be consumed and processed as needed;\u003c/li\u003e\n\u003cli\u003eProvide “random access” to this data selectively, e.g. by\nchromosome, rather than always reading through the entire file;\u003c/li\u003e\n\u003cli\u003eProvide access to metadata encoded in the file.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe functionality to do this is posted in the \u003ca href=\"https://github.com/eigenhombre/jenome\"\u003ejenome\u003c/a\u003e project on\nGitHub. In this post, we’ll explore this code a little; in following\nposts, we’ll do some investigating of the actual genome \u003cem\u003eper se\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\nCapability (2) is provided, in part, by implementing random-access\nreads from file \u003ccode class=\"verbatim\"\u003efname\u003c/code\u003e of \u003ccode class=\"verbatim\"\u003elen\u003c/code\u003e bytes starting at \u003ccode class=\"verbatim\"\u003eoffset\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(ns jenome.rafile\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (:import (java.io RandomAccessFile)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn read-with-offset [fname offset len]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let [raf (RandomAccessFile. fname \u0026#34;r\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        bb (byte-array len)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (.seek raf offset)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (.readFully raf bb)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (.close raf)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    bb))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nArmed with this, we can get the \u003ccode class=\"verbatim\"\u003e.2bit\u003c/code\u003e file header:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn file-header [fname]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let [[sig ver seqcnt resvd] (-\u0026gt;\u0026gt; (read-with-offset fname 0 16)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                    (partition 4)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                    (map bytes-to-number))]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (assert (= sig 0x1A412743))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (assert (= ver 0))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (assert (= resvd 0))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    seqcnt))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n\u003ccode class=\"verbatim\"\u003efile-header\u003c/code\u003e basically just gives us the number of sequences (usually,\nchromosomes) in the file, doing some sanity checks along the\nway. \u003ccode class=\"verbatim\"\u003ebytes-to-number\u003c/code\u003e converts an arbitrary sequence of bytes to the\nappropriate unsigned integer. (For brevity’s sake, I won’t show every\nutility function in this blog post; \u003ca href=\"https://github.com/eigenhombre/jenome/blob/master/src/jenome/core.clj\"\u003ethe source code on GitHub\u003c/a\u003e is\nreasonably short.)\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/2bitfig1.png\"\u003e\u003cimg class=\"resize\" src=\"/2bitfig1_hu8f24fbf3460761160bca848e280ea66d_302261_700x0_resize_box_3.png\" style=\"width:400px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\nThe next part of the file, as shown in Figure 1, is called the “file\nindex,” and contains a list of sequences contained the rest of the\nfile. It can be read as follows:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn file-index [fname seqcnt]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (loop [i 0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         ofs 16\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         ret []]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (if (\u0026lt; i seqcnt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (let [[nlen] (read-with-offset fname ofs 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            name (apply str (map char (read-with-offset fname \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                                        (+ ofs 1) nlen)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            seq-offset (get32 fname (+ ofs 1 nlen))]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        (recur (inc i) (+ ofs nlen 5) (conj ret [nlen name seq-offset])))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      ret)))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThis somewhat imperative code walks through the \u003ccode class=\"verbatim\"\u003eseqcnt\u003c/code\u003e sequence\nportions of the index, pulling out sequence names and lengths as we\ngo.\u003c/p\u003e\n\u003cp\u003e\nIt’s here that we introduce a new friend, the yeast \u003ca href=\"http://en.wikipedia.org/wiki/Saccharomyces_cerevisiae\"\u003eSaccharomyces\ncerevisiae\u003c/a\u003e (SacCer3), used since antiquity for making bread and\nfermented beverages. Relatively small in comparison with the human\ngenome, SacCer3 will be our “unit test” organism. Available online and\nchecked into the \u003ccode class=\"verbatim\"\u003eresources\u003c/code\u003e folder in this repo, the file can be accessed as\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(def yeast\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   (as-file (resource \u0026#34;sacCer3.2bit\u0026#34;)))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n(I have imported \u003ccode class=\"verbatim\"\u003eresource\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003eas-file\u003c/code\u003e from \u003ccode class=\"verbatim\"\u003eclojure.java.io\u003c/code\u003e; again, see\nthe source code.)\u003c/p\u003e\n\u003cp\u003e\nOur index-reading code yields:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let [seqcnt (file-header yeast)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (file-index yeast seqcnt))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e[[4 \u0026#34;chrI\u0026#34; 191]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrII\u0026#34; 57762]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6 \u0026#34;chrIII\u0026#34; 261074]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrIV\u0026#34; 340245]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrIX\u0026#34; 723245]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [4 \u0026#34;chrV\u0026#34; 833233]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrVI\u0026#34; 977468]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6 \u0026#34;chrVII\u0026#34; 1045025]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [7 \u0026#34;chrVIII\u0026#34; 1317776]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [4 \u0026#34;chrX\u0026#34; 1458453]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrXI\u0026#34; 1644907]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6 \u0026#34;chrXII\u0026#34; 1811627]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [7 \u0026#34;chrXIII\u0026#34; 2081188]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6 \u0026#34;chrXIV\u0026#34; 2312312]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5 \u0026#34;chrXV\u0026#34; 2508412]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6 \u0026#34;chrXVI\u0026#34; 2781251]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [4 \u0026#34;chrM\u0026#34; 3018284]]\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThe apparent consistency of these values give us some initial\nconfidence that we are reading the index correctly. Note, however, the\ncurious fact that \u003ccode class=\"verbatim\"\u003echrIX\u003c/code\u003e appears between \u003ccode class=\"verbatim\"\u003eIV\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003eV\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e\nWith this encouraging start, we can now attack the sequences\nproper. These are laid out as shown in Figure 2, with block metadata\nprepended to the actual DNA sequences:\u003c/p\u003e\n\u003cfigure\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/2bitfig2.png\"\u003e\u003cimg class=\"resize\" src=\"/2bitfig2_hu2950de1fecc1ad732b9fe2d5d5f8ede6_256175_700x0_resize_box_3.png\" style=\"width:300px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\n\u003cfigcaption\u003e\nSequence Record Layout\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003e\nThe “N blocks” are blocks of unknown sequences with specified offsets\nand lengths. Masked blocks are blocks which are known repetitions\n(indicated as lower case \u003ccode class=\"verbatim\"\u003ea\u003c/code\u003e, \u003ccode class=\"verbatim\"\u003eg\u003c/code\u003e, \u003ccode class=\"verbatim\"\u003ec\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003et\u003c/code\u003e in the text-based\n‘FASTA’ file format). We are obviously most interested in \u003ccode class=\"verbatim\"\u003ednaSize\u003c/code\u003e, the\nnumber of base pairs in the sequence, and the actual sequence values\nthemselves.\u003c/p\u003e\n\u003cp\u003e\nUnpacking the above data format (except the base pairs \u003cem\u003eper se\u003c/em\u003e) makes\nheavy use of \u003ccode class=\"verbatim\"\u003eget32\u003c/code\u003e, which just returns the unsigned 32-bit integer at\nthe specified file location. This code doesn’t need to be super\nefficient, since the block headers themselves are quite small. The\nmetadata for the entire file is returned as a sequence of maps.\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn getblk [fname offset n]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let [ret (map #(get32 fname (+ offset (* 4 %))) (range n))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        offset (skip offset n)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    [ret offset]))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sequence-headers\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Get sequence headers from .2bit file, as documented in\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  http://genome.ucsc.edu/FAQ/FAQformat#format7. Returns a list of maps\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  with details for each sequence.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  [fname]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let [seqcnt (file-header fname)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (for [[nlen name ofs] (file-index fname seqcnt)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (let [[[dna-size]         ofs] (getblk fname ofs 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [[n-block-count]    ofs] (getblk fname ofs 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [n-block-starts     ofs] (getblk fname ofs n-block-count)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [n-block-sizes      ofs] (getblk fname ofs n-block-count)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [[mask-block-count] ofs] (getblk fname ofs 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [mask-block-starts  ofs] (getblk fname ofs mask-block-count)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [mask-block-sizes   ofs] (getblk fname ofs mask-block-count)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            [[reserved]         ofs] (getblk fname ofs 1)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        (assert (zero? reserved))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        {:name name\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :nlen nlen\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :dna-size dna-size\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :n-block-count n-block-count\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :n-block-starts n-block-starts\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :n-block-sizes n-block-sizes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :mask-block-starts mask-block-starts\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :mask-block-sizes mask-block-sizes\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         :dna-offset ofs}))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nA few sanity checks are included in \u003ccode class=\"verbatim\"\u003etest_core.clj\u003c/code\u003e to make sure we’re\ndecoding the metadata correctly. Requirement (3) is done!\u003c/p\u003e\n\u003cp\u003e\nThe final step (Requirement (1)), is to actually get our base pairs\n(BPs). Since we have to assume the data set is very large (as is the\ncase with the human genome), we cannot read the entire DNA sequence at\nonce. The first part is to break the \u003ccode class=\"verbatim\"\u003edna-size\u003c/code\u003e base pairs (remember we\nhave 2 bits per BP, or 4 BP/byte), starting at \u003ccode class=\"verbatim\"\u003edna-offset\u003c/code\u003e. First we\nobtain the “coordinates” of the sequences we want to read:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn get-buffer-starts-and-lengths \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Return buffer offsets (starting at ofs) required to cleanly read a\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  total of m bytes no more than n at a time\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  [ofs n m]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (loop [a ofs\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         len n\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         ret []]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (if (\u0026gt;= a (+ m ofs))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      ret\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (recur (+ a n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             n\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             (conj ret [a (min len (- (+ m ofs) a))])))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;; Example:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(get-buffer-starts-and-lengths 100 200 512)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;=\u0026gt; [[100 200] [300 200] [500 112]]\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAt long last, having obtained the locations and lengths we want to read from, we can get our sequences out:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn genome-sequence\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Read a specific sequence, or all sequences in a file concatenated\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  together; return it as a lazy seq.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([fname]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (let [sh (sequence-headers fname)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (mapcat #(genome-sequence fname %1 %2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               (map :dna-offset sh)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               (map :dna-size sh))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([fname ofs dna-len]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take dna-len\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           (apply concat\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                  (let [byte-len (rounding-up-divide dna-len 4)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        starts-and-lengths (get-buffer-starts-and-lengths\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                              ofs 10000 byte-len)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    (for [[offset length] starts-and-lengths\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                          :let [buf (read-with-offset fname offset length)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                          b buf]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                      (byte-to-base-pairs b)))))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;; Example:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (-\u0026gt;\u0026gt; yeast\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      genome-sequence\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (take 30))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;=\u0026gt; (:C :C :A :C :A :C :C :A :C :A :C :C :C :A :C\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;    :A :C :A :C :C :C :A :C :A :C :A :C :C :A :C)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThis function allows us to choose the entire genome, or that for a\ngiven offset and number of base pairs (whether from the metadata for\nan entire chromosome, or some smaller region, thus satisfying (2)).\u003c/p\u003e\n\u003cp\u003e\nThe next post will focus on verification of correctness of this code;\nsubsequent posts will begin to explore the characteristics of this\ndata for various genomes, human or otherwise.\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/validating-the-genome-decoder/\"\u003eValidating the Genome Decoder\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/exploratory-genomics-with-clojure/\"\u003eExploratory Genomics with Clojure\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2013-07-06T00:00:00Z",
  "Author": "John Jacobsen"
}