{
  "Source": "johnj.com",
  "Title": "Adding Tail Call Optimization to A Lisp Written in Go",
  "Link": "http://johnj.com/posts/tco/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eAdding Tail Call Optimization to A Lisp Written in Go\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/lisp\"\u003e\u003cspan class=\"lisp-tag\"\u003elisp\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/l1\"\u003e\u003cspan class=\"l1-tag\"\u003el1\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/golang\"\u003e\u003cspan class=\"golang-tag\"\u003egolang\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2022-08-08T00:00:00Z\"\u003e\n      August 8, 2022\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/practices/\"\u003ePractices for Software Projects\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/tests-by-example/\"\u003eTests by Example in Clojure and Common Lisp\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/swirl5.jpg\"\u003e\u003cimg class=\"resize\" src=\"/swirl5_hud6892c7a4b5f63fe222a2f9f639f3d13_1231490_700x0_resize_q75_box.jpg\" style=\"width:300px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\nThe last few days have been devoted to improving \u003ca href=\"https://github.com/eigenhombre/l1/\"\u003e\u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e\u003c/a\u003e, the homegrown lisp I\n\u003ca href=\"http://johnj.com/posts/l1/\"\u003ewrote about\u003c/a\u003e earlier this year.  A number of changes have landed in the\nlast week:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eImplemented \u003ca href=\"https://github.com/eigenhombre/l1/issues/36\"\u003e\u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e\u003c/a\u003e, \u003ca href=\"https://github.com/eigenhombre/l1/issues/42\"\u003e\u003ccode class=\"verbatim\"\u003edefn\u003c/code\u003e\u003c/a\u003e and sugar for \u003ca href=\"https://github.com/eigenhombre/l1/issues/38\"\u003equote\u003c/a\u003e;\u003c/li\u003e\n\u003cli\u003eFigured out \u003ca href=\"https://github.com/eigenhombre/l1#emacs-integration\"\u003ebasic REPL integration\u003c/a\u003e with Emacs;\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/eigenhombre/l1/issues/27\"\u003eAdded numeric comparison operators\u003c/a\u003e;\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/eigenhombre/l1/issues/33\"\u003eReviewed my Minimum Viable Repo\u003c/a\u003e checklist for this project;\u003c/li\u003e\n\u003cli\u003eFixed \u003ca href=\"https://github.com/eigenhombre/l1/issues?q=is%3Aissue+is%3Aclosed+sort%3Aupdated-desc+label%3Abug\"\u003efour bugs\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI also implemented the bulk of the automated tests \u003ca href=\"https://github.com/eigenhombre/l1/blob/master/tests.l1\"\u003ein the language\nitself\u003c/a\u003e.  This was a decisive step forward in both ease of creating new\ntests and confidence that the language was approaching something usable.\u003c/p\u003e\n\u003cp\u003e\nThe work I\u0026#39;m happiest with, though, because it taught me the most, was implementing\n\u003ca href=\"https://en.wikipedia.org/wiki/Tail_call\"\u003etail call optimization\u003c/a\u003e (TCO) in the language, which the rest of this post will be about.\u003c/p\u003e\n\u003cdiv id=\"outline-container-headline-1\" class=\"outline-2\"\u003e\n\u003ch2 id=\"headline-1\"\u003e\nMotivation\n\u003c/h2\u003e\n\u003cdiv id=\"outline-text-headline-1\" class=\"outline-text-2\"\u003e\n\u003cp\u003e\nThe need for some form of TCO became clear as I started to write more small programs in \u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e.\nPerhaps the simplest example is one that sums all the natural numbers up to $n$:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sum-to-acc (n acc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (cond ((zero? n) acc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        (t (sum-to-acc (- n 1) (+ n acc)))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sum-to (n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (sum-to-acc n 0))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nCalling \u003ccode class=\"verbatim\"\u003esum-to\u003c/code\u003e for small $n$ worked fine:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(sum-to 100)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e5050\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nHowever, larger $n$ blew up spectacularly:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(sum-to (* 1000 1000))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime: goroutine stack exceeds 1000000000-byte limit\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime: sp=0x14020500360 stack=[0x14020500000, 0x14040500000]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efatal error: stack overflow\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime stack:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime.throw({0x10289aa2b?, 0x10294ddc0?})\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t/opt/homebrew/Cellar/go/1.18.3/libexec/src/runtime/panic.go:992 +0x50\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime.newstack()\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t/opt/homebrew/Cellar/go/1.18.3/libexec/src/runtime/stack.go:1101 +0x46c\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eruntime.morestack()\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t/opt/homebrew/Cellar/go/1.18.3/libexec/src/runtime/asm_arm64.s:314 +0x70\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egoroutine 1 [running]:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003estrings.(*Reader).ReadByte(0x1401c2820e0?)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t/opt/homebrew/Cellar/go/1.18.3/libexec/src/strings/reader.go:66 +0x98 fp=0x14020500360 sp=0x14020500360 pc=0x102883348\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003emath/big.nat.scan({0x0, 0x1401c2820e0?, 0x0}, {0x1028dc7c8, 0x1401c2820e0}, 0xa, 0x0)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t/opt/homebrew/Cellar/go/1.18.3/libexec/src/math/big/natconv.go:126 +0x80 fp=0x14020500430 sp=0x14020500360 pc=0x10288b1e0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;; ...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThis happens, of course, because \u003ccode class=\"verbatim\"\u003esum-to-acc\u003c/code\u003e calls itself a million times,\neach time storing a copy of its local bindings on the stack, which\neventually consumes all the space on the stack.\u003c/p\u003e\n\u003cp\u003e\nGetting simple recursive functions like this to work for large $n$ is\nespecially important because \u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e doesn\u0026#39;t have loops (yet)!\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id=\"outline-container-headline-2\" class=\"outline-2\"\u003e\n\u003ch2 id=\"headline-2\"\u003e\nThe Optimization\n\u003c/h2\u003e\n\u003cdiv id=\"outline-text-headline-2\" class=\"outline-text-2\"\u003e\n\u003cp\u003e\nThe solution is hinted at already in my test case.  Note that I did\nnot write \u003ccode class=\"verbatim\"\u003esum-to\u003c/code\u003e as a single recursive function, as follows:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sum-to-notail (n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (cond ((zero? n) 0)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        (t (+ n (sum-to-notail (- n 1))))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nWhile this function looks slightly simpler, it is harder for a\ncompiler or interpreter to optimize.  The difference is that, whereas\n\u003ccode class=\"verbatim\"\u003esum-to-notail\u003c/code\u003e does some work after calling itself (by adding \u003ccode class=\"verbatim\"\u003en\u003c/code\u003e to\nthe result), \u003ccode class=\"verbatim\"\u003esum-to-acc\u003c/code\u003e calls itself from the \u003cem\u003etail position\u003c/em\u003e; that is,\nthe function \u003cem\u003ereturns immediately after calling itself\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003e\nPeople have \u003ca href=\"https://dspace.mit.edu/handle/1721.1/5753\"\u003elong realized\u003c/a\u003e that function calls from the tail position\ncan be replaced by updating the return address and then jumping\ndirectly to the the new function without adding new information to the\nstack.  This is something I had heard about for years and used in\nvarious \u0026#34;functional\u0026#34; languages, without ever really implementing\nmyself (and therefore fully understanding).  It\u0026#39;s an easy thing to take for\ngranted without knowing anything about how it\u0026#39;s actually implemented\nunder the hood.  The failure of \u003ccode class=\"verbatim\"\u003esum-to-acc\u003c/code\u003e and similar recursive\nfunctions, described above, meant I would have to learn.\u003c/p\u003e\n\u003cp\u003e\nTwo very different blog posts were helpful to me in pointing the way\nforward: \u003ca href=\"https://www.geoffreylitt.com/2018/01/15/adding-tail-calls-optimization-to-a-lisp-interpreter.html\"\u003eAdding tail call optimization to a Lisp interpreter in Ruby\u003c/a\u003e,\nand \u003ca href=\"https://eklitzke.org/how-tail-call-optimization-works\"\u003eHow Tail Call Optimization Works\u003c/a\u003e.  The posts focus on very\ndifferent languages (Ruby vs. C / assembler), but they each revolve\naround what are effectively \u003ccode class=\"verbatim\"\u003eGOTO\u003c/code\u003e statements.  I\u0026#39;m old enough to\nremember BASIC and the pernicious \u003ccode class=\"verbatim\"\u003eGOTO\u003c/code\u003e statement leading to\n\u0026#34;spaghetti code.\u0026#34;  I doubt I\u0026#39;ve ever used a \u003ccode class=\"verbatim\"\u003eGOTO\u003c/code\u003e statement in\nproduction code, whose use in modern programming languages fell out of\nfavor in the aftermath of Dijkstra\u0026#39;s famous \u003ca href=\"https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf\"\u003eGo To Statement Considered\nHarmful\u003c/a\u003e paper.  But the ability to transfer control to another part of\nyour program without invoking a function call is key to the\noptimization.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id=\"outline-container-headline-3\" class=\"outline-2\"\u003e\n\u003ch2 id=\"headline-3\"\u003e\nThe Approach\n\u003c/h2\u003e\n\u003cdiv id=\"outline-text-headline-3\" class=\"outline-text-2\"\u003e\n\u003cp\u003e\nSince the strategy is general, let\u0026#39;s lose all the parentheses for a\nmoment and rewrite \u003ccode class=\"verbatim\"\u003esum-to-acc\u003c/code\u003e in language-agnostic pseudo-code:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efunction sum-to-acc(n sum)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   if n == 0, then return sum\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   return sum-to-acc(n - 1, n + sum)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nIn most languages (without TCO), when this function is called, the\nvalues of \u003ccode class=\"verbatim\"\u003en\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003esum\u003c/code\u003e, as well as the return address, will be put on\nthe stack, whose evolution looks something like the following.\u003csup class=\"footnote-reference\"\u003e\u003ca id=\"footnote-reference-1\" href=\"#footnote-1\"\u003e1\u003c/a\u003e\u003c/sup\u003e:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e first invocation: [n=5, sum=0,  ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esecond invocation: [n=4, sum=5,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=5, sum=0,  ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e third invocation: [n=3, sum=9,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=4, sum=5,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=5, sum=0,  ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efourth invocation: [n=2, sum=12, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=3, sum=9,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=4, sum=5,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=5, sum=0,  ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e fifth invocation: [n=1, sum=14, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=2, sum=12, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=3, sum=9,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=4, sum=5,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=5, sum=0,  ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e sixth invocation: [n=0, sum=15, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=1, sum=14, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=2, sum=12, ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=3, sum=9,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=4, sum=5,  ret=sum-to-acc:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   [n=5, sum=0,  ret=sum-to:...]\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAt the sixth invocation, our terminating condition is reached, and 15\nis returned, with all the pending stack frames popped off the stack.\u003c/p\u003e\n\u003cp\u003e\nWith TCO, the implementation looks more like the following:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efunction sum-to-acc(n sum)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTOP:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   if n == 0, then return sum\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   n = n - 1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   sum = sum + n\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   GOTO TOP\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nas a result, the evolution of the stack looks as follows:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e first invocation: [n=5, sum=0, ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esecond invocation: [n=4, sum=5, ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e third invocation: [n=3, sum=9, ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efourth invocation: [n=2, sum=12, ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e fifth invocation: [n=1, sum=14, ret=sum-to:...]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e sixth invocation: [n=0, sum=15, ret=sum-to:...]\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAll those extra stack frames are gone: recursion has turned into a form of iteration.\u003c/p\u003e\n\u003cp\u003e\nImplementing TCO, then, has two ingredients:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eReplace the values of the current arguments with their new values directly.\u003c/li\u003e\n\u003cli\u003eJump straight to the next call of the function without adding to the stack;\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThis low-level, imperative optimization makes high-level,\nfunctional, recursive implementations efficient.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id=\"outline-container-headline-4\" class=\"outline-2\"\u003e\n\u003ch2 id=\"headline-4\"\u003e\nImplementation\n\u003c/h2\u003e\n\u003cdiv id=\"outline-text-headline-4\" class=\"outline-text-2\"\u003e\n\u003cp\u003e\nIn thinking about the implementation for \u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e, I was pleased to learn\nthat Go actually has a \u003ccode class=\"verbatim\"\u003egoto\u003c/code\u003e statement.  However, my implementation\nwas poorly set up to use it.\u003c/p\u003e\n\u003cp\u003e\nEarly in the implementation of \u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e, I noticed that each data type\n(numbers, atoms, and lists) had its own evaluation rules, so it made\nsense to make use of Go\u0026#39;s features supporting polymorphism, namely\ninterfaces and receivers.  I had a \u003ccode class=\"verbatim\"\u003eSexpr\u003c/code\u003e interface which looked like the following:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etype Sexpr interface {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tString() string\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tEval(*env) (Sexpr, error)  // \u0026lt;--------\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tEqual(Sexpr) bool\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nNumbers and atoms, for example, had fairly simple \u003ccode class=\"verbatim\"\u003eEval\u003c/code\u003e\nimplementations.  For example,\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efunc (a Atom) Eval(e *env) (Sexpr, error) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tif a.s == \u0026#34;t\u0026#34; {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\treturn a, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tret, ok := e.Lookup(a.s)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tif ok {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\treturn ret, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tret, ok = builtins[a.s]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\tif ok {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t\treturn ret, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\treturn nil, fmt.Errorf(\u0026#34;unknown symbol: %s\u0026#34;, a.s)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAnd, of course, numbers eval to themselves:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efunc (n Number) Eval(e *env) (Sexpr, error) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\treturn n, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nLists, as you would expect, were more complicated – evaluating a list\nexpression needs to handle special forms\u003csup class=\"footnote-reference\"\u003e\u003ca id=\"footnote-reference-2\" href=\"#footnote-2\"\u003e2\u003c/a\u003e\u003c/sup\u003e,\nuser-defined functions, and built-in functions.  Following the classic\n\u003ca href=\"https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs\"\u003eStructure and Interpretation of Computer Programs\u003c/a\u003e, I separated the\ncore logic for function application into separate \u003ccode class=\"verbatim\"\u003eEval\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003eApply\u003c/code\u003e\nphases.  And to prevent the \u003ccode class=\"verbatim\"\u003eEval\u003c/code\u003e for lists from getting too large, I\nbroke out the evaluation rules for different cases (e.g. for \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e and\n\u003ccode class=\"verbatim\"\u003econd\u003c/code\u003e special forms and for function application) into their own\nfunctions.\u003c/p\u003e\n\u003cp\u003e\nIn other words, I had evaluation logic spread over ten functions in\nfive files.  Sadly, the need to jump back to the beginning of an\nevaluation rather than recursively calling \u003ccode class=\"verbatim\"\u003eEval\u003c/code\u003e again meant that\nseveral of those nicely broken out functions had to be brought\ntogether into a single function, because \u003ccode class=\"verbatim\"\u003egoto\u003c/code\u003e \u003ca href=\"https://go.dev/ref/spec#Goto_statements\"\u003edoes not support\njumping from one function to another\u003c/a\u003e.  (C has \u003ccode class=\"verbatim\"\u003esetjmp\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003elongjmp\u003c/code\u003e,\nwhich effectively do this, but I would want to upgrade my IQ by a\nfew points before applying them in this situation.)\u003c/p\u003e\n\u003cp\u003e\nThere were actually three cases where I was performing an evaluation\nstep right before returning, and the \u003ccode class=\"verbatim\"\u003egoto\u003c/code\u003e pattern could be used:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWhen evaluating code in the tail position of a user-defined function;\u003c/li\u003e\n\u003cli\u003eWhen evaluating code in the last expression in a \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e block;\u003c/li\u003e\n\u003cli\u003eWhen evaluating code in the chosen branch of a \u003ccode class=\"verbatim\"\u003econd\u003c/code\u003e clause.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eI wound up with code which with looks like the following.  Several\nsteps are indicated only with comments.  Note the tiny, easy-to-miss\n\u003cstrong\u003e\u003ccode class=\"verbatim\"\u003etop:\u003c/code\u003e\u003c/strong\u003e label at the very beginning:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e// lisp.go\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e//\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efunc eval(expr Sexpr, e *env) (Sexpr, error) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cstrong\u003etop:\u003c/strong\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tswitch t := expr.(type) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcase Atom:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\treturn evAtom(t, e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcase Number:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\treturn expr, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t// ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcase *ConsCell:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tif t == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\treturn Nil, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t// special forms:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tif carAtom, ok := t.car.(Atom); ok {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tswitch {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tcase carAtom.s == \u0026#34;quote\u0026#34;:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\treturn t.cdr.(*ConsCell).car, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tcase carAtom.s == \u0026#34;cond\u0026#34;:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tpairList := t.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tif pairList == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\treturn Nil, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tfor {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif pairList == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\treturn Nil, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tpair := pairList.car.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tev, err := eval(pair.car, e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif err != nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\treturn nil, err\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif ev == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\tpairList = pairList.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\tcontinue\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\texpr = pair.cdr.(*ConsCell).car\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\u003cstrong\u003egoto top\u003c/strong\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t// ...\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThe code so far shows the evaluation for atoms, numbers, and \u003ccode class=\"verbatim\"\u003econd\u003c/code\u003e\nstatements.  \u003ccode class=\"verbatim\"\u003econd\u003c/code\u003e does not introduce any new bindings, but when the\nfirst truthy condition is encountered, it evaluates the next argument\nas its final act.  So the code above simply replaces the expression to\nbe evaluated, \u003ccode class=\"verbatim\"\u003eexpr\u003c/code\u003e, with the expression from the matching clause,\nand then restarts the evaluation via \u003ccode class=\"verbatim\"\u003egoto\u003c/code\u003e, without the overhead of a\nseparate function call.\u003c/p\u003e\n\u003cp\u003e\nThe code for \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e is somewhat similar:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tcase carAtom.s == \u0026#34;let\u0026#34;:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\targs := t.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tif args == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\treturn nil, fmt.Errorf(\u0026#34;let requires a binding list\u0026#34;)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t// ... code to set up let bindings ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tbody := args.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tvar ret Sexpr = Nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tfor {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tvar err error\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif body == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\treturn ret, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t// Implement TCO for `let`:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif body.cdr == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\texpr = body.car\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\te = \u0026amp;newEnv\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\u003cstrong\u003egoto top\u003c/strong\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tret, err = eval(body.car, \u0026amp;newEnv)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tif err != nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\treturn nil, err\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\tbody = body.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\nThe \u003ccode class=\"verbatim\"\u003efor\u003c/code\u003e loop invokes a new \u003ccode class=\"verbatim\"\u003eeval\u003c/code\u003e for each expression in the body of\nthe \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e, \u003cem\u003eexcept\u003c/em\u003e for the last one: when the last expression is\nreached, (the \u003ccode class=\"verbatim\"\u003ecdr\u003c/code\u003e is \u003ccode class=\"verbatim\"\u003eNil\u003c/code\u003e), the last \u003ccode class=\"verbatim\"\u003eeval\u003c/code\u003e is done by jumping to\nthe beginning of the function, once it has updated its environment to\npoint to include the new bindings.\u003c/p\u003e\n\u003cp\u003e\nThe last use of this pattern is in function invocation proper, which looks similar:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t// (... code to set up new environment based on passed arguments ...)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tvar ret Sexpr = Nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tfor {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tif lambda.body == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\treturn ret, nil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t// TCO:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tif lambda.body.cdr == Nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\texpr = lambda.body.car\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\te = \u0026amp;newEnv\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\u003cstrong\u003egoto top\u003c/strong\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tret, err = eval(lambda.body.car, \u0026amp;newEnv)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tif err != nil {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\treturn nil, err\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tlambda.body = lambda.body.cdr.(*ConsCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\nI\u0026#39;ve skipped various parts of \u003ccode class=\"verbatim\"\u003eeval\u003c/code\u003e that aren\u0026#39;t relevant for TCO\noptimization – if you\u0026#39;re interested, you can \u003ca href=\"https://github.com/eigenhombre/l1/blob/5873705ab1badb16dd1f1586bb7cc13467287187/lisp.go#L126\"\u003echeck out the code\u003c/a\u003e\nyourself.\u003c/p\u003e\n\u003cp\u003e\nTo be clear, what we are optimizing is all tail calls, not just\nrecursive ones – though the recursive ones were the primary objective\ndue to the stack overflows reported above.\u003c/p\u003e\n\u003cp\u003e\nThe end result is that \u003ccode class=\"verbatim\"\u003esum-to\u003c/code\u003e now can complete for large values of\n$n$:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(sum-to (* 1000 1000))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e500000500000\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nIncidentally, a variant of our test case failed before I added the TCO\noptimization to \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e shown above; this now works, as well:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sum-to-acc-with-let (n acc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (let ((_ 1))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    (cond ((zero? n) acc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e          (t (sum-to-acc-with-let (- n 1) (+ n acc))))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn sum-to-with-let (n) (sum-to-acc-with-let n 0))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(sum-to-with-let (* 1000 1000))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e500000500000\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"outline-container-headline-5\" class=\"outline-2\"\u003e\n\u003ch2 id=\"headline-5\"\u003e\nConclusion\n\u003c/h2\u003e\n\u003cdiv id=\"outline-text-headline-5\" class=\"outline-text-2\"\u003e\n\u003cp\u003e\nGetting tail-call optimization to work was very satisfying… though\nthe \u003ccode class=\"verbatim\"\u003eeval\u003c/code\u003e implementation is certainly more complex than before.  (Ah,\noptimization!)\u003c/p\u003e\n\u003cp\u003e\nTo ensure TCO continues to work, variants of \u003ccode class=\"verbatim\"\u003esum-to\u003c/code\u003e with and without \u003ccode class=\"verbatim\"\u003elet\u003c/code\u003e are \u003ca href=\"https://github.com/eigenhombre/l1/blob/5873705ab1badb16dd1f1586bb7cc13467287187/Makefile#L17\"\u003erun\non every build\u003c/a\u003e, along with a few other short example programs.\u003c/p\u003e\n\u003cp\u003e\nAfter implementing TCO in my own code, I can appreciate and understand\nthe optimization better when I see it in the wild.  I fully expect to\nuse the pattern again when implementing future lisps (yes, I hope there\nwill be more).\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"footnotes\"\u003e\n\u003chr class=\"footnotes-separatator\"/\u003e\n\u003cdiv class=\"footnote-definitions\"\u003e\n\u003cdiv class=\"footnote-definition\"\u003e\n\u003csup id=\"footnote-1\"\u003e\u003ca href=\"#footnote-reference-1\"\u003e1\u003c/a\u003e\u003c/sup\u003e\n\u003cdiv class=\"footnote-body\"\u003e\n\u003cp\u003eNote that this is a somewhat abstract representation: the details are language-specific.  The \u003ccode class=\"verbatim\"\u003eret=sum-to:...\u003c/code\u003e notation means that when the function returns, control will pass back to where it left off inside the \u003ccode class=\"verbatim\"\u003esum-to\u003c/code\u003e function.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"footnote-definition\"\u003e\n\u003csup id=\"footnote-2\"\u003e\u003ca href=\"#footnote-reference-2\"\u003e2\u003c/a\u003e\u003c/sup\u003e\n\u003cdiv class=\"footnote-body\"\u003e\n\u003cp\u003eA special form is one that does not follow the normal evaluation rule for functions – it may evaluate its arguments once, many times, or not at all.  (I am glossing over macros for the time being; \u003ccode class=\"verbatim\"\u003el1\u003c/code\u003e does not have them yet.)\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/practices/\"\u003ePractices for Software Projects\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/tests-by-example/\"\u003eTests by Example in Clojure and Common Lisp\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2022-08-08T00:00:00Z",
  "Author": "John Jacobsen"
}