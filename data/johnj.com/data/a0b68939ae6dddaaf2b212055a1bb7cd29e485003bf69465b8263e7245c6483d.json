{
  "Source": "johnj.com",
  "Title": "Continuous Testing in Python, Clojure and Blub",
  "Link": "http://johnj.com/posts/continuous-testing/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eContinuous Testing in Python, Clojure and Blub\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/clojure\"\u003e\u003cspan class=\"clojure-tag\"\u003eclojure\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/python\"\u003e\u003cspan class=\"python-tag\"\u003epython\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2012-03-31T00:00:00Z\"\u003e\n      March 31, 2012\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/resources-for-learning-clojure/\"\u003eResources for Learning Clojure\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/programming-languages/\"\u003eProgramming Languages\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003cfigure\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/paintbrushes-optional.jpg\"\u003e\u003cimg class=\"resize\" src=\"/paintbrushes-optional_hua2ab40c77e1163cdda8974d62d4acc55_1724878_700x0_resize_q75_box.jpg\" style=\"width:700px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\n\u003cfigcaption\u003e\nA separate monitor is handy for showing tests results continuously while working. The paintbrushes are strictly optional.\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003e\n\u003cstrong\u003eWhat follows is a somewhat rambling introduction to continuous, test-driven development, focusing mainly on Python and influenced by Clojure tools and philosophy. At the end, a simple script is introduced to help facilitate continuous TDD in (almost) any language.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\nFor the last four years I have increasingly followed a test-driven\napproach in my development. My approach continues to evolve and deepen\neven as some of the \u003ca href=\"http://patrick.lioi.net/2011/11/23/guard-rail-programming/\"\u003elimits of TDD\u003c/a\u003e are becoming clearer to me.\u003c/p\u003e\n\u003cp\u003e\nInitially, I had a hard time getting my head around TDD. Writing tests\nAND production code seemed like twice as much work, and, even before I\nwrote tests, I typically ran the program under development, e.g. with\nprint statements added, to test each change. But making changes to old\ncode was always a fairly daunting proposition, since there was no way\nto validate all the assumptions I’d checked “by eye” just after I’d\nwritten the code.\u003c/p\u003e\n\u003cp\u003e\nTDD helps reduce risk by continuously verifying your assumptions about\nhow the code should perform at any time. Using TDD for \u003ca href=\"https://arxiv.org/abs/1612.05093\"\u003ea fairly large\nproject\u003c/a\u003e has saved my bacon any number of times.\u003c/p\u003e\n\u003cp\u003e\nThe basic approach is that the test code and the production code\nevolve together more or less continuously, as one follows these rules:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDon’t write any production code without a failing unit test;\u003c/li\u003e\n\u003cli\u003eWrite only enough production code needed to make the tests pass.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eOnce I started writing tests for all new production code, I found I\ncould change that code and make it better without fear. That led to\nmuch better (and usually simpler) code. I realized I was spending much\nless time debugging; and when there were bugs, the tests helped find\nthem much faster. As I have gained experience with this approach I\nhave found that the reliability of, and my trust in, my code written\nwith TDD is vastly superior than otherwise. The two-rule cycle also\ntends to foster simplicity, as one tends to eschew any modifications\nthat don’t actually achieve the desired objectives (i.e. meet the\ngoals of the software, as specified formally in the tests\nthemselves). The process is also surprisingly agreeable!\u003c/p\u003e\n\u003cp\u003e\nIt goes without saying that if you follow this approach you will be\nrunning your tests a lot. The natural next step is to automate this\nmore. In the book Foundations of Agile Python Development, Jeff\nYounker explains how to make Eclipse run your unit tests every time\nyou save a file in the project. The speed and convenience of this\napproach was enough to get me to switch from Emacs to Eclipse for\nawhile.\u003c/p\u003e\n\u003cp\u003e\nMost of my daily programming work is in Python, but I have been an\navid \u003ca href=\"/posts/in-defense-of-hobbies\"\u003ehobbyist\u003c/a\u003e in Clojure for several months now. It wasn’t until I saw\nBill Caputo’s preparatory talk for Clojure/West here in Chicago that I\nheard the term continuous testing and realized that this is what I was\nalready doing; namely, the natural extension of TDD in which one runs\ntests continuously rather than “by hand.” Bill demoed the expectations\nmodule and the autoexpect plugin for Leiningen, which runs your tests\nafter every save without incurring the overhead of starting a fresh\nJVM each time.\u003c/p\u003e\n\u003cp\u003e\n(One point Bill made in his talk was that if your tests are slow,\ni.e. if you introduce some new inefficiency, you really notice\nit. Ideally the tests should take a few seconds or less to complete.)\u003c/p\u003e\n\u003cp\u003e\nBack to Python-land. Not wanting to be always leashed to Eclipse, and\ninspired by the autoexpect plugin, I started looking for an\nalternative to using Eclipse’s auto-builders — something I could use\nwith Emacs or any other editor. There are a lot of continuous build\nsystems out there, but I wanted something simple which would just run\non the command line on my laptop screen while I edited code on my\nlarger external monitor. I found \u003ca href=\"https://github.com/brunobord/tdaemon/blob/master/tdaemon.py\"\u003etdaemon\u003c/a\u003e on GitHub; this program walks\na directory tree and runs tests whenever anything changes (as\ndetermined by keeping a dictionary/map of SHA values for all the\nfiles). This is most of what I want, but it restricts you to its own\nchoices of test programs.\u003c/p\u003e\n\u003cp\u003e\nIn a large project with many tests, some fast and some slow, I often\nneed to specify a specific test program or arguments. For example, I\nhave a wrapper for \u003ca href=\"http://readthedocs.org/docs/nose/en/latest/\"\u003e\u003ccode class=\"verbatim\"\u003enosetests\u003c/code\u003e\u003c/a\u003e which will alternately run all my “fast”\nunit tests, check for PEP-8 compliance, run Django tests, etc. In some\ncases, such as debugging a system with multiple processes, I may need\nto do something complex at the shell prompt to set up and/or tear down\nenough infrastructure to perform an existing test in a new way.\u003c/p\u003e\n\u003cp\u003e\nOne piece of Clojure philosophy (from Functional Programming,\na.k.a. “FP”) that has been influencing my thinking of late is the\nnotion of \u003cstrong\u003ecomposability\u003c/strong\u003e: the decoupling or disentanglement of the\npieces of the systems one builds into small, general, composable\npieces. This will make those pieces easier to reuse in new ways, and\nwill also facilitate reasoning about their use and\nbehaviors. (Unfortunately, the merits of the FP approach, which are\nmany, have poisoned my enthusiasm for OO to the extent that I will\ntypically use a function, or even a closure, before using an object,\nwhich would perhaps be more Pythonic in some cases).\u003c/p\u003e\n\u003cp\u003e\nSo, in the current case under discussion (continuous testing), rather\nthan making some kind of stateful object which knows about not only\nyour current file system, but also what tests should be allowed, their\nunderlying dependencies, etc., it would be better (or at least more\n“functional”) instead to simply provide a directory-watching function\nthat checks a dictionary of file hashes, and compose that function\nwith whatever test program suits your purposes at the moment.\u003c/p\u003e\n\u003cp\u003e\nThe result of these thoughts is a small script called \u003ca href=\"https://github.com/eigenhombre/continuous-testing-helper\"\u003e\u003ccode class=\"verbatim\"\u003econttest\u003c/code\u003e\u003c/a\u003e which\nis a simplification of \u003ccode class=\"verbatim\"\u003etdaemon\u003c/code\u003e that composes well with any test suite\nyou can specify on the command line.\u003c/p\u003e\n\u003cp\u003e\nSome examples follow:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ conttest nosetests  # Runs nosetests whenever the files on disk change\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ conttest nosetests test.path:harness  # Runs only tests in \u0026#39;harness\u0026#39;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                        # object in path/to/test — handy\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                        # for developing a single feature\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                        # or fixing a single bug.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# Check both PEP-8 style and unit tests:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ conttest \u0026#39;pep8 -r . ; nosetests\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nIt would work equally well with a different language (“\u003ca href=\"http://www.paulgraham.com/avg.html\"\u003eblub\u003c/a\u003e language”)\nwith a separate compilation step:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ conttest \u0026#39;make \u0026amp;\u0026amp; ./run-tests\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nUsing this program, depending on my needs of the moment, I can\ncontinuously run a single unit test, all my “fast” unit tests, or, if\nI’m willing to deal with slower turnaround times, all my unit and\nintegration tests.\u003c/p\u003e\n\u003cp\u003e\nThe script is on \u003ca href=\"https://github.com/eigenhombre/continuous-testing-helper\"\u003eGitHub\u003c/a\u003e for your continuous enjoyment of continuous\ntesting. May you find it helpful.\u003c/p\u003e\n\u003cp\u003e\n(Ironically, this script does NOT work that well for JVM languages\nlike Clojure since the startup time is lengthy (a couple of seconds on\nmy MacBook Pro). Most of Clojure\u0026#39;s testing frameworks have autotest\ncapabilities built in, which work great.)\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/resources-for-learning-clojure/\"\u003eResources for Learning Clojure\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/programming-languages/\"\u003eProgramming Languages\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2012-03-31T00:00:00Z",
  "Author": "John Jacobsen"
}