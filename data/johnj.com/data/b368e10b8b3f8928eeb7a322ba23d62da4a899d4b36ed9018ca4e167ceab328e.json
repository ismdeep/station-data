{
  "Source": "johnj.com",
  "Title": "Lazy Physics",
  "Link": "http://johnj.com/posts/lazy-physics/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eLazy Physics\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/clojure\"\u003e\u003cspan class=\"clojure-tag\"\u003eclojure\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/physics\"\u003e\u003cspan class=\"physics-tag\"\u003ephysics\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2015-02-12T00:00:00Z\"\u003e\n      February 12, 2015\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/time-limits/\"\u003eTime Limits\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/fun-with-instaparse/\"\u003eFun with Instaparse\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003cp\u003e\n\u003cem\u003e… in which we explore lazy sequences and common functional idioms in Clojure via the example of looking for (nearly) coincident clusters of times in a series.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\nA fundamental technical problem in experimental particle physics is\nhow to distinguish the signatures of particles from instrumental\nnoise.\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/birds-on-wires.jpg\"\u003e\u003cimg class=\"resize\" src=\"/birds-on-wires_hueff924daeff5586b556b26ea5ba2dfe8_667591_700x0_resize_q75_box.jpg\" style=\"width:700px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\nImagine a tree full of hundreds of sparrows, each nesting on a branch,\neach chirping away occasionally. Suddenly, for a brief moment, they\nall start chirping vigorously (maybe a hawk flew past). A clustering\nof chirps in time is the signal that \u003cem\u003esomething has happened!\u003c/em\u003e The\nanalogous situation occurs in instruments consisting of many similar\ndetector elements, each generating some amount of random noise that,\non its own, is indistinguishable from any evidence left by particles,\nbut which, taken together, signals that, again, \u003cem\u003esomething has happened\u003c/em\u003e\n—a muon, an electron, a neutrino has left a sudden spume of\nelectronic evidence in your instrument, waiting to be read out and\ndistinguished from the endless noise.\u003c/p\u003e\n\u003cp\u003e\nThis process of separating the noise from the signal is known in\nphysics as \u003cem\u003etriggering\u003c/em\u003e and is typically done through some combination\nof spatial or time clustering; in many cases, time is the simplest to\nhandle and the first “line of defense” against being overrun by too\nmuch data. (It is often impractical to consume all the data generated\nby all the elements —data reduction is the name of the game at most\nstages of these experiments.)\u003c/p\u003e\n\u003cp\u003e\nThis data is typically generated continously ad infinitum, and must\ntherefore be processed differently than, say, a single file on\ndisk. Such infinite sequences of data are an excellent fit for the\nfunctional pattern known as \u003cem\u003elaziness\u003c/em\u003e, in which, rather than chewing up\nall your RAM and/or hard disk space, data is consumed and transformed\nonly as needed / as available. This kind of processing is baked into\nClojure at many levels and throughout its library of core functions,\ndozens of which can be combined (“composed”) to serve an endless\nvariety of data transformations. (This style of data wrangling is also\navailable in Python via generators and functional libraries such as\n\u003ca href=\"http://toolz.readthedocs.org/\"\u003eToolz\u003c/a\u003e.)\u003c/p\u003e\n\u003cp\u003e\nPrompted by a recent question on the topic from a physicist and former\ncolleague, I got to thinking about the classic problem of triggering,\nand realized that the time series trigger provides a nice showcase for\nClojure’s core library and for processing lazy sequences. The rest of\nthis post will describe a simple trigger, essentially what particle\nastrophysicists I know call a “simple majority trigger”; or a “simple\nmultiplicity trigger” (depending on whom you talk to).\u003c/p\u003e\n\u003cp\u003e\nNow for some Clojure code. (A small amount of familiarity with\nClojure’s simple syntax is recommended for maximum understanding of\nwhat follows.) We will build up our understanding through a series of\nsuccessively more complex code snippets. The exposition follows\nclosely what one might do in the Clojure REPL, building up\nsuccessively more complete examples. In each case, we use \u003ccode class=\"verbatim\"\u003etake\u003c/code\u003e to\nlimit what would otherwise be infinite sequences of data (so that our\nexamples can terminate without keeping us waiting forever…).\u003c/p\u003e\n\u003cp\u003e\nFirst we create a sorted, infinite series of ever-increasing times\n(in, say, nsec):\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(def times (iterate #(+ % (rand-int 1000)) 0))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;; Caution: infinite sequence...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(take 30 times)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(0 955 1559 2063 2735 2858 3542 4067 4366 5246 5430 6168 7127 7932\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e 8268 8929 9426 9918 10436 10850 11680 12367 12569 13343 14155 14420\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e 15062 15171 15663 16355)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n\u003ccode class=\"verbatim\"\u003etimes\u003c/code\u003e is an infinite (but “unrealized”) series, constructed by\niterating the anonymous function \u003ccode class=\"verbatim\"\u003e#(+ % (rand-int 1000))\u003c/code\u003e which adds a\nrandom integer from 0 to 999 to its argument (starting with zero). The\nfact that it is infinite does not prevent us from defining it or\n(gingerly) interrogating it via take\u003csup class=\"footnote-reference\"\u003e\u003ca id=\"footnote-reference-1\" href=\"#footnote-1\"\u003e1\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e\n\u003cp\u003e\nNow, the way we’ll look for excesses is to look for groupings of hits\n(say, eight of them) whose first and last hit times are within 1\nmicrosecond (1000 nsec) of each other. To start, there is a handy\nfunction called \u003ccode class=\"verbatim\"\u003epartition\u003c/code\u003e which groups a series in blocks of fixed\nlength:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(take 10 (partition 8 times))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e((0 955 1559 2063 2735 2858 3542 4067)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (4366 5246 5430 6168 7127 7932 8268 8929)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (9426 9918 10436 10850 11680 12367 12569 13343)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (14155 14420 15062 15171 15663 16355 16700 16947)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (17919 17949 18575 18607 18849 19597 20410 20680)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (20737 21289 21315 21323 21426 21637 22422 23000)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (23477 24351 24426 25106 25861 26568 27511 28332)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (29071 29831 29957 30761 31073 31914 32591 33187)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (33878 34739 34842 35674 36444 36960 36983 37400)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (37587 38012 38969 39131 39317 40135 40587 40759))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nWe’ll rewrite this using Clojure’s thread-last macro \u003ccode class=\"verbatim\"\u003e-\u0026gt;\u0026gt;\u003c/code\u003e, which is a\nvery helpful tool for rewriting nested expressions as a more readable\npipeline of successive function applications:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e((0 955 1559 2063 2735 2858 3542 4067)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (4366 5246 5430 6168 7127 7932 8268 8929)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e ...same as above...)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nHowever, this isn’t quite what we want, because it won’t find clusters\nof times close together who don’t happen to begin on our \u003ccode class=\"verbatim\"\u003epartition\u003c/code\u003e\nboundaries. To fix this, we use the optional \u003ccode class=\"verbatim\"\u003estep\u003c/code\u003e argument to\n\u003ccode class=\"verbatim\"\u003epartition\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e((0 955 1559 2063 2735 2858 3542 4067)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (955 1559 2063 2735 2858 3542 4067 4366)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (1559 2063 2735 2858 3542 4067 4366 5246)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (2063 2735 2858 3542 4067 4366 5246 5430)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (2735 2858 3542 4067 4366 5246 5430 6168)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (2858 3542 4067 4366 5246 5430 6168 7127)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (3542 4067 4366 5246 5430 6168 7127 7932)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (4067 4366 5246 5430 6168 7127 7932 8268)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (4366 5246 5430 6168 7127 7932 8268 8929)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e (5246 5430 6168 7127 7932 8268 8929 9426))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThis is getting closer to what we want—if you look carefully, you’ll\nsee that each row consists of the previous one shifted by one\nelement. The next step is to grab (via \u003ccode class=\"verbatim\"\u003emap\u003c/code\u003e) the first and last times\nof each group, using \u003ccode class=\"verbatim\"\u003ejuxt\u003c/code\u003e to apply both \u003ccode class=\"verbatim\"\u003efirst\u003c/code\u003e and \u003ccode class=\"verbatim\"\u003elast\u003c/code\u003e to each\nsubsequence….\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (map (juxt last first))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e([4067 0]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [4366 955]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5246 1559]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [5430 2063]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [6168 2735]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [7127 2858]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [7932 3542]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [8268 4067]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [8929 4366]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [9426 5246])\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n… and turn these into time differences:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (map (comp (partial apply -) (juxt last first)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(4067 3411 3687 3367 3433 4269 4390 4201 4563 4180)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nNote that so far these time differences are all \u0026gt; 1000. \u003ccode class=\"verbatim\"\u003ecomp\u003c/code\u003e, above,\nturns a collection of multiple functions into a new function which is\nthe composition of these functions, applied successively one after the\nother (right-to-left). \u003ccode class=\"verbatim\"\u003epartial\u003c/code\u003e turns a function of multiple arguments\ninto a function of fewer arguments, by binding one or more of the\narguments in a new function. For example,\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e((partial + 2) 3)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e5\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e((comp (partial apply -) (juxt last first)) [3 10])\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e7\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nRecall that we only want events whose times are close to each other;\nsay, whose duration is under a maximum limit of 1000 nsec. In general,\nto select only the elements of a sequence which satisfy a filter\nfunction, we use \u003ccode class=\"verbatim\"\u003efilter\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (map (comp (partial apply -) (juxt last first)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (filter (partial \u0026gt; 1000))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(960 942 827 763 597 682 997 836 986 966)\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n(\u003ccode class=\"verbatim\"\u003e(partial \u0026gt; 1000)\u003c/code\u003e is a function of one argument which returns true if\nthat argument is strictly less than 1000.)\u003c/p\u003e\n\u003cp\u003e\nGreat! We now have total “durations”; for subsequences of 8 times, where the total durations are less than 1000 nsec.\u003c/p\u003e\n\u003cp\u003e\nBut this is not actually that helpful. It would be better if we could get both the total durations and the actual subsequences satisfying the requirement (the analog of this in a real physics experiment would be returning the actual hit data falling inside the trigger window).\u003c/p\u003e\n\u003cp\u003e\nTo do this, \u003ccode class=\"verbatim\"\u003ejuxt\u003c/code\u003e once again comes to the rescue, by allowing us to\n\u003ccode class=\"verbatim\"\u003ejuxt\u003c/code\u003e-apose the original data alongside the total duration to show both\ntogether….\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (map (juxt identity (comp (partial apply -) (juxt last first))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 10))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e([(0 309 410 562 979 1423 2180 3159) 3159]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(309 410 562 979 1423 2180 3159 3585) 3276]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(410 562 979 1423 2180 3159 3585 4325) 3915]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(562 979 1423 2180 3159 3585 4325 4573) 4011]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(979 1423 2180 3159 3585 4325 4573 5074) 4095]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(1423 2180 3159 3585 4325 4573 5074 5942) 4519]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(2180 3159 3585 4325 4573 5074 5942 6599) 4419]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(3159 3585 4325 4573 5074 5942 6599 7458) 4299]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(3585 4325 4573 5074 5942 6599 7458 8128) 4543]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(4325 4573 5074 5942 6599 7458 8128 8439) 4114])\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n… and adapt our filter slightly to apply our filter only to the time\nrather than the original data:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (map (juxt identity (comp (partial apply -) (juxt last first))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (filter (comp (partial \u0026gt; 1000) second))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (take 3))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;;=\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e([(1577315 1577322 1577514 1577570 1577793 1577817 1577870 1578151)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  836]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(3119967 3120203 3120416 3120469 3120471 3120620 3120715 3120937)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  970]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e [(6752453 6752483 6752522 6752918 6752966 6753008 6753026 6753262)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  809])\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nFinally, to turn this into a function for later use, use \u003ccode class=\"verbatim\"\u003edefn\u003c/code\u003e and\nremove \u003ccode class=\"verbatim\"\u003etake\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn smt-8 [times]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (-\u0026gt;\u0026gt; times\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (partition 8 1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (map (juxt identity (comp (partial apply -) (juxt last first))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (filter (comp (partial \u0026gt; 1000) second))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\n\u003ccode class=\"verbatim\"\u003esmt-8\u003c/code\u003e consumes one, potentially infinite sequence and outputs another,\n“smaller” (but also potentially infinite) lazy sequence of\ntime-clusters-plus-durations, in the form shown above.\u003c/p\u003e\n\u003cp\u003e\nSome contemplation will suggest many variants; for example, one in\nwhich some number of hits outside the trigger “window” are also\nincluded in the output. This is left as an exercise for the advanced\nreader.\u003c/p\u003e\n\u003cp\u003e\nA “real” physics trigger would have to deal with many other details:\neach hit, in addition to its time, would likely have an amplitude, a\nsensor ID, and other data associated with it. Also, the data may not\nbe perfectly sorted, some sensors may drop out of the data stream,\netc. But in some sense this prototypical time clustering algorithm is\none of the fundamental building blocks of experimental high energy\nphysics and astrophysics and was used (in some variant) in every\nexperiment I worked on over a 25+ year period. The representation\nabove is certainly one of the most succinct, and shows off the power\nand elegance of the language, its core library, and lazy\nsequences. (It is also reasonably fast for such a simple algorithm;\n\u003ccode class=\"verbatim\"\u003esmt-8\u003c/code\u003e consumes input times at a rate of about 250 kHz. This is not,\nhowever, fast enough for an instrument like IceCube, whose 5160\nsensors each count at a rate of roughly 300 Hz, for a total rate of\n1.5 MHz. A future post may look at ways to get better performance.)\u003c/p\u003e\n\u003cdiv class=\"footnotes\"\u003e\n\u003chr class=\"footnotes-separatator\"/\u003e\n\u003cdiv class=\"footnote-definitions\"\u003e\n\u003cdiv class=\"footnote-definition\"\u003e\n\u003csup id=\"footnote-1\"\u003e\u003ca href=\"#footnote-reference-1\"\u003e1\u003c/a\u003e\u003c/sup\u003e\n\u003cdiv class=\"footnote-body\"\u003e\n\u003cp\u003eTo model a Poisson process — one in which any given event time is independent of the future or past times — one would normally choose an exponential rather than a uniformly flat distribution of time differences, but this is not important for our discussion, so, in the interest of simplicity, we’ll go with what we have here.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/time-limits/\"\u003eTime Limits\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/fun-with-instaparse/\"\u003eFun with Instaparse\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2015-02-12T00:00:00Z",
  "Author": "John Jacobsen"
}