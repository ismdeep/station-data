{
  "Source": "johnj.com",
  "Title": "Updating the Genome Decoder",
  "Link": "http://johnj.com/posts/updating-the-genome-decoder-resulting-consequences/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eUpdating the Genome Decoder\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/clojure\"\u003e\u003cspan class=\"clojure-tag\"\u003eclojure\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/genomics\"\u003e\u003cspan class=\"genomics-tag\"\u003egenomics\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2013-07-13T00:00:00Z\"\u003e\n      July 13, 2013\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/nucleotide-repetition-lengths/\"\u003eNucleotide Repetition Lengths\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/getting-our-hands-dirty/\"\u003eGetting Our Hands Dirty (with the Human Genome)\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\n\u003c/p\u003e\u003cp\u003e\nIn our \u003ca href=\"/posts/getting-our-hands-dirty/\"\u003elast post\u003c/a\u003e we saw that so-called “N-blocks” (regions of the\ngenome for which sequences are not available) were not getting decoded\ncorrectly by \u003ca href=\"/posts/a-two-bit-decoder\"\u003eour decoder\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003e\nThe solution is to look back into the so-called “file index” which\nspecifies where the N-blocks are, and how long each block is. The\nmodified decoder looks like this:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn genome-sequence\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Read a specific sequence, or all sequences in a file concatenated\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  together; return it as a lazy seq.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([fname]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (let [sh (sequence-headers fname)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (lazy-mapcat (partial genome-sequence fname) sh)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([fname hdr]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (let [ofs (:dna-offset hdr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           dna-len (:dna-size hdr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           byte-len (rounding-up-divide dna-len 4)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e           starts-and-lengths (get-buffer-starts-and-lengths ofs 10000 byte-len)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (-\u0026gt;\u0026gt; (for [[offset length] starts-and-lengths\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                  b (read-with-offset fname offset length)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e              (byte-to-base-pairs b))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            (apply concat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            (take dna-len)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            (map-indexed (fn [i x] (if (is-in-an-n-block i hdr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                    :N\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                    x)))))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThe primary modification is the \u003ccode class=\"verbatim\"\u003emap-indexed\u003c/code\u003e bit at the end, which\nlooks up the position of the base pair in the index using the\n\u003ccode class=\"verbatim\"\u003eis-in-an-n-block\u003c/code\u003e function:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn is-in-an-n-block\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([x hdr]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (let [{:keys [n-block-starts n-block-sizes]} hdr]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (is-in-an-n-block x n-block-starts n-block-sizes)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  ([x n-block-starts n-block-lengths]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (let [pairs (map (fn [a b] [a (+ a b)])\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                      n-block-starts n-block-lengths)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e       (some (fn [[a b]] (\u0026lt; (dec a) x b)) pairs))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nI tested the new decoder against FASTA files of the first two\nchromosomes of the human genome using the same procedure we used for\nyeast in \u003ca href=\"/posts/validating-the-genome-decoder\"\u003emy validation post\u003c/a\u003e.  The N-blocks (and all other sequences)\nwere decoded correctly.\u003c/p\u003e\n\u003cp\u003e\nThe astute reader will note the use of \u003ccode class=\"verbatim\"\u003elazy-mapcat\u003c/code\u003e instead of =mapcat:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defn lazy-mapcat\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Fully lazy version of mapcat.  See:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  http://clojurian.blogspot.com/2012/11/beware-of-mapcat.html\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  [f coll]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  (lazy-seq\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e   (if (not-empty coll)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e     (concat\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (f (first coll))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e      (lazy-mapcat f (rest coll))))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nA version of \u003ccode class=\"verbatim\"\u003egenome-sequence\u003c/code\u003e which used mapcat instead of \u003ccode class=\"verbatim\"\u003elazy-mapcat\u003c/code\u003e\nworked fine for individual chromosomes (file sections), but\nconsistently ran out of memory when processing whole genome files. It\ntook a bit of research and hair-pulling to figure out that there is a\nrough edge with mapcat operating on large lazy sequences.\u003c/p\u003e\n\u003cp\u003e\nLazy sequences are a strength of Clojure in general – they allow one\nto process large, or even infinite, sequences of data without running\nout of memory, by consuming and emitting values only as needed, rather\nthan all at once. Many of the core functions and macros in Clojure\noperate on sequences lazily (producing lazy sequences as output),\nincluding \u003ccode class=\"verbatim\"\u003emap\u003c/code\u003e, \u003ccode class=\"verbatim\"\u003efor\u003c/code\u003e, \u003ccode class=\"verbatim\"\u003econcat\u003c/code\u003e, and so on. \u003ccode class=\"verbatim\"\u003emapcat\u003c/code\u003e is among these; however,\n\u003ccode class=\"verbatim\"\u003emapcat\u003c/code\u003e is apparently not “maximally lazy” when concatenating other\nlazy seqs, causing excessive memory consumption as explained in this\nblog post. Using that post’s fully lazy (if slightly slower) version\nof \u003ccode class=\"verbatim\"\u003emapcat\u003c/code\u003e fixed my memory leak as well. Though lazy seqs are awesome\nin many ways, one does have to be careful of gotchas such as this one.\u003c/p\u003e\n\u003cp\u003e\nSo, in the process of handling this relatively large dataset, we have\ndiscovered two rough edges of Clojure, namely with \u003ccode class=\"verbatim\"\u003emapcat\u003c/code\u003e and\n\u003ccode class=\"verbatim\"\u003ecount\u003c/code\u003e. We shall see if other surprises await us. Meanwhile, the latest\ncode is \u003ca href=\"https://github.com/eigenhombre/jenome\"\u003eup on GitHub\u003c/a\u003e.\u003c/p\u003e\n\u003cdiv id=\"outline-container-headline-1\" class=\"outline-3\"\u003e\n\u003ch3 id=\"headline-1\"\u003e\nBack to Frequencies\n\u003c/h3\u003e\n\u003cdiv id=\"outline-text-headline-1\" class=\"outline-text-3\"\u003e\n\u003cp\u003e\nNow that we are armed with a decoder which handles N-blocks correctly,\nlet us return to our original problem: nucleotide frequencies. For\nyeast, we again have:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ejenome.core\u0026gt; (-\u0026gt;\u0026gt; yeast genome-sequence frequencies)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e{:C 2320576, :A 3766349, :T 3753080, :G 2317100}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nSame as last time. For humans,\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ejenome.core\u0026gt; (-\u0026gt;\u0026gt; human genome-sequence frequencies)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e{:N 239850802, :T 856055361, :A 854963149, :C 592966724, :G 593325228}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAs expected, the GAC numbers are the same as what we had previously;\nonly T and N have changed. The distributions look like so:\u003c/p\u003e\n\u003cfigure\u003e\n\n\n\n\n\n\u003ca href=\"http://johnj.com/hg-yeast-frequencies-2.png\"\u003e\u003cimg class=\"resize\" src=\"/hg-yeast-frequencies-2_hu1d7e5d571a608b99987a2fddecb83250_37540_700x0_resize_box_3.png\" style=\"width:700px; border:0px solid black;\"/\u003e\u003c/a\u003e\n\n\n\u003cfigcaption\u003e\nUpdated nucleotide frequencies\n\u003c/figcaption\u003e\n\u003c/figure\u003e\n\u003cp\u003e\nWe can see that \u003ca href=\"http://en.wikipedia.org/wiki/Chargaff\u0026#39;s_rules\"\u003eChargaff’s Rule\u003c/a\u003e obtains now: A/T ratios are equal, as\nare G/C ratios. (BTW, this rule is intuitively obvious if you consider\nthat in the double-helix structure, As are paired with Ts and Gs are\npaired with Cs.) Interestingly, the relative abundance of GC pairs in\nthe human genome is higher than it is in yeast.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id=\"outline-container-headline-2\" class=\"outline-3\"\u003e\n\u003ch3 id=\"headline-2\"\u003e\nTiming and Parallelizing\n\u003c/h3\u003e\n\u003cdiv id=\"outline-text-headline-2\" class=\"outline-text-3\"\u003e\n\u003cp\u003e\nMany of these “queries” on our data take a long time to run\n(particularly for the human genome). So as not to tie up my REPL and\npreventing me from doing other (presumably shorter) experiments, I\nfind it helpful to run such tasks inside a little macro (similar to\nClojure’s time) which performs the computation in a thread and, when\nthe task is finished, prints the time elapsed, the code that was run,\nand the result:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defmacro tib\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  tib: Time in the Background\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Run body in background, printing body and showing result when it\u0026#39;s done.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  [expr]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  `(future (let [code# \u0026#39;~expr\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                 start# (. System (nanoTime))]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             (println \u0026#34;Starting\u0026#34; code#)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e             (let [result# ~expr\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   end# (. System (nanoTime))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                   dursec# (/ (double (- end# start#)) (* 1000 1000 1000.0))]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               (println (format \u0026#34;Code: %s\\nTime: %.6f seconds\\nResult: %s\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                code#\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                dursec#\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                result#))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               result#))))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nFor example, our overflowing \u003ccode class=\"verbatim\"\u003ecount\u003c/code\u003e runs as follows:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(tib (count (range (* 1000 1000 1000 3))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eStarting (count (range (* 1000 1000 1000 3)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e;; ...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCode: (count (range (* 1000 1000 1000 3)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTime: 399.204845 seconds\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eResult: -1294967296\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nAnother tool which has proved useful is:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e(defmacro pseq\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  Apply threading of funcs in parallel through all sequences specified\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  in the index of fname.\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  [fname \u0026amp; funcs]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  `(pmap #(-\u0026gt;\u0026gt; (genome-sequence ~fname %)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               ~@funcs)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e         (sequence-headers ~fname)))\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThis threads one or more \u003ccode class=\"verbatim\"\u003efuncs\u003c/code\u003e through all the sequences in the file,\nas mapped out by the file headers. The magic here is \u003ccode class=\"verbatim\"\u003epmap\u003c/code\u003e, which is\n\u003ccode class=\"verbatim\"\u003emap\u003c/code\u003e parallelized onto separate threads across all available\ncores. \u003ccode class=\"verbatim\"\u003epseq\u003c/code\u003e maxes out the CPU on my quad-core Macbook Pro and gives\nresults significantly faster:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCode: (-\u0026gt;\u0026gt; yeast genome-sequence frequencies)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTime: 33.090855 seconds\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eResult: {:C 2320576, :A 3766349, :T 3753080, :G 2317100}\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eCode: (apply (partial merge-with +) (pseq yeast frequencies))\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eTime: 16.056695 seconds\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eResult: {:C 2320576, :A 3766349, :T 3753080, :G 2317100}\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nWith our updated decoder and these new tools, we can \u003ca href=\"/posts/nucleotide-repetition-lengths\"\u003econtinue our\npoking and prodding of the genome\u003c/a\u003e in subsequent posts.\u003c/p\u003e\n\u003c/div\u003e\n\u003c/div\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/nucleotide-repetition-lengths/\"\u003eNucleotide Repetition Lengths\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/getting-our-hands-dirty/\"\u003eGetting Our Hands Dirty (with the Human Genome)\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2013-07-13T00:00:00Z",
  "Author": "John Jacobsen"
}