{
  "Source": "johnj.com",
  "Title": "Processes vs. Threads for Integration Testing",
  "Link": "http://johnj.com/posts/process-vs-threads/",
  "Content": "\u003cmain class=\"content\"\u003e\n\n\n\u003ch1\u003eProcesses vs. Threads for Integration Testing\u003c/h1\u003e\n\n\n\u003cp\u003e\n\n\u003ca class=\"tag\" href=\"/tags/python\"\u003e\u003cspan class=\"python-tag\"\u003epython\u003c/span\u003e\u003c/a\u003e\n\n\u003ca class=\"tag\" href=\"/tags/code\"\u003e\u003cspan class=\"code-tag\"\u003ecode\u003c/span\u003e\u003c/a\u003e\n\n  ..... \u003cem\u003e\u003ctime class=\"postdate\" datetime=\"2013-04-19T00:00:00Z\"\u003e\n      April 19, 2013\n    \u003c/time\u003e\u003c/em\u003e\n\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/intro-to-context-managers-in-python/\"\u003eIntroduction to Context Managers in Python\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/resources-for-learning-clojure/\"\u003eResources for Learning Clojure\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003cp\u003e\nPython has become notorious for being somewhat problematic when it\ncomes to concurrency. The language supports threads, but performance\nis known to be dismal in some cases. In particular, \u003ca href=\"http://www.dabeaz.com/GIL/\"\u003eas David Beazley\ndiscovered\u003c/a\u003e, when I/O-bound and CPU-bound threads run in the same\nprogram, the GIL performs very badly (worse than if you ran the tasks\none after the other on a single thread/CPU). Alternative approaches\nwhich have become popular are to use asynchronous or event-driven\nprogramming techniques (\u003ca href=\"http://twistedmatrix.com/trac/\"\u003eTwisted\u003c/a\u003e, \u003ca href=\"http://docs.python.org/2/library/asyncore.html\"\u003easyncore\u003c/a\u003e), or to make heavy use of\nthe \u003ccode class=\"verbatim\"\u003emultiprocessing\u003c/code\u003e module.\u003c/p\u003e\n\u003cp\u003e\nThese wrinkles aside, there are situations where threads in Python are\nstill very useful. One of these is integration testing of distributed\nsystems.\u003c/p\u003e\n\u003cp\u003e\nImagine you have a distributed system with some 30 (or 3, or 300)\nsoftware components running on some cluster. These programs might\ninteract with a database, with a user via command line or a GUI (Web\nor otherwise), and with each other via a messaging or RPC protocol\n(XML-RPC, ZeroMQ, …).\u003c/p\u003e\n\u003cp\u003e\nWhile low-level (functional, unit) testing will perhaps be the bulk of\nyour tests, integration tests are important to make sure all the\nprograms talk to each other as they should. Like your other tests, you\nwant to automate these. And they should run as fast as possible to\noptimize the feedback cycle during development.\u003c/p\u003e\n\u003cp\u003e\nA straightforward way to test these components is to run them all in\nseparate programs (locally or distributed), each in their own\nprocess. However, you’re likely to get much better performance from\nyour many short-running tests if you run the components as local\nthreads in a single process. The components running in these threads\nwould, of course, still talk to each other via RPC, ZeroMQ, etc., same\nas if they were processes. But for short tests the setup and teardown\nfor threads is much faster. The most trivial example (assigning a\nvalue to a variabled) shows the difference dramatically:\u003c/p\u003e\n\u003cdiv class=\"src src-text\"\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-text\" data-lang=\"text\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# in ipython:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eimport threading, subprocess\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edoproc = lambda: subprocess.Popen([\u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;\u0026#39;a=1\u0026#39;\u0026#34;],\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                                  stdout=subprocess.PIPE).communicate()\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edef dothread():\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    def run():\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        a = 1\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    th = threading.Thread(target=run)\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    th.start()\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    th.join()\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etime junk = [doproc() for _ in range(500)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# CPU times: user 0.18 s, sys: 1.81 s, total: 1.98 s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# Wall time: 14.30 s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etime junk = [dothread() for _ in range(500)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# CPU times: user 0.09 s, sys: 0.05 s, total: 0.14 s\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e# Wall time: 0.16 s\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cp\u003e\nThat’s a factor of about a hundred – something you will most\ndefinitely notice in your test suite.\u003c/p\u003e\n\u003cp\u003e\nAnother advantage of this approach is that, when you write your code\nso that it can be run as threads, you can put as many or few of these\nthreads in actual processes (programs) as you’d like. In other words,\nthe coupling of processes to components is loosened. Your automated\ntests will force you to implement clean shutdown semantics for each\nthread (otherwise your test program will likely not terminate without\nmanual interruption).\u003c/p\u003e\n\u003cp\u003e\nFinally, it’s much easier to interrogate the state of each component\nwhen it’s running as a thread, than it is to query a subprocess (via\ne.g. RPC). This greatly simplifies the assertions you have to make in\nyour integration tests, since you don’t have to send a message of some\nsort via RPC or message queues – you can just query variables.\u003c/p\u003e\n\u003cp\u003e\nI found, while writing the automated tests in IceCube Live (the\ncontrol and monitoring system of the \u003ca href=\"https://icecube.wisc.edu/\"\u003eIceCube Neutrino Detector\u003c/a\u003e), that\nmaking components that could be instantiated in threads (for testing)\nor in processes (for production) greatly sped up my test suite and\nsimplified the actual tests quite a bit. I should note that, prior to\nrelease, there is still a final integration test done on a mirror test\nsystem which simulates actual data collection and makes sure IceCube\nLive can play along with other systems. The mirroring, however, is not\nexact, since the actual detector elements we deployed at South Pole\nare expensive and rely on a billion tons of crystal-clear ice to work\nas intended.\u003c/p\u003e\n\u003cp\u003e\nIn \u003ca href=\"/posts/intro-to-context-managers-in-python\"\u003ethe next post\u003c/a\u003e we will explore the use of context managers, which\nare helpful for organizing setup and teardown of complex tests cases\ninvolving multiple components.\u003c/p\u003e\n\n\n\n\u003cp\u003e\n\n\nLater: \u003ca href=\"http://johnj.com/posts/intro-to-context-managers-in-python/\"\u003eIntroduction to Context Managers in Python\u003c/a\u003e\n\n\n\u003cbr/\u003e\n\n\nEarlier: \u003ca href=\"http://johnj.com/posts/resources-for-learning-clojure/\"\u003eResources for Learning Clojure\u003c/a\u003e\n\n\n\u003c/p\u003e\u003cp\u003e\n\n\n\n\u003c/p\u003e\u003c/main\u003e",
  "Date": "2013-04-19T00:00:00Z",
  "Author": "John Jacobsen"
}