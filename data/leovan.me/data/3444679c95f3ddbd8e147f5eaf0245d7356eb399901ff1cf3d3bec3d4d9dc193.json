{
  "Source": "leovan.me",
  "Title": "利用 Flask 和 Google App Engine 部署模型服务",
  "Link": "https://leovan.me/cn/2018/10/serving-models-with-flask-and-gae/",
  "Content": "\u003carticle class=\"main\"\u003e\n    \u003cheader class=\"content-title\"\u003e\n    \n\u003ch1 class=\"title\"\u003e\n  \n  利用 Flask 和 Google App Engine 部署模型服务\n  \n\u003c/h1\u003e\n\n\n\n\n\n\n\n\u003ch2 class=\"author-date\"\u003e范叶亮 / \n2018-10-19\u003c/h2\u003e\n\n\n\n\u003ch3 class=\"post-meta\"\u003e\n\n\n\u003cstrong\u003e分类: \u003c/strong\u003e\n\u003ca href=\"/categories/%E7%BC%96%E7%A8%8B\"\u003e编程\u003c/a\u003e, \u003ca href=\"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\"\u003e机器学习\u003c/a\u003e, \u003ca href=\"/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0\"\u003e深度学习\u003c/a\u003e\n\n\n\n\n/\n\n\n\n\n\u003cstrong\u003e标签: \u003c/strong\u003e\n\u003cspan\u003eFlask\u003c/span\u003e, \u003cspan\u003eGoogle App Engine\u003c/span\u003e, \u003cspan\u003eGAE\u003c/span\u003e, \u003cspan\u003eRESTful\u003c/span\u003e, \u003cspan\u003e模型部署\u003c/span\u003e, \u003cspan\u003e模型服务\u003c/span\u003e\n\n\n\n\n/\n\n\n\u003cstrong\u003e字数: \u003c/strong\u003e\n4357\n\u003c/h3\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n    \n    \n    \u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"1261604535\"\u003e\u003c/ins\u003e\n    \u003cscript\u003e\n    (adsbygoogle = window.adsbygoogle || []).push({});\n    \u003c/script\u003e\n    \n    \n    \u003c/header\u003e\n\n\n\n\n\u003clink rel=\"stylesheet\" href=\"/css/admonition.css\"/\u003e\n\u003cdiv class=\"admonition admonition-note  kai\"\u003e\n  \u003cdiv class=\"admonition-content\"\u003e本文的配套代码请参见 \u003ca href=\"https://github.com/leovan/model-serving-demo\"\u003e这里\u003c/a\u003e，建议配合代码阅读本文。\u003c/div\u003e\n\u003c/div\u003e\n\u003ch1 id=\"模型部署和服务调用\"\u003e模型部署和服务调用\u003c/h1\u003e\n\u003cp\u003e对于做算法的同学，大家或多或少的更关心模型的性能指标多些，对于一些工程性问题考虑的较少。模型的部署是这些工程性问题中重要的一个，它直接关系到模型在生产系统的使用。一些成熟的机器学习框架会提供自己的解决方案，例如 \u003ca href=\"https://www.tensorflow.org\"\u003eTensorflow\u003c/a\u003e 提供的 \u003ca href=\"https://www.tensorflow.org/serving/\"\u003eServing\u003c/a\u003e 服务等。但很多情况下我们构建的工程可能不只使用了一种框架，因此一个框架自身的部署工具可能就很难满足我们的需求了。\u003c/p\u003e\n\u003cp\u003e针对此类情况，本文介绍一个 \u003cstrong\u003e简单\u003c/strong\u003e 的 \u003cstrong\u003e准生产\u003c/strong\u003e 模型部署方案。简单是指除了模型相关代码之外的工程性代码量不大，这得益于将要使用的 \u003ca href=\"http://flask.pocoo.org/\"\u003eFlask\u003c/a\u003e 框架。准生产是指这种部署方案应对一般的生产环境问题不大，对于高并发的场景可以通过横向扩容并进行负载均衡解决，但对于单次调用时效性要求较高的场景则需要另寻其他解决方案。\u003c/p\u003e\n\u003cp\u003e本文方案的模型部署和服务调用框架如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2018-10-19-serving-models-with-flask-and-gae/model-serving.png\" alt=\"Model-Serving\"/\u003e\u003c/p\u003e\n\u003cp\u003e其主要特性如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e服务端采用 Python 的 Flask 框架构建，无需使用其他外部服务。Flask 框架的 \u003ca href=\"https://zh.wikipedia.org/zh/%E5%BE%AE%E6%9C%8D%E5%8A%A1\"\u003e微服务\u003c/a\u003e (Microframework) 特性使得服务端代码简洁高效。\u003c/li\u003e\n\u003cli\u003e利用 \u003ca href=\"https://gunicorn.org/\"\u003eGunicorn\u003c/a\u003e 提供的高性能 Python WSGI HTTP UNIX Server，方便在服务端运行 Flask 应用。\u003c/li\u003e\n\u003cli\u003e客户端和服务端之间采用 \u003ca href=\"https://zh.wikipedia.org/zh/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\"\u003eRESTful API\u003c/a\u003e 调用方式，尽管在性能上可能不及其他一些方案 (例如：基于 RPC 的解决方案等)，但其较好地解决了跨语言交互的问题，不同语言之间交互仅需使用 HTTP 协议和 JSON 数据格式即可。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch1 id=\"flask-服务和-ajax-调用\"\u003eFlask 服务和 AJAX 调用\u003c/h1\u003e\n\u003ch2 id=\"flask-服务封装\"\u003eFlask 服务封装\u003c/h2\u003e\n\u003cp\u003e为了将模型代码和 Flask 服务进行整合，首先假设你已经对模型部分代码做了完美的封装 😎，整个工程先叫做 \u003ccode\u003emodel-serving-demo\u003c/code\u003e 吧。整理一下代码的目录结构，给一个我中意的 Python 目录结构风格：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emodel-serving-demo/                # 工程根目录\n├── bin/                           # 可执行命令目录\n|   ├─ start.sh                    # 启动脚本\n|   ├─ stop.sh                     # 停止脚本\n|   └─ ...\n├── conf/                          # 配置文件目录\n|   ├─ logging.conf                # 日志配置文件\n|   ├─ xxx_model.conf              # XXX Model 配置文件\n|   └─ ...\n├── data/                          # 数据文件目录\n├── docs/                          # 文档目录\n├── model_serving/                 # 模块根目录\n|   ├─ models/                     # 模型代码目录\n|   |   ├─ __init__.py\n|   |   ├─ xxx_model.py            # XXX Model 代码\n|   |   └─ ...\n|   ├─ resources/                  # Flask RESTful Resources 代码目录\n|   |   ├─ __init__.py\n|   |   ├─ xxx_model_resource.py   # XXX Model Flask RESTful Resources 代码\n|   |   └─ ...\n|   ├─ tests/                      # 测试代码根目录\n|   |   ├─ models                  # 模型测试代码目录\n|   |   |   ├─ __init__.py\n|   |   |   ├─ test_xxx_model.py   # XXX Model 测试代码\n|   |   |   └─ ...\n|   |   ├─ __init__.py\n|   |   └─ ...\n|   ├─ tmp/                        # 临时目录\n|   └─ ...\n├── .gitignore                     # Git Ignore 文件\n├── app.yaml                       # Google App Engine 配置文件\n├── LICENSE                        # 授权协议\n├── main.py                        # 主程序代码\n├── README.md                      # 说明文件\n└── requirements.txt               # 依赖包列表\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们利用一个极简的示例介绍整个模型部署，相关的库依赖 \u003ccode\u003erequirements.txt\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eFlask==1.0.2\nFlask-RESTful==0.3.6\nFlask-Cors==3.0.6\njsonschema==2.6.0\ndocopt==0.6.2\n\n# 本地部署时需保留，GAE 部署时请删除\n# gunicorn==19.9.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"http://flask.pocoo.org/\"\u003eFlask\u003c/a\u003e 用于构建 Flask 服务。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://flask-restful.readthedocs.io/\"\u003eFlask-RESTful\u003c/a\u003e 用于构建 Flask RESTful API。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://flask-cors.readthedocs.io/\"\u003eFlask-Cors\u003c/a\u003e 用于解决 AJAX 调用时的 \u003ca href=\"https://zh.wikipedia.org/zh/%E8%B7%A8%E4%BE%86%E6%BA%90%E8%B3%87%E6%BA%90%E5%85%B1%E4%BA%AB\"\u003e跨域问题\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://python-jsonschema.readthedocs.io/\"\u003ejsonschema\u003c/a\u003e 用于对请求数据的 JSON 格式进行校验。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://docopt.org/\"\u003edocopt\u003c/a\u003e 用于从代码文档自动生成命令行参数解析器。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://gunicorn.org/\"\u003egunicorn\u003c/a\u003e 用于提供的高性能 Python WSGI HTTP UNIX Server。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eXXX Model 的代码 \u003ccode\u003exxx_model.py\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom ..utils.log_utils import XXXModel_LOGGER\n\n\nLOGGER = XXXModel_LOGGER\n\n\nclass XXXModel():\n    def __init__(self):\n        LOGGER.info(\u0026#39;Initializing XXX Model ...\u0026#39;)\n\n        LOGGER.info(\u0026#39;XXX Model Initialized.\u0026#39;)\n\n    def hello(self, name:str) -\u0026gt; str:\n        return \u0026#39;Hello, {name}!\u0026#39;.format(name=name)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中 \u003ccode\u003ehello()\u003c/code\u003e 为服务使用的方法，其接受一个类型为 \u003ccode\u003estr\u003c/code\u003e 的参数 \u003ccode\u003ename\u003c/code\u003e，并返回一个类型为 \u003ccode\u003estr\u003c/code\u003e 的结果。\u003c/p\u003e\n\u003cp\u003eXXX Model 的 Flask RESTful Resource 代码 \u003ccode\u003exxx_model_resource.py\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom flask_restful import Resource, request\n\nfrom ..models.xxx_model import XXXModel\nfrom ..utils.validation_utils import validate_json\n\n\nxxx_model_instance = XXXModel()\nxxx_model_schema = {\n    \u0026#39;type\u0026#39;: \u0026#39;object\u0026#39;,\n    \u0026#39;properties\u0026#39;: {\n        \u0026#39;name\u0026#39;: {\u0026#39;type\u0026#39;: \u0026#39;string\u0026#39;}\n    },\n    \u0026#39;required\u0026#39;: [\u0026#39;name\u0026#39;]\n}\n\n\nclass XXXModelResource(Resource):\n    @validate_json(xxx_model_schema)\n    def post(self):\n        json = request.json\n\n        return {\u0026#39;result\u0026#39;: xxx_model_instance.hello(json[\u0026#39;name\u0026#39;])}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们需要从 Flask RESTful 的 \u003ccode\u003eResource\u003c/code\u003e 类继承一个新的类 \u003ccode\u003eXXXModelResource\u003c/code\u003e 用于处理 XXX Model 的服务请求。如上文介绍，我们在整个模型服务调用中使用 POST 请求方式和 JSON 数据格式，因此我们需要在类 \u003ccode\u003eXXXModelResource\u003c/code\u003e 中实现 \u003ccode\u003epost()\u003c/code\u003e 方法，同时对于传入数据的 JSON 格式进行校验。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epost()\u003c/code\u003e 方法用于处理整个模型的服务请求，\u003ccode\u003exxx_model_instance\u003c/code\u003e 模型实例在类 \u003ccode\u003eXXXModelResource\u003c/code\u003e 外部进行实例化，避免每次处理请求时都进行初始化。\u003ccode\u003epost()\u003c/code\u003e 的返回结果无需处理成 JSON 格式的字符串，仅需返回词典数据即可，Flask RESTful 会自动对其进行转换。\u003c/p\u003e\n\u003cp\u003e为了方便对请求数据的 JSON 格式进行校验，我们将对 JSON 格式的校验封装成一个修饰器。使用时如上文代码中所示，在 \u003ccode\u003epost()\u003c/code\u003e 方法上方添加 \u003ccode\u003e@validate_json(xxx_model_schema)\u003c/code\u003e 即可，其中 \u003ccode\u003exxx_model_schema\u003c/code\u003e 为一个符合 \u003ca href=\"https://python-jsonschema.readthedocs.io/\"\u003ejsonschema\u003c/a\u003e 要求的 JSON Schema。示例代码中要求传入的 JSON 数据 \u003cstrong\u003e必须\u003c/strong\u003e 包含一个名为 \u003ccode\u003ename\u003c/code\u003e 类型为 \u003ccode\u003estring\u003c/code\u003e 的字段。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003evalidate_json\u003c/code\u003e 修饰器的代码 \u003ccode\u003evalidation_utils.py\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom functools import wraps\nfrom jsonschema import validate, ValidationError\nfrom flask_restful import request\n\n\ndef validate_json(schema, force=False):\n    def decorator(f):\n        @wraps(f)\n        def wrapper(*args, **kwargs):\n            json_body = request.get_json(force=force)\n\n            if json_body is None:\n                return {\u0026#39;message\u0026#39;: \u0026#39;No JSON object\u0026#39;}, 400\n\n            try:\n                validate(json_body, schema)\n            except ValidationError as e:\n                return {\u0026#39;message\u0026#39;: e.message}, 400\n\n            return f(*args, **kwargs)\n        return wrapper\n    return decorator\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先我们需要验证请求包含一个 JSON 请求体，同时 JSON 请求体的内容需满足 \u003ccode\u003eschema\u003c/code\u003e 的要求。如果不满足这些条件，我们需要返回对应的错误信息 \u003ccode\u003emessage\u003c/code\u003e，同时返回合理的 \u003ca href=\"https://zh.wikipedia.org/zh/HTTP%E7%8A%B6%E6%80%81%E7%A0%81\"\u003eHTTP 状态码\u003c/a\u003e (例如：\u003ccode\u003e400\u003c/code\u003e) 用于表示无法处理错误的请求。对于正常的请求响应 (即 HTTP 状态码为 200 的情况)，状态码可以省略不写。\u003c/p\u003e\n\u003cp\u003e构建完 XXX Model 的 Flask RESTful Resource 后，我们就可以构建 Flask 的主服务了，主程序代码 \u003ccode\u003emain.py\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e\u0026#34;\u0026#34;\u0026#34;\nModel Serving Demo\n\nUsage:\n    main.py [--host \u0026lt;host\u0026gt;] [--port \u0026lt;port\u0026gt;] [--debug]\n    main.py (-h | --help)\n    main.py --version\n\nOptions:\n    --host \u0026lt;host\u0026gt;                     绑定的 Host [default: 0.0.0.0]\n    --port \u0026lt;port\u0026gt;                     绑定的 Port [default: 9999]\n    --debug                           是否开启 Debug [default: False]\n    -h --help                         显示帮助\n    -v --version                      显示版本\n\n\u0026#34;\u0026#34;\u0026#34;\n\nfrom docopt import docopt\n\nfrom flask import Flask\nfrom flask_cors import CORS\nfrom flask_restful import Api\n\nfrom model_serving.resources.xxx_model_resource import XXXModelResource\n\n\napp = Flask(__name__)\nCORS(app)\n\napi = Api(app)\napi.add_resource(XXXModelResource, \u0026#39;/v1/XXXModel\u0026#39;)\n\n\nif __name__ == \u0026#39;__main__\u0026#39;:\n    args = docopt(__doc__, version=\u0026#39;Model Serving Demo v1.0.0\u0026#39;)\n    app.run(host=args[\u0026#39;--host\u0026#39;], port=args[\u0026#39;--port\u0026#39;], debug=args[\u0026#39;--debug\u0026#39;])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003edocopt\u003c/code\u003e 库用于从代码文档自动生成命令行参数解析器，具体使用方法请参见 \u003ca href=\"http://docopt.org/\"\u003e官方文档\u003c/a\u003e。整个 Flask 主服务的构建比较简单，流程如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e构建 Flask 主程序，\u003ccode\u003eapp = Flask(__name__)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e解决 AJAX 调用的跨域问题， \u003ccode\u003eCORS(app)\u003c/code\u003e。为了方便起见，我们不加任何参数，允许任意来源的请求，详细的使用方式请参见 \u003ca href=\"https://flask-cors.readthedocs.io/\"\u003e官方文档\u003c/a\u003e。\u003c/li\u003e\n\u003cli\u003e构建 Flask RESTful API，\u003ccode\u003eapi = Api(app)\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e将构建好的 XXX Model 的 Flask RESTful Resource 添加到 API 中，\u003ccode\u003eapi.add_resource(XXXModelResource, \u0026#39;/v1/XXXModel\u0026#39;)\u003c/code\u003e。\n其中第二个参数为请求的 URL，对于这个 URL 的建议将在后续小节中详细说明。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFlask 主程序配置完毕后，我们通过 \u003ccode\u003eapp.run()\u003c/code\u003e 在本地启动 Flask 服务，同时可以指定绑定的主机名，端口，以及是否开启调试模式等。通过 \u003ccode\u003epython main.py\u003c/code\u003e 启动 Flask 服务后，可以在命令行看到如下类似的日志：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[2018/10/21 00:00:00] - [INFO] - [XXXModel] - Initializing XXX Model ...\n[2018/10/21 00:00:00] - [INFO] - [XXXModel] - XXX Model Initialized.\n * Serving Flask app \u0026#34;main\u0026#34; (lazy loading)\n * Environment: production\n   WARNING: Do not use the development server in a production environment.\n   Use a production WSGI server instead.\n * Debug mode: off\n[2018/10/21 00:00:00] - [INFO] - [werkzeug] -  * Running on http://0.0.0.0:9999/ (Press CTRL+C to quit)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e现在就可以测试调用服务了，我们用 \u003ccode\u003ecurl\u003c/code\u003e 命令进行简单的测试，相关代码 \u003ccode\u003erequest-demo.sh\u003c/code\u003e 如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ehost=0.0.0.0\nport=9999\nurl=/v1/XXXModel\ncurl_url=http://${host}:${port}${url}\n\ninvalid_json=\u0026#39;{}\u0026#39;\nvalid_json=\u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Leo\u0026#34;}\u0026#39;\n\n# No JSON object\ncurl --request POST --url ${curl_url} --verbose\n\n# Invalid JSON object\ncurl --header \u0026#39;Content-Type: application/json; charset=UTF-8\u0026#39; \\\n    --request POST --data ${invalid_json} --url ${curl_url} --verbose\n\n# Valid JSON object\ncurl --header \u0026#39;Content-Type: application/json; charset=UTF-8\u0026#39; \\\n    --request POST --data ${valid_json} --url ${curl_url} --verbose\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e三种不同的请求返回的 HTTP 状态码和结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHTTP/1.0 400 BAD REQUEST\n{\u0026#34;message\u0026#34;: \u0026#34;No JSON object\u0026#34;}\n\nHTTP/1.0 400 BAD REQUEST\n{\u0026#34;message\u0026#34;: \u0026#34;\u0026#39;name\u0026#39; is a required property\u0026#34;}\n\nHTTP/1.0 200 OK\n{\u0026#34;result\u0026#34;: \u0026#34;Hello, Leo!\u0026#34;}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上文中，我们通过 \u003ccode\u003epython main.py\u003c/code\u003e 利用内置的 Server 启动了 Flask 服务，启动后日志中打印出来一条警告信息，告诉使用者不要在生产环境中使用内置的 Server。在生产环境中我们可以利用高性能 Python WSGI HTTP UNIX Server \u003ca href=\"https://gunicorn.org/\"\u003egunicorn\u003c/a\u003e 来启动 Flask 服务。\u003c/p\u003e\n\u003cp\u003e服务启动 (\u003ccode\u003estart.sh\u003c/code\u003e) 脚本代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecd `dirname $0`\ncd ..\n\nbase_dir=`pwd`\ntmp_dir=${base_dir}/tmp\npid_file_path=${tmp_dir}/model-serving-demo.pid\nlog_file_path=${tmp_dir}/model-serving-demo.log\n\nbind_host=0.0.0.0\nbind_port=9999\nworkers=2\n\nnohup gunicorn -b ${bind_host}:${bind_port} \\\n  -w ${workers} -p ${pid_file_path} \\\n  main:app \u0026gt; ${log_file_path} 2\u0026gt;\u0026amp;1 \u0026amp;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e服务停止 (\u003ccode\u003estop.sh\u003c/code\u003e) 脚本代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ecd `dirname $0`\ncd ..\n\nbase_dir=`pwd`\ntmp_dir=${base_dir}/tmp\npid_file_path=${tmp_dir}/model-serving-demo.pid\n\nkill -TERM `echo ${pid_file_path}`\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003egunicorn 的详细参数配置和使用教程请参见 \u003ca href=\"https://docs.gunicorn.org/en/stable/\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"restful-api-设计\"\u003eRESTful API 设计\u003c/h2\u003e\n\u003cp\u003eRESTful API 是一种符合 REST(Representational State Transfer，表现层状态转换) 原则的框架，该框架是由 Fielding 在其博士论文 \u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e 中提出。相关的核心概念如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e资源 (Resources)\u003c/strong\u003e，即网络中的一个实体 (文本，图片，服务等)，使用一个 URL 进行表示。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e表现层 (Representation)\u003c/strong\u003e，资源具体的呈现形式即为表现层，例如图片可以表示为 PNG 文件，音乐可以表示为 MP3 文件，还有本文使用的数据格式 JSON 等。HTTP 请求的头信息中用 Accept 和 Content-Type 字段对表现层进行描述。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e状态转换 (State Transfer)\u003c/strong\u003e，互联网通信协议 HTTP 协议是一个无状态协议，所有的状态都保存在服务端。因此如果客户端想要操作服务器，必须通过某种手段让服务器端发生 \u003cstrong\u003e状态转换\u003c/strong\u003e。客户端利用 HTTP 协议中的动作对服务器进行操作，例如：GET，POST，PUT，DELETE 等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e利用 RESTful API 构建模型服务时，需要注意如下几点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e为模型服务设置专用域名，例如：\u003ccode\u003ehttps://api.example.com\u003c/code\u003e，并配以负载均衡。\u003c/li\u003e\n\u003cli\u003e将 API 的版本号写入 URL 中，例如：\u003ccode\u003ehttps://api.example.com/v1\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003eRESTful 框架中每个 URL 表示一种资源，因此可以将模型的名称作为 URL 的终点 (Endpoint)，例如：\u003ccode\u003ehttps://api.example.com/v1/XXXModel\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e对于操作资源的 HTTP 方式有多种，综合考虑建议选用 POST 方式，同时建议使用 JSON 数据格式。\u003c/li\u003e\n\u003cli\u003e为请求响应设置合理的状态码，例如：200 OK 表示正常返回，400 INVALID REQUEST 表示无法处理客户端的错误请求等。\u003c/li\u003e\n\u003cli\u003e对于错误码为 4xx 的情况，建议在返回中添加键名为 \u003ccode\u003emessage\u003c/code\u003e 的错误信息。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"ajax-调用\"\u003eAJAX 调用\u003c/h2\u003e\n\u003cp\u003e对于动态网页，我们可以很容易的在后端服务中发起 POST 请求调用模型服务，然后将结果在前端进行渲染。对于静态网页，我们可以利用 AJAX 进行相关操作，实现细节请参见 \u003ca href=\"https://github.com/leovan/model-serving-demo/tree/master/client/xxx-model-ajax-client.html\"\u003e示例代码\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003eAJAX 服务请求代码的核心部分如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e$(document).ready(function() {\n    $(\u0026#34;#submit\u0026#34;).click(function() {\n        $.ajax({\n            url: \u0026#34;http://0.0.0.0:9999/v1/XXXModel\u0026#34;,\n            method: \u0026#34;POST\u0026#34;,\n            contentType: \u0026#34;application/json; charset=UTF-8\u0026#34;,\n            data: JSON.stringify({\u0026#34;name\u0026#34;: $(\u0026#34;#name\u0026#34;).val()}),\n            timeout: 3000,\n\n            success: function (data, textStatus, jqXHR) {\n                $(\u0026#34;#result\u0026#34;).html(data.result);\n            },\n            error: function (jqXHR, textStatus, errorThrown) {\n                $(\u0026#34;#result\u0026#34;).html(errorThrown);\n            }\n        });\n    });\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码使用了 \u003ca href=\"https://jquery.com/\"\u003ejQuery\u003c/a\u003e 的相关函数。\u003ccode\u003eJSON.stringify({\u0026#34;name\u0026#34;: $(\u0026#34;#name\u0026#34;).val()})\u003c/code\u003e 获取 ID 为 \u003ccode\u003ename\u003c/code\u003e 的元素的值，并将其转换成符合服务端要求的 JSON 格式。通过 AJAX 向远程发出请求后，如果请求成功则将返回数据 \u003ccode\u003edata\u003c/code\u003e 中对应的结果 \u003ccode\u003eresult\u003c/code\u003e 填充到 ID 为 \u003ccode\u003eresult\u003c/code\u003e 的元素中，否则填入返回的错误信息。\u003c/p\u003e\n\u003ch1 id=\"google-app-engine-部署\"\u003eGoogle App Engine 部署\u003c/h1\u003e\n\u003cp\u003e上文中已经介绍了如何在本地利用 Flask 部署模型服务和相关调用方法，但如果希望在自己的网站中调用时，则利用 SaaS 来部署符合会是一个不二之选。国内外多个厂商均提供了相应的 SaaS 产品，例如 \u003ca href=\"https://cloud.google.com/appengine/\"\u003eGoogle\u003c/a\u003e，\u003ca href=\"https://aws.amazon.com/partners/saas-on-aws/\"\u003eAmazon\u003c/a\u003e，\u003ca href=\"https://azure.microsoft.com/en-us/solutions/saas/\"\u003eMicrosoft\u003c/a\u003e 等。Google App Engine (GAE) 提供了一个 \u003ca href=\"https://cloud.google.com/free/docs/always-free-usage-limits\"\u003e始终免费\u003c/a\u003e 方案，虽然部署阶段会受到 GFW 的影响，但调用阶段测试影响并不是很大 (不同地区和服务提供商会有差异)。综合考虑，本文选择 GAE 作为 SaaS 平台部署服务，各位看官请自备梯子。\u003c/p\u003e\n\u003ch2 id=\"环境准备\"\u003e环境准备\u003c/h2\u003e\n\u003cp\u003e首先，在 \u003ca href=\"https://console.cloud.google.com/projectcreate\"\u003eGoogle Cloud Platform Console\u003c/a\u003e 中建立一个新的 Project，假设项目名为 \u003ccode\u003eYOUR_PROJECT_ID\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e其次，根据 \u003ca href=\"https://cloud.google.com/sdk/docs/\"\u003eGoogle Cloud SDK 文档\u003c/a\u003e 在本地安装相应版本的 Google Cloud SDK。MacOS 下建议通过 \u003ccode\u003ebrew cask install google-cloud-sdk\u003c/code\u003e 方式安装，安装完毕后确认在命令行中可以运行 \u003ccode\u003egcloud\u003c/code\u003e 命令。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ gcloud version\nGoogle Cloud SDK 221.0.0\nbq 2.0.35\ncore 2018.10.12\ngsutil 4.34\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"构建-gae-工程\"\u003e构建 GAE 工程\u003c/h2\u003e\n\u003cp\u003e模型服务仅作为后端应用，因此本节不介绍前端页面开发的相关部分，有兴趣的同学请参见 \u003ca href=\"https://cloud.google.com/appengine/docs/standard/python3/quickstart\"\u003e官方文档\u003c/a\u003e。GAE 部署 Python Web 应用采用了 \u003ca href=\"https://wsgi.readthedocs.io/en/latest/\"\u003eWSGI 标准\u003c/a\u003e，我们构建的本地部署版本完全满足这个要求，因此仅需为项目在根目录添加一个 GAE 配置文件 \u003ccode\u003eapp.yaml\u003c/code\u003e 即可，内容如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-yaml\"\u003eruntime: python37\n\nhandlers:\n  - url: /.*\n    script: main.app\n\nskip_files:\n  - .idea/\n  - .vscode/\n  - __pycache__/\n  - .hypothesis/\n  - .pytest_cache/\n  - bin/\n  - ^(.*/)?.*\\.py[cod]$\n  - ^(.*/)?.*\\$py\\.class$\n  - ^(.*/)?.*\\.log$\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，\u003ccode\u003eruntime\u003c/code\u003e 指定了服务运行的环境，\u003ccode\u003ehandlers\u003c/code\u003e 指定了不同的 URL 对应的处理程序，在此所有的 URL 均由 \u003ccode\u003emain.py\u003c/code\u003e 中的 \u003ccode\u003eapp\u003c/code\u003e 进行处理，\u003ccode\u003eskip_files\u003c/code\u003e 用于过滤不需要上传的文件。更多关于 \u003ccode\u003eapp.yaml\u003c/code\u003e 的设置信息，请参见 \u003ca href=\"https://cloud.google.com/appengine/docs/standard/python3/config/appref\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"部署-gae-工程\"\u003e部署 GAE 工程\u003c/h2\u003e\n\u003cp\u003e在部署 GAE 工程之前我们可以利用本地的开发环境对其进行测试，测试无误后，即可运行如下命令将其部署到 GAE 上：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003egcloud app deploy --project [YOUR_PROJECT_ID]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后根据命令行提示完成整个部署流程，部署完成的远程服务 URL 为 \u003ccode\u003ehttps://YOUR_PROJECT_ID.appspot.com\u003c/code\u003e，更多的测试和部署细节请参见 \u003ca href=\"https://cloud.google.com/appengine/docs/standard/python3/testing-and-deploying-your-app\"\u003e官方文档\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e部署后的 GAE 服务使用了其自带的域名 \u003ccode\u003eappspot.com\u003c/code\u003e。如果你拥有自己的域名，可以根据官方文档 \u003ca href=\"https://cloud.google.com/appengine/docs/standard/python3/mapping-custom-domains\"\u003e设置自己的域名\u003c/a\u003e 并 \u003ca href=\"https://cloud.google.com/appengine/docs/standard/python3/secURLng-custom-domains-with-ssl\"\u003e开启 SSL\u003c/a\u003e。\u003c/p\u003e\n\u003cdiv class=\"admonition admonition-note  kai\"\u003e\n  \u003cdiv class=\"admonition-content\"\u003e本文部分内容参考了 Genthial 的博客 \u003ca href=\"https://guillaumegenthial.github.io/serving.html\"\u003eServing a model with Flask\u003c/a\u003e 和阮一峰的博客 \u003ca href=\"https://www.ruanyifeng.com/blog/2011/09/restful.html\"\u003e理解RESTful架构\u003c/a\u003e 和 \u003ca href=\"https://www.ruanyifeng.com/blog/2014/05/restful_api.html\"\u003eRESTful API 设计指南\u003c/a\u003e。\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\"\u003e\n\u003cp\u003eFielding, Roy T., and Richard N. Taylor. \u003cem\u003eArchitectural styles and the design of network-based software architectures.\u003c/em\u003e Vol. 7. Doctoral dissertation: University of California, Irvine, 2000. \u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"donate\"\u003e\n  \u003cdiv class=\"donate-header\"\u003e\u003c/div\u003e\n  \u003cdiv class=\"donate-slug\" id=\"donate-slug\"\u003eserving-models-with-flask-and-gae\u003c/div\u003e\n  \u003cbutton class=\"donate-button\"\u003e赞 赏\u003c/button\u003e\n  \u003cdiv class=\"donate-footer\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"donate-modal-wrapper\"\u003e\n  \u003cdiv class=\"donate-modal\"\u003e\n    \u003cdiv class=\"donate-box\"\u003e\n      \u003cdiv class=\"donate-box-content\"\u003e\n        \u003cdiv class=\"donate-box-content-inner\"\u003e\n          \u003cdiv class=\"donate-box-header\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n          \u003cdiv class=\"donate-box-body\"\u003e\n            \u003cdiv class=\"donate-box-money\"\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-2\" data-v=\"2\" data-unchecked=\"￥ 2\" data-checked=\"2 元\"\u003e￥ 2\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-5\" data-v=\"5\" data-unchecked=\"￥ 5\" data-checked=\"5 元\"\u003e￥ 5\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-10\" data-v=\"10\" data-unchecked=\"￥ 10\" data-checked=\"10 元\"\u003e￥ 10\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-50\" data-v=\"50\" data-unchecked=\"￥ 50\" data-checked=\"50 元\"\u003e￥ 50\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-100\" data-v=\"100\" data-unchecked=\"￥ 100\" data-checked=\"100 元\"\u003e￥ 100\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-custom\" data-v=\"custom\" data-unchecked=\"任意金额\" data-checked=\"任意金额\"\u003e任意金额\u003c/button\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-qrcode\" id=\"donate-box-pay-qrcode\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"donate-box-footer\"\u003e\n            \u003cdiv class=\"donate-box-pay-method donate-box-pay-method-checked\" data-v=\"wechat-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-wechat-pay\" src=\"\"/\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay-method\" data-v=\"alipay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-alipay\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"button\" class=\"donate-box-close-button\"\u003e\n      \u003csvg class=\"donate-box-close-button-icon\" fill=\"#fff\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"\u003e\u003cpath d=\"M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z\" fill-rule=\"evenodd\"\u003e\u003c/path\u003e\u003c/svg\u003e\n    \u003c/button\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cscript type=\"text/javascript\" src=\"/js/donate.js\"\u003e\u003c/script\u003e\n\n\n  \u003cfooter\u003e\n  \n\u003cnav class=\"post-nav\"\u003e\n  \u003cspan class=\"nav-prev\"\u003e← \u003ca href=\"/cn/2018/10/seq2seq-and-attention-machanism/\"\u003e序列到序列 (Seq2Seq) 和注意力机制 (Attention Machanism)\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"nav-next\"\u003e\u003ca href=\"/cn/2018/11/computational-complexity-and-dynamic-programming/\"\u003e计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)\u003c/a\u003e →\u003c/span\u003e\n\u003c/nav\u003e\n\n\n\n\n\u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"8302038603\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n  (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/toggle-theme.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"/js/no-highlight.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/math-code.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/heading-anchor.js\"\u003e\u003c/script\u003e\n\n\n\n\u003csection class=\"comments\"\u003e\n\u003cscript src=\"https://giscus.app/client.js\" data-repo=\"leovan/leovan.me\" data-repo-id=\"MDEwOlJlcG9zaXRvcnkxMTMxOTY0Mjc=\" data-category=\"Comments\" data-category-id=\"DIC_kwDOBr89i84CT-R7\" data-mapping=\"pathname\" data-strict=\"1\" data-reactions-enabled=\"1\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"preferred_color_scheme\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" defer=\"\"\u003e\n\u003c/script\u003e\n\u003c/section\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n  (function() {\n    if (!self.Prism) {\n      return;\n    }\n\n    \n    Prism.languages.dos = Prism.languages.powershell;\n    Prism.languages.gremlin = Prism.languages.groovy;\n\n    let languages = {\n      'r': 'R', 'python': 'Python', 'xml': 'XML', 'html': 'HTML',\n      'yaml': 'YAML', 'latex': 'LaTeX', 'tex': 'TeX',\n      'powershell': 'PowerShell', 'javascript': 'JavaScript',\n      'dos': 'DOS', 'qml': 'QML', 'json': 'JSON', 'bash': 'Bash',\n      'text': 'Text', 'txt': 'Text', 'sparql': 'SPARQL',\n      'gremlin': 'Gremlin', 'cypher': 'Cypher', 'ngql': 'nGQL',\n      'shell': 'Shell', 'sql': 'SQL', 'apacheconf': 'Apache Configuration', 'c': 'C', 'css': 'CSS'\n    };\n\n    Prism.hooks.add('before-highlight', function(env) {\n      if (env.language !== 'plain') {\n        let language = languages[env.language] || env.language;\n        env.element.setAttribute('data-language', language);\n      }\n    });\n\n    \n    let ClipboardJS = window.ClipboardJS || undefined;\n\n    Prism.plugins.toolbar.registerButton('copy-to-clipboard', function(env) {\n      let linkCopy = document.createElement('button');\n      linkCopy.classList.add('prism-button-copy');\n\n      registerClipboard();\n\n      return linkCopy;\n\n      function registerClipboard() {\n        let clip = new ClipboardJS(linkCopy, {\n          'text': function () {\n            return env.code;\n          }\n        });\n\n        clip.on('success', function() {\n          linkCopy.classList.add('prism-button-copy-success');\n          resetText();\n        });\n        clip.on('error', function () {\n          linkCopy.classList.add('prism-button-copy-error');\n          resetText();\n        });\n      }\n\n      function resetText() {\n        setTimeout(function () {\n          linkCopy.classList.remove('prism-button-copy-success');\n          linkCopy.classList.remove('prism-button-copy-error');\n        }, 1600);\n      }\n    });\n  })();\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cscript async=\"\" src=\"/js/center-img.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/right-quote.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/external-link.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/alt-title.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/figure.js\"\u003e\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\naddBackToTop({\n  diameter: 48\n});\n\u003c/script\u003e\n\n  \u003chr/\u003e\n  \u003cdiv class=\"copyright no-border-bottom\"\u003e\n    \u003cdiv class=\"copyright-author-year\"\u003e\n      \u003cspan\u003eCopyright © 2017-2024 \u003ca href=\"/\"\u003e范叶亮 | Leo Van\u003c/a\u003e\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003c/footer\u003e\n  \u003c/article\u003e",
  "Date": "2018-10-19T00:00:00Z",
  "Author": "范叶亮"
}