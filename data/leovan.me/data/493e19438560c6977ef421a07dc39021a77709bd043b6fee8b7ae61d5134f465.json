{
  "Source": "leovan.me",
  "Title": "计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)",
  "Link": "https://leovan.me/cn/2018/11/computational-complexity-and-dynamic-programming/",
  "Content": "\u003carticle class=\"main\"\u003e\n    \u003cheader class=\"content-title\"\u003e\n    \n\u003ch1 class=\"title\"\u003e\n  \n  计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)\n  \n\u003c/h1\u003e\n\n\n\n\n\n\n\n\u003ch2 class=\"author-date\"\u003e范叶亮 / \n2018-11-18\u003c/h2\u003e\n\n\n\n\u003ch3 class=\"post-meta\"\u003e\n\n\n\u003cstrong\u003e分类: \u003c/strong\u003e\n\u003ca href=\"/categories/%E6%9C%80%E4%BC%98%E5%8C%96\"\u003e最优化\u003c/a\u003e\n\n\n\n\n/\n\n\n\n\n\u003cstrong\u003e标签: \u003c/strong\u003e\n\u003cspan\u003e计算复杂性\u003c/span\u003e, \u003cspan\u003eComputational Complexity\u003c/span\u003e, \u003cspan\u003e函数的增长\u003c/span\u003e, \u003cspan\u003eP 问题\u003c/span\u003e, \u003cspan\u003eNP 问题\u003c/span\u003e, \u003cspan\u003eNP Complete 问题\u003c/span\u003e, \u003cspan\u003eNP Hard 问题\u003c/span\u003e, \u003cspan\u003e动态规划\u003c/span\u003e, \u003cspan\u003eDynamic Programming\u003c/span\u003e, \u003cspan\u003e背包问题\u003c/span\u003e, \u003cspan\u003eKnapsack Problem\u003c/span\u003e, \u003cspan\u003e最长公共子序列\u003c/span\u003e, \u003cspan\u003eLongest Common Subsequence\u003c/span\u003e, \u003cspan\u003e最长公共子串\u003c/span\u003e, \u003cspan\u003eLongest Common Substring\u003c/span\u003e, \u003cspan\u003e最短路问题\u003c/span\u003e, \u003cspan\u003eShortest Path Problem\u003c/span\u003e, \u003cspan\u003eFloyd-Warshall 算法\u003c/span\u003e\n\n\n\n\n/\n\n\n\u003cstrong\u003e字数: \u003c/strong\u003e\n5272\n\u003c/h3\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n    \n    \n    \u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"1261604535\"\u003e\u003c/ins\u003e\n    \u003cscript\u003e\n    (adsbygoogle = window.adsbygoogle || []).push({});\n    \u003c/script\u003e\n    \n    \n    \u003c/header\u003e\n\n\n\n\n\u003ch1 id=\"计算复杂性\"\u003e计算复杂性\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e计算复杂性 (Computational Complexity)\u003c/strong\u003e 是用于对一个问题求解所需的资源 (通常为 \u003cstrong\u003e空间\u003c/strong\u003e 和 \u003cstrong\u003e时间\u003c/strong\u003e) 的度量。在评估一个算法的时候，除了算法本身的准确性以外，同时需要关注算法运行的时间以及占用的内存，从而根据实际情况选择合适的算法。\u003c/p\u003e\n\u003ch2 id=\"函数的增长\"\u003e函数的增长\u003c/h2\u003e\n\u003cp\u003e计算复杂性中的空间和时间的评估方法类似，在此我们更多的以时间复杂度为例。算法的运行时间刻画了算法的效率，对于一个输入规模为 \u003ccode\u003e$n$\u003c/code\u003e 的问题，定义一个算法求解该问题 \u003cstrong\u003e最坏情况\u003c/strong\u003e 下的运行时间为 \u003ccode\u003e$T \\left(n\\right)$\u003c/code\u003e，我们可以使用一些 \u003cstrong\u003e渐进记号\u003c/strong\u003e 更加方便地对其进行描述。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e$\\Theta$\u003c/code\u003e 记号\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于一个给定的函数 \u003ccode\u003e$g \\left(n\\right)$\u003c/code\u003e，\u003ccode\u003e$\\Theta \\left(g \\left(n\\right)\\right)$\u003c/code\u003e 可以表示如下函数的集合：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\Theta \\left(g \\left(n\\right)\\right) = \\left\\{f \\left(n\\right): \\exists c_1 \u0026gt; 0, c_2 \u0026gt; 0, n_0 \u0026gt; 0, s.t. \\forall n \\geq n_0, 0 \\leq c_1 g \\left(n\\right) \\leq f \\left(n\\right) \\leq c_2 g \\left(n\\right) \\right\\} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e也就是说当 \u003ccode\u003e$n$\u003c/code\u003e 足够大时，函数 \u003ccode\u003e$f \\left(n\\right)$\u003c/code\u003e 能够被 \u003ccode\u003e$c_1 g \\left(n\\right)$\u003c/code\u003e 和 \u003ccode\u003e$c_2 g \\left(n\\right)$\u003c/code\u003e 夹在中间，我们称 \u003ccode\u003e$g \\left(n\\right)$\u003c/code\u003e 为 \u003ccode\u003e$f \\left(n\\right)$\u003c/code\u003e 的一个 \u003cstrong\u003e渐进紧确界 (Asymptotically Tight Bound)\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e$O$\u003c/code\u003e 记号\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e$\\Theta$\u003c/code\u003e 记号给出了一个函数的上界和下界，当只有一个 \u003cstrong\u003e渐进上界\u003c/strong\u003e 时，可使用 \u003ccode\u003e$O$\u003c/code\u003e 记号。\u003ccode\u003e$O \\left(g \\left(n\\right)\\right)$\u003c/code\u003e 表示的函数集合为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ O \\left(g \\left(n\\right)\\right) = \\left\\{f \\left(n\\right): \\exists c \u0026gt; 0, n_0 \u0026gt; 0, s.t. \\forall n \\geq n_0, 0 \\leq f \\left(n\\right) \\leq c g \\left(n\\right)\\right\\} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$O$\u003c/code\u003e 记号描述的为函数的上界，因此可以用它来限制算法在最坏情况下的运行时间。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e$\\Omega$\u003c/code\u003e 记号\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e$\\Omega$\u003c/code\u003e 记号提供了 \u003cstrong\u003e渐进下界\u003c/strong\u003e，其表示的函数集合为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\Omega \\left(g \\left(n\\right)\\right) = \\left\\{f \\left(n\\right): \\exists c \u0026gt; 0, n_0 \u0026gt; 0, s.t. \\forall n \\geq n_0, 0 \\leq c g \\left(n\\right) \\leq f \\left(n\\right)\\right\\} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e根据上面的三个渐进记号，不难证明如下定理：\u003c/p\u003e\n\u003clink rel=\"stylesheet\" href=\"/css/admonition.css\"/\u003e\n\u003cdiv class=\"admonition admonition-note admonition-no-icon kai\"\u003e\n  \u003cp class=\"admonition-title\"\u003e\u003cstrong\u003e定理 1\u003c/strong\u003e\u003c/p\u003e\n  \u003cdiv class=\"admonition-content\"\u003e对于任意两个函数 \u003ccode\u003e$f \\left(n\\right)$\u003c/code\u003e 和 \u003ccode\u003e$g \\left(n\\right)$\u003c/code\u003e，有 \u003ccode\u003e$f \\left(n\\right) = \\Theta \\left(g \\left(n\\right)\\right)$\u003c/code\u003e，当且仅当 \u003ccode\u003e$f \\left(n\\right) = O \\left(g \\left(n\\right)\\right)$\u003c/code\u003e 且 \u003ccode\u003e$f \\left(n\\right) = \\Omega \\left(g \\left(n\\right)\\right)$\u003c/code\u003e。\u003c/div\u003e\n\u003c/div\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e$o$\u003c/code\u003e 记号\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e$O$\u003c/code\u003e 记号提供的渐进上界可能是也可能不是渐进紧确的，例如 \u003ccode\u003e$2n^2 = O \\left(n^2\\right)$\u003c/code\u003e 是渐进紧确的，但 \u003ccode\u003e$2n = O \\left(n^2\\right)$\u003c/code\u003e 是非渐进紧确的。我们使用 \u003ccode\u003e$o$\u003c/code\u003e 记号表示非渐进紧确的上界，其表示的函数集合为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ o \\left(g \\left(n\\right)\\right) = \\left\\{f \\left(n\\right): \\forall c \u0026gt; 0, \\exists n_0 \u0026gt; 0, s.t. \\forall n \\geq n_0, 0 \\leq f \\left(n\\right) \u0026lt; c g \\left(n\\right)\\right\\} $$\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003e$\\omega$\u003c/code\u003e 记号\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003e$\\omega$\u003c/code\u003e 记号与 \u003ccode\u003e$\\Omega$\u003c/code\u003e 记号的关系类似于 \u003ccode\u003e$o$\u003c/code\u003e 记号与 \u003ccode\u003e$O$\u003c/code\u003e 记号的关系，我们使用 \u003ccode\u003e$\\omega$\u003c/code\u003e 记号表示一个非渐进紧确的下界，其表示的函数集合为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\omega \\left(g \\left(n\\right)\\right) = \\left\\{f \\left(n\\right): \\forall c \u0026gt; 0, \\exists n_0 \u0026gt; 0, s.t. \\forall n \\geq n_0, 0 \\leq c g \\left(n\\right) \u0026lt; f \\left(n\\right)\\right\\} $$\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"np-完全性\"\u003eNP 完全性\u003c/h2\u003e\n\u003cp\u003e计算问题可以按照在不同计算模型下所需资源的不同予以分类，从而得到一个对算法问题“难度”的类别，这就是复杂性理论中复杂性类概念的来源 \u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e。对于输入规模为 \u003ccode\u003e$n$\u003c/code\u003e 的问题，一个算法在最坏情况下的运行时间为 \u003ccode\u003e$O \\left(n^k\\right)$\u003c/code\u003e，其中 \u003ccode\u003e$k$\u003c/code\u003e 为一个确定的常数，我们称这类算法为 \u003cstrong\u003e多项式时间的算法\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e本节我们将介绍四类问题：P 类问题，NP 类问题，NPC 类问题和 NPH 类问题。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eP 类问题\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eP 类问题 (Polynomial Problem，多项式问题) 是指能在多项式时间内 \u003cstrong\u003e解决\u003c/strong\u003e 的问题。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNP 类问题\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNP 类问题 (Non-Deteministic Polynomial Problem，非确定性多项式问题) 是指能在多项式时间内被 \u003cstrong\u003e证明\u003c/strong\u003e 的问题，也就是可以在多项式时间内对于一个给定的解验证其是否正确。所有的 P 类问题都是 NP 类问题，但目前 (截至 2018 年，下文如不做特殊说明均表示截至到该时间) 人类还未证明 \u003ccode\u003e$P \\neq NP$\u003c/code\u003e 还是 \u003ccode\u003e$P = NP$\u003c/code\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNPC 类问题 (NP-Complete Problems)\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在理解 NPC 类问题之前，我们需要引入如下几个概念：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e最优化问题 (Optimization Problem)\u003c/strong\u003e 与 \u003cstrong\u003e判定问题 (Decision Problem)\u003c/strong\u003e：最优化问题是指问题的每一个可行解都关联一个值，我们希望找到具有最佳值的可行解。判定问题是指问题的答案仅为“是”或“否”的问题。NP 完全性仅适用于判定问题，但通过对最优化问题强加一个界，可以将其转换为判定问题。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e归约 (Reduction)\u003c/strong\u003e：假设存在一个判定问题 A，该问题的输入称之为实例，我们希望能够在多项式时间内解决该问题。假设存在另一个不同的判定问题 B，并且已知能够在多项式时间内解决该问题，同时假设存在一个过程，它可以将 A 的任何实例 \u003ccode\u003e$\\alpha$\u003c/code\u003e 转换成 B 的某个实例 \u003ccode\u003e$\\beta$\u003c/code\u003e，转换操作需要在多项式时间内完成，同时两个实例的解是相同的。则我们称这一过程为多项式 \u003cstrong\u003e规约算法 (Reduction Algorithm)\u003c/strong\u003e。通过这个过程，我们可以将问题 A 的求解“归约”为对问题 B 的求解，从而利用问题 B 的“易求解性”来证明 A 的“易求解性”。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e从而我们可以定义 NPC 类问题为：首先 NPC 类问题是一个 NP 类问题，其次所有的 NP 类问题都可以用多项式时间归约到这类问题。因此，只要找到 NPC 类问题的一个多项式时间的解，则所有的 NP 问题都可以通过多项式时间归约到该问题，并用多项式时间解决该问题，从而使得 \u003ccode\u003e$NP = P$\u003c/code\u003e，但目前，NPC 类问题并没有找到一个多项式时间的算法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eNPH 类问题 (NP-Hard Problems)\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNPH 类问题定义为所有的 NP 类问题都可以通过多项式时间归约到这类问题，但 NPH 类问题不一定是 NP 类问题。NPH 类问题同样很难找到多项式时间的解，由于 NPH 类问题相比较 NPC 类问题放松了约束，因此即便 NPC 类问题找到了多项式时间的解，NPH 类问题仍可能无法在多项式时间内求解。\u003c/p\u003e\n\u003cp\u003e下图分别展示了 \u003ccode\u003e$P \\neq NP$\u003c/code\u003e 和 \u003ccode\u003e$P = NP$\u003c/code\u003e 两种假设情况下四类问题之间的关系：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2018-11-18-computational-complexity-and-dynamic-programming/p-np-np-complete-np-hard.svg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch1 id=\"动态规划\"\u003e动态规划\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e动态规划 (Dynamic Programming, DP)\u003c/strong\u003e 算法通常基于一个递归公式和一个或多个初始状态，并且当前子问题的解可以通过之前的子问题构造出来。动态规划算法求解问题的时间复杂度仅为多项式复杂度，相比其他解法，例如：回溯法，暴利破解法所需的时间要少。动态规划中的 “Programming” 并非表示利用计算机编程，而是一种表格法。动态规划对于每个子问题只求解一次，将解保存在一个表格中，从而避免不必要的重复计算。\u003c/p\u003e\n\u003cp\u003e动态规划算法的适用情况如下 \u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e最优子结构性质\u003c/strong\u003e，即问题的最优解由相关子问题的最优解组合而成，子问题可以独立求解。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e无后效性\u003c/strong\u003e，即每个状态均不会影响之前的状态。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e子问题重叠性质\u003c/strong\u003e，即在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e一个动态规划算法的核心包含两个部分：\u003cstrong\u003e状态\u003c/strong\u003e 和 \u003cstrong\u003e状态转移方程\u003c/strong\u003e。状态即一个子问题的表示，同时这个表示需要具备 \u003cstrong\u003e无后效性\u003c/strong\u003e。状态转移方程用于描述状态之间的关系，也就是如何利用之前的状态构造出当前的状态进而求解。\u003c/p\u003e\n\u003cp\u003e动态规划有两种等价的实现方法：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e带备忘的自顶向下法 (Top-Down with Memoization)\u003c/strong\u003e，该方法采用自然的递归形式编写过程，但会保留每个子问题的解，当需要一个子问题的解时会先检查是否保存过，如果有则直接返回该结果。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e自底向上法 (Bottom-Up Method)\u003c/strong\u003e，该方法需要恰当的定义子问题“规模”，任何子问题的求解都值依赖于“更小”的子问题的求解，从而可以按照子问题的规模从小到大求解。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e两种方法具有相同的渐进运行时间，在某些特殊的情况下，自顶向下的方法并未真正递归地考虑所有可能的子问题；自底向上的方法由于没有频繁的递归调用，时间复杂性函数通常具有更小的系数。\u003c/p\u003e\n\u003ch2 id=\"背包问题\"\u003e背包问题\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e背包问题 (Knapsack problem)\u003c/strong\u003e 是一种组合优化的 NPC 类问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价值，在限定的总重量内，合理地选择物品使得总价值最高。\u003c/p\u003e\n\u003cp\u003e形式化的定义，我们有 \u003ccode\u003e$n$\u003c/code\u003e 种物品，物品 \u003ccode\u003e$j$\u003c/code\u003e 的重量为 \u003ccode\u003e$w_j$\u003c/code\u003e，价值为 \u003ccode\u003e$p_j$\u003c/code\u003e，假定所有物品的重量和价值都是非负的，背包所能承受的最大重量为 \u003ccode\u003e$W$\u003c/code\u003e。如果限定每种物品只能选择 0 个或 1 个，则该问题称为 \u003cstrong\u003e0-1 背包问题\u003c/strong\u003e；如果限定物品 \u003ccode\u003e$j$\u003c/code\u003e 最多只能选择 \u003ccode\u003e$b_j$\u003c/code\u003e 个，则该问题称为 \u003cstrong\u003e有界背包问题\u003c/strong\u003e；如果不限定每种物品的数量，则该问题称为 \u003cstrong\u003e无界背包问题\u003c/strong\u003e。最优化问题可以表示为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{equation} \\begin{split} \\text{maximize} \u0026amp; \\sum_{j=1}^{n}{p_j x_j} \\\\ s.t. \u0026amp; \\sum_{j=1}^{n}{w_j x_j} \\leq W, x_j \\in \\left\\{0, 1, ..., b_j\\right\\} \\end{split} \\end{equation} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e以 0-1 背包问题为例，用 \u003ccode\u003e$d_{i, w}$\u003c/code\u003e 表示取 \u003ccode\u003e$i$\u003c/code\u003e 件商品填充一个最大承重 \u003ccode\u003e$w$\u003c/code\u003e 的背包的最大价值，问题的最优解即为 \u003ccode\u003e$d_{n, W}$\u003c/code\u003e。不难写出 0-1 背包问题的状态转移方程如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ d_{i, w} =  \\begin{cases} d_{i - 1, w}, \u0026amp; w \u0026lt; w_i \\\\ \\max \\left(d_{i - 1, w}, d_{i - 1, w - w_i} + p_i\\right), \u0026amp; w \\geq w_i \\\\ 0, \u0026amp; i w = 0 \\end{cases} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e一个 0-1 背包问题的具体示例如下：背包承受的最大重量 \u003ccode\u003e$W = 10$\u003c/code\u003e，共有 \u003ccode\u003e$n = 5$\u003c/code\u003e 种物品，编号分别为 \u003ccode\u003e$A, B, C, D, E$\u003c/code\u003e，重量分别为 \u003ccode\u003e$2, 2, 6, 5, 4$\u003c/code\u003e，价值分别为 \u003ccode\u003e$6, 3, 5, 4, 6$\u003c/code\u003e，利用 BP 求解该问题，不同 \u003ccode\u003e$i, w$\u003c/code\u003e 情况下的状态如下表所示 (计算过程详见 \u003ca href=\"https://github.com/leovan/leovan.me/tree/main/static/codes/cn/2018-11-18-computational-complexity-and-dynamic-programming/0-1-knapsack-dp.py\"\u003e这里\u003c/a\u003e)：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003ei \\ w\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e1\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e2\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e3\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e4\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e5\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e6\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e7\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e8\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e9\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e10\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e1\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, C) \u003cbr/\u003e 8 - 11\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, C) \u003cbr/\u003e 8 - 11\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, C) \u003cbr/\u003e 10 - 14\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, D) \u003cbr/\u003e 7 - 10\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, C) \u003cbr/\u003e 8 - 11\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, D) \u003cbr/\u003e 9 - 13\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, C) \u003cbr/\u003e 10 - 14\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A) \u003cbr/\u003e 2 - 6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B) \u003cbr/\u003e 4 - 9\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, E) \u003cbr/\u003e 6 - 12\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, E) \u003cbr/\u003e 6 - 12\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, E) \u003cbr/\u003e 8 - 15\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, E) \u003cbr/\u003e 8 - 15\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e(A, B, E) \u003cbr/\u003e 8 - 15\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其中，NA 表示未选取任何物品，单元格上部括号中的为选取物品的编号，单元格下部分别为选取物品的总重量和总价值。\u003c/p\u003e\n\u003ch2 id=\"最长公共子序列与最长公共子串\"\u003e最长公共子序列与最长公共子串\u003c/h2\u003e\n\u003cp\u003e给定一个序列 \u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_m\\right\\}$\u003c/code\u003e，另一个序列 \u003ccode\u003e$Z = \\left\\{z_1, z_2, \\dotsc, z_k\\right\\}$\u003c/code\u003e 在满足如下条件时称其为 \u003ccode\u003e$X$\u003c/code\u003e 的一个 \u003cstrong\u003e子序例 (Subsequence)\u003c/strong\u003e，即存在一个严格递增的 \u003ccode\u003e$X$\u003c/code\u003e 的下标序列 \u003ccode\u003e$\\left\\{i_1, i_2, \\dotsc, i_k\\right\\}$\u003c/code\u003e，对于所有的 \u003ccode\u003e$j = 1, 2, \\dotsc, k$\u003c/code\u003e，满足 \u003ccode\u003e$x_{i_j} = z_j$\u003c/code\u003e。给定两个序例 \u003ccode\u003e$X$\u003c/code\u003e 和 \u003ccode\u003e$Y$\u003c/code\u003e，如果 \u003ccode\u003e$Z$\u003c/code\u003e 既是 \u003ccode\u003e$X$\u003c/code\u003e 的子序列，也是 \u003ccode\u003e$Y$\u003c/code\u003e 的子序列，则称它为 \u003ccode\u003e$X$\u003c/code\u003e 和 \u003ccode\u003e$Y$\u003c/code\u003e 的 \u003cstrong\u003e公共子序列 (Common Subsequence)\u003c/strong\u003e。\u003cstrong\u003e最长公共子序列 (Longest Common Subsequence)\u003c/strong\u003e 问题为给定两个序列 \u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_m\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_n\\right\\}$\u003c/code\u003e，求 \u003ccode\u003e$X$\u003c/code\u003e 和 \u003ccode\u003e$Y$\u003c/code\u003e 最长的公共子序列。\u003c/p\u003e\n\u003cp\u003e我们可以按如下递归的方式求解最长公共子序列问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e当 \u003ccode\u003e$x_i = y_j$\u003c/code\u003e 时，求解 \u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_{i-1}\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_{j-1}\\right\\}$\u003c/code\u003e 的最长公共子序列，在其尾部添加 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$y_j$\u003c/code\u003e 即为当前状态下的最长公共子序列。\u003c/li\u003e\n\u003cli\u003e当 \u003ccode\u003e$x_i \\neq y_j$\u003c/code\u003e 时，我们则需求解 \u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_{i-1}\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_j\\right\\}$\u003c/code\u003e 与 \u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_i\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_{j-1}\\right\\}$\u003c/code\u003e 两种情况下最长的公共子序列作为当前状态下的最长公共子序列。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e用 \u003ccode\u003e$c_{i, j}$\u003c/code\u003e 表示\u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_i\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_j\\right\\}$\u003c/code\u003e 情况下的最长公共子序列的长度，则状态转移方程如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ c_{i, w} =  \\begin{cases} c_{i - 1, j - 1} + i, \u0026amp; x_i = y_j \\\\ \\max \\left(c_{i, j - 1}, c_{i - 1, j}\\right), \u0026amp; x_i \\neq y_j \\\\ 0, \u0026amp; i j = 0 \\end{cases} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e例如：给定序列 \u003ccode\u003e$X = \\left\\{A, B, C, B, D, A, B\\right\\}$\u003c/code\u003e 和序列 \u003ccode\u003e$Y = \\left\\{B, D, C, A, B, A\\right\\}$\u003c/code\u003e，不同状态下最长公共子序列如下表所示 (计算过程详见 \u003ca href=\"https://github.com/leovan/leovan.me/tree/main/static/codes/cn/2018-11-18-computational-complexity-and-dynamic-programming/longest-common-subsequence-dp.py\"\u003e这里\u003c/a\u003e)：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003e\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e\u003ccode\u003e$j$\u003c/code\u003e\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e0\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e1\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e2\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e3\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e4\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e5\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e6\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e$i$\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e$y_j$\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eB\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eD\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eC\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eB\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eA\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e$x_i$\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e1\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eA\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e0\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (←)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↖)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eB\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e1 (↖)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e1 (←)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (←)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (←)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eC\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e2 (↖)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e2 (←)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eB\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e3 (↖)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3 (←)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e5\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eD\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e3 (↑)\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3 (↑)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e6\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003eA\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e4 (↖)\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e7\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eB\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e1 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e2 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e3 (↑)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e4 (↖)\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003cstrong\u003e4 (↑)\u003c/strong\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其中，每个单元格前面的数字为最长公共子序列的长度，后面的符号为还原最长公共子序列使用的备忘录符号。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e最长公共子串 (Longest Common Substring)\u003c/strong\u003e 同最长公共子序列问题略有不同，子序列不要求字符是连续的，而子串要求字符必须是连续的。例如：给定序列 \u003ccode\u003e$X = \\left\\{A, B, C, B, D, A, B\\right\\}$\u003c/code\u003e 和序列 \u003ccode\u003e$Y = \\left\\{B, D, C, A, B, A\\right\\}$\u003c/code\u003e，最长公共子序列为 \u003ccode\u003e$\\left\\{B, C, B, A\\right\\}$\u003c/code\u003e，而最长公共子串为 \u003ccode\u003e$\\left\\{A, B\\right\\}$\u003c/code\u003e 或 \u003ccode\u003e$\\left\\{B, D\\right\\}$\u003c/code\u003e。用 \u003ccode\u003e$c_{i, j}$\u003c/code\u003e 表示\u003ccode\u003e$X = \\left\\{x_1, x_2, \\dotsc, x_i\\right\\}$\u003c/code\u003e 和 \u003ccode\u003e$Y = \\left\\{y_1, y_2, \\dotsc, y_j\\right\\}$\u003c/code\u003e 情况下的最长公共子串的长度，则状态转移方程如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ c_{i, w} =  \\begin{cases} c_{i - 1, j - 1} + i, \u0026amp; x_i = y_j \\\\ 0, \u0026amp; x_i \\neq y_j \\\\ 0, \u0026amp; i j = 0 \\end{cases} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e利用动态规划可以在 \u003ccode\u003e$\\Theta \\left(nm\\right)$\u003c/code\u003e 的时间复杂度内求解，利用广义后缀树 \u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e 可以进一步降低问题求解的时间复杂度 \u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003ch2 id=\"floyd-warshall-算法\"\u003eFloyd-Warshall 算法\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eFloyd-Warshall 算法\u003c/strong\u003e 是一种求解任意两点之间 \u003cstrong\u003e最短路\u003c/strong\u003e 的算法，相比 \u003cstrong\u003eDijkstra 算法\u003c/strong\u003e \u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e，Floyd-Warshall 算法可以处理有向图或负权图 (但不可以存在负权回路) 的情况 \u003csup id=\"fnref:6\"\u003e\u003ca href=\"#fn:6\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e6\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003cp\u003e用 \u003ccode\u003e$d_{i, j}^{\\left(k\\right)}$\u003c/code\u003e 表示从 \u003ccode\u003e$i$\u003c/code\u003e 到 \u003ccode\u003e$j$\u003c/code\u003e 路径上最大节点的标号为 \u003ccode\u003e$k$\u003c/code\u003e 的最短路径的长度。有：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e$d_{i, j}^{\\left(k\\right)} = d_{i, k}^{\\left(k-1\\right)} + d_{k, j}^{\\left(k-1\\right)}$\u003c/code\u003e，若最短路径经过点 \u003ccode\u003e$k$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$d_{i, j}^{\\left(k\\right)} = d_{i, j}^{\\left(k-1\\right)}$\u003c/code\u003e，若最短路径不经过点 \u003ccode\u003e$k$\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e则状态转移方程如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ d_{i, j}^{\\left(k\\right)} =  \\begin{cases} w_{i, j}, \u0026amp; k = 0 \\\\ \\min \\left(d_{i, j}^{\\left(k-1\\right)}, d_{i, k}^{\\left(k-1\\right)} + d_{k, j}^{\\left(k-1\\right)}\\right), \u0026amp; k \\leq 1 \\end{cases} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e以下图所示的最短路问题为例：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2018-11-18-computational-complexity-and-dynamic-programming/shortest-path.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eFloyd-Warshall 算法的求解伪代码如下所示：\u003c/p\u003e\n\n\n\u003clink rel=\"stylesheet\" type=\"text/css\" href=\"//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css\"/\u003e\n\n\n\u003cdiv\u003e\u003cpre class=\"pseudocode\"\u003e\\begin{algorithm}\n\\caption{Floyd-Warshall 算法}\n\\begin{algorithmic}\n\\REQUIRE \\\\\n    边集合 $w$ \\\\\n    顶点数量 $c$\n\\ENSURE \\\\\n    距离矩阵 $d$ \\\\\n    备忘录矩阵 $m$\n\\FUNCTION{Floyd-Warshall}{$w, c$}\n\\FOR{$i$ = $1$ to $c$}\n    \\FOR{$j$ = $1$ to $c$}\n        \\STATE $d_{i, j} \\gets \\infty$\n    \\ENDFOR\n\\ENDFOR\n\\FOR{$i$ = $1$ to $c$}\n    \\STATE $d_{i, i} \\gets 0$\n\\ENDFOR\n\\FORALL{$w_{i, j}$}\n    \\STATE $d_{i, j} \\gets w_{i, j}$\n\\ENDFOR\n\\FOR{$k$ = $1$ to $c$}\n    \\FOR{$i$ = $1$ to $c$}\n        \\FOR{$j$ = $1$ to $c$}\n            \\IF{$d_{i, j} \u0026gt; d_{i, k} + d_{k, j}$}\n                \\STATE $d_{i, j} \\gets d_{i, k} + d_{k, j}$\n                \\STATE $m_{i, j} \\gets k$\n            \\ENDIF\n        \\ENDFOR\n    \\ENDFOR\n\\ENDFOR\n\\ENDFUNCTION\n\\end{algorithmic}\n\\end{algorithm}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e通过备忘录矩阵 \u003ccode\u003e$m$\u003c/code\u003e，恢复从点 \u003ccode\u003e$i$\u003c/code\u003e 到点 \u003ccode\u003e$j$\u003c/code\u003e 的过程如下所示：\u003c/p\u003e\n\n\n\u003cdiv\u003e\u003cpre class=\"pseudocode\"\u003e\\begin{algorithm}\n\\caption{Floyd-Warshall-Path 算法}\n\\begin{algorithmic}\n\\REQUIRE \\\\\n    备忘录矩阵 $m$ \\\\\n    起点 $i$ \\\\\n    终点 $j$ \\\\\n    路径 $p$\n\\FUNCTION{Floyd-Warshall-Path}{$m, i, j, p$}\n\\IF{$i == j$}\n    \\RETURN\n\\ENDIF\n\\IF{$m_{i, j} == 0$}\n    \\STATE $p \\gets p \\cup j$\n\\ELSE\n    \\STATE Floyd-Warshall-Path($m, i, m_{i, j}, p$)\n    \\STATE Floyd-Warshall-Path($m, m_{i, j}, j, p$)\n\\ENDIF\n\\ENDFUNCTION\n\\end{algorithmic}\n\\end{algorithm}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cdiv class=\"admonition admonition-note  kai\"\u003e\n  \u003cdiv class=\"admonition-content\"\u003e文章部分内容参考了 Thomas H. Cormen 等人的《算法导论》\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA\"\u003ehttps://zh.wikipedia.org/zh/计算复杂性理论\u003c/a\u003e \u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"\u003ehttps://zh.wikipedia.org/zh/动态规划\u003c/a\u003e \u003ca href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/%E5%90%8E%E7%BC%80%E6%A0%91\"\u003ehttps://zh.wikipedia.org/zh/后缀树\u003c/a\u003e \u003ca href=\"#fnref:3\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2\"\u003ehttps://zh.wikipedia.org/zh/最长公共子串\u003c/a\u003e \u003ca href=\"#fnref:4\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\"\u003ehttps://zh.wikipedia.org/zh/戴克斯特拉算法\u003c/a\u003e \u003ca href=\"#fnref:5\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:6\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh/Floyd-Warshall%E7%AE%97%E6%B3%95\"\u003ehttps://zh.wikipedia.org/zh/Floyd-Warshall算法\u003c/a\u003e \u003ca href=\"#fnref:6\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"donate\"\u003e\n  \u003cdiv class=\"donate-header\"\u003e\u003c/div\u003e\n  \u003cdiv class=\"donate-slug\" id=\"donate-slug\"\u003ecomputational-complexity-and-dynamic-programming\u003c/div\u003e\n  \u003cbutton class=\"donate-button\"\u003e赞 赏\u003c/button\u003e\n  \u003cdiv class=\"donate-footer\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"donate-modal-wrapper\"\u003e\n  \u003cdiv class=\"donate-modal\"\u003e\n    \u003cdiv class=\"donate-box\"\u003e\n      \u003cdiv class=\"donate-box-content\"\u003e\n        \u003cdiv class=\"donate-box-content-inner\"\u003e\n          \u003cdiv class=\"donate-box-header\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n          \u003cdiv class=\"donate-box-body\"\u003e\n            \u003cdiv class=\"donate-box-money\"\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-2\" data-v=\"2\" data-unchecked=\"￥ 2\" data-checked=\"2 元\"\u003e￥ 2\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-5\" data-v=\"5\" data-unchecked=\"￥ 5\" data-checked=\"5 元\"\u003e￥ 5\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-10\" data-v=\"10\" data-unchecked=\"￥ 10\" data-checked=\"10 元\"\u003e￥ 10\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-50\" data-v=\"50\" data-unchecked=\"￥ 50\" data-checked=\"50 元\"\u003e￥ 50\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-100\" data-v=\"100\" data-unchecked=\"￥ 100\" data-checked=\"100 元\"\u003e￥ 100\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-custom\" data-v=\"custom\" data-unchecked=\"任意金额\" data-checked=\"任意金额\"\u003e任意金额\u003c/button\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-qrcode\" id=\"donate-box-pay-qrcode\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"donate-box-footer\"\u003e\n            \u003cdiv class=\"donate-box-pay-method donate-box-pay-method-checked\" data-v=\"wechat-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-wechat-pay\" src=\"\"/\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay-method\" data-v=\"alipay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-alipay\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"button\" class=\"donate-box-close-button\"\u003e\n      \u003csvg class=\"donate-box-close-button-icon\" fill=\"#fff\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"\u003e\u003cpath d=\"M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z\" fill-rule=\"evenodd\"\u003e\u003c/path\u003e\u003c/svg\u003e\n    \u003c/button\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cscript type=\"text/javascript\" src=\"/js/donate.js\"\u003e\u003c/script\u003e\n\n\n  \u003cfooter\u003e\n  \n\u003cnav class=\"post-nav\"\u003e\n  \u003cspan class=\"nav-prev\"\u003e← \u003ca href=\"/cn/2018/10/serving-models-with-flask-and-gae/\"\u003e利用 Flask 和 Google App Engine 部署模型服务\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"nav-next\"\u003e\u003ca href=\"/cn/2018/12/ensemble-learning/\"\u003e集成学习算法 (Ensemble Learning)\u003c/a\u003e →\u003c/span\u003e\n\u003c/nav\u003e\n\n\n\n\n\u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"8302038603\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n  (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/toggle-theme.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"/js/no-highlight.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/math-code.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/heading-anchor.js\"\u003e\u003c/script\u003e\n\n\n\n\u003csection class=\"comments\"\u003e\n\u003cscript src=\"https://giscus.app/client.js\" data-repo=\"leovan/leovan.me\" data-repo-id=\"MDEwOlJlcG9zaXRvcnkxMTMxOTY0Mjc=\" data-category=\"Comments\" data-category-id=\"DIC_kwDOBr89i84CT-R7\" data-mapping=\"pathname\" data-strict=\"1\" data-reactions-enabled=\"1\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"preferred_color_scheme\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" defer=\"\"\u003e\n\u003c/script\u003e\n\u003c/section\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n  (function() {\n    if (!self.Prism) {\n      return;\n    }\n\n    \n    Prism.languages.dos = Prism.languages.powershell;\n    Prism.languages.gremlin = Prism.languages.groovy;\n\n    let languages = {\n      'r': 'R', 'python': 'Python', 'xml': 'XML', 'html': 'HTML',\n      'yaml': 'YAML', 'latex': 'LaTeX', 'tex': 'TeX',\n      'powershell': 'PowerShell', 'javascript': 'JavaScript',\n      'dos': 'DOS', 'qml': 'QML', 'json': 'JSON', 'bash': 'Bash',\n      'text': 'Text', 'txt': 'Text', 'sparql': 'SPARQL',\n      'gremlin': 'Gremlin', 'cypher': 'Cypher', 'ngql': 'nGQL',\n      'shell': 'Shell', 'sql': 'SQL', 'apacheconf': 'Apache Configuration', 'c': 'C', 'css': 'CSS'\n    };\n\n    Prism.hooks.add('before-highlight', function(env) {\n      if (env.language !== 'plain') {\n        let language = languages[env.language] || env.language;\n        env.element.setAttribute('data-language', language);\n      }\n    });\n\n    \n    let ClipboardJS = window.ClipboardJS || undefined;\n\n    Prism.plugins.toolbar.registerButton('copy-to-clipboard', function(env) {\n      let linkCopy = document.createElement('button');\n      linkCopy.classList.add('prism-button-copy');\n\n      registerClipboard();\n\n      return linkCopy;\n\n      function registerClipboard() {\n        let clip = new ClipboardJS(linkCopy, {\n          'text': function () {\n            return env.code;\n          }\n        });\n\n        clip.on('success', function() {\n          linkCopy.classList.add('prism-button-copy-success');\n          resetText();\n        });\n        clip.on('error', function () {\n          linkCopy.classList.add('prism-button-copy-error');\n          resetText();\n        });\n      }\n\n      function resetText() {\n        setTimeout(function () {\n          linkCopy.classList.remove('prism-button-copy-success');\n          linkCopy.classList.remove('prism-button-copy-error');\n        }, 1600);\n      }\n    });\n  })();\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\"\u003e\nlet pseudocodeCaptionCount = 0;\n(function(d) {\n  d.querySelectorAll(\".pseudocode\").forEach(function(elem) {\n    let pseudocode_options = {\n      indentSize: '1.2em',\n      commentDelimiter: '\\/\\/',\n      lineNumber:  true ,\n      lineNumberPunc: ':',\n      noEnd:  false \n    };\n    pseudocode_options.captionCount = pseudocodeCaptionCount;\n    pseudocodeCaptionCount += 1;\n    pseudocode.renderElement(elem, pseudocode_options);\n  });\n})(document);\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\u003cscript async=\"\" src=\"/js/center-img.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/right-quote.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/external-link.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/alt-title.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/figure.js\"\u003e\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\naddBackToTop({\n  diameter: 48\n});\n\u003c/script\u003e\n\n  \u003chr/\u003e\n  \u003cdiv class=\"copyright no-border-bottom\"\u003e\n    \u003cdiv class=\"copyright-author-year\"\u003e\n      \u003cspan\u003eCopyright © 2017-2024 \u003ca href=\"/\"\u003e范叶亮 | Leo Van\u003c/a\u003e\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003c/footer\u003e\n  \u003c/article\u003e",
  "Date": "2018-11-18T00:00:00Z",
  "Author": "范叶亮"
}