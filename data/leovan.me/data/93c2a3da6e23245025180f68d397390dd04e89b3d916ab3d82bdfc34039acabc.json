{
  "Source": "leovan.me",
  "Title": "进程，线程和协程 (Process, Thread and Coroutine)",
  "Link": "https://leovan.me/cn/2021/04/process-thread-and-coroutine-python-implementation/",
  "Content": "\u003carticle class=\"main\"\u003e\n    \u003cheader class=\"content-title\"\u003e\n    \n\u003ch1 class=\"title\"\u003e\n  \n  进程，线程和协程 (Process, Thread and Coroutine)\n  \n\u003c/h1\u003e\n\u003ch2 class=\"subtitle\"\u003e实现篇\u003c/h2\u003e\n\n\n\n\n\n\n\u003ch2 class=\"author-date\"\u003e范叶亮 / \n2021-04-03\u003c/h2\u003e\n\n\n\n\u003ch3 class=\"post-meta\"\u003e\n\n\n\u003cstrong\u003e分类: \u003c/strong\u003e\n\u003ca href=\"/categories/%E7%BC%96%E7%A8%8B\"\u003e编程\u003c/a\u003e\n\n\n\n\n/\n\n\n\n\n\u003cstrong\u003e标签: \u003c/strong\u003e\n\u003cspan\u003e进程\u003c/span\u003e, \u003cspan\u003eProcess\u003c/span\u003e, \u003cspan\u003e线程\u003c/span\u003e, \u003cspan\u003eThread\u003c/span\u003e, \u003cspan\u003e协程\u003c/span\u003e, \u003cspan\u003eCoroutine\u003c/span\u003e, \u003cspan\u003eCPU 密集型\u003c/span\u003e, \u003cspan\u003eIO 密集型\u003c/span\u003e, \u003cspan\u003e磁盘 IO 密集型\u003c/span\u003e, \u003cspan\u003e网络 IO 密集型\u003c/span\u003e, \u003cspan\u003e模拟 IO 密集型\u003c/span\u003e, \u003cspan\u003e互斥锁\u003c/span\u003e, \u003cspan\u003e可重入锁\u003c/span\u003e, \u003cspan\u003e嵌套锁\u003c/span\u003e, \u003cspan\u003e死锁\u003c/span\u003e, \u003cspan\u003e全局解释器锁\u003c/span\u003e, \u003cspan\u003eGlobal Interpreter Lock\u003c/span\u003e, \u003cspan\u003eGIL\u003c/span\u003e, \u003cspan\u003e事件\u003c/span\u003e, \u003cspan\u003eEvent\u003c/span\u003e, \u003cspan\u003e队列\u003c/span\u003e, \u003cspan\u003eQueue\u003c/span\u003e, \u003cspan\u003e池\u003c/span\u003e, \u003cspan\u003e进程池\u003c/span\u003e, \u003cspan\u003e线程池\u003c/span\u003e, \u003cspan\u003e容器\u003c/span\u003e, \u003cspan\u003e可迭代对象\u003c/span\u003e, \u003cspan\u003e生成器\u003c/span\u003e, \u003cspan\u003e迭代器\u003c/span\u003e, \u003cspan\u003eyield\u003c/span\u003e, \u003cspan\u003e双向通道\u003c/span\u003e, \u003cspan\u003easyncio\u003c/span\u003e, \u003cspan\u003e异步 IO\u003c/span\u003e, \u003cspan\u003e事件循环\u003c/span\u003e, \u003cspan\u003e回调\u003c/span\u003e, \u003cspan\u003eCallback\u003c/span\u003e\n\n\n\n\n/\n\n\n\u003cstrong\u003e字数: \u003c/strong\u003e\n7719\n\u003c/h3\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n    \n    \n    \u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"1261604535\"\u003e\u003c/ins\u003e\n    \u003cscript\u003e\n    (adsbygoogle = window.adsbygoogle || []).push({});\n    \u003c/script\u003e\n    \n    \n    \u003c/header\u003e\n\n\n\n\u003cdiv class=\"toc-depth-3\"\u003e\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#进程和线程\"\u003e进程和线程\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#利用函数创建线程\"\u003e利用函数创建线程\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#利用类创建线程\"\u003e利用类创建线程\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#锁\"\u003e锁\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#互斥锁\"\u003e互斥锁\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#可重入锁\"\u003e可重入锁\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#全局解释器锁\"\u003e全局解释器锁\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#通信\"\u003e通信\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#event-事件\"\u003eEvent 事件\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#condition\"\u003eCondition\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#queue-队列\"\u003eQueue 队列\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#进程池和线程池\"\u003e进程池和线程池\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#生成器和迭代器\"\u003e生成器和迭代器\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#可迭代对象\"\u003e可迭代对象\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#迭代器\"\u003e迭代器\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#生成器\"\u003e生成器\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#协程\"\u003e协程\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#yield\"\u003eyield\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#asyncio\"\u003easyncio\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\u003c/div\u003e\n\n\n\u003cblockquote\u003e\n\u003cp\u003e理论篇请参见：\u003ca href=\"/cn/2021/04/process-thread-and-coroutine-theory\"\u003e进程，线程和协程 (Process, Thread and Coroutine) - 理论篇\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e本文将介绍进程，线程和协程在 Python 中的实现，代码详见\u003ca href=\"https://github.com/leovan/leovan.me/tree/main/static/codes/cn/2021-04-03-process-thread-and-coroutine-python-implementation\"\u003e这里\u003c/a\u003e，部分参考自「Python 并发编程」 \u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e:。\u003c/p\u003e\n\u003ch1 id=\"进程和线程\"\u003e进程和线程\u003c/h1\u003e\n\u003cp\u003e在 Python 中可以使用 \u003ccode\u003emultiprocessing.Process\u003c/code\u003e 和 \u003ccode\u003ethreading.Thread\u003c/code\u003e 来实现进程和线程。我们采用\u003cstrong\u003eCPU 密集型\u003c/strong\u003e、\u003cstrong\u003e磁盘 IO 密集型\u003c/strong\u003e、\u003cstrong\u003e网络 IO 密集型\u003c/strong\u003e和\u003cstrong\u003e模拟 IO 密集型\u003c/strong\u003e任务类型来测试单线程，多线程和多进程之间的性能差异。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport requests\n\n# CPU 密集型\ndef cpu_bound_task(x=1, y=1):\n    c = 0\n\n    while c \u0026lt; 1500000:\n        c += 1\n        x += x\n        y += y\n\n# 磁盘 IO 密集型\ndef disk_io_bound_task():\n    with open(\u0026#39;tmp.log\u0026#39;, \u0026#39;w\u0026#39;) as f:\n        for idx in range(5000000):\n            f.write(\u0026#39;{}\\n\u0026#39;.format(idx))\n\n# 网络 IO 密集型\ndef web_io_bound_task():\n    try:\n        requests.get(\u0026#39;https://www.baidu.com\u0026#39;)\n    except Exception as e:\n        pass\n\n# 模拟 IO 密集型\ndef simulation_io_bound_task():\n    time.sleep(2)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了方便统计运行时间，定义如下一个运行时间装饰器：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\n\ndef timer(task_mode):\n    def wrapper(func):\n        def decorator(*args, **kwargs):\n            task_type = kwargs.setdefault(\u0026#39;task_type\u0026#39;, None)\n            start_time = time.time()\n            func(*args, **kwargs)\n            end_time = time.time()\n            print(\u0026#39;耗时（{} - {}）: {}\u0026#39;.format(\n                task_mode, task_type, end_time - start_time))\n        return decorator\n    return wrapper\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e单线程，多线程和多进程的测试代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom threading import Thread\nfrom multiprocessing import Process\n\n@timer(\u0026#39;单线程\u0026#39;)\ndef single_thread(func, task_type=\u0026#39;\u0026#39;, n=10):\n    for idx in range(n):\n        func()\n\n\n@timer(\u0026#39;多线程\u0026#39;)\ndef multi_threads(func, task_type=\u0026#39;\u0026#39;, n=10):\n    threads = {}\n\n    for idx in range(n):\n        t = Thread(target=func)\n        threads[idx] = t\n        t.start()\n\n    for thread in threads.values():\n        thread.join()\n\n\n@timer(\u0026#39;多进程\u0026#39;)\ndef multi_processes(func, task_type=\u0026#39;\u0026#39;, n=10):\n    processes = {}\n\n    for idx in range(n):\n        p = Process(target=func)\n        processes[idx] = p\n        p.start()\n\n    for process in processes.values():\n        process.join()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行测试\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 单线程\nsingle_thread(cpu_bound_task, task_type=\u0026#39;CPU 密集型任务\u0026#39;)\nsingle_thread(disk_io_bound_task, task_type=\u0026#39;磁盘 IO 密集型任务\u0026#39;)\nsingle_thread(web_io_bound_task, task_type=\u0026#39;网络 IO 密集型任务\u0026#39;)\nsingle_thread(simulation_io_bound_task, task_type=\u0026#39;模拟 IO 密集型任务\u0026#39;)\n\n# 多线程\nmulti_threads(cpu_bound_task, task_type=\u0026#39;CPU 密集型任务\u0026#39;)\nmulti_threads(disk_io_bound_task, task_type=\u0026#39;磁盘 IO 密集型任务\u0026#39;)\nmulti_threads(web_io_bound_task, task_type=\u0026#39;网络 IO 密集型任务\u0026#39;)\nmulti_threads(simulation_io_bound_task, task_type=\u0026#39;模拟 IO 密集型任务\u0026#39;\n\n# 多进程\nmulti_processes(cpu_bound_task, task_type=\u0026#39;CPU 密集型任务\u0026#39;)\nmulti_processes(disk_io_bound_task, task_type=\u0026#39;磁盘 IO 密集型任务\u0026#39;)\nmulti_processes(web_io_bound_task, task_type=\u0026#39;网络 IO 密集型任务\u0026#39;)\nmulti_processes(simulation_io_bound_task, task_type=\u0026#39;模拟 IO 密集型任务\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以得到类似如下的结果：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e单线程\u003c/th\u003e\n\u003cth\u003e多线程\u003c/th\u003e\n\u003cth\u003e多进程\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eCPU 密集型\u003c/td\u003e\n\u003ctd\u003e83.42\u003c/td\u003e\n\u003ctd\u003e93.82\u003c/td\u003e\n\u003ctd\u003e9.08\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e磁盘 IO 密集型\u003c/td\u003e\n\u003ctd\u003e15.64\u003c/td\u003e\n\u003ctd\u003e13.27\u003c/td\u003e\n\u003ctd\u003e1.28\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e网络 IO 密集型\u003c/td\u003e\n\u003ctd\u003e1.13\u003c/td\u003e\n\u003ctd\u003e0.18\u003c/td\u003e\n\u003ctd\u003e0.13\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e模拟 IO 密集型\u003c/td\u003e\n\u003ctd\u003e20.02\u003c/td\u003e\n\u003ctd\u003e2.02\u003c/td\u003e\n\u003ctd\u003e2.01\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e从测试结果来看，不难得出如下结论：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e多线程和多进程相比单线程速度整体上有很大提升。\u003c/li\u003e\n\u003cli\u003e对于 CPU 密集型任务，由于 GIL 加锁和释放问题，多线程相比单线程更慢。\u003c/li\u003e\n\u003cli\u003e多线程更适合在 IO 密集场景下使用，例如：爬虫等。\u003c/li\u003e\n\u003cli\u003e多进程更适合在 CPU 密集场景下使用，例如：大数据处理，机器学习等。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e创建线程有两种方式：\u003c/p\u003e\n\u003ch2 id=\"利用函数创建线程\"\u003e利用函数创建线程\u003c/h2\u003e\n\u003cp\u003ePython 中的 \u003ccode\u003ethreading.Thread()\u003c/code\u003e 接受两个参数：\u003cstrong\u003e线程函数\u003c/strong\u003e，用于指定线程执行的函数；\u003cstrong\u003e线程函数参数\u003c/strong\u003e，以元组的形式传入执行函数所需的参数。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\nfrom threading import Thread\n\n# 自定义函数\ndef func(name=\u0026#39;Python\u0026#39;):\n    for idx in range(2):\n        print(\u0026#39;Hello, {}\u0026#39;.format(name))\n        time.sleep(1)\n\n# 创建线程\nthread_1 = Thread(target=func)\nthread_2 = Thread(target=func, args=(\u0026#39;Leo\u0026#39;, ))\n\n# 启动线程\nthread_1.start()\nthread_2.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以得到如下输出：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHello, Python\nHello, Leo\nHello, Python\nHello, Leo\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"利用类创建线程\"\u003e利用类创建线程\u003c/h2\u003e\n\u003cp\u003e利用类创建线程需要自定义一个类并继承 \u003ccode\u003ethreading.Thread\u003c/code\u003e 这个父类，同时重写 \u003ccode\u003erun\u003c/code\u003e 方法。最后通过实例化该类，并运行 \u003ccode\u003estart()\u003c/code\u003e 方法执行该线程。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 自定义类\nclass MyThread(Thread):\n    def __init__(self, name=\u0026#39;Python\u0026#39;):\n        super(MyThread, self).__init__()\n        self.name = name\n\n    def run(self):\n        for idx in range(2):\n            print(\u0026#39;Hello, {}\u0026#39;.format(self.name))\n            time.sleep(1)\n\n# 创建线程\nthread_1 = MyThread()\nthread_2 = MyThread(\u0026#39;Leo\u0026#39;)\n\n# 启动线程\nthread_1.start()\nthread_2.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以得到同上面一样的输出：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHello, Python\nHello, Leo\nHello, Python\nHello, Leo\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e线程的一些常用方法和属性如下所示：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 创建线程\nt = Thread(target=func)\n\n# 启动线程\nt.start()\n\n# 阻塞线程\nt.join()\n\n# 判断线程是否处于执行状态\n# True: 执行中，False: 其他\nt.is_alive()\n\n# 这是线程是否随主线程退出而退出\n# 默认为 False\nt.daemon = True\n\n# 设置线程名称\nt.name = \u0026#39;My Thread\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"锁\"\u003e锁\u003c/h1\u003e\n\u003cp\u003e在一段代码中加锁表示同一时间有且仅有一个线程可以执行这段代码。在 Python 中锁分为两种：\u003cstrong\u003e互斥锁\u003c/strong\u003e和\u003cstrong\u003e可重入锁\u003c/strong\u003e。利用 \u003ccode\u003ethreading.Lock()\u003c/code\u003e 可以获取全局唯一的锁对象，使用 \u003ccode\u003eacquire()\u003c/code\u003e 和 \u003ccode\u003erelease()\u003c/code\u003e 方法可以获取和释放锁，注意两个需成对出现，否则可能造成死锁。\u003c/p\u003e\n\u003ch2 id=\"互斥锁\"\u003e互斥锁\u003c/h2\u003e\n\u003cp\u003e例如定义两个函数，并在两个线程中执行，这两个函数共用一个变量 \u003ccode\u003eC\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\nimport random\n\nfrom threading import Thread\n\n# 共用变量\nC = 0\n\ndef job1(n=10):\n    global C\n\n    for idx in range(n):\n        C += 1\n        print(\u0026#39;Job1: {}\u0026#39;.format(C))\n\ndef job2(n=10):\n    global C\n\n    for idx in range(n):\n        C += 10\n        print(\u0026#39;Job2: {}\u0026#39;.format(C))\n\nt1 = Thread(target=job1)\nt2 = Thread(target=job2)\n\nt1.start()\nt2.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJob1: 1\nJob2: 11\nJob2: 21\nJob1: 22\nJob1: 23\nJob2: 33\nJob2: 43\nJob1: 44\nJob2: 54\nJob1: 55\nJob2: 65\nJob1: 66\nJob2: 76\nJob2: 86\nJob1: 87\nJob1: 88\nJob2: 98\nJob1: 99\nJob2: 109\nJob1: 110\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e两个线程共用一个全局变量，两个线程根据自己执行的快慢对变量 \u003ccode\u003eC\u003c/code\u003e 进行修改。在增加锁后：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\nimport random\n\nfrom threading import Lock\n\n# 全局唯一锁\nLOCK = Lock()\n\n# 共用变量\nC = 0\n\ndef job1_with_lock(n=10):\n    global C, LOCK\n\n    LOCK.acquire()\n\n    for idx in range(n):\n        C += 1\n        print(\u0026#39;Job1: {}\u0026#39;.format(C))\n        time.sleep(random.random())\n\n    LOCK.release()\n\n\ndef job2_with_lock(n=10):\n    global C, LOCK\n\n    LOCK.acquire()\n\n    for idx in range(n):\n        C += 10\n        print(\u0026#39;Job2: {}\u0026#39;.format(C))\n        time.sleep(random.random())\n\n    LOCK.release()\n\nt1 = Thread(target=job1_with_lock)\nt2 = Thread(target=job2_with_lock)\n\nt1.start()\nt2.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eJob1: 1\nJob1: 2\nJob1: 3\nJob1: 4\nJob1: 5\nJob1: 6\nJob1: 7\nJob1: 8\nJob1: 9\nJob1: 10\nJob2: 20\nJob2: 30\nJob2: 40\nJob2: 50\nJob2: 60\nJob2: 70\nJob2: 80\nJob2: 90\nJob2: 100\nJob2: 110\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此时，由于 \u003ccode\u003ejob1_with_lock\u003c/code\u003e 先拿到了锁，所以当执行时 \u003ccode\u003ejob2_with_lock\u003c/code\u003e 无法获取到锁，就无法对 \u003ccode\u003eC\u003c/code\u003e 进行修改。只有当 \u003ccode\u003ejob1_with_lock\u003c/code\u003e 执行完毕释放锁后，\u003ccode\u003ejob2_with_lock\u003c/code\u003e 才能执行对 \u003ccode\u003eC\u003c/code\u003e 的修改操作。为了避免忘记释放锁，可以使用 \u003ccode\u003ewith\u003c/code\u003e 上下文管理器来加锁。\u003c/p\u003e\n\u003ch2 id=\"可重入锁\"\u003e可重入锁\u003c/h2\u003e\n\u003cp\u003e在同一个线程中，我们可能会多次请求同一个资源，这称为\u003cstrong\u003e嵌套锁\u003c/strong\u003e。如果使用常规的方式：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom threading import Lock\n\ndef lock_with_lock(n=10):\n    c = 0\n    lock = Lock()\n\n    with lock:\n        for idx in range(n):\n            c += 1\n            with lock:\n                print(c)\n\nt = Thread(target=lock_with_lock)\nt.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e则无法正常运行，因为第二次获取锁时，锁已经被同一线程获取，从而无法运行后续代码。由于后续代码无法运行则无法释放锁，从而上述的嵌套锁会造成\u003cstrong\u003e死锁\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，\u003ccode\u003ethreading\u003c/code\u003e 模块提供了\u003cstrong\u003e可重入锁\u003c/strong\u003e \u003ccode\u003eRLock\u003c/code\u003e：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom threading import RLock\n\ndef rlock_with_lock(n=10):\n    c = 0\n    lock = RLock()\n\n    with lock:\n        for idx in range(n):\n            c += 1\n            with lock:\n                print(c)\n  \nt = Thread(target=rlock_with_lock)\nt.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"全局解释器锁\"\u003e全局解释器锁\u003c/h2\u003e\n\u003cp\u003e全局解释器锁（Global Interpreter Lock，GIL），是计算机程序设计语言解释器用于同步线程的一种机制，它使得任何时刻仅有一个线程在执行。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行 100 条字节码，解释器就自动释放 GIL 锁，让别的线程有机会执行。这个 GIL 全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在 Python 中只能交替执行，即使 100 个线程跑在 100 核 CPU 上，也只能用到 1 个核。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"通信\"\u003e通信\u003c/h1\u003e\n\u003cp\u003ePython 中实现线程中通信有如下 3 中方法：\u003c/p\u003e\n\u003ch2 id=\"event-事件\"\u003eEvent 事件\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ethreading.Event\u003c/code\u003e 可以创建一个事件变量，多个线程等待这个事件的发生，在事件发生后，所有线程继续运行。\u003ccode\u003ethreading.Event\u003c/code\u003e 包含如下三个函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eevent = threading.Event()\n\n# 重置 event，使得所有该 event 事件都处于待命状态\nevent.clear()\n\n# 等待接收 event 的指令，决定是否阻塞程序执行\nevent.wait()\n\n# 发送 event 指令，使所有设置该 event 事件的线程执行\nevent.set()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\n\nfrom threading import Thread, Event\n\nclass EventThread(Thread):\n    def __init__(self, name, event):\n        super(EventThread, self).__init__()\n\n        self.name = name\n        self.event = event\n\n    def run(self):\n        print(\u0026#39;线程 {} 启动于 {}\u0026#39;.format(self.name, time.ctime(time.time())))\n        self.event.wait()\n        print(\u0026#39;线程 {} 结束于 {}\u0026#39;.format(self.name, time.ctime(time.time())))\n\nthreads = {}\nevent = Event()\n\nfor tid in range(3):\n    threads[tid] = EventThread(str(tid), event)\n\nevent.clear()\n\nfor thread in threads.values():\n    thread.start()\n\nprint(\u0026#39;等待 3 秒钟 ...\u0026#39;)\ntime.sleep(3)\n\nprint(\u0026#39;唤醒所有线程 ...\u0026#39;)\nevent.set() \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e线程 0 启动于 Thu Apr  1 23:12:32 2021\n线程 1 启动于 Thu Apr  1 23:12:32 2021\n线程 2 启动于 Thu Apr  1 23:12:32 2021\n等待 3 秒钟 ...\n唤醒所有线程 ...\n线程 0 结束于 Thu Apr  1 23:12:35 2021\n线程 1 结束于 Thu Apr  1 23:12:35 2021\n线程 2 结束于 Thu Apr  1 23:12:35 2021\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可见线程启动后并未执行完成，而是卡在了 \u003ccode\u003eevent.wait()\u003c/code\u003e 处，直到通过 \u003ccode\u003eevent.set()\u003c/code\u003e 发送指令后，所有线程才继续向下执行。\u003c/p\u003e\n\u003ch2 id=\"condition\"\u003eCondition\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ethreading.Condition\u003c/code\u003e 与 \u003ccode\u003ethreading.Event\u003c/code\u003e 类似，包含如下 4 个函数：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003econd = threading.Condition()\n\n# 类似 lock.acquire()\ncond.acquire()\n\n# 类似 lock.release()\ncond.release()\n\n# 等待指定触发，同时会释放对锁的获取,直到被 notify 才重新占有琐。\ncond.wait()\n\n# 发送指定，触发执行\ncond.notify()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以一个捉迷藏的游戏为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\n\nfrom threading import Thread, Condition\n\nclass Seeker(Thread):\n    def __init__(self, condition, name):\n        super(Seeker, self).__init__()\n\n        self.condition = condition\n        self.name = name\n\n    def run(self):\n        time.sleep(1) # 确保先运行 Hider 中的方法\n\n        self.condition.acquire()\n\n        print(\u0026#39;{}: 我把眼睛蒙好了\u0026#39;.format(self.name))\n        self.condition.notify()\n        self.condition.wait()\n        print(\u0026#39;{}: 我找到你了\u0026#39;.format(self.name))\n        self.condition.notify()\n\n        self.condition.release()\n        print(\u0026#39;{}: 我赢了\u0026#39;.format(self.name))\n\n\nclass Hider(Thread):\n    def __init__(self, condition, name):\n        super(Hider, self).__init__()\n\n        self.condition = condition\n        self.name = name\n\n    def run(self):\n        self.condition.acquire()\n\n        self.condition.wait()\n        print(\u0026#39;{}: 我藏好了\u0026#39;.format(self.name))\n        self.condition.notify()\n        self.condition.wait()\n        self.condition.release()\n        print(\u0026#39;{}: 被你找到了\u0026#39;.format(self.name))\n\ncondition = Condition()\n\nseeker = Seeker(condition, \u0026#39;Seeker\u0026#39;)\nhider = Hider(condition, \u0026#39;Hider\u0026#39;)\n\nseeker.start()\nhider.start()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eSeeker: 我把眼睛蒙好了\nHider: 我藏好了\nSeeker: 我找到你了\nSeeker: 我赢了\nHider: 被你找到了\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可见通过 \u003ccode\u003econd.wait()\u003c/code\u003e 和 \u003ccode\u003econd.notify()\u003c/code\u003e 进行阻塞和通知可以实现双方动作交替进行。\u003c/p\u003e\n\u003ch2 id=\"queue-队列\"\u003eQueue 队列\u003c/h2\u003e\n\u003cp\u003e从一个线程向另一个线程发送数据最安全的方式是使用 \u003ccode\u003equeue\u003c/code\u003e 库中的队列。创建一个被多个线程共享的队列对象，通过 \u003ccode\u003eput()\u003c/code\u003e 和 \u003ccode\u003eget()\u003c/code\u003e 方法向队列发送和获取元素。队列的常用方法如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom queue import Queue\n\n# maxsize=0 表示不限大小\n# maxsize\u0026gt;0 且消息数达到限制时，put() 方法会阻塞\nq = Queue(maxsize=0)\n\n# 默认阻塞程序，等待队列消息，可设置超时时间\nq.get(block=True, timeout=None)\n\n# 发送消息，默认会阻塞程序至队列中有空闲位置放入数据\nq.put(item, block=True, timeout=None)\n\n# 等待所有的消息都被消费完\nq.join()\n\n# 通知队列任务处理已经完成，当所有任务都处理完成时，join() 阻塞将会解除\nq.task_done()\n\n# 查询当前队列的消息个数\nq.qsize()\n\n# 队列消息是否都被消费完，返回 True/False\nq.empty()\n\n# 检测队列里消息是否已满\nq.full()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e以老师点名为例：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\n\nfrom queue import Queue\nfrom threading import Thread\n\nclass Student(object):\n    def __init__(self, name):\n        super(Student, self).__init__()\n\n        self.name = name\n\n    def speak(self):\n        print(\u0026#39;{}: 到\u0026#39;.format(self.name))\n\n\nclass Teacher(object):\n    def __init__(self, queue):\n        super(Teacher, self).__init__()\n\n        self.queue = queue\n\n    def call(self, student_name):\n        if student_name == \u0026#39;exit\u0026#39;:\n            print(\u0026#39;老师: 点名结束，开始上课\u0026#39;)\n        else:\n            print(\u0026#39;老师: {}\u0026#39;.format(student_name))\n\n        self.queue.put(student_name)\n\n\nclass CallManager(Thread):\n    def __init__(self, queue):\n        super(CallManager, self).__init__()\n\n        self.students = {}\n        self.queue = queue\n\n    def put(self, student):\n        self.students.setdefault(student.name, student)\n\n    def run(self):\n        while True:\n            student_name = self.queue.get()\n\n            if student_name == \u0026#39;exit\u0026#39;:\n                break\n            elif student_name in self.students:\n                self.students[student_name].speak()\n            else:\n                print(\u0026#39;学生: 老师，没有 {} 这个人\u0026#39;.format(student_name))\n\nqueue = Queue()\n\nteacher = Teacher(queue=queue)\ns1 = Student(name=\u0026#39;张三\u0026#39;)\ns2 = Student(name=\u0026#39;李四\u0026#39;)\n\ncm = CallManager(queue)\ncm.put(s1)\ncm.put(s2)\n\ncm.start()\n\nprint(\u0026#39;开始点名\u0026#39;)\nteacher.call(\u0026#39;张三\u0026#39;)\ntime.sleep(1)\nteacher.call(\u0026#39;李四\u0026#39;)\ntime.sleep(1)\nteacher.call(\u0026#39;王五\u0026#39;)\ntime.sleep(1)\nteacher.call(\u0026#39;exit\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e开始点名\n老师: 张三\n张三: 到\n老师: 李四\n李四: 到\n老师: 王五\n学生: 老师，没有 王五 这个人\n老师: 点名结束，开始上课\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e除了先进先出队列 \u003ccode\u003equeue.Queue\u003c/code\u003e 外，还有后进先出队列 \u003ccode\u003equeue.LifoQueue\u003c/code\u003e 和优先级队列 \u003ccode\u003equeue.PriorityQueue\u003c/code\u003e。\u003c/p\u003e\n\u003ch1 id=\"进程池和线程池\"\u003e进程池和线程池\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e池\u003c/strong\u003e是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。当服务器进入正式运行阶段，即开始处理客户请求的时候，如果它需要相关的资源，就可以直接从池中获取，无需动态分配。很显然，直接从池中取得所需资源比动态分配资源的速度要快得多，因为分配系统资源的系统调用都是很耗时的。\u003c/p\u003e\n\u003cp\u003e池的概念主要目的是为了重用：让线程或进程在生命周期内可以多次使用。它减少了创建创建线程和进程的开销，以空间换时间来提高了程序性能。重用不是必须的规则，但它是程序员在应用中使用池的主要原因。\u003c/p\u003e\n\u003cp\u003ePython 中利用 \u003ccode\u003econcurrent.futures\u003c/code\u003e 库中的 \u003ccode\u003eThreadPoolExecutor\u003c/code\u003e 和 \u003ccode\u003eProcessPoolExecutor\u003c/code\u003e 创建\u003cstrong\u003e线程池\u003c/strong\u003e和\u003cstrong\u003e进程池\u003c/strong\u003e。示例如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport time\nimport threading\n\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\n\n\ndef print_func(n=3):\n    for idx in range(n):\n        print(\u0026#39;运行 {}-{}\u0026#39;.format(threading.get_ident(), idx))\n        time.sleep(1)\n\n\ndef return_func(n=3):\n    res = []\n\n    for idx in range(n):\n        res.append(\u0026#39;{}-{}\u0026#39;.format(threading.get_ident(), idx))\n        time.sleep(1)\n\n    return res\n\n\ndef test_thread_pool_print(n=3, m=12):\n    with ThreadPoolExecutor(max_workers=n) as executor:\n        for _ in range(m):\n            executor.submit(print_func)\n\n\ndef test_process_pool_print(n=3, m=12):\n    with ProcessPoolExecutor(max_workers=n) as executor:\n        for _ in range(m):\n            executor.submit(print_func)\n\n\ndef test_thread_pool_return(n=3, m=12):\n    with ThreadPoolExecutor(max_workers=n) as executor:\n        futures = [executor.submit(return_func) for _ in range(m)]\n\n        for future in as_completed(futures):\n            print(future.result())\n\n\ndef test_process_pool_return(n=3, m=12):\n    with ProcessPoolExecutor(max_workers=n) as executor:\n        futures = [executor.submit(return_func) for _ in range(m)]\n\n        for future in as_completed(futures):\n            print(future.result())\n\n\nline_sep = \u0026#39;-\u0026#39; * 60\n\nprint(line_sep)\nprint(\u0026#39;测试线程池\u0026#39;)\nprint(line_sep)\ntest_thread_pool_print()\nprint(line_sep)\n\nprint(line_sep)\nprint(\u0026#39;测试进程池\u0026#39;)\nprint(line_sep)\ntest_process_pool_print()\nprint(line_sep)\n\nprint(line_sep)\nprint(\u0026#39;测试线程池\u0026#39;)\nprint(line_sep)\ntest_thread_pool_return()\nprint(line_sep)\n\nprint(line_sep)\nprint(\u0026#39;测试进程池\u0026#39;)\nprint(line_sep)\ntest_process_pool_return()\nprint(line_sep)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e------------------------------------------------------------\n测试线程池\n------------------------------------------------------------\n运行 123145462505472-0\n运行 123145479294976-0\n运行 123145496084480-0\n运行 123145496084480-1\n运行 123145462505472-1\n运行 123145479294976-1\n运行 123145496084480-2\n运行 123145462505472-2\n运行 123145479294976-2\n运行 123145462505472-0\n运行 123145479294976-0\n运行 123145496084480-0\n运行 123145479294976-1\n运行 123145462505472-1\n运行 123145496084480-1\n运行 123145479294976-2\n运行 123145462505472-2\n运行 123145496084480-2\n------------------------------------------------------------\n------------------------------------------------------------\n测试进程池\n------------------------------------------------------------\n运行 4545199616-0\n运行 4545199616-1\n运行 4545199616-2\n运行 4545199616-0\n运行 4545199616-1\n运行 4545199616-2\n运行 4663131648-0\n运行 4663131648-1\n运行 4663131648-2\n运行 4663131648-0\n运行 4663131648-1\n运行 4663131648-2\n运行 4633173504-0\n运行 4633173504-1\n运行 4633173504-2\n运行 4633173504-0\n运行 4633173504-1\n运行 4633173504-2\n------------------------------------------------------------\n------------------------------------------------------------\n测试线程池\n------------------------------------------------------------\n[\u0026#39;123145496084480-0\u0026#39;, \u0026#39;123145496084480-1\u0026#39;, \u0026#39;123145496084480-2\u0026#39;]\n[\u0026#39;123145479294976-0\u0026#39;, \u0026#39;123145479294976-1\u0026#39;, \u0026#39;123145479294976-2\u0026#39;]\n[\u0026#39;123145462505472-0\u0026#39;, \u0026#39;123145462505472-1\u0026#39;, \u0026#39;123145462505472-2\u0026#39;]\n[\u0026#39;123145479294976-0\u0026#39;, \u0026#39;123145479294976-1\u0026#39;, \u0026#39;123145479294976-2\u0026#39;]\n[\u0026#39;123145496084480-0\u0026#39;, \u0026#39;123145496084480-1\u0026#39;, \u0026#39;123145496084480-2\u0026#39;]\n[\u0026#39;123145462505472-0\u0026#39;, \u0026#39;123145462505472-1\u0026#39;, \u0026#39;123145462505472-2\u0026#39;]\n------------------------------------------------------------\n------------------------------------------------------------\n测试进程池\n------------------------------------------------------------\n[\u0026#39;4791307776-0\u0026#39;, \u0026#39;4791307776-1\u0026#39;, \u0026#39;4791307776-2\u0026#39;]\n[\u0026#39;4588228096-0\u0026#39;, \u0026#39;4588228096-1\u0026#39;, \u0026#39;4588228096-2\u0026#39;]\n[\u0026#39;4654599680-0\u0026#39;, \u0026#39;4654599680-1\u0026#39;, \u0026#39;4654599680-2\u0026#39;]\n[\u0026#39;4791307776-0\u0026#39;, \u0026#39;4791307776-1\u0026#39;, \u0026#39;4791307776-2\u0026#39;]\n[\u0026#39;4588228096-0\u0026#39;, \u0026#39;4588228096-1\u0026#39;, \u0026#39;4588228096-2\u0026#39;]\n[\u0026#39;4654599680-0\u0026#39;, \u0026#39;4654599680-1\u0026#39;, \u0026#39;4654599680-2\u0026#39;]\n------------------------------------------------------------\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其中，\u003ccode\u003esubmit()\u003c/code\u003e 方法用于提交要执行的任务到线程池或进程池中，并返回该任务的 \u003ccode\u003eFuture\u003c/code\u003e 对象。\u003ccode\u003eFuture\u003c/code\u003e 对象的 \u003ccode\u003edone()\u003c/code\u003e 方法用于判断任务是否执行完毕，通过 \u003ccode\u003eresult(timeout=None)\u003c/code\u003e 方法获取返回结果。利用 \u003ccode\u003econcurrent.futures.as_completed()\u003c/code\u003e 方法可以返回一个包含指定 Future 实例的迭代器，这些实例在完成时生成 Future 对象。\u003c/p\u003e\n\u003ch1 id=\"生成器和迭代器\"\u003e生成器和迭代器\u003c/h1\u003e\n\u003cfigure\u003e\n  \u003cimg class=\"lazyload\" data-src=\"/images/cn/2021-04-03-process-thread-and-coroutine-python-implementation/iterators-and-generators.png\" data-large-max-width=\"100%\" data-middle-max-width=\"100%\" data-small-max-width=\"100%\"/\u003e\n  \n  \u003cfigcaption class=\"kai\"\u003e图片来源：https://nvie.com/posts/iterators-vs-generators/\u003c/figcaption\u003e\n  \n\u003c/figure\u003e\n\u003cp\u003e\u003cstrong\u003e容器\u003c/strong\u003e是一种把多个元素组织在一起的数据结构，容器中的元素可以逐个迭代获取，可以用 \u003ccode\u003ein\u003c/code\u003e 或 \u003ccode\u003enot in\u003c/code\u003e 判断元素是否包含在容器中。常见的容器对象有：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elist, deque, ...\nset, frozensets, ...\ndict, defaultdict, OrderedDict, Counter, ...\ntuple, namedtuple, ...\nstr\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"可迭代对象\"\u003e可迭代对象\u003c/h2\u003e\n\u003cp\u003e很多容器都是\u003cstrong\u003e可迭代对象\u003c/strong\u003e，此外还有更多的对象同样也可以是可迭代对象，比如处于打开状态的 \u003ccode\u003efile\u003c/code\u003e 和 \u003ccode\u003esocket\u003c/code\u003e 等。凡是可以返回一个迭代器的对象都可称之为可迭代对象，例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections import deque\nfrom collections.abc import Iterable\n\nprint(isinstance(\u0026#39;Leo Van\u0026#39;, Iterable))\nprint(isinstance([1, 2, 3], Iterable))\nprint(isinstance({\u0026#39;k1\u0026#39;: \u0026#39;v1\u0026#39;, \u0026#39;k2\u0026#39;: \u0026#39;v2\u0026#39;}, Iterable))\nprint(isinstance(deque(\u0026#39;abc\u0026#39;), Iterable))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTrue\nTrue\nTrue\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"迭代器\"\u003e迭代器\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e迭代器\u003c/strong\u003e是一个带有状态的对象，通过 \u003ccode\u003enext()\u003c/code\u003e 方法可以返回容器中的下一个值。任何实现 \u003ccode\u003e__iter__()\u003c/code\u003e 和 \u003ccode\u003e__next__()\u003c/code\u003e 方法的对象都是迭代器。其中，\u003ccode\u003e__iter__()\u003c/code\u003e 方法返回迭代器本身，\u003ccode\u003e__next__()\u003c/code\u003e 方法返回容器中的下一个值，如果容器中没有更多元素了，则抛出 \u003ccode\u003eStopIteration\u003c/code\u003e 异常。例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eclass MyList(object):\n    def __init__(self, end):\n        super(MyList, self).__init__()\n\n        self.end = end\n\n    def __iter__(self):\n        return MyListIterator(self.end)\n\n    def __repr__(self):\n        return \u0026#39;[{}]\u0026#39;.format(\u0026#39;, \u0026#39;.join([str(ele) for ele in self]))\n\n\nclass MyListIterator(object):\n    def __init__(self, end):\n        super(MyListIterator, self).__init__()\n\n        self.data = end\n        self.start = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        while self.start \u0026lt; self.data:\n            self.start += 1\n            return self.start - 1\n\n        raise StopIteration\n\nmy_list = MyList(3)\n\nprint(\u0026#39;MyList: {}\u0026#39;.format(my_list))\nprint(isinstance(my_list, Iterable))\nprint(isinstance(my_list, Iterator))\n\nfor ele in my_list:\n    print(ele)\n\nmy_list_iterator = MyListIterator(3)\n\nprint(\u0026#39;MyListIterator: {}\u0026#39;.format(my_list_iterator))\nprint(isinstance(my_list_iterator, Iterable))\nprint(isinstance(my_list_iterator, Iterator))\n\nmy_iterator = iter(my_list)\n\nprint(\u0026#39;MyIterator: {}\u0026#39;.format(my_iterator))\nprint(isinstance(my_iterator, Iterable))\nprint(isinstance(my_iterator, Iterator))\n\nwhile True:\n    try:\n        print(next(my_iterator))\n    except StopIteration as e:\n        return\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eMyList: [0, 1, 2]\nTrue\nFalse\n0\n1\n2\nMyListIterator: \u0026lt;__main__.MyListIterator object at 0x7fc9602b2100\u0026gt;\nTrue\nTrue\n0\n1\n2\nMyIterator: \u0026lt;__main__.MyListIterator object at 0x7fc9602b2fa0\u0026gt;\nTrue\nTrue\n0\n1\n2\nStop\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"生成器\"\u003e生成器\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e生成器\u003c/strong\u003e非常类似于返回数组的函数，都是具有参数、可被调用、产生一系列的值。但是生成器并不是构造出数组包含所有的值并一次性返回，而是每次产生一个值，因此生成器看起来像函数，但行为像迭代器。\u003c/p\u003e\n\u003cp\u003ePython 中创建生成器有两种方法：使用类似列表方式或 \u003ccode\u003eyield\u003c/code\u003e 关键字：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections.abc import Generator\nfrom inspect import getgeneratorstate\n\na_list = [x for x in range(10)]\nprint(a_list)\nprint(isinstance(a_list, Generator))\n\na_generator = (x for x in range(10))\nprint(a_generator)\nprint(isinstance(a_generator, Generator))\n\ndef my_yield(n):\n    now = 0\n\n    while now \u0026lt; n:\n        yield now\n        now += 1\n\n    raise StopIteration\n\ngen = my_yield(4)\nprint(gen)\nprint(isinstance(gen, Generator))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nFalse\n\u0026lt;generator object \u0026lt;genexpr\u0026gt; at 0x7fdf84a8a430\u0026gt;\nTrue\n\u0026lt;generator object my_yield at 0x7fdf86a03f20\u0026gt;\nTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由于生成器并不是一次生成所有元素，而是每次执行后返回一个值，通过 \u003ccode\u003enext()\u003c/code\u003e 和 \u003ccode\u003egenerator.send(None)\u003c/code\u003e 两个方法可以激活生成器，例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef my_yield(n):\n    now = 0\n\n    while now \u0026lt; n:\n        yield now\n        now += 1\n\n    raise StopIteration\n\ngen = my_yield(4)\nprint(gen.send(None))\nprint(next(gen))\nprint(gen.send(None))\nprint(next(gen))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0\n1\n2\n3\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成器在其生命周期中共有 4 种状态：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eGEN_CREATED\u003c/code\u003e：已创建\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGEN_RUNNING\u003c/code\u003e：正在执行（只在多线程应用中能看到该状态）\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGEN_SUSPENDED\u003c/code\u003e：暂停中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eGEN_CLOSED\u003c/code\u003e：已关闭\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections.abc import Generator\nfrom inspect import getgeneratorstate\n\ndef my_yield(n):\n    now = 0\n\n    while now \u0026lt; n:\n        yield now\n        now += 1\n\n    raise StopIteration\n\ngen = my_yield(4)\nprint(gen)\nprint(getgeneratorstate(gen))\n\nprint(gen.send(None))\nprint(next(gen))\nprint(getgeneratorstate(gen))\n\nprint(gen.send(None))\nprint(next(gen))\nprint(getgeneratorstate(gen))\n\ngen.close()\nprint(getgeneratorstate(gen))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGEN_CREATED\n0\n1\nGEN_SUSPENDED\n2\n3\nGEN_SUSPENDED\nGEN_CLOSED\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e生成器在不满足生成元素的条件时，会抛出 \u003ccode\u003eStopIteration\u003c/code\u003e 异常，通过类似列表形式构建的生成器会自动实现该异常，自定的生成器则需要手动实现该异常。\u003c/p\u003e\n\u003ch1 id=\"协程\"\u003e协程\u003c/h1\u003e\n\u003ch2 id=\"yield\"\u003eyield\u003c/h2\u003e\n\u003cp\u003e协程通过 \u003ccode\u003eyield\u003c/code\u003e 暂停生成器，可以将程序的执行流程交给其他子程序，从而实现不同子程序之间的交替执行。例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003edef jump_range(n):\n    idx = 0\n\n    while idx \u0026lt; n:\n        jump = yield idx\n        print(\u0026#39;[idx: {}, jump: {}]\u0026#39;.format(idx, jump))\n\n        if jump is None:\n            jump = 1\n\n        idx += jump\n\nitr = jump_range(6)\nprint(next(itr))\nprint(itr.send(2))\nprint(next(itr))\nprint(itr.send(-1))\nprint(next(itr))\nprint(next(itr))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e0\n[idx: 0, jump: 2]\n2\n[idx: 2, jump: None]\n3\n[idx: 3, jump: -1]\n2\n[idx: 2, jump: None]\n3\n[idx: 3, jump: None]\n4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eyield idx\u003c/code\u003e 将 \u003ccode\u003eidx\u003c/code\u003e 返回给外部调用程序，\u003ccode\u003ejump = yield\u003c/code\u003e 可以接受外部程序通过 \u003ccode\u003esend()\u003c/code\u003e 发送的信息，并将其赋值给 \u003ccode\u003ejump\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eyield from\u003c/code\u003e 是 Python 3.3 之后出现的新语法，后面是可迭代对象，可以是普通的可迭代对象，也可以是迭代器，甚至是生成器。\u003ccode\u003eyield\u003c/code\u003e 和 \u003ccode\u003eyield from\u003c/code\u003e 的对比如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ea_str = \u0026#39;Leo\u0026#39;\na_list = [1, 2, 3]\na_dict = {\u0026#39;name\u0026#39;: \u0026#39;Leo\u0026#39;, \u0026#39;gender\u0026#39;: \u0026#39;Male\u0026#39;}\na_gen = (idx for idx in range(4, 8))\n\ndef gen(*args, **kwargs):\n    for item in args:\n        for ele in item:\n            yield ele\n\nnew_gen = gen(a_str, a_list, a_dict, a_gen)\nprint(list(new_gen))\n\na_gen = (idx for idx in range(4, 8))\n\ndef gen_from(*args, **kwargs):\n    for item in args:\n        yield from item\n\nnew_gen = gen_from(a_str, a_list, a_dict, a_gen)\nprint(list(new_gen))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e[\u0026#39;L\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;o\u0026#39;, 1, 2, 3, \u0026#39;name\u0026#39;, \u0026#39;gender\u0026#39;, 4, 5, 6, 7]\n[\u0026#39;L\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;o\u0026#39;, 1, 2, 3, \u0026#39;name\u0026#39;, \u0026#39;gender\u0026#39;, 4, 5, 6, 7]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在实现生成器的嵌套时，使用 \u003ccode\u003eyield from\u003c/code\u003e 可以比使用 \u003ccode\u003eyield\u003c/code\u003e 避免各种意想不到的异常。使用 \u003ccode\u003eyield from\u003c/code\u003e 时，需要关注如下几个概念：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e调用方：调用委托生成器的代码\u003c/li\u003e\n\u003cli\u003e委托生成器：包含 \u003ccode\u003eyield from\u003c/code\u003e 表达式的生成器函数\u003c/li\u003e\n\u003cli\u003e子生成器：\u003ccode\u003eyield from\u003c/code\u003e 后面的生成器函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如下是一个计算平均数的例子：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003e# 子生成器\ndef average_gen():\n    total = 0\n    count = 0\n    average = 0\n\n    while True:\n        num = yield average\n\n        if num is None:\n            break\n\n        count += 1\n        total += num\n        average = total / count\n\n    return total, count, average\n\n# 委托生成器\ndef proxy_gen():\n    while True:\n        total, count, average = yield from average_gen()\n        print(\u0026#39;计算完毕，共输入 {} 个数值，总和 {}，平均值 {}\u0026#39;.format(\n            count, total, average))\n\n# 调用方\ncalc_average = proxy_gen()\nnext(calc_average)\nprint(calc_average.send(10))\nprint(calc_average.send(20))\nprint(calc_average.send(30))\ncalc_average.send(None)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e10.0\n15.0\n20.0\n计算完毕，共输入 3 个数值，总和 60，平均值 20.0\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e委托生成器的作用是在调用方和子生成器之间建立一个\u003cstrong\u003e双向通道\u003c/strong\u003e，调用方通过 \u003ccode\u003esend()\u003c/code\u003e 将消息发送给子生成器，子生成器 \u003ccode\u003eyield\u003c/code\u003e 的值则返回给调用方。\u003ccode\u003eyield from\u003c/code\u003e 背后为整个过程做了很多操作，例如：捕获 \u003ccode\u003eStopIteration\u003c/code\u003e 异常等。\u003c/p\u003e\n\u003ch2 id=\"asyncio\"\u003easyncio\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 是 Python 3.4 引入的标准库，直接内置了对\u003cstrong\u003e异步 IO\u003c/strong\u003e 的支持。只要在一个函数前面加上 \u003ccode\u003easync\u003c/code\u003e 关键字就可以将一个函数变为一个协程。例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003efrom collections.abc import Coroutine\n\nasync def async_func(name):\n    print(\u0026#39;Hello, \u0026#39;, name)\n\ncoroutine = async_func(\u0026#39;World\u0026#39;)\nprint(isinstance(coroutine, Coroutine))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e利用 \u003ccode\u003easyncio.coroutine\u003c/code\u003e 装饰器可以将一个生成器当作协程使用，但其本质仍旧是一个生成器。例如：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\n\nfrom collections.abc import Generator, Coroutine\n\n@asyncio.coroutine\ndef coroutine_func(name):\n    print(\u0026#39;Hello,\u0026#39;, name)\n    yield from asyncio.sleep(1)\n    print(\u0026#39;Bye,\u0026#39;, name)\n\n\ncoroutine = coroutine_func(\u0026#39;World\u0026#39;)\nprint(isinstance(coroutine, Generator))\nprint(isinstance(coroutine, Coroutine))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTrue\nFalse\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 中包含如下几个重要概念：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eevent_loop\u003c/code\u003e 事件循环\u003c/strong\u003e：程序开启一个无限的循环，协程将注册到事件循环上，当满足事件发生时，调用相应的协程函数。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003ecoroutine\u003c/code\u003e 协程\u003c/strong\u003e：一个使用 \u003ccode\u003easync\u003c/code\u003e 定义的协程函数，它的调用不会立即执行，而是会返回一个协程对象。协程对象需要注册到事件循环上，由事件循环控制调用。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003efuture\u003c/code\u003e 对象\u003c/strong\u003e：代表将来执行或没有执行的对象。它和 \u003ccode\u003etask\u003c/code\u003e 对象没有本质上的区别。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003etask\u003c/code\u003e 对象\u003c/strong\u003e：一个协程对象是一个原生可以挂起的函数，任务是对协程的进一步封装，其中包含任务的各种状态。\u003ccode\u003eTask\u003c/code\u003e 对象是 \u003ccode\u003eFuture\u003c/code\u003e 的子类，它将 \u003ccode\u003ecoroutine\u003c/code\u003e 和 \u003ccode\u003eFuture\u003c/code\u003e 联系在一起，将 \u003ccode\u003ecoroutine\u003c/code\u003e 封装成为一个 \u003ccode\u003eFuture\u003c/code\u003e 对象。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003easync / await\u003c/code\u003e 关键字\u003c/strong\u003e：\u003ccode\u003easync\u003c/code\u003e 定义一个协程，\u003ccode\u003eawait\u003c/code\u003e 用于挂起阻塞的异步调用接口。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e协程完整的工作流程如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\n\nasync def hello(name):\n    print(\u0026#39;Hello,\u0026#39;, name)\n    \n# 定义协程\ncoroutine = hello(\u0026#39;World\u0026#39;)\n\n# 定义事件循环\nloop = asyncio.get_event_loop()\n\n# 创建任务\ntask = loop.create_task(coroutine)\n\n# 将任务交由时间循环并执行\nloop.run_until_complete(task)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eHello, World\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 用于挂起阻塞的异步调用接口，其作用在一定程度上类似于 \u003ccode\u003eyield\u003c/code\u003e。\u003ccode\u003eyield from\u003c/code\u003e 后面可接可迭代对象，也可接 future 对象或协程对象；\u003ccode\u003eawait\u003c/code\u003e 后面必须接 future 对象或协程对象。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\nfrom asyncio.futures import Future\n\nasync def hello(name):\n    await asyncio.sleep(2)\n    print(\u0026#39;Hello, \u0026#39;, name)\n\ncoroutine = hello(\u0026#34;World\u0026#34;)\n\n# 将协程转为 task 对象\ntask = asyncio.ensure_future(coroutine)\n\nprint(isinstance(task, Future))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eTrue\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e异步 IO 的实现原理就是在 IO 高的地方挂起，等 IO 结束后再继续执行。绝大部分情况下，后续代码的执行是需要依赖 IO 的返回值的，这就需要使用\u003cstrong\u003e回调\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e回调的实现有两种，一种是在同步编程中直接获取返回结果：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\nimport time\n\nasync def _sleep(x):\n    time.sleep(x)\n    return \u0026#39;暂停了 {} 秒\u0026#39;.format(x)\n\ncoroutine = _sleep(2)\nloop = asyncio.get_event_loop()\ntask = asyncio.ensure_future(coroutine)\n\nloop.run_until_complete(task)\nprint(\u0026#39;返回结果：{}\u0026#39;.format(task.result()))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e返回结果：暂停了 2 秒\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另一种是通过添加回调函数来实现：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\nimport time\n\nasync def _sleep(x):\n    time.sleep(x)\n    return \u0026#39;暂停了 {} 秒\u0026#39;.format(x)\n\ndef callback(future):\n    print(\u0026#39;回调返回结果：{}\u0026#39;.format(future.result()))\n\ncoroutine = _sleep(2)\nloop = asyncio.get_event_loop()\ntask = asyncio.ensure_future(coroutine)\n\ntask.add_done_callback(callback)\nloop.run_until_complete(task)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e回调返回结果：暂停了 2 秒\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio\u003c/code\u003e 实现并发需要多个协程来完成，每当有任务阻塞时需要 \u003ccode\u003eawait\u003c/code\u003e，然后让其他协程继续工作。\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\n\nasync def do_some_work(x):\n    print(\u0026#39;等待中 ...\u0026#39;)\n    await asyncio.sleep(x)\n    print(\u0026#39;{} 秒后结束\u0026#39;.format(x))\n    return x\n\n# 协程对象\ncoroutine1 = do_some_work(1)\ncoroutine2 = do_some_work(2)\ncoroutine3 = do_some_work(4)\n\n# 任务列表\ntasks = [\n    asyncio.ensure_future(coroutine1),\n    asyncio.ensure_future(coroutine2),\n    asyncio.ensure_future(coroutine3)\n]\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(asyncio.wait(tasks))\n\nfor task in tasks:\n    print(\u0026#39;任务结果：{}\u0026#39;.format(task.result()))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e等待中 ...\n等待中 ...\n等待中 ...\n1 秒后结束\n2 秒后结束\n4 秒后结束\n任务结果：1\n任务结果：2\n任务结果：4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e协程之间可以进行嵌套，即在一个协程中 \u003ccode\u003eawait\u003c/code\u003e 另一个协程：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport asyncio\n\nasync def do_some_work(x):\n    print(\u0026#39;等待中 ...\u0026#39;)\n    await asyncio.sleep(x)\n    print(\u0026#39;{} 秒后结束\u0026#39;.format(x))\n    return x\n\nasync def out_do_some_work():\n    coroutine1 = do_some_work(1)\n    coroutine2 = do_some_work(2)\n    coroutine3 = do_some_work(4)\n\n    tasks = [\n        asyncio.ensure_future(coroutine1),\n        asyncio.ensure_future(coroutine2),\n        asyncio.ensure_future(coroutine3)\n    ]\n\n    dones, pendings = await asyncio.wait(tasks)\n\n    for task in dones:\n        print(\u0026#39;任务结果：{}\u0026#39;.format(task.result()))\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(out_do_some_work())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果使用 \u003ccode\u003easyncio.gather()\u003c/code\u003e 来获取结果，则需要对获取结果部分做如下修改：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eresults = await asyncio.gather(*tasks)\nfor result in results:\n    print(\u0026#39;任务结果：{}\u0026#39;.format(result))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio.wait()\u003c/code\u003e 返回 \u003ccode\u003edones\u003c/code\u003e 和 \u003ccode\u003ependings\u003c/code\u003e，分别表示已完成和未完成的任务；\u003ccode\u003easyncio.gather()\u003c/code\u003e 则会把结果直接返回。\u003c/p\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e等待中 ...\n等待中 ...\n等待中 ...\n1 秒后结束\n2 秒后结束\n4 秒后结束\n任务结果：1\n任务结果：4\n任务结果：2\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e协程（准确的说是 \u003ccode\u003eFuture\u003c/code\u003e 或 \u003ccode\u003eTask\u003c/code\u003e 对象）包含如下状态：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ePending\u003c/code\u003e：已创建，未执行\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRunning\u003c/code\u003e：执行中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDone\u003c/code\u003e：执行完毕\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCancelled\u003c/code\u003e：被取消\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e测试代码如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003ecoroutine = _sleep(10)\nloop = asyncio.get_event_loop()\ntask = loop.create_task(coroutine)\n\nprint(\u0026#39;Pending\u0026#39;)\n\ntry:\n    t = Thread(target=loop.run_until_complete, args=(task, ))\n    t.start()\n    print(\u0026#39;Running\u0026#39;)\n    t.join()\nexcept KeyboardInterrupt as e:\n    task.cancel()\n    print(\u0026#39;Cancel\u0026#39;)\nfinally:\n    print(\u0026#39;Done\u0026#39;)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e执行顺利的话，运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePending\nRunning\nDone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果在启动后按下 \u003ckbd\u003eCtrl\u003c/kbd\u003e + \u003ckbd\u003eC\u003c/kbd\u003e 则会触发 \u003ccode\u003etask.cancel()\u003c/code\u003e，运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ePending\nRunning\nCancelled\nDone\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003easyncio.wait()\u003c/code\u003e 可以通过参数控制何时返回：\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-python\"\u003eimport random\nimport asyncio\n\nasync def random_sleep():\n    await asyncio.sleep(random.uniform(0.5, 6))\n\nloop = asyncio.get_event_loop()\ntasks = [random_sleep() for _ in range(1, 10)]\n\ndones, pendings = loop.run_until_complete(asyncio.wait(\n    tasks, return_when=asyncio.FIRST_COMPLETED))\nprint(\u0026#39;第一次完成的任务数：{}\u0026#39;.format(len(dones)))\n\ndones, pendings = loop.run_until_complete(asyncio.wait(\n    pendings, timeout=2))\nprint(\u0026#39;第二次完成的任务数: {}\u0026#39;.format(len(dones)))\n\ndones, pendings = loop.run_until_complete(asyncio.wait(pendings))\nprint(\u0026#39;第三次完成的任务数：{}\u0026#39;.format(len(dones)))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e运行结果如下：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e第一次完成的任务数：1\n第二次完成的任务数: 4\n第三次完成的任务数：4\n\u003c/code\u003e\u003c/pre\u003e\n\u003cdiv class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\"\u003e\n\u003cp\u003e\u003ca href=\"https://iswbm.com/108.html\"\u003ehttps://iswbm.com/108.html\u003c/a\u003e \u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"donate\"\u003e\n  \u003cdiv class=\"donate-header\"\u003e\u003c/div\u003e\n  \u003cdiv class=\"donate-slug\" id=\"donate-slug\"\u003eprocess-thread-and-coroutine-python-implementation\u003c/div\u003e\n  \u003cbutton class=\"donate-button\"\u003e赞 赏\u003c/button\u003e\n  \u003cdiv class=\"donate-footer\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"donate-modal-wrapper\"\u003e\n  \u003cdiv class=\"donate-modal\"\u003e\n    \u003cdiv class=\"donate-box\"\u003e\n      \u003cdiv class=\"donate-box-content\"\u003e\n        \u003cdiv class=\"donate-box-content-inner\"\u003e\n          \u003cdiv class=\"donate-box-header\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n          \u003cdiv class=\"donate-box-body\"\u003e\n            \u003cdiv class=\"donate-box-money\"\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-2\" data-v=\"2\" data-unchecked=\"￥ 2\" data-checked=\"2 元\"\u003e￥ 2\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-5\" data-v=\"5\" data-unchecked=\"￥ 5\" data-checked=\"5 元\"\u003e￥ 5\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-10\" data-v=\"10\" data-unchecked=\"￥ 10\" data-checked=\"10 元\"\u003e￥ 10\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-50\" data-v=\"50\" data-unchecked=\"￥ 50\" data-checked=\"50 元\"\u003e￥ 50\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-100\" data-v=\"100\" data-unchecked=\"￥ 100\" data-checked=\"100 元\"\u003e￥ 100\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-custom\" data-v=\"custom\" data-unchecked=\"任意金额\" data-checked=\"任意金额\"\u003e任意金额\u003c/button\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-qrcode\" id=\"donate-box-pay-qrcode\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"donate-box-footer\"\u003e\n            \u003cdiv class=\"donate-box-pay-method donate-box-pay-method-checked\" data-v=\"wechat-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-wechat-pay\" src=\"\"/\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay-method\" data-v=\"alipay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-alipay\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"button\" class=\"donate-box-close-button\"\u003e\n      \u003csvg class=\"donate-box-close-button-icon\" fill=\"#fff\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"\u003e\u003cpath d=\"M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z\" fill-rule=\"evenodd\"\u003e\u003c/path\u003e\u003c/svg\u003e\n    \u003c/button\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cscript type=\"text/javascript\" src=\"/js/donate.js\"\u003e\u003c/script\u003e\n\n\n  \u003cfooter\u003e\n  \n\u003cnav class=\"post-nav\"\u003e\n  \u003cspan class=\"nav-prev\"\u003e← \u003ca href=\"/cn/2021/04/process-thread-and-coroutine-theory/\"\u003e进程，线程和协程 (Process, Thread and Coroutine)\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"nav-next\"\u003e\u003ca href=\"/cn/2021/05/sql-style-guide/\"\u003eSQL 样式指南 (SQL Style Guide)\u003c/a\u003e →\u003c/span\u003e\n\u003c/nav\u003e\n\n\n\n\n\u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"8302038603\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n  (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/toggle-theme.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"/js/no-highlight.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/math-code.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/heading-anchor.js\"\u003e\u003c/script\u003e\n\n\n\n\u003csection class=\"comments\"\u003e\n\u003cscript src=\"https://giscus.app/client.js\" data-repo=\"leovan/leovan.me\" data-repo-id=\"MDEwOlJlcG9zaXRvcnkxMTMxOTY0Mjc=\" data-category=\"Comments\" data-category-id=\"DIC_kwDOBr89i84CT-R7\" data-mapping=\"pathname\" data-strict=\"1\" data-reactions-enabled=\"1\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"preferred_color_scheme\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" defer=\"\"\u003e\n\u003c/script\u003e\n\u003c/section\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n  (function() {\n    if (!self.Prism) {\n      return;\n    }\n\n    \n    Prism.languages.dos = Prism.languages.powershell;\n    Prism.languages.gremlin = Prism.languages.groovy;\n\n    let languages = {\n      'r': 'R', 'python': 'Python', 'xml': 'XML', 'html': 'HTML',\n      'yaml': 'YAML', 'latex': 'LaTeX', 'tex': 'TeX',\n      'powershell': 'PowerShell', 'javascript': 'JavaScript',\n      'dos': 'DOS', 'qml': 'QML', 'json': 'JSON', 'bash': 'Bash',\n      'text': 'Text', 'txt': 'Text', 'sparql': 'SPARQL',\n      'gremlin': 'Gremlin', 'cypher': 'Cypher', 'ngql': 'nGQL',\n      'shell': 'Shell', 'sql': 'SQL', 'apacheconf': 'Apache Configuration', 'c': 'C', 'css': 'CSS'\n    };\n\n    Prism.hooks.add('before-highlight', function(env) {\n      if (env.language !== 'plain') {\n        let language = languages[env.language] || env.language;\n        env.element.setAttribute('data-language', language);\n      }\n    });\n\n    \n    let ClipboardJS = window.ClipboardJS || undefined;\n\n    Prism.plugins.toolbar.registerButton('copy-to-clipboard', function(env) {\n      let linkCopy = document.createElement('button');\n      linkCopy.classList.add('prism-button-copy');\n\n      registerClipboard();\n\n      return linkCopy;\n\n      function registerClipboard() {\n        let clip = new ClipboardJS(linkCopy, {\n          'text': function () {\n            return env.code;\n          }\n        });\n\n        clip.on('success', function() {\n          linkCopy.classList.add('prism-button-copy-success');\n          resetText();\n        });\n        clip.on('error', function () {\n          linkCopy.classList.add('prism-button-copy-error');\n          resetText();\n        });\n      }\n\n      function resetText() {\n        setTimeout(function () {\n          linkCopy.classList.remove('prism-button-copy-success');\n          linkCopy.classList.remove('prism-button-copy-error');\n        }, 1600);\n      }\n    });\n  })();\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cscript async=\"\" src=\"/js/center-img.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/right-quote.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/external-link.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/alt-title.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/figure.js\"\u003e\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\naddBackToTop({\n  diameter: 48\n});\n\u003c/script\u003e\n\n  \u003chr/\u003e\n  \u003cdiv class=\"copyright no-border-bottom\"\u003e\n    \u003cdiv class=\"copyright-author-year\"\u003e\n      \u003cspan\u003eCopyright © 2017-2024 \u003ca href=\"/\"\u003e范叶亮 | Leo Van\u003c/a\u003e\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003c/footer\u003e\n  \u003c/article\u003e",
  "Date": "2021-04-03T00:00:00Z",
  "Author": "范叶亮"
}