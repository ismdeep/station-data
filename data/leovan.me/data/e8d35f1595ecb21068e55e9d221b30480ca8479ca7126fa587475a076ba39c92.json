{
  "Source": "leovan.me",
  "Title": "网络算法 (Network Algorithms)",
  "Link": "https://leovan.me/cn/2020/12/network-algorithms/",
  "Content": "\u003carticle class=\"main\"\u003e\n    \u003cheader class=\"content-title\"\u003e\n    \n\u003ch1 class=\"title\"\u003e\n  \n  网络算法 (Network Algorithms)\n  \n\u003c/h1\u003e\n\u003ch2 class=\"subtitle\"\u003e复杂网络系列\u003c/h2\u003e\n\n\n\n\n\n\n\u003ch2 class=\"author-date\"\u003e范叶亮 / \n2020-12-12\u003c/h2\u003e\n\n\n\n\u003ch3 class=\"post-meta\"\u003e\n\n\n\u003cstrong\u003e分类: \u003c/strong\u003e\n\u003ca href=\"/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\"\u003e机器学习\u003c/a\u003e, \u003ca href=\"/categories/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C\"\u003e复杂网络\u003c/a\u003e\n\n\n\n\n/\n\n\n\n\n\u003cstrong\u003e标签: \u003c/strong\u003e\n\u003cspan\u003e复杂网络\u003c/span\u003e, \u003cspan\u003e搜索算法\u003c/span\u003e, \u003cspan\u003e最短路径\u003c/span\u003e, \u003cspan\u003eShortest Path\u003c/span\u003e, \u003cspan\u003e广度优先搜索\u003c/span\u003e, \u003cspan\u003eBreadth-First Search\u003c/span\u003e, \u003cspan\u003eBFS\u003c/span\u003e, \u003cspan\u003e最短路径树\u003c/span\u003e, \u003cspan\u003eShortest Path Tree\u003c/span\u003e, \u003cspan\u003eDijkstra\u003c/span\u003e, \u003cspan\u003eFloyd-Warshall\u003c/span\u003e, \u003cspan\u003e边独立\u003c/span\u003e, \u003cspan\u003e顶点独立\u003c/span\u003e, \u003cspan\u003e边连通度\u003c/span\u003e, \u003cspan\u003e顶点连通度\u003c/span\u003e, \u003cspan\u003e最大流\u003c/span\u003e, \u003cspan\u003e增广路径算法\u003c/span\u003e, \u003cspan\u003eFord-Fulkerson Algorithm\u003c/span\u003e, \u003cspan\u003eFFA\u003c/span\u003e, \u003cspan\u003e剩余图\u003c/span\u003e, \u003cspan\u003eResidual Graph\u003c/span\u003e, \u003cspan\u003e最小割\u003c/span\u003e, \u003cspan\u003e图划分\u003c/span\u003e, \u003cspan\u003e图对分\u003c/span\u003e, \u003cspan\u003e割集规模\u003c/span\u003e, \u003cspan\u003eKernighan-Lin 算法\u003c/span\u003e, \u003cspan\u003e谱划分\u003c/span\u003e, \u003cspan\u003e代数连通度\u003c/span\u003e, \u003cspan\u003e社区发现\u003c/span\u003e, \u003cspan\u003e社团发现\u003c/span\u003e, \u003cspan\u003e社群发现\u003c/span\u003e, \u003cspan\u003eCommunity Detection\u003c/span\u003e, \u003cspan\u003e拉普拉斯算子\u003c/span\u003e, \u003cspan\u003eLaplace Operator\u003c/span\u003e, \u003cspan\u003eLaplacian\u003c/span\u003e, \u003cspan\u003e梯度\u003c/span\u003e, \u003cspan\u003eGradient\u003c/span\u003e, \u003cspan\u003e散度\u003c/span\u003e, \u003cspan\u003eDiveragence\u003c/span\u003e, \u003cspan\u003e拉普拉斯矩阵\u003c/span\u003e, \u003cspan\u003eLaplacian Matrix\u003c/span\u003e, \u003cspan\u003e调和矩阵\u003c/span\u003e, \u003cspan\u003eHarmonic Matrix\u003c/span\u003e, \u003cspan\u003eFast Unfolding\u003c/span\u003e, \u003cspan\u003eLouvain\u003c/span\u003e, \u003cspan\u003e标签传播算法\u003c/span\u003e, \u003cspan\u003eLabel Propagation Algorithm\u003c/span\u003e, \u003cspan\u003eLPA\u003c/span\u003e\n\n\n\n\n/\n\n\n\u003cstrong\u003e字数: \u003c/strong\u003e\n6093\n\u003c/h3\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n    \n    \n    \u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"1261604535\"\u003e\u003c/ins\u003e\n    \u003cscript\u003e\n    (adsbygoogle = window.adsbygoogle || []).push({});\n    \u003c/script\u003e\n    \n    \n    \u003c/header\u003e\n\n\n\n\u003cdiv class=\"toc-depth-3\"\u003e\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#网络基础算法\"\u003e网络基础算法\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#最短路径\"\u003e最短路径\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#最大流和最小割\"\u003e最大流和最小割\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#图划分和社团发现\"\u003e图划分和社团发现\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#图划分\"\u003e图划分\u003c/a\u003e\n          \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"#kernighan-lin-算法\"\u003eKernighan-Lin 算法\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#谱划分\"\u003e谱划分\u003c/a\u003e\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#社团发现\"\u003e社团发现\u003c/a\u003e\n          \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"#fast-unfolding-louvain\"\u003eFast Unfolding (Louvain)\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#label-propagation-algorithm-lpa\"\u003eLabel Propagation Algorithm (LPA)\u003c/a\u003e\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#附录\"\u003e附录\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#开放资源\"\u003e开放资源\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#常用网络算法包\"\u003e常用网络算法包\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#常用网络可视化软件\"\u003e常用网络可视化软件\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\u003c/div\u003e\n\n\n\u003cblockquote\u003e\n\u003cp\u003e本文为\u003ca href=\"/categories/%E5%A4%8D%E6%9D%82%E7%BD%91%E7%BB%9C/\"\u003e《复杂网络系列》\u003c/a\u003e文章\u003cbr/\u003e\n本文内容主要参考自：《网络科学引论》\u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"网络基础算法\"\u003e网络基础算法\u003c/h1\u003e\n\u003ch2 id=\"最短路径\"\u003e最短路径\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e最短路径\u003c/strong\u003e（shortest path）算法是寻找两个顶点之间的最短路径，寻找网络中最短路径的标准算法称为\u003cstrong\u003e广度优先搜索\u003c/strong\u003e（breadth-first search）。算法的基本思想如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/bfs.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e根据广度优先搜索的基本思想，不难证明距 \u003ccode\u003e$s$\u003c/code\u003e 最短距离为 \u003ccode\u003e$d$\u003c/code\u003e 的每个顶点都有一个到 \u003ccode\u003e$s$\u003c/code\u003e 的最短距离为 \u003ccode\u003e$d - 1$\u003c/code\u003e 的邻居顶点。一个简单的实现方式是，创建一个有 \u003ccode\u003e$n$\u003c/code\u003e 个元素的数组存储从源顶点 \u003ccode\u003e$s$\u003c/code\u003e 到其他所有顶点的距离，同时创建一个距离变量 \u003ccode\u003e$d$\u003c/code\u003e 来记录当前在搜索过程中所处的层数，算法的具体流程如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e遍历距离数组，查找到 \u003ccode\u003e$s$\u003c/code\u003e 的距离为 \u003ccode\u003e$d$\u003c/code\u003e 的所有顶点。\u003c/li\u003e\n\u003cli\u003e查找上述顶点的所有邻居顶点，如果同 \u003ccode\u003e$s$\u003c/code\u003e 的距离未知，则距离置为 \u003ccode\u003e$d + 1$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e如果距离未知的邻居顶点数量为零，则停止算法，否则将 \u003ccode\u003e$d$\u003c/code\u003e 的值加一并重复上述过程。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这种方法在最坏的情况下时间复杂度为 \u003ccode\u003e$O \\left(m + n^2\\right)$\u003c/code\u003e，考虑多数网络的直径只随 \u003ccode\u003e$\\log n$\u003c/code\u003e 增长，算法运行的时间复杂度为 \u003ccode\u003e$O \\left(m + n \\log n\\right)$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e上述算法中步骤 1 是最耗时的部分，通过使用\u003cstrong\u003e队列\u003c/strong\u003e的数据结构我们可以避免每次都遍历列表来找到距离源顶点 \u003ccode\u003e$s$\u003c/code\u003e 距离为 \u003ccode\u003e$d$\u003c/code\u003e 的顶点。构造一个队列，一个指针指向下一个要读取的元素，另一个指针指向要填充的空位，这样距离为 \u003ccode\u003e$d + 1$\u003c/code\u003e 的顶点就会紧跟在距离为 \u003ccode\u003e$d$\u003c/code\u003e 的顶点后面，队列如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/bfs-queue.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e通过队列可以将算法的时间复杂度降至 \u003ccode\u003e$O \\left(m + n\\right)$\u003c/code\u003e，对于 \u003ccode\u003e$m \\propto n$\u003c/code\u003e 的稀疏网络而言，\u003ccode\u003e$O \\left(m + n\\right)$\u003c/code\u003e 相当于 \u003ccode\u003e$O \\left(n\\right)$\u003c/code\u003e，所以算法的时间复杂度同顶点数量成正比。\u003c/p\u003e\n\u003cp\u003e通过对算法进行进一步修改则可以得到源顶点 \u003ccode\u003e$s$\u003c/code\u003e 到其他任何顶点的最短路径。方法是在原来的网络上构建一个新的有向网络，该网络代表最短路径，称为\u003cstrong\u003e最短路径树\u003c/strong\u003e（shortest path tree），通常情况下，该网络是一个有向非循环网络，而不是树。\u003c/p\u003e\n\u003cp\u003e对于加权网络，利用广度优先搜索无法找到最短路径，这里需要用到 Dijkstra 算法 \u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e 进行求解。算法将图中的顶点分成两组 \u003ccode\u003e$S$\u003c/code\u003e 和 \u003ccode\u003e$U$\u003c/code\u003e，整个算法过程如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e初始状态，\u003ccode\u003e$S$\u003c/code\u003e 仅包含源顶点，即 \u003ccode\u003e$S = \\left\\{v\\right\\}$\u003c/code\u003e，\u003ccode\u003e$U$\u003c/code\u003e 包含其余顶点。如果 \u003ccode\u003e$v$\u003c/code\u003e 与 \u003ccode\u003e$U$\u003c/code\u003e 中的顶点 \u003ccode\u003e$u$\u003c/code\u003e 为邻居，则距离为边的权重，否则为无穷大。\u003c/li\u003e\n\u003cli\u003e从 \u003ccode\u003e$U$\u003c/code\u003e 中选择一个距离 \u003ccode\u003e$v$\u003c/code\u003e 最短的顶点 \u003ccode\u003e$k$\u003c/code\u003e，并把 \u003ccode\u003e$k$\u003c/code\u003e 加入到 \u003ccode\u003e$S$\u003c/code\u003e 中。\u003c/li\u003e\n\u003cli\u003e若从源点 \u003ccode\u003e$v$\u003c/code\u003e 经过顶点 \u003ccode\u003e$k$\u003c/code\u003e 到达 \u003ccode\u003e$u$\u003c/code\u003e 的距离比之前 \u003ccode\u003e$v$\u003c/code\u003e 到 \u003ccode\u003e$u$\u003c/code\u003e 的距离短，则将距离修改为这个更短的距离。\u003c/li\u003e\n\u003cli\u003e重复步骤 2 和 3，直至所有顶点都包含在 \u003ccode\u003e$S$\u003c/code\u003e 中。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e整个算法过程的可视化效果如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/dijkstras-progress.gif\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003eDijkstra 算法的时间复杂度为 \u003ccode\u003e$O \\left(m + n^2\\right)$\u003c/code\u003e，通过二叉堆的数据结构可以将时间复杂度优化至 \u003ccode\u003e$O \\left(\\left(m + n\\right) \\log n\\right)$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003eDijkstra 算法虽然能够处理加权网络，但不能处理存在负权重的网络，需要利用 Floyd-Warshall 算法 \u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e 进行求解。更多 Floyd-Warshall 算法的细节请参见之前的博客\u003ca href=\"/cn/2018/11/computational-complexity-and-dynamic-programming/\"\u003e计算复杂性 (Computational Complexity) 与动态规划 (Dynamic Programming)\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"最大流和最小割\"\u003e最大流和最小割\u003c/h2\u003e\n\u003cp\u003e对于连接给定顶点 \u003ccode\u003e$s$\u003c/code\u003e 和 \u003ccode\u003e$t$\u003c/code\u003e 的两条路径，若没有共享边，则这两条路径是\u003cstrong\u003e边独立\u003c/strong\u003e的；若除 \u003ccode\u003e$s$\u003c/code\u003e 和 \u003ccode\u003e$t$\u003c/code\u003e 外不共享任何其他顶点，则这两条路径是\u003cstrong\u003e顶点独立\u003c/strong\u003e的。顶点之间的\u003cstrong\u003e边连通度\u003c/strong\u003e和\u003cstrong\u003e顶点连通度\u003c/strong\u003e分别是顶点之间边独立路径数和顶点独立路径数。连通度是度量顶点之间连通鲁棒性的简单参数。假设一个网络是一个管线网络，其中每个管线的容量均为单位流量，那么边连通度等于从 \u003ccode\u003e$s$\u003c/code\u003e 流向 \u003ccode\u003e$t$\u003c/code\u003e 的\u003cstrong\u003e最大流\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e增广路径算法\u003c/strong\u003e（Ford-Fulkerson Algorithm，FFA）是计算最大流最简单的算法。基本思想是：首先利用广度优先搜索算法找到一条从源 \u003ccode\u003e$s$\u003c/code\u003e 到目标 \u003ccode\u003e$t$\u003c/code\u003e 的路径。该步骤“消耗”了网络中的一些边，将这些边的容量填充满后，它们不再承载更多流量。之后在剩余边中找到从 \u003ccode\u003e$s$\u003c/code\u003e 到 \u003ccode\u003e$t$\u003c/code\u003e 的另一条路径，重复该过程直到找不到更多的路径为止。\u003c/p\u003e\n\u003cp\u003e但这还不是一个有效的算法，如下图中的 (a) 所示，如果在 \u003ccode\u003e$s$\u003c/code\u003e 和 \u003ccode\u003e$t$\u003c/code\u003e 之间运用广度优先搜索，可以发现黑色标记的路径。一旦这些边的容量被填充满，就不能在剩余边中找到从 \u003ccode\u003e$s$\u003c/code\u003e 到 \u003ccode\u003e$t$\u003c/code\u003e 的更多路径，但很明显，从 \u003ccode\u003e$s$\u003c/code\u003e 到 \u003ccode\u003e$t$\u003c/code\u003e 有两条边独立路径（上下各一条）。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/augmenting-path-algorithm.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e解决该问题的一个简单修正方法是允许网络流量在一条边中能够同时在两个方向流动。更一般地，因为一条边容许承载的最大流是在任意方向的单位流量，那么一条边可以有多个单位流量，只要保证他们能够相互抵消，并且最终每条边承载不超过一个单位流量。\u003c/p\u003e\n\u003cp\u003e增广路径算法的实现利用了\u003cstrong\u003e剩余图\u003c/strong\u003e（residual graph），这是一个有向网络，该网络中的有向边连接原网络中相应的顶点对，并在指定方向承载一个或多个单位流量。例如上图中 (c) 和 (d) 就是对应 (a) 和 (b) 的流量状态的剩余图。算法的正确性在这里就不过多展开说明，该算法在计算两个顶点之间的最大流的平均时间复杂度为 \u003ccode\u003e$O \\left(\\left(m + n\\right) m / n\\right)$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e在图论中，去掉其中所有边使一张网络不再连通的边集为图的\u003cstrong\u003e割\u003c/strong\u003e，一张图上最小的割为\u003cstrong\u003e最小割\u003c/strong\u003e。通过对增广路径算法进行改动即可以寻找到边独立路径、最小边割集和顶点独立路径。\u003c/p\u003e\n\u003ch1 id=\"图划分和社团发现\"\u003e图划分和社团发现\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e图划分\u003c/strong\u003e（graph partitioning）和\u003cstrong\u003e社团发现\u003c/strong\u003e（community detection）都是指根据网络中的边的连接模式，把网络顶点划分成群组、簇或社团。将网络顶点划分成群组后最常见的属性是，同一群组内部的顶点之间通过边紧密连接，而不同群组之间只有少数边。\u003c/p\u003e\n\u003ch2 id=\"图划分\"\u003e图划分\u003c/h2\u003e\n\u003cp\u003e最简单的图划分问题是把网络划分成两部分，有时也称其为\u003cstrong\u003e图对分\u003c/strong\u003e（graph bisection）。图对分是把一个网络中的顶点划分成为两个指定规模的非重叠群组，使得不同群组之间相互连接的边数最小。群组之间的边数称为\u003cstrong\u003e割集规模\u003c/strong\u003e（cut size）。 利用穷举搜索解决该问题是极为耗时的，通过启发式算法我们可以找到较好的网络划分。\u003c/p\u003e\n\u003ch3 id=\"kernighan-lin-算法\"\u003eKernighan-Lin 算法\u003c/h3\u003e\n\u003cp\u003eKernighan-Lin 算法是由 Brian Kernighan 和 Shen Lin 在 1970 年提出的 \u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e，是图对分问题中最简单、最知名的启发式算法之一，如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/kernighan%E2%80%93lin-algorithm.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e先以任意方式将网络顶点按指定规模划分成两个群组，对于任何由分属不同群组的顶点 \u003ccode\u003e$i$\u003c/code\u003e 和顶点 \u003ccode\u003e$j$\u003c/code\u003e 组成的顶点对 \u003ccode\u003e$\\left(i, j\\right)$\u003c/code\u003e，交换 \u003ccode\u003e$i$\u003c/code\u003e 和 \u003ccode\u003e$j$\u003c/code\u003e 的位置，并计算交换前后两个群组之间割集规模的变化量。在所有顶点对中找到使割集规模减小最多的顶点对，或者若没有使割集规模减小的顶点对，则找到使割集规模增加最小的顶点对，交换这两个顶点。重复这个过程，同时保证网络中的每个顶点只能移动一次。\u003c/p\u003e\n\u003cp\u003e继续算法，每一步都交换最大程度减少或最小程度增加群组之间边数的顶点对，直到没有可以变换的顶点对，此时本轮算法停止。在完成所有交换后，检查网络在此过程中经过的每一个状态，然后选择割集规模最小的状态。最后，重复执行上述整个过程，每次始于上次发现的最优网络划分，直到割集规模不在出现改善。\u003c/p\u003e\n\u003cp\u003eKernighan-Lin 算法的主要缺点是运算速度缓慢，采用一些技巧来改善算法也只能使时间复杂度降至 \u003ccode\u003e$O \\left(n^3\\right)$\u003c/code\u003e，因此该算法仅适用于有几百或几千个顶点的网络，而不适用于更大规模的网络。\u003c/p\u003e\n\u003ch3 id=\"谱划分\"\u003e谱划分\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e请先了解\u003ca href=\"#%E9%99%84%E5%BD%95\"\u003e附录\u003c/a\u003e中的拉普拉斯算子和拉普拉斯矩阵等相关概念。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e考虑具有 \u003ccode\u003e$n$\u003c/code\u003e 个顶点 \u003ccode\u003e$m$\u003c/code\u003e 条边的网络，将其划分为两个群组，称为群组 1 和群组 2。可以把该划分的割集规模，也就是两个群组之间的边数表示为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\label{eq:r_1} R = \\dfrac{1}{2} \\sum_{i, j \\text{ 属于不同群组}} A_{ij} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于每个网络划分，定义有参数 \u003ccode\u003e$s_i$\u003c/code\u003e 组成的集合，集合中每个元素对应于一个顶点 \u003ccode\u003e$i$\u003c/code\u003e，则有：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ s_i = \\left\\{\\begin{array}{ll} +1 \u0026amp; \\text{顶点 } i \\text{ 在群组 1 中} \\\\ -1 \u0026amp; \\text{顶点 } i \\text{ 在群组 2 中} \\end{array}\\right. $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e那么：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\dfrac{1}{2} \\left(1 - s_i s_j\\right) = \\left\\{\\begin{array}{ll} 1 \u0026amp; \\text{顶点 } i \\text{ 和 } j \\text{ 在不同的群组中} \\\\ 0 \u0026amp; \\text{顶点 } i \\text{ 和 } j \\text{ 在相同的群组中} \\end{array}\\right. $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e则式 \\ref{eq:r_1} 可以改写为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} R \u0026amp; = \\dfrac{1}{4} \\sum_{ij} A_{ij} \\left(1 - s_i s_j\\right) \\\\ \u0026amp; = \\dfrac{1}{4} \\left(k_i \\delta_{ij} - A_{ij}\\right) s_i s_j \\\\ \u0026amp; = \\dfrac{1}{4} \\sum_{ij} L_{ij} s_i s_j \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e$\\delta_{ij}$\u003c/code\u003e 是克罗内克函数，\u003ccode\u003e$L_{ij}$\u003c/code\u003e 是图拉普拉斯矩阵的第 \u003ccode\u003e$ij$\u003c/code\u003e 个元素。写成矩阵的形式有：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ R = \\dfrac{1}{4} \\mathbf{s}^{\\top} \\mathbf{L} \\mathbf{s} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e由于每个 \u003ccode\u003e$s_i$\u003c/code\u003e 的取值只能是 \u003ccode\u003e$\\left\\{+1, -1\\right\\}$\u003c/code\u003e，所以在给定 \u003ccode\u003e$\\mathbf{L}$\u003c/code\u003e 时求解 \u003ccode\u003e$\\mathbf{s}$\u003c/code\u003e 使其割集规模最小时并不容易。具体求解方法的推导在此不再展开说明，最终谱划分算法的过程如下所示：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e计算图拉普拉斯矩阵的第二小特征值 \u003ccode\u003e$\\lambda_2$\u003c/code\u003e，称为网络的\u003cstrong\u003e代数连通度\u003c/strong\u003e（algebraic connectivity），及其对应的特征向量 \u003ccode\u003e$\\mathbf{v}_2$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e按从大到小的顺序对特征向量的元素进行排序。\u003c/li\u003e\n\u003cli\u003e把前 \u003ccode\u003e$n_1$\u003c/code\u003e 个最大元素对应的顶点放入群组 1，其余放入群组 2，计算割集规模。\u003c/li\u003e\n\u003cli\u003e把前 \u003ccode\u003e$n_1$\u003c/code\u003e 个最小（注意：中文译本中有错误）元素对应的顶点放入群组 2，其余放入群组 1，并重新计算割集规模。\u003c/li\u003e\n\u003cli\u003e在两种网络划分中，选择割集规模较小的那个划分。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e谱划分方法在稀疏网络上的时间复杂度为 \u003ccode\u003e$O \\left(n^2\\right)$\u003c/code\u003e，这比 Kernighan-Lin 算法时间复杂度少了一个因子 \u003ccode\u003e$n$\u003c/code\u003e，从而使该算法能应用于更大规模的网络。\u003c/p\u003e\n\u003ch2 id=\"社团发现\"\u003e社团发现\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e社团发现\u003c/strong\u003e（社区发现，社群发现，Community Detection）的基本目的与图划分类似，即把网络分成几个节点点群组，并使节点群组之间的连接较少。主要的差别就是群组的数量和规模是不确定的。社团发现的算法分类和具体实现很多，本文仅介绍几个常用的算法，更多方法及其细节请参见如下开放资源：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eCommunity Detection in Graphs \u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003eDeep Learning for Community Detection: Progress, Challenges and Opportunities \u003csup id=\"fnref:6\"\u003e\u003ca href=\"#fn:6\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e6\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e复杂网络社团发现算法研究新进展 \u003csup id=\"fnref:7\"\u003e\u003ca href=\"#fn:7\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e7\u003c/a\u003e\u003c/sup\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/benedekrozemberczki/awesome-community-detection\"\u003ebenedekrozemberczki/awesome-community-detection\u003c/a\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"fast-unfolding-louvain\"\u003eFast Unfolding (Louvain)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003eFast Unfolding (Louvain)\u003c/strong\u003e \u003csup id=\"fnref:8\"\u003e\u003ca href=\"#fn:8\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e8\u003c/a\u003e\u003c/sup\u003e 是一种基于模块度的社团发现算法，通过模块度来衡量一个社团的紧密程度。算法包含两个阶段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e历遍网络中所有的节点，通过比较将节点给每个邻居社团带来的模块度变化，将这个节点加入到使模块度增加最大的社团中。\u003c/li\u003e\n\u003cli\u003e对于步骤 1 的结果，将属于同一个社团的节点合并成为一个大的节点，进而重型构造网络。新的节点之间边的权重是所包含的之前所有节点之间相连的边权重之和，然后重复步骤 1。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e算法的两个步骤如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/louvain.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"label-propagation-algorithm-lpa\"\u003eLabel Propagation Algorithm (LPA)\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e标签传播算法\u003c/strong\u003e（Label Propagation Algorithm，LPA）是一种基于半监督学习的社团发现算法。对于每个节点都有对应的标签（即节点所隶属的社团），在算法迭代过程中，节点根据其邻居节点更新自身的标签。更新的规则是选择邻居节点中最多的标签作为自身的标签。\u003c/p\u003e\n\u003cp\u003e标签传播的过程中，节点的标签更新方式分为\u003cstrong\u003e同步更新\u003c/strong\u003e和\u003cstrong\u003e异步更新\u003c/strong\u003e两种方式。同步更新是指对于节点 \u003ccode\u003e$x$\u003c/code\u003e，在第 \u003ccode\u003e$t$\u003c/code\u003e 步时，根据其所有邻居节点在 \u003ccode\u003e$t - 1$\u003c/code\u003e 步时的标签对其进行更新，即：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ C_{x}(t)=f\\left(C_{x_{1}}(t-1), C_{x_{2}}(t-1), \\cdots, C_{x_{k}}(t-1)\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e同步更新对于一个二分或者近似二分的网络来说可能会出现标签震荡的现象。对于异步更新方式，更新公式为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ C_{x}(t)=f\\left(C_{x_{i 1}}(t), \\cdots, C_{x_{i m}}(t), C_{x_{i(m+1)}}(t-1), \\cdots, C_{x_{i k}}(t-1)\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，邻居节点 \u003ccode\u003e$x_{i1}, \\cdots, x_{im}$\u003c/code\u003e 的标签在第 \u003ccode\u003e$t$\u003c/code\u003e 步时已经更新过，而 \u003ccode\u003e$x_{i(m+1)}, \\cdots, x_{ik}$\u003c/code\u003e 的标签还未更新。\u003c/p\u003e\n\u003ch1 id=\"附录\"\u003e附录\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e拉普拉斯算子\u003c/strong\u003e（Laplace operator，Laplacian）是由欧式空间中的一个函数的梯度的散度给出的微分算子，通常写作 \u003ccode\u003e$\\Delta$\u003c/code\u003e，\u003ccode\u003e$\\nabla^2$\u003c/code\u003e 或 \u003ccode\u003e$\\nabla \\cdot \\nabla$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e梯度\u003c/strong\u003e（gradient）是对多元导数的概括，函数沿着梯度的方向变化最快，变化率则为梯度的模。假设二元函数 \u003ccode\u003e$f \\left(x, y\\right)$\u003c/code\u003e 在区域 \u003ccode\u003e$G$\u003c/code\u003e 内具有一阶连续偏导数，点 \u003ccode\u003e$P \\left(x, y\\right) \\in G$\u003c/code\u003e，则称向量：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\nabla f = \\left(\\dfrac{\\partial f}{\\partial x}, \\dfrac{\\partial f}{\\partial y} \\right) = \\dfrac{\\partial f}{\\partial x} \\mathbf{i} + \\dfrac{\\partial f}{\\partial y} \\mathbf{j} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e为函数 \u003ccode\u003e$f$\u003c/code\u003e 在点 \u003ccode\u003e$P$\u003c/code\u003e 处的梯度，其中 \u003ccode\u003e$\\mathbf{i}$\u003c/code\u003e 和 \u003ccode\u003e$\\mathbf{j}$\u003c/code\u003e 为单位向量，分别指向 \u003ccode\u003e$x$\u003c/code\u003e 和 \u003ccode\u003e$y$\u003c/code\u003e 坐标方向。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e散度\u003c/strong\u003e（divergence）将向量空间上的一个向量场对应到一个标量场上，记为 \u003ccode\u003e$\\nabla \\cdot$\u003c/code\u003e。散度的意义是场的有源性，当 \u003ccode\u003e$\\nabla \\cdot F \u0026gt; 0$\u003c/code\u003e 时，表示该点是发源点；当 \u003ccode\u003e$\\nabla \\cdot F \u0026lt; 0$\u003c/code\u003e 时，表示该点是汇聚点；当 \u003ccode\u003e$\\nabla \\cdot F = 0$\u003c/code\u003e 时，表示该点无源，如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/divergence.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e拉普拉斯离散化后即为\u003cstrong\u003e拉普拉斯矩阵\u003c/strong\u003e（laplacian matrix），也称为\u003cstrong\u003e调和矩阵\u003c/strong\u003e（harmonic matrix）。离散化的拉普拉斯算子形式如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} \\Delta f \u0026amp; = \\dfrac{\\partial^2 f}{\\partial x^2} + \\dfrac{\\partial^2 f}{\\partial y^2} \\\\ \u0026amp; = f \\left(x + 1, y\\right) + f \\left(x - 1, y\\right) - 2 f \\left(x, y\\right) + f \\left(x, y + 1\\right) + f \\left(x, y - 1\\right) - 2 f \\left(x, y\\right) \\\\ \u0026amp; = f \\left(x + 1, y\\right) + f \\left(x - 1, y\\right) + f \\left(x, y + 1\\right) + f \\left(x, y - 1\\right) - 4 f \\left(x, y\\right) \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e从上述离散化后的拉普拉斯算子形式可以看出，拉普拉斯矩阵表示的是对矩阵进行微小扰动后获得的收益。\u003c/p\u003e\n\u003cp\u003e设图 \u003ccode\u003e$G$\u003c/code\u003e 有 \u003ccode\u003e$n$\u003c/code\u003e 个节点，节点的邻域为 \u003ccode\u003e$N$\u003c/code\u003e，图上的函数 \u003ccode\u003e$f = \\left(f_1, f_2, \\cdots, f_n\\right)$\u003c/code\u003e，其中 \u003ccode\u003e$f_i$\u003c/code\u003e 表示节点 \u003ccode\u003e$i$\u003c/code\u003e 处的函数值。对 \u003ccode\u003e$i$\u003c/code\u003e 进行扰动，其可能变为邻域内的任意一个节点 \u003ccode\u003e$j \\in N_i$\u003c/code\u003e：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\Delta f_{i}=\\sum_{j \\in N_{i}}\\left(f_{i}-f_{j}\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e设每一条边 \u003ccode\u003e$e_{ij}$\u003c/code\u003e 的权重为 \u003ccode\u003e$w_{ij}$\u003c/code\u003e，\u003ccode\u003e$w_{ij} = 0$\u003c/code\u003e 表示节点 \u003ccode\u003e$i$\u003c/code\u003e 和节点 \u003ccode\u003e$j$\u003c/code\u003e 不相邻，则有：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} \\Delta f_i \u0026amp; = \\sum_{j \\in N} w_{ij} \\left(f_i - f_j\\right) \\\\ \u0026amp; = \\sum_{j \\in N} w_{ij} f_i - \\sum_{j \\in N} w_{ij} f_i \\\\ \u0026amp; = d_i f_i - W_{i:} f  \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于所有节点有：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} \\Delta f \u0026amp; = \\left(\\begin{array}{c} \\Delta f_{1} \\\\ \\vdots \\\\ \\Delta f_{N} \\end{array}\\right)=\\left(\\begin{array}{c} d_{1} f_{1}-W_{1:} f \\\\ \\vdots \\\\ d_{N} f_{N}-W_{N:} f \\end{array}\\right) \\\\ \u0026amp; = \\left(\\begin{array}{ccc} d_{1} \u0026amp; \\cdots \u0026amp; 0 \\\\ \\vdots \u0026amp; \\ddots \u0026amp; \\vdots \\\\ 0 \u0026amp; \\cdots \u0026amp; d_{N} \\end{array}\\right) f-\\left(\\begin{array}{c} W_{1:} \\\\ \\vdots \\\\ W_{N:} \\end{array}\\right) f \\\\ \u0026amp; = diag \\left(d_i\\right) f - W f \\\\ \u0026amp; = \\left(D - W\\right) f \\\\ \u0026amp; = L f \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e令图 \u003ccode\u003e$G$\u003c/code\u003e 的邻接矩阵为 \u003ccode\u003e$W$\u003c/code\u003e，度矩阵为 \u003ccode\u003e$D$\u003c/code\u003e，从上式可知拉普拉斯矩阵 \u003ccode\u003e$L = D - W$\u003c/code\u003e，其中：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ L_{ij} = \\left\\{\\begin{array}{ll} \\deg \\left(v_i\\right) \u0026amp; \\text{如果 } i = j \\\\ -1 \u0026amp; \\text{如果 } i \\neq j \\text{ 且 } v_i \\text{ 与 } v_j \\text{ 相邻} \\\\ 0 \u0026amp; \\text{其他情况} \\end{array}\\right. $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e以下面的图为例：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2020-12-12-network-algorithms/laplacian-matrix-demo-graph.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e邻接矩阵为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\left(\\begin{array}{llllll} 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 1 \\\\ 1 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\end{array}\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e度矩阵为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\left(\\begin{array}{cccccc} 2 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 2 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{array}\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e拉普拉斯矩阵为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\left(\\begin{array}{rrrrrr} 2 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 2 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 3 \u0026amp; -1 \u0026amp; -1 \\\\ -1 \u0026amp; -1 \u0026amp; 0 \u0026amp; -1 \u0026amp; 3 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 1 \\end{array}\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003ch1 id=\"开放资源\"\u003e开放资源\u003c/h1\u003e\n\u003ch2 id=\"常用网络算法包\"\u003e常用网络算法包\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e语言\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://networkx.org/\"\u003eNetworkX\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-python\"\u003ePython\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://graph-tool.skewed.de/\"\u003egraph-tool\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-python\"\u003ePython\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://snap.stanford.edu/index.html\"\u003eSNAP\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-cpp\"\u003eC++\u003c/i\u003e, \u003ci class=\"icon icon-python\"\u003ePython\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://github.com/networkit/networkit\"\u003eNetworKit\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-cpp\"\u003eC++\u003c/i\u003e, \u003ci class=\"icon icon-python\"\u003ePython\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://igraph.org/\"\u003eigraph\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-c\"\u003eC\u003c/i\u003e, \u003ci class=\"icon icon-cpp\"\u003eC++\u003c/i\u003e, \u003ci class=\"icon icon-python\"\u003ePython\u003c/i\u003e, \u003ci class=\"icon icon-r\"\u003eR\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://github.com/JuliaGraphs/LightGraphs.jl\"\u003elightgraphs\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-julia\"\u003eJulia\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e不同扩展包之间的性能比较如下表所示 \u003csup id=\"fnref:9\"\u003e\u003ca href=\"#fn:9\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e9\u003c/a\u003e\u003c/sup\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e数据集\u003c/th\u003e\n\u003cth\u003e算法\u003c/th\u003e\n\u003cth\u003egraph-tool\u003c/th\u003e\n\u003cth\u003eigraph\u003c/th\u003e\n\u003cth\u003eLightGraphs\u003c/th\u003e\n\u003cth\u003eNetworKit\u003c/th\u003e\n\u003cth\u003eNetworkX\u003c/th\u003e\n\u003cth\u003eSNAP\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmazon\u003c/td\u003e\n\u003ctd\u003eCC\u003c/td\u003e\n\u003ctd\u003e0.08\u003c/td\u003e\n\u003ctd\u003e0.22\u003c/td\u003e\n\u003ctd\u003e0.07\u003c/td\u003e\n\u003ctd\u003e0.09\u003c/td\u003e\n\u003ctd\u003e2.22\u003c/td\u003e\n\u003ctd\u003e0.31\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmazon\u003c/td\u003e\n\u003ctd\u003ek-core\u003c/td\u003e\n\u003ctd\u003e0.08\u003c/td\u003e\n\u003ctd\u003e0.15\u003c/td\u003e\n\u003ctd\u003e0.04\u003c/td\u003e\n\u003ctd\u003e0.15\u003c/td\u003e\n\u003ctd\u003e3.63\u003c/td\u003e\n\u003ctd\u003e0.37\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmazon\u003c/td\u003e\n\u003ctd\u003eloading\u003c/td\u003e\n\u003ctd\u003e2.61\u003c/td\u003e\n\u003ctd\u003e0.57\u003c/td\u003e\n\u003ctd\u003e4.66\u003c/td\u003e\n\u003ctd\u003e0.98\u003c/td\u003e\n\u003ctd\u003e4.72\u003c/td\u003e\n\u003ctd\u003e1.61\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmazon\u003c/td\u003e\n\u003ctd\u003epage rank\u003c/td\u003e\n\u003ctd\u003e0.04\u003c/td\u003e\n\u003ctd\u003e0.57\u003c/td\u003e\n\u003ctd\u003e0.02\u003c/td\u003e\n\u003ctd\u003e0.02\u003c/td\u003e\n\u003ctd\u003e8.59\u003c/td\u003e\n\u003ctd\u003e0.58\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eAmazon\u003c/td\u003e\n\u003ctd\u003eshortest path\u003c/td\u003e\n\u003ctd\u003e0.03\u003c/td\u003e\n\u003ctd\u003e0.05\u003c/td\u003e\n\u003ctd\u003e0.01\u003c/td\u003e\n\u003ctd\u003e0.04\u003c/td\u003e\n\u003ctd\u003e1.37\u003c/td\u003e\n\u003ctd\u003e0.12\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGoogle\u003c/td\u003e\n\u003ctd\u003eCC\u003c/td\u003e\n\u003ctd\u003e0.28\u003c/td\u003e\n\u003ctd\u003e1.38\u003c/td\u003e\n\u003ctd\u003e0.29\u003c/td\u003e\n\u003ctd\u003e0.37\u003c/td\u003e\n\u003ctd\u003e7.77\u003c/td\u003e\n\u003ctd\u003e1.56\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGoogle\u003c/td\u003e\n\u003ctd\u003ek-core\u003c/td\u003e\n\u003ctd\u003e0.39\u003c/td\u003e\n\u003ctd\u003e0.92\u003c/td\u003e\n\u003ctd\u003e0.16\u003c/td\u003e\n\u003ctd\u003e0.83\u003c/td\u003e\n\u003ctd\u003e42.6\u003c/td\u003e\n\u003ctd\u003e1.31\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGoogle\u003c/td\u003e\n\u003ctd\u003eloading\u003c/td\u003e\n\u003ctd\u003e11.02\u003c/td\u003e\n\u003ctd\u003e3.87\u003c/td\u003e\n\u003ctd\u003e16.75\u003c/td\u003e\n\u003ctd\u003e4.38\u003c/td\u003e\n\u003ctd\u003e19.24\u003c/td\u003e\n\u003ctd\u003e7.56\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGoogle\u003c/td\u003e\n\u003ctd\u003epage rank\u003c/td\u003e\n\u003ctd\u003e0.36\u003c/td\u003e\n\u003ctd\u003e2.42\u003c/td\u003e\n\u003ctd\u003e0.06\u003c/td\u003e\n\u003ctd\u003e0.1\u003c/td\u003e\n\u003ctd\u003e33.5\u003c/td\u003e\n\u003ctd\u003e2.31\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eGoogle\u003c/td\u003e\n\u003ctd\u003eshortest path\u003c/td\u003e\n\u003ctd\u003e0.08\u003c/td\u003e\n\u003ctd\u003e0.41\u003c/td\u003e\n\u003ctd\u003e0.01\u003c/td\u003e\n\u003ctd\u003e0.14\u003c/td\u003e\n\u003ctd\u003e3.41\u003c/td\u003e\n\u003ctd\u003e0.26\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePokec\u003c/td\u003e\n\u003ctd\u003eCC\u003c/td\u003e\n\u003ctd\u003e1.83\u003c/td\u003e\n\u003ctd\u003e3.96\u003c/td\u003e\n\u003ctd\u003e1.5\u003c/td\u003e\n\u003ctd\u003e1.75\u003c/td\u003e\n\u003ctd\u003e61.74\u003c/td\u003e\n\u003ctd\u003e9.75\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePokec\u003c/td\u003e\n\u003ctd\u003ek-core\u003c/td\u003e\n\u003ctd\u003e3.6\u003c/td\u003e\n\u003ctd\u003e5.99\u003c/td\u003e\n\u003ctd\u003e0.95\u003c/td\u003e\n\u003ctd\u003e5.05\u003c/td\u003e\n\u003ctd\u003e296.26\u003c/td\u003e\n\u003ctd\u003e6.91\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePokec\u003c/td\u003e\n\u003ctd\u003eloading\u003c/td\u003e\n\u003ctd\u003e71.46\u003c/td\u003e\n\u003ctd\u003e25.75\u003c/td\u003e\n\u003ctd\u003e170.63\u003c/td\u003e\n\u003ctd\u003e26.77\u003c/td\u003e\n\u003ctd\u003e140.19\u003c/td\u003e\n\u003ctd\u003e52.73\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePokec\u003c/td\u003e\n\u003ctd\u003epage rank\u003c/td\u003e\n\u003ctd\u003e1.1\u003c/td\u003e\n\u003ctd\u003e23.39\u003c/td\u003e\n\u003ctd\u003e0.21\u003c/td\u003e\n\u003ctd\u003e0.24\u003c/td\u003e\n\u003ctd\u003e239.75\u003c/td\u003e\n\u003ctd\u003e8.62\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePokec\u003c/td\u003e\n\u003ctd\u003eshortest path\u003c/td\u003e\n\u003ctd\u003e0.48\u003c/td\u003e\n\u003ctd\u003e0.6\u003c/td\u003e\n\u003ctd\u003e0.05\u003c/td\u003e\n\u003ctd\u003e0.56\u003c/td\u003e\n\u003ctd\u003e5.65\u003c/td\u003e\n\u003ctd\u003e2.3\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"常用网络可视化软件\"\u003e常用网络可视化软件\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e软件\u003c/th\u003e\n\u003cth\u003e平台\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://cytoscape.org/\"\u003eCytoscape\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-windows\"\u003eWindows\u003c/i\u003e, \u003ci class=\"icon icon-macos\"\u003emacOS\u003c/i\u003e, \u003ci class=\"icon icon-linux\"\u003eLinux\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://gephi.org/\"\u003eGephi\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-windows\"\u003eWindows\u003c/i\u003e, \u003ci class=\"icon icon-macos\"\u003emacOS\u003c/i\u003e, \u003ci class=\"icon icon-linux\"\u003eLinux\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"https://tulip.labri.fr/TulipDrupal/\"\u003eTulip\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-windows\"\u003eWindows\u003c/i\u003e, \u003ci class=\"icon icon-macos\"\u003emacOS\u003c/i\u003e, \u003ci class=\"icon icon-linux\"\u003eLinux\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ca href=\"http://mrvar.fdv.uni-lj.si/pajek/\"\u003ePajek\u003c/a\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ci class=\"icon icon-windows\"\u003eWindows\u003c/i\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e不同可视化软件之间的比较如下表所示 \u003csup id=\"fnref:10\"\u003e\u003ca href=\"#fn:10\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e10\u003c/a\u003e\u003c/sup\u003e：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003eCytoscape\u003c/th\u003e\n\u003cth\u003eTulip\u003c/th\u003e\n\u003cth\u003eGephi\u003c/th\u003e\n\u003cth\u003ePajek\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eScalability\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eUser friendliness\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eVisual styles\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eEdge bundling\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e-\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eRelevance to biology\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eMemory efficiency\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eClustering\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eManual node/edge editing\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eLayouts\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eNetwork profiling\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eFile formats\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003ePlugins\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eStability\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eSpeed\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eDocumentation\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑\u003c/td\u003e\n\u003ctd\u003e⭑⭑⭑\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其中，⭑ 表示较弱、⭑⭑ 表示中等、⭑⭑⭑ 表示较好、⭑⭑⭑⭑ 表示优秀。\u003c/p\u003e\n\u003cdiv class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\"\u003e\n\u003cp\u003eNewman, M. E. J. (2014) \u003cem\u003e网络科学引论\u003c/em\u003e. 电子工业出版社. \u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/wiki/%E6%88%B4%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95\"\u003ehttps://zh.wikipedia.org/wiki/戴克斯特拉算法\u003c/a\u003e \u003ca href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\"\u003e\n\u003cp\u003e\u003ca href=\"https://zh.wikipedia.org/zh-hans/Floyd-Warshall%E7%AE%97%E6%B3%95\"\u003ehttps://zh.wikipedia.org/zh-hans/Floyd-Warshall算法\u003c/a\u003e \u003ca href=\"#fnref:3\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\"\u003e\n\u003cp\u003eKernighan, B. W., \u0026amp; Lin, S. (1970). An efficient heuristic procedure for partitioning graphs. \u003cem\u003eThe Bell system technical journal\u003c/em\u003e, 49(2), 291-307. \u003ca href=\"#fnref:4\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\"\u003e\n\u003cp\u003eFortunato, S. (2010). Community detection in graphs. \u003cem\u003ePhysics reports\u003c/em\u003e, 486(3-5), 75-174. \u003ca href=\"#fnref:5\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:6\"\u003e\n\u003cp\u003eLiu, F., Xue, S., Wu, J., Zhou, C., Hu, W., Paris, C., … \u0026amp; Yu, P. S. (2020). Deep Learning for Community Detection: Progress, Challenges and Opportunities. \u003cem\u003earXiv preprint arXiv:2005.08225\u003c/em\u003e. \u003ca href=\"#fnref:6\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:7\"\u003e\n\u003cp\u003e骆志刚, 丁凡, 蒋晓舟, \u0026amp; 石金龙. (2011). 复杂网络社团发现算法研究新进展. \u003cem\u003e国防科技大学学报\u003c/em\u003e, (1), 12. \u003ca href=\"#fnref:7\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:8\"\u003e\n\u003cp\u003eBlondel, V. D., Guillaume, J. L., Lambiotte, R., \u0026amp; Lefebvre, E. (2008). Fast unfolding of communities in large networks. \u003cem\u003eJournal of statistical mechanics: theory and experiment\u003c/em\u003e, 2008(10), P10008. \u003ca href=\"#fnref:8\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:9\"\u003e\n\u003cp\u003e\u003ca href=\"https://www.timlrx.com/2020/05/10/benchmark-of-popular-graph-network-packages-v2/\"\u003eBenchmark of popular graph/network packages v2\u003c/a\u003e \u003ca href=\"#fnref:9\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:10\"\u003e\n\u003cp\u003ePavlopoulos, G. A., Paez-Espino, D., Kyrpides, N. C., \u0026amp; Iliopoulos, I. (2017). Empirical comparison of visualization tools for larger-scale network analysis. \u003cem\u003eAdvances in bioinformatics\u003c/em\u003e, 2017. \u003ca href=\"#fnref:10\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"donate\"\u003e\n  \u003cdiv class=\"donate-header\"\u003e\u003c/div\u003e\n  \u003cdiv class=\"donate-slug\" id=\"donate-slug\"\u003enetwork-algorithms\u003c/div\u003e\n  \u003cbutton class=\"donate-button\"\u003e赞 赏\u003c/button\u003e\n  \u003cdiv class=\"donate-footer\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"donate-modal-wrapper\"\u003e\n  \u003cdiv class=\"donate-modal\"\u003e\n    \u003cdiv class=\"donate-box\"\u003e\n      \u003cdiv class=\"donate-box-content\"\u003e\n        \u003cdiv class=\"donate-box-content-inner\"\u003e\n          \u003cdiv class=\"donate-box-header\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n          \u003cdiv class=\"donate-box-body\"\u003e\n            \u003cdiv class=\"donate-box-money\"\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-2\" data-v=\"2\" data-unchecked=\"￥ 2\" data-checked=\"2 元\"\u003e￥ 2\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-5\" data-v=\"5\" data-unchecked=\"￥ 5\" data-checked=\"5 元\"\u003e￥ 5\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-10\" data-v=\"10\" data-unchecked=\"￥ 10\" data-checked=\"10 元\"\u003e￥ 10\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-50\" data-v=\"50\" data-unchecked=\"￥ 50\" data-checked=\"50 元\"\u003e￥ 50\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-100\" data-v=\"100\" data-unchecked=\"￥ 100\" data-checked=\"100 元\"\u003e￥ 100\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-custom\" data-v=\"custom\" data-unchecked=\"任意金额\" data-checked=\"任意金额\"\u003e任意金额\u003c/button\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-qrcode\" id=\"donate-box-pay-qrcode\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"donate-box-footer\"\u003e\n            \u003cdiv class=\"donate-box-pay-method donate-box-pay-method-checked\" data-v=\"wechat-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-wechat-pay\" src=\"\"/\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay-method\" data-v=\"alipay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-alipay\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"button\" class=\"donate-box-close-button\"\u003e\n      \u003csvg class=\"donate-box-close-button-icon\" fill=\"#fff\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"\u003e\u003cpath d=\"M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z\" fill-rule=\"evenodd\"\u003e\u003c/path\u003e\u003c/svg\u003e\n    \u003c/button\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cscript type=\"text/javascript\" src=\"/js/donate.js\"\u003e\u003c/script\u003e\n\n\n  \u003cfooter\u003e\n  \n\u003cnav class=\"post-nav\"\u003e\n  \u003cspan class=\"nav-prev\"\u003e← \u003ca href=\"/cn/2020/11/structure-of-real-world-network/\"\u003e真实世界网络结构 (Structure of Real-World Network)\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"nav-next\"\u003e\u003ca href=\"/cn/2021/01/network-storage-and-computing/\"\u003e图存储与计算（Network Storage \u0026amp; Computing)\u003c/a\u003e →\u003c/span\u003e\n\u003c/nav\u003e\n\n\n\n\n\u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"8302038603\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n  (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/toggle-theme.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"/js/no-highlight.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/math-code.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/heading-anchor.js\"\u003e\u003c/script\u003e\n\n\n\n\u003csection class=\"comments\"\u003e\n\u003cscript src=\"https://giscus.app/client.js\" data-repo=\"leovan/leovan.me\" data-repo-id=\"MDEwOlJlcG9zaXRvcnkxMTMxOTY0Mjc=\" data-category=\"Comments\" data-category-id=\"DIC_kwDOBr89i84CT-R7\" data-mapping=\"pathname\" data-strict=\"1\" data-reactions-enabled=\"1\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"preferred_color_scheme\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" defer=\"\"\u003e\n\u003c/script\u003e\n\u003c/section\u003e\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cscript async=\"\" src=\"/js/center-img.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/right-quote.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/external-link.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/alt-title.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/figure.js\"\u003e\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\naddBackToTop({\n  diameter: 48\n});\n\u003c/script\u003e\n\n  \u003chr/\u003e\n  \u003cdiv class=\"copyright no-border-bottom\"\u003e\n    \u003cdiv class=\"copyright-author-year\"\u003e\n      \u003cspan\u003eCopyright © 2017-2024 \u003ca href=\"/\"\u003e范叶亮 | Leo Van\u003c/a\u003e\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003c/footer\u003e\n  \u003c/article\u003e",
  "Date": "2020-12-12T00:00:00Z",
  "Author": "范叶亮"
}