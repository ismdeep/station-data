{
  "Source": "leovan.me",
  "Title": "启发式算法 (Heuristic Algorithms)",
  "Link": "https://leovan.me/cn/2019/04/heuristic-algorithms/",
  "Content": "\u003carticle class=\"main\"\u003e\n    \u003cheader class=\"content-title\"\u003e\n    \n\u003ch1 class=\"title\"\u003e\n  \n  启发式算法 (Heuristic Algorithms)\n  \n\u003c/h1\u003e\n\n\n\n\n\n\n\n\u003ch2 class=\"author-date\"\u003e范叶亮 / \n2019-04-05\u003c/h2\u003e\n\n\n\n\u003ch3 class=\"post-meta\"\u003e\n\n\n\u003cstrong\u003e分类: \u003c/strong\u003e\n\u003ca href=\"/categories/%E6%9C%80%E4%BC%98%E5%8C%96\"\u003e最优化\u003c/a\u003e\n\n\n\n\n/\n\n\n\n\n\u003cstrong\u003e标签: \u003c/strong\u003e\n\u003cspan\u003e智能优化算法\u003c/span\u003e, \u003cspan\u003eIntelligent Optimization Algorithms\u003c/span\u003e, \u003cspan\u003e启发式算法\u003c/span\u003e, \u003cspan\u003eHeuristic Algorithms\u003c/span\u003e, \u003cspan\u003e贪心算法\u003c/span\u003e, \u003cspan\u003eGreedy Algorithm\u003c/span\u003e, \u003cspan\u003e局部搜索\u003c/span\u003e, \u003cspan\u003eLocal Search\u003c/span\u003e, \u003cspan\u003e爬山算法\u003c/span\u003e, \u003cspan\u003eHill Climbing\u003c/span\u003e, \u003cspan\u003e元启发式算法\u003c/span\u003e, \u003cspan\u003eMeta-Heuristic Algorithms\u003c/span\u003e, \u003cspan\u003e禁忌搜索\u003c/span\u003e, \u003cspan\u003eTabu Search\u003c/span\u003e, \u003cspan\u003eTaboo Search\u003c/span\u003e, \u003cspan\u003eTS\u003c/span\u003e, \u003cspan\u003e模拟退火\u003c/span\u003e, \u003cspan\u003eSimulated Annealing\u003c/span\u003e, \u003cspan\u003e遗传算法\u003c/span\u003e, \u003cspan\u003eGenetic Algorithm\u003c/span\u003e, \u003cspan\u003eGA\u003c/span\u003e, \u003cspan\u003e群体智能\u003c/span\u003e, \u003cspan\u003eSwarm Intelligence\u003c/span\u003e, \u003cspan\u003e蚁群算法\u003c/span\u003e, \u003cspan\u003eAnt Colony Optimization\u003c/span\u003e, \u003cspan\u003eACO\u003c/span\u003e, \u003cspan\u003e粒子群算法\u003c/span\u003e, \u003cspan\u003eParticle Swarm Optimization\u003c/span\u003e, \u003cspan\u003ePSO\u003c/span\u003e, \u003cspan\u003e超启发式算法\u003c/span\u003e, \u003cspan\u003eHyper-Heuristic Algorithms\u003c/span\u003e\n\n\n\n\n/\n\n\n\u003cstrong\u003e字数: \u003c/strong\u003e\n5479\n\u003c/h3\u003e\n\n\n\n\u003chr/\u003e\n\n\n\n    \n    \n    \u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"1261604535\"\u003e\u003c/ins\u003e\n    \u003cscript\u003e\n    (adsbygoogle = window.adsbygoogle || []).push({});\n    \u003c/script\u003e\n    \n    \n    \u003c/header\u003e\n\n\n\n\u003cdiv class=\"toc-depth-2\"\u003e\u003cnav id=\"TableOfContents\"\u003e\n  \u003cul\u003e\n    \u003cli\u003e\u003ca href=\"#启发式算法-heuristic-algorithms\"\u003e启发式算法 (Heuristic Algorithms)\u003c/a\u003e\u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#简单启发式算法-simple-heuristic-algorithms\"\u003e简单启发式算法 (Simple Heuristic Algorithms)\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#贪心算法-greedy-algorithm\"\u003e贪心算法 (Greedy Algorithm)\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#局部搜索-local-search-和爬山算法-hill-climbing\"\u003e局部搜索 (Local Search) 和爬山算法 (Hill Climbing)\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#元启发式算法-meta-heuristic-algorithms\"\u003e元启发式算法 (Meta-Heuristic Algorithms)\u003c/a\u003e\n      \u003cul\u003e\n        \u003cli\u003e\u003ca href=\"#禁忌搜索-tabu-search\"\u003e禁忌搜索 (Tabu Search)\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#模拟退火-simulated-annealing\"\u003e模拟退火 (Simulated Annealing)\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#遗传算法-genetic-algorithm\"\u003e遗传算法 (Genetic Algorithm)\u003c/a\u003e\n          \u003cul\u003e\n            \u003cli\u003e\u003ca href=\"#初始化种群\"\u003e初始化种群\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#计算适应度\"\u003e计算适应度\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#选择\"\u003e选择\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#交叉\"\u003e交叉\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#变异\"\u003e变异\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#小结\"\u003e小结\u003c/a\u003e\u003c/li\u003e\n            \u003cli\u003e\u003ca href=\"#示例-商旅问题\"\u003e示例 - 商旅问题\u003c/a\u003e\u003c/li\u003e\n          \u003c/ul\u003e\n        \u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#蚁群算法-ant-colony-optimization-aco\"\u003e蚁群算法 (Ant Colony Optimization, ACO)\u003c/a\u003e\u003c/li\u003e\n        \u003cli\u003e\u003ca href=\"#粒子群算法-particle-swarm-optimization-pso\"\u003e粒子群算法 (Particle Swarm Optimization, PSO)\u003c/a\u003e\u003c/li\u003e\n      \u003c/ul\u003e\n    \u003c/li\u003e\n    \u003cli\u003e\u003ca href=\"#超启发式算法-hyper-heuristic-algorithms\"\u003e超启发式算法 (Hyper-Heuristic Algorithms)\u003c/a\u003e\u003c/li\u003e\n  \u003c/ul\u003e\n\u003c/nav\u003e\u003c/div\u003e\n\n\n\u003ch1 id=\"启发式算法-heuristic-algorithms\"\u003e启发式算法 (Heuristic Algorithms)\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e启发式算法 (Heuristic Algorithms)\u003c/strong\u003e 是相对于最优算法提出的。一个问题的最优算法是指求得该问题每个实例的最优解. 启发式算法可以这样定义 \u003csup id=\"fnref:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e：一个基于直观或经验构造的算法，在可接受的花费 (指计算时间、占用空间等) 下给出待解决组合优化问题每一个实例的一个可行解，该可行解与最优解的偏离程度不一定事先可以预计。\u003c/p\u003e\n\u003cp\u003e在某些情况下，特别是实际问题中，最优算法的计算时间使人无法忍受或因问题的难度使其计算时间随问题规模的增加以指数速度增加，此时只能通过启发式算法求得问题的一个可行解。\u003c/p\u003e\n\u003cp\u003e利用启发式算法进行目标优化的一些优缺点如下：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e优点\u003c/th\u003e\n\u003cth\u003e缺点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e1. 算法简单直观，易于修改 \u003cbr/\u003e2. 算法能够在可接受的时间内给出一个较优解\u003c/td\u003e\n\u003ctd\u003e1. 不能保证为全局最优解 \u003cbr/\u003e2. 算法不稳定，性能取决于具体问题和设计者经验\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e启发式算法简单的划分为如下三类：\u003cstrong\u003e简单启发式算法 (Simple Heuristic Algorithms)\u003c/strong\u003e，\u003cstrong\u003e元启发式算法 (Meta-Heuristic Algorithms)\u003c/strong\u003e 和 \u003cstrong\u003e超启发式算法 (Hyper-Heuristic Algorithms)\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/heuristic-algorithms.png\" alt=\"Heuristic-Algorithms\"/\u003e\u003c/p\u003e\n\u003ch1 id=\"简单启发式算法-simple-heuristic-algorithms\"\u003e简单启发式算法 (Simple Heuristic Algorithms)\u003c/h1\u003e\n\u003ch2 id=\"贪心算法-greedy-algorithm\"\u003e贪心算法 (Greedy Algorithm)\u003c/h2\u003e\n\u003cp\u003e贪心算法是指一种在求解问题时总是采取当前状态下最优的选择从而得到最优解的算法。贪心算法的基本步骤定义如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e确定问题的最优子结构。\u003c/li\u003e\n\u003cli\u003e设计递归解，并保证在任一阶段，最优选择之一总是贪心选择。\u003c/li\u003e\n\u003cli\u003e实现基于贪心策略的递归算法，并转换成迭代算法。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e对于利用贪心算法求解的问题需要包含如下两个重要的性质：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e最优子结构性质。当一个问题具有最优子结构性质时，可用 \u003ca href=\"/cn/2018/11/computational-complexity-and-dynamic-programming\"\u003e动态规划\u003c/a\u003e 法求解，但有时用贪心算法求解会更加的简单有效。同时并非所有具有最优子结构性质的问题都可以利用贪心算法求解。\u003c/li\u003e\n\u003cli\u003e贪心选择性质。所求问题的整体最优解可以通过一系列局部最优的选择 (即贪心选择) 来达到。这是贪心算法可行的基本要素，也是贪心算法与动态规划算法的主要区别。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e贪心算法和动态规划算法之间的差异如下表所示：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e贪心算法\u003c/th\u003e\n\u003cth\u003e动态规划\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e每个阶段可以根据选择当前状态最优解快速的做出决策\u003c/td\u003e\n\u003ctd\u003e每个阶段的选择建立在子问题的解之上\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e可以在子问题求解之前贪婪的做出选择\u003c/td\u003e\n\u003ctd\u003e子问题需先进行求解\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e自顶向下的求解\u003c/td\u003e\n\u003ctd\u003e自底向上的求解 (也可采用带备忘录的自顶向下方法)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e通常情况下简单高效\u003c/td\u003e\n\u003ctd\u003e效率可能比较低\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2 id=\"局部搜索-local-search-和爬山算法-hill-climbing\"\u003e局部搜索 (Local Search) 和爬山算法 (Hill Climbing)\u003c/h2\u003e\n\u003cp\u003e局部搜索算法基于贪婪思想，从一个候选解开始，持续地在其\u003cstrong\u003e邻域\u003c/strong\u003e中搜索，直至邻域中没有更好的解。对于一个优化问题：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\min f \\left(x\\right), x \\in \\mathbb{R}^n $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e$f \\left(x\\right)$\u003c/code\u003e 为目标函数。搜索可以理解为从一个解移动到另一个解的过程，令 \u003ccode\u003e$s \\left(x\\right)$\u003c/code\u003e 表示通过移动得到的一个解，\u003ccode\u003e$S \\left(x\\right)$\u003c/code\u003e 为从当前解出发所有可能的解的集合 (邻域)，则局部搜索算法的步骤描述如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e初始化一个可行解 \u003ccode\u003e$x$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在当前解的邻域内选择一个移动后的解 \u003ccode\u003e$s \\left(x\\right)$\u003c/code\u003e，使得 \u003ccode\u003e$f \\left(s \\left(x\\right)\\right) \u0026lt; f \\left(x\\right), s \\left(x\\right) \\in S \\left(x\\right)$\u003c/code\u003e，如果不存在这样的解，则 \u003ccode\u003e$x$\u003c/code\u003e 为最优解，算法停止。\u003c/li\u003e\n\u003cli\u003e令 \u003ccode\u003e$x = s \\left(x\\right)$\u003c/code\u003e，重复步骤 2。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e当我们的优化目标为最大化目标函数 \u003ccode\u003e$f \\left(x\\right)$\u003c/code\u003e 时，这种局部搜索算法称之为爬山算法。\u003c/p\u003e\n\u003ch1 id=\"元启发式算法-meta-heuristic-algorithms\"\u003e元启发式算法 (Meta-Heuristic Algorithms)\u003c/h1\u003e\n\u003cp\u003e元启发式算法 (Meta-Heuristic Algorithms) 是启发式算法的改进，通常使用随机搜索技巧，可以应用在非常广泛的问题上，但不能保证效率。本节部分内容参考了《智能优化方法》\u003csup id=\"fnref:2\"\u003e\u003ca href=\"#fn:2\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e2\u003c/a\u003e\u003c/sup\u003e 和《现代优化计算方法》\u003csup id=\"fnref1:1\"\u003e\u003ca href=\"#fn:1\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e1\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003ch2 id=\"禁忌搜索-tabu-search\"\u003e禁忌搜索 (Tabu Search)\u003c/h2\u003e\n\u003cp\u003e禁忌搜索 (Tabu Search) 是由 Glover \u003csup id=\"fnref:3\"\u003e\u003ca href=\"#fn:3\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e3\u003c/a\u003e\u003c/sup\u003e 提出的一种优化方法。禁忌搜索通过在解邻域内搜索更优的解的方式寻找目标的最优解，在搜索的过程中将搜索历史放入禁忌表 (Tabu List) 中从而避免重复搜索。禁忌表通过模仿人类的记忆功能，禁忌搜索因此得名。\u003c/p\u003e\n\u003cp\u003e在禁忌搜索算法中，禁忌表用于防止搜索过程出现循环，避免陷入局部最优。对于一个给定长度的禁忌表，随着新的禁忌对象的不断进入，旧的禁忌对象会逐步退出，从而可以重新被访问。禁忌表是禁忌搜索算法的核心，其功能同人类的短时记忆功能相似，因此又称之为“短期表”。\u003c/p\u003e\n\u003cp\u003e在某些特定的条件下，无论某个选择是否包含在禁忌表中，我们都接受这个选择并更新当前解和历史最优解，这个选择所满足的特定条件称之为渴望水平。\u003c/p\u003e\n\u003cp\u003e一个基本的禁忌搜索算法的步骤描述如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e给定一个初始可行解，将禁忌表设置为空。\u003c/li\u003e\n\u003cli\u003e选择候选集中的最优解，若其满足渴望水平，则更新渴望水平和当前解；否则选择未被禁忌的最优解。\u003c/li\u003e\n\u003cli\u003e更新禁忌表。\u003c/li\u003e\n\u003cli\u003e判断是否满足停止条件，如果满足，则停止算法；否则转至步骤 2。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"模拟退火-simulated-annealing\"\u003e模拟退火 (Simulated Annealing)\u003c/h2\u003e\n\u003cp\u003e模拟退火 (Simulated Annealing) 是一种通过在邻域中寻找目标值相对小的状态从而求解全局最优的算法，现代的模拟退火是由 Kirkpatrick 等人于 1983 年提出 \u003csup id=\"fnref:4\"\u003e\u003ca href=\"#fn:4\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e4\u003c/a\u003e\u003c/sup\u003e。模拟退火算法源自于对热力学中退火过程的模拟，在给定一个初始温度下，通过不断降低温度，使得算法能够在多项式时间内得到一个近似最优解。\u003c/p\u003e\n\u003cp\u003e对于一个优化问题 \u003ccode\u003e$\\min f \\left(x\\right)$\u003c/code\u003e，模拟退火算法的步骤描述如下：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e给定一个初始可行解 \u003ccode\u003e$x_0$\u003c/code\u003e，初始温度 \u003ccode\u003e$T_0$\u003c/code\u003e 和终止温度 \u003ccode\u003e$T_f$\u003c/code\u003e，令迭代计数为 \u003ccode\u003e$k$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e随机选取一个邻域解 \u003ccode\u003e$x_k$\u003c/code\u003e，计算目标函数增量 \u003ccode\u003e$\\Delta f = f \\left(x_k\\right) - f \\left(x\\right)$\u003c/code\u003e。若 \u003ccode\u003e$\\Delta f \u0026lt; 0$\u003c/code\u003e，则令 \u003ccode\u003e$x = x_k$\u003c/code\u003e；否则生成随机数 \u003ccode\u003e$\\xi = U \\left(0, 1\\right)$\u003c/code\u003e，若随机数小于转移概率 \u003ccode\u003e$P \\left(\\Delta f, T\\right)$\u003c/code\u003e，则令 \u003ccode\u003e$x = x_k$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e降低温度 \u003ccode\u003e$T$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e若达到最大迭代次数 \u003ccode\u003e$k_{max}$\u003c/code\u003e 或最低温度 \u003ccode\u003e$T_f$\u003c/code\u003e，则停止算法；否则转至步骤 2。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e整个算法的伪代码如下：\u003c/p\u003e\n\n\n\u003clink rel=\"stylesheet\" type=\"text/css\" href=\"//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css\"/\u003e\n\n\n\u003cdiv\u003e\u003cpre class=\"pseudocode\"\u003e\\begin{algorithm}\n\\caption{模拟退火算法}\n\\begin{algorithmic}\n\\STATE $x \\gets x_0$\n\\STATE $T \\gets T_0$\n\\STATE $k \\gets 0$\n\\WHILE{$k \\leq k_{max}$ \\AND $T \\geq T_f$}\n    \\STATE $x_k \\gets $ \\CALL{neighbor}{$s$}\n    \\STATE $\\Delta f = f \\left(x_k\\right) - f \\left(x\\right)$\n    \\IF{$\\Delta f \u0026lt; 0$ \\OR \\CALL{random}{$0, 1$} $ \\leq P \\left(\\Delta f, T\\right)$}\n        \\STATE $x \\gets x_k$\n    \\ENDIF\n    \\STATE $T \\gets $ \\CALL{cooling}{$T, k, k_{max}$}\n    \\STATE $k \\gets k + 1$\n\\ENDWHILE\n\\end{algorithmic}\n\\end{algorithm}\n\u003c/pre\u003e\u003c/div\u003e\n\n\u003cp\u003e在进行邻域搜索的过程中，当温度较高时，搜索的空间较大，反之搜索的空间较小。类似的，当 \u003ccode\u003e$\\Delta f \u0026gt; 0$\u003c/code\u003e 时，转移概率的设置也同当前温度的大小成正比。常用的降温函数有两种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003e$T_{k+1} = T_k * r$\u003c/code\u003e，其中 \u003ccode\u003e$r \\in \\left(0.95, 0.99\\right)$\u003c/code\u003e，\u003ccode\u003e$r$\u003c/code\u003e 设置的越大，温度下降越快。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$T_{k+1} = T_k - \\Delta T$\u003c/code\u003e，其中 \u003ccode\u003e$\\Delta T$\u003c/code\u003e 为每一步温度的减少量。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e初始温度和终止温度对算法的影响较大，相关参数设置的细节请参见参考文献。\u003c/p\u003e\n\u003cp\u003e模拟退火算法是对局部搜索和爬山算法的改进，我们通过如下示例对比两者之间的差异。假设目标函数如下：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ f \\left(x, y\\right) = e^{- \\left(x^2 + y^2\\right)} + 2 e^{- \\left(\\left(x - 1.7\\right)^2 + \\left(y - 1.7\\right)^2\\right)} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e优化问题定义为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\max f \\left(x, y\\right), x \\in \\left[-2, 4\\right], y \\in \\left[-2, 4\\right] $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们分别令初始解为 \u003ccode\u003e$\\left(1.5, -1.5\\right)$\u003c/code\u003e 和 \u003ccode\u003e$\\left(3.5, 0.5\\right)$\u003c/code\u003e，下图 (上) 为爬山算法的结果，下图 (下) 为模拟退火算法的结果。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/hill-climbing.png\" alt=\"Hill Climbing\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/simulated-annealing.png\" alt=\"Simulated Annealing\"/\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003cspan style=\"color:#FFF; background-color:#000;\"\u003e\u003cstrong\u003e白色\u003c/strong\u003e\u003c/span\u003e 的大点为初始解位置，\u003cspan style=\"color:#F71893;\"\u003e\u003cstrong\u003e粉色\u003c/strong\u003e\u003c/span\u003e 的大点为求解的最优解位置，颜色从白到粉描述了迭代次数。从图中不难看出，由于局部最大值的存在，从不同的初始解出发，爬山算法容易陷入局部最大值，而模拟退火算法则相对稳定。\u003c/p\u003e\n\u003ch2 id=\"遗传算法-genetic-algorithm\"\u003e遗传算法 (Genetic Algorithm)\u003c/h2\u003e\n\u003cp\u003e遗传算法 (Genetic Algorithm, GA) 是由 John Holland 提出，其学生 Goldberg 对整个算法进行了进一步完善 \u003csup id=\"fnref:5\"\u003e\u003ca href=\"#fn:5\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e5\u003c/a\u003e\u003c/sup\u003e。算法的整个思想来源于达尔文的进化论，其基本思想是根据问题的目标函数构造一个适应度函数 (Fitness Function)，对于种群中的每个个体 (即问题的一个解) 进行评估 (计算适应度)，选择，交叉和变异，通过多轮的繁殖选择适应度最好的个体作为问题的最优解。算法的整个流程如下所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-process.png\" alt=\"GA-Process\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"初始化种群\"\u003e初始化种群\u003c/h3\u003e\n\u003cp\u003e在初始化种群时，我们首先需要对每一个个体进行编码，常用的编码方式有二进制编码，实值编码 \u003csup id=\"fnref:6\"\u003e\u003ca href=\"#fn:6\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e6\u003c/a\u003e\u003c/sup\u003e，矩阵编码 \u003csup id=\"fnref:7\"\u003e\u003ca href=\"#fn:7\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e7\u003c/a\u003e\u003c/sup\u003e，树形编码等。以二进制为例 (如下不做特殊说明时均以二进制编码为例)，对于 \u003ccode\u003e$p \\in \\left\\{0, 1, \\dotsc, 100\\right\\}$\u003c/code\u003e 中 \u003ccode\u003e$p_i = 50$\u003c/code\u003e 可以表示为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ x_i = 50_{10} = 0110010_{2} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于一个具体的问题，我们需要选择合适的编码方式对问题的解进行编码，编码后的个体可以称之为一个染色体。则一个染色体可以表示为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ x = \\left(p_1, p_2, \\dotsc, p_m\\right) $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e$m$\u003c/code\u003e 为染色体的长度或编码的位数。初始化种群个体共 \u003ccode\u003e$n$\u003c/code\u003e 个，对于任意一个个体染色体的任意一位 \u003ccode\u003e$i$\u003c/code\u003e，随机生成一个随机数 \u003ccode\u003e$\\text{rand} \\in U \\left(0, 1\\right)$\u003c/code\u003e，若 \u003ccode\u003e$\\text{rand} \u0026gt; 0.5$\u003c/code\u003e，则 \u003ccode\u003e$p_i = 1$\u003c/code\u003e，否则 \u003ccode\u003e$p_i = 0$\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"计算适应度\"\u003e计算适应度\u003c/h3\u003e\n\u003cp\u003e适应度为评价个体优劣程度的函数 \u003ccode\u003e$f\\left(x\\right)$\u003c/code\u003e，通常为问题的目标函数，对最小化优化问题 \u003ccode\u003e$f\\left(x\\right) = - \\min \\sum{\\mathcal{L} \\left(\\hat{y}, y\\right)}$\u003c/code\u003e，对最大化优化问题 \u003ccode\u003e$f\\left(x\\right) = \\max \\sum{\\mathcal{L} \\left(\\hat{y}, y\\right)}$\u003c/code\u003e，其中 \u003ccode\u003e$\\mathcal{L}$\u003c/code\u003e 为损失函数。\u003c/p\u003e\n\u003ch3 id=\"选择\"\u003e选择\u003c/h3\u003e\n\u003cp\u003e对于种群中的每个个体，计算其适应度，记第 \u003ccode\u003e$i$\u003c/code\u003e 个个体的适应度为 \u003ccode\u003e$F_i = f\\left(x_i\\right)$\u003c/code\u003e。则个体在一次选择中被选中的概率为：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ P_i = \\dfrac{F_i}{\\sum_{i=1}^{n}{F_i}} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e为了保证种群的数量不变，我们需要重复 \u003ccode\u003e$n$\u003c/code\u003e 次选择过程，单次选择采用轮盘赌的方法。利用计算得到的被选中的概率计算每个个体的累积概率：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{equation} \\begin{split} CP_0 \u0026amp;= 0 \\\\ CP_i \u0026amp;= \\sum_{j=1}^{i}{P_i} \\end{split} \\end{equation} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于如下一个示例：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e指标 \\ 个体\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_1$\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_2$\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_3$\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_4$\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_5$\u003c/code\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003e$x_6$\u003c/code\u003e\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e适应度 (F)\u003c/td\u003e\n\u003ctd\u003e100\u003c/td\u003e\n\u003ctd\u003e60\u003c/td\u003e\n\u003ctd\u003e60\u003c/td\u003e\n\u003ctd\u003e40\u003c/td\u003e\n\u003ctd\u003e30\u003c/td\u003e\n\u003ctd\u003e20\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e概率 (P)\u003c/td\u003e\n\u003ctd\u003e0.322\u003c/td\u003e\n\u003ctd\u003e0.194\u003c/td\u003e\n\u003ctd\u003e0.194\u003c/td\u003e\n\u003ctd\u003e0.129\u003c/td\u003e\n\u003ctd\u003e0.097\u003c/td\u003e\n\u003ctd\u003e0.064\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e累积概率 (CP)\u003c/td\u003e\n\u003ctd\u003e0.322\u003c/td\u003e\n\u003ctd\u003e0.516\u003c/td\u003e\n\u003ctd\u003e0.71\u003c/td\u003e\n\u003ctd\u003e0.839\u003c/td\u003e\n\u003ctd\u003e0.936\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e每次选择时，随机生成 \u003ccode\u003e$\\text{rand} \\in U \\left(0, 1\\right)$\u003c/code\u003e，当 \u003ccode\u003e$CP_{i-1} \\leq \\text{rand} \\leq CP_i$\u003c/code\u003e 时，选择个体 \u003ccode\u003e$x_i$\u003c/code\u003e。选择的过程如同在下图的轮盘上安装一个指针并随机旋转，每次指针停止的位置的即为选择的个体。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-roulette-wheel.png\" alt=\"GA-Roulette-Wheel\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"交叉\"\u003e交叉\u003c/h3\u003e\n\u003cp\u003e交叉运算类似于染色体之间的交叉，常用的方法有单点交叉，多点交叉和均匀交叉等。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单点交叉：在染色体中选择一个切点，然后将其中一部分同另一个染色体的对应部分进行交换得到两个新的个体。交叉过程如下图所示：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-one-point.png\" alt=\"GA-Crossover-One-Point\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e多点交叉：在染色体中选择多个切点，对其任意两个切点之间部分以概率 \u003ccode\u003e$P_c$\u003c/code\u003e 进行交换，其中 \u003ccode\u003e$P_c$\u003c/code\u003e 为一个较大的值，例如 \u003ccode\u003e$P_m = 0.9$\u003c/code\u003e。两点交叉过程如下图所示：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-two-points.png\" alt=\"GA-Crossover-Two-Points\"/\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e均匀交叉：染色体任意对应的位置以一定的概率进行交换得到新的个体。交叉过程如下图所示：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-crossover-uniform.png\" alt=\"GA-Crossover-Uniform\"/\u003e\u003c/p\u003e\n\u003ch3 id=\"变异\"\u003e变异\u003c/h3\u003e\n\u003cp\u003e变异即对于一个染色体的任意位置的值以一定的概率 \u003ccode\u003e$P_m$\u003c/code\u003e 发生变化，对于二进制编码来说即反转该位置的值。其中  \u003ccode\u003e$P_m$\u003c/code\u003e 为一个较小的值，例如 \u003ccode\u003e$P_m = 0.05$\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"小结\"\u003e小结\u003c/h3\u003e\n\u003cp\u003e在整个遗传运算的过程中，不同的操作发挥着不同的作用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e选择：优胜劣汰，适者生存。\u003c/li\u003e\n\u003cli\u003e交叉：丰富种群，持续优化。\u003c/li\u003e\n\u003cli\u003e变异：随机扰动，避免局部最优。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e除此之外，对于基本的遗传算法还有多种优化方法，例如：精英主义，即将每一代中的最优解原封不动的复制到下一代中，这保证了最优解可以存活到整个算法结束。\u003c/p\u003e\n\u003ch3 id=\"示例-商旅问题\"\u003e示例 - 商旅问题\u003c/h3\u003e\n\u003cp\u003e以 \u003ca href=\"https://zh.wikipedia.org/zh/%E6%97%85%E8%A1%8C%E6%8E%A8%E9%94%80%E5%91%98%E9%97%AE%E9%A2%98\"\u003e商旅问题\u003c/a\u003e 为例，利用 GA 算法求解中国 34 个省会城市的商旅问题。求解代码利用了 \u003ca href=\"https://deap.readthedocs.io/en/master/\"\u003eDeap\u003c/a\u003e 库，结果可视化如下图所示：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-tsp.gif\" alt=\"GA-TSP\"/\u003e\u003c/p\u003e\n\u003cp\u003e一个更有趣的例子是利用 GA 算法，使用不同颜色和透明度的多边形的叠加表示一张图片，在线体验详见 \u003ca href=\"http://alteredqualia.com/visualization/evolve/\"\u003e这里\u003c/a\u003e，下图为不同参数下的蒙娜丽莎图片的表示情况：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/ga-mona-lisa.png\" alt=\"GA-Mona-Lisa\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"蚁群算法-ant-colony-optimization-aco\"\u003e蚁群算法 (Ant Colony Optimization, ACO)\u003c/h2\u003e\n\u003cp\u003e1991 年，意大利学者 Dorigo M. 等人在第一届欧洲人工生命会议 (ECAL) 上首次提出了蚁群算法。1996 年 Dorigo M. 等人发表的文章 “Ant system: optimization by a colony of cooperating agents” \u003csup id=\"fnref:8\"\u003e\u003ca href=\"#fn:8\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e8\u003c/a\u003e\u003c/sup\u003e 为蚁群算法奠定了基础。在自然界中，蚂蚁会分泌一种叫做信息素的化学物质，蚂蚁的许多行为受信息素的调控。蚂蚁在运动过程中能够感知其经过的路径上信息素的浓度，蚂蚁倾向朝着信息素浓度高的方向移动。以下图为例 \u003csup id=\"fnref:9\"\u003e\u003ca href=\"#fn:9\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e9\u003c/a\u003e\u003c/sup\u003e：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/aco-shortest-path.png\" alt=\"ACO Shortest Path\"/\u003e\u003c/p\u003e\n\u003cp\u003e蚂蚁从蚁巢 (N) 出发到达食物源所在地 (F)，取得食物后再折返回蚁巢。整个过程中蚂蚁有多种路径可以选择，单位时间内路径上通过蚂蚁的数量越多，则该路径上留下的信息素浓度越高。因此，最短路径上走过的蚂蚁数量越多，则后来的蚂蚁选择该路径的机率就越大，从而蚂蚁通过信息的交流实现了寻找食物和蚁巢之间最短路的目的。\u003c/p\u003e\n\u003ch2 id=\"粒子群算法-particle-swarm-optimization-pso\"\u003e粒子群算法 (Particle Swarm Optimization, PSO)\u003c/h2\u003e\n\u003cp\u003eEberhart, R. 和 Kennedy, J. 于 1995 年提出了粒子群优化算法 \u003csup id=\"fnref:10\"\u003e\u003ca href=\"#fn:10\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e10\u003c/a\u003e\u003c/sup\u003e \u003csup id=\"fnref:11\"\u003e\u003ca href=\"#fn:11\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e11\u003c/a\u003e\u003c/sup\u003e。粒子群算法模仿的是自然界中鸟群和鱼群等群体的行为，其基本原理描述如下：\u003c/p\u003e\n\u003cp\u003e一个由 \u003ccode\u003e$m$\u003c/code\u003e 个粒子 (Particle) 组成的群体 (Swarm) 在 \u003ccode\u003e$D$\u003c/code\u003e 维空间中飞行，每个粒子在搜索时，考虑自己历史搜索到的最优解和群体内 (或邻域内) 其他粒子历史搜索到的最优解，在此基础上进行位置 (状态，也就是解) 的变化。令第 \u003ccode\u003e$i$\u003c/code\u003e 个粒子的位置为 \u003ccode\u003e$x_i$\u003c/code\u003e，速度为 \u003ccode\u003e$v_i$\u003c/code\u003e，历史搜索的最优解对应的点为 \u003ccode\u003e$p_i$\u003c/code\u003e，群体内 (或邻域内) 所有粒子历史搜索到的最优解对应的点为 \u003ccode\u003e$p_g$\u003c/code\u003e，则粒子的位置和速度依据如下公式进行变化：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{equation} \\begin{split} v^{k+1}_i \u0026amp;= \\omega v^k_i + c_1 \\xi \\left(p^k_i - x^k_i\\right) + c_2 \\eta \\left(p^k_g - x^k_i\\right) \\\\ x^{k+1}_i \u0026amp;= x^k_i + v^{k+1}_i \\end{split} \\end{equation} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e$\\omega$\u003c/code\u003e 为惯性参数；\u003ccode\u003e$c_1$\u003c/code\u003e 和 \u003ccode\u003e$c_2$\u003c/code\u003e 为学习因子，其一般为正数，通常情况下等于 2；\u003ccode\u003e$\\xi, \\eta \\in U \\left[0, 1\\right]$\u003c/code\u003e。学习因子使得粒子具有自我总结和向群体中优秀个体学习的能力，从而向自己的历史最优点以及群体内或邻域内的最优点靠近。同时，粒子的速度被限制在一个最大速度 \u003ccode\u003e$V_{max}$\u003c/code\u003e 范围内。\u003c/p\u003e\n\u003cp\u003e对于 Rosenbrock 函数\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ f \\left(x, y\\right) = \\left(1 - x\\right)^2 + 100 \\left(y - x^2\\right)^2 $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e当 \u003ccode\u003e$x \\in \\left[-2, 2\\right], y \\in \\left[-1, 3\\right]$\u003c/code\u003e，定义优化问题为最小化目标函数，最优解为 \u003ccode\u003e$\\left(0, 0\\right)$\u003c/code\u003e。利用 \u003ca href=\"https://github.com/ljvmiranda921/pyswarms\"\u003ePySwarms\u003c/a\u003e 扩展包的优化过程可视化如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/rosenbrock-pso.gif\" alt=\"Rosenbrock PSO\"/\u003e\u003c/p\u003e\n\u003cp\u003e其中，\u003ccode\u003e$m = 50, \\omega = 0.8, c_1 = 0.5, c_2 = 0.3$\u003c/code\u003e，迭代次数为 200。\u003c/p\u003e\n\u003cp\u003e本节相关示例代码详见 \u003ca href=\"https://github.com/leovan/leovan.me/tree/main/static/codes/cn/2019-04-05-heuristic-algorithms/\"\u003e这里\u003c/a\u003e。\u003c/p\u003e\n\u003ch1 id=\"超启发式算法-hyper-heuristic-algorithms\"\u003e超启发式算法 (Hyper-Heuristic Algorithms)\u003c/h1\u003e\n\u003cp\u003e超启发式算法 (Hyper-Heuristic Algorithms) 提供了一种高层次启发式方法，通过管理或操纵一系列低层次启发式算法 (Low-Level Heuristics，LLH)，以产生新的启发式算法。这些新启发式算法被用于求解各类组合优化问题 \u003csup id=\"fnref:12\"\u003e\u003ca href=\"#fn:12\" class=\"footnote-ref\" role=\"doc-noteref\"\u003e12\u003c/a\u003e\u003c/sup\u003e。\u003c/p\u003e\n\u003cp\u003e下图给出了超启发式算法的概念模型。该模型分为两个层面：在问题域层面上，应用领域专家根据自己的背景知识，在智能计算专家协助下，提供一系列 LLH 和问题的定义、评估函数等信息；在高层次启发式方法层面上，智能计算专家设计高效的管理操纵机制，运用问题域所提供的 LLH 算法库和问题特征信息，构造出新的启发式算法。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/cn/2019-04-05-heuristic-algorithms/hyper-heuristic-algorithms-model.png\" alt=\"Hyper-Heuristic-Algorithms\"/\u003e\u003c/p\u003e\n\u003cdiv class=\"footnotes\" role=\"doc-endnotes\"\u003e\n\u003chr/\u003e\n\u003col\u003e\n\u003cli id=\"fn:1\"\u003e\n\u003cp\u003e邢文训, \u0026amp; 谢金星. (2005). \u003cem\u003e现代优化计算方法\u003c/em\u003e. 清华大学出版社. \u003ca href=\"#fnref:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e \u003ca href=\"#fnref1:1\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:2\"\u003e\n\u003cp\u003e汪定伟, 王俊伟, 王洪峰, 张瑞友, \u0026amp; 郭哲. (2007). \u003cem\u003e智能优化方法\u003c/em\u003e.  高等教育出版社. \u003ca href=\"#fnref:2\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:3\"\u003e\n\u003cp\u003eGlover, F. W., \u0026amp; Laguna, M. (1997). \u003cem\u003eTabu Search\u003c/em\u003e. Springer US. \u003ca href=\"#fnref:3\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:4\"\u003e\n\u003cp\u003eKirkpatrick, S., Gelatt, C. D., \u0026amp; Vecchi, M. P. (1983). Optimization by Simulated Annealing. \u003cem\u003eScience\u003c/em\u003e, 220(4598), 671–680. \u003ca href=\"#fnref:4\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:5\"\u003e\n\u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Genetic_algorithm\"\u003ehttps://en.wikipedia.org/wiki/Genetic_algorithm\u003c/a\u003e \u003ca href=\"#fnref:5\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:6\"\u003e\n\u003cp\u003eMichalewicz, Z., Janikow, C. Z., \u0026amp; Krawczyk, J. B. (1992). A modified genetic algorithm for optimal control problems. \u003cem\u003eComputers \u0026amp; Mathematics with Applications\u003c/em\u003e, 23(12), 83-94. \u003ca href=\"#fnref:6\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:7\"\u003e\n\u003cp\u003eGottlieb, J., \u0026amp; Paulmann, L. (1998, May). Genetic algorithms for the fixed charge transportation problem. In \u003cem\u003eEvolutionary Computation Proceedings, 1998. IEEE World Congress on Computational Intelligence., The 1998 IEEE International Conference on\u003c/em\u003e (pp. 330-335). IEEE. \u003ca href=\"#fnref:7\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:8\"\u003e\n\u003cp\u003eDorigo, M., Maniezzo, V., \u0026amp; Colorni, A. (1996). Ant system: optimization by a colony of cooperating agents. \u003cem\u003eIEEE Transactions on Systems, man, and cybernetics, Part B: Cybernetics\u003c/em\u003e, 26(1), 29-41. \u003ca href=\"#fnref:8\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:9\"\u003e\n\u003cp\u003eToksari, M. D. (2016). A hybrid algorithm of Ant Colony Optimization (ACO) and Iterated Local Search (ILS) for estimating electricity domestic consumption: Case of Turkey. \u003cem\u003eInternational Journal of Electrical Power \u0026amp; Energy Systems\u003c/em\u003e, 78, 776-782. \u003ca href=\"#fnref:9\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:10\"\u003e\n\u003cp\u003eEberhart, R., \u0026amp; Kennedy, J. (1995, November). Particle swarm optimization. In \u003cem\u003eProceedings of the IEEE international conference on neural networks\u003c/em\u003e (Vol. 4, pp. 1942-1948). \u003ca href=\"#fnref:10\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:11\"\u003e\n\u003cp\u003eEberhart, R., \u0026amp; Kennedy, J. (1995, October). A new optimizer using particle swarm theory. In \u003cem\u003eMHS\u0026#39;95. Proceedings of the Sixth International Symposium on Micro Machine and Human Science\u003c/em\u003e (pp. 39-43). IEEE. \u003ca href=\"#fnref:11\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"fn:12\"\u003e\n\u003cp\u003e江贺. (2011). 超启发式算法：跨领域的问题求解模式. \u003cem\u003e中国计算机学会通讯\u003c/em\u003e, 7(2), 63-70 \u003ca href=\"#fnref:12\" class=\"footnote-backref\" role=\"doc-backlink\"\u003e↩︎\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"donate\"\u003e\n  \u003cdiv class=\"donate-header\"\u003e\u003c/div\u003e\n  \u003cdiv class=\"donate-slug\" id=\"donate-slug\"\u003eheuristic-algorithms\u003c/div\u003e\n  \u003cbutton class=\"donate-button\"\u003e赞 赏\u003c/button\u003e\n  \u003cdiv class=\"donate-footer\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv class=\"donate-modal-wrapper\"\u003e\n  \u003cdiv class=\"donate-modal\"\u003e\n    \u003cdiv class=\"donate-box\"\u003e\n      \u003cdiv class=\"donate-box-content\"\u003e\n        \u003cdiv class=\"donate-box-content-inner\"\u003e\n          \u003cdiv class=\"donate-box-header\"\u003e「真诚赞赏，手留余香」\u003c/div\u003e\n          \u003cdiv class=\"donate-box-body\"\u003e\n            \u003cdiv class=\"donate-box-money\"\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-2\" data-v=\"2\" data-unchecked=\"￥ 2\" data-checked=\"2 元\"\u003e￥ 2\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-5\" data-v=\"5\" data-unchecked=\"￥ 5\" data-checked=\"5 元\"\u003e￥ 5\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-10\" data-v=\"10\" data-unchecked=\"￥ 10\" data-checked=\"10 元\"\u003e￥ 10\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-50\" data-v=\"50\" data-unchecked=\"￥ 50\" data-checked=\"50 元\"\u003e￥ 50\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-100\" data-v=\"100\" data-unchecked=\"￥ 100\" data-checked=\"100 元\"\u003e￥ 100\u003c/button\u003e\n              \u003cbutton class=\"donate-box-money-button donate-box-money-button-unchecked\" id=\"donate-box-money-button-custom\" data-v=\"custom\" data-unchecked=\"任意金额\" data-checked=\"任意金额\"\u003e任意金额\u003c/button\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-qrcode\" id=\"donate-box-pay-qrcode\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class=\"donate-box-footer\"\u003e\n            \u003cdiv class=\"donate-box-pay-method donate-box-pay-method-checked\" data-v=\"wechat-pay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-wechat-pay\" src=\"\"/\u003e\n            \u003c/div\u003e\n            \u003cdiv class=\"donate-box-pay-method\" data-v=\"alipay\"\u003e\n              \u003cimg class=\"donate-box-pay-method-image\" id=\"donate-box-pay-method-image-alipay\" src=\"\"/\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cbutton type=\"button\" class=\"donate-box-close-button\"\u003e\n      \u003csvg class=\"donate-box-close-button-icon\" fill=\"#fff\" viewBox=\"0 0 24 24\" width=\"24\" height=\"24\"\u003e\u003cpath d=\"M13.486 12l5.208-5.207a1.048 1.048 0 0 0-.006-1.483 1.046 1.046 0 0 0-1.482-.005L12 10.514 6.793 5.305a1.048 1.048 0 0 0-1.483.005 1.046 1.046 0 0 0-.005 1.483L10.514 12l-5.208 5.207a1.048 1.048 0 0 0 .006 1.483 1.046 1.046 0 0 0 1.482.005L12 13.486l5.207 5.208a1.048 1.048 0 0 0 1.483-.006 1.046 1.046 0 0 0 .005-1.482L13.486 12z\" fill-rule=\"evenodd\"\u003e\u003c/path\u003e\u003c/svg\u003e\n    \u003c/button\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cscript type=\"text/javascript\" src=\"/js/donate.js\"\u003e\u003c/script\u003e\n\n\n  \u003cfooter\u003e\n  \n\u003cnav class=\"post-nav\"\u003e\n  \u003cspan class=\"nav-prev\"\u003e← \u003ca href=\"/cn/2019/03/browser-tabs-you-do-not-close/\"\u003e关不掉的浏览器标签页 (Browser Tabs You do not Close)\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"nav-next\"\u003e\u003ca href=\"/cn/2019/07/my-childhood-in-memory/\"\u003e记忆中的儿时 (My Childhood in Memory)\u003c/a\u003e →\u003c/span\u003e\n\u003c/nav\u003e\n\n\n\n\n\u003cins class=\"adsbygoogle\" style=\"display:block; text-align:center;\" data-ad-layout=\"in-article\" data-ad-format=\"fluid\" data-ad-client=\"ca-pub-2608165017777396\" data-ad-slot=\"8302038603\"\u003e\u003c/ins\u003e\n\u003cscript\u003e\n  (adsbygoogle = window.adsbygoogle || []).push({});\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/js-cookie@3.0.5/dist/js.cookie.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/toggle-theme.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"/js/no-highlight.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/math-code.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"/js/heading-anchor.js\"\u003e\u003c/script\u003e\n\n\n\n\u003csection class=\"comments\"\u003e\n\u003cscript src=\"https://giscus.app/client.js\" data-repo=\"leovan/leovan.me\" data-repo-id=\"MDEwOlJlcG9zaXRvcnkxMTMxOTY0Mjc=\" data-category=\"Comments\" data-category-id=\"DIC_kwDOBr89i84CT-R7\" data-mapping=\"pathname\" data-strict=\"1\" data-reactions-enabled=\"1\" data-emit-metadata=\"0\" data-input-position=\"top\" data-theme=\"preferred_color_scheme\" data-lang=\"zh-CN\" data-loading=\"lazy\" crossorigin=\"anonymous\" defer=\"\"\u003e\n\u003c/script\u003e\n\u003c/section\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js\"\u003e\u003c/script\u003e\n\u003cscript src=\"//cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/toolbar/prism-toolbar.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\n  (function() {\n    if (!self.Prism) {\n      return;\n    }\n\n    \n    Prism.languages.dos = Prism.languages.powershell;\n    Prism.languages.gremlin = Prism.languages.groovy;\n\n    let languages = {\n      'r': 'R', 'python': 'Python', 'xml': 'XML', 'html': 'HTML',\n      'yaml': 'YAML', 'latex': 'LaTeX', 'tex': 'TeX',\n      'powershell': 'PowerShell', 'javascript': 'JavaScript',\n      'dos': 'DOS', 'qml': 'QML', 'json': 'JSON', 'bash': 'Bash',\n      'text': 'Text', 'txt': 'Text', 'sparql': 'SPARQL',\n      'gremlin': 'Gremlin', 'cypher': 'Cypher', 'ngql': 'nGQL',\n      'shell': 'Shell', 'sql': 'SQL', 'apacheconf': 'Apache Configuration', 'c': 'C', 'css': 'CSS'\n    };\n\n    Prism.hooks.add('before-highlight', function(env) {\n      if (env.language !== 'plain') {\n        let language = languages[env.language] || env.language;\n        env.element.setAttribute('data-language', language);\n      }\n    });\n\n    \n    let ClipboardJS = window.ClipboardJS || undefined;\n\n    Prism.plugins.toolbar.registerButton('copy-to-clipboard', function(env) {\n      let linkCopy = document.createElement('button');\n      linkCopy.classList.add('prism-button-copy');\n\n      registerClipboard();\n\n      return linkCopy;\n\n      function registerClipboard() {\n        let clip = new ClipboardJS(linkCopy, {\n          'text': function () {\n            return env.code;\n          }\n        });\n\n        clip.on('success', function() {\n          linkCopy.classList.add('prism-button-copy-success');\n          resetText();\n        });\n        clip.on('error', function () {\n          linkCopy.classList.add('prism-button-copy-error');\n          resetText();\n        });\n      }\n\n      function resetText() {\n        setTimeout(function () {\n          linkCopy.classList.remove('prism-button-copy-success');\n          linkCopy.classList.remove('prism-button-copy-error');\n        }, 1600);\n      }\n    });\n  })();\n\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js\"\u003e\u003c/script\u003e\n\u003cscript type=\"text/javascript\"\u003e\nlet pseudocodeCaptionCount = 0;\n(function(d) {\n  d.querySelectorAll(\".pseudocode\").forEach(function(elem) {\n    let pseudocode_options = {\n      indentSize: '1.2em',\n      commentDelimiter: '\\/\\/',\n      lineNumber:  true ,\n      lineNumberPunc: ':',\n      noEnd:  false \n    };\n    pseudocode_options.captionCount = pseudocodeCaptionCount;\n    pseudocodeCaptionCount += 1;\n    pseudocode.renderElement(elem, pseudocode_options);\n  });\n})(document);\n\u003c/script\u003e\n\n\n\n\n\n\n\n\n\n\n\n\u003cscript async=\"\" src=\"/js/center-img.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/right-quote.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/external-link.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/alt-title.js\"\u003e\u003c/script\u003e\n\u003cscript async=\"\" src=\"/js/figure.js\"\u003e\u003c/script\u003e\n\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js\"\u003e\u003c/script\u003e\n\n\n\u003cscript src=\"//cdn.jsdelivr.net/npm/vanilla-back-to-top@latest/dist/vanilla-back-to-top.min.js\"\u003e\u003c/script\u003e\n\u003cscript\u003e\naddBackToTop({\n  diameter: 48\n});\n\u003c/script\u003e\n\n  \u003chr/\u003e\n  \u003cdiv class=\"copyright no-border-bottom\"\u003e\n    \u003cdiv class=\"copyright-author-year\"\u003e\n      \u003cspan\u003eCopyright © 2017-2024 \u003ca href=\"/\"\u003e范叶亮 | Leo Van\u003c/a\u003e\u003c/span\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003c/footer\u003e\n  \u003c/article\u003e",
  "Date": "2019-04-05T00:00:00Z",
  "Author": "范叶亮"
}