{
  "Source": "liam.page",
  "Title": "谈谈 C++ 中流的缓冲区",
  "Link": "https://liam.page/2017/12/31/buffer-of-stream-in-Cpp/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e众所周知，C++ 语言本身并不提供 I/O 功能。C++ 的 I/O 是通过标准库中输入输出流来实现的。标准库在 \u003ccode\u003eiostream\u003c/code\u003e 头文件当中，预定义了六个流对象，他们是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eistream\u003c/code\u003e \u0026lt;- \u003ccode\u003estd::cin\u003c/code\u003e/\u003ccode\u003estd::wcin\u003c/code\u003e，对应标准输入的输入流；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eostream\u003c/code\u003e \u0026lt;- \u003ccode\u003estd::cout\u003c/code\u003e/\u003ccode\u003estd::wcout\u003c/code\u003e，对应标准输出的输出流；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eostream\u003c/code\u003e \u0026lt;- \u003ccode\u003estd::cerr\u003c/code\u003e/\u003ccode\u003estd::wcerr\u003c/code\u003e，对应标准错误的输出流。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e稍有经验的 C++ 程序员都应对这些流熟悉（至少对非宽字符版本的三个流对象熟悉），因此此篇不介绍它们的基本用法，而是讨论流的缓冲区。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"为什么要有缓冲区？\"\u003e\u003ca href=\"#为什么要有缓冲区？\" class=\"headerlink\" title=\"为什么要有缓冲区？\"\u003e\u003c/a\u003e为什么要有缓冲区？\u003c/h2\u003e\u003cp\u003e首先需要思考的问题是：为什么要有缓冲区，而不是与相关的文件/设备进行直接的读写操作。提出这个问题是很显然的。这是因为任何决定都是一种在代价和收益中的权衡。考虑到加上缓冲区是有代价的（代码变得更加复杂、需要控制的内容增多），所以加上缓冲区必然有随之而来的收益。\u003c/p\u003e\n\u003cp\u003e众所周知，相对于 CPU 的指令执行和主存访问，I/O 操作是非常慢的。这也就是说，在不考虑缓冲区的情况下，如果程序有频繁的 I/O 操作，那么相当于程序的「高速」部分就会被频繁打断。这对于程序的整体性能是不利的。有了缓冲区，程序就可以避免频繁的 I/O 操作，而是对缓冲区进行读写，只有在必须的情况下，才通过刷新缓冲区进行真实的 I/O 操作。这样一来，程序就能将多个缓慢的 I/O 操作合并成一个，从而在整体上提高了程序的性能。\u003c/p\u003e\n\u003cp\u003e因此，问题的答案是：使用缓冲区有助于提高程序的整体性能。\u003c/p\u003e\n\u003ch2 id=\"缓冲区要做哪些工作？\"\u003e\u003ca href=\"#缓冲区要做哪些工作？\" class=\"headerlink\" title=\"缓冲区要做哪些工作？\"\u003e\u003c/a\u003e缓冲区要做哪些工作？\u003c/h2\u003e\u003cp\u003e确定了必须要使用缓冲区，接下来的问题就是，这种缓冲区应该有哪些功能。\u003c/p\u003e\n\u003cp\u003e从上一节的描述中，不难发现缓冲区向上连接了程序的输入输出请求，向下连接了真实的 I/O 操作。作为中间层，必然需要分别处理好与上下两层之间的接口，以及要处理好上下两层之间的协作。（后者即是中间层本身的功能）\u003c/p\u003e\n\u003cp\u003e在 C++ 中，流的缓冲区之基类是定义在 \u003ccode\u003estreambuf\u003c/code\u003e 头文件当中的 \u003ccode\u003estd::basic_streambuf\u003c/code\u003e。这是一个类模板；其声明如下：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCharT\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eTraits\u003c/span\u003e = std::char_traits\u0026lt;CharT\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e basic_streambuf;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003estd::basic_streambuf\u003c/code\u003e 包含两个字符序列，并提供对这两个序列控制和访问的能力：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e受控字符序列（controlled character sequence）：又称缓冲序列（buffer sequence），由读取区（get area）和/或写入区（put area）组成。此二者分别用来缓冲上层流的读写操作。\u003c/li\u003e\n\u003cli\u003e关联字符序列（associated character sequence）：对于输入流来说又称源（source），对于输出流来说又称槽（sink）。关联字符序列通常是通过系统 API 与 I/O 设备关联，或是与 \u003ccode\u003estd::vector\u003c/code\u003e/\u003ccode\u003earray\u003c/code\u003e/字符串字面值等能作为源或槽的对象关联。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于关联字符序列来说，需要 \u003ccode\u003estd::basic_streambuf\u003c/code\u003e 自己实现的功能不多。因为，大多数情况可通过系统 API 或是相关对象的接口来实现。\u003ccode\u003estd::basic_streambuf\u003c/code\u003e 大多数的功能集中在对受控字符序列的管理上。\u003c/p\u003e\n\u003cp\u003e读取区或写入区，通常实现为相应 \u003ccode\u003eCharT\u003c/code\u003e 的 C 风格数组，并辅以 3 个指针，以实现对受控字符序列的控制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e起始指针（beginning pointer）：用于标识相应缓冲序列可用范围的起始位置；\u003c/li\u003e\n\u003cli\u003e终止指针（end pointer）：用于标识相应缓冲序列可用范围的尾后位置；\u003c/li\u003e\n\u003cli\u003e工作指针（next pointer）：指向相应缓冲序列中，下一个等待读/写的元素的位置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e若是一个受控字符序列单单是读取区或写入区，则它必然有这三个指针；若一个受控字符序列同时是读取区和写入区，那么则有两套共六个这样的指针。通过这些指针，\u003ccode\u003estd::basic_streambuf\u003c/code\u003e 就能实现对换受控字符序列的控制。\u003c/p\u003e\n\u003ch2 id=\"流中的缓冲区\"\u003e\u003ca href=\"#流中的缓冲区\" class=\"headerlink\" title=\"流中的缓冲区\"\u003e\u003c/a\u003e流中的缓冲区\u003c/h2\u003e\u003cp\u003e在头文件 \u003ccode\u003eios\u003c/code\u003e 当中，定义着两个类（模板）：\u003ccode\u003estd::ios_base\u003c/code\u003e 和 \u003ccode\u003estd::basic_ios\u003c/code\u003e。前者是所有 I/O 类的祖先，提供了状态信息、控制信息、内部存储、回调等设施。后者继承自前者，额外提供了与 \u003ccode\u003estd::basic_streambuf\u003c/code\u003e 的接口；同时允许多个 \u003ccode\u003estd::basic_ios\u003c/code\u003e 对象绑定同一个 \u003ccode\u003estd::basic_streambuf\u003c/code\u003e 对象。它们的声明分别是：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eios_base\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eCharT\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eTraits\u003c/span\u003e = std::char_traits\u0026lt;CharT\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e basic_ios;  \u003cspan class=\"comment\"\u003e// : public ios_base\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e由于 \u003ccode\u003estd::ios_base\u003c/code\u003e 没有提供与 \u003ccode\u003estd::basic_streambuf\u003c/code\u003e 的接口，\u003ccode\u003estd::basic_ios\u003c/code\u003e 才是标准库内所有 I/O 类（模板）事实上的最近共同祖先。\u003ccode\u003estd::basic_ios\u003c/code\u003e 的成员函数 \u003ccode\u003erdbuf\u003c/code\u003e 是读取和设置流对象（\u003ccode\u003estd::basic_ios\u003c/code\u003e 的对象）绑定缓冲区的成员函数，它有两个不同的重载形式，分别如下：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003estd::basic_streambuf\u0026lt;CharT, Traits\u0026gt;*\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003erdbuf\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003cspan class=\"type\"\u003econst\u003c/span\u003e\u003c/span\u003e;                                      \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003estd::basic_streambuf\u0026lt;CharT, Traits\u0026gt;*\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"title\"\u003erdbuf\u003c/span\u003e\u003cspan class=\"params\"\u003e( std::basic_streambuf\u0026lt;CharT, Traits\u0026gt;* sb )\u003c/span\u003e\u003c/span\u003e;   \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e两个重载版本，第一版不接受任何参数，第二版接受一个指向 \u003ccode\u003estd::basic_streambuf\u0026lt;CharT, Traits\u0026gt;\u003c/code\u003e 类型对象的指针。\u003c/p\u003e\n\u003cp\u003e不接受参数的版本返回流对象绑定的缓冲区对象的指针；而若流对象未绑定任何缓冲区对象，则返回空指针 \u003ccode\u003enullptr\u003c/code\u003e。接受指针的版本首先返回上述指针，而后与先前绑定的缓冲区对象（如果有）解绑，再绑定参数中传入指针指向的缓冲区对象；而若传入空指针 \u003ccode\u003enullptr\u003c/code\u003e，则流对象不与任何缓冲区对象绑定。\u003c/p\u003e\n\u003ch2 id=\"巧妙设置流中的缓冲区\"\u003e\u003ca href=\"#巧妙设置流中的缓冲区\" class=\"headerlink\" title=\"巧妙设置流中的缓冲区\"\u003e\u003c/a\u003e巧妙设置流中的缓冲区\u003c/h2\u003e\u003cp\u003e通过巧妙设置流中的缓冲区，可以达成各种特殊的效果。这里给出几个演示。\u003c/p\u003e\n\u003ch3 id=\"输出流共享缓冲区\"\u003e\u003ca href=\"#输出流共享缓冲区\" class=\"headerlink\" title=\"输出流共享缓冲区\"\u003e\u003c/a\u003e输出流共享缓冲区\u003c/h3\u003e\u003cp\u003e从机制上说，\u003ccode\u003estd::basic_ios\u003c/code\u003e 允许多个流对象绑定同一个缓冲区对象。当然，虽然机制上允许，一般来说这样做却不是好主意。不过，在某些情况下，让多个流对象绑定同一个缓冲区对象，也是有好处的。\u003c/p\u003e\n\u003cp\u003e在具体介绍具体操作之前，还有一事必须说明。如前所述，缓冲区对象是在流和 I/O 设备之间加入的抽象中间层。因此，实际上对于流的所有操作，都会反馈在缓冲区对象之上，而非直接作用域 I/O。这也就是说，一旦流对象绑定的缓冲区对象发生变化，最终的 I/O 效果也会随之发生变化。\u003c/p\u003e\n\u003cp\u003e众所周知，头文件 \u003ccode\u003eiomanip\u003c/code\u003e 当中定义了许多与 \u003ccode\u003estd::ios_base\u003c/code\u003e 相关的格式控制函数与对象。通过这些函数与对象，程序员可以控制从 I/O 流的行为。但若上述行为需要频繁在若干状态之间发生切换，则代码会显得相当繁琐。此时，让多个流对象绑定同一个缓冲区对象就是有好处的了。程序员可以让多个流对象绑定同一个缓冲区对象，而后为每个流对象设置不同的 I/O 行为，即可在需要的时候使用对应的流对象。由于这些流对象绑定了同一个缓冲区对象，这些 I/O 操作最终会合在一起。如此，就达成了目的。\u003c/p\u003e\n\u003cp\u003e以下是让输出流共享缓冲区的示例。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003eostream_shares_buf.cc\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iomanip\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::ostream fixed{std::cout.\u003cspan class=\"built_in\"\u003erdbuf\u003c/span\u003e()};                          \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::ostream sci{std::cout.\u003cspan class=\"built_in\"\u003erdbuf\u003c/span\u003e()};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    fixed.\u003cspan class=\"built_in\"\u003esetf\u003c/span\u003e(std::ios_base::fixed, std::ios_base::floatfield);    \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    fixed.\u003cspan class=\"built_in\"\u003eprecision\u003c/span\u003e(\u003cspan class=\"number\"\u003e5\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    sci.\u003cspan class=\"built_in\"\u003esetf\u003c/span\u003e(std::ios_base::scientific, std::ios_base::floatfield);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    sci.\u003cspan class=\"built_in\"\u003eprecision\u003c/span\u003e(\u003cspan class=\"number\"\u003e3\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    fixed \u0026lt;\u0026lt; \u003cspan class=\"number\"\u003e15.518\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e;                                        \u003cspan class=\"comment\"\u003e// 3.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    sci   \u0026lt;\u0026lt; \u003cspan class=\"number\"\u003e15.518\u003c/span\u003e \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此处，(1) 将新建的两个流对象 \u003ccode\u003efixed\u003c/code\u003e 和 \u003ccode\u003esci\u003c/code\u003e 都与 \u003ccode\u003estd::cout\u003c/code\u003e 的缓冲区对象绑定，而后在 (2) 处分别设置两个流对象的输出格式，最后在 (3) 处用两个不同的流对象输出同一浮点数。编译后得到的结果如下。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ -std=c++11 ostream_shares_buf.cc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15.51800\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e1.552e+01\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"替换输入流的缓冲区\"\u003e\u003ca href=\"#替换输入流的缓冲区\" class=\"headerlink\" title=\"替换输入流的缓冲区\"\u003e\u003c/a\u003e替换输入流的缓冲区\u003c/h3\u003e\u003cp\u003e标准库的 \u003ccode\u003estd::cin\u003c/code\u003e 默认与关联标准输入的缓冲区对象绑定。因此，使用 \u003ccode\u003estd::cin\u003c/code\u003e 可以从标准输入中读取输入。不过，在某些情况下，程序员也会希望改变这一点。例如，在 Online Judge 训练时，程序员可能会希望让 \u003ccode\u003estd::cin\u003c/code\u003e 从本地的测试文件中读取测试用例。考虑到 C++ 中的流对象实际上是对缓冲区进行操作；此时，替换 \u003ccode\u003estd::cin\u003c/code\u003e 的缓冲区，即可达成目的。\u003c/p\u003e\n\u003cp\u003e以下是替换标准输入流的示例。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003eistream_replace_buf.cc\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eifdef\u003c/span\u003e DEBUG_                                           \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;fstream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003enamespace\u003c/span\u003e {                                             \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003econstexpr\u003c/span\u003e \u003cspan class=\"type\"\u003echar\u003c/span\u003e* kTestFileName = \u003cspan class=\"string\"\u003e\u0026#34;oj.test.txt\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::ifstream fin{kTestFileName};                       \u003cspan class=\"comment\"\u003e// 3.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e cin_buf = std::cin.\u003cspan class=\"built_in\"\u003erdbuf\u003c/span\u003e(fin.\u003cspan class=\"built_in\"\u003erdbuf\u003c/span\u003e());             \u003cspan class=\"comment\"\u003e// 4.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}  \u003cspan class=\"comment\"\u003e// namespace\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eendif\u003c/span\u003e  \u003cspan class=\"comment\"\u003e// DEBUG_\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eifdef\u003c/span\u003e DEBUG_\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::cin.\u003cspan class=\"built_in\"\u003etie\u003c/span\u003e(\u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e);                              \u003cspan class=\"comment\"\u003e// 5.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eendif\u003c/span\u003e  \u003cspan class=\"comment\"\u003e// DEBUG_\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::string temp;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::\u003cspan class=\"built_in\"\u003egetline\u003c/span\u003e(std::cin, temp);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::cout \u0026lt;\u0026lt; temp \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#39;\\n\u0026#39;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此处，(1) 在 \u003ccode\u003eDEBUG_\u003c/code\u003e 宏有定义的情况下，进行 (2)(3)(4)(5) 的步骤。其中 (2) 启用了一个匿名空间，起到 C 语言中文件 \u003ccode\u003estatic\u003c/code\u003e 的作用（C++ 也支持这样的用法，但是已经不推荐）；(3) 声明了一个与测试文件关联的文件输入流；(4) 将 \u003ccode\u003estd::cin\u003c/code\u003e 与上述文件输入流的缓冲区绑定，同时将 \u003ccode\u003estd::cin\u003c/code\u003e 原本的缓冲区指针保存在 \u003ccode\u003ecin_buf\u003c/code\u003e 当中。由于在 \u003ccode\u003eDEBUG_\u003c/code\u003e 宏有定义的情况下，\u003ccode\u003estd::cin\u003c/code\u003e 与标准输入解绑，因此无需与标准输入绑定，故而 (5）处取消这种绑定。编译后得到的结果如下。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003ecat\u003c/span\u003e oj.test.txt\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThis is a file \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e testing.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ g++ -std=c++11 -DDEBUG_ istream_replace_buf.cc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThis is a file \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e testing.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e可见，无需在标准输入手工输入测试样例，程序在 \u003ccode\u003eDEBUG_\u003c/code\u003e 有定义时，直接从测试样例文件中读取测试。\u003c/p\u003e\n\u003c!-- 2017 结束，祝 2018 一切顺利！ --\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-12-31T09:14:10Z",
  "Author": "Liam Huang"
}