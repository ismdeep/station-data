{
  "Source": "liam.page",
  "Title": "最佳搭档：利用 SSH 及其配置文件节省你的生命",
  "Link": "https://liam.page/2017/09/12/rescue-your-life-with-SSH-config-file/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eSSH 协议是事实上的互联网基石之一。在 SSH 协议出现之前（1995 年由 Tatu Ylonen 设计），通过互联网远程登录其他设备（\u003ccode\u003etelnet\u003c/code\u003e）的过程是明文的。这意味着，整个通信过程，很容易被旁路嗅探，泄露敏感信息。\u003c/p\u003e\n\u003cp\u003eOpenSSH 是 SSH 协议的经典实现。目前，它作为各 Linux 发行版默认自带的 SSH 工具分发；因而广为使用。\u003c/p\u003e\n\u003cp\u003e若你在学习工作生活中，需要通过 SSH 协议，登录、管理多台服务器。那么，一方面你可能会厌烦记忆各个远程服务器的主机名/IP 地址；另一方面你可能会被繁琐的口令输入过程弄得烦躁不安。特别地，若是你需要在同一台远程主机上，打开多个终端窗口进行操作时；你可能需要反复输入多次用户名和口令（在不用 \u003ccode\u003escreen\u003c/code\u003e/\u003ccode\u003etmux\u003c/code\u003e 之类的工具的前提下）。\u003c/p\u003e\n\u003cp\u003e这篇文章首先会尝试介绍 Linux 自带的 SSH 工具的基本用法，并附带介绍 SSH 配置文件的编写规则。而后，尝试解决上述繁琐的记忆和口令输入命令。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"SSH\"\u003e\u003ca href=\"#SSH\" class=\"headerlink\" title=\"SSH\"\u003e\u003c/a\u003eSSH\u003c/h2\u003e\u003cp\u003e我们说，在创造一件事情之前，你需要想清楚这件事情的意义是什么。通常而言，创造新事物的原动力，是我们发现了旧事物和我们目标之间存在的差距（gap）；而新事物就是为了填上这一差距的。因此，讲道理，我们首先应该去分析在 SSH 协议诞生之前人们使用的远程登录协议有哪些问题；而后去分析 SSH 分别是如何解决这些问题，填上所谓的 gaps 的。\u003c/p\u003e\n\u003cp\u003e然而，「空谈误国，实干兴邦」。一方面在没有任何实践之前，大谈理论是空洞的；另一方面，我们最终也是要将理论落实到时间上去。因此这一节，我们首先介绍/回顾 SSH 的最基本用法；而后讨论 SSH 是如何解决过去远程登录协议遗留下来的问题的；借此，我们将讨论 SSH 连接建立时会发生什么；介绍完这些内容之后，我们将介绍如何免密登录。\u003c/p\u003e\n\u003ch3 id=\"SSH-的基本用法\"\u003e\u003ca href=\"#SSH-的基本用法\" class=\"headerlink\" title=\"SSH 的基本用法\"\u003e\u003c/a\u003eSSH 的基本用法\u003c/h3\u003e\u003cp\u003eLinux 下，\u003ccode\u003essh\u003c/code\u003e 命令的基本用法是\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh [params] [flags] [user@]remotehost [\u003cspan class=\"built_in\"\u003ecommand\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e先除去参数（\u003ccode\u003eparams\u003c/code\u003e）和标识（\u003ccode\u003eflags\u003c/code\u003e）不论，以及不讨论后续的执行命令（\u003ccode\u003ecommand\u003c/code\u003e）；\u003ccode\u003essh\u003c/code\u003e 命令的基本用法是 \u003ccode\u003essh [user@]remotehost\u003c/code\u003e。若一切顺利，如此就能成功以用户 \u003ccode\u003euser\u003c/code\u003e 登录远程服务器 \u003ccode\u003eremotehost\u003c/code\u003e。其中，若你本地登录账户的用户名与远程服务器上的用户名一致，则可以省略 \u003ccode\u003e[user@]\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e另外值得一提的是，这里说的 \u003ccode\u003eremotehost\u003c/code\u003e 指的是「逻辑上」的远程主机。实际上，若是你尝试执行下列命令，就能（利用本地回环）登录你本机的 \u003ccode\u003efoo\u003c/code\u003e 账户了。此时，本机的主机名/IP 地址，就充当了 \u003ccode\u003essh\u003c/code\u003e 命令中逻辑上的远程主机。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh foo@localhost \u003cspan class=\"comment\"\u003e# 127.0.0.0/24, ::1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e127.0.0.0/24\u003c/code\u003e 都是本地回环的 IPv4 地址。只不过，因为 \u003ccode\u003e127.0.0.1\u003c/code\u003e 是其中第一个合法的主机地址；所以被用来指代本地回环。但千万不要以为只有 \u003ccode\u003e127.0.0.1\u003c/code\u003e 这一个地址能够本地回环。\u003ccode\u003e: )\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"SSH-怎样防止信息泄露？\"\u003e\u003ca href=\"#SSH-怎样防止信息泄露？\" class=\"headerlink\" title=\"SSH 怎样防止信息泄露？\"\u003e\u003c/a\u003eSSH 怎样防止信息泄露？\u003c/h3\u003e\u003cp\u003e前文提到，SSH 提出的背景即是在它出现之前，远程登录协议无法保障通信安全。那么，在 SSH 出现之前，远程登录可能面临哪些信息泄露风险呢？\u003c/p\u003e\n\u003cp\u003e首先是前文提到的旁路嗅探。事实上，这是网络通信不可避免的问题；因为从我们本地主机到远程主机的通信链路，是广域网上通过 IP 协议路由实现的。在这一通信链路上，有太多我们无法控制的通信节点。因此，若是这其中但凡有一个节点被黑客控制，我们经由这条链路的通信信息，就可能被嗅探甚至篡改。\u003c/p\u003e\n\u003cp\u003e解决这一问题的根本办法是使用加密的信道。这一办法的思路在于，既然我们无法控制流量被嗅探/篡改，那么我们至少可以让敌手得到的信息是难以破译的密文（至少是破译成本远高于明文本身蕴含的价值）。SSH 协议正是这样做的：它通过非对称加密方法（公钥加密方法），在预先交换公钥的前提下，通信双方通过对方的公钥加密信息，而使用自身私钥解开密文。如此一来，若是能保证密钥交换的可信，则基于非对称加密方案的加密信道就是安全的。\u003c/p\u003e\n\u003cp\u003e除了旁路嗅探，信息泄露的另一大风险来自所谓的中间人攻击。中间人攻击的源头依然来自广域网路由的不可控性。设想，在我们的主机和目标远程主机的通信链路中间，有一个节点充当双面间谍：一方面，它在链路中间截获我们发出的信号，并伪装成目标主机予以返回；另一方面，它在链路中间伪装成我们的主机，转发我们的流量，给真实的远程主机。在这个过程中，如果没有恰当的身份验证手段，那么无论是我们的主机还是远程主机，都无法验证对方的身份。因此，事实上，一方面发起中间人攻击的敌手可以获取所有通信流量，另一方面它可以随意篡改通信流量而难以发现。考虑到上述加密信道的可信性，一方面基于非对称加密的安全性（在这里我们假设为 ground truth，不作怀疑），另一方面基于密钥交换的可信性；那么，由于中间人攻击可能在密钥交换阶段从中作梗，则若 SSH 协议不能妥善解决这一问题，则其安全性就仍然存疑。\u003c/p\u003e\n\u003cp\u003e这样一来，问题实际上转换成了密钥交换过程的身份验证问题。考虑到我们反复提及的广域网上的通信链路是不可信的；仅凭借当前通信进行身份验证，就变成了「鸡生蛋、蛋生鸡」的循环问题。因此，这类验证不得不采用所谓的「盘外招」。\u003c/p\u003e\n\u003cp\u003eSSH 的思路的关键点在于：既然正常信道建立后，远程主机需要将自己的公钥发送给本地主机，那么这一公钥本身就能看作是远程主机的一个身份：若是无法验证远程主机的身份，那么本地主机使用这一公钥进行信息加密是不安全的（因为公钥可能来自敌手，而加密信息可能被敌手使用正确私钥解密而窃取）；若是验证了远程主机的身份，则这一公钥就能放心地用来加密信息。因此，在 SSH 建立链接的过程中，它会要求本地主机的操作者确认远程主机返回的公钥的 hash 值。若这一 hash 值和操作者通过其他方式（盘外招）得到的值一致，则认可远程主机的身份。当然，这一验证不需要每次 SSH 连接时都进行——只需要验证一次，而后交由本地计算机验证 hash 与前次连接获得的 hash 的一致性即可。而这又要求本地计算机将远程主机的公钥 hash 值保存下来，以便下次核对。\u003c/p\u003e\n\u003ch3 id=\"SSH-远程登录的流程\"\u003e\u003ca href=\"#SSH-远程登录的流程\" class=\"headerlink\" title=\"SSH 远程登录的流程\"\u003e\u003c/a\u003eSSH 远程登录的流程\u003c/h3\u003e\u003cp\u003e当本机发起登录请求时，SSH 会依次执行以下几个主要步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过远程主机公钥 hash，确认远程主机身份；\u003c/li\u003e\n\u003cli\u003e若通过，远程主机验证登录身份，例如：提示输入远程主机目标用户的口令；\u003c/li\u003e\n\u003cli\u003e本地主机将用户键入的口令，使用远程主机的公钥加密，并发送给远程主机；\u003c/li\u003e\n\u003cli\u003e远程主机使用上述公钥对应的私钥，对得到的密文进行解密；\u003c/li\u003e\n\u003cli\u003e远程主机验证解密后的口令；\u003c/li\u003e\n\u003cli\u003e若通过，则建立 SSH 连接，成功登录。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e前面已经说过，\u003ccode\u003elocalhost\u003c/code\u003e 也可以充当逻辑上的远程主机。这里我们就以 \u003ccode\u003elocalhost\u003c/code\u003e 为例，验证一下这一过程。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh liamhuang@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe authenticity of host \u003cspan class=\"string\"\u003e\u0026#39;localhost (127.0.0.1)\u0026#39;\u003c/span\u003e can\u003cspan class=\"string\"\u003e\u0026#39;t be established.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eECDSA key fingerprint is 4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eAre you sure you want to continue connecting (yes/no)?\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e执行 \u003ccode\u003essh liamhuang@localhost\u003c/code\u003e 尝试以 \u003ccode\u003eliamhuang\u003c/code\u003e 的用户身份登录（逻辑上的）远程主机 \u003ccode\u003elocalhost\u003c/code\u003e 时，SSH 如我们预期一样，提示我们验证远程主机的身份。这段文字翻译如下。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e无法验证主机 \u0026#39;localhost (127.0.0.1)\u0026#39; 的真实性。ECDSA 密钥指纹为 \u003ccode\u003e4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e\u003c/code\u003e。你是否要继续连接？(yes/no)\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e标准的操作，我们必须通过额外的方式，与远程主机取得联系，验证这一指纹是否真实。不过，此处我们略去这一步骤，键入 \u003ccode\u003eyes\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh liamhuang@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe authenticity of host \u003cspan class=\"string\"\u003e\u0026#39;localhost (127.0.0.1)\u0026#39;\u003c/span\u003e can\u003cspan class=\"string\"\u003e\u0026#39;t be established.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eECDSA key fingerprint is 4d:28:ed:f1:3d:40:fe:68:c8:b3:b0:9b:a7:dc:5d:7e.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eAre you sure you want to continue connecting (yes/no)? yes\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eWarning: Permanently added \u0026#39;\u003c/span\u003elocalhost\u003cspan class=\"string\"\u003e\u0026#39; (ECDSA) to the list of known hosts.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eliamhuang@localhost\u0026#39;\u003c/span\u003es password:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eLast login: Tue Sep 12 17:49:33 2017 from 127.0.0.1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如前所述，为了下次自动地验证远程主机的身份，本地主机会将远程主机的公钥指纹保存下来。新出现的提示，翻译如下。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e警告：已将 \u0026#39;localhost\u0026#39; (ECDSA) 永久地加入已知主机列表之中。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在输入远程主机目标用户的口令之后（无终端回显），本地主机会将输入的口令以远程主机提供的密钥加密并发送给远程主机。待远程主机解密并验证通过后，即提示成功登录。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e上一次成功登录：2017 年 9 月 12 日（周四）17:49:33，自 \u003ccode\u003e127.0.0.1\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e那么，具体来说，本地主机将这一信息保存在哪里了呢？答案是当前用户的 \u003ccode\u003e${HOME}/.ssh/known_hosts\u003c/code\u003e 文件当中。我们可以执行 \u003ccode\u003eexit\u003c/code\u003e 命令，退出远程主机；而后使用 \u003ccode\u003etail\u003c/code\u003e 命令可以查看刚刚插入在该文件末尾的远程主机信息。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003etail\u003c/span\u003e -1 \u003cspan class=\"variable\"\u003e${HOME}\u003c/span\u003e/.ssh/known_hosts\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elocalhost ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBCPWoEQ7iCCYDrpyb5KeMmCaQ8aOnSfehqmrplZRkbqqnkS9++PdSX/eSLJ0tkFd5902/C+HTCqbDgso4mCKpMo=\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"使用公钥验证身份\"\u003e\u003ca href=\"#使用公钥验证身份\" class=\"headerlink\" title=\"使用公钥验证身份\"\u003e\u003c/a\u003e使用公钥验证身份\u003c/h3\u003e\u003cp\u003e现在我们考虑下一个问题：除去输入远程主机用户口令的方式，是否还有其他方式能够验证登录者的身份？\u003c/p\u003e\n\u003cp\u003e对于身份认证来说，通常有三种手段：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e你知道的（例如账户口令）；\u003c/li\u003e\n\u003cli\u003e你独有的（例如网银的 U 盾）；\u003c/li\u003e\n\u003cli\u003e你身上的（例如指纹）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通常来说，对于没有极端的安全性要求的场景，通过其一验证即可。在上述登录过程中，我们采取了「你知道的」这一手段来验证登陆者的身份。考虑到，对于远程登录来说，很难通过生物信息识别来验证身份；剩下可行的方案就是验证「你独有的」特殊物件来验证身份了。\u003c/p\u003e\n\u003cp\u003e对于「你独有的」这一手段来说，使用类似网银的 U 盾显然不现实。一则制作成本太高，二则相关的认证过于复杂。因此，我们须得考虑其他更易行的手段。\u003c/p\u003e\n\u003cp\u003e在 SSH 协议中，信道的安全是通过非对称加密保证的。事实上，非对称加密需要持有私钥。因此，私钥这件事情本身，也可以认为是一种「你独有的」东西。考虑到，在 SSH 登录成功之前，在不完整的信道中，从本地主机向远程主机通信是安全的（因为有远程主机的公钥可用于加密），而远程主机可以用持有的私钥解密本地主机发来的信息。（例如口令登录验证的过程）。类似的过程也可以反过来用：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e本地主机生成一对非对称密钥；\u003c/li\u003e\n\u003cli\u003e本地主机将公钥交付远程主机；\u003c/li\u003e\n\u003cli\u003e远程主机在收到登录请求时，使用上述公钥加密一串无害的随机信息；\u003c/li\u003e\n\u003cli\u003e本地主机将接收到的密文，以本地持有的私钥解密，而后通过远程主机的公钥再进行加密；\u003c/li\u003e\n\u003cli\u003e远程主机使用相应私钥解密，并与上述随机信息进行比对；\u003c/li\u003e\n\u003cli\u003e若一致，则认可登录者的身份，许可登录。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在这个过程中，远程主机对比一来一回前后随机信息的一致性，验证了本地主机确实持有一个安全介质——本地主机生成的私钥。因此，这就不需要输入远程主机的用户口令了。\u003c/p\u003e\n\u003cp\u003e为此，我们首先需要生成一对密钥。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh-keygen\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eGenerating public/private rsa key pair.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eEnter file \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"built_in\"\u003ewhich\u003c/span\u003e to save the key (/home/test/.ssh/id_rsa): /home/test/.ssh/id_rsa.test\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eEnter passphrase (empty \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e no passphrase):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eEnter same passphrase again:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eYour identification has been saved \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e /home/test/.ssh/id_rsa.test.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eYour public key has been saved \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e /home/test/.ssh/id_rsa.test.pub.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe key fingerprint is:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e91:cb:1d:45:65:27:76:cc:66:02:4d:e5:1f:c4:64:6d liam@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe key\u003cspan class=\"string\"\u003e\u0026#39;s randomart image is:\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e+--[ RSA 2048]----+\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|         .o.*o*=.|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|        .o o.=== |\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|        +  E .o.=|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|       . =     +o|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|        S  o    .|\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|                 |\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|                 |\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|                 |\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e|                 |\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e+-----------------+\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003essh-keygen\u003c/code\u003e 是 OpenSSH 的一部分，它用于生成供 SSH 使用的密钥。默认情况下，\u003ccode\u003essh-keygen\u003c/code\u003e 生成的是 RSA 密钥（本机上是 2048 位 RSA），并将私钥保存在 \u003ccode\u003e${HOME}/.ssh/id_rsa\u003c/code\u003e 当中。为了避免与已有的密钥冲突，这里我们另存为 \u003ccode\u003eid_rsa.test\u003c/code\u003e。随后，\u003ccode\u003essh-keygen\u003c/code\u003e 要求我们为生成的私钥设置口令（passphrase）。这一口令是对私钥进行保护的口令，可以留空。这样一来，我们就生成了一对 RSA 密钥。其中，私钥保存在 \u003ccode\u003e/home/test/.ssh/id_rsa.test\u003c/code\u003e 而公钥保存在 \u003ccode\u003e/home/test/.ssh/id_rsa.test.pub\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e接下来，我们需要将生成的密钥交付给远程主机。为此，我们需要使用 \u003ccode\u003essh-copy-id\u003c/code\u003e 这一命令。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh-copy-id -i ~/.ssh/id_rsa.test liamhuang@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e/usr/bin/ssh-copy-id: INFO: attempting to \u003cspan class=\"built_in\"\u003elog\u003c/span\u003e \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e with the new key(s), to filter out any that are already installed\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e you are prompted now it is to install the new keys\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eliamhuang@localhost\u003cspan class=\"string\"\u003e\u0026#39;s password:\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eNumber of key(s) added: 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eNow try logging into the machine, with:   \u0026#34;ssh \u0026#39;\u003c/span\u003eliamhuang@localhost\u003cspan class=\"string\"\u003e\u0026#39;\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003eand check to make sure that only the key(s) you wanted were added.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003essh-copy-id\u003c/code\u003e 会将 \u003ccode\u003e~/.ssh/id_rsa.test\u003c/code\u003e 对应的公钥，交付给 \u003ccode\u003eliamhuang@localhost\u003c/code\u003e。在这个过程中，我们需要输入用户 \u003ccode\u003eliamhuang\u003c/code\u003e 在远程主机 \u003ccode\u003elocalhost\u003c/code\u003e 上的口令。注意，此处我们使用了 \u003ccode\u003e-i\u003c/code\u003e 参数，指定了需要交付的密钥。若是省略 \u003ccode\u003e-i\u003c/code\u003e 参数，则 \u003ccode\u003essh-copy-id\u003c/code\u003e 会将默认的密钥 \u003ccode\u003e~/.ssh/id_rsa\u003c/code\u003e 对应的公钥交付给远程主机。\u003c/p\u003e\n\u003cp\u003e之后，我们就可以「免密登录」了。同样，我们需要使用 \u003ccode\u003e-i\u003c/code\u003e 参数指定所需使用的私钥。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh -i ~/.ssh/id_rsa.test liamhuang@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eLast login: Tue Sep 12 17:53:11 2017 from 127.0.0.1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e类似上面提到过的 \u003ccode\u003e~/.ssh/known_hosts\u003c/code\u003e，保存这类公钥也有一个特定的文件：远程主机目标用户的 \u003ccode\u003e${HOME}/.ssh/authorized_keys\u003c/code\u003e。登录远程主机后，我们可以使用 \u003ccode\u003etail\u003c/code\u003e 命令来查看刚刚添加的公钥。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003etail\u003c/span\u003e -1 ~/.ssh/authorized_keys\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003essh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCiDajuJwE1cyrRxDiDNB+2T2WiWB29l7C61zfnSTFA31SrsWU2DGuC9qoFqRtsbXUXS57E0kmPSJzmkwj+EihHJmZUt6AXYx8UdwXtzSPyhkLH6K/iH2W4fxe9vMvzSdbhM58LUi9+4d1I3Zte9zdG1/boHPIH/+6reU/2V1l2rr44+/LzZoeoyVWICIq2gf7ZMxdJzLLUtuFUBMLIxre3sob6EYSeIJFPvMXfpk9D/Qxio+x8U+PdFOl5avA0m0BaaatXyBe0jhTs43YJOgONnbBQAuJOEJ8RKHgnEVUh1Wu7eIKheaHAeOqBiNW3UMEUDGY9dyInhvFR0tlY8jg5 \u003cspan class=\"built_in\"\u003etest\u003c/span\u003e@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003etail\u003c/span\u003e -1 ~/.ssh/authorized_keys | \u003cspan class=\"built_in\"\u003emd5sum\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e293b27ababace5a6004427af4b0739b9  -\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e返回到本地主机，可见它正是我们刚刚生成的公钥。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003ecat\u003c/span\u003e ~/.ssh/id_rsa.test.pub\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003essh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCiDajuJwE1cyrRxDiDNB+2T2WiWB29l7C61zfnSTFA31SrsWU2DGuC9qoFqRtsbXUXS57E0kmPSJzmkwj+EihHJmZUt6AXYx8UdwXtzSPyhkLH6K/iH2W4fxe9vMvzSdbhM58LUi9+4d1I3Zte9zdG1/boHPIH/+6reU/2V1l2rr44+/LzZoeoyVWICIq2gf7ZMxdJzLLUtuFUBMLIxre3sob6EYSeIJFPvMXfpk9D/Qxio+x8U+PdFOl5avA0m0BaaatXyBe0jhTs43YJOgONnbBQAuJOEJ8RKHgnEVUh1Wu7eIKheaHAeOqBiNW3UMEUDGY9dyInhvFR0tlY8jg5 \u003cspan class=\"built_in\"\u003etest\u003c/span\u003e@localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ \u003cspan class=\"built_in\"\u003ecat\u003c/span\u003e ~/.ssh/id_rsa.test.pub | \u003cspan class=\"built_in\"\u003emd5sum\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e293b27ababace5a6004427af4b0739b9  -\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e须得注意的是，出于安全性考虑，若要保证这一特性打开，远程主机上的相关文件必须限制除当前用户之外的权限。个人建议 \u003ccode\u003e.ssh\u003c/code\u003e 目录权限必须不高于 \u003ccode\u003e700\u003c/code\u003e；且 \u003ccode\u003eauthorized_keys\u003c/code\u003e 文件权限必须不高于 \u003ccode\u003e600\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e若是你的机器不支持 \u003ccode\u003essh-copy-id\u003c/code\u003e，也可以直接将公钥信息写入远程主机目标用户的 \u003ccode\u003e${HOME}/.ssh/authorized_keys\u003c/code\u003e 当中。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh liamhuang@localhost \u003cspan class=\"string\"\u003e\u0026#39;mkdir -p .ssh \u0026amp;\u0026amp; chmod 700 .ssh \u0026amp;\u0026amp; cat \u0026gt;\u0026gt; .ssh/authorized_keys \u0026amp;\u0026amp; chmod 600 .ssh/authorized_keys\u0026#39;\u003c/span\u003e \u0026lt; ~/.ssh/id_rsa.test.pub\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"SSH-的配置文件\"\u003e\u003ca href=\"#SSH-的配置文件\" class=\"headerlink\" title=\"SSH 的配置文件\"\u003e\u003c/a\u003eSSH 的配置文件\u003c/h2\u003e\u003cp\u003e我们在文章开头处提出了利用 SSH 登录管理大量机器的两个不便：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e需要记忆大量机器的主机名；\u003c/li\u003e\n\u003cli\u003e需要记忆、输入大量机器上的用户口令。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在上一节中，我们通过在本地主机生成公钥并交付远程主机，利用「你独有的」这条渠道完成了身份认证；从而避免了在登录时输入远程主机用户的口令。虽然，在示例中，我们不得不使用 \u003ccode\u003e-i\u003c/code\u003e 参数来指定希望使用的私钥文件路径。但这一方面是为了避免与本地主机当前用户默认密钥冲突，另一方面是为了演示这一参数的作用，再者也表明了本地主机用户可以使用功能多个密钥分别用于连接不同主机。\u003c/p\u003e\n\u003cp\u003e然而，尽管避免了输入口令，但是「需要记忆大量主机名」的问题没有解决；同时还引出了新的问题：需要使用 \u003ccode\u003e-i\u003c/code\u003e 参数指定私钥路径。怎样解决这些问题呢？\u003c/p\u003e\n\u003cp\u003eSSH 的配置文件与用户实际执行 \u003ccode\u003essh\u003c/code\u003e 命令时传入的参数协同作用。按照优先级，低优先级的配置项可视作默认值；而高优先级的配置项则会覆盖默认值。按优先级，有如下排序：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用户实际执行 \u003ccode\u003essh\u003c/code\u003e 时传入的参数；\u003c/li\u003e\n\u003cli\u003e用户的 SSH 配置文件 \u003ccode\u003e${HOME}/.ssh/config\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e系统的 SSH 配置文件 \u003ccode\u003e/etc/ssh/ssh_config\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这样一来，通过 SSH 配置文件，我们可以按访问的主机来配置 SSH 的默认行为。\u003c/p\u003e\n\u003ch3 id=\"SSH-配置文件的说明\"\u003e\u003ca href=\"#SSH-配置文件的说明\" class=\"headerlink\" title=\"SSH 配置文件的说明\"\u003e\u003c/a\u003eSSH 配置文件的说明\u003c/h3\u003e\u003cp\u003eSSH 的配置文件有很多配置项可供配置。限于篇幅，此处显然是不可能穷尽的。因此，有兴趣的读者可以通过 \u003ccode\u003eman ssh_config\u003c/code\u003e 查看可用的配置项。\u003c/p\u003e\n\u003cp\u003eSSH 的配置文件采用空格分割的键值形式。例如 \u003ccode\u003eHost localhost\u003c/code\u003e 表示键 \u003ccode\u003eHost\u003c/code\u003e 对应的值为 \u003ccode\u003elocalhost\u003c/code\u003e。此篇涉及到的键如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eHost\u003c/code\u003e：值为通配符的模式（Pattern）；该键之后的键值对，将用于匹配于该模式的主机。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHostName\u003c/code\u003e：值为真实的目标远程主机名；在值中，\u003ccode\u003e%h\u003c/code\u003e 可用于命令行接收到的主机名字的转义。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eUser\u003c/code\u003e：值为希望登录的远程主机的用户名；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eIdentityFile\u003c/code\u003e：值为希望登录时使用的密钥文件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"一个简单的例子\"\u003e\u003ca href=\"#一个简单的例子\" class=\"headerlink\" title=\"一个简单的例子\"\u003e\u003c/a\u003e一个简单的例子\u003c/h3\u003e\u003cp\u003e这样一来，我们可以在配置文件中写入如下内容。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eHost localliam\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    HostName localhost\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    User liamhuang\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    IdentityFile /home/test/.ssh/id_rsa.test\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样一来，执行 \u003ccode\u003essh localliam\u003c/code\u003e 就相当于执行了 \u003ccode\u003essh -i /home/test/.ssh/id_rsa.test liamhuang@localhost\u003c/code\u003e 了。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ssh localliam\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eLast login: Tue Sep 12 19:03:16 2017 from 127.0.0.1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"批量管理\"\u003e\u003ca href=\"#批量管理\" class=\"headerlink\" title=\"批量管理\"\u003e\u003c/a\u003e批量管理\u003c/h3\u003e\u003cp\u003e现在我们构建这样一个场景。我们有 1000 台服务器；它们的主机名编号从 \u003ccode\u003ew-i0.test.sh.localnet\u003c/code\u003e 一直到 \u003ccode\u003ew-i999.test.sh.localnet\u003c/code\u003e。那么，为了免密以 \u003ccode\u003ecloud\u003c/code\u003e 用户的身份登录这 1000 台机器，我们可以首先将准备好的公钥上传到这 1000 台机器上；而后在 SSH 配置文件里配置如下内容。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eHost i? i?? i???\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    Host w-%h.test.sh.localnet\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    User cloud\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    IdentityFile ~/.ssh/id_rsa.test\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样一来，我们就只需要使用 \u003ccode\u003essh i73\u003c/code\u003e 就能以 \u003ccode\u003ecloud\u003c/code\u003e 用户的身份，登录 \u003ccode\u003ew-i73.test.sh.localnet\u003c/code\u003e 了。\u003c/p\u003e\n\u003ch3 id=\"更多场景\"\u003e\u003ca href=\"#更多场景\" class=\"headerlink\" title=\"更多场景\"\u003e\u003c/a\u003e更多场景\u003c/h3\u003e\u003cp\u003e在实际使用中，任何基于 SSH 之上的程序，都可以借助 SSH 配置文件达到简化的目的。例如，代码托管网站 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://bitbucket.org/\"\u003ebitbucket\u003c/a\u003e 支持通过 Git 来管理代码。而 Git 又是支持 SSH 方式与远程仓库进行通信。这样一来，我们就可以通过 SSH 配置文件，简化对 bitbucket 的访问；另一方面，通过 SSH 配置文件，我们可以将访问 bitbucket 时使用的密钥与其它密钥区分开。\u003c/p\u003e\n\u003cp\u003e首先，我们使用 \u003ccode\u003essh-keygen\u003c/code\u003e 生成一对专用于 bitbucket 的密钥；保存在 \u003ccode\u003e~/.ssh/id_rsa.bitbucket\u003c/code\u003e 当中。而后，我们需要将 \u003ccode\u003e~/.ssh/id_rsa.bitbucket.pub\u003c/code\u003e 中的内容，粘贴到 bitbucket 的账户设置中去。而后，我们可以在 SSH 配置文件中记录：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eHost bitb\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    HostName bitbucket.org\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    IdentityFile ~/.ssh/id_rsa.bitbucket\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样一来，\u003ccode\u003egit clone git@bitb:foo/bar.git\u003c/code\u003e 就能克隆 bitbucket 上 \u003ccode\u003efoo\u003c/code\u003e 用户的 \u003ccode\u003ebar\u003c/code\u003e 仓库了（前提是你的账户对这个仓库有访问权限）。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-09-12T12:33:10Z",
  "Author": "Liam Huang"
}