{
  "Source": "liam.page",
  "Title": "为什么不能在动态库里静态链接？",
  "Link": "https://liam.page/2017/04/03/not-to-link-libstdc-statically-and-why/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e因为各种复杂的原因，工作中遇到了某个模块当中的一个动态库（Linux Dynamic Shared Object，我们称其为 \u003ccode\u003eA.so\u003c/code\u003e）需要使用与整个模块不同版本的 gcc 进行编译。由于 \u003ccode\u003eA.so\u003c/code\u003e 使用了高版本 \u003ccode\u003elibstdc++.so\u003c/code\u003e 中提供的接口；因此，如果让 \u003ccode\u003eA.so\u003c/code\u003e 与整个模块运行在同一个环境（即，依赖同一个低版本的 \u003ccode\u003elibstdc++.so\u003c/code\u003e），那么，整个程序运行时将会由动态链接器提示「找不到符号」的错误。\u003c/p\u003e\n\u003cp\u003e一个「看似」可行的解决办法，是在编译 \u003ccode\u003eA.so\u003c/code\u003e 的时候，将对应的高版本的 \u003ccode\u003elibstdc++\u003c/code\u003e 以静态的方式链接到 \u003ccode\u003eA.so\u003c/code\u003e 里面。这样，如果能把来自高版本 \u003ccode\u003elibstdc++.a\u003c/code\u003e 的符号隐藏起来（不暴露给动态链接器，避免符号冲突），那么就可以解决问题了。\u003c/p\u003e\n\u003cp\u003e然而，这个解决办法，实际上是不可行的。本文将分析为什么不可行。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"静态链接的优缺点\"\u003e\u003ca href=\"#静态链接的优缺点\" class=\"headerlink\" title=\"静态链接的优缺点\"\u003e\u003c/a\u003e静态链接的优缺点\u003c/h2\u003e\u003cp\u003e总结起来，静态链接有如下优点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e得到单一的文件，可以拷贝到所有体系结构相同的操作系统上运行；\u003c/li\u003e\n\u003cli\u003e对环境的依赖少，在缺少相应动态库的环境里也可以运行；\u003c/li\u003e\n\u003cli\u003e因为减少了动态链接的步骤，所以运行起来会快一些（某些情况下）；\u003c/li\u003e\n\u003cli\u003e因为在链接时，链接器可以看到所有符号，并进行符号解析，所以链接器可以硬编码函数的入口地址，故而函数调用会快一些；\u003c/li\u003e\n\u003cli\u003e因为在链接时，链接器可以看到所有的符号，所以链接器可以优化删除一些没有被引用的符号，一定程度上减小编译出的文件的体积；\u003c/li\u003e\n\u003cli\u003e能够明确地知道程序使用的依赖库的版本，而无需担心 \u003ccode\u003eLD_LIBRARY_PATH\u003c/code\u003e/\u003ccode\u003eLD_PATH\u003c/code\u003e 的影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当然，静态链接也会有缺点（反过来就是动态链接的优点）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e因为要把所有的符号都打包在一个文件当中，所以文件的体积会显著增大；\u003c/li\u003e\n\u003cli\u003e对于依赖的动态库，不论内存中是否有已经载入的副本（特别是 \u003ccode\u003e.text\u003c/code\u003e 段），对于静态链接的程序，这部分指令都必须重复载入内存，因此内存会消耗得很快；\u003c/li\u003e\n\u003cli\u003e对于依赖的动态库，但凡有任何更新，升级程序都必须整个编译、发布走一圈，无法简单地替换 \u003ccode\u003e.so\u003c/code\u003e 升级。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"对装载的影响\"\u003e\u003ca href=\"#对装载的影响\" class=\"headerlink\" title=\"对装载的影响\"\u003e\u003c/a\u003e对装载的影响\u003c/h2\u003e\u003cp\u003e上述优缺点，实际是站在一个非常 general 的角度对静态链接和动态链接的讨论。在本篇开头处提及的问题，实际上就是希望用到最后一条优点，让 \u003ccode\u003eA.so\u003c/code\u003e 引用指定版本的 \u003ccode\u003elibstdc++\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e但是，在链接生成动态链接库的时候，静态链接依赖另一个静态库，是一种非常规的方法。实际上，这是一种不可行的方法。\u003c/p\u003e\n\u003cp\u003e为了说明这个问题，我们需要对程序装载进内存的过程做一个简单的梳理。\u003c/p\u003e\n\u003cp\u003e当我们在 Linux bash 当中执行命令启动一个进程的时候，bash 实际上会先做一个 \u003ccode\u003efork()\u003c/code\u003e 系统调用，而后在子进程里做一个 \u003ccode\u003eexecve()\u003c/code\u003e 系统调用执行指定的 ELF 可执行文件，原先的进程则返回等待。GLIBC 对 \u003ccode\u003eexecve()\u003c/code\u003e 系统调用做了封装，提供了诸如 \u003ccode\u003eexeclp()\u003c/code\u003e 的函数；但这些函数内里都会去执行 \u003ccode\u003eexecve()\u003c/code\u003e 系统调用。\u003c/p\u003e\n\u003cp\u003e以下代码实现了一个简单的 minibash，模拟展示了启动一个进程的过程。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003cfigcaption\u003e\u003cspan\u003eminibash.c\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;stdio.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;sys/types.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003esize_t\u003c/span\u003e buf_size = \u003cspan class=\"number\"\u003e1024\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title function_\"\u003emain\u003c/span\u003e \u003cspan class=\"params\"\u003e()\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003echar\u003c/span\u003e buf[buf_size] = {\u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003epid_t\u003c/span\u003e pid;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e (\u003cspan class=\"number\"\u003e1\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;minibash $ \u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003escanf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;%s\u0026#34;\u003c/span\u003e, buf);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        pid = fork();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"number\"\u003e0\u003c/span\u003e == pid) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (execlp(buf, \u003cspan class=\"number\"\u003e0\u003c/span\u003e) \u0026lt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;exec error\\n\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (pid \u0026gt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"type\"\u003eint\u003c/span\u003e status;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            waitpid(pid, \u0026amp;status, \u003cspan class=\"number\"\u003e0\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        } \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            pritnf(\u003cspan class=\"string\"\u003e\u0026#34;fork error %d\\n\u0026#34;\u003c/span\u003e, pid);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e当执行到 \u003ccode\u003eexecve()\u003c/code\u003e 系统调用时，就会进入到对应的 \u003ccode\u003esys_execve()\u003c/code\u003e 入口。这标志着由用户态向内核态的转变，同时也标志着装载的开始。对于 ELF 可执行文件，之后的调用顺序是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esys_execve()\u003c/code\u003e - 进行参数检查；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edo_execve()\u003c/code\u003e - 找到可执行文件，读取头部的 128 字节（用以判断可执行文件的类型，例如 ELF 可执行文件的前两个字节是 \u003ccode\u003e0x7F\u003c/code\u003e，即 ELF）；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eload_elf_binary()\u003c/code\u003e\u003cul\u003e\n\u003cli\u003e检查文件格式\u003c/li\u003e\n\u003cli\u003e寻找 \u003ccode\u003e.interp\u003c/code\u003e 段，设置动态链接器的路径\u003c/li\u003e\n\u003cli\u003e设置 ELF 各个段（section）对 VMA 的段（segment）的映射关系\u003c/li\u003e\n\u003cli\u003e初始化 ELF 的进程环境\u003c/li\u003e\n\u003cli\u003e返回入口地址（静态链接程序：\u003ccode\u003ee_entry\u003c/code\u003e，动态链接程序：动态链接器）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之后，系统将从内核态转回用户态，并且将控制权交给上述入口地址的指令。对于静态链接的程序来说，\u003ccode\u003ee_entry\u003c/code\u003e 记录的是整个程序的入口；从内核态转回到用户态之后，进程就从此开始执行。对于动态链接的程序来说，它们的入口是系统提供的动态链接器；从内核态转回到用户态之后，系统将控制权交给动态链接器，由动态链接器完成动态链接过程，而后再跳转到整个程序的真正入口。动态链接器大致完成这些工作：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e启动动态链接器本身，完成自举（Bootstrap）；\u003c/li\u003e\n\u003cli\u003e装载所有依赖的动态库（通常是广度优先遍历，但也可以是深度优先遍历）；\u003c/li\u003e\n\u003cli\u003e处理全局符号表，完成重定位和初始化；\u003c/li\u003e\n\u003cli\u003e将系统控制权交给程序的真正入口。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关于链接、装载的详细内容，可以期待「程序员的自我修养」系列文章。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e注意到，我们的模块依赖了 \u003ccode\u003eA.so\u003c/code\u003e。那么，毫无疑问，这是一个动态链接的程序。我们应该注意到，在进程装载的过程中，首先会完成所有可执行 ELF 文件本身的装载（ELF 到虚存空间的映射），而后才会进入到动态链接库的装载。此外，在动态链接库的装载过程中，动态链接库只会处理以来的动态库（Dynamic Shared Objects，即各种 \u003ccode\u003e.so\u003c/code\u003e 文件）。也就是说，动态链接程序的装载过程可以分成两个步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e装载可执行 ELF 文件静态链接的部分；\u003c/li\u003e\n\u003cli\u003e装载所有依赖的 \u003ccode\u003e.so\u003c/code\u003e 部分。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们注意到，被 \u003ccode\u003e.so\u003c/code\u003e 依赖的静态库 \u003ccode\u003e.a\u003c/code\u003e 是没有机会被装载进内存的。因此，在生成 \u003ccode\u003eA.so\u003c/code\u003e 的过程中，将 \u003ccode\u003elibstdc++.a\u003c/code\u003e 静态链接进去，是不可行的。因为，这部分静态链接的指令永远没有机会被装载进进程空间执行。因此，若要解决这个问题，就只有将 \u003ccode\u003elibstdc++.a\u003c/code\u003e 解包成各个普通的目标文件 \u003ccode\u003e.o\u003c/code\u003e，而后使用链接器 \u003ccode\u003eld\u003c/code\u003e 将这些目标文件链接打包进 \u003ccode\u003eA.so\u003c/code\u003e 当中。\u003c/p\u003e\n\u003ch2 id=\"符号冲突\"\u003e\u003ca href=\"#符号冲突\" class=\"headerlink\" title=\"符号冲突\"\u003e\u003c/a\u003e符号冲突\u003c/h2\u003e\u003cp\u003e现在，我们将 \u003ccode\u003elibstdc++\u003c/code\u003e 的各个目标文件都链接进了 \u003ccode\u003eA.so\u003c/code\u003e。那么，\u003ccode\u003eA.so\u003c/code\u003e 当中会包含 \u003ccode\u003elibstdc++\u003c/code\u003e 中的所有符号。\u003c/p\u003e\n\u003cp\u003e现在的问题是，几乎所有的使用 C++ 编写的可执行程序，都会直接或者间接地依赖 \u003ccode\u003elibstdc++.so\u003c/code\u003e。因此，当动态链接器尝试装载 \u003ccode\u003elibstdc++.so\u003c/code\u003e 和 \u003ccode\u003eA.so\u003c/code\u003e 的时候，就会有大量来自 \u003ccode\u003elibstdc++\u003c/code\u003e 的符号重复了。这就牵扯到了所谓\u003cstrong\u003e全局符号调解（Global Symbol Interpose）\u003c/strong\u003e的问题。\u003c/p\u003e\n\u003cp\u003e对于 Linux 下的动态链接器，全局符号调解的策略很简单：先读入全局符号表的符号生效，后读入的符号被直接忽略丢弃。\u003c/p\u003e\n\u003cp\u003e因此，在这种情况下，我们无法预见整个模块使用的 \u003ccode\u003elibstdc++\u003c/code\u003e 究竟是来自于系统环境，还是来自于 \u003ccode\u003eA.so\u003c/code\u003e 中包含的那些部分。因为，这取决于动态链接器装载动态库的顺序。\u003c/p\u003e\n\u003cp\u003e为此，我们需要在链接生成 \u003ccode\u003eA.so\u003c/code\u003e 的时候，将 \u003ccode\u003elibstdc++\u003c/code\u003e 所含的那些符号隐藏起来。\u003c/p\u003e\n\u003ch2 id=\"全局变量更新导致的运行时问题\"\u003e\u003ca href=\"#全局变量更新导致的运行时问题\" class=\"headerlink\" title=\"全局变量更新导致的运行时问题\"\u003e\u003c/a\u003e全局变量更新导致的运行时问题\u003c/h2\u003e\u003cp\u003e我们回顾一下，至此我们做了这些事情：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将 \u003ccode\u003elibstdc++.a\u003c/code\u003e 解包成各个 \u003ccode\u003e.o\u003c/code\u003e 文件；\u003c/li\u003e\n\u003cli\u003e将来自 \u003ccode\u003elibstdc++\u003c/code\u003e 的各个 \u003ccode\u003e.o\u003c/code\u003e 文件，编译进 \u003ccode\u003eA.so\u003c/code\u003e，并隐藏这些符号。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e至此，我们的程序在链接和装载的过程中，不会遇到任何问题——系统能够正常地将控制权交给模块真正的入口了。但是，如此解决方案仍然有问题。\u003c/p\u003e\n\u003cp\u003e众所周知，诸如 \u003ccode\u003elibstdc++\u003c/code\u003e/\u003ccode\u003elibpthread\u003c/code\u003e 这些库，会在进程空间自行维护一套全局变量和数据结构，用于维护和记录当前的运行状态。很多第三方库，也会有类似的全局变量和数据结构。现在，我们为了使得两个版本的 \u003ccode\u003elibstdc++\u003c/code\u003e（来自系统环境的，以及来自 \u003ccode\u003eA.so\u003c/code\u003e 的）在符号的层面上得以共存，就引起了这样的问题：整个进程空间里，这些全局变量和数据结构存在了两份。比如\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e文件描述符（FD，File Description)；\u003c/li\u003e\n\u003cli\u003e内存边界；\u003c/li\u003e\n\u003cli\u003e错误码 \u003ccode\u003eerrorno\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elibpthread\u003c/code\u003e 的定时器等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样一来，在这些全局变量和数据结构的角度，进程在运行时就会出现很多自相矛盾的状态；甚至直接引起运行时异常。而因为全局变量和数据结构存在两份，这些问题在追查的过程中会极其困难。\u003c/p\u003e\n\u003cp\u003e回顾整个过程，我们不难发现，这样的需求会产生很多问题。尽管从编译、链接、装载的角度，我们可以用一些很 tricky 的方法解决问题；但是，等到程序执行过程中，仍然可能会隐藏各种难以发现、解决的问题。因此，我们说\u003cstrong\u003e不应该尝试向动态库静态编译标准库或第三方库\u003c/strong\u003e。\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2 id=\"附录：如何将依赖的库静态链接进可执行程序\"\u003e\u003ca href=\"#附录：如何将依赖的库静态链接进可执行程序\" class=\"headerlink\" title=\"附录：如何将依赖的库静态链接进可执行程序\"\u003e\u003c/a\u003e附录：如何将依赖的库静态链接进可执行程序\u003c/h2\u003e\u003cp\u003e我们先来看一个耳熟能详的 \u003ccode\u003eHello world!\u003c/code\u003e 程序。\u003c/p\u003e\n\u003cfigure class=\"highlight c++\"\u003e\u003cfigcaption\u003e\u003cspan\u003ehello.cpp\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eusing\u003c/span\u003e std::cout;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eusing\u003c/span\u003e std::endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34;Hello world!\u0026#34;\u003c/span\u003e \u0026lt;\u0026lt; endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e众所周知，如果要将它编译为可执行程序，只需要执行 \u003ccode\u003eg++ hello.cpp -o hello\u003c/code\u003e 就可以了。在这个过程中，\u003ccode\u003eg++\u003c/code\u003e 这个命令，隐藏了编译、链接的细节。我们在这里把步骤拆开，依次进行。\u003c/p\u003e\n\u003cp\u003e首先，我们对其进行编译。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ -c hello.cpp -o hello.o\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，\u003ccode\u003e-c\u003c/code\u003e 参数告知 \u003ccode\u003eg++\u003c/code\u003e 命令，我们只希望编译就可以了，之后的链接不要自动执行。\u003c/p\u003e\n\u003cp\u003e我们知道，编译器会将代码中的函数、变量等，翻译成一个个的符号（symbol）。我们可以用 \u003ccode\u003enm\u003c/code\u003e 命令，查看 \u003ccode\u003ehello.o\u003c/code\u003e 当中包含了哪些符号。而后可以用 \u003ccode\u003ec++filt\u003c/code\u003e 命令，查看符号背后对应的函数签名或者变量名。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ nm hello.o | \u003cspan class=\"built_in\"\u003ewc\u003c/span\u003e -l\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello.o\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e000000000000003e t _GLOBAL__I_main\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000000000 t _Z41__static_initialization_and_destruction_0ii\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSolsEPFRSoS_E\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSt8ios_base4InitC1Ev\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSt8ios_base4InitD1Ev\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZSt4cout\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000000000 b _ZSt8__ioinit\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U __cxa_atexit\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U __dso_handle\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U __gxx_personality_v0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000000054 t __tcf_0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e000000000000006c T main\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ c++filt _Z41__static_initialization_and_destruction_0ii\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e__static_initialization_and_destruction_0(int, int)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们看到，\u003ccode\u003ehello.o\u003c/code\u003e 当中，只有 14 个符号。并且，在这些符号中，有很多是未定义的符号——第二列提示 \u003ccode\u003eU\u003c/code\u003e 表示未定义。这表明，\u003ccode\u003ehello.o\u003c/code\u003e 用到了这些符号，但是这些符号对应的函数、变量，定义在其他目标文件当中。\u003c/p\u003e\n\u003cp\u003e接下来我们执行链接这一步。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ hello.o -o hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eHello world!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello | \u003cspan class=\"built_in\"\u003ewc\u003c/span\u003e -l\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e49\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000600ae8 d _DYNAMIC\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000600cb0 d _GLOBAL_OFFSET_TABLE_\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000400816 t _GLOBAL__I_main\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000400958 R _IO_stdin_used\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 w _Jv_RegisterClasses\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e00000000004007d8 t _Z41__static_initialization_and_destruction_0ii\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSolsEPFRSoS_E@@GLIBCXX_3.4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U _ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000000000400844 T main\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e经过链接之后，可执行文件 \u003ccode\u003ehello\u003c/code\u003e 当中的符号多了不少：从 14 个增加到了 49 个。这说明，经过链接之后，可执行文件补充了一些执行过程中需要的符号。但是我们也看到，在 \u003ccode\u003ehello\u003c/code\u003e 当中，仍然存在被标记为 \u003ccode\u003eU\u003c/code\u003e 的未定义的符号。这说明，\u003ccode\u003ehello\u003c/code\u003e 在运行时仍旧会动态地依赖系统中的动态库。我们可以用 \u003ccode\u003eldd\u003c/code\u003e 命令查看一个 ELF 文件依赖的动态库。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ldd hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        linux-vdso.so.1 =\u0026gt;  (0x00007fffb3bfd000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libstdc++.so.6 =\u0026gt; /opt/gcc/lib64/libstdc++.so.6 (0x00002ada4968e000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libm.so.6 =\u0026gt; /lib64/libm.so.6 (0x0000003576c00000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libgcc_s.so.1 =\u0026gt; /opt/gcc/lib64/libgcc_s.so.1 (0x00002ada49996000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x0000003576000000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        /lib64/ld-linux-x86-64.so.2 (0x0000003575c00000)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003elinux-vdso.so.1\u003c/code\u003e 是 Linux 的一个内核模块；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elibstdc++.so.6\u003c/code\u003e 是 C++ 标准库对应的动态库；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003elibm.so.6\u003c/code\u003e/\u003ccode\u003elibgcc_s.so.1\u003c/code\u003e/\u003ccode\u003elibc.so.6\u003c/code\u003e 都是 gcc 相关的动态库；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e/lib64/ld-linux-x86-64.so.2\u003c/code\u003e 则是动态链接器对应的动态库（实际上也是一个可执行的 ELF）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果想要将这些依赖的动态库对应的符号，都静态链接到可执行文件中的话，则需要在链接的时候加上 \u003ccode\u003e-static\u003c/code\u003e 参数。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ hello.o -o hello -static\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eHello world!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello | \u003cspan class=\"built_in\"\u003ewc\u003c/span\u003e -l\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4425\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ldd hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        not a dynamic executable\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello | grep \u003cspan class=\"string\"\u003e\u0026#34; U \u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                 U __tls_get_addr\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们看到，相对不加 \u003ccode\u003e-static\u003c/code\u003e 参数的版本，新的 \u003ccode\u003ehello\u003c/code\u003e 多出了四千多个符号；并且，以 \u003ccode\u003eldd\u003c/code\u003e 查看 \u003ccode\u003ehello\u003c/code\u003e 依赖的动态库，命令提示 \u003ccode\u003ehello\u003c/code\u003e 没有依赖其他的动态库；最后，我们发现，\u003ccode\u003ehello\u003c/code\u003e 的所有符号中，仅有 \u003ccode\u003e__tls_get_addr\u003c/code\u003e 是未定义的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etls\u003c/code\u003e 是 Thread Local Storage 的缩写，\u003ccode\u003e__tls_get_addr()\u003c/code\u003e 接收一个参数（数据结构 \u003ccode\u003etls_index\u003c/code\u003e 的起始地址），返回一个 Thread Local Variable 的在当前段的偏移量和长度。这个函数是专为动态链接器设计的，在静态链接时这个符号对应的函数无意义（参见 \u003ccode\u003eELF/SymbolTable.cpp\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e因此，我们说，对于静态链接版本的 \u003ccode\u003ehello\u003c/code\u003e 来说，它已经包含了运行所需的所有符号。\u003c/p\u003e\n\u003cp\u003e若是想要静态链接 \u003ccode\u003elibstdc++\u003c/code\u003e，其他的部分依然保留动态链接，则可以使用 \u003ccode\u003eg++\u003c/code\u003e 的参数 \u003ccode\u003e-static-libstdc++\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ hello.o -o hello -static-libstdc++\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eHello world!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ldd hello\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        linux-vdso.so.1 =\u0026gt;  (0x00007fffcd5fd000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libm.so.6 =\u0026gt; /lib64/libm.so.6 (0x0000003576c00000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libgcc_s.so.1 =\u0026gt; /opt/gcc/lib64/libgcc_s.so.1 (0x00002b6ccb401000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        libc.so.6 =\u0026gt; /lib64/libc.so.6 (0x0000003576000000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        /lib64/ld-linux-x86-64.so.2 (0x0000003575c00000)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello | \u003cspan class=\"built_in\"\u003ewc\u003c/span\u003e -l\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3022\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ nm hello | grep \u003cspan class=\"string\"\u003e\u0026#34; U \u0026#34;\u003c/span\u003e | grep -v GLIBC | grep -v GCC\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e可以看到，使用 \u003ccode\u003e-static-libstdc++\u003c/code\u003e 之后，\u003ccode\u003ehello\u003c/code\u003e 不再依赖 \u003ccode\u003elibstdc++.so\u003c/code\u003e 了。同时，其中包含的符号相比动态链接 \u003ccode\u003elibstdc++\u003c/code\u003e 的版本要多出不少，而相对完全静态链接的版本又少了不少；介于二者之间。此外，我们也验证了，\u003ccode\u003ehello\u003c/code\u003e 中包含的未定义的符号，除开 \u003ccode\u003eGLIBC\u003c/code\u003e 和 \u003ccode\u003eGCC\u003c/code\u003e 相关的符号之外，就没有了。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-04-03T04:13:09Z",
  "Author": "Liam Huang"
}