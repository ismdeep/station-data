{
  "Source": "liam.page",
  "Title": "二分类的评价指标",
  "Link": "https://liam.page/2019/12/05/evaluation-of-binary-classification/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e分类问题是机器学习领域的一大类问题，二分类问题又是其中最为基础的一种。在评价模型性能时，机器学习领域延伸出了很多评价指标。这篇文章简单梳理一下这些指标。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"混淆矩阵（confusion-matrix）\"\u003e\u003ca href=\"#混淆矩阵（confusion-matrix）\" class=\"headerlink\" title=\"混淆矩阵（confusion matrix）\"\u003e\u003c/a\u003e混淆矩阵（confusion matrix）\u003c/h2\u003e\u003cp\u003e二分类模型的基本工作是这样的：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将样本 \u003ccode\u003e$\\{\\vec x, y\\}$\u003c/code\u003e 输入二分类模型 \u003ccode\u003e$\\mathcal C$\u003c/code\u003e，得到模型输出得分 \u003ccode\u003e$s$\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e将模型输出得分 \u003ccode\u003e$s$\u003c/code\u003e 映射为最终结果 \u003ccode\u003e$\\hat y = M(s)$\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于给定的模型 \u003ccode\u003e$\\mathcal C$\u003c/code\u003e 和映射函数 \u003ccode\u003e$M(\\cdot)$\u003c/code\u003e，根据样本真实分类 \u003ccode\u003e$y$\u003c/code\u003e 和模型预测分类 \u003ccode\u003e$\\hat y$\u003c/code\u003e 的组合，定义如下四种情况：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e真阳性（True Positive，简称：TP）：表示样本是阳性 \u003ccode\u003e$y = 1$\u003c/code\u003e，并且模型也预测为阳性 \u003ccode\u003e$\\hat y = 1$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e假阳性（False Positive，简称：FP）：表示样本是阴性 \u003ccode\u003e$y = 0$\u003c/code\u003e，但模型预测为阳性 \u003ccode\u003e$\\hat y = 1$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e真阴性（True Negative，简称：TN）：表示样本是阴性 \u003ccode\u003e$y = 0$\u003c/code\u003e，并且模型也预测为阴性 \u003ccode\u003e$\\hat y = 0$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e假阴性（False Negative，简称：FN）：表示样本是阳性 \u003ccode\u003e$y = 1$\u003c/code\u003e，但模型预测为阴性 \u003ccode\u003e$\\hat y = 0$\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e又根据样本真实分类 \u003ccode\u003e$y$\u003c/code\u003e 和模型预测分类 \u003ccode\u003e$\\hat y$\u003c/code\u003e 的实际情况，定义如下四个变量：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e$P = TP + FN$\u003c/code\u003e：表示所有真实分类为阳性的样本的数量。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$N = FP + TN$\u003c/code\u003e：表示所有真实分类为阴性的样本的数量。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$P\u0026#39; = TP + FP$\u003c/code\u003e：表示所有预测分类为阳性的样本的数量。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e$N\u0026#39; = TN + FN$\u003c/code\u003e：表示所有预测分类为阴性的样本的数量。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e于是可绘制如下混淆矩阵：\u003c/p\u003e\n\u003ctable align=\"center\"\u003e\n\n\u003ctbody\u003e\u003ctr\u003e\n\u003cth colspan=\"2\" rowspan=\"2\"\u003e \u003c/th\u003e\n\u003cth colspan=\"2\" align=\"center\"\u003e真实值\u003c/th\u003e\n\u003cth rowspan=\"2\"\u003e总\u003cbr/\u003e数\n\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003ci\u003e1\u003c/i\u003e\u003c/th\u003e\n\u003cth\u003e\u003ci\u003e0\u003c/i\u003e\n\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth rowspan=\"2\" valign=\"middle\"\u003e预\u003cbr/\u003e测\u003cbr/\u003e输\u003cbr/\u003e出\n\u003c/th\u003e\n\u003cth valign=\"middle\" style=\"padding:0.5em;\"\u003e\u003ci\u003e1\u003c/i\u003e\u003c/th\u003e\n\u003cth style=\"padding:0.5em;\"\u003e真阳性\u003cbr/\u003e(TP)\u003c/th\u003e\n\u003cth style=\"padding:0.5em;\"\u003e假阳性\u003cbr/\u003e(FP)\u003c/th\u003e\n\u003cth style=\"padding:0.5em;\"\u003eP\u0026#39;\n\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth valign=\"middle\" style=\"padding:0.5em;\"\u003e\u003ci\u003e0\u003c/i\u003e\u003c/th\u003e\n\u003cth style=\"padding: 0.5em;\"\u003e假阴性\u003cbr/\u003e(FN)\u003c/th\u003e\n\u003cth style=\"padding:0.5em;\"\u003e真阴性\u003cbr/\u003e(TN)\u003c/th\u003e\n\u003cth style=\"padding:0.5em;\"\u003eN\u0026#39;\n\u003c/th\u003e\u003c/tr\u003e\n\u003ctr\u003e\n\u003cth colspan=\"2\" style=\"padding:0.5em;\"\u003e总数\u003c/th\u003e\n\u003cth align=\"center\"\u003eP\u003c/th\u003e\n\u003cth align=\"center\"\u003eN\u003c/th\u003e\n\u003cth\u003e\n\u003c/th\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\n\u003ch2 id=\"由混淆矩阵衍生的指标\"\u003e\u003ca href=\"#由混淆矩阵衍生的指标\" class=\"headerlink\" title=\"由混淆矩阵衍生的指标\"\u003e\u003c/a\u003e由混淆矩阵衍生的指标\u003c/h2\u003e\u003cp\u003e混淆矩阵是二分类模型与其数据相互作用得到的最基本的结果。建立在混淆矩阵之上，我们可以定义出一系列的指标，来衡量二分类模型的性能。这里对常见的指标及需要关注的要点罗列如下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e真阳性率\u003c/strong\u003e（true positive rate，TPR）/\u003cstrong\u003e敏感度\u003c/strong\u003e（sensitivity）/\u003cstrong\u003e召回率\u003c/strong\u003e（recall rate）：在二分类问题中，真阳性率、敏感度和召回率三个名词对应着同一个概念；它表示正样本中被预测为正样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$TPR = TP / P = TP / (TP + FN).$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e真阴性率\u003c/strong\u003e（true negative rate，TNR）/\u003cstrong\u003e特异度\u003c/strong\u003e（specificity）：在二分类问题中，真阴性率和特异度对应着同一个概念；它表示负样本中被预测为负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$TNR = TN / N = TN / (TN + FP).$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e假阳性率\u003c/strong\u003e（false positive rate，FPR）：它表示负样本中被错误地预测为正样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 \u003ccode\u003e$FPR = FP / N = FP / (TN + FP) = 1 - TNR.$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e假阴性率\u003c/strong\u003e（false negative rate，FNR）：它表示正样本中被错误滴预测为负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 \u003ccode\u003e$FNR = FN / P = FN / (TP + FN) = 1 - TPR.$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e阳性预测值\u003c/strong\u003e（positive predictive value，PPV）/\u003cstrong\u003e精确率\u003c/strong\u003e（percision）：它表示被预测为正的样本中正样本的占比。在二分类问题中，阳性预测值和精确率对应着同一个概念；一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$PPV = TP / (TP + FP) = TP / P\u0026#39;.$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e阴性预测值\u003c/strong\u003e（negative predictive value，NPV）：它表示被预测为负的样本中负样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$NPV = TN / (TN + FN) = TN / N\u0026#39;.$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e假发现率\u003c/strong\u003e（false detective rate，FDR）：它表示被预测为正的样本中负样本的占比。一般而言，它的值越小意味着模型性能越好。其计算公式是 \u003ccode\u003e$FDR = FP / (TP + FP) = FP / P\u0026#39; = 1 - PPV.$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e准确率\u003c/strong\u003e（accuracy，ACC）：它表示全体样本中预测正确的样本的占比。一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$ACC = (TP + TN) / (P + N).$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eF1 值\u003c/strong\u003e（F1-score）：它是召回率（真阳性率）和精确率（阳性预测值）的调和平均。一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$F1 = 2TP / (P + P\u0026#39;).$\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e约登指数\u003c/strong\u003e（Youden\u0026#39;s J statistic）：一般而言，它的值越大意味着模型性能越好。其计算公式是 \u003ccode\u003e$J = TPR + TNR - 1.$\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"准确率悖论（Accuracy-Paradox）\"\u003e\u003ca href=\"#准确率悖论（Accuracy-Paradox）\" class=\"headerlink\" title=\"准确率悖论（Accuracy Paradox）\"\u003e\u003c/a\u003e准确率悖论（Accuracy Paradox）\u003c/h3\u003e\u003cp\u003e准确率表示全体样本中，模型预测正确的样本之占比。这是一个非常 intuitive 的指标，和我们一般的认知很相符。但准确率有一个很大的问题：当正负例极不平衡时，即当 \u003ccode\u003e$P \\gg N$\u003c/code\u003e 或 \u003ccode\u003e$N \\gg P$\u003c/code\u003e 时，准确率会被样本量占优的类别主导从而失真。一般我们认为正例是重要的，于是这个问题在负例数量远多于正例数量时，显得尤为严重。欺诈检测、癌症检测等场合，均属于这种情况。\u003c/p\u003e\n\u003cp\u003e举个栗子。假设验证集中共有 100 个样本，其中有 95 个负例和 5 个正例。若模型对所有输入都认定为负例，则这种情况下有 \u003ccode\u003e$ACC = (TP + TN) / (P + N) = (0 + 95) / (5 +95) = 0.95$\u003c/code\u003e。看起来准确率很高，但这个模型一个正例都分辨不出来，没有实际价值。\u003c/p\u003e\n\u003cp\u003e单独用 TPR、TNR、FPR、FNR、PPV、NPV、FDR 这些指标，也会遇到类似的困难。\u003c/p\u003e\n\u003ch3 id=\"召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值\"\u003e\u003ca href=\"#召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与-F1-值\" class=\"headerlink\" title=\"召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值\"\u003e\u003c/a\u003e召回率（真阳性率，TPR）、精确率（阳性预测值，PPV）与 F1 值\u003c/h3\u003e\u003cp\u003e计算召回率和精确率时的分子都是 TP，不同在于分母。召回率的分母是 \u003ccode\u003e$P$\u003c/code\u003e，而精确率的分母是 \u003ccode\u003e$P\u0026#39;$\u003c/code\u003e。这也就是说，召回率是相对真实样本而言的，精确率是相对模型预测为正例的样本而言的。\u003c/p\u003e\n\u003cp\u003e举个栗子。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e假设验证集当中有 100 个正例，你的模型将这 100 个正例中的 40 个预测为正例，则你的模型的召回率是 40%。\u003c/li\u003e\n\u003cli\u003e假设你的模型一共预测了 50 个正例，其中 40 个确实是正例（还有 10 个是负例，即 FP 的情形），则你的模型精确率是 80%。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e显然，若要提高召回率，则模型会变得「贪婪」，于是犯错的可能性就会变大，也就是精确率下降；若要提高精确率，则模型会变得「保守」，此时模型能够覆盖的正例就少，于是召回率下降。考虑到召回率和精确率之间「跷跷板」的关系，人们发明了 F1 值这个指标，并将其定义为召回率和精确率的调和平均数，从而能够比较容易地在召回率和精确率方面取得平衡：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$F1 = \\frac{2}{\\frac{1}{TPR} + \\frac{1}{PPV}} = \\frac{2TP}{P + P\u0026#39;}.$$\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数\"\u003e\u003ca href=\"#敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数\" class=\"headerlink\" title=\"敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数\"\u003e\u003c/a\u003e敏感度（真阳性率，TPR）、特异度（真阴性率，TNR）与约登指数\u003c/h3\u003e\u003cp\u003e从数学上将，召回率和精确率之间跷跷板一般的关系来自于精确率计算的分母是 \u003ccode\u003e$P\u0026#39;$\u003c/code\u003e 而非 \u003ccode\u003e$P$\u003c/code\u003e。因为当模型发生变化的时候，\u003ccode\u003e$P\u0026#39;$\u003c/code\u003e 就会发生变化。所以你无法在提升召回率的时候，保证精确率不变；反之亦然。\u003c/p\u003e\n\u003cp\u003e既然如此，我们寻找分母为 \u003ccode\u003e$P$\u003c/code\u003e 或 \u003ccode\u003e$N$\u003c/code\u003e 的指标，是否就能解决这个问题了呢？按照这个思路，人们定义了敏感度和特异度的概念。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e敏感度就是召回率，它是真阳性率的有一个马甲。\u003c/li\u003e\n\u003cli\u003e特异度是模型在负例上的召回率，因此它是真阴性率的马甲。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因为敏感度和特异度分别是以验证集中正例数量和负例数量为分母的，所以它们：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不存在必然的跷跷板关系；\u003c/li\u003e\n\u003cli\u003e不受不平衡数据的影响。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这就「很\u003cdel\u003e理中客\u003c/del\u003e」了嘛。为了统一考量模型的敏感度和特异度，即为了统一考量模型在正负例上的召回率，人们又定义了约登指数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$J = TPR + TNR - 1.$$\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"曲线及其-AUC（Area-under-Curve，曲线下面积）\"\u003e\u003ca href=\"#曲线及其-AUC（Area-under-Curve，曲线下面积）\" class=\"headerlink\" title=\"曲线及其 AUC（Area under Curve，曲线下面积）\"\u003e\u003c/a\u003e曲线及其 AUC（Area under Curve，曲线下面积）\u003c/h2\u003e\u003cp\u003e上面的讨论都基于一个假设，即映射函数 \u003ccode\u003e$M(\\cdot)$\u003c/code\u003e 是确定的。如果映射函数发生变化，模型对样本的最终预测 \u003ccode\u003e$\\hat y$\u003c/code\u003e 就会发生变化，进而影响到混淆矩阵，最终影响到各个评价指标。因此，在这个意义下，对于确定的模型，各个指标将是映射函数的函数。\u003c/p\u003e\n\u003cp\u003e一般来说，对于二分类问题，映射函数是一个简单的分段函数。于是，各个指标将是分段阈值 \u003ccode\u003e$t$\u003c/code\u003e 的函数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$M(s) = \\begin{cases} 1 \u0026amp; s \u0026gt; t, \\\\ 0 \u0026amp; \\text{otherwise}. \\end{cases}$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e对于需要取舍的指标对，我们可以做如下操作，得到一条曲线（折线）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e逐渐改变阈值 \u003ccode\u003e$t$\u003c/code\u003e，得到序列 \u003ccode\u003e$\\bigl\\{\\bigl(A(t), B(t)\\bigr)\\bigr\\}$\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e将指标 A 和指标 B 分别作为平面直角坐标系的横轴和纵轴。\u003c/li\u003e\n\u003cli\u003e将序列对应的点，绘制在平面直角坐标系中。\u003c/li\u003e\n\u003cli\u003e顺序连接这些点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于真阳性率（敏感度，召回率）和假阳性率（1 - 特异度），这条曲线是接收者操作特征曲线（receiver operating characteristic curve）。对于召回率和精确率，这条曲线是精确率-召回率曲线（PR-Curve）。\u003c/p\u003e\n\u003ch3 id=\"接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）\"\u003e\u003ca href=\"#接收者操作特征曲线（receiver-operating-characteristic-curve-ROC）\" class=\"headerlink\" title=\"接收者操作特征曲线（receiver operating characteristic curve, ROC）\"\u003e\u003c/a\u003e接收者操作特征曲线（receiver operating characteristic curve, ROC）\u003c/h3\u003e\u003cp\u003e一条典型的 ROC 如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/MachineLearning/roc.png\" alt=\"ROC\"/\u003e\u003c/p\u003e\n\u003cp\u003e这里，横坐标代表假阳性率 FPR，它是阈值 \u003ccode\u003e$t$\u003c/code\u003e 的函数，我们记作 \u003ccode\u003e$F(t)$\u003c/code\u003e；纵坐标代表真阳性率 TPR，它也是阈值 \u003ccode\u003e$t$\u003c/code\u003e 的函数，我们记作 \u003ccode\u003e$T(t)$\u003c/code\u003e。从图中很明显能看出 FPR 和 TPR 之间「鱼和熊掌不可兼得」的关系。曲线下面积（AUC）越大，也就是曲线约接近左上角，说明模型就越理想。那么 ROC 的 AUC 是什么含义呢？\u003c/p\u003e\n\u003cp\u003e我们将 FPR 看做是一个累积分布函数，即\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$F(t) = P(\\hat y \\geqslant t \\mid y = 0),$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e因此 FPR 相对 \u003ccode\u003e$t$\u003c/code\u003e 的偏导数应当是一个概率密度函数，即\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\frac{\\partial F(t)}{\\partial t} = P(\\hat y = t \\mid y = 0).$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e我们将 TPR 看做是 FPR 的函数，即 \u003ccode\u003e$T(t) = T(F) = T(F^{-1}(F(t)))$\u003c/code\u003e。因此有\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\begin{aligned} \\text{AUC} = {}\u0026amp; \\int_{0}^{1} T(F)\\,\\mathop{}\\mathrm{d}F \\\\            = {}\u0026amp; \\int_{0}^{1} P(\\hat y \u0026gt; t \\mid y = 1)\\cdot\\frac{\\partial F(t)}{\\partial t}\\,\\mathop{}\\mathrm{d}t \\\\            = {}\u0026amp; \\int_{0}^{1} P(\\hat y \u0026gt; t \\mid y = 1)\\cdot P(\\hat y\u0026#39; = t \\mid y\u0026#39; = 0)\\,\\mathop{}\\mathrm{d}t \\\\            = {}\u0026amp; \\int_{0}^{1} P(\\hat y \u0026gt; t \\wedge \\hat y\u0026#39; = t \\mid y = 1 \\wedge y\u0026#39; = 0)\\,\\mathop{}\\mathrm{d}t \\\\            = {}\u0026amp; \\int_{0}^{1} P(\\hat y \u0026gt; \\hat y\u0026#39; \\wedge \\hat y\u0026#39; = t \\mid y = 1 \\wedge y\u0026#39; = 0)\\,\\mathop{}\\mathrm{d}t \\\\            = {}\u0026amp; P(\\hat y \u0026gt; \\hat y\u0026#39; \\mid y = 1 \\wedge y\u0026#39; = 0). \\\\ \\end{aligned}$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e于是我们知道，ROC 的 AUC 表示任选正负例对 \u003ccode\u003e$\\bigl((\\vec x_1, y_1 = 1), (\\vec x_2, y_2 = 0)\\bigr)$\u003c/code\u003e，模型输出得分中，正例得分大于负例得分的概率 \u003ccode\u003e$P\\bigl(\\mathcal C(\\vec x_1) \u0026gt; \\mathcal C(\\vec x_2)\\bigr)$\u003c/code\u003e。换言之，ROC 的 AUC 反映了模型的排序能力。这在 CTR 预估排序的场景下，非常有用。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关于这一点，\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://madrury.github.io/jekyll/update/statistics/2017/06/21/auc-proof.html\"\u003e这里\u003c/a\u003e有一个有趣的集合解释。\u003cbr/\u003e另外，值得一提的是，一般默认的 AUC 指的是 AUC of ROC。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"精确率-召回率曲线（precision-recall-curve-PR-Curve）\"\u003e\u003ca href=\"#精确率-召回率曲线（precision-recall-curve-PR-Curve）\" class=\"headerlink\" title=\"精确率-召回率曲线（precision-recall curve, PR-Curve）\"\u003e\u003c/a\u003e精确率-召回率曲线（precision-recall curve, PR-Curve）\u003c/h3\u003e\u003cp\u003e一条典型的 PR-Curve 如下图所示。\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/MachineLearning/pr-curve.jpg\" alt=\"PR-Curve\"/\u003e\u003c/p\u003e\n\u003cp\u003e从中很明显能看出来之前说的「跷跷板」关系。曲线下面积（AUC）越大，也就是曲线约接近右上角，说明模型就越理想。但这种情况，在实际工作中基本是不可能出现的。因此我们需要根据实际问题进行取舍（确定一个合适的 \u003ccode\u003e$t$\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e对于正例显著少于负例的情况，人们往往追求尽可能高的召回率。因此，可以预先设定一个精确率下限，然后在这个下限之上，寻找召回率最高的点。比如在上图中，若设定可接受的最低精确率是 0.8，则召回率最高大约是 0.55；若设定可接受的最低精确率是 0.6，则召回率最高大约是 0.92。对于正例显著多于负例的情况，人们往往追求尽可能高的精确率。此时可以反向操作，选取合适的 \u003ccode\u003e$t$\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e同样的问题：那么 PR-Curve 的 AUC 是什么含义呢？利用类似的思路可得：PR-Curve 的 AUC 表示任选一个正例 \u003ccode\u003e$(\\vec x_1, y_1 = 1)$\u003c/code\u003e，而后任选一个满足 \u003ccode\u003e$\\mathcal C(\\vec x_2) \u0026gt; \\mathcal C(\\vec x_1)$\u003c/code\u003e 的样本 \u003ccode\u003e$(\\vec x_2, y_2)$\u003c/code\u003e，该样本为正样本的概率 \u003ccode\u003e$P\\bigl(y_2 = 1 \\mid y_1 = 1 \\wedge \\mathcal C(\\vec x_2) \u0026gt; \\mathcal C(\\vec x_1)\\bigr)$\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"ROC-与-PR-Curve-的比较\"\u003e\u003ca href=\"#ROC-与-PR-Curve-的比较\" class=\"headerlink\" title=\"ROC 与 PR-Curve 的比较\"\u003e\u003c/a\u003eROC 与 PR-Curve 的比较\u003c/h3\u003e\u003cp\u003e\u003cimg data-src=\"/uploads/images/MachineLearning/roc-imbalanced.webp\" alt=\"ROC in skewed datasets\"/\u003e\u003c/p\u003e\n\u003cp\u003e由于 ROC 的横纵坐标分别表示 FPR 和 TPR，二者的分母完全隔开，从而使得 AUC of ROC 不受正负样本比例的影响（如上图所示）。这看起来是个好事，因为它在倾斜的数据集上依然保持了稳定的物理意义（类似准确率）。但是，另一方面，这说明在负例数量远大于正例数量的极度倾斜的数据集上，AUC of ROC 可能失真。在这种情况下，PR-Curve 能够更好地反映出模型的性能。\u003c/p\u003e\n\u003ch2 id=\"点击率预估模型中的-AUC-与-gAUC（grouped-AUC）\"\u003e\u003ca href=\"#点击率预估模型中的-AUC-与-gAUC（grouped-AUC）\" class=\"headerlink\" title=\"点击率预估模型中的 AUC 与 gAUC（grouped AUC）\"\u003e\u003c/a\u003e点击率预估模型中的 AUC 与 gAUC（grouped AUC）\u003c/h2\u003e\u003cp\u003e在个性化推荐、广告中，用作 rank 的模型，通常是点击率预估模型。此类模型将问题抽象为一个二分类问题，用模型预测用户是否会点击一个物品（推荐的内容或者广告）。由于该场景的目标是对物品进行排序，所以天然适合使用 AUC 作为评价指标。\u003c/p\u003e\n\u003cp\u003e但这有一个问题，我们通过例子来说明。\u003c/p\u003e\n\u003cp\u003e假设样本集中有 A 和 B 两个用户，分别都有 10 个物品。在这分别的 10 个物品当中，又分别有 5 个正例和 5 个负例。我们将这些正例和负例记为 A+/B+/A-/B-。假设将点击率预估模型的输出从高到低排序，结果是 A+/A-/B+/B-。此时，将两个用户的正负例混合起来看，AUC 不会很高。因为模型将部分负例（A-）排在了部分正例（B+）之前。但是，对于 A 和 B 分别来说，他们能观察到的正例均排在负例之前。也就是说，此时 AUC 不高，但实际效果很好。\u003c/p\u003e\n\u003cp\u003e这个问题可以这样解释：在模型预测分数越集中的区域，用户之间的细微差异导致的正负样本差异的影响就越大。因此，AUC 在这些区域可能会失真。此时，引入分组 AUC（grouped AUC, gAUC）可以缓解这一问题。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\text{gAUC} := \\frac{\\sum_{i = 1}^{n}(\\omega_{i}\\cdot\\text{AUC}_{i})}{\\sum_{i = 1}^{n}\\omega_{i}}.$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这里，\u003ccode\u003e$\\text{AUC}_{i}$\u003c/code\u003e 表示第 \u003ccode\u003e$i$\u003c/code\u003e 个分组内的 AUC；\u003ccode\u003e$\\omega_{i}$\u003c/code\u003e 则表示该组权重。对于点击率预估的场景，每个用户对应一个分组，该用户的权重可设为该用户在样本集当中可见的曝光数量。即有\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\text{gAUC} := \\frac{\\sum_{i = 1}^{n}(\\#\\text{impression}_{i}\\cdot\\text{AUC}_{i})}{\\sum_{i = 1}^{n}\\#\\text{impression}_{i}}.$$\u003c/code\u003e\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-12-05T12:34:14Z",
  "Author": "Liam Huang"
}