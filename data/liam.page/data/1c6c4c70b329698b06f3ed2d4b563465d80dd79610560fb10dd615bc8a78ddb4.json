{
  "Source": "liam.page",
  "Title": "跳过冗余 revisions 以加速 git svn fetch",
  "Link": "https://liam.page/2020/01/09/speed-up-git-svn-fetch-by-skipping-reduntant-revisions/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e众所周知，Git 相较 SVN 的一个优势在于它会将版本库的所有历史信息下载到本地，但它的背面则是：如果版本库很大，则 \u003ccode\u003egit clone\u003c/code\u003e 会消耗很长时间。使用 \u003ccode\u003egit svn\u003c/code\u003e 桥接 SVN 仓库时，如果 SVN 仓库很大（例如有超过 100,000 次修订），则 \u003ccode\u003egit svn fetch\u003c/code\u003e 会花费很长时间（可能超过 24 hours）。\u003c/p\u003e\n\u003cp\u003e如果你觉得，\u003ccode\u003egit svn fetch\u003c/code\u003e 这么多修订只是一次性的工作，因此勉强能够忍受。那我只能说，能有这种想法，还是「太年轻」。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003eSVN 相较 Git 的一个优势在于它可以针对仓库里的各个子路径进行权限设置。于是，我们可以假设这样一种场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSVN 仓库中，有例如 100,000 次修订。\u003c/li\u003e\n\u003cli\u003e你使用 \u003ccode\u003egit svn clone -s \u0026lt;uri of svn repository\u0026gt;\u003c/code\u003e 将这 10 万次修订都下载到本地，行程了一个 Git 本地仓库。\u003c/li\u003e\n\u003cli\u003e在开发的过程中，你发现你缺少某些子路径的权限，于是你找到 SVN 管理员，为你授权了这些子路径。\u003c/li\u003e\n\u003cli\u003e而后，你会使用 \u003ccode\u003egit svn fetch\u003c/code\u003e 来更新你的本地仓库。这时，你会发现报错 \u003ccode\u003e\u0026lt;file\u0026gt; was not found in commit \u0026lt;hash\u0026gt;\u003c/code\u003e。其原因在于，由于之前你的权限缺失，导致前次 \u003ccode\u003egit svn clone\u003c/code\u003e 以及历次 \u003ccode\u003egit svn fetch\u003c/code\u003e 的过程中，这些路径在 \u003ccode\u003egit-svn\u003c/code\u003e 看来是「空的」；但在这次 \u003ccode\u003egit svn fetch\u003c/code\u003e 时，这些路径突然有了东西，但是缺少相应的历史。\u003c/li\u003e\n\u003cli\u003e为了修正这个问题，有以下一些解决办法：\u003cul\u003e\n\u003cli\u003e干掉整个本地仓库，从头再 \u003ccode\u003egit svn clone -s \u0026lt;uri of svn repository\u0026gt;\u003c/code\u003e 一次。这相当于从 \u003ccode\u003er1\u003c/code\u003e 开始重新 \u003ccode\u003egit svn fetch\u003c/code\u003e 一次。\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003egit svn reset -p \u0026lt;revision\u0026gt;\u003c/code\u003e 将本地仓库回退到一个早先的版本，然后从该版本 \u003ccode\u003egit svn fetch\u003c/code\u003e。需要注意的是，涉及到权限缺失的路径，必须在该 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 之后创建。定位这个 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 本身就很困难，更不用说若是这些路径有过移动的话，又会有一系列的问题。因此，虽然该方案相当于从 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 开始重新 \u003ccode\u003egit svn fetch\u003c/code\u003e；能省下 \u003ccode\u003er1 -- \u0026lt;revision\u0026gt;\u003c/code\u003e 之间的修订，但仍然十分麻烦。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在这种情况下，从头再来，似乎是唯一的选择了。而后，你终于不得不承认曾经的自己「太年轻」。\u003c/p\u003e\n\u003cp\u003e为了解决这个困局，我们不得不做一次 trade-off。既然问题的根源在于 Git 会将所有历史信息下载到本地，若是我们能舍弃一些过早的历史信息，只下载较近的历史，就能够绕过这个问题。为此，我们需要：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erm -rf \u0026lt;local repo\u0026gt;\u003c/code\u003e：删掉已经「失真」的本地仓库。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emkdir \u0026lt;local repo\u0026gt;\u003c/code\u003e：建立一个空的目录。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecd \u0026lt;local repo\u0026gt;\u003c/code\u003e：进入刚创立的目录。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit svn init -s \u0026lt;uri of svn repository\u0026gt;\u003c/code\u003e：以 \u003ccode\u003egit svn\u003c/code\u003e 初始化该仓库，但不立即 \u003ccode\u003eclone\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003egit svn fetch -r \u0026lt;revision\u0026gt;\u003c/code\u003e：从 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 开始，拉取仓库版本信息；即舍弃从 \u003ccode\u003er1\u003c/code\u003e 开始到 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 结束的所有历史信息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e唯独需要注意的是，如果涉及到分支操作，你必须保证你会用到的分支，都在上述 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 之后创建。\u003c/p\u003e\n\u003cp\u003e如此一来，只要 \u003ccode\u003e\u0026lt;revision\u0026gt;\u003c/code\u003e 选得好，代码开始写的早。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-01-09T11:41:55Z",
  "Author": "Liam Huang"
}