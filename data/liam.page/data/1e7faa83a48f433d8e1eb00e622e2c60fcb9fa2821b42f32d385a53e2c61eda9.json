{
  "Source": "liam.page",
  "Title": "程序员的自我修养（五）：C++ 多线程编程初步",
  "Link": "https://liam.page/2017/05/16/first-step-on-multithread-programming-of-cxx/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e这是\u003ca href=\"/series/\"\u003e系列文章\u003c/a\u003e的第五篇。\u003c/p\u003e\n\u003cp\u003e这篇文章里，我们介绍如何使用 C++ 11 的标准库，进行多线程编程。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"Babystep\"\u003e\u003ca href=\"#Babystep\" class=\"headerlink\" title=\"Babystep\"\u003e\u003c/a\u003eBabystep\u003c/h2\u003e\u003cp\u003e好吧，不管学什么编程语言，「Hello world!」总是不会少的。虽然在 C++ 中进行多线程编程依然是在使用 C++，但是迈出 babystep 总是很重要的。让我们从 \u003cem\u003eHello multithread!\u003c/em\u003e 开始。\u003c/p\u003e\n\u003cp\u003e首先，作为对比，我们写出 \u003cem\u003eHello world!\u003c/em\u003e 程序。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003ehello_world.cpp\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#inlcude \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34;Hello world!\u0026#34;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e使用 C++ 11 的标准库，在程序中启动一个线程是很简单的。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003ehello_multithread.cpp\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;thread\u0026gt;\u003c/span\u003e       \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003egreeting\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{       \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34;Hello multithread!\u0026#34;\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::thread t{greeting};    \u003cspan class=\"comment\"\u003e// 3.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    t.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();                   \u003cspan class=\"comment\"\u003e// 4.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在编译它的时候，需要注意链接平台相关的线程库。比如在 Linux 上，需要链接 \u003ccode\u003epthread\u003c/code\u003e 库。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ g++ --std=c++11 -pthread hello_multithread.cpp\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eHello multithread!\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这份代码值得注意的地方有四点。\u003c/p\u003e\n\u003cp\u003e首先，我们引入了头文件 \u003ccode\u003ethread\u003c/code\u003e。在这个头文件中，C++ 11 提供了管理线程的类和函数。\u003c/p\u003e\n\u003cp\u003e之后，我们定义了一个无返回类型的函数 \u003ccode\u003egreeting\u003c/code\u003e，这个函数除了在标准输出流中打印一行文字之外什么也不做。\u003c/p\u003e\n\u003cp\u003e而后，我们定义了一个 \u003ccode\u003estd::thread\u003c/code\u003e 类型的变量 \u003ccode\u003et\u003c/code\u003e，并用列表初始化的方式传入了 \u003ccode\u003egreeting\u003c/code\u003e 函数（的指针，参考\u003ca href=\"/2017/02/05/pointer-in-C-and-Cpp/\"\u003e这里\u003c/a\u003e），作为 \u003ccode\u003estd::thread\u003c/code\u003e 类构造函数的参数。传入的函数，会作为新启动的子线程的入口函数。也就是说，当子线程准备就绪之后，就会开始执行这个入口函数。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e从 C++ 11 开始，推荐使用列表初始化的方式，构造类类型的变量。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e最后，我们调用成员函数 \u003ccode\u003et.join()\u003c/code\u003e，确保主线程在子线程退出之后才退出。\u003c/p\u003e\n\u003ch2 id=\"线程管理初步\"\u003e\u003ca href=\"#线程管理初步\" class=\"headerlink\" title=\"线程管理初步\"\u003e\u003c/a\u003e线程管理初步\u003c/h2\u003e\u003cp\u003e上面的 Babystep 中，我们已经介绍了 C++ 11 标准库中提供的设施，并以之启动了一个线程。当然，这个线程实在是太简单了，所以在性能上没有任何的价值。这一节，我们将介绍如何使用 C++ 11 标准库提供的设施，对线程进行基本的管理\u003c/p\u003e\n\u003ch3 id=\"线程函数\"\u003e\u003ca href=\"#线程函数\" class=\"headerlink\" title=\"线程函数\"\u003e\u003c/a\u003e线程函数\u003c/h3\u003e\u003cp\u003e首先需要说明的概念，是\u003cstrong\u003e线程函数\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e我们讲，任何事情都有个「开始」。对于整个程序来说，我们知道，每个程序都有一个入口。当程序被装载到内存，处于内核态完成一些初始化的工作之后，控制权就转交给程序入口，并以此为标志进入用户态。这是一个程序的开始。同样地，线程也需要有「开始」的地方。作为线程入口的函数，就是线程函数。\u003c/p\u003e\n\u003cp\u003e稍微思考一下，就不难发现，线程函数必须在启动线程之前，就准备好。这是因为，哪怕线程什么也不做——等待，也需要一条指令。因此，线程函数必须在线程启动之前准备好，并在线程初始化后立即执行。\u003c/p\u003e\n\u003cp\u003e类似地，当线程函数返回时，线程也就随之终止了。\u003c/p\u003e\n\u003ch3 id=\"启动线程\"\u003e\u003ca href=\"#启动线程\" class=\"headerlink\" title=\"启动线程\"\u003e\u003c/a\u003e启动线程\u003c/h3\u003e\u003cp\u003e在 Babystep 一节中，我们已经可以观察到：\u003cstrong\u003e线程随着 \u003ccode\u003estd::thread\u003c/code\u003e 类型实例的创建而创建\u003c/strong\u003e。C++ 11 的标准库，将创建线程和创建实例两个动作统一起来，对于 C++ 的程序员来说，线程就变成了如内存、文件一样的资源，由 C++ 提供统一的接口进行管理。同时，我们也已知晓，创建线程需指定线程函数。那么，根据线程函数的不同，在 C++ 中使用 \u003ccode\u003estd::thread\u003c/code\u003e 直接创建线程，大致有三种不同的方式。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edo_some_work\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread wk_thread{do_some_work};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e仿照 Babystep 中的介绍，这是在 C++ 中创建线程最简单的例子。如同我们在\u003ca href=\"/2017/02/05/pointer-in-C-and-Cpp/\"\u003e指针一文\u003c/a\u003e中介绍的那样，当函数的名字被当做一个值来使用的时候，实际上使用的是函数的指针。因此，我们也可以显式地传入 \u003ccode\u003e\u0026amp;do_some_work\u003c/code\u003e，作为 \u003ccode\u003ewk_thread\u003c/code\u003e 的构造参数。\u003c/p\u003e\n\u003cp\u003e除了普通的函数之外，\u003cstrong\u003e可调用类型\u003c/strong\u003e的实例也可以作为线程函数，创建线程。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eThreadTask\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003esize_t\u003c/span\u003e count_ = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"title\"\u003eThreadTask\u003c/span\u003e \u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e count)\u003c/span\u003e : count_(count) {\u003c/span\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eoperator\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003edo_something\u003c/span\u003e(\u003cspan class=\"keyword\"\u003ethis\u003c/span\u003e-\u0026gt;count_);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThreadTask task{\u003cspan class=\"number\"\u003e42\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread wk_thread{task};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于可调用类型，这里有两件事情需要特别注意。\u003c/p\u003e\n\u003cp\u003e首先，尽管可调用类型的实例看起来和函数一样，但是它毕竟是一个类类型的对象。所以，在 \u003ccode\u003ewk_thread\u003c/code\u003e 构造时，\u003ccode\u003etask\u003c/code\u003e 会被拷贝到线程的存储空间，而后再开始执行。因此，\u003ccode\u003eThreadTask\u003c/code\u003e 类必须做好足够的拷贝控制。\u003c/p\u003e\n\u003cp\u003e其次，若是在创建线程的时候，传入的是临时构造的实例，需要注意 C++ 的语法解析规则。这种情况下，推荐使用 C++ 的列表初始化。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003estd::thread \u003cspan class=\"title\"\u003ewk_thread\u003c/span\u003e\u003cspan class=\"params\"\u003e(ThreadTask())\u003c/span\u003e\u003c/span\u003e;    \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread wk_thread{ThreadTask{}};    \u003cspan class=\"comment\"\u003e// 2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在 (1) 处，作者的本意，是想构造一个 \u003ccode\u003eThreadTask\u003c/code\u003e 实例，作为可调用对象作为 \u003ccode\u003ewk_thread\u003c/code\u003e 线程的线程函数。但实际上，\u003ca href=\"/2017/02/05/pointer-in-C-and-Cpp/\"\u003e指针一文\u003c/a\u003e介绍过，\u003ccode\u003eThreadTask()\u003c/code\u003e 是一个函数指针的类型——这个函数没有参数 (\u003ccode\u003evoid\u003c/code\u003e)，返回值的类型是 \u003ccode\u003eThreadTask\u003c/code\u003e。因此，整个 (1) 会被 C++ 理解为一个函数声明：参数是一个函数指针（前述），返回类型是 \u003ccode\u003estd::thread\u003c/code\u003e。显而易见，这不是作者想要的。\u003c/p\u003e\n\u003cp\u003e我们说，构造函数和普通的函数是有一些不同的。构造函数执行完毕之后，就产生了一个可用的实例。产生这样误解的本质原因，是 \u003ccode\u003estd::thread\u003c/code\u003e 的构造函数也是函数，因而采用 \u003ccode\u003e()\u003c/code\u003e 接受参数列表；这样一来，从形式上构造函数就没有任何特殊性了。C++ 11 引入了列表初始化的概念，允许程序员以花括号代替圆括号，将参数传递给构造函数。这样一来，(2) 就没有歧义了。\u003c/p\u003e\n\u003cp\u003eC++ 11 引入了 lambda-表达式（或者你可以简单地称其为 lambda-函数）。在创建线程时，我们也可以将 lambda-表达式作为线程函数，传入 \u003ccode\u003estd::thread\u003c/code\u003e 的构造函数。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003estd::thread wk_thread{[](){\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003edo_something\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"线程结束的控制\"\u003e\u003ca href=\"#线程结束的控制\" class=\"headerlink\" title=\"线程结束的控制\"\u003e\u003c/a\u003e线程结束的控制\u003c/h3\u003e\u003cp\u003e正如申请了内存，必须主动释放一样，对线程的管理也讲究有始有终。当线程启动之后，我们必须在 \u003ccode\u003estd::thread\u003c/code\u003e 实例销毁之前，显式地说明我们希望如何处理实例对应线程的结束状态。如果上述实例销毁之时，程序员尚未显式说明如何处理对应线程的结束状态，那么在上述实例的析构函数中，会调用 \u003ccode\u003estd::terminate()\u003c/code\u003e 函数，终止整个程序。\u003c/p\u003e\n\u003cp\u003e在主线程中，我们可以选择「接合 (join)」或者「分离 (detach)」产生的子线程。具体来说，就是对 \u003ccode\u003estd::thread\u003c/code\u003e 实例调用 \u003ccode\u003ejoin()\u003c/code\u003e 或者 \u003ccode\u003edetach()\u003c/code\u003e 成员函数。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edo_something\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread join_me{do_something};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread detach_me{do_something};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (join_me.\u003cspan class=\"built_in\"\u003ejoinable\u003c/span\u003e()) {       \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    join_me.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (detach_me.\u003cspan class=\"built_in\"\u003ejoinable\u003c/span\u003e()) {     \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    detach_me.\u003cspan class=\"built_in\"\u003edetach\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，不论是接合或是分离，我们都首先调用了 \u003ccode\u003ejoinable()\u003c/code\u003e 成员函数。它在尚未决定接合/分离时，返回 \u003ccode\u003etrue\u003c/code\u003e；而若已经决定了接合/分离（通过调用 \u003ccode\u003ejoin()\u003c/code\u003e/\u003ccode\u003edetach()\u003c/code\u003e），则返回 \u003ccode\u003efalse\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果选择接合子线程，则主线程会阻塞住，直到该子线程退出为止。这就好像将子线程尚未执行完的部分，接合在主线程的当前位置，而后顺序执行。\u003c/p\u003e\n\u003cp\u003e如果选择分离子线程，则主线程丧失对子线程的控制权，其控制权转交给 C++ 运行时库。这就引出了两个需要注意的地方\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主线程结束之后，子线程可能仍在运行（因而可以作为守护线程）；\u003c/li\u003e\n\u003cli\u003e主线程结束伴随着资源销毁，需要保证子线程没有引用这些资源。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003e一个会引发错误的例子\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title class_\"\u003efunc\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003esize_t\u003c/span\u003e\u0026amp; i_ = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003efunc\u003c/span\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e\u0026amp; i): \u003cspan class=\"built_in\"\u003ei_\u003c/span\u003e(i) {}      \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eoperator\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e j{\u003cspan class=\"number\"\u003e0\u003c/span\u003e}; j!= \u003cspan class=\"number\"\u003e1000000\u003c/span\u003e; ++j) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"built_in\"\u003edo_something\u003c/span\u003e(i);    \u003cspan class=\"comment\"\u003e// 2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ebad_reference\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003esize_t\u003c/span\u003e working{\u003cspan class=\"number\"\u003e42\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    func wk_func{working};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::thread wk_thread{wk_func};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    wk_thread.\u003cspan class=\"built_in\"\u003edetach\u003c/span\u003e();         \u003cspan class=\"comment\"\u003e// 3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;                     \u003cspan class=\"comment\"\u003e// 4\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，我们定义了一个可调用的类。在循环内，我们不断尝试对外部传来的引用 (1) 进行一些操作 (2)。然而，在分离子线程之后 (3)，子线程所依赖的外部引用，随着函数的退出而销毁 (4)。这样，子线程后续使用该引用 (2) 的行为就是未定义的了，这是非常危险的。\u003c/p\u003e\n\u003cp\u003e至此，关于线程结束的控制，你已经了解大半了。你应该已经知道必须要在 \u003ccode\u003estd::thread\u003c/code\u003e 实例销毁之前，决定接合或是分离相应的线程。并且你也应该知道，对于分离的线程，要保证其数据的完整性。一般来说，「你」所能做的事情，就到此为止了。但是，总有例外的情况，需要特别处理。\u003c/p\u003e\n\u003cp\u003e对于大多数程序员来说，可能甚少处理「异常」。很多程序员，会在代码里做「防御式」编程，以规避各种可能导致异常的可能。在一些情况下，这样做无可厚非。但是，不论如何，我们应该记住「任何代码都有可能发生异常」这一原则。特别地，运行在子线程里的代码，也有可能发生异常。如果子线程里扔出的异常，没有被任何调用者处理，那么这个异常最终会导致整个程序终止。又如果子线程里扔出的异常，调用者在处理时没有决定线程的接合或分离，那么 \u003ccode\u003estd::thread\u003c/code\u003e 的销毁很可能会绕过正常逻辑中的接合或分离的逻辑，从而调用 \u003ccode\u003estd::terminate()\u003c/code\u003e 终止整个进程。\u003c/p\u003e\n\u003cp\u003e我们在\u003ca href=\"/2017/04/09/Foundations-of-Cpp/\"\u003e前作\u003c/a\u003e中讲到，对于可能发生资源泄漏的情况，我们可以考虑用 RAII 的思想，将资源封装在一个 handle 或者 guard 当中，从而防止资源泄漏。同时，前文也提到，\u003cstrong\u003e线程也是一种资源\u003c/strong\u003e。因此，我们可以考虑构造一个 \u003ccode\u003eThreadGuard\u003c/code\u003e 来处理这种异常安全的问题。\u003c/p\u003e\n\u003cfigure class=\"highlight c++\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title class_\"\u003eThreadGuard\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::thread\u0026amp; t_;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003eexplicit\u003c/span\u003e \u003cspan class=\"title\"\u003eThreadGuard\u003c/span\u003e\u003cspan class=\"params\"\u003e(std::thread\u0026amp; t)\u003c/span\u003e : t_(t) {\u003c/span\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ~\u003cspan class=\"built_in\"\u003eThreadGuard\u003c/span\u003e() {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"keyword\"\u003ethis\u003c/span\u003e-\u0026gt;t_.\u003cspan class=\"built_in\"\u003ejoinable\u003c/span\u003e()) {          \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ethis\u003c/span\u003e-\u0026gt;t_.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();                \u003cspan class=\"comment\"\u003e// 2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eThreadGuard\u003c/span\u003e  (\u003cspan class=\"type\"\u003econst\u003c/span\u003e ThreadGuard\u0026amp;) = \u003cspan class=\"keyword\"\u003edelete\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ThreadGuard\u0026amp; \u003cspan class=\"keyword\"\u003eoperator\u003c/span\u003e=(\u003cspan class=\"type\"\u003econst\u003c/span\u003e ThreadGuard\u0026amp;) = \u003cspan class=\"keyword\"\u003edelete\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edo_something\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eshow\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::thread wk_thread;                  \u003cspan class=\"comment\"\u003e// default constructed\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ThreadGuard g{wk_thread};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    wk_thread = std::thread{do_something};  \u003cspan class=\"comment\"\u003e// 3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003edo_domething_in_current_thread\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;                                 \u003cspan class=\"comment\"\u003e// 3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这是一个典型的利用 RAII 保护资源的例子。不论 \u003ccode\u003ewk_thread\u003c/code\u003e 对应的线程如何退出 (3)，守卫变量 \u003ccode\u003eg\u003c/code\u003e 都会在声明周期结束是，帮助 \u003ccode\u003ewk_thread\u003c/code\u003e 确认结束状态 (1)(2)。\u003c/p\u003e\n\u003ch2 id=\"向线程函数传递参数\"\u003e\u003ca href=\"#向线程函数传递参数\" class=\"headerlink\" title=\"向线程函数传递参数\"\u003e\u003c/a\u003e向线程函数传递参数\u003c/h2\u003e\u003cp\u003e前一节中提到，线程函数即是作为线程入口的函数。作为函数，它自然可以接受参数；只不过此前我们举的例子，都是无参数的函数。这一节介绍如何向线程函数传递参数。\u003c/p\u003e\n\u003cp\u003e首先我们要确认：在线程启动时，向线程函数传递参数是可行的。具体做法，是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e向 \u003ccode\u003estd::thread\u003c/code\u003e 的构造函数传递参数，将参数拷贝进线程的内部存储空间；\u003c/li\u003e\n\u003cli\u003e而后，由线程构造函数，将参数传递给线程函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"预先转换格式\"\u003e\u003ca href=\"#预先转换格式\" class=\"headerlink\" title=\"预先转换格式\"\u003e\u003c/a\u003e预先转换格式\u003c/h3\u003e\u003cp\u003e我们来看看，如何向线程函数传参。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edemo\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003econst\u003c/span\u003e std::string\u0026amp;)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread \u003cspan class=\"type\"\u003edemo_t\u003c/span\u003e{demo, \u003cspan class=\"number\"\u003e42\u003c/span\u003e, \u003cspan class=\"string\"\u003e\u0026#34;hello thread\u0026#34;\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，我们就新建了一个线程，它调用线程函数 \u003ccode\u003edemo(42, \u0026#34;hello thread\u0026#34;)\u003c/code\u003e。需要注意的是构造函数的第三个参数 \u003ccode\u003e\u0026#34;hello thread\u0026#34;\u003c/code\u003e，\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先，它作为 \u003ccode\u003econst char*\u003c/code\u003e 被拷贝进入线程内部；\u003c/li\u003e\n\u003cli\u003e而后，它被传递给 \u003ccode\u003edemo\u003c/code\u003e 作为第二个参数；\u003c/li\u003e\n\u003cli\u003e此时，由于 \u003ccode\u003edemo\u003c/code\u003e 的第二个参数类型为 \u003ccode\u003econst std::string\u0026amp;\u003c/code\u003e，所以会发生类型转换。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在这里，被转换的是一个字符串常量，看上去没什么问题。但是，当替换 \u003ccode\u003econst char*\u003c/code\u003e 为 \u003ccode\u003echar*\u003c/code\u003e 时，就可能引发严重的后果。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edemo\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003econst\u003c/span\u003e std::string\u0026amp;)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ebad_buffer\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e param)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003echar\u003c/span\u003e buffer[\u003cspan class=\"number\"\u003e2014\u003c/span\u003e];                  \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003esprintf\u003c/span\u003e(buffer, \u003cspan class=\"string\"\u003e\u0026#34;%i\u0026#34;\u003c/span\u003e, param);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003estd::thread \u003cspan class=\"title\"\u003ewk_t\u003c/span\u003e\u003cspan class=\"params\"\u003e(demo, \u003cspan class=\"number\"\u003e42\u003c/span\u003e, buffer)\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"comment\"\u003e// 2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003ewk_t\u003c/span\u003e.\u003cspan class=\"built_in\"\u003edetach\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;                             \u003cspan class=\"comment\"\u003e// 3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e同样地，\u003ccode\u003ebuffer\u003c/code\u003e 是数组名 (1)，作为值使用时被当做指针 (2)，传入 \u003ccode\u003estd::thread\u003c/code\u003e 的构造函数。而后，在调用 \u003ccode\u003edemo\u003c/code\u003e 时，尝试转换为 \u003ccode\u003estd::string\u003c/code\u003e。若 \u003ccode\u003ebad_buffer\u003c/code\u003e 函数退出 (3) 于上述转换完成之前，那么就会产生一个未定义的行为（Undefined Behavior），这是非常危险的。\u003c/p\u003e\n\u003cp\u003e因此，关于线程函数传参的铁律是：\u003cstrong\u003e必须在参数传递给线程构造之前，就转换好格式\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"也需要准备好引用、右值等\"\u003e\u003ca href=\"#也需要准备好引用、右值等\" class=\"headerlink\" title=\"也需要准备好引用、右值等\"\u003e\u003c/a\u003e也需要准备好引用、右值等\u003c/h3\u003e\u003cp\u003e由于传参给 \u003ccode\u003estd::thread\u003c/code\u003e 的过程只是简单的拷贝，当线程函数需要引用或者移动语义的时候，也可能出现问题。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eupdate\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e weight, WeightedData\u0026amp; data)\u003c/span\u003e\u003c/span\u003e; \u003cspan class=\"comment\"\u003e// 1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ebad_update\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e weight)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    WeightedData data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003estd::thread \u003cspan class=\"title\"\u003ewk_t\u003c/span\u003e\u003cspan class=\"params\"\u003e(update, weight, data)\u003c/span\u003e\u003c/span\u003e;     \u003cspan class=\"comment\"\u003e// 2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    t.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprocess\u003c/span\u003e(data);                              \u003cspan class=\"comment\"\u003e// 3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e代码的意图是通过引用 (1)，在子线程中更新 \u003ccode\u003edata\u003c/code\u003e 的权值 (2)。然而，由于 (2) 对 \u003ccode\u003edata\u003c/code\u003e 的处理是简单的拷贝，因此实际上线程函数得到的引用，是对「线程存储空间中的拷贝的引用」。于是，(3) 处理的 \u003ccode\u003edata\u003c/code\u003e，实际是未有更新的数据。这种情况未必会报错，但是却埋下了难以排查的隐患。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eupdate\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e weight, WeightedData\u0026amp; data)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ebad_update\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e weight)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    WeightedData data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003estd::thread \u003cspan class=\"title\"\u003ewk_t\u003c/span\u003e\u003cspan class=\"params\"\u003e(update, weight, std::ref(data)\u003cspan class=\"comment\"\u003e/* #include \u0026lt;functional\u0026gt; */\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    t.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprocess\u003c/span\u003e(data);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e类似地，对于一些不可拷贝的类型，我们需要准备好移动语义——在传参的时候，使用 \u003ccode\u003estd::move()\u003c/code\u003e 得到右值，传递给 \u003ccode\u003estd::thread\u003c/code\u003e 的构造函数。\u003c/p\u003e\n\u003ch3 id=\"以非静态成员函数为线程函数\"\u003e\u003ca href=\"#以非静态成员函数为线程函数\" class=\"headerlink\" title=\"以非静态成员函数为线程函数\"\u003e\u003c/a\u003e以非静态成员函数为线程函数\u003c/h3\u003e\u003cp\u003e类的非静态成员函数也是函数，因而也可以作为线程函数使用。不过，相比一般的函数（包括静态成员函数），将其作为线程函数使用时，有两个特殊之处。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e必须显式地使用函数指针，作为 \u003ccode\u003estd::thread\u003c/code\u003e 构造函数的第一个参数；\u003c/li\u003e\n\u003cli\u003e非静态成员函数的第一个参数，实际上是类实例的指针，在创建线程时，需要显式地填入这个参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFoo\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ebar\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003edemo\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    Foo baz;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    std::thread \u003cspan class=\"type\"\u003etemp_t\u003c/span\u003e{\u0026amp;Foo::bar, \u0026amp;baz};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003etemp_t\u003c/span\u003e.\u003cspan class=\"built_in\"\u003ejoin\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此外，必须说明的是，脱离了实例的非静态成员函数是没有意义的。因此，在将非静态成员函数作为线程函数时，必须保证对应的实例可用。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-05-16T12:21:18Z",
  "Author": "Liam Huang"
}