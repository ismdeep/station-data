{
  "Source": "liam.page",
  "Title": "程序员的自我修养（⑪）：C++ 的内存顺序·上",
  "Link": "https://liam.page/2021/06/06/memory-order-cpp-01/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e此篇继\u003ca href=\"/2021/06/05/memory-model-cpp/\"\u003e前文\u003c/a\u003e讨论内存模型，继续讨论 C++ 的内存顺序。类似地，文中内容基本上是 CPP reference 上\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e对应页面\u003c/a\u003e术语部分的翻译，有删减和补充。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e线程间同步及内存顺序决定表达式的\u003cins\u003e求值（evaluations）\u003c/ins\u003e及其\u003cins\u003e副作用（side effects）\u003c/ins\u003e在不同线程中的顺序。首先有相关术语的定义。\u003c/p\u003e\n\u003ch2 id=\"消费操作（consume-operation）\"\u003e\u003ca href=\"#消费操作（consume-operation）\" class=\"headerlink\" title=\"消费操作（consume operation）\"\u003e\u003c/a\u003e消费操作（consume operation）\u003c/h2\u003e\u003cp\u003e配置了 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e\u003ccode\u003estd::memory_order_consume\u003c/code\u003e\u003c/a\u003e 或更强的内存顺序的原子读操作是消费操作（consume operation）。\u003c/p\u003e\n\u003cp\u003e注意：\u003ccode\u003estd::atomic_thread_fence\u003c/code\u003e 引入的同步机制比消费操作更强。\u003c/p\u003e\n\u003ch2 id=\"占有操作（aquire-operation）\"\u003e\u003ca href=\"#占有操作（aquire-operation）\" class=\"headerlink\" title=\"占有操作（aquire operation）\"\u003e\u003c/a\u003e占有操作（aquire operation）\u003c/h2\u003e\u003cp\u003e配置了 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e\u003ccode\u003estd::memory_order_acquire\u003c/code\u003e\u003c/a\u003e 或更强的内存顺序的原子读操作是占有操作（aquire operation）。在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/named_req/Mutex\"\u003e互斥量（mutex）\u003c/a\u003e上执行 \u003ccode\u003elock()\u003c/code\u003e 操作亦属于占有操作。\u003c/p\u003e\n\u003cp\u003e注意：\u003ccode\u003estd::atomic_thread_fence\u003c/code\u003e 引入的同步机制比占有操作更强。\u003c/p\u003e\n\u003ch2 id=\"释放操作（release-operation）\"\u003e\u003ca href=\"#释放操作（release-operation）\" class=\"headerlink\" title=\"释放操作（release operation）\"\u003e\u003c/a\u003e释放操作（release operation）\u003c/h2\u003e\u003cp\u003e配置了 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e\u003ccode\u003estd::memory_order_release\u003c/code\u003e\u003c/a\u003e 或更强的内存顺序的原子读操作是释放操作（release operation）。在\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/named_req/Mutex\"\u003e互斥量（mutex）\u003c/a\u003e上执行 \u003ccode\u003eunlock()\u003c/code\u003e 操作亦属于释放操作。\u003c/p\u003e\n\u003cp\u003e注意：\u003ccode\u003estd::atomic_thread_fence\u003c/code\u003e 引入的同步机制比释放操作更强。\u003c/p\u003e\n\u003ch2 id=\"表达式求值（evaluations-of-expressions）\"\u003e\u003ca href=\"#表达式求值（evaluations-of-expressions）\" class=\"headerlink\" title=\"表达式求值（evaluations of expressions）\"\u003e\u003c/a\u003e表达式求值（evaluations of expressions）\u003c/h2\u003e\u003cp\u003e对一个表达式\u003cins\u003e求值（evaluation）\u003c/ins\u003e包含以下两个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cins\u003e值计算（value computations）\u003c/ins\u003e：计算表达式的返回值。其中可能涉及到对象的识别（identity of the object；左值求值）或是读取对象中保存的值（右值求值）。前者例如返回某个对象的引用，后者例如返回一个数值。\u003c/li\u003e\n\u003cli\u003e\u003cins\u003e副作用（side effect）\u003c/ins\u003e：通过一个易变左值访问（读/写）对象；修改对象；调用函数库中的 I/O 函数；或调用包含上述操作的其他函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"先序（sequenced-before）关系\"\u003e\u003ca href=\"#先序（sequenced-before）关系\" class=\"headerlink\" title=\"先序（sequenced-before）关系\"\u003e\u003c/a\u003e先序（sequenced-before）关系\u003c/h2\u003e\u003cp\u003e先序关系描述同一个线程中两次求值之间的偏序关系。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若 A \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B，则 A 将在 B 开始执行之前完成。\u003c/li\u003e\n\u003cli\u003e若 A 不先序于 B，而 B 先序于 A，则 B 将在 A 开始执行之前完成。\u003c/li\u003e\n\u003cli\u003e若 A 不先序于 B 而 B 亦不先序于 A，则有两种可能性\u003cul\u003e\n\u003cli\u003eA 和 B 的求值不存在序列关系：二者可能以任意顺序求值，并且它们的求值动作在时间上可能重叠（在同一线程中，编译器可能打乱组成 A 和 B 的指令的顺序，使他们相互穿插）。\u003c/li\u003e\n\u003cli\u003eA 和 B 的求值序列关系不确定：二者可能以任意顺序求值，但它们的求值动作在时间上不可能重叠。此外，程序再次执行时，二者的执行顺序可能和上一次不同。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"带去依赖（Carries-dependency）\"\u003e\u003ca href=\"#带去依赖（Carries-dependency）\" class=\"headerlink\" title=\"带去依赖（Carries dependency）\"\u003e\u003c/a\u003e带去依赖（Carries dependency）\u003c/h2\u003e\u003cp\u003e在同一线程中，若 A \u003cins\u003e先序于\u003c/ins\u003e B，则在下列情况下，A 为 B 带去依赖（即，B 依赖于 A）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA 的返回值是 B 的操作数，但下列情形除外：\u003cul\u003e\n\u003cli\u003eB 是对 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/kill_dependency\"\u003e\u003ccode\u003estd::kill_dependency\u003c/code\u003e\u003c/a\u003e 的调用；\u003c/li\u003e\n\u003cli\u003eA 的返回值是内建 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e, \u003ccode\u003e||\u003c/code\u003e, \u003ccode\u003e?:\u003c/code\u003e 或是 \u003ccode\u003e,\u003c/code\u003e 运算符的左操作数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e执行 A 的过程中写入标量 M，而执行 B 的过程读取标量 M。\u003c/li\u003e\n\u003cli\u003eA 为 X 带去依赖，而 X 为 B 带去依赖。（即依赖关系具有传递性）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"修改顺序（Modification-Order）\"\u003e\u003ca href=\"#修改顺序（Modification-Order）\" class=\"headerlink\" title=\"修改顺序（Modification Order）\"\u003e\u003c/a\u003e修改顺序（Modification Order）\u003c/h2\u003e\u003cp\u003e对于某个原子变量来说，其全部写入操作组成一个全局修改顺序。\u003c/p\u003e\n\u003cp\u003e所有原子操作都保证符合以下四个要求：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e写写一致性：若对原子变量 M 的写入操作 A \u003cins\u003e先于（happens-before）\u003c/ins\u003e对同一原子变量的写入操作 B。则在 M 的\u003cins\u003e修改顺序（modification order）\u003c/ins\u003e中，A 在 B 之前。\u003c/li\u003e\n\u003cli\u003e读读一致性：若 A 和 B 的值计算均读取原子变量 M，且 A \u003cins\u003e先于\u003c/ins\u003e B；又假定 A 读到的原子变量 M 的值来自某个对 M 有写操作的表达式 X；则 B 读到的值，要么来自 X 的写入，要么来自在 M 的\u003cins\u003e修改顺序（modification order）\u003c/ins\u003e中晚于 X 的某个写入 Y。\u003c/li\u003e\n\u003cli\u003e读写一致性：若 A 的值计算读取原子变量 M 而 B 写入 M，且 A \u003cins\u003e先于\u003c/ins\u003e B；则 A 读到的值来自在 M 的\u003cins\u003e修改顺序（modification order）\u003c/ins\u003e中早于 B 的某个写入 X。\u003c/li\u003e\n\u003cli\u003e写读一致性：若 X 对原子变量 M 有写入，而 B 的值计算读取原子变量 M；又假定 X \u003cins\u003e先于\u003c/ins\u003e B；则 B 读到的值要么来自 X 的写入，要么来自在 M 的\u003cins\u003e修改顺序（modification order）\u003c/ins\u003e中晚于 X 的某个写入 Y。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"释放序列（Release-sequence）\"\u003e\u003ca href=\"#释放序列（Release-sequence）\" class=\"headerlink\" title=\"释放序列（Release sequence）\"\u003e\u003c/a\u003e释放序列（Release sequence）\u003c/h2\u003e\u003cp\u003e假定 A 是原子变量 M 上的一个\u003cins\u003e释放操作（release operation）\u003c/ins\u003e。则在 M 的修改顺序中，\u003cstrong\u003e位于 A 之后\u003c/strong\u003e的由下列操作组成的最长连续子序列被称为以 A 为首的\u003cins\u003e释放序列（release sequence）\u003c/ins\u003e：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e执行 A 的线程中，对 M 的写入操作（until C++20）；\u003c/li\u003e\n\u003cli\u003e任意线程对 M 的读-改-写操作（CAS 成功时的操作）。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"依赖顺序上先于（Dependency-ordered-before）\"\u003e\u003ca href=\"#依赖顺序上先于（Dependency-ordered-before）\" class=\"headerlink\" title=\"依赖顺序上先于（Dependency-ordered before）\"\u003e\u003c/a\u003e依赖顺序上先于（Dependency-ordered before）\u003c/h2\u003e\u003cp\u003e满足下列某个情况时，我们称表达式 A 在\u003cins\u003e依赖顺序上先于（dependency-ordered before）\u003c/ins\u003e表达式 B——其中 A 和 B 处于不同线程。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA 对原子变量 M 执行\u003cins\u003e释放操作（release operation）\u003c/ins\u003e，在另一线程中 B 对同一原子变量 M 执行\u003cins\u003e消费操作（consume operation）\u003c/ins\u003e，且 B 读取的值来自 A（以 A 为首的\u003cins\u003e释放序列（release sequence）\u003c/ins\u003e中的任意部分（until C++20））的写入。\u003c/li\u003e\n\u003cli\u003eA 在依赖顺序上先于 X，而 X 为 B 带去依赖。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"线程间先于（Inter-thread-happens-before）\"\u003e\u003ca href=\"#线程间先于（Inter-thread-happens-before）\" class=\"headerlink\" title=\"线程间先于（Inter-thread happens-before）\"\u003e\u003c/a\u003e线程间先于（Inter-thread happens-before）\u003c/h2\u003e\u003cp\u003e若满足下列条件之一，则称对表达式 A 的求值\u003cins\u003e线程间先于（inter-thread happens-before）\u003c/ins\u003e对表达式 B 的求值：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA 与 B \u003cins\u003e同步（synchronizes-with）\u003c/ins\u003e；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e依赖顺序上先于\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA 与某个表达式 X \u003cins\u003e同步\u003c/ins\u003e，而 X \u003cins\u003e先序于\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e先序于\u003c/ins\u003e 某个表达式 X 的求值，而 X \u003cins\u003e线程间先于\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e线程间先于\u003c/ins\u003e 某个表达式 X 的求值，而 X \u003cins\u003e线程间先于\u003c/ins\u003e B。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"先于（happens-before）\"\u003e\u003ca href=\"#先于（happens-before）\" class=\"headerlink\" title=\"先于（happens-before）\"\u003e\u003c/a\u003e先于（happens-before）\u003c/h2\u003e\u003cp\u003e无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值\u003cins\u003e先于（happens-before）\u003c/ins\u003e对表达式 B 的求值：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e线程间先于（inter-thread happens-before）\u003c/ins\u003e B。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e编译器实现应当引入必要的同步措施，以保证表达式求值之间的先于关系链不成环。（仅当引入消费操作（consume operation）时有此必要；参见 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.cl.cam.ac.uk/~pes20/cpp/popl085ap-sewell.pdf\"\u003eBetty 等的论文\u003c/a\u003e）\u003c/p\u003e\n\u003cp\u003e若某个求值操作修改了一个内存位置（见\u003ca href=\"/2021/06/05/memory-model-cpp/\"\u003e前文\u003c/a\u003e），另一个求值操作读写同一内存位置，且至少其一不是原子操作，除非二者之间存在\u003cins\u003e先于\u003c/ins\u003e关系，程序行为未定义（程序有数据竞争）。\u003c/p\u003e\n\u003ch2 id=\"简单先于（Simply-happens-before；since-C-20）\"\u003e\u003ca href=\"#简单先于（Simply-happens-before；since-C-20）\" class=\"headerlink\" title=\"简单先于（Simply happens-before；since C++20）\"\u003e\u003c/a\u003e简单先于（Simply happens-before；since C++20）\u003c/h2\u003e\u003cp\u003e无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值\u003cins\u003e简单先于（happens-before）\u003c/ins\u003e对表达式 B 的求值：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA 与 B \u003cins\u003e同步（synchronizes-with）\u003c/ins\u003e；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e简单先于\u003c/ins\u003e 某个表达式 X 的求值，而 X \u003cins\u003e简单先于\u003c/ins\u003e B。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e注：没有消费操作（consume operation）时，简单先于等价于先于。\u003c/p\u003e\n\u003ch2 id=\"强先于（Strongly-happens-before）\"\u003e\u003ca href=\"#强先于（Strongly-happens-before）\" class=\"headerlink\" title=\"强先于（Strongly happens-before）\"\u003e\u003c/a\u003e强先于（Strongly happens-before）\u003c/h2\u003e\u003cp\u003e无论线程情况如何，若满足下列条件之一，则称对表达式 A 的求值\u003cins\u003e强先于（strongly happens-before）\u003c/ins\u003e对表达式 B 的求值：\u003c/p\u003e\n\u003ch3 id=\"until-C-20\"\u003e\u003ca href=\"#until-C-20\" class=\"headerlink\" title=\"until C++20\"\u003e\u003c/a\u003euntil C++20\u003c/h3\u003e\u003col\u003e\n\u003cli\u003eA \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA 与 B \u003cins\u003e同步（synchronizes-with）\u003c/ins\u003e；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e强先于\u003c/ins\u003e 某个表达式 X 的求值，而 X \u003cins\u003e强先于\u003c/ins\u003e B。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e注：C++20 之前的强先于，即是 C++20 及之后的简单先于。\u003c/p\u003e\n\u003ch3 id=\"since-C-20\"\u003e\u003ca href=\"#since-C-20\" class=\"headerlink\" title=\"since C++20\"\u003e\u003c/a\u003esince C++20\u003c/h3\u003e\u003col\u003e\n\u003cli\u003eA \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA 与 B \u003cins\u003e同步（synchronizes-with）\u003c/ins\u003e，且 A/B 均为顺序一致（sequentially consistent）的原子操作；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e X，X \u003cins\u003e简单先于\u003c/ins\u003e Y，Y \u003cins\u003e先序于（sequenced-before）\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003eA \u003cins\u003e强先于\u003c/ins\u003e 某个表达式 X 的求值，而 X \u003cins\u003e强先于\u003c/ins\u003e B。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e注：不正式地讲，若 A \u003cins\u003e强先于（strongly happens-before）\u003c/ins\u003e B，则在任何上下文中，A 都先于 B 求值。\u003c/p\u003e\n\u003cp\u003e注：强先于关系排除了消费操作（consume operation）。\u003c/p\u003e\n\u003ch2 id=\"可见副作用（Visible-side-effects）\"\u003e\u003ca href=\"#可见副作用（Visible-side-effects）\" class=\"headerlink\" title=\"可见副作用（Visible side-effects）\"\u003e\u003c/a\u003e可见副作用（Visible side-effects）\u003c/h2\u003e\u003cp\u003e若下列条件均成立，则 A 对于标量 M 的副作用（写操作）于在标量 M 上的求值 B（读操作）可见：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eA \u003cins\u003e先于\u003c/ins\u003e B；\u003c/li\u003e\n\u003cli\u003e任意满足 A \u003cins\u003e先于\u003c/ins\u003e X 且 X \u003cins\u003e先于\u003c/ins\u003e B 的表达式 X 对标量 M 没有副作用。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e若 A 的副作用对 B 可见，则在 M 的修改顺序当中 B 之前的最长连续副作用子集称之为 B 可见的副作用序列。（B 见到的 M 的值是上述副作用其中之一写入的）\u003c/p\u003e\n\u003cp\u003e注：线程间同步本质是要通过建立\u003cins\u003e先于（happens-before）\u003c/ins\u003e关系来避免数据竞争以及定义在哪些条件下哪些副作用可见。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-06-06T04:16:06Z",
  "Author": "Liam Huang"
}