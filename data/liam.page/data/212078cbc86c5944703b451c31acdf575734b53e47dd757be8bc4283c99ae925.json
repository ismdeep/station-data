{
  "Source": "liam.page",
  "Title": "Python envoy 模块源码剖析",
  "Link": "https://liam.page/2016/09/25/review-of-envoy/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eKenneth Reitz 是公认的这个世界上 Python 代码写得最好的人之一。抱着学习的心态，我阅读了 Reitz 写的 \u003ccode\u003eenvoy\u003c/code\u003e 模块的源码，将笔记记录如下。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"介绍\"\u003e\u003ca href=\"#介绍\" class=\"headerlink\" title=\"介绍\"\u003e\u003c/a\u003e介绍\u003c/h2\u003e\u003cp\u003e和 \u003ccode\u003erequests\u003c/code\u003e 模块一样，\u003ccode\u003eenvoy\u003c/code\u003e 也是 Reitz 的作品，连官方描述都类似——Python Subprocesses for Humans。\u003c/p\u003e\n\u003cp\u003e实际上，\u003ccode\u003eenvoy\u003c/code\u003e 的核心代码非常少，总共只有不到 300 行代码，只是简单的对标准库 \u003ccode\u003esubprocess\u003c/code\u003e 的封装。但是，所谓短小精干，\u003ccode\u003eenvoy\u003c/code\u003e 实现的接口简单易用，比裸用 \u003ccode\u003esubprocess\u003c/code\u003e 方便不少。\u003c/p\u003e\n\u003ch2 id=\"背景知识\"\u003e\u003ca href=\"#背景知识\" class=\"headerlink\" title=\"背景知识\"\u003e\u003c/a\u003e背景知识\u003c/h2\u003e\u003cp\u003e在讲 \u003ccode\u003eenvoy\u003c/code\u003e 的代码之前，我们先回顾一些背景知识。\u003c/p\u003e\n\u003ch3 id=\"程序和进程\"\u003e\u003ca href=\"#程序和进程\" class=\"headerlink\" title=\"程序和进程\"\u003e\u003c/a\u003e程序和进程\u003c/h3\u003e\u003cp\u003e在计算机科学及相关领域，经常能看到程序和进程的概念。有些人不清楚它们的差别，混为一谈。这是不好的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e程序：一般是一组CPU指令的集合构成的文件，静态存储在诸如硬盘之类的存储设备上。\u003c/li\u003e\n\u003cli\u003e进程：当一个程序要被计算机运行时，就是在内存中产生该程序的一个运行时实例，我们就把这个实例叫做进程。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e简单来说，程序就是编译出来的二进制可执行文件，比如 Windows 里的 \u003ccode\u003e.exe\u003c/code\u003e 文件，*nix 里的 ELF 文件。操作系统将它们装载到内存空间并执行时的实例，就是进程。\u003cstrong\u003e程序和进程之间隔着一个「装载」的步骤\u003c/strong\u003e。\u003c/p\u003e\n\u003ch3 id=\"Linux-里的进程\"\u003e\u003ca href=\"#Linux-里的进程\" class=\"headerlink\" title=\"Linux 里的进程\"\u003e\u003c/a\u003eLinux 里的进程\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003e以下实验均在 CentOS 5.4 环境下操作。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e首先，我们在终端里执行\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eps -eo pid,ppid,\u003cspan class=\"built_in\"\u003ecomm\u003c/span\u003e,cmd | less\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里 \u003ccode\u003eps\u003c/code\u003e 命令用来查询正在运行的进程，\u003ccode\u003e-e\u003c/code\u003e 表示我们想要查看所有的进程，\u003ccode\u003e-o\u003c/code\u003e 则选择我们想查看的列名称。这里我们查看 \u003ccode\u003epid\u003c/code\u003e, \u003ccode\u003eppid\u003c/code\u003e, \u003ccode\u003ecomm\u003c/code\u003e, \u003ccode\u003ecmd\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/python/review_envoy_01.png\"/\u003e\u003c/p\u003e\n\u003cp\u003e在这个输出结果中，每一行代表一个进程（表头除外），共分为 4 列。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePID: Process IDentity，进程在当前系统中的唯一识别码，相当于我们的身份证号。\u003c/li\u003e\n\u003cli\u003ePPID: Parent PID，父进程的 PID。\u003c/li\u003e\n\u003cli\u003eCOMMAND: 进程的简称。\u003c/li\u003e\n\u003cli\u003eCMD: \u003cstrong\u003e进程对应的程序\u003c/strong\u003e及其运行时所带的参数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"从计算机启动到进程的创建\"\u003e\u003ca href=\"#从计算机启动到进程的创建\" class=\"headerlink\" title=\"从计算机启动到进程的创建\"\u003e\u003c/a\u003e从计算机启动到进程的创建\u003c/h3\u003e\u003cp\u003e计算机启动时，首先会从主板上的 \u003cstrong\u003eBIOS\u003c/strong\u003e (Basic Input/Output System) 中执行程序，从某个设备（比如软盘、硬盘、光盘、网络等）上启动计算机。而后，计算机会定位到所选的设备上，读取开头的 512 字节里的 \u003cstrong\u003eMBR\u003c/strong\u003e (Master Boot Record)。MBR 里记录着从存储设备启动 \u003cstrong\u003eBoot Loader\u003c/strong\u003e 的具体分区和位置。Boot Loder 里记录着操作系统名称、内核所在位置等信息，启动 Boot Loader 之后，它会帮我们\u003cstrong\u003e加载 Kernel\u003c/strong\u003e。内核负责两件事：对下负责管理硬件，对上负责提供系统调用。于是，内核首先会\u003cstrong\u003e预留自己运行所需的内存空间\u003c/strong\u003e，然后调用**驱动程序 (drivers)**检测计算机硬件，最后启动 \u003ccode\u003einit\u003c/code\u003e 进程，并将控制权交给这个进程。在 Linux 里，\u003ccode\u003einit\u003c/code\u003e 的 PID 是 \u003ccode\u003e1\u003c/code\u003e。\u003ccode\u003einit\u003c/code\u003e 进程负责设置计算机名称、时区，检测文件系统，挂载硬盘，清空临时文件，设置网络等操作。通常意义上说，当 \u003ccode\u003einit\u003c/code\u003e 完成这些工作，计算机就算启动完成了。\u003c/p\u003e\n\u003cp\u003e我们小结一下，计算机启动的流程是：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eBIOS -\u0026gt; MBR -\u0026gt; Boot Loader -\u0026gt; Kernel -\u0026gt; 预留内存空间 -\u0026gt; drivers -\u0026gt; \u003ccode\u003einit\u003c/code\u003e -\u0026gt; settings\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e我们知道，运行于操作系统上的进程（包括 \u003ccode\u003einit\u003c/code\u003e）与操作系统交互，都是通过\u003cstrong\u003e系统调用\u003c/strong\u003e来完成的。然而 Linux 并没有提供创建新进程的系统调用。实际上，Linux 里创建新的进程这一动作，是通过 \u003ccode\u003efork\u003c/code\u003e 和 \u003ccode\u003eexec\u003c/code\u003e 两个函数来实现的。\u003c/p\u003e\n\u003cp\u003e我们先来看看 \u003ccode\u003efork\u003c/code\u003e 函数的用法。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003epid_t\u003c/span\u003e pid;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (pid = fork()) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e} \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// ...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e调用 \u003ccode\u003efork\u003c/code\u003e 函数后，新的进程（任务）和当前进程一起从代码的同一位置开始执行：从 \u003ccode\u003efork\u003c/code\u003e 函数获得返回值。在这里，新的进程称为子进程 (Child Process)，当前进程相对应称之为父进程 (Parent Process)。不过，在子进程中，\u003ccode\u003efork\u003c/code\u003e 函数返回 \u003ccode\u003e0\u003c/code\u003e；在父进程中，\u003ccode\u003efork\u003c/code\u003e 函数则返回子进程的 PID。因此，在子进程中，表达式 \u003ccode\u003epid = fork()\u003c/code\u003e 为 \u003ccode\u003efalse\u003c/code\u003e，跳转到后续的 \u003ccode\u003eelse\u003c/code\u003e 语句块继续执行；在父进程中，表达式 \u003ccode\u003epid = fork()\u003c/code\u003e 为 \u003ccode\u003etrue\u003c/code\u003e，继续执行语句块。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efork\u003c/code\u003e 函数的产生子进程的速度非常快。这是因为，通过 \u003ccode\u003efork\u003c/code\u003e 产生的子进程，只是简单地分配了内存空间，并与父进程共享**写时复制 (Copy on Write, COW)**内存空间。这意味着，通过 \u003ccode\u003efork\u003c/code\u003e 产生子进程的过程中，并没有内存中内容的复制，因此速度非常快。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003efork\u003c/code\u003e 产生的子进程，只是父进程的镜像。通过 \u003ccode\u003efork\u003c/code\u003e 的返回值，我们可以在代码里判断是否是子进程。如果是子进程，就可以调用 \u003ccode\u003eexec\u003c/code\u003e 函数，使用新的程序（可执行映像文件）覆盖当前的映像，从而执行新的任务。\u003c/p\u003e\n\u003cp\u003e不难发现，Linux 中所有的进程，不断追溯其父进程，都会最终追溯到 \u003ccode\u003einit\u003c/code\u003e 进程。\u003c/p\u003e\n\u003ch3 id=\"进程的终止\"\u003e\u003ca href=\"#进程的终止\" class=\"headerlink\" title=\"进程的终止\"\u003e\u003c/a\u003e进程的终止\u003c/h3\u003e\u003cp\u003e当一个进程执行 \u003ccode\u003eexit\u003c/code\u003e 函数之后，内核会释放它所打开的文件、占用的内存等资源，然后在操作系统内核中保留一些退出信息\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePID\u003c/li\u003e\n\u003cli\u003eExit Code\u003c/li\u003e\n\u003cli\u003eCPU time taken by the process\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e简而言之，进程退出后，会释放资源，然后在内核里留下一些诊断信息，成为**僵尸进程 (Zombie Process)**。进程退出后，将 PID 留在了操作系统内核中尚未释放。因此，该 PID 是不可以被后续的新进程使用的。因此，在 Linux 的设计中，父进程需要调用 \u003ccode\u003ewait\u003c/code\u003e 或者 \u003ccode\u003ewaitpid\u003c/code\u003e 函数从内核中获取并处理子进程的诊断信息，并释放 PID（清扫僵尸进程）。\u003c/p\u003e\n\u003cp\u003e如果子进程退出时，父进程尚在，但父进程始终不处理子进程退出后留下的僵尸进程，而不断因为业务逻辑产生新的子进程，那么僵尸进程就会不断积累，最终占满所有可用的 PID（没有进程槽了）。这样一来，在操作系统中就无法产生新的子进程了。（参见 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zh.wikipedia.org/wiki/Fork%E7%82%B8%E5%BC%B9\"\u003efork 炸弹\u003c/a\u003e）因此，通过 \u003ccode\u003efork\u003c/code\u003e 函数创建子进程之后，一定要注意 \u003ccode\u003ewait\u003c/code\u003e 子进程。\u003c/p\u003e\n\u003cp\u003e如果父进程退出时，子进程尚在。这时候，没爹没娘的孤儿进程（Orphand Process）就会被 \u003ccode\u003einit\u003c/code\u003e 进程收养，直到它退出后被 \u003ccode\u003einit\u003c/code\u003e 处理。\u003c/p\u003e\n\u003ch2 id=\"envoy-源码剖析\"\u003e\u003ca href=\"#envoy-源码剖析\" class=\"headerlink\" title=\"envoy 源码剖析\"\u003e\u003c/a\u003e\u003ccode\u003eenvoy\u003c/code\u003e 源码剖析\u003c/h2\u003e\u003cp\u003eReitz 的 \u003ccode\u003eenvoy\u003c/code\u003e 项目地址是 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/kennethreitz/envoy\"\u003ehttps://github.com/kennethreitz/envoy\u003c/a\u003e。为了保证本文的长期有效性，我将它 fork 到了这里 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/reviewlib/envoy\"\u003ehttps://github.com/reviewlib/envoy\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eenvoy\u003c/code\u003e 的核心代码保存在 \u003ccode\u003e./envoy/core.py\u003c/code\u003e 当中。我们先就这份代码的语法点做分析，然后讨论它的结构。\u003c/p\u003e\n\u003ch3 id=\"库\"\u003e\u003ca href=\"#库\" class=\"headerlink\" title=\"库\"\u003e\u003c/a\u003e库\u003c/h3\u003e\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e os\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e sys\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e shlex\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e signal\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e subprocess\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e threading\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eimport\u003c/span\u003e traceback\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e最头上的两个 \u003ccode\u003eos\u003c/code\u003e 和 \u003ccode\u003esys\u003c/code\u003e 是常用的标准库，不必多说。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eshlex\u003c/code\u003e 的名字可以分为两部分：\u003ccode\u003esh\u003c/code\u003e 代表 shell；\u003ccode\u003elex\u003c/code\u003e 是一个著名的词法分析器的生成器（lexical analyzer）。运用这个标准库，我们可以很容易地解析出用户需要在子进程中执行的命令。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esignal\u003c/code\u003e 是 Python 里处理 Linux 内核信号的标准库。我们这里主要用它内部定义的信号的值，不涉及它的具体用法。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003esubprocess\u003c/code\u003e 是 Python 中实现子进程的标准库，是 \u003ccode\u003eenvoy\u003c/code\u003e 封装的实际内容。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethreading\u003c/code\u003e 是 Python 中实现多线程的一个标准库。在 \u003ccode\u003eenvoy\u003c/code\u003e 里，我们实际用它来执行 \u003ccode\u003esubprocess.Popen()\u003c/code\u003e 创建子进程并执行任务。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003etraceback\u003c/code\u003e 是 Python 中用来追溯异常的标准库。\u003c/p\u003e\n\u003ch3 id=\"Command-类\"\u003e\u003ca href=\"#Command-类\" class=\"headerlink\" title=\"Command 类\"\u003e\u003c/a\u003e\u003ccode\u003eCommand\u003c/code\u003e 类\u003c/h3\u003e\u003cp\u003e我们来看 \u003ccode\u003eCommand\u003c/code\u003e 类。这是一个模块内部使用的类，\u003ccode\u003eCommand\u003c/code\u003e 类的每个实例都能执行 \u003ccode\u003erun()\u003c/code\u003e 方法，在一个子进程里执行 Shell 命令。\u003c/p\u003e\n\u003cp\u003e初始化函数 \u003ccode\u003e__init__()\u003c/code\u003e 直截了当，只是简单地对各个数据成员赋值。\u003c/p\u003e\n\u003cp\u003e整个类的主要部分是 \u003ccode\u003erun()\u003c/code\u003e 函数，我们仔细深入进去观察一下。\u003c/p\u003e\n\u003cp\u003e第一个值得注意的地方，是对环境变量的处理。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eenviron = \u003cspan class=\"built_in\"\u003edict\u003c/span\u003e(os.environ)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eenviron.update(env \u003cspan class=\"keyword\"\u003eor\u003c/span\u003e {})\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先，作者将 \u003ccode\u003eos.environ\u003c/code\u003e 转换成一个 Python 内建字典，保存在 \u003ccode\u003eenviron\u003c/code\u003e 中。而后，用字典的 \u003ccode\u003eupdate()\u003c/code\u003e 方法，将用户传入的环境变量补充到 \u003ccode\u003eenviron\u003c/code\u003e 中。这里，\u003ccode\u003eupdate()\u003c/code\u003e 方法有两个特点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e输入必须是一个非空的字典，因此作者\u003cstrong\u003e利用短路求值 \u003ccode\u003eenv or {}\u003c/code\u003e 的方式确保「非空」\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e输入的 \u003ccode\u003eenv\u003c/code\u003e 如果有与 \u003ccode\u003eos.environ\u003c/code\u003e 同名的环境变量，则会以 \u003ccode\u003eenv\u003c/code\u003e 中的值为准，否则直接在 \u003ccode\u003eenviron\u003c/code\u003e 中添加键值对。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e利用这两个特点，作者巧妙地实现了程序逻辑。\u003c/p\u003e\n\u003cp\u003e第二个值得注意的地方，是在 \u003ccode\u003erun()\u003c/code\u003e 函数的内部，嵌套定义了 \u003ccode\u003etarget()\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003etarget\u003c/span\u003e():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.process = subprocess.Popen(self.cmd,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            universal_newlines=\u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            shell=\u003cspan class=\"literal\"\u003eFalse\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            env=environ,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            stdin=subprocess.PIPE,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            stdout=subprocess.PIPE,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            stderr=subprocess.PIPE,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            bufsize=\u003cspan class=\"number\"\u003e0\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            cwd=cwd,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e sys.version_info[\u003cspan class=\"number\"\u003e0\u003c/span\u003e] \u0026gt;= \u003cspan class=\"number\"\u003e3\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            self.out, self.err = self.process.communicate(\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"built_in\"\u003einput\u003c/span\u003e = \u003cspan class=\"built_in\"\u003ebytes\u003c/span\u003e(self.data, \u003cspan class=\"string\"\u003e\u0026#34;UTF-8\u0026#34;\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e self.data \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            self.out, self.err = self.process.communicate(self.data)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eexcept\u003c/span\u003e Exception \u003cspan class=\"keyword\"\u003eas\u003c/span\u003e exc:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.exc = exc\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在 Python 中，函数定义是允许嵌套的，不过\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e各个函数有自己的作用域；\u003c/li\u003e\n\u003cli\u003e内层函数优先访问内层作用域的变量，如果内层没有所需变量，则逐层向外寻找所需变量；\u003c/li\u003e\n\u003cli\u003e外层函数不能访问内层函数的变量（对外层函数来说，这是局部变量）；除非内层函数声明变量时加上了 \u003ccode\u003eglobal\u003c/code\u003e 关键字修饰，并且在访问它时已经调用过内层函数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里的 \u003ccode\u003etarget()\u003c/code\u003e 函数定义了我们接到一个执行 Shell 命令的需求时，我们要做哪些事情。依其定义，我们要首先使用 \u003ccode\u003esubprocess.Popen()\u003c/code\u003e 创建一个子进程，并在相应的条件下执行 \u003ccode\u003eself.cmd\u003c/code\u003e。然后调用 \u003ccode\u003eself.process.communicate()\u003c/code\u003e 方法，将 \u003ccode\u003eself.data\u003c/code\u003e 通过管道传给正在 Shell 中执行的程序，并获取程序的标准输出和标准错误。在整个过程中，但凡出现任何问题，都保存在 \u003ccode\u003eself.exc\u003c/code\u003e 当中。这里作者使用了所有异常的基类 \u003ccode\u003eException\u003c/code\u003e，这是因为对于作者来说 \u003cstrong\u003e\u003ccode\u003eself.cmd\u003c/code\u003e 是不可控的，在执行 \u003ccode\u003eself.cmd\u003c/code\u003e 的过程中可能出现任何形式的异常\u003c/strong\u003e。为了能够处理所有异常，作者必须使用 \u003ccode\u003eException\u003c/code\u003e 来处理。\u003c/p\u003e\n\u003cp\u003e第三个值得注意的地方，是作者在工作线程中去实际执行 \u003ccode\u003etarget()\u003c/code\u003e 完成的任务。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ethread = threading.Thread(target=target)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ethread.start()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ethread.join(timeout)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先，作者创建了一个线程，将 \u003ccode\u003etarget()\u003c/code\u003e 函数作为参数传入构造。也就是说，\u003ccode\u003ethread.start()\u003c/code\u003e 实际会执行 \u003ccode\u003etarget()\u003c/code\u003e 函数的代码。而后，作者用 \u003ccode\u003ethread.join(timeout)\u003c/code\u003e 的方式，来处理上层传下来的超时限制。这样，主进程将会阻塞住，直到\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e线程中的任务完成（也就是 \u003ccode\u003etarget()\u003c/code\u003e 中创建的子进程的任务完成）；或者\u003c/li\u003e\n\u003cli\u003e达到超时时间限制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e第四个值得注意的地方，是作者回收和处理在线程中运行的子进程任务的执行状态信息。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e self.exc:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eraise\u003c/span\u003e self.exc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e _is_alive(thread) :\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    _terminate_process(self.process)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    thread.join(kill_timeout)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e _is_alive(thread):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        _kill_process(self.process)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        thread.join()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eself.returncode = self.process.returncode\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e self.out, self.err\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先，子进程可能抛出异常，因此需要捕获和继续向上抛出异常。\u003c/p\u003e\n\u003cp\u003e其次，线程 \u003ccode\u003ethread\u003c/code\u003e 可能因为超时而执行到当前代码，因此通过预定义的 \u003ccode\u003e_is_alive()\u003c/code\u003e 函数来判断线程是正常退出还是扔在超时运行。如果确实超时，那么首先应该终止子进程，然后尝试等待线程超时终止。如果线程仍然还活着，说明线程内的子进程没有被正确终止，那么首先杀死子进程，然后阻塞线程直到它完成。这样的设计，是\u003cstrong\u003e确保子进程和线程都完全停止，防止僵尸进程的出现\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e最后，函数返回标准输出和标准错误的内容。\u003c/p\u003e\n\u003ch3 id=\"Response-类\"\u003e\u003ca href=\"#Response-类\" class=\"headerlink\" title=\"Response 类\"\u003e\u003c/a\u003e\u003ccode\u003eResponse\u003c/code\u003e 类\u003c/h3\u003e\u003cp\u003e我们来看 \u003ccode\u003eResponse\u003c/code\u003e 类。这是一个模块内部使用的类，\u003ccode\u003eResponse\u003c/code\u003e 类的每个实例都是 \u003ccode\u003eCommand\u003c/code\u003e 类的实例调用 \u003ccode\u003erun()\u003c/code\u003e 方法后的执行结果信息。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eResponse\u003c/span\u003e(\u003cspan class=\"title class_ inherited__\"\u003eobject\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003e\u0026#34;\u0026#34;\u0026#34;A command\u0026#39;s response\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003e__init__\u003c/span\u003e(\u003cspan class=\"params\"\u003eself, process=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003esuper\u003c/span\u003e(Response, self).__init__()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self._process = process\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.command = \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.std_err = \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.std_out = \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.status_code = \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.history = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003e__repr__\u003c/span\u003e(\u003cspan class=\"params\"\u003eself\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"built_in\"\u003elen\u003c/span\u003e(self.command):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#39;\u0026lt;Response [{0}]\u0026gt;\u0026#39;\u003c/span\u003e.\u003cspan class=\"built_in\"\u003eformat\u003c/span\u003e(self.command[\u003cspan class=\"number\"\u003e0\u003c/span\u003e])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#39;\u0026lt;Response\u0026gt;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e从只有一个 \u003ccode\u003e__repr__()\u003c/code\u003e 方法可以看出，\u003ccode\u003eResponse\u003c/code\u003e 类几乎只是一个简单的数据结构，提供了可供打印的功能，仅此而已。那么作者为什么要设计这样一个类呢？这里我们留给读者思考。\u003c/p\u003e\n\u003ch3 id=\"expand-args-函数\"\u003e\u003ca href=\"#expand-args-函数\" class=\"headerlink\" title=\"expand_args 函数\"\u003e\u003c/a\u003e\u003ccode\u003eexpand_args\u003c/code\u003e 函数\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eexpand_args(command)\u003c/code\u003e 函数接收一个字符串作为参数，并将之解析为一个个的命令。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003eexpand_args\u003c/span\u003e(\u003cspan class=\"params\"\u003ecommand\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003e\u0026#34;\u0026#34;\u0026#34;Parses command strings and returns a Popen-ready list.\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e# Prepare arguments.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"built_in\"\u003eisinstance\u003c/span\u003e(command, (\u003cspan class=\"built_in\"\u003estr\u003c/span\u003e, unicode)):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        splitter = shlex.shlex(command.encode(\u003cspan class=\"string\"\u003e\u0026#39;utf-8\u0026#39;\u003c/span\u003e))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        splitter.whitespace = \u003cspan class=\"string\"\u003e\u0026#39;|\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        splitter.whitespace_split = \u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        command = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            token = splitter.get_token()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e token:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                command.append(token)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"keyword\"\u003ebreak\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        command = \u003cspan class=\"built_in\"\u003elist\u003c/span\u003e(\u003cspan class=\"built_in\"\u003emap\u003c/span\u003e(shlex.split, command))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e command\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们以 \u003ccode\u003e\u0026#39;cat inFile | sort | uniq\u0026#39;\u003c/code\u003e 为引数，传入 \u003ccode\u003eexpand_args\u003c/code\u003e 函数，分析一下会发生什么。\u003c/p\u003e\n\u003cp\u003e首先，作者用 \u003ccode\u003eshlex.shlex()\u003c/code\u003e 构造了一个词法分析器，并设置以管道符号 \u003ccode\u003e|\u003c/code\u003e 为标志，分割传入的字符串（或者 \u003ccode\u003eunicode\u003c/code\u003e 类型的实例，后不再重复）。加上之后的 \u003ccode\u003ewhile\u003c/code\u003e 循环，这基本相当于执行了 \u003ccode\u003ecommand = command.split(\u0026#39;|\u0026#39;)\u003c/code\u003e 的效果。\u003c/p\u003e\n\u003cp\u003e而后，执行 \u003ccode\u003ecommand = list(map(shlex.split, command))\u003c/code\u003e，调用 \u003ccode\u003eshlex.split\u003c/code\u003e 函数，作用在 \u003ccode\u003ecommand\u003c/code\u003e 的每一个元素上，并返回一个列表，保存在 \u003ccode\u003ecommand\u003c/code\u003e 当中。最后以 \u003ccode\u003ereturn\u003c/code\u003e 将 \u003ccode\u003ecommand\u003c/code\u003e 返回给调用函数。\u003c/p\u003e\n\u003cp\u003e这里的 \u003ccode\u003emap()\u003c/code\u003e 函数接收两个参数\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一个函数\u003c/li\u003e\n\u003cli\u003e一个可迭代的列表\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e然后将函数作用在列表的每一个元素上，并返回一个列表。类似的函数还有 \u003ccode\u003ereduce()\u003c/code\u003e 函数（参考 Google 的 MapReduce 架构）。这里给出两个示例，供体会它们的作用\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003cfigcaption\u003e\u003cspan\u003emap.py\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e#!/usr/bin/env python\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003einIter = [\u003cspan class=\"string\"\u003e\u0026#39;adam\u0026#39;\u003c/span\u003e, \u003cspan class=\"string\"\u003e\u0026#39;LISA\u0026#39;\u003c/span\u003e, \u003cspan class=\"string\"\u003e\u0026#39;barT\u0026#39;\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eregNames = \u003cspan class=\"keyword\"\u003elambda\u003c/span\u003e \u003cspan class=\"built_in\"\u003eiter\u003c/span\u003e: \u003cspan class=\"built_in\"\u003emap\u003c/span\u003e ((\u003cspan class=\"keyword\"\u003elambda\u003c/span\u003e inStr: inStr.capitalize()), \u003cspan class=\"built_in\"\u003eiter\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eprint\u003c/span\u003e regNames (inIter)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cfigure class=\"highlight python\"\u003e\u003cfigcaption\u003e\u003cspan\u003ereduce.py\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e#!/usr/bin/env python\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003einIter = [\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e, \u003cspan class=\"number\"\u003e3\u003c/span\u003e, \u003cspan class=\"number\"\u003e4\u003c/span\u003e, \u003cspan class=\"number\"\u003e5\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprod = \u003cspan class=\"keyword\"\u003elambda\u003c/span\u003e \u003cspan class=\"built_in\"\u003eiter\u003c/span\u003e: reduce ((\u003cspan class=\"keyword\"\u003elambda\u003c/span\u003e x, y: x * y), \u003cspan class=\"built_in\"\u003eiter\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eprint\u003c/span\u003e prod (inIter)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e最后，输入 \u003ccode\u003e\u0026#39;cat inFile | sort | uniq\u0026#39;\u003c/code\u003e 有输出 \u003ccode\u003e[[\u0026#39;cat\u0026#39;, \u0026#39;inFile\u0026#39;], [\u0026#39;sort\u0026#39;], [\u0026#39;uniq\u0026#39;]]\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"run-函数\"\u003e\u003ca href=\"#run-函数\" class=\"headerlink\" title=\"run 函数\"\u003e\u003c/a\u003e\u003ccode\u003erun\u003c/code\u003e 函数\u003c/h3\u003e\u003cp\u003e\u003ccode\u003erun(command, data=None, timeout=None, kill_timeout=None, env=None, cwd=None)\u003c/code\u003e 函数是 \u003ccode\u003eenvoy\u003c/code\u003e 模块的主要接口，用来在子进程里执行 Shell 命令。\u003c/p\u003e\n\u003cp\u003e首先解释一下 \u003ccode\u003erun()\u003c/code\u003e 函数的各个参数的含义\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ecommand\u003c/code\u003e 需要执行的 Shell 命令（可以包含管道，但是不允许包含 \u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e 或者 \u003ccode\u003e;\u003c/code\u003e 之类的符号）；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edata\u003c/code\u003e 通过管道传入 Shell 命令的内容；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etimeout\u003c/code\u003e 子进程执行超时时间；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekill_timeout\u003c/code\u003e 终止子进程失败的超时时间，超过这个时间将直接杀死子进程；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eenv\u003c/code\u003e 环境变量；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecwd\u003c/code\u003e Current Working Directory，工作目录。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003erun\u003c/code\u003e 函数的实现相对来说是平铺直叙的，这里用注释简单说明一下各个部分都做了什么即可。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003erun\u003c/span\u003e(\u003cspan class=\"params\"\u003ecommand, data=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e, timeout=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e, kill_timeout=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e, env=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e, cwd=\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003e\u0026#34;\u0026#34;\u0026#34;Executes a given commmand and returns Response.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    Blocks until process is complete, or timeout is reached.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u0026#39;对 `command` 做词法分析，拆分命令\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    command = expand_args(command)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    history = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e c \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e command:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u0026#39;模拟管道的作用，传入上一程序的标准输出\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"built_in\"\u003elen\u003c/span\u003e(history):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"comment\"\u003e# due to broken pipe problems pass only first 10 KiB\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            data = history[-\u003cspan class=\"number\"\u003e1\u003c/span\u003e].std_out[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e10\u003c/span\u003e*\u003cspan class=\"number\"\u003e1024\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u0026#39;实际在子进程里执行命令\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        cmd = Command(c)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003etry\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            out, err = cmd.run(data, timeout, kill_timeout, env, cwd)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            status_code = cmd.returncode\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eexcept\u003c/span\u003e OSError \u003cspan class=\"keyword\"\u003eas\u003c/span\u003e e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            out, err = \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e, \u003cspan class=\"string\"\u003eu\u0026#34;\\n\u0026#34;\u003c/span\u003e.join([e.strerror, traceback.format_exc()])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            status_code = \u003cspan class=\"number\"\u003e127\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u0026#39;将执行结果保存在 `history` 当中\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        r = Response(process=cmd)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        r.command = c\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        r.std_out = out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        r.std_err = err\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        r.status_code = status_code\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        history.append(r)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"string\"\u003e\u0026#39;\u0026#39;\u0026#39;函数返回最后一个管道（如果有）之后命令的输出和详细情况\u0026#39;\u0026#39;\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    r = history.pop()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    r.history = history\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e r\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"模块设计分析\"\u003e\u003ca href=\"#模块设计分析\" class=\"headerlink\" title=\"模块设计分析\"\u003e\u003c/a\u003e模块设计分析\u003c/h3\u003e\u003cp\u003eKenneth Reitz \u003cstrong\u003e不愧\u003c/strong\u003e是公认的这个世界上 Python 代码写得最好的人之一——虽然 \u003ccode\u003eenvoy\u003c/code\u003e 是对 \u003ccode\u003esubprocess\u003c/code\u003e 的简单封装，功能有限，但是代码结构非常优雅，内部实现的逐层封装十分完善。\u003c/p\u003e\n\u003cp\u003e对于模块的用户（程序员）来说，\u003ccode\u003eenvoy\u003c/code\u003e 几乎只有 \u003ccode\u003erun\u003c/code\u003e 这一个入口。而它的作用也很明确：开一个子进程，执行一条 Shell 命令，然后在规定时间内取得执行结果——中间的脏活累活（处理异常、超时、主进程阻塞等待、保存历史等等），\u003ccode\u003eenvoy\u003c/code\u003e 都帮你做好了。\u003c/p\u003e\n\u003cp\u003e对于 \u003ccode\u003erun()\u003c/code\u003e 函数来说，它只需要知道执行 \u003ccode\u003eout, err = cmd.run()\u003c/code\u003e 就能在子进程里执行用户需要的命令，然后将结果存在 \u003ccode\u003eResponse\u003c/code\u003e 里就可以了。\u003c/p\u003e\n\u003cp\u003e对于 \u003ccode\u003eCommand.run()\u003c/code\u003e 函数来说，它只需要处理好环境变量，执行 \u003ccode\u003etarget()\u003c/code\u003e 最后处理超时、异常、收集结果信息就可以了。\u003c/p\u003e\n\u003cp\u003e对于 \u003ccode\u003etarget()\u003c/code\u003e 来说，这是一个嵌套定义的函数，它才是真正 \u003ccode\u003efork\u003c/code\u003e 子进程并执行 Shell 命令的函数。\u003c/p\u003e\n\u003cp\u003e不难发现，每个层次完成的任务，几乎都可以用简单一句话解释清楚\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eenvoy.run()\u003c/code\u003e - 将 Shell 命令交给它，就会在子进程里执行这些命令并处理好返回结果；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCommand.run()\u003c/code\u003e - 将一个具体的 Shell 命令（不包含管道）交给它，就会在子进程里执行这些命令并处理好返回结果；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etarget()\u003c/code\u003e - \u003ccode\u003efork\u003c/code\u003e 一个子进程，然后在子进程里开心地执行命令。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种符合 *nix 哲学的设计，造就了优雅好用的 \u003ccode\u003eenvoy\u003c/code\u003e 库。对于程序员来说，将命令交给它，然后坐等结果就可以了。无愧于 Python Subprocesses for Humans 的豪言壮语。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-09-25T03:48:07Z",
  "Author": "Liam Huang"
}