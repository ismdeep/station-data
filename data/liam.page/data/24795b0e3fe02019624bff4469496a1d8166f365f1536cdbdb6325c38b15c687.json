{
  "Source": "liam.page",
  "Title": "Linux top 命令里的内存相关字段（VIRT, RES, SHR, CODE, DATA）",
  "Link": "https://liam.page/2020/07/17/memory-stat-in-TOP/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eLinux 系统中，著名的 \u003ccode\u003etop\u003c/code\u003e 命令可列出各个进程对系统资源的利用情况。其中有 \u003ccode\u003eVIRT\u003c/code\u003e, \u003ccode\u003eRES\u003c/code\u003e, \u003ccode\u003eSHR\u003c/code\u003e, \u003ccode\u003eCODE\u003c/code\u003e, \u003ccode\u003eDATA\u003c/code\u003e 等几个字段，用来描述进程对内存的使用情况。（后二者默认不展示，需要按下 F 键，将相关字段调出来）。\u003c/p\u003e\n\u003cp\u003e但它们究竟表示什么含义呢？\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"top-命令的文档\"\u003e\u003ca href=\"#top-命令的文档\" class=\"headerlink\" title=\"top 命令的文档\"\u003e\u003c/a\u003e\u003ccode\u003etop\u003c/code\u003e 命令的文档\u003c/h2\u003e\u003cp\u003e执行 \u003ccode\u003eman top\u003c/code\u003e 可查看 \u003ccode\u003etop\u003c/code\u003e 命令的手册。可见这些字段的含义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eVIRT\u003c/code\u003e Virtual Memory Size (KiB)：进程使用的所有虚拟内存；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRES\u003c/code\u003e Resident Memory Size (KiB)：进程所占用的所有实体内存（physical memory），不包括被换出到交换区的部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSHR\u003c/code\u003e Shared Memory Size (KiB)：进程可读的全部共享内存，并非所有部分都包含在 \u003ccode\u003eRES\u003c/code\u003e 中。它反映了可能被其他进程共享的内存部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCODE\u003c/code\u003e Code Size (KiB)：进程所占用的实体内存中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDATA\u003c/code\u003e Data + Stack Size (KiB)：进程所占用的实体内存中，除去可执行代码所占用部分之外的内存大小。此项亦称为驻存数据集合（Data Resident Set, DRS）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e但是，真的这样吗？\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/captures/top.jpg\"/\u003e\u003c/p\u003e\n\u003cp\u003e按照 \u003ccode\u003etop\u003c/code\u003e 命令的手册，应有等式 \u003ccode\u003eCODE + DATA = RES\u003c/code\u003e 成立。但这里，进程号为 22 的进程，\u003ccode\u003eCODE\u003c/code\u003e 为 59,984KiB，\u003ccode\u003eDATA\u003c/code\u003e 为 42.076GiB，\u003ccode\u003eRES\u003c/code\u003e 为 5.348GiB。显然不满足上述等式。\u003c/p\u003e\n\u003ch2 id=\"top-命令的数据源\"\u003e\u003ca href=\"#top-命令的数据源\" class=\"headerlink\" title=\"top 命令的数据源\"\u003e\u003c/a\u003e\u003ccode\u003etop\u003c/code\u003e 命令的数据源\u003c/h2\u003e\u003cp\u003e经查，\u003ccode\u003etop\u003c/code\u003e 命令读取的是 \u003ccode\u003e/proc/\u0026lt;pid\u0026gt;/statm\u003c/code\u003e 当中的数据。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e你可以通过 \u003ccode\u003ecat /proc/\u0026lt;pid\u0026gt;/statm\u003c/code\u003e 来查看。它有 7 列，分别是以内存页计算的 \u003ccode\u003eVIRT\u003c/code\u003e, \u003ccode\u003eRES\u003c/code\u003e, \u003ccode\u003eSHR\u003c/code\u003e, \u003ccode\u003eCODE\u003c/code\u003e, LRS, \u003ccode\u003eDATA\u003c/code\u003e, DIRTY。其中 LRS 和 DIRTY 自 Linux 2.6 开始不再使用。内存页的大小是 4KiB，因此，将内存页的数量乘以 4，就是以 KiB 计算的内存占用大小。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e而 \u003ccode\u003e/proc/\u0026lt;pid\u0026gt;/statm\u003c/code\u003e 当中的数据，是经过内核函数 \u003ccode\u003etask_statm\u003c/code\u003e 读取而后由 \u003ccode\u003eprocfs\u003c/code\u003e 写入的。\u003c/p\u003e\n\u003cp\u003e我们来看看\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/fs/proc/task_mmu.c#L87-L98\"\u003e内核函数 \u003ccode\u003etask_statm\u003c/code\u003e\u003c/a\u003e 是怎样定义的：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e \u003cspan class=\"title\"\u003etask_statm\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e mm_struct *mm,\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e       \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e *shared, \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e *text,\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"params\"\u003e\u003cspan class=\"function\"\u003e       \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e *data, \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e *resident)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  *shared = \u003cspan class=\"built_in\"\u003eget_mm_counter\u003c/span\u003e(mm, MM_FILEPAGES) +\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"built_in\"\u003eget_mm_counter\u003c/span\u003e(mm, MM_SHMEMPAGES);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  *text = (\u003cspan class=\"built_in\"\u003ePAGE_ALIGN\u003c/span\u003e(mm-\u0026gt;end_code) - (mm-\u0026gt;start_code \u0026amp; PAGE_MASK))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u0026gt;\u0026gt; PAGE_SHIFT;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  *data = mm-\u0026gt;data_vm + mm-\u0026gt;stack_vm;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  *resident = *shared + \u003cspan class=\"built_in\"\u003eget_mm_counter\u003c/span\u003e(mm, MM_ANONPAGES);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e mm-\u0026gt;total_vm;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里 \u003ccode\u003eget_mm_counter\u003c/code\u003e 实际啥也没干，就是保证读取计数器的原子性——这是因为读取的是实体内存占用情况。\u003c/p\u003e\n\u003cp\u003e由此可知，并不一定有等式 \u003ccode\u003eCODE + DATA = RES\u003c/code\u003e 成立，但一定成立等式 \u003ccode\u003eANON = RES - SHR\u003c/code\u003e。这里 \u003ccode\u003eANON\u003c/code\u003e 表示在堆上分配的内存。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L1843-L1856\"\u003e\u003ccode\u003eget_mm_counter\u003c/code\u003e 在 \u003ccode\u003emm.h\u003c/code\u003e 中定义\u003c/a\u003e：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003estatic\u003c/span\u003e \u003cspan class=\"keyword\"\u003einline\u003c/span\u003e \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e \u003cspan class=\"title\"\u003eget_mm_counter\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e mm_struct *mm, \u003cspan class=\"type\"\u003eint\u003c/span\u003e member)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003elong\u003c/span\u003e val = \u003cspan class=\"built_in\"\u003eatomic_long_read\u003c/span\u003e(\u0026amp;mm-\u0026gt;rss_stat.count[member]);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eifdef\u003c/span\u003e SPLIT_RSS_COUNTING\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"comment\"\u003e/*\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e   * counter is updated in asynchronous manner and may go to minus.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e   * But it\u0026#39;s never be expected number for users.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e   */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (val \u0026lt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    val = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003eendif\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e (\u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e)val;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e可见 \u003ccode\u003eget_mm_counter\u003c/code\u003e 其实啥也没干，就是保证读取计数器的原子性。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c!--\n* \u003chttps://github.com/torvalds/linux/blob/cbafe18c71028d5e0ee1626b4776fea5d5824a78/include/linux/mm_types_task.h\u003e\n* \u003chttps://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548\u003e\n --\u003e\n\n\u003cp\u003e从代码可见\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eshared\u003c/code\u003e 是共享文件和动态库占用实体内存页（memory page）之和；它对应 \u003ccode\u003eSHR\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etext\u003c/code\u003e 是代码段占用内存页；它对应 \u003ccode\u003eCODE\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edata\u003c/code\u003e 是 \u003ccode\u003eVM_WRITE \u0026amp; ~VM_SHARED \u0026amp; ~VM_STACK\u003c/code\u003e 与 \u003ccode\u003eVM_STACK\u003c/code\u003e 占用内存页之和，也就是所有非栈内存中可写但非共享内存页与栈内存页之和；它对应 \u003ccode\u003eDATA\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eresident\u003c/code\u003e 是 \u003ccode\u003eshared\u003c/code\u003e 和实体匿名内存页（memory page）之和；它对应 \u003ccode\u003eRES\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003ereturn value 是整个虚拟内存的内存页；它对应 \u003ccode\u003eVIRT\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e从代码来看，\u003ccode\u003eVIRT\u003c/code\u003e, \u003ccode\u003eSHR\u003c/code\u003e, \u003ccode\u003eCODE\u003c/code\u003e, \u003ccode\u003eRES\u003c/code\u003e 与 \u003ccode\u003etop\u003c/code\u003e 命令的手册吻合，区别在于 \u003ccode\u003eDATA\u003c/code\u003e 这个字段——从我们观察到的现象，也确实在 \u003ccode\u003eDATA\u003c/code\u003e 上有明显的问题。\u003c/p\u003e\n\u003ch2 id=\"DATA-之谜\"\u003e\u003ca href=\"#DATA-之谜\" class=\"headerlink\" title=\"DATA 之谜\"\u003e\u003c/a\u003e\u003ccode\u003eDATA\u003c/code\u003e 之谜\u003c/h2\u003e\u003cp\u003e在\u003ca href=\"/2016/05/01/Introduction-to-Memory-Addressing/#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"\u003e老文\u003c/a\u003e中，我们谈到了虚拟内存和物理内存（实体内存）之间的差别与联系。在 Linux 中，进程能直接看到的，都是虚拟内存。\u003c/p\u003e\n\u003cp\u003e对于每一个虚拟内存页，根据其是否有对应的实体内存帧对应，有三种状态：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e该页没有实体内存帧与之对应；记为 vm_unmapped。\u003c/li\u003e\n\u003cli\u003e该页有实体内存帧与之对应，且未被换出到交换区；记为 vm_physic。\u003c/li\u003e\n\u003cli\u003e该页有实体内存帧与之对应，但已被换出到交换区；记为 vm_swap。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在本文讨论的五个字段当中，按照是否有强调为 vm_physic，记录如下：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e\u003ccode\u003etop\u003c/code\u003e 手册\u003c/th\u003e\n\u003cth\u003e内核代码\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eVIRT\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ex\u003c/td\u003e\n\u003ctd\u003ex\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eRES\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSHR\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ex\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eCODE\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eDATA\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003ey\u003c/td\u003e\n\u003ctd\u003ex\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e可见，比较明确的是 \u003ccode\u003eVIRT\u003c/code\u003e, \u003ccode\u003eRES\u003c/code\u003e 和 \u003ccode\u003eCODE\u003c/code\u003e。\u003ccode\u003eSHR\u003c/code\u003e 的情况也比较好理解，内核代码可以明确是只包含实体内存部分，而 \u003ccode\u003etop\u003c/code\u003e 手册里则没有说明，因此我们也将其理解为只包含实体内存部分。\u003c/p\u003e\n\u003cp\u003e现在，需要确认的，就是 \u003ccode\u003eDATA\u003c/code\u003e 了。我们看一下 \u003ccode\u003eDATA\u003c/code\u003e 的实现：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e*data = mm-\u0026gt;data_vm + mm-\u0026gt;stack_vm;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e其中 \u003ccode\u003emm\u003c/code\u003e 是 Linux 的内存描述符，它定义在 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm_types.h#L384-L548\"\u003e\u003ccode\u003elinux/mm_types.h\u003c/code\u003e\u003c/a\u003e 当中，是一个相当大的结构体。其中 \u003ccode\u003edata_vm\u003c/code\u003e 和 \u003ccode\u003estack_vm\u003c/code\u003e 的定义如下：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e data_vm;     \u003cspan class=\"comment\"\u003e/* VM_WRITE \u0026amp; ~VM_SHARED \u0026amp; ~VM_STACK */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e \u003cspan class=\"type\"\u003elong\u003c/span\u003e stack_vm;     \u003cspan class=\"comment\"\u003e/* VM_STACK */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，显然后缀 \u003ccode\u003evm\u003c/code\u003e 表示虚拟内存（Virtual Memory），因此 \u003ccode\u003eDATA\u003c/code\u003e 表示的不只是实体内存占用，这一点是显然的了。接下来的问题是，这里的注释表示什么呢？\u003ccode\u003eVM_WRITE\u003c/code\u003e 等宏，定义在 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/torvalds/linux/blob/a5ad5742f671de906adbf29fbedf0a04705cebad/include/linux/mm.h#L240-L391\"\u003e\u003ccode\u003elinux/mm.h\u003c/code\u003e\u003c/a\u003e 当中。这些宏表示虚拟内存区域（Virtual Memory Area, \u003ccode\u003evm_area\u003c/code\u003e）的属性，由一些 one-hot 的整数来表示。于是，\u003ccode\u003eVM_WRITE \u0026amp; ~VM_SHARED \u0026amp; ~VM_STACK\u003c/code\u003e 表示非栈且非共享的可写虚拟内存区域。因此 \u003ccode\u003eDATA\u003c/code\u003e 字段表达的是虚拟内存中，栈区域与非栈区域中非共享可写区域之和。\u003c/p\u003e\n\u003cp\u003e这也就能解释，为什么 \u003ccode\u003eDATA\u003c/code\u003e 看起来远远大于 \u003ccode\u003eRES\u003c/code\u003e 了。因为 \u003ccode\u003eRES\u003c/code\u003e 是实际占用的实体内存大小，而 \u003ccode\u003eDATA\u003c/code\u003e 计算的是数据部分占用虚拟内存的大小。后者可能包含了大量实际没有与实体内存帧映射的虚拟内存页，从而导致看起来虚高。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e\u003ca href=\"#总结\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h2\u003e\u003cp\u003e\u003ccode\u003etop\u003c/code\u003e 的手册关于 \u003ccode\u003eDATA\u003c/code\u003e 的说明是错的，有 bug。更新如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eVIRT\u003c/code\u003e Virtual Memory Size (KiB)：进程使用的所有\u003cstrong\u003e虚拟内存\u003c/strong\u003e；包括代码（code）、数据（data）、共享库（shared libraries），以及被换出（swap out）到交换区和映射了（map）但尚未使用（未载入实体内存）的部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eRES\u003c/code\u003e Resident Memory Size (KiB)：进程所占用的所有\u003cstrong\u003e实体内存\u003c/strong\u003e（physical memory），不包括被换出到交换区的部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSHR\u003c/code\u003e Shared Memory Size (KiB)：进程可读的全部共享\u003cstrong\u003e实体内存\u003c/strong\u003e，并非所有部分都包含在 \u003ccode\u003eRES\u003c/code\u003e 中。它反映了可能被其他进程共享的内存部分。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eCODE\u003c/code\u003e Code Size (KiB)：进程所占用的\u003cstrong\u003e实体内存\u003c/strong\u003e中，可执行代码所占用的内存大小。此项亦称为驻存代码集合（Text Resident Set, TRS）。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDATA\u003c/code\u003e Data + Stack Size (KiB)：进程所占用的\u003cstrong\u003e虚拟内存\u003c/strong\u003e中，栈区域与非栈区域中非共享可写区域之和。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不一定有等式 \u003ccode\u003eCODE + DATA = RES\u003c/code\u003e 成立，但一定成立等式 \u003ccode\u003eANON = RES - SHR\u003c/code\u003e 及不等式 \u003ccode\u003eANON \u0026lt;= DATA (vm_physic) \u0026lt;= DATA\u003c/code\u003e。如果观察到程序稳定运行时 \u003ccode\u003eRES - SHR\u003c/code\u003e 不断增长，则可能预示着程序存在内存泄漏现象。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-07-17T07:30:36Z",
  "Author": "Liam Huang"
}