{
  "Source": "liam.page",
  "Title": "在 C++ 中移除序列中连续重复的特定值",
  "Link": "https://liam.page/2019/01/27/remove-consecutive-duplicates-in-Cxx/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e最近在写 YTL 中的字符串相关辅助函数。实现到 \u003ccode\u003esplit\u003c/code\u003e 函数时，希望能够实现类似 Python 当中的 \u003ccode\u003estr.split\u003c/code\u003e 方法的功能。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf \u003ccode\u003esep\u003c/code\u003e is not specified or is \u003ccode\u003eNone\u003c/code\u003e, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.\u003cbr/\u003e——\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://docs.python.org/3/library/stdtypes.html#str.split\"\u003ehttps://docs.python.org/3/library/stdtypes.html#str.split\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e也就是说，在最基本的 \u003ccode\u003esplit\u003c/code\u003e 的基础上，要添加两个功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e删除输入字符串首尾的空白；\u003c/li\u003e\n\u003cli\u003e将字符串中的连续分隔符当成一个分隔符看待。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e前一个功能很好实现。将空白符保存在 \u003ccode\u003econst char* trim_chars = \u0026#34; \\t\\n\\r\\v\\f\u0026#34;\u003c/code\u003e 当中，然后使用 \u003ccode\u003estd::string::find_first_not_of\u003c/code\u003e 以及 \u003ccode\u003estd::string::find_last_not_of\u003c/code\u003e 即可找到有效内容的起止位置，最后再 \u003ccode\u003estd::string::erase\u003c/code\u003e 一下就好了。\u003c/p\u003e\n\u003cp\u003e后一个功能也不复杂。但要写得优雅——最好是能利用上标准库的设施——就不那么容易了。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"std-unique-的基本用法\"\u003e\u003ca href=\"#std-unique-的基本用法\" class=\"headerlink\" title=\"std::unique 的基本用法\"\u003e\u003c/a\u003e\u003ccode\u003estd::unique\u003c/code\u003e 的基本用法\u003c/h2\u003e\u003cp\u003e\u003ccode\u003estd::unique\u003c/code\u003e 是定义在 \u003ccode\u003ealgorithm\u003c/code\u003e 头文件内的容器算法。它有两种基本形式：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e ForwardIt \u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003eForwardIt \u003cspan class=\"title\"\u003eunique\u003c/span\u003e\u003cspan class=\"params\"\u003e( ForwardIt first, ForwardIt last )\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e ForwardIt, \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e BinaryPredicate \u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003eForwardIt \u003cspan class=\"title\"\u003eunique\u003c/span\u003e\u003cspan class=\"params\"\u003e( ForwardIt first, ForwardIt last, BinaryPredicate p )\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e其中，第一种形式是第二种形式的特例，它等价于 \u003ccode\u003eBinaryPredicate p\u003c/code\u003e 为连续两元素相等性判断时的第二种形式：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eForwardIt\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e          \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eBinaryPredicate\u003c/span\u003e =\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            std::function\u0026lt;\u003cspan class=\"built_in\"\u003ebool\u003c/span\u003e(\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e std::iterator_traits\u0026lt;ForwardIt\u0026gt;::value_type\u0026amp;,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e              \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e std::iterator_traits\u0026lt;ForwardIt\u0026gt;::value_type\u0026amp;)\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eForwardIt \u003cspan class=\"built_in\"\u003eunique\u003c/span\u003e( ForwardIt first, ForwardIt last,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            BinaryPredicate p = [](\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e std::iterator_traits\u0026lt;ForwardIt\u0026gt;::value_type\u0026amp; lhs,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                   \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e std::iterator_traits\u0026lt;ForwardIt\u0026gt;::value_type\u0026amp; rhs) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e lhs == rhs; });\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这也就是说，第一种形式的 \u003ccode\u003estd::unique\u003c/code\u003e 会找到每个连续重复的区间，而后保留这些区间的首个元素，最后返回新序列逻辑上的尾后迭代器。例如，\u003ccode\u003eaabbccaa\u003c/code\u003e 经过 \u003ccode\u003estd::unique\u003c/code\u003e 处理之后得到：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eabca????\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ↑\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里用箭头标出的位置，即是 \u003ccode\u003estd::unique\u003c/code\u003e 的返回值所指向的位置。需要注意的是，经过 \u003ccode\u003estd::unique\u003c/code\u003e 处理之后，容器的实际大小没有发生改变，甚至逻辑尾后迭代器到容器实际尾后迭代器之间的左闭右开区间内的迭代器仍然是可解引用的（dereferenceable）。但这部分区间内的元素的值是不确定的。因此，在使用 \u003ccode\u003estd::unqiue\u003c/code\u003e 之后，往往会调用容器的 \u003ccode\u003eerase\u003c/code\u003e 函数成员，删除逻辑尾后迭代器开始的所有元素。例如：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003estd::string \u003cspan class=\"title\"\u003esource\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"string\"\u003e\u0026#34;aabbccaa\u0026#34;\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esource.\u003cspan class=\"built_in\"\u003eerase\u003c/span\u003e(std::\u003cspan class=\"built_in\"\u003eunique\u003c/span\u003e(source.\u003cspan class=\"built_in\"\u003ebegin\u003c/span\u003e(), source.\u003cspan class=\"built_in\"\u003eend\u003c/span\u003e()), source.\u003cspan class=\"built_in\"\u003eend\u003c/span\u003e());\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::cout \u0026lt;\u0026lt; source \u0026lt;\u0026lt; std::endl;  \u003cspan class=\"comment\"\u003e// expect result: abca\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"只对特定内容进行-std-unique-操作\"\u003e\u003ca href=\"#只对特定内容进行-std-unique-操作\" class=\"headerlink\" title=\"只对特定内容进行 std::unique 操作\"\u003e\u003c/a\u003e只对特定内容进行 \u003ccode\u003estd::unique\u003c/code\u003e 操作\u003c/h2\u003e\u003cp\u003e回到最开始的问题。我们需要的功能，是针对分隔符 \u003ccode\u003esep\u003c/code\u003e 进行操作，将连续出现的 \u003ccode\u003esep\u003c/code\u003e 压缩成一个。\u003ccode\u003estd::unique\u003c/code\u003e 的默认行为则不然，它会将所有连续出现的元素都压缩成一个——不光是 \u003ccode\u003esep\u003c/code\u003e。为此，我们需要实现自己的 \u003ccode\u003eBinaryPredicate\u003c/code\u003e。首先，由于我们要指定具体需要被 \u003ccode\u003estd::unique\u003c/code\u003e 压缩的元素，我们必然要将其作为函数参数传入函数。于是我们有以下实现：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;functional\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e T\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e \u003cspan class=\"title\"\u003eAreConsecutiveElements\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003econst\u003c/span\u003e T\u0026amp; target, \u003cspan class=\"type\"\u003econst\u003c/span\u003e T\u0026amp; lhs, \u003cspan class=\"type\"\u003econst\u003c/span\u003e T\u0026amp; rhs)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e (lhs == rhs) \u003cspan class=\"built_in\"\u003eand\u003c/span\u003e (lhs == target);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003estd::unique\u003c/code\u003e 要求一个二元谓词（\u003ccode\u003eBinaryPredicate\u003c/code\u003e），但此处我们实现的是三元谓词。于是，好在 \u003ccode\u003etarget\u003c/code\u003e 总是应当预先给出的，所以我们可以利用 \u003ccode\u003estd::bind\u003c/code\u003e 将 \u003ccode\u003etarget\u003c/code\u003e 绑定在 \u003ccode\u003eAreConsecutiveElements\u003c/code\u003e 的第一个参数上，产生一个二元谓词。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;functional\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// using namespace std::placeholders;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;string\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// #include \u0026lt;algorithm\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003echar\u003c/span\u003e target = \u003cspan class=\"string\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e binp = std::\u003cspan class=\"built_in\"\u003ebind\u003c/span\u003e(AreConsecutiveElements, target, _1, _2);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003estd::string \u003cspan class=\"title\"\u003esource\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"string\"\u003e\u0026#34;aabbccaa\u0026#34;\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esource.\u003cspan class=\"built_in\"\u003eerase\u003c/span\u003e(std::\u003cspan class=\"built_in\"\u003eunique\u003c/span\u003e(source.\u003cspan class=\"built_in\"\u003ebegin\u003c/span\u003e(), source.\u003cspan class=\"built_in\"\u003eend\u003c/span\u003e(), binp), source.\u003cspan class=\"built_in\"\u003eend\u003c/span\u003e());\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::cout \u0026lt;\u0026lt; source \u0026lt;\u0026lt; std::endl;  \u003cspan class=\"comment\"\u003e// expect result: aabccaa\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，我们将 \u003ccode\u003e\u0026#39;b\u0026#39;\u003c/code\u003e 作为压缩目标，并将其与 \u003ccode\u003eAreConsecutiveElements\u003c/code\u003e 绑定在一起，产生一个新的二元谓词。最终输出期待的结果。\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2 id=\"附：std-unique-的一个可能实现\"\u003e\u003ca href=\"#附：std-unique-的一个可能实现\" class=\"headerlink\" title=\"附：std::unique 的一个可能实现\"\u003e\u003c/a\u003e附：\u003ccode\u003estd::unique\u003c/code\u003e 的一个可能实现\u003c/h2\u003e\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e ForwardIt, \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e BinaryPredicate\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003eForwardIt \u003cspan class=\"title\"\u003eunique\u003c/span\u003e\u003cspan class=\"params\"\u003e(ForwardIt first, ForwardIt last, BinaryPredicate p)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (first == last) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e last;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ForwardIt result = first;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e (++first != last) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"built_in\"\u003ep\u003c/span\u003e(*result, *first) \u0026amp;\u0026amp; ++result != first) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      *result = std::\u003cspan class=\"built_in\"\u003emove\u003c/span\u003e(*first);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e ++result;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003c!-- 今天是老女人邢坤悦的 28 岁生日。但邢坤悦是个婊子，我肏烂她全家女性的骚屄。 --\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-01-27T06:02:18Z",
  "Author": "Liam Huang"
}