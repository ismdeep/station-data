{
  "Source": "liam.page",
  "Title": "记 C 语言词法分析中的贪心法",
  "Link": "https://liam.page/2017/01/31/traps-in-lexical-analysis-of-C/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e很早以前就知道，编译器做的工作，首先就是读入源码，而后进行词法分析（有预处理的语言，还要先经过预处理器）。但是，一直没有对 C 语言的词法分析过程进行过深入了解。今天又拿起 Koenig 的《C 陷阱与缺陷》，才又读到相关的说明。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"说明\"\u003e\u003ca href=\"#说明\" class=\"headerlink\" title=\"说明\"\u003e\u003c/a\u003e说明\u003c/h2\u003e\u003cp\u003e所谓词法分析，就是编译器将源码中的字符串切分，变成一个个记号（token）的过程。所谓的记号，就相当于是英文中单词的地位；因此也有翻译将它译作单词。这个过程，其实很简单：无非就是顺序读入源码文件，而后挨个切分就好了。但是，看似简单的问题，往往就会有意料之外的事情发生。\u003c/p\u003e\n\u003cp\u003e举一个简单的例子。在 C 语言中，\u003ccode\u003e-\u003c/code\u003e 是一个记号，它表示「负号」或者「减号」；同时 \u003ccode\u003e\u0026gt;\u003c/code\u003e 也是一个记号，它表示「大于号」。麻烦之处在于，\u003ccode\u003e-\u0026gt;\u003c/code\u003e 也是一个记号，它是「成员运算符」；那么，当编译器遇到 \u003ccode\u003e-\u0026gt;\u003c/code\u003e 的时候，是将它作为一个记号 \u003ccode\u003e-\u0026gt;\u003c/code\u003e 呢？还是作为两个记号 \u003ccode\u003e-\u003c/code\u003e 和 \u003ccode\u003e\u0026gt;\u003c/code\u003e 呢？回答这个问题，应当是不难的。答案显而易见，它应当被看做是一个完整的成员运算符，而不是一个减号紧接着一个大于号。\u003c/p\u003e\n\u003cp\u003e然而，这个答案背后的原理，值得思考：编译器遇到此类可能存在歧义的情况，适用怎样的规则，以保证行为的一致性呢？C 编译器采用了所谓的\u003cstrong\u003e贪心法\u003c/strong\u003e（或者，大嘴法）来处理这些情况：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入一个字符：\u003cul\u003e\n\u003cli\u003e如果它是一个单字符记号，并且不能与其它字符组成记号，那么将它作为记号加入队列，继续读入下一个字符；\u003c/li\u003e\n\u003cli\u003e如果它是一个单字符记号，而且可能与其它字符组成记号，那么先读入下一个字符：\u003cul\u003e\n\u003cli\u003e如果它能与先前读入的字符组成记号，那么将它们一起作为记号加入队列，继续读入下一个字符；\u003c/li\u003e\n\u003cli\u003e如果它不能与先前读入的字符组成记号，那么：\u003cul\u003e\n\u003cli\u003e如果至今为止尚未组成记号的字符，也不能作为其他记号的组成部分，则将先前读入的字符作为单字符记号加入队列，并依先例，继续处理当前字符；\u003c/li\u003e\n\u003cli\u003e否则，继续读入下一个字符，尝试拼接更长的符号。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e或者，简单来说就是\u003cstrong\u003e如果输入流截至某个字符，之前的字符都已经被分解为一个个记号，那么下一个记号，应该是从这个字符起可能组成记号的最长字符串对应的记号\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"例子\"\u003e\u003ca href=\"#例子\" class=\"headerlink\" title=\"例子\"\u003e\u003c/a\u003e例子\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ea---b\u003c/code\u003e 表示 \u003ccode\u003e(a--) - b\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ey = x/*p\u003c/code\u003e 表示 \u003ccode\u003ey = x[注释开始]p\u003c/code\u003e，而不是 \u003ccode\u003ey = x / (*p)\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"启发\"\u003e\u003ca href=\"#启发\" class=\"headerlink\" title=\"启发\"\u003e\u003c/a\u003e启发\u003c/h2\u003e\u003cp\u003e这个来自编译器词法分析器的陷阱应当引起注意，对于程序员来说，写代码应该养成良好的习惯：合理使用空格、括号，以避免可能的歧义造成难以排查的错误。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e不好好些空格、括号的程序员，都应该拉出去打屁屁。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-01-31T02:31:55Z",
  "Author": "Liam Huang"
}