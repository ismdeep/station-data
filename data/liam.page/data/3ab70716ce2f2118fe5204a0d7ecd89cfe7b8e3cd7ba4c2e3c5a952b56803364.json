{
  "Source": "liam.page",
  "Title": "像递归一样的函数模板调用",
  "Link": "https://liam.page/2019/02/19/recursive-like-function-template-calling/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e遇到一个蛮奇葩的问题：在 C++ 中如何不用循环和递归，打印从 1 至 N 的自然数？\u003c/p\u003e\n\u003cp\u003e想了想，用模板元编程可以解决——让编译器在编译期把该打印的东西都展开就好了。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e直接上代码好了……\u003c/p\u003e\n\u003cfigure class=\"highlight c++\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"type\"\u003eint\u003c/span\u003e N\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003ecounting\u003c/span\u003e\u003cspan class=\"params\"\u003e(std::ostream\u0026amp; os)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"built_in\"\u003ecounting\u003c/span\u003e\u0026lt;N - \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u0026gt;(os);  \u003cspan class=\"comment\"\u003e// *\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  os \u0026lt;\u0026lt; N \u0026lt;\u0026lt; std::endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"built_in\"\u003ecounting\u003c/span\u003e\u0026lt;\u003cspan class=\"number\"\u003e1\u003c/span\u003e\u0026gt;(std::ostream\u0026amp; os) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  os \u0026lt;\u0026lt; \u003cspan class=\"number\"\u003e1\u003c/span\u003e \u0026lt;\u0026lt; std::endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e N = \u003cspan class=\"number\"\u003e10\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"built_in\"\u003ecounting\u003c/span\u003e\u0026lt;N\u0026gt;(std::cout);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，(*) 处有类似递归的调用。但由于 \u003ccode\u003ecounting\u003c/code\u003e 是函数模板，所以 \u003ccode\u003ecounting\u0026lt;N\u0026gt;\u003c/code\u003e 调用的 \u003ccode\u003ecounting\u0026lt;N - 1\u0026gt;\u003c/code\u003e 并非自身，因此不是递归。\u003c/p\u003e\n\u003cp\u003e编译器在实例化 \u003ccode\u003ecounting\u0026lt;N\u0026gt;\u003c/code\u003e 的时候，由于它调用了 \u003ccode\u003ecounting\u0026lt;N - 1\u0026gt;\u003c/code\u003e，所以在编译期会递归地实例化下去——直到遇见全特化的 \u003ccode\u003ecounting\u0026lt;1\u0026gt;\u003c/code\u003e 为止。这段代码利用了编译器在编译期的递归替代运行期的递归，巧妙地绕过了原始问题的限制。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e类似的手段也可以运用在类模板上。在 YTL 的 \u003ccode\u003etraits\u003c/code\u003e 库当中就有这样的运用。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e不过要注意，既然是递归，就有可能爆栈。编译器递归实例化的深度是有限制的。\u003ccode\u003eclang 3.4\u003c/code\u003e 的默认限制是 256 层而 \u003ccode\u003egcc 8.2\u003c/code\u003e 的默认限制是 900 层。超过这一限制会引发编译器 Fatal error 而编译失败。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-02-19T08:02:59Z",
  "Author": "Liam Huang"
}