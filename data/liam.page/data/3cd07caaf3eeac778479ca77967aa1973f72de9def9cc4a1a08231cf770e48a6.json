{
  "Source": "liam.page",
  "Title": "反编译 Android 程序小记",
  "Link": "https://liam.page/2015/07/21/decompile-android-application/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e使用 QQ 这么多年，管理的群越来越多。现在每天被入群申请搞得烦不胜烦，于是萌生了写一个 QQ 机器人的想法。\u003c/p\u003e\n\u003cp\u003e要想实现一个 QQ 机器人，首先是要在程序里模拟登录。经过整理，可用的思路有两个：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 WebQQ 的方式登录，模拟浏览器的行为；\u003c/li\u003e\n\u003cli\u003e使用 Android QQ 的方式登录，模拟 Android 客户端的行为。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e二者各有利弊。使用 WebQQ 方式登录协议相对简单，网络上也有\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://hfutfei.iteye.com/blog/800866\"\u003e相关分析\u003c/a\u003e；但是 WebQQ 不能与电脑上的 QQ 共存：登录 WebQQ 就会将电脑上的登录踢下线。使用 Android QQ 的方式登录，由于没有现成的资料可供查询，实现起来十分复杂；但是 Android QQ 是手机端 QQ，可以与电脑端 QQ 共存。\u003c/p\u003e\n\u003cp\u003e「要做就做好」。思前想后，我还是决定使用 Android QQ 的方式登录。于是问题来了，怎样去抓取 Android QQ 的行为呢？\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 Android QQ 外围进行抓包分析，然后让程序伪装成 Android QQ 向腾讯的服务器发包；\u003c/li\u003e\n\u003cli\u003e直接读 Android QQ 的源代码，然后仿照着相关内容重新实现。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e方案 1 是常规方法，若能顺利实施，无非是不断重复抓包 - 分析 - 伪造的步骤。不过 QQ 的通信信息是加密处理过的，抓包分析比较费劲。因此，我决定尝试反编译 Android 程序，直接阅读源代码。\u003c/p\u003e\n\u003cp\u003e这里我介绍反编译安卓程序，得到 Java 代码的详细方法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e请尊重他人劳动成果，勿将此方法用于恶意活动。\u003c/strong\u003e\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"解包-apk\"\u003e\u003ca href=\"#解包-apk\" class=\"headerlink\" title=\"解包 .apk\"\u003e\u003c/a\u003e解包 \u003ccode\u003e.apk\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zh.wikipedia.org/wiki/APK\"\u003eAPK\u003c/a\u003e 是 Application Package File 的缩写。\u003ccode\u003e.apk\u003c/code\u003e 文件的实质是一个 \u003ccode\u003e.zip\u003c/code\u003e 压缩包，包含 Android 运行 APP 所需以下内容：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e编译好的代码文件 \u003ccode\u003e.dex\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eassets\u003c/code\u003e 目录\u003c/li\u003e\n\u003cli\u003e证书\u003c/li\u003e\n\u003cli\u003e文件资源（\u003ccode\u003eresources.arsc\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e文件清单（\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e想要得到源码，首先需要解包 \u003ccode\u003e.apk\u003c/code\u003e 文件。\u003cstrong\u003e我们只需要将后缀名从 \u003ccode\u003e.apk\u003c/code\u003e 改为 \u003ccode\u003e.zip\u003c/code\u003e，然后按照常规方式解压即可\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"处理-AndroidManifest-xml\"\u003e\u003ca href=\"#处理-AndroidManifest-xml\" class=\"headerlink\" title=\"处理 AndroidManifest.xml\"\u003e\u003c/a\u003e处理 \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e 是一个传统的Android清单文件，用于描述该应用程序的名字、版本号、所需权限、注册的服务、链接的其他应用程序。为了搞清楚程序到底做了什么，我们有必要知道这个文件的具体内容。\u003c/p\u003e\n\u003cp\u003e如果用文本编辑器打开 \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e，我们会发现其中是一堆乱码。\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"//liam.page/attachment/attachment/images/Android/AndroidManifest-Mojibake.png\" alt=\"AndroidManifest.xml 乱码\"/\u003e\u003c/p\u003e\n\u003cp\u003e实际上，\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e 已经被处理成二进制格式，我们用文本模式打开它乱码是理所应当的。为了正确读取其中内容，我们需要用 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://code.google.com/p/android4me/downloads/list\"\u003eAXMLPrinter2\u003c/a\u003e 这个工具对它进行处理，将它还原成文本格式。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://code.google.com/p/android4me/downloads/detail?name=AXMLPrinter2.jar\u0026amp;can=2\u0026amp;q=\"\u003eAXMLPrinter2 官方下载\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"//liam.page/attachment/attachment/Android/AXMLPrinter2.jar\"\u003e预防 Google Code 关闭准备的备用链接\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e之后我们需要运行\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ejava -jar AXMLPrinter2.jar AndroidManifest.xml \u0026gt; AndroidManifest.txt\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e将二进制格式的 \u003ccode\u003eAndroidManifest.xml\u003c/code\u003e 转换为文本格式，并保存在 \u003ccode\u003eAndroidManifest.txt\u003c/code\u003e 之中。这样我们就能阅读其中信息了。\u003c/p\u003e\n\u003ch2 id=\"处理-dex-文件\"\u003e\u003ca href=\"#处理-dex-文件\" class=\"headerlink\" title=\"处理 .dex 文件\"\u003e\u003c/a\u003e处理 \u003ccode\u003e.dex\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e\u003ccode\u003e.dex\u003c/code\u003e 文件是 Java 标准的 classes 文件通过 DEX 编译后的文件格式，是用于在 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://zh.wikipedia.org/wiki/Dalvik%E8%99%9A%E6%8B%9F%E6%9C%BA\"\u003eDalvik 虚拟机\u003c/a\u003e上运行的主要代码部分。显而易见，这是我们需要处理的重头戏。\u003c/p\u003e\n\u003cp\u003e处理 \u003ccode\u003e.dex\u003c/code\u003e 文件就是要将其还原为 Java 标准的 \u003ccode\u003e.jar\u003c/code\u003e 文件。为此我们需要用到 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/pxb1988/dex2jar\"\u003e\u003ccode\u003edex2jar\u003c/code\u003e\u003c/a\u003e 这个工具。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/pxb1988/dex2jar/releases\"\u003e\u003ccode\u003edex2jar\u003c/code\u003e 官方下载\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"//liam.page/attachment/attachment/Android/dex-tools-2.0.zip\"\u003e预防 GitHub 不能用的备用链接\u003c/a\u003e（版本 2.0，\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/pxb1988/dex2jar/commit/a9126a95ad613c4021cb37930823b1281ec5414a\"\u003e\u003ccode\u003ea9126a9\u003c/code\u003e\u003c/a\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e解压后，我们在命令行中运行\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e/path/to/dex-tools/d2j-dex2jar.sh *.dex\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eWindows 用户运行\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\\path\\to\\dex-tools\\d2j-dex2jar.bat *.dex\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e就能得到 \u003ccode\u003eclasses.dex\u003c/code\u003e 相应的 \u003ccode\u003eclasses-dex2jar.jar\u003c/code\u003e 文件。\u003c/p\u003e\n\u003ch2 id=\"处理-jar-文件，得到-Java-源码\"\u003e\u003ca href=\"#处理-jar-文件，得到-Java-源码\" class=\"headerlink\" title=\"处理 .jar 文件，得到 Java 源码\"\u003e\u003c/a\u003e处理 \u003ccode\u003e.jar\u003c/code\u003e 文件，得到 Java 源码\u003c/h2\u003e\u003cp\u003e\u003ccode\u003e.jar\u003c/code\u003e 文件是 \u003ccode\u003e.class\u003c/code\u003e 文件的封装。\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://jd.benow.ca/\"\u003ejd-gui\u003c/a\u003e 这个小工具可以以图形化的界面查看 \u003ccode\u003e.jar\u003c/code\u003e 当中 \u003ccode\u003e.class\u003c/code\u003e 文件对应的 Java 源码。所得结果可读性非常高。\u003c/p\u003e\n\u003cp\u003e下载地址：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/java-decompiler/jd-gui/releases/download/v1.3.0/jd-gui-windows-1.3.0.zip\"\u003eWindows 版 - 官方\u003c/a\u003e - \u003ca href=\"//liam.page/attachment/attachment/Android/jd-gui-windows-1.3.0.zip\"\u003e备用\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/java-decompiler/jd-gui/releases/download/v1.3.0/jd-gui-osx-1.3.0.tar\"\u003eMac 版 - 官方\u003c/a\u003e - \u003ca href=\"//liam.page/attachment/attachment/Android/jd-gui-osx-1.3.0.tar\"\u003e备用\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用 jd-gui 打开上一步得到的 \u003ccode\u003e.jar\u003c/code\u003e 文件，就能看到 \u003ccode\u003e.class\u003c/code\u003e 对应的 Java 源码了。\u003c/p\u003e\n\u003cp\u003e\u003cimg data-src=\"//liam.page/attachment/attachment/images/Android/jd-gui-view.png\" alt=\"使用 jd-gui 查看 Java 源码\"/\u003e\u003c/p\u003e\n\u003cp\u003e按下快捷键 \u003ccode\u003eCommand + Option + S\u003c/code\u003e 保存源码就好啦。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2015-07-21T13:43:10Z",
  "Author": "Liam Huang"
}