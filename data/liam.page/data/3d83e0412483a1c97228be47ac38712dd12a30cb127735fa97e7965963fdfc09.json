{
  "Source": "liam.page",
  "Title": "C 和 C++ 中的指针",
  "Link": "https://liam.page/2017/02/05/pointer-in-C-and-Cpp/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cblockquote\u003e\n\u003cp\u003e指针是 C 语言的精髓。——无名氏\u003cbr/\u003e指针是学业不精的程序员的大杀器。——Liam Huang\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eC 和 C++ 中的指针，是语言中相当犀利的工具。但是它也是一把双刃剑，用得不好，就是毁灭整个工程的大杀器。此篇老调重弹，讲一讲 C 和 C++ 中的指针。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e此篇别名：可能是中文网络中关于 C 和 C++ 指针最好的文章。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"数据、指令和内存\"\u003e\u003ca href=\"#数据、指令和内存\" class=\"headerlink\" title=\"数据、指令和内存\"\u003e\u003c/a\u003e数据、指令和内存\u003c/h2\u003e\u003cp\u003e在冯诺依曼体系中，程序的数据和指令，是存放在同一空间中的。在 Linux 中，它们存放在进程的虚拟内存空间中。（相关内容可以关注「程序员的自我修养」系列文章，目前有：\u003ca href=\"/2016/08/30/review-of-hardware-development/\"\u003e一\u003c/a\u003e/\u003ca href=\"/2016/05/01/Introduction-to-Memory-Addressing/\"\u003e二\u003c/a\u003e/\u003ca href=\"/2017/01/17/fork-safe/\"\u003e三\u003c/a\u003e）因此，对于进程来说，数据和指令其实没有本质的差别；其区别仅在于如何理解和使用虚存空间中的内容——如果读取虚存空间某个位置的值来使用，这块内容就是数据，如果执行虚存空间某个位置的代码，这块内容就是指令。决定如何理解和使用虚存空间中的内容的因素，是类型。具体到 C 和 C++ 语言来说，对应数据的那部分内存，当中存储的自然就是数据；对应函数的那部分内存，当中存储的就是指令。\u003c/p\u003e\n\u003cp\u003e因此，对于虚存空间中的内容来说，有两个关键要素：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e它在哪里（内存地址是多少）；\u003c/li\u003e\n\u003cli\u003e它具有哪些属性、能做哪些事情（它的类型是什么）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"指针是对内存区域的抽象\"\u003e\u003ca href=\"#指针是对内存区域的抽象\" class=\"headerlink\" title=\"指针是对内存区域的抽象\"\u003e\u003c/a\u003e指针是对内存区域的抽象\u003c/h2\u003e\u003cp\u003eC 和 C++ 中的指针，是一种特殊的复合类型。指针变量中存放着目标对象的内存地址，而与指针相复合的类型，则说明了相应内存区域中的内容具有哪些属性，以及能做什么事情。也就是说，在内存空间某块区域中的内容，原本可以是不可解读的；但是，如果有一个描述这块内存区域的指针存在，我们就能找到它（地址的作用），并且\u003cstrong\u003e合理地\u003c/strong\u003e使用它（类型的作用）。因此，我们说：\u003cstrong\u003e指针是对内存区域的抽象\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2 id=\"定义和使用指针\"\u003e\u003ca href=\"#定义和使用指针\" class=\"headerlink\" title=\"定义和使用指针\"\u003e\u003c/a\u003e定义和使用指针\u003c/h2\u003e\u003ch3 id=\"指针的定义\"\u003e\u003ca href=\"#指针的定义\" class=\"headerlink\" title=\"指针的定义\"\u003e\u003c/a\u003e指针的定义\u003c/h3\u003e\u003cp\u003e在 C 和 C++ 中定义指针变量是很简单的，和定义普通的变量基本是一样的。所有的区别，仅在于我们需要在变量名称前使用\u003cstrong\u003e解引用符号 \u003ccode\u003e*\u003c/code\u003e\u003c/strong\u003e 来标记这是一个指针。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *ip1, *ip2;         \u003cspan class=\"comment\"\u003e// ip1 和 ip2 都是指向 int 类型变量的指针变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e d, *dp;          \u003cspan class=\"comment\"\u003e// d 是 double 类型变量，dp 是指向 double 类型变量的指针变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上述定义中，我们看到，\u003ccode\u003eip1\u003c/code\u003e, \u003ccode\u003eip2\u003c/code\u003e, \u003ccode\u003edp\u003c/code\u003e 是三个指针——因为在它们之前用 \u003ccode\u003e*\u003c/code\u003e 号标记处他们是指针；而 \u003ccode\u003ed\u003c/code\u003e 是一个普通的 \u003ccode\u003edouble\u003c/code\u003e 类型变量。同时，我们注意到，\u003ccode\u003eip1\u003c/code\u003e 和 \u003ccode\u003eip2\u003c/code\u003e 在定义之时，就确定了他们是指向 \u003ccode\u003eint\u003c/code\u003e 类型的变量。这意味着，被 \u003ccode\u003eip1\u003c/code\u003e 和 \u003ccode\u003eip2\u003c/code\u003e 指向的内存，\u003cstrong\u003e在使用 \u003ccode\u003eip1\u003c/code\u003e 和 \u003ccode\u003eip2\u003c/code\u003e 进行访问的时候\u003c/strong\u003e，将被当做是 \u003ccode\u003eint\u003c/code\u003e 类型的对象来对待。同理，\u003ccode\u003edp\u003c/code\u003e 指向的内存，\u003cstrong\u003e在使用 \u003ccode\u003edp\u003c/code\u003e 进行访问的时候\u003c/strong\u003e，将被当做是 \u003ccode\u003edouble\u003c/code\u003e 类型的对象来对待。\u003c/p\u003e\n\u003cp\u003e回顾一下，我们在第一节中提到，内存空间中的内容有两个关键要素：地址和类型。在上述定义过程中，我们通过类型与解引用符号 \u003ccode\u003e*\u003c/code\u003e 相结合，已经确定了类型。如果要正确使用指针，我们还应该让指针记录一个地址。\u003c/p\u003e\n\u003ch3 id=\"获取对象的地址\"\u003e\u003ca href=\"#获取对象的地址\" class=\"headerlink\" title=\"获取对象的地址\"\u003e\u003c/a\u003e获取对象的地址\u003c/h3\u003e\u003cp\u003e上面说到，我们应该在定义指针之后，记录一个地址。在 C 和 C++ 中，我们需要使用\u003cstrong\u003e取地址符号 \u003ccode\u003e\u0026amp;\u003c/code\u003e\u003c/strong\u003e 来获取对象的地址。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e val = \u003cspan class=\"number\"\u003e42\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p  = \u0026amp;val;     \u003cspan class=\"comment\"\u003e// \u0026amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e（绝大多数情况下，）指针的类型和对象的类型需要严格匹配。例如，你不能用一个指向 \u003ccode\u003eint\u003c/code\u003e 类型的指针变量，保存一个 \u003ccode\u003edouble\u003c/code\u003e 类型的对象的地址。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e dval = \u003cspan class=\"number\"\u003e0.0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *pd1 = \u0026amp;dval;    \u003cspan class=\"comment\"\u003e// 正确：pd1 保存 double 类型变量 dval 的地址\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *pd2 = pd1;      \u003cspan class=\"comment\"\u003e// 正确：pd1 是 double 类型的指针，可以赋值初始化同样类型的 pd2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *pi1 = \u0026amp;dval;       \u003cspan class=\"comment\"\u003e// 错误：不能用指向 int 类型变量的指针保存 double 类型变量的地址\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *pi2 = pd1;         \u003cspan class=\"comment\"\u003e// 错误：pd1 是 double 类型的指针，不能将其赋值给 int 类型的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"访问指针指向的对象\"\u003e\u003ca href=\"#访问指针指向的对象\" class=\"headerlink\" title=\"访问指针指向的对象\"\u003e\u003c/a\u003e访问指针指向的对象\u003c/h3\u003e\u003cp\u003e在下例中，指针 \u003ccode\u003ep\u003c/code\u003e 记录了变量 \u003ccode\u003eval\u003c/code\u003e 的地址。因此，我们可以通过解引用指针 \u003ccode\u003ep\u003c/code\u003e 来访问变量 \u003ccode\u003eval\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e val = \u003cspan class=\"number\"\u003e42\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p  = \u0026amp;val;         \u003cspan class=\"comment\"\u003e// \u0026amp;val 返回变量 val 的地址，记录在指向 int 类型变量的指针里\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003ecout\u003c/span\u003e \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u003cspan class=\"built_in\"\u003eendl\u003c/span\u003e;     \u003cspan class=\"comment\"\u003e// 通过指针 p 访问变量 val，输出 val 的值：42\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e*p = \u003cspan class=\"number\"\u003e360\u003c/span\u003e;               \u003cspan class=\"comment\"\u003e// 通过指针 p 改变变量 val 的值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003ecout\u003c/span\u003e \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u003cspan class=\"built_in\"\u003eendl\u003c/span\u003e;     \u003cspan class=\"comment\"\u003e// 通过指针 p 访问变量 val，输出 val 的值：360\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003ecout\u003c/span\u003e \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \u003cspan class=\"built_in\"\u003eendl\u003c/span\u003e;    \u003cspan class=\"comment\"\u003e// 输出 val 的值：360\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"空指针和空类型的指针\"\u003e\u003ca href=\"#空指针和空类型的指针\" class=\"headerlink\" title=\"空指针和空类型的指针\"\u003e\u003c/a\u003e空指针和空类型的指针\u003c/h3\u003e\u003cp\u003e空指针是不指向任何对象的指针，在实际编程中，通常使用空指针作为指针变量有效性的判断标准。\u003c/p\u003e\n\u003cp\u003eC 语言和老版本 C++ 的空指针字面值是 \u003ccode\u003eNULL\u003c/code\u003e，它定义在 \u003ccode\u003estdlib\u003c/code\u003e 当中；新版本的 C++ 使用 \u003ccode\u003enullptr\u003c/code\u003e 作为空指针字面值。C++ 还支持用字面值常量 \u003ccode\u003e0\u003c/code\u003e 初始化指针变量，被这样初始化的指针变量会是一个空指针。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p1 = \u003cspan class=\"literal\"\u003eNULL\u003c/span\u003e;         \u003cspan class=\"comment\"\u003e// C 风格的空指针初始化\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p2 = \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e;      \u003cspan class=\"comment\"\u003e// C++ 风格的空指针初始化\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p3 = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;            \u003cspan class=\"comment\"\u003e// 使用字面值常量 0 初始化空指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e == p1) {    \u003cspan class=\"comment\"\u003e// 思考一下为什么不是 p1 == nullptr\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ; \u003cspan class=\"comment\"\u003e// do something\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e空类型的指针，指的是形如 \u003ccode\u003evoid *pv\u003c/code\u003e 的指针。这是一类特殊的指针；这里的空类型，不是说没有类型，而是说空类型的指针，可以用于存储任意类型对象的地址。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e pi = \u003cspan class=\"number\"\u003e3.14\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e *pv = \u0026amp;pi;     \u003cspan class=\"comment\"\u003e// 使用 void * 存放了一个 double 类型对象的地址\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *pd = \u0026amp;pi;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epd = pv;            \u003cspan class=\"comment\"\u003e// 错误：不能将空类型的指针赋值给其他类型的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epv = pd;            \u003cspan class=\"comment\"\u003e// 正确：空类型的指针可以接受任意类型的指针赋值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epd = (\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *)pv;  \u003cspan class=\"comment\"\u003e// 正确：C 风格的强制类型转换\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epd = \u003cspan class=\"built_in\"\u003ereinterpret_cast\u003c/span\u003e\u0026lt;\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *\u0026gt;(pv); \u003cspan class=\"comment\"\u003e// 正确：C++ 风格的强制类型转换\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e让我们回顾一下指针的两个要素：地址和类型。由于空类型的指针可以接受任意类型对象的地址，所以，当编译器拿到一个空类型的指针的时候，它无法知道应该按照何种方式解释和使用指针中记录地址中的内容。因此，空类型指针能够做的事情非常有限：做指针之间的比较、作为函数的输入或输出、赋值给另外一个空类型指针。\u003c/p\u003e\n\u003ch2 id=\"理解指针的定义\"\u003e\u003ca href=\"#理解指针的定义\" class=\"headerlink\" title=\"理解指针的定义\"\u003e\u003c/a\u003e理解指针的定义\u003c/h2\u003e\u003ch3 id=\"再探变量声明\"\u003e\u003ca href=\"#再探变量声明\" class=\"headerlink\" title=\"再探变量声明\"\u003e\u003c/a\u003e再探变量声明\u003c/h3\u003e\u003cp\u003e在 C 和 C++ 中，变量的声明包括一个基本数据类型（或者类类型），以及一组声明符。定义指针使用的解引用符号 \u003ccode\u003e*\u003c/code\u003e 是类型修饰符，它是声明符的一部分。因此，在下列语句中，\u003ccode\u003eint\u003c/code\u003e 是基本数据类型，\u003ccode\u003e*p\u003c/code\u003e 是声明符，\u003ccode\u003e*\u003c/code\u003e 是类型修饰符作为声明符的一部分存在。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在同一个变量定义语句中，基本数据类型只能有一个，但是可以有多个形式相同或不同的声明符。这也就是说，同一个语句可以定义出不同类型的变量。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// pi 是指向 int 型变量的指针；val 是 int 型变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *pi = \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    val = \u003cspan class=\"number\"\u003e1024\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"理解稍微复杂的指针定义\"\u003e\u003ca href=\"#理解稍微复杂的指针定义\" class=\"headerlink\" title=\"理解稍微复杂的指针定义\"\u003e\u003c/a\u003e理解稍微复杂的指针定义\u003c/h3\u003e\u003cp\u003e因为指针本身也是变量，所以它当然也是存储在虚存空间里的。因此，我们当然也可以定义一个指向这一指针的指针。比如：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e val  = \u003cspan class=\"number\"\u003e1024\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p   = \u0026amp;val;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e **pp = \u0026amp;p;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们需要仔细理解一下 \u003ccode\u003epp\u003c/code\u003e 的定义。理解这类稍微复杂的定义语句，一个基本的办法就是：从最靠近变量名字的地方开始，一层一层剖析变量的类型。我们来看\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e距离 \u003ccode\u003epp\u003c/code\u003e 最近的是一个解引用符 \u003ccode\u003e*\u003c/code\u003e，这预示着 \u003ccode\u003epp\u003c/code\u003e 是一个指针，它指向 \u003ccode\u003eint *\u003c/code\u003e 类型的变量；\u003c/li\u003e\n\u003cli\u003e再来看 \u003ccode\u003eint *\u003c/code\u003e，距离 \u003ccode\u003e*pp\u003c/code\u003e 最近的，依然是一个解引用符，这意味着 \u003ccode\u003e*pp\u003c/code\u003e 也是一个指针，它指向 \u003ccode\u003eint\u003c/code\u003e 类型的变量；\u003c/li\u003e\n\u003cli\u003e因此 \u003ccode\u003epp\u003c/code\u003e 是一个\u003cstrong\u003e指向指向 \u003ccode\u003eint\u003c/code\u003e 类型变量的指针的指针\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e你可以仔细斟酌一下这段内容。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"const-与指针\"\u003e\u003ca href=\"#const-与指针\" class=\"headerlink\" title=\"const 与指针\"\u003e\u003c/a\u003e\u003ccode\u003econst\u003c/code\u003e 与指针\u003c/h2\u003e\u003cp\u003e常量的值在生存期内不允许改变。这一特性经常是有用的：可以定义一个常量，然后在多个地方使用；当认为这个常量的值不合适的时候，修改它的定义，即可在所有使用到它的地方生效（而无需依次手工修改）；此外，还可以防止程序意外修改这个值。定义常量，只需要在基本类型前，加上 \u003ccode\u003econst\u003c/code\u003e 关键字即可；它是 constant 的缩写，意为常量。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003edouble\u003c/span\u003e pi = \u003cspan class=\"number\"\u003e3.141592653580793\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e当 \u003ccode\u003econst\u003c/code\u003e 与指针牵扯到一起，就有些复杂了。至少有以下几种情况：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e val = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;                \u003cspan class=\"comment\"\u003e// int 型变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e cnst = \u003cspan class=\"number\"\u003e1\u003c/span\u003e;         \u003cspan class=\"comment\"\u003e// int 型常量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *pi = \u0026amp;val;             \u003cspan class=\"comment\"\u003e// pi 本身是变量，通过 pi 访问的也是变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 正确：将变量地址赋值给变量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epi = \u0026amp;cnst;                 \u003cspan class=\"comment\"\u003e// 错误：不允许将常量的地址赋值给变量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e *pci = \u0026amp;cnst;     \u003cspan class=\"comment\"\u003e// pci 本身是变量，通过 pci 访问的是常量 (point to const)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 正确：将常量地址赋值给常量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epci = \u0026amp;val;                 \u003cspan class=\"comment\"\u003e// 正确：允许将变量地址赋值给常量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *\u003cspan class=\"type\"\u003econst\u003c/span\u003e cpi = \u0026amp;val;      \u003cspan class=\"comment\"\u003e// cpi 本身是常量，通过 cpi 访问的是变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 正确：允许将变量地址赋值给变量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e fake = \u003cspan class=\"number\"\u003e2\u003c/span\u003e;               \u003cspan class=\"comment\"\u003e// int 型变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecpi = \u0026amp;fake;                \u003cspan class=\"comment\"\u003e// 错误：cpi 本身是常量，不能在定义之外赋值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e *\u003cspan class=\"type\"\u003econst\u003c/span\u003e cpci = \u0026amp;val;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// cpci 本身是常量，通过 cpci 访问的也是常量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 正确：允许将变量地址赋值给常量的指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecpci = \u0026amp;fake;               \u003cspan class=\"comment\"\u003e// 错误：cpci 本身是常量，不能在定义之外赋值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecpci = \u0026amp;cnst;               \u003cspan class=\"comment\"\u003e// 错误：cpci 本身是常量，不能在定义之外赋值，哪怕是常量的地址\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e因为变量可以是常量，而指针本身也可以是常量。因此在变量和指针两个维度，都可以选择是否为常量。这样一来，就像上面代码展示的那样，当 \u003ccode\u003econst\u003c/code\u003e 与指针牵扯在一起的时候，就有 4 中可能性。为了区分这两个维度，我们引入\u003cstrong\u003e顶层 \u003ccode\u003econst\u003c/code\u003e\u003c/strong\u003e 和\u003cstrong\u003e底层 \u003ccode\u003econst\u003c/code\u003e\u003c/strong\u003e 的概念：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e顶层 \u003ccode\u003econst\u003c/code\u003e：指针本身是常量。此时，指针在定义初始化之外，不能被赋值修改。称指针为指针常量。\u003c/li\u003e\n\u003cli\u003e底层 \u003ccode\u003econst\u003c/code\u003e：指针指向的变量是常量。此时，不能通过解引用指针的方式，修改变量的值。称指针为常量的指针。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"指针与数组\"\u003e\u003ca href=\"#指针与数组\" class=\"headerlink\" title=\"指针与数组\"\u003e\u003c/a\u003e指针与数组\u003c/h2\u003e\u003ch3 id=\"数组的名字被当做指针使用\"\u003e\u003ca href=\"#数组的名字被当做指针使用\" class=\"headerlink\" title=\"数组的名字被当做指针使用\"\u003e\u003c/a\u003e数组的名字被当做指针使用\u003c/h3\u003e\u003cp\u003e在 C 和 C++ 中，指针与数组有非常紧密的联系。实际上，使用数组的时候，编译器通常都是在操作指针。这里我们从两个角度说明数组名在很多时候被当做是一个指针。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e nums[] = {\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e, \u003cspan class=\"number\"\u003e3\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p = \u0026amp;(nums[\u003cspan class=\"number\"\u003e0\u003c/span\u003e]);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (p == nums) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;true!\\n\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e; i != \u003cspan class=\"number\"\u003e3\u003c/span\u003e; ++i) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;%d\\n\u0026#34;\u003c/span\u003e, p[i]);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如果你执行这一小段代码，那么，不出意外的话，程序会在终端上打印 \u003ccode\u003etrue!\u003c/code\u003e，以及 \u003ccode\u003enums\u003c/code\u003e 中的三个数字。这预示着，指针变量 \u003ccode\u003ep\u003c/code\u003e 保存的内容（也就是 \u003ccode\u003enums[0]\u003c/code\u003e 的地址）和 \u003ccode\u003enums\u003c/code\u003e 保存的内容是完全一样的；同时，编译器以相同的方式去解释 \u003ccode\u003ep\u003c/code\u003e 和 \u003ccode\u003enums\u003c/code\u003e。显然 \u003ccode\u003ep\u003c/code\u003e 是一个指向 \u003ccode\u003eint\u003c/code\u003e 型变量的指针，那么 \u003ccode\u003enums\u003c/code\u003e 也就是一个指针了。\u003c/p\u003e\n\u003cp\u003eC++11 标准引入了 \u003ccode\u003eauto\u003c/code\u003e 关键字，它能够在定义变量时，探测初始值的类型，并为新定义的变量设置合适的类型。我们看看 \u003ccode\u003eauto\u003c/code\u003e 关键字作用于数组名字的时候，会发生什么。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e nums[] = {\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e, \u003cspan class=\"number\"\u003e3\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e what = nums;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e val = \u003cspan class=\"number\"\u003e42\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ewhat = \u0026amp;val;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这份代码在 C++11 标准中，可以顺利通过。这说明 \u003ccode\u003ewhat\u003c/code\u003e 的类型，经由 \u003ccode\u003eauto\u003c/code\u003e 检测，是 \u003ccode\u003eint *\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这两个例子，足以说明：当数组名字被当做是一个值来使用的时候，它就相当于是一个指针。\u003c/p\u003e\n\u003ch3 id=\"也不是全部时候\"\u003e\u003ca href=\"#也不是全部时候\" class=\"headerlink\" title=\"也不是全部时候\"\u003e\u003c/a\u003e也不是全部时候\u003c/h3\u003e\u003cp\u003e当然，也不是全部时候，数组名字都被当做是简单的指针。比如，\u003ca href=\"/2016/11/26/init-vector-from-array/\"\u003e前作\u003c/a\u003e中的使用方式表明，在数组名字被传入 \u003ccode\u003esizeof()\u003c/code\u003e 运算符的时候，它会被当做是一个真实的数组来看待。\u003c/p\u003e\n\u003ch3 id=\"数组指针可以自增\"\u003e\u003ca href=\"#数组指针可以自增\" class=\"headerlink\" title=\"数组指针可以自增\"\u003e\u003c/a\u003e数组指针可以自增\u003c/h3\u003e\u003cp\u003e数组的指针，可以像 C++ 中 \u003ccode\u003estd::vector\u003c/code\u003e 的迭代器那样进行自增操作。这句话不是太严谨，因为，实际上是先有数组的指针，再有 \u003ccode\u003estd::vector\u003c/code\u003e 的迭代器；迭代器实际上是仿造数组的指针设计的功能。\u003c/p\u003e\n\u003cp\u003e前文提到，数组的指针，实际上是一个指向数组元素类型的对象的指针。数组的指针进行自增、自减运算，实际是将指针所指的位置，沿着数组向后或者向前移动一个元素。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e nums[] = {\u003cspan class=\"number\"\u003e0\u003c/span\u003e,\u003cspan class=\"number\"\u003e1\u003c/span\u003e,\u003cspan class=\"number\"\u003e2\u003c/span\u003e,\u003cspan class=\"number\"\u003e3\u003c/span\u003e,\u003cspan class=\"number\"\u003e4\u003c/span\u003e,\u003cspan class=\"number\"\u003e5\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e len = \u003cspan class=\"keyword\"\u003esizeof\u003c/span\u003e(nums) / \u003cspan class=\"keyword\"\u003esizeof\u003c/span\u003e(nums[\u003cspan class=\"number\"\u003e0\u003c/span\u003e]);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *iter;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *end = nums + len;     \u003cspan class=\"comment\"\u003e// end 是尾后指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (iter = nums; iter != end; ++iter) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;%d\\n\u0026#34;\u003c/span\u003e, *iter);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e像这样的用法，就和 \u003ccode\u003estd::vector\u003c/code\u003e 的迭代器几乎没有差别了。\u003c/p\u003e\n\u003ch3 id=\"数组指针可以进行加减运算\"\u003e\u003ca href=\"#数组指针可以进行加减运算\" class=\"headerlink\" title=\"数组指针可以进行加减运算\"\u003e\u003c/a\u003e数组指针可以进行加减运算\u003c/h3\u003e\u003cp\u003e数组的指针还可以进行加减运算。比如，在上述例子中 \u003ccode\u003eiter += 2\u003c/code\u003e，就是将 \u003ccode\u003eiter\u003c/code\u003e 指针沿着数组向后移动 2 个元素。\u003c/p\u003e\n\u003cp\u003e两个指针如果指向同一个数组中的元素，那么它们可以做差。做差得到的结果是两个指针之间的距离，这个结果可以是负数（实际类型是 \u003ccode\u003eptrdiff_t\u003c/code\u003e）。例如，在上述例子中在循环体末尾处，如果进行 \u003ccode\u003eend - iter\u003c/code\u003e 计算，则其结果表示当前尚未打印的元素的数量。\u003c/p\u003e\n\u003ch3 id=\"数组下标与指针加减\"\u003e\u003ca href=\"#数组下标与指针加减\" class=\"headerlink\" title=\"数组下标与指针加减\"\u003e\u003c/a\u003e数组下标与指针加减\u003c/h3\u003e\u003cp\u003e上面提到，数组指针可以进行加减运算：数组指针与整数的加减，实际是将指针沿着数组进行移动，得到的结果还是一个指针。既然结果是指针，那么就可以解引用，访问数组中的元素。因此有\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e nums[] = {\u003cspan class=\"number\"\u003e0\u003c/span\u003e,\u003cspan class=\"number\"\u003e1\u003c/span\u003e,\u003cspan class=\"number\"\u003e2\u003c/span\u003e,\u003cspan class=\"number\"\u003e3\u003c/span\u003e,\u003cspan class=\"number\"\u003e4\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e len = \u003cspan class=\"keyword\"\u003esizeof\u003c/span\u003e(nums) / \u003cspan class=\"keyword\"\u003esizeof\u003c/span\u003e(nums[\u003cspan class=\"number\"\u003e0\u003c/span\u003e]);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *p = nums;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003esize_t\u003c/span\u003e i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e; i != len; ++i) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (nums[i] == *(p + i)) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;true!\\n\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不出意外的话，这一小段代码会连续打印五行 \u003ccode\u003etrue!\u003c/code\u003e。这提供了另一种访问数组内元素的方法；而事实上，在使用下标访问数组元素的时候，编译器都会转换成类似 \u003ccode\u003e*(nums + i)\u003c/code\u003e 的形式。也就是说，通过指针运算和解引用来访问数组元素，其实是更加本质的方式。\u003c/p\u003e\n\u003ch2 id=\"函数与指针\"\u003e\u003ca href=\"#函数与指针\" class=\"headerlink\" title=\"函数与指针\"\u003e\u003c/a\u003e函数与指针\u003c/h2\u003e\u003cp\u003e函数与指针，基本上是指针相关的话题中，最复杂的一个了。\u003c/p\u003e\n\u003ch3 id=\"让函数返回一个数组的指针\"\u003e\u003ca href=\"#让函数返回一个数组的指针\" class=\"headerlink\" title=\"让函数返回一个数组的指针\"\u003e\u003c/a\u003e让函数返回一个数组的指针\u003c/h3\u003e\u003cp\u003e我们知道，函数在返回的过程中，会对返回值进行拷贝。因此，一个无法拷贝的对象，是无法被函数返回的。（也可以参考\u003ca href=\"/2016/08/14/copy-control-in-Cpp/\"\u003e此篇\u003c/a\u003e）数组是不能被拷贝的，所以函数无法直接返回数组。为了达到返回数组的目的，我们只能寄希望于让函数返回数组的指针（在 C++ 中还可以返回数组的引用）。\u003c/p\u003e\n\u003cp\u003e为此，我们需要了解，如何定义一个返回数组指针的函数。\u003c/p\u003e\n\u003cp\u003e首先，我们看一组数组的定义：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e arr[\u003cspan class=\"number\"\u003e10\u003c/span\u003e];        \u003cspan class=\"comment\"\u003e// arr 是一个数组，长度是 10，元素类型是 int 型\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *parr[\u003cspan class=\"number\"\u003e10\u003c/span\u003e];      \u003cspan class=\"comment\"\u003e// parr 是一个数组，长度是 10，元素类型是 int *，也就是数组中存的是指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e (*p)[\u003cspan class=\"number\"\u003e10\u003c/span\u003e] = \u0026amp;arr;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// p 是一个指针，它指向一个长度是 10 元素类型是 int 型的数组\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样一来，就不难构造返回数组的指针的函数定义了。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e *(func(param_list))[\u003cspan class=\"number\"\u003e10\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 错误：func 是一个函数，param_list 是它的参数\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 它尝试返回一个长度为 10，元素类型为 int * 的数组\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 而数组是无法返回的\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e (*func(param_list))[\u003cspan class=\"number\"\u003e10\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 正确：func 是一个函数，param_list 是它的参数\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 它返回的是一个指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                    \u003cspan class=\"comment\"\u003e// 这个指针指向了一个长度为 10 元素类型是 int 型的数组\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e于是，我们得到了此类函数定义的一般形式：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eelement_type (*func(param_list))[dimension]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"函数的指针\"\u003e\u003ca href=\"#函数的指针\" class=\"headerlink\" title=\"函数的指针\"\u003e\u003c/a\u003e函数的指针\u003c/h3\u003e\u003cblockquote\u003e\n\u003cp\u003e终于到这个话题了，呼……\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e上文提到，无论是数据（变量）还是指令（函数），都是存放在虚存空间的。因此，既然有变量的指针，那么也一定会有函数的指针。这就是我们这一小节需要讨论的函数指针；这会逐渐引出本文最复杂的话题。\u003c/p\u003e\n\u003cp\u003e一个函数的类型，取决于它的输入和输出。这也就是说，一个函数的类型，应当包含它的返回值类型和参数列表。比如下面定义的函数，用于比较两个 \u003ccode\u003eint\u003c/code\u003e 型数据是否相等（这是一个仅用于示例而没有实际用处的函数）：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e \u003cspan class=\"title function_\"\u003eisEqual\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e)\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于一个函数来说，如果你能拿到它的定义，就很容易能取得它的类型：只需要去掉函数名字就可以了。因此，定义一个指向该类型的函数指针，并不困难。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e \u003cspan class=\"title function_\"\u003eisEqual\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e)\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e (*pfunc)(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e) = \u0026amp;isEqual;     \u003cspan class=\"comment\"\u003e// 定义了一个函数指针，指向 isEqual\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e (*pfunc)(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e) = isEqual;      \u003cspan class=\"comment\"\u003e// 一个等价定义\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，\u003ccode\u003epfunc\u003c/code\u003e 就是一个函数指针，它指向一个 \u003ccode\u003ebool (int, int)\u003c/code\u003e 类型的函数。也就是说，这类函数接收两个 \u003ccode\u003eint\u003c/code\u003e 型的参数，并返回一个 \u003ccode\u003ebool\u003c/code\u003e 类型的值。\u003c/p\u003e\n\u003cp\u003e值得一提的是，当函数名字作为值使用时，它会自动地转换成指针（有点像数组名字，不是吗）。因此，在函数指针的初始化或者复制的过程中，取值运算符是可选的。于是，上述两个定义语句是等价的。另一方面，函数指针作为函数调用使用时，它会自动转换成函数名（有点像数组指针，不是吗）。因此，这种情况下，解引用运算符是可选的。请看下例：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e \u003cspan class=\"title function_\"\u003eisEqual\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e)\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e (*pfunc)(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e) = isEqual;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e res1 = isEqual(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e);  \u003cspan class=\"comment\"\u003e// 通过原函数名调用\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e res2 = (*pfunc)(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e); \u003cspan class=\"comment\"\u003e// 一个等价调用：通过函数指针，解引用调用\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e res3 = pfunc(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e2\u003c/span\u003e);    \u003cspan class=\"comment\"\u003e// 另一个等价调用：函数指针自动转换成函数名\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e值得一提的是，不同类型的函数的指针之间，不存在任何的类型转换：你不能期待一个接受两个 \u003ccode\u003eint\u003c/code\u003e 型参数并返回 \u003ccode\u003ebool\u003c/code\u003e 值的函数的指针，经过类型转换，就能接受三个 \u003ccode\u003eint\u003c/code\u003e 型的参数。因此，对于重载的同名函数，他们的函数类型是不一样的，因此函数指针也不能是同一个。\u003c/p\u003e\n\u003ch3 id=\"将函数指针作为参数传入另一个函数\"\u003e\u003ca href=\"#将函数指针作为参数传入另一个函数\" class=\"headerlink\" title=\"将函数指针作为参数传入另一个函数\"\u003e\u003c/a\u003e将函数指针作为参数传入另一个函数\u003c/h3\u003e\u003cp\u003e在传参的过程中（除了 C++ 的传引用），也是伴随着拷贝的过程。因此，一个对象如果不能拷贝，那么它就不能作为参数传入函数。无疑，函数是不能拷贝的，因此你无法将函数作为参数直接传给另一个函数。但是，指针是可以拷贝的，因此，你可以将函数指针作为参数，传给另一个函数。\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eaddIfEqual\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e lhs, \u003cspan class=\"type\"\u003eint\u003c/span\u003e rhs, \u003cspan class=\"type\"\u003ebool\u003c/span\u003e pfunc(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e))\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// addIfEqual 的第三个参数是一个函数定义\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 它会自动地转换成一个函数指针的参数\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title function_\"\u003eaddIfEqual\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e lhs, \u003cspan class=\"type\"\u003eint\u003c/span\u003e rhs, \u003cspan class=\"type\"\u003ebool\u003c/span\u003e (*pfunc)(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e))\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                            \u003cspan class=\"comment\"\u003e// 一个等价定义：显式地注明第三个参数是函数指针\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e于是，你可以这样使用这个函数：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eaddIfEqual(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e1\u003c/span\u003e, isEqual);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此时，函数名 \u003ccode\u003eisEqual\u003c/code\u003e 作为引数被传入，它起到的是「值」的作用。因此，\u003ccode\u003eisEqual\u003c/code\u003e 被自动地转换成指向该函数的指针。\u003c/p\u003e\n\u003ch3 id=\"让函数返回一个函数的指针\"\u003e\u003ca href=\"#让函数返回一个函数的指针\" class=\"headerlink\" title=\"让函数返回一个函数的指针\"\u003e\u003c/a\u003e让函数返回一个函数的指针\u003c/h3\u003e\u003cp\u003e同样地，与数组类似，虽然我们无法返回一个函数，但是我们可以返回一个函数指针。我们回到 \u003ccode\u003eisEqual\u003c/code\u003e 的函数指针的定义上来：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003ebool\u003c/span\u003e (*pfunc)(\u003cspan class=\"type\"\u003eint\u003c/span\u003e, \u003cspan class=\"type\"\u003eint\u003c/span\u003e) = isEqual;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，\u003ccode\u003epfunc\u003c/code\u003e 是一个指针，它指向了一个函数；该函数接收两个 \u003ccode\u003eint\u003c/code\u003e 型参数，并返回一个 \u003ccode\u003ebool\u003c/code\u003e 值。因此，仿造之前「返回数组指针的函数的定义形式」，我们不难得出：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eouter_return_type (*func(param_list))(outer_param_list)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，\u003ccode\u003efunc(param_list)\u003c/code\u003e 是当前需要定义的函数；\u003ccode\u003eouter_return_type\u003c/code\u003e 和 \u003ccode\u003eouter_param_list\u003c/code\u003e 分别是当前定义的函数返回的函数指针对应函数的返回值类型和参数列表。\u003c/p\u003e\n\u003ch2 id=\"登峰造极的-void-0\"\u003e\u003ca href=\"#登峰造极的-void-0\" class=\"headerlink\" title=\"登峰造极的 (*(void(*)())0)();\"\u003e\u003c/a\u003e登峰造极的 \u003ccode\u003e(*(void(*)())0)();\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e这恐怕是一个会令所有 C/C++ 程序员战栗不已的函数调用语句。因此，在解释这个语句之前，我愿意先给出它的含义，安抚读者战栗的心灵。它表示：\u003cstrong\u003e访问内存地址 \u003ccode\u003e0\u003c/code\u003e，将它作为一个参数列表和返回类型均为空的函数，并执行函数调用\u003c/strong\u003e。（这是一个特殊场景下的函数调用，不用纠结为什么会调用 \u003ccode\u003e0\u003c/code\u003e 位置上的函数）\u003c/p\u003e\n\u003ch3 id=\"类型定义与-C-风格的类型强制转换符\"\u003e\u003ca href=\"#类型定义与-C-风格的类型强制转换符\" class=\"headerlink\" title=\"类型定义与 C 风格的类型强制转换符\"\u003e\u003c/a\u003e类型定义与 C 风格的类型强制转换符\u003c/h3\u003e\u003cp\u003eC 风格的类型强制转换符应该不是个稀罕玩意儿。比如 \u003ccode\u003e(double)a\u003c/code\u003e 就能将变量 \u003ccode\u003ea\u003c/code\u003e 强制转换为 \u003ccode\u003edouble\u003c/code\u003e 类型。在这个简单的例子里，我们希望能够找到一些朴素的规律，破解这一登峰造极而又令人战栗的函数调用语句。\u003c/p\u003e\n\u003cp\u003e同样以 \u003ccode\u003edouble\u003c/code\u003e 类型及相关指针类型为例，我们首先看下面的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e a;       \u003cspan class=\"comment\"\u003e// 定义了一个 double 型的变量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *b;      \u003cspan class=\"comment\"\u003e// 定义了一个 double * 型的变量（double 型的指针）\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e) c;     \u003cspan class=\"comment\"\u003e// 将变量 c 强制转换为 double 类型\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u003cspan class=\"type\"\u003edouble\u003c/span\u003e *) d;   \u003cspan class=\"comment\"\u003e// 将变量 d 强制转换为 double * 类型\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们不难发现，类型转换和对应类型的变量定义，有着千丝万缕的联系：首先去掉变量定义语句末尾的分号，然后去掉变量定义语句中的变量名，最后给剩余的部分加上括号——一个 C 风格的类型强制转换符，就得到了。\u003c/p\u003e\n\u003ch3 id=\"破解谜题\"\u003e\u003ca href=\"#破解谜题\" class=\"headerlink\" title=\"破解谜题\"\u003e\u003c/a\u003e破解谜题\u003c/h3\u003e\u003cp\u003e我们知道 \u003ccode\u003evoid(*pfunc)();\u003c/code\u003e 定义了一个函数指针 \u003ccode\u003epfunc\u003c/code\u003e，它指向的函数参数列表为空、返回值类型也为空。因此，\u003ccode\u003e(void(*)())\u003c/code\u003e 就是一个 C 风格的类型转换符。\u003c/p\u003e\n\u003cp\u003e因此，\u003ccode\u003e(void(*)())0\u003c/code\u003e 会将 \u003ccode\u003e0\u003c/code\u003e 转换成一个函数指针，然后交给 \u003ccode\u003e*\u003c/code\u003e 解引用，最后传入参数（空的参数列表 \u003ccode\u003e()\u003c/code\u003e），执行函数调用。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在 C++ 中，这个函数调用应该写作\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(*\u003cspan class=\"built_in\"\u003ereinterpret_cast\u003c/span\u003e\u0026lt;\u003cspan class=\"built_in\"\u003evoid\u003c/span\u003e(*)()\u0026gt;(\u003cspan class=\"number\"\u003e0\u003c/span\u003e))();\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cblockquote\u003e\n\u003cp\u003e显而易见，这个写法，相较 C 风格的类型强制转换符，要清晰明朗得多。因此，请不要再吐槽 C++ 风格的强制转换是「语法盐」了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003chr/\u003e\n\u003cp\u003e谨以此文，作为献给自己的生日礼物。\u003ccode\u003e:)\u003c/code\u003e\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-02-04T16:02:02Z",
  "Author": "Liam Huang"
}