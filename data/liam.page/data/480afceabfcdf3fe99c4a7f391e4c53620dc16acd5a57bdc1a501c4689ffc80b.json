{
  "Source": "liam.page",
  "Title": "利用 Protobuf 中 oneof 的特性生成 has_xxx 接口",
  "Link": "https://liam.page/2020/05/05/using-oneof-to-generate-has-xxx-in-pb3/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eProtobuf（全称 Protocal Buffer，简称 pb）是 Google 开源的序列化/反序列化工具，在工业界相当流行。pb3 相比 pb2 的一个显著变化，就是在 pb3 当中不再区分 \u003ccode\u003erequired\u003c/code\u003e 和 \u003ccode\u003eoptional\u003c/code\u003e 字段。与此同时，在 pb2 中针对 \u003ccode\u003eoptional\u003c/code\u003e 基本类型字段设计的 \u003ccode\u003e[default = foobar]\u003c/code\u003e 的默认值功能和 \u003ccode\u003ehas_xxx()\u003c/code\u003e 的接口也随之消失。这样引出来一个问题，即：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在多数场景下，「未设置」和「取值为 \u003ccode\u003e0\u003c/code\u003e/\u003ccode\u003e0.0\u003c/code\u003e/\u003ccode\u003e\u0026#34;\u0026#34;\u003c/code\u003e/\u003ccode\u003efalse\u003c/code\u003e」等价；但是\u003c/li\u003e\n\u003cli\u003e在某些场景下，「未设置」和上述取值不等价。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e特别地，在序列化 - 反序列化之后，如果拿到一个零值，你无法得知这个值是确实为零值，还是说因为没有显示设置而得到的零值。本文在 C++ 场景下来解决这个问题。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"oneof\"\u003e\u003ca href=\"#oneof\" class=\"headerlink\" title=\"oneof\"\u003e\u003c/a\u003e\u003ccode\u003eoneof\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eProtobuf 提供了 \u003ccode\u003eoneof\u003c/code\u003e 功能（见\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#oneof\"\u003e文档\u003c/a\u003e）。其本意是想实现 C/C++ 当中 \u003ccode\u003eunion\u003c/code\u003e 的功能，即多个不同类型共享存储空间，但同一时间只有一个类型有实际值。但在实现的过程中，Protobuf 做了一些妥协。例如，对于下面这样定义的 \u003ccode\u003emessage\u003c/code\u003e 来说，\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emessage FooMessage {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  string id = 1;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  oneof oneof_name {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    int32 bar = 2;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    int64 baz = 3;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在生成的类当中，会有一个名为 \u003ccode\u003eOneofNameCase\u003c/code\u003e 的枚举类型来标记 \u003ccode\u003eoneof_name\u003c/code\u003e 字段的设置状态——你可以用 \u003ccode\u003eoneof_name_case()\u003c/code\u003e 接口来获取该状态。若状态取 \u003ccode\u003eONEOF_NAME_NOT_SET\u003c/code\u003e 说明 \u003ccode\u003eoneof_name\u003c/code\u003e 未设置，若状态取 \u003ccode\u003ekBar\u003c/code\u003e/\u003ccode\u003ekBaz\u003c/code\u003e 其意义不言自明。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eenum\u003c/span\u003e \u003cspan class=\"title class_\"\u003eOneofNameCase\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  kBar = \u003cspan class=\"number\"\u003e2\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  kBaz = \u003cspan class=\"number\"\u003e3\u003c/span\u003e,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ONEOF_NAME_NOT_SET = \u003cspan class=\"number\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"文档未注明的特性\"\u003e\u003ca href=\"#文档未注明的特性\" class=\"headerlink\" title=\"文档未注明的特性\"\u003e\u003c/a\u003e文档未注明的特性\u003c/h2\u003e\u003cp\u003e对比开发文档和 pb3 的源码，我们发现 pb3 会为 \u003ccode\u003eoneof\u003c/code\u003e 字段生成一个 \u003ccode\u003ehas_xxx()\u003c/code\u003e 的接口，其实现正是内联了 \u003ccode\u003ereturn xxx_case() != XXX_NOT_SET;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意到其命名策略，我们只需定义一个**只含有一个字段的同名 \u003ccode\u003eoneof\u003c/code\u003e**就能方便地判断了。例如：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emessage FooMessage {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  string id = 1;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  oneof bar {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    int32 bar = 2;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此时，Protobuf 会生成 \u003ccode\u003ehas_bar()\u003c/code\u003e 这个接口。于是，利用这一特性，我们就可以在反序列化之后来判断字段是否有设置过了。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-05-05T11:38:42Z",
  "Author": "Liam Huang"
}