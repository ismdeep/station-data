{
  "Source": "liam.page",
  "Title": "谈谈因子分解机模型（FM）",
  "Link": "https://liam.page/2019/03/25/Factorization-Machine/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e先前我们讨论过\u003ca href=\"/2018/10/10/logistic-regression/\"\u003e逻辑回归\u003c/a\u003e。作为线性模型，它最大的优势是简单，于是可以以很高的效率去学习和预测，因而在很多领域都被广泛应用。但「成也萧何败萧何」，由于 LR 只能捕捉关于特征的线性信息，而无法捕捉非线性信息——特别是交叉特征信息，人们对 LR 进行了各种升级改造。\u003c/p\u003e\n\u003cp\u003e此篇介绍因子分解机模型（Factorization Machine）。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"背景\"\u003e\u003ca href=\"#背景\" class=\"headerlink\" title=\"背景\"\u003e\u003c/a\u003e背景\u003c/h2\u003e\u003cp\u003e首先我们介绍一下在实际工程中模型的使用背景。\u003c/p\u003e\n\u003ch3 id=\"特征稀疏性\"\u003e\u003ca href=\"#特征稀疏性\" class=\"headerlink\" title=\"特征稀疏性\"\u003e\u003c/a\u003e特征稀疏性\u003c/h3\u003e\u003cp\u003e在诸如 CTR 预估、推荐或搜索 ranking 的场景中，特征是非常稀疏的。特征的稀疏性往往来自分类特征的 one-hot 编码。举例来说，我们有以下数据集。数据集中的「点击」是 label，而性别、地区、频道则是特征。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e点击\u003c/th\u003e\n\u003cth\u003e性别\u003c/th\u003e\n\u003cth\u003e地区\u003c/th\u003e\n\u003cth\u003e频道\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e男\u003c/td\u003e\n\u003ctd\u003e天津\u003c/td\u003e\n\u003ctd\u003e相声\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e女\u003c/td\u003e\n\u003ctd\u003e甘肃\u003c/td\u003e\n\u003ctd\u003e体育\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e女\u003c/td\u003e\n\u003ctd\u003e云南\u003c/td\u003e\n\u003ctd\u003e电视剧\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e不难发现，在这个场景下，性别、地区、频道都是分类特征。其中性别有 2 个取值；地区按省级行政单位划分全中国有 30 余个取值；频道则可能更多，可能有上百个取值。由于类别特征的不同取址之间，在数值上是不可比较和不可计算的——例如我们没法说「天津与甘肃哪个更大」，或者去计算「云南 * 3 是多少」——因此我们通常会对这些分类特征进行 one-hot 编码。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e点击\u003c/th\u003e\n\u003cth\u003e性别 = 男\u003c/th\u003e\n\u003cth\u003e性别 = 女\u003c/th\u003e\n\u003cth\u003e地区 = 天津\u003c/th\u003e\n\u003cth\u003e地区 = 甘肃\u003c/th\u003e\n\u003cth\u003e地区 = 云南\u003c/th\u003e\n\u003cth\u003e频道 = 相声\u003c/th\u003e\n\u003cth\u003e频道 = 体育\u003c/th\u003e\n\u003cth\u003e频道 = 电视剧\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e这里仅列出了 8 维特征。但实际上，如前所述，实际上由性别、地区、频道 one-hot 编码之后，特征维度会升高到 100+ 维。但对于每一条样本，这 100+ 维特征中，大多数的取值都是 0。具体来说，由于它们来自三个原始的分类特征，因此这 100+ 维特征中只有 3 维取值为 1，其余都是 0。\u003c/p\u003e\n\u003cp\u003e由此可见其稀疏性。\u003c/p\u003e\n\u003ch3 id=\"交叉特征\"\u003e\u003ca href=\"#交叉特征\" class=\"headerlink\" title=\"交叉特征\"\u003e\u003c/a\u003e交叉特征\u003c/h3\u003e\u003cp\u003e用户是否会点击某个 item，往往与不同特征的组合高度相关。例如，地处天津的用户点击相声类 item 的概率可能显著高于全国用户的平均水平。因此，若一条样本的 \u003ccode\u003e地区 = 天津\u003c/code\u003e 和 \u003ccode\u003e频道 = 相声\u003c/code\u003e 同时出现，则其 CTR 应该相对较高。\u003c/p\u003e\n\u003cp\u003e对于这些特征，对产品形态和策略较熟悉的工程师，可以根据这些先验知识，进行人工的特征组合，作为新的组合特征交付给模型使用。使用 LR 作为 CTR 预估模型/ranking 模型时，往往会需要工程师进行大量的特征工程操作，以便提升模型的预测性能。\u003c/p\u003e\n\u003cp\u003e不过，当分类特征增多，特别是取值多的分类特征越来越多，进行人工特征交叉的工作量会越来越大。此外，全凭经验的特征工程，可能无法完全捕捉到特征中蕴含的规律，从而降低模型预测性能的天花板。这是这类做法的主要缺陷之一。\u003c/p\u003e\n\u003ch3 id=\"问题\"\u003e\u003ca href=\"#问题\" class=\"headerlink\" title=\"问题\"\u003e\u003c/a\u003e问题\u003c/h3\u003e\u003cp\u003e如此一来，我们就会希望设计一些模型，使得它们\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）；\u003c/li\u003e\n\u003cli\u003e同时，我们还要求这些模型能够自动地学习到特征交叉带来的信息。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"模型演进的背后\"\u003e\u003ca href=\"#模型演进的背后\" class=\"headerlink\" title=\"模型演进的背后\"\u003e\u003c/a\u003e模型演进的背后\u003c/h2\u003e\u003cp\u003e讲清楚了背景情况和总结了问题之后，我们就能分析模型演进背后的原理了。\u003c/p\u003e\n\u003ch3 id=\"线性模型\"\u003e\u003ca href=\"#线性模型\" class=\"headerlink\" title=\"线性模型\"\u003e\u003c/a\u003e线性模型\u003c/h3\u003e\u003cp\u003e这里说的线性模型指的是线性回归和逻辑回归模型。假设模型的输入是特征向量 \u003ccode\u003e$\\vec x$\u003c/code\u003e，则它们的预测函数分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e线性回归：\u003ccode\u003e$\\hat y = f(\\vec x) = w_0 + \\sum_{i = 1}^{n}w_ix_i$\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e逻辑回归：\u003ccode\u003e$\\hat y = f(\\vec x) = \\sigma(\\vec w\\vec x) = \\frac{1}{1 + \\exp{\\{w_0 + \\sum_{i = 1}^{n}w_ix_i\\}}}$\u003c/code\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e线性模型的优势是简单可解释易扩展易并行。因此，逻辑回归模型是 CTR 预估领域早期最成功的模型。并且时至今日，仍有工业级的系统仍然采用逻辑回归模型。\u003c/p\u003e\n\u003cp\u003e不过，如前所述，由于线性模型无法捕获交叉特征带来的信息，因此其预测效果依赖大量的人工特征工程。随着特征量和样本量的增加，人工特征工程的成本越来越高，考虑让模型自动学习特征组合是必然的模型演进方向。\u003c/p\u003e\n\u003ch3 id=\"二阶多项式核-SVM\"\u003e\u003ca href=\"#二阶多项式核-SVM\" class=\"headerlink\" title=\"二阶多项式核 SVM\"\u003e\u003c/a\u003e二阶多项式核 SVM\u003c/h3\u003e\u003cp\u003e既然单纯的线性模型无法捕获交叉特征。那么，最简单直接的做法就是为两两的特征组合分配一个权重参数。这些新的权重参数和原始特征对应的参数一样，交给模型去在训练阶段学习。如此一来就形成了如下的预测函数：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\hat y = f(\\vec x) = w_0 + \\sum_{i = 1}^{n}w_ix_i + \\sum_{0 \u0026lt; i \u0026lt; j \u0026lt;= n}w_{i, j}x_ix_j.$$\u003c/code\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这实际上就是核函数选择为二阶多项式核的 SVM 模型。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这样设计的模型看起来能够学习到特征两两交叉带来的信息了。但这只是理论上的改进，别忘了我们从工程背景中抽象出来的问题中的第一条要求：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由于 \u003ccode\u003e$w_{i, j}$\u003c/code\u003e 的取值\u003cstrong\u003e完全取决于 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 的乘积\u003c/strong\u003e，在数据稀疏的场景下，可能存在训练集中 \u003ccode\u003e$x_ix_j$\u003c/code\u003e 始终为零的情况。这样一来，模型就无法有效地更新权重 \u003ccode\u003e$w_{i, j}$\u003c/code\u003e 了；更进一步，在预测阶段，模型遇到 \u003ccode\u003e$x_ix_j$\u003c/code\u003e 不为零的情况可能就很难有效地泛化。\u003c/p\u003e\n\u003ch3 id=\"因子分解机模型\"\u003e\u003ca href=\"#因子分解机模型\" class=\"headerlink\" title=\"因子分解机模型\"\u003e\u003c/a\u003e因子分解机模型\u003c/h3\u003e\u003cp\u003e既然二阶多项式核 SVM 泛化性能不足的原因是「\u003ccode\u003e$w_{i, j}$\u003c/code\u003e 的取值\u003cstrong\u003e完全取决于 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 的乘积\u003c/strong\u003e」，那么最直接的办法就是突破这一限制了。\u003c/p\u003e\n\u003cp\u003eFM 模型的解决办法是为每个维度的特征（\u003ccode\u003e$x_i$\u003c/code\u003e）学习一个表征向量（\u003ccode\u003e$v_i$\u003c/code\u003e，其实可以理解为是特征 ID 的 embedding 向量）。而后将 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 的乘积的权重设定为各自表征向量的点积。也就是有如下形式的预测函数：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\hat y = f(\\vec x) = w_0 + \\sum_{i = 1}^{n}w_ix_i + \\sum_{0 \u0026lt; i \u0026lt; j \u0026lt;= n}\\langle \\vec v_i, \\vec v_j\\rangle x_ix_j.$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e显然，FM 模型也具有二阶多项式核 SVM 的优点：能够学习到特征两两交叉带来的信息。那么现在的问题是，为什么相对二阶多项式核 SVM 做出的改进能够提高模型的泛化性能？\u003c/p\u003e\n\u003cp\u003e如果你熟悉现在深度学习中各种对 item 的 embedding 操作，那么这个问题就不难理解了。FM 模型的表征向量相比深度学习中各种 embedding 其实是一回事——只是少了若干层 MLP，而是直接对交叉特征的组合进行建模。\u003c/p\u003e\n\u003cp\u003e我们回到上一小节举的例子：训练集中 \u003ccode\u003e$x_ix_j$\u003c/code\u003e 始终为零。在二阶多项式核 SVM 中，由于参数权重 \u003ccode\u003e$w_{i, j}$\u003c/code\u003e 得不到更新，模型无法学到 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 交叉带来的信息。但是在 FM 中，\u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 的参数并不完全由 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_j$\u003c/code\u003e 的乘积决定。具体来说，每一维特征的表征向量由该维特征与其它所有维度特征的交叉共同决定。于是，只要存在某个 \u003ccode\u003e$k$\u003c/code\u003e 使得 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_k$\u003c/code\u003e 的乘积不总是为零，那么第 \u003ccode\u003e$i$\u003c/code\u003e 维特征的表征向量 \u003ccode\u003e$\\vec v_i$\u003c/code\u003e 就能够学到有效的信息——同理对 \u003ccode\u003e$\\vec v_j$\u003c/code\u003e 也有同样的结论。于是乎，哪怕在训练集中，\u003ccode\u003e$x_ix_j$\u003c/code\u003e 始终为零，其参数 \u003ccode\u003e$\\langle \\vec v_i, \\vec v_j\\rangle$\u003c/code\u003e 也是经过了学习更新的，因此能够表现出很好的泛化性能。\u003c/p\u003e\n\u003cp\u003e也许有人会说，如果不存在这样的 \u003ccode\u003e$k$\u003c/code\u003e 使得 \u003ccode\u003e$x_i$\u003c/code\u003e 和 \u003ccode\u003e$x_k$\u003c/code\u003e 的乘积不总是为零，会怎么样呢？好吧，这就意味着这一维特征的取值永远是零——那它还有什么意义？从特征列表中删掉它就好啦！\u003c/p\u003e\n\u003ch2 id=\"效率问题\"\u003e\u003ca href=\"#效率问题\" class=\"headerlink\" title=\"效率问题\"\u003e\u003c/a\u003e效率问题\u003c/h2\u003e\u003cp\u003e在文章开篇，我们提到「LR 可以以很高的效率去学习和预测，因而在很多领域都被广泛应用」。那么 FM 模型如何呢？如果 FM 模型训练和预测都死慢死慢地，那么工程师迭代模型的效率会非常低，上线后 serving 的开销也会很大。这样一来，等待 FM 模型的最终结果必然是被抛弃……\u003c/p\u003e\n\u003cp\u003e考虑到 FM 模型会对特征进行二阶组合，在有 $n$ 个原始特征时，交叉特征就会有 \u003ccode\u003e$\\frac{n ^ 2 - n}{2}$\u003c/code\u003e 个。因此，如果不做任何优化，FM 模型的复杂度会是 \u003ccode\u003e$O(n^2)$\u003c/code\u003e，具体来说是 \u003ccode\u003e$O(kn^2)$\u003c/code\u003e（其中 \u003ccode\u003e$k$\u003c/code\u003e 是表征向量的长度）。在特征规模非常大的场景中，这是不可接受的。\u003c/p\u003e\n\u003cp\u003e那么问题来了，是否有办法将复杂度降低到 \u003ccode\u003e$O(kn)$\u003c/code\u003e 呢？答案是可以的，我们来看针对特征交叉项的一系列变换。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$\\begin{aligned} \\sum_{0 \u0026lt; i \u0026lt; j \u0026lt;= n}\\langle \\vec v_i, \\vec v_j\\rangle x_ix_j     \u0026amp;{} = \\sum_{i = 1}^{n - 1}\\sum_{j = i + 1}^{n} \\langle \\vec v_i, \\vec v_j\\rangle x_ix_j \\\\     \u0026amp;{} = \\frac{1}{2}\\sum_{i = 1}^{n}\\sum_{j = 1}^{n}\\langle \\vec v_i, \\vec v_j\\rangle x_ix_j - \\frac{1}{2}\\sum_{i = 1}^{n}\\langle \\vec v_i, \\vec v_i\\rangle x_ix_i \\\\     \u0026amp;{} = \\frac{1}{2}\\biggl(\\sum_{i = 1}^{n}\\sum_{j = 1}^{n}\\sum_{d = 1}^{k}\\vec v_{i, d}\\vec v_{j, d}x_ix_j - \\sum_{i = 1}^{n}\\sum_{d = 1}^{k}\\vec v_{i, d}^2x_i^2\\biggr) \\\\     \u0026amp;{} = \\frac{1}{2}\\sum_{d = 1}^{k}\\biggl(\\sum_{i = 1}^{n}\\sum_{j = 1}^{n}\\vec v_{i, d}\\vec v_{j, d}x_ix_j - \\sum_{i = 1}^{n}\\vec v_{i, d}^2x_i^2\\biggr) \\\\     \u0026amp;{} = \\frac{1}{2}\\sum_{d = 1}^{k}\\biggl(\\Bigl(\\sum_{i = 1}^{n}\\vec v_{i, d}x_i\\Bigr)\\Bigl(\\sum_{j = 1}^{n}\\vec v_{j, d}x_j\\Bigr) - \\sum_{i = 1}^{n}\\vec v_{i, d}^2x_i^2\\biggr) \\\\     \u0026amp;{} = \\frac{1}{2}\\sum_{d = 1}^{k}\\biggl(\\Bigl(\\sum_{i = 1}^{n}\\vec v_{i, d}x_i\\Bigr)^2 - \\sum_{i = 1}^{n}\\vec v_{i, d}^2x_i^2\\biggr). \\end{aligned}$$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e等式第一行是一个平凡的变换，很容易理解。\u003c/p\u003e\n\u003cp\u003e等式第二行修改了求和符号的范围。原本的求和符号中有 \u003ccode\u003e$\\frac{n ^ 2 - n}{2}$\u003c/code\u003e 项；变换之后第一项中的求和符号有 \u003ccode\u003e$n^2$\u003c/code\u003e 项，第二项中的求和符号有 \u003ccode\u003e$n$\u003c/code\u003e 项。因此两式恰好相等。\u003c/p\u003e\n\u003cp\u003e等式第三行是对向量内积的展开，很容易理解。\u003c/p\u003e\n\u003cp\u003e等式第四行是运用了加法的结合律，将 \u003ccode\u003e$\\sum_{d = 1}^{k}$\u003c/code\u003e 抽到外面，这步容易理解。\u003c/p\u003e\n\u003cp\u003e等式第五行是连续两次逆向使用了乘法对加法的分配率（提取公因子），这一步可能稍微难理解一些。简便起见，我们将 \u003ccode\u003e$\\vec v_{i, d}x_i$\u003c/code\u003e 记作 \u003ccode\u003e$a_i$\u003c/code\u003e；将 \u003ccode\u003e$\\vec v_{j, d}x_j$\u003c/code\u003e 记作 \u003ccode\u003e$a_j$\u003c/code\u003e。则变换前的公式记作 \u003ccode\u003e$\\sum_{i = 1}^{n}\\sum_{j = 1}^{n}a_ia_j$\u003c/code\u003e。将它展开是：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} \\sum_{i = 1}^{n}\\sum_{j = 1}^{n}a_ia_j    = {}\u0026amp; a_1a_1 + a_1a_2 + \\cdots + a_1a_n + \\\\      {}\u0026amp; a_2a_1 + a_2a_2 + \\cdots + a_2a_n + \\\\      {}\u0026amp; \\cdots + \\\\      {}\u0026amp; a_na_1 + a_na_2 + \\cdots + a_na_n \\\\    = {}\u0026amp; a_1\\bigl(a_1 + a_2 + \\cdots + a_n\\bigr) + \\\\      {}\u0026amp; a_2\\bigl(a_1 + a_2 + \\cdots + a_n\\bigr) + \\\\      {}\u0026amp; \\cdots + \\\\      {}\u0026amp; a_n\\bigl(a_1 + a_2 + \\cdots + a_n\\bigr) \\\\    = {}\u0026amp; a_1\\Bigl(\\sum_{j = 1}^{n}a_j\\Bigr) + a_2\\Bigl(\\sum_{j = 1}^{n}a_j\\Bigr) + \\cdots + a_n\\Bigl(\\sum_{j = 1}^{n}a_j\\Bigr) \\\\    = {}\u0026amp; \\sum_{i = 1}^{n}a_i\\sum_{j = 1}^{n}a_j \\\\    = {}\u0026amp; \\Bigl(\\sum_{i = 1}^{n}\\vec v_{i, d}x_i\\Bigr)\\Bigl(\\sum_{j = 1}^{n}\\vec v_{j, d}x_j\\Bigr). \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e等式第六行也很明显。第五行的结果中的两个求和项仅仅是下标不同，实际上完全是一回事，因此直接平方就好了。\u003c/p\u003e\n\u003cp\u003e如此一来，FM 的预测公式变成了下面这样\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} \\hat y   \u0026amp;{} = f(\\vec x) \\\\   \u0026amp;{} = w_0 + \\sum_{i = 1}^{n}w_ix_i + \\frac{1}{2}\\sum_{d = 1}^{k}\\biggl(\\Bigl(\\sum_{i = 1}^{n}\\vec v_{i, d}x_i\\Bigr)^2 - \\sum_{i = 1}^{n}\\vec v_{i, d}^2x_i^2\\biggr). \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e显然，它的复杂度是 \u003ccode\u003e$O(kn)$\u003c/code\u003e。考虑到特征的稀疏性，尽管 \u003ccode\u003e$n$\u003c/code\u003e 可能很大，但很多 \u003ccode\u003e$x_i$\u003c/code\u003e 都是零。因此其实际复杂度应该是 \u003ccode\u003e$O(k\\bar n)$\u003c/code\u003e——其中 \u003ccode\u003e$\\bar n$\u003c/code\u003e 表示样本不为零的特征维度数量的平均值。\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e\u003ca href=\"#总结\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h2\u003e\u003cp\u003e总结一下。FM 模型不仅在模型本身能够满足下列两个特性，还保证了训练和预测的效率为 \u003ccode\u003e$O(k\\bar n)$\u003c/code\u003e，因而是非常优秀的模型、被广泛运用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e能够处理大规模的稀疏数据，并保有足够好的泛化性能（generalization performance）；\u003c/li\u003e\n\u003cli\u003e同时，能够自动地学习到特征交叉带来的信息。\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-03-25T02:56:24Z",
  "Author": "Liam Huang"
}