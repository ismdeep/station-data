{
  "Source": "liam.page",
  "Title": "LaTeX 字体机制简介",
  "Link": "https://liam.page/2016/12/11/LaTeX-traditional-font-scheme/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e一直有很多人闹不清 \u003ccode\u003e.def\u003c/code\u003e, \u003ccode\u003e.fd\u003c/code\u003e, \u003ccode\u003e.pfb\u003c/code\u003e 之类文件的作用，这里正好看到 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://tex.stackexchange.com/users/4427/egreg\"\u003eegreg\u003c/a\u003e 的回答，感觉很好，就翻译过来。\u003c/p\u003e\n\u003cp\u003e原文地址：\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://tex.stackexchange.com/a/119501/38350\"\u003ehttp://tex.stackexchange.com/a/119501/38350\u003c/a\u003e\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"def-文件\"\u003e\u003ca href=\"#def-文件\" class=\"headerlink\" title=\".def 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.def\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e\u003ccode\u003et1enc.def\u003c/code\u003e 之类的 \u003ccode\u003e\u0026lt;encoding\u0026gt;enc.def\u003c/code\u003e 文件定义了字符形状（glyph）与编码的对应关系，LaTeX 读入这些文件之后，才能在相应的编码下正确调用字符形状来排版。在任意时刻，都有一个\u003cem\u003e当前的字体编码\u003c/em\u003e。诸如 \u003ccode\u003e\\\u0026#34;{o}\u003c/code\u003e 的命令，在不同编码下的效果是不一样的。例如，在 OT1 编码下（或是其它不包含字符形状 ö 的编码），\u003ccode\u003e\\\u0026#34;{o}\u003c/code\u003e 会被翻译成 \u003ccode\u003e\\accent\u0026#34;7F o\u003c/code\u003e；在 T1 编码下，则是 \u003ccode\u003e\\char\u0026#34;F6\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e当加载 \u003ccode\u003efontenc\u003c/code\u003e 宏包的时候，LaTeX 就会读入 \u003ccode\u003e\u0026lt;encoding\u0026gt;enc.def\u003c/code\u003e 文件。具体读入的文件，由 \u003ccode\u003efontenc\u003c/code\u003e 宏包的参数确定。每次读入 \u003ccode\u003e\u0026lt;encoding\u0026gt;enc.def\u003c/code\u003e 文件就改变一次当前字体编码。和大多数宏包不同，\u003ccode\u003efontenc\u003c/code\u003e 宏包可以加载多次，以便根据不同的字体指定不同的编码。有一些字体相关的宏包，会在内部隐式地调用 \u003ccode\u003efontenc\u003c/code\u003e 宏包（比如 \u003ccode\u003etextcomp\u003c/code\u003e 宏包）。在 \u003ccode\u003e\\begin{document}\u003c/code\u003e 处的字体编码，则是最后一次传给 \u003ccode\u003efontenc\u003c/code\u003e 宏包的参数。\u003c/p\u003e\n\u003cp\u003e除了 \u003ccode\u003e\u0026lt;encoding\u0026gt;enc.def\u003c/code\u003e 类型的文件，还有其他一些 \u003ccode\u003e.def\u003c/code\u003e 文件。不过这些文件就和字体没关系了。\u003c/p\u003e\n\u003ch2 id=\"fd-文件\"\u003e\u003ca href=\"#fd-文件\" class=\"headerlink\" title=\".fd 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.fd\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e当 LaTeX 遇到 \u003ccode\u003e\\fontfamily{\u0026lt;family\u0026gt;}\\selectfont\u003c/code\u003e 的时候（可能隐式地调用，比如在 \u003ccode\u003e\\ttfamily\u003c/code\u003e 之类的字体声明处，以及在 \u003ccode\u003e\\textsf\u003c/code\u003e 之类的字体命令处），LaTeX 会在内部表中查询是否有已知的，由 \u003ccode\u003e\\DeclareFontFamily{\u0026lt;encoding\u0026gt;}{\u0026lt;family\u0026gt;}{\u0026lt;tokens\u0026gt;}\u003c/code\u003e 定义的组合\u003c/p\u003e\n\u003cfigure class=\"highlight tex\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u0026lt;encoding\u0026gt;+\u0026lt;family\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，\u003ccode\u003e\u0026lt;encoding\u0026gt;\u003c/code\u003e 就是当前的字体编码。\u003c/p\u003e\n\u003cp\u003e假设当前的字体编码是 T1，然后希望使用 Palatino 字族（\u003ccode\u003eppl\u003c/code\u003e），但 \u003ccode\u003eT1+ppl\u003c/code\u003e 的组合没有定义（也就是 \u003ccode\u003e\\T1+ppl\u003c/code\u003e 命令未定义，对的，命令中间有个加号），那么 LaTeX 就会去寻找 \u003ccode\u003et1ppl.fd\u003c/code\u003e 或者大写版本的 \u003ccode\u003eT1ppl.fd\u003c/code\u003e 文件。\u003c/p\u003e\n\u003cp\u003e如果二者都找不到，那么 LaTeX 就会输出警告，告诉用户「当前的字体我找不到，不过我会用另外的字体来替代」。不过，这种替代，不会改变当前的字体编码。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.fd\u003c/code\u003e 文件总是以 \u003ccode\u003e\\DeclareFontFamily\u003c/code\u003e 声明开头，然后跟着若干个 \u003ccode\u003e\\DeclareFontShape\u003c/code\u003e 命令。这些命令组合在一起，对应了 \u003ccode\u003e\u0026lt;encoding\u0026gt;+\u0026lt;family\u0026gt;\u003c/code\u003e 的组合。\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://texdoc.net/texmf-dist/doc/latex/base/fntguide.pdf\"\u003e\u003ccode\u003efntguide.pdf\u003c/code\u003e\u003c/a\u003e 里有更详细的介绍。\u003c/p\u003e\n\u003cp\u003e当然，你也可以在导言区里写 \u003ccode\u003e\\DeclareFontFamily\u003c/code\u003e 或者 \u003ccode\u003e\\DeclareFontShape\u003c/code\u003e 这样的命令。\u003ccode\u003e\\DeclareFontShape\u003c/code\u003e 必须与紧跟的 \u003ccode\u003e\\DeclareFontFamily\u003c/code\u003e 对应。这些声明会对应字体四个维度的属性声明，并对应一个字体尺寸文件（font metric file）。在我们的例子中\u003c/p\u003e\n\u003cfigure class=\"highlight tex\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e\\usefont\u003c/span\u003e{T1}{ppl}{b}{up}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e会指向 \u003ccode\u003epplb8t\u003c/code\u003e 这个字体尺寸。具体来说，字体尺寸文件又两种：\u003ccode\u003e.vf\u003c/code\u003e 文件或者 \u003ccode\u003e.tfm\u003c/code\u003e 文件。如果存在 \u003ccode\u003epplb8t.vf\u003c/code\u003e 文件，那么 TeX 会优先加载它，否则就会加载 \u003ccode\u003epplb8t.tfm\u003c/code\u003e 文件。二者必需有一个，否则就会报错。\u003c/p\u003e\n\u003cp\u003e在 \u003ccode\u003e\\DeclareFontShape\u003c/code\u003e 命令中，你可以设定字体替换等规则；如果 LaTeX 没有找到合适的字体替换规则，那么就会使用默认字体去替换。如果 \u003ccode\u003e.fd\u003c/code\u003e 文件里，或者导言区中的，\u003ccode\u003e\\DeclareFontShape\u003c/code\u003e 写错了，也会导致错误（\u003ccode\u003eCorrupt NFSS tables\u003c/code\u003e）。\u003c/p\u003e\n\u003cp\u003e接下来，假设 TeX 找到了 \u003ccode\u003epplb8t.vf\u003c/code\u003e 或者 \u003ccode\u003epplb8t.tfm\u003c/code\u003e 文件。\u003c/p\u003e\n\u003ch2 id=\"vf-文件\"\u003e\u003ca href=\"#vf-文件\" class=\"headerlink\" title=\".vf 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.vf\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e字体尺寸文件可以是\u003cem\u003e虚拟的\u003c/em\u003e，\u003ccode\u003epplb8t\u003c/code\u003e 正是这种情况。\u003ccode\u003e.vf\u003c/code\u003e 尺寸文件中有字符边界框、意大利体修正、铅空、连字等信息，还有一些关于从其它文件中（虚拟的或者实际存在的）选择实际字符形状的信息。在本例中，\u003ccode\u003epplb8t.vf\u003c/code\u003e 选择了一个实际存在的字符形状 \u003ccode\u003epplb8r\u003c/code\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight tex\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(MAPFONT D 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (FONTNAME pplb8r)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (FONTCHECKSUM O 25012244013)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (FONTAT R 1.0)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (FONTDSIZE R 10.0)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   )\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e并按照 T1 字体编码重新对字符形状做了排序。例如，在 \u003ccode\u003epplb8t.vf\u003c/code\u003e 的 \u003ccode\u003e\u0026#34;F7\u003c/code\u003e 位上 （八进制 \u003ccode\u003e `367\u003c/code\u003e），有如下声明\u003c/p\u003e\n\u003cfigure class=\"highlight tex\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(CHARACTER O 367\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (CHARWD R 0.832996)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (CHARHT R 0.485498)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (CHARDP R 0.011493)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   (MAP\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      (SETCHAR O 234)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   )\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这是说，字符形状 \u003ccode\u003eœ\u003c/code\u003e（你在 LaTeX 里可以用 \u003ccode\u003e\\oe\u003c/code\u003e 输出它）实际会在 \u003ccode\u003epplb8r\u003c/code\u003e 的以八进制计算的第 \u003ccode\u003e `234\u003c/code\u003e 个位置（十六进制：\u003ccode\u003e\u0026#34;9C\u003c/code\u003e）中取得，不过实际的用户是不会想关心它的。这里也包含了关于字符形状的尺寸信息：宽度 8.32996pt、高度 4.85498pt、深度 0.11493pt，并且意大利体修正为 0（这是在字体大小为 10pt 时候的值，否则需要按比例做额外的换算）。\u003c/p\u003e\n\u003ch2 id=\"tfm-文件\"\u003e\u003ca href=\"#tfm-文件\" class=\"headerlink\" title=\".tfm 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.tfm\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e\u003ccode\u003e.tfm\u003c/code\u003e 文件（在本例中 \u003ccode\u003epplb8r.tfm\u003c/code\u003e 文件必须存在）中的内容格式和 \u003ccode\u003e.vf\u003c/code\u003e 文件的格式完全相同，不过，它可以指向其他字体尺寸文件。\u003c/p\u003e\n\u003ch2 id=\"打住\"\u003e\u003ca href=\"#打住\" class=\"headerlink\" title=\"打住\"\u003e\u003c/a\u003e打住\u003c/h2\u003e\u003cp\u003e实际上，TeX 引擎关心的东西到这里就结束了：根据字符尺寸将字符排版并按页输出。打印或预览的驱动才会实际去关注字符形状。不过，对 pdfTeX 来说，它也需要储存所有的字符形状（译注：因为要直接输出 PDF 文件，必须知道字符形状）。\u003c/p\u003e\n\u003ch2 id=\"map-文件\"\u003e\u003ca href=\"#map-文件\" class=\"headerlink\" title=\".map 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.map\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e粗体的字形 \u003ccode\u003eœ\u003c/code\u003e 最终从 \u003ccode\u003epplb8r\u003c/code\u003e 里取得。因此 pdfTeX 会读取已经加载的 \u003ccode\u003e.map\u003c/code\u003e 文件（默认是 \u003ccode\u003epdftex.map\u003c/code\u003e），在其中查找以 \u003ccode\u003epplb8r\u003c/code\u003e 开头的条目\u003c/p\u003e\n\u003cfigure class=\"highlight tex\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003epplb8r URWPalladioL-Bold \u0026#34; TeXBase1Encoding ReEncodeFont \u0026#34; \u0026lt;8r.enc \u0026lt;uplb8a.pfb\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e于是，pdfTeX 会读取 Type1 字体文件 \u003ccode\u003euplb8a.pfb\u003c/code\u003e（如果已经读取过了就不会再次读取了），然后，pdfTeX 会对字体文件\u003cem\u003e重新编码\u003c/em\u003e。这是因为 \u003ccode\u003e.pfb\u003c/code\u003e 文件是以 Adobe Standard Encoding 编码保存的，并且有一些字符形状在这种情况下是隐藏起来的。 于是，驱动（译注：在 pdfTeX 的情况下，驱动就是它自己）会根据 \u003ccode\u003e8r\u003c/code\u003e 编码（与 T1 类似，但不推荐在实际文稿中使用）重新排布字符形状的顺序。此时，字符形状 \u003ccode\u003eœ\u003c/code\u003e 会被保存在 \u003ccode\u003e\u0026#34;F7\u003c/code\u003e 位置（而不是 Adobe Standard Encoding 中的 \u003ccode\u003e\u0026#34;FA\u003c/code\u003e）。此外，字符形状 \u003ccode\u003eö\u003c/code\u003e 不在 Adobe Standard Encoding 当中，不过它在 \u003ccode\u003e.pfb\u003c/code\u003e 文件中以未编码的形式存在着；在 \u003ccode\u003e8r\u003c/code\u003e 编码中，它被保存在 \u003ccode\u003e\u0026#34;F6\u003c/code\u003e 位置。\u003c/p\u003e\n\u003cp\u003e我们需要的是 \u003ccode\u003epplb8a\u003c/code\u003e，为什么最后读取的是 \u003ccode\u003euplb8a\u003c/code\u003e 呢？这是因为，字体最终是由 URW 提供的免费版本。当然，实际用户是不会关注这个的。\u003c/p\u003e\n\u003ch2 id=\"pfb-文件\"\u003e\u003ca href=\"#pfb-文件\" class=\"headerlink\" title=\".pfb 文件\"\u003e\u003c/a\u003e\u003ccode\u003e.pfb\u003c/code\u003e 文件\u003c/h2\u003e\u003cp\u003e\u003ccode\u003e.pfb\u003c/code\u003e 文件包含了字符的形状，它们决定了字符在打印（或者预览）中是怎样呈现的。这些文件不会被用户直接调取，而是被引擎或者驱动程序调用。当然，也有 \u003ccode\u003e.pfa\u003c/code\u003e 文件，它和 \u003ccode\u003e.pfb\u003c/code\u003e 文件储存的信息完全相同，只不过它是用可见的 ASCII 码字符来储存信息的，因此它会比相应的 \u003ccode\u003e.pfb\u003c/code\u003e 文件要大出不少。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e译注：\u003cbr/\u003e在现代的 TeX 发行版中，有名为 \u003ccode\u003etex-font-cheatsheet.pdf\u003c/code\u003e 的文件。你可以在系统命令行中执行 \u003ccode\u003etexdoc tex-font-cheatsheet\u003c/code\u003e 打开它。有惊喜！\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于本篇的捐助，将用于支持 TeX 在中文界的发展。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-12-11T13:23:20Z",
  "Author": "Liam Huang"
}