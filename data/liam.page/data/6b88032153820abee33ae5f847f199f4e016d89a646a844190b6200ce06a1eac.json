{
  "Source": "liam.page",
  "Title": "调度场算法",
  "Link": "https://liam.page/2016/12/14/Shunting-Yard-Algorithm/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e在软件工程课中，有一个经典的作业题：实现一个小学四则运算器。当然，它有不少变种，比如要求学生预先生成合规的四则运算题目。但不论如何变形，此类问题都绕不开 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Edsger_Dijkstra\"\u003eDijkstra\u003c/a\u003e 提出的调度场算法。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"回顾问题\"\u003e\u003ca href=\"#回顾问题\" class=\"headerlink\" title=\"回顾问题\"\u003e\u003c/a\u003e回顾问题\u003c/h2\u003e\u003cp\u003e对于中国人来说，可能从小学学会四则运算开始，这件事情就变成了深入骨髓的本能。类似的问题，可能还有：人脸识别、性别判断等等。对于计算机而言，似乎有这样一个悖论：有一些对人而言非常自然和简单的事情，想要用有效的算法表示出来，就不那么容易。\u003c/p\u003e\n\u003cp\u003e比如，对于一个四则运算式子\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1 + 2 * (3 + (4 + 5 - 6) * 2)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于人来说，可能一眼扫过去，就知道应该怎样运算。可是，当被问及下面这个问题的时候，人们就很难回答了：怎样让计算机理解你使用的算法，并有足够的通用性去解决普遍的四则运算问题（带括号）。但不论如何，我们还是要回到这个问题本身，尝试理清一下，我们究竟是怎样在大脑里处理四则运算的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e首先，我们定义了「先乘除、后加减」的优先级规则，所有的运算都应该遵循这个规则。\u003c/li\u003e\n\u003cli\u003e其次，对于有括号的式子，我们会找到括号层次最深的部分（在这里就是 \u003ccode\u003e4 + 5 - 6\u003c/code\u003e），按照上述规则进行计算，逐层脱去括号。等到没有括号的时候，再依据基本的规则计算最终结果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e有人可能会说：你看，其实还是很简单的嘛，几句话就说清楚了。其实不然，原因有几个：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e对于人来说，可以一观全貌，因此可以轻易地找到括号嵌套最深的部分。但是对于计算机而言，必须逐个 token (numbers and operators) 地读入，经过一系列的判断才能确定嵌套最深的部分。\u003c/li\u003e\n\u003cli\u003e对于人来说，可以一观全貌，因此可以轻松地判断是否还有括号。但对于计算机而言，每次脱去一层括号的时候，都需要完整地将式子扫描一遍（或者将记录扫描一遍），才能确定这个问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e稍有算法分析和设计经验的人，可能会很敏感地发现：这事儿复杂度很高。其实不光是算法复杂度很高，用程序设计语言描述算法这件事情本身就很复杂——你试过就知道，你需要写一大堆的 if-else 才能完成这一任务。甚至，还有我们未曾考虑的问题：如何判断确定式子的合法性（比如括号是否成对）。\u003c/p\u003e\n\u003ch2 id=\"人类的习惯与计算机的习惯\"\u003e\u003ca href=\"#人类的习惯与计算机的习惯\" class=\"headerlink\" title=\"人类的习惯与计算机的习惯\"\u003e\u003c/a\u003e人类的习惯与计算机的习惯\u003c/h2\u003e\u003cp\u003e通过上面的说明，不难发现，这一件人类看起来相当简单的问题，对计算机来说不那么好处理。这话有些耳熟不是吗？哦，原来，在制作计算机之处，人们就发现用电路表示十进制运算，很困难。当然，这个问题早就解决了，因为人们发现，电路的通断很自然地就对应了二进制的 0 和 1。因此，在计算机内部，运算都是以二进制的形式展现的，只有到了呈现给人看的时候，才转换成十进制。这就引出了一个问题：十进制运算对人来说很自然，这是人类的习惯（因为人有十个手指，可能？），但是计算机看不懂；同时，二进制对于计算机来说很自然，这是计算机的习惯，但是人类读起二进制的 01 串，就费劲得很。\u003c/p\u003e\n\u003cp\u003e这件事情应该于我们有启发：处理带括号的四则运算这件事情，在计算机看来很复杂，究竟是因为问题本身困难？还是因为问题的形式不好？答案似乎是显而易见的——如果问题本身困难，那么人类也就无法快速学会四则运算了。所以，我们需要寻找问题的另一种展现形式。\u003c/p\u003e\n\u003ch2 id=\"中缀表达式与后缀表达式\"\u003e\u003ca href=\"#中缀表达式与后缀表达式\" class=\"headerlink\" title=\"中缀表达式与后缀表达式\"\u003e\u003c/a\u003e中缀表达式与后缀表达式\u003c/h2\u003e\u003cp\u003e之前我们举过例子，给了一个简单的四则运算式子。这个式子，还有我们过去见过的大部分数学式子，都是用\u003cstrong\u003e中缀表达式\u003c/strong\u003e呈现的。有这些例子打底，顾名思义，不难理解何谓中缀表达式：将操作符（加减乘除符号）置于操作数中间的算式表示法，就是中缀表示法；对应的算式就是中缀表达式。\u003c/p\u003e\n\u003cp\u003e刚才说到，中缀表达式在人类看起来很简单和直观，但是对于计算机而言就不那么方便处理了。为此，我们需要引入另一种算式的表示方法：后缀表达式（逆波兰表达式）。它的特点有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e操作符置于被操作数的后面；\u003c/li\u003e\n\u003cli\u003e不需要括号，也不需要定义优先级，只需从左到右依次计算即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e显而易见，操作符置于什么地方本身并不能解决痛点，但是省略了括号和优先级，就能正确计算结果，才是对计算机来说最重要的特性。就刚才的式子来说，转换成后缀表达式应该是：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1 2 3 4 5 + 6 - 2 * + * +\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对计算机来说，它只需要从左向右扫描后缀表达式，每当遇到操作符的时候，就停下来，取出刚才读入的合适数量的操作数进行计算。而后它需要将计算结果放回序列，再重复整个步骤，直到完成计算就可以了。\u003c/p\u003e\n\u003cp\u003e现在的问题是，我们要如何快速有效地将中缀表达式转换成后缀表达式，以便计算机能够顺利处理。\u003c/p\u003e\n\u003ch2 id=\"调度场算法\"\u003e\u003ca href=\"#调度场算法\" class=\"headerlink\" title=\"调度场算法\"\u003e\u003c/a\u003e调度场算法\u003c/h2\u003e\u003ch3 id=\"理想的算法是怎样的？\"\u003e\u003ca href=\"#理想的算法是怎样的？\" class=\"headerlink\" title=\"理想的算法是怎样的？\"\u003e\u003c/a\u003e理想的算法是怎样的？\u003c/h3\u003e\u003cp\u003e事情总是从易到难，慢慢解决的。我们先看一个简单的例子，它不包含括号这种恼人的东西。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1 + 2 * 3 / 4 - 5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们希望，一个完美的算法，能够从左往右扫描中缀表达式，然后就能得到等价的后缀表达式。虽然我们暂时不知道这个算法长什么样，不过我们可以先扫描试试看。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入操作数 \u003ccode\u003e1\u003c/code\u003e，将它放在结果序列中\u003c/li\u003e\n\u003cli\u003e读入操作符 \u003ccode\u003e+\u003c/code\u003e，将它暂时保存在\u003cstrong\u003e某个地方\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e尽管这个式子里，没有括号，但是仍然有操作符的优先级问题。现在，我们读入了操作符 \u003ccode\u003e+\u003c/code\u003e，问题就来了：我们不知道在 \u003ccode\u003e+\u003c/code\u003e 的后面，是否有优先级更高的操作符，会和它「争抢」操作数（也就是优先进行运算）。因此，我们不能将它直接放在结果序列中。因为，在后缀表达式中，操作符执行的顺序只取决于操作符在表达式中的顺序为止；如果我们将 \u003ccode\u003e+\u003c/code\u003e 直接放在结果序列中，那么即使后续有优先级更高的操作符出现，按照规则也只能先执行 \u003ccode\u003e+\u003c/code\u003e。因此，我们需要将 \u003ccode\u003e+\u003c/code\u003e 暂时保存在某个地方。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入操作数 \u003ccode\u003e2\u003c/code\u003e，将它放在结果序列中\u003c/li\u003e\n\u003cli\u003e读入操作符 \u003ccode\u003e*\u003c/code\u003e，将它与那个地方最后的操作符 \u003ccode\u003e+\u003c/code\u003e 比较后，发现当前操作符的优先级更高\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在遇到了操作符 \u003ccode\u003e*\u003c/code\u003e，和「某个地方」最后的操作符 \u003ccode\u003e+\u003c/code\u003e 相比，\u003ccode\u003e*\u003c/code\u003e 的优先级更高。因此，在运算时，我们必须先执行 \u003ccode\u003e*\u003c/code\u003e 再执行 \u003ccode\u003e+\u003c/code\u003e。这毫无疑问。不过，尽管 \u003ccode\u003e*\u003c/code\u003e 的优先级更高，我们也依然无法保证后面是否会有更高优先级的运算符出现。因此我们仍然将 \u003ccode\u003e*\u003c/code\u003e 暂存。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入操作数 \u003ccode\u003e3\u003c/code\u003e，将它放在结果序列中\u003c/li\u003e\n\u003cli\u003e读入操作符 \u003ccode\u003e/\u003c/code\u003e，将它与那个地方最后的操作符 \u003ccode\u003e*\u003c/code\u003e 比较后，发现二者优先级一致\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在我们遇到了 \u003ccode\u003e/\u003c/code\u003e，它的优先级与「那个地方」最后的操作符一致。我们知道 \u003ccode\u003e*\u003c/code\u003e 和 \u003ccode\u003e/\u003c/code\u003e 都是左结合的，也就是说，应该按顺序从左向右计算。所以，应该先计算 \u003ccode\u003e*\u003c/code\u003e 再计算 \u003ccode\u003e/\u003c/code\u003e。因此我们\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将那个地方最后的运算符 \u003ccode\u003e*\u003c/code\u003e 取出，放入结果序列\u003c/li\u003e\n\u003cli\u003e紧接着，将 \u003ccode\u003e/\u003c/code\u003e 放入那个地方\u003c/li\u003e\n\u003cli\u003e读入操作数 \u003ccode\u003e4\u003c/code\u003e，将它放在结果序列中\u003c/li\u003e\n\u003cli\u003e读入操作符 \u003ccode\u003e-\u003c/code\u003e，与那个地方最后的操作符 \u003ccode\u003e/\u003c/code\u003e 比较，发现当前操作符的优先级更低\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e显而易见，当前操作符优先级低，就应该先进行 \u003ccode\u003e/\u003c/code\u003e 的计算。因此\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将那个地方最后的运算符 \u003ccode\u003e/\u003c/code\u003e 取出，放入结果序列\u003c/li\u003e\n\u003cli\u003e将当前操作符 \u003ccode\u003e-\u003c/code\u003e 与那个地方最后的操作符 \u003ccode\u003e+\u003c/code\u003e 比较，发现二者优先级一致（遇到了熟悉的情况）\u003c/li\u003e\n\u003cli\u003e将那个地方最后的运算符 \u003ccode\u003e+\u003c/code\u003e 取出，放入结果序列\u003c/li\u003e\n\u003cli\u003e紧接着，将 \u003ccode\u003e-\u003c/code\u003e 放入那个地方\u003c/li\u003e\n\u003cli\u003e读入操作数 \u003ccode\u003e5\u003c/code\u003e，放入结果序列\u003c/li\u003e\n\u003cli\u003e读入完毕，将那个地方剩余的操作符 \u003ccode\u003e-\u003c/code\u003e 取出，于是得到\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1 2 3 * 4 / + 5 -\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e完美！总结一下，我们不难发现整个流程有以下一些特点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e每次遇到操作数，都直接放入结果序列；\u003c/li\u003e\n\u003cli\u003e每次遇到操作符，都要与那个地方做比较，当\u003cbr/\u003e a. 当前操作符优先级较高，则将当前操作符放进那个地方；否则，\u003cbr/\u003e b. 将那个地方最后的操作符取出并放入结果序列，并将当前操作符放进那个地方\u003c/li\u003e\n\u003cli\u003e结果序列是顺序填充的，一旦填充就确定位置不会更改；\u003c/li\u003e\n\u003cli\u003e那个地方挺神秘的，不过\u003cbr/\u003e a. 任意时刻，那个地方先进去的操作符总是在优先级上低于后进去的操作符；因此\u003cbr/\u003e b. 在从那个地方取出操作符的时候，总是先取出后进去的操作符\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e不难发现，「那个地方」所具有的性质，就是一个\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Stack_(abstract_data_type\"\u003e栈\u003c/a\u003e所具有的性质。因此，我们说，在这套流程里，我们需要一个栈作为辅助的数据结构，而作为结果序列，则只需要一个顺序表即可。我们将整个过程整理如下。\u003c/p\u003e\n\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003cth\u003e输入\u003c/th\u003e\u003cth\u003e动作\u003c/th\u003e\u003cth\u003e输出\u003c/th\u003e\u003cth\u003e操作符栈\u003c/th\u003e\u003cth\u003e说明\u003c/th\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e将操作数加入输出队列\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e+\u003c/td\u003e\u003ctd\u003e操作符压栈\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e+\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e2\u003c/td\u003e\u003ctd\u003e将操作数加入输出队列\u003c/td\u003e\u003ctd\u003e1 2\u003c/td\u003e\u003ctd\u003e+\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e\\*\u003c/td\u003e\u003ctd\u003e操作符压栈\u003c/td\u003e\u003ctd\u003e1 2\u003c/td\u003e\u003ctd\u003e+ \\*\u003c/td\u003e\u003ctd\u003e当前操作符优先级高于栈顶\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e3\u003c/td\u003e\u003ctd\u003e将操作数加入输出队列\u003c/td\u003e\u003ctd\u003e1 2 3\u003c/td\u003e\u003ctd\u003e+ \\*\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd rowspan=\"2\"\u003e/\u003c/td\u003e\u003ctd\u003e操作符弹栈入列\u003c/td\u003e\u003ctd\u003e1 2 3 \\*\u003c/td\u003e\u003ctd\u003e+\u003c/td\u003e\u003ctd\u003e当前操作符优先级与栈顶相等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e操作符压栈\u003c/td\u003e\u003ctd\u003e1 2 3 \\*\u003c/td\u003e\u003ctd\u003e+ /\u003c/td\u003e\u003ctd\u003e当前操作符优先级高\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e4\u003c/td\u003e\u003ctd\u003e将操作数加入输出队列\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4\u003c/td\u003e\u003ctd\u003e+ /\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd rowspan=\"3\"\u003e-\u003c/td\u003e\u003ctd\u003e操作符弹栈入列\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4 /\u003c/td\u003e\u003ctd\u003e+\u003c/td\u003e\u003ctd\u003e当前操作符优先级低于栈顶\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e操作符弹栈入列\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4 / +\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e当前操作符优先级与栈顶相等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e操作符压栈\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4 / +\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e5\u003c/td\u003e\u003ctd\u003e将操作数加入输出队列\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4 / + 5\u003c/td\u003e\u003ctd\u003e-\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEOL\u003c/td\u003e\u003ctd\u003e弹栈入列至空\u003c/td\u003e\u003ctd\u003e1 2 3 \\* 4 / + 5 -\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e又有来自 Wikipedia 的图解（类似但不完全相同的问题）\u003cbr/\u003e\u003cimg data-src=\"/uploads/images/ACS/Shunting_yard.png\"/\u003e\u003cbr/\u003e由 \u003ca target=\"_blank\" rel=\"noopener\" href=\"//commons.wikimedia.org/wiki/User:Salix_alba\" title=\"User:Salix alba\"\u003eSalix alba\u003c/a\u003e - \u003cspan class=\"int-own-work\" lang=\"zh-cn\"\u003e 自己的作品\u003c/span\u003e，\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://creativecommons.org/licenses/by-sa/3.0\" title=\"Creative Commons Attribution-Share Alike 3.0\"\u003eCC BY-SA 3.0\u003c/a\u003e，\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://commons.wikimedia.org/w/index.php?curid=10960619\"\u003e链接\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e从图解中不难看出，操作符栈的行为，与供火车检修用和调度用的调度场非常相似，所以这个算法得名「调度场算法（Shunting Yard Algorithm）」.\u003c/p\u003e\n\u003ch3 id=\"算法描述\"\u003e\u003ca href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"\u003e\u003c/a\u003e算法描述\u003c/h3\u003e\u003cp\u003e经过了上面的分析，你应该已经对调度场算法有了大致的了解。剩余的内容，就是如何将括号，以及右结合的操作符纳入考量范围的过程了。不过，有了上面详细的分析，这些都不难。因此，这里就直接给出算法描述。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e读入一个记号，直到无记号可读\u003cul\u003e\n\u003cli\u003e如果记号是操作数，则加入输出队列\u003c/li\u003e\n\u003cli\u003e如果记号是操作符，记作 $O_c$\u003cul\u003e\n\u003cli\u003e若 $O_c$ 是左结合的且优先级\u003cstrong\u003e不高于\u003c/strong\u003e栈顶，或者 $O_c$ 是右结合的且优先级\u003cstrong\u003e低于\u003c/strong\u003e栈顶，则弹栈入列，直到条件被打破；\u003c/li\u003e\n\u003cli\u003e$O_c$ 压栈\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果记号是左括号，则压栈\u003c/li\u003e\n\u003cli\u003e如果记号是右括号，则\u003cul\u003e\n\u003cli\u003e弹栈入列，直到遇见左括号\u003c/li\u003e\n\u003cli\u003e弹栈，丢弃左括号\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e若遇见左括号之前，栈为空\u003c/strong\u003e，则括号不匹配（右括号多）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e无记号可读时\u003cul\u003e\n\u003cli\u003e弹栈入列，直至栈空\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e若栈空之前遇见左括号\u003c/strong\u003e，则括号不匹配（左括号多）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-12-14T00:21:33Z",
  "Author": "Liam Huang"
}