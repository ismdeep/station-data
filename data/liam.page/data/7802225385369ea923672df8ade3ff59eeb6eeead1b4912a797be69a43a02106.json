{
  "Source": "liam.page",
  "Title": "删除 Hive SQL 查询结果中的重复内容",
  "Link": "https://liam.page/2020/05/14/remove-duplicate-entries-in-Hive-SQL/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e最近用 Hive 实在太频繁了，此篇继续讲 Hive。\u003c/p\u003e\n\u003cp\u003e此篇遇到的问题是要以某几列为 key，对 Hive SQL \u003ccode\u003eSELECT\u003c/code\u003e 出来的数据进行去重。以下逐步讨论。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"DISTINCT\"\u003e\u003ca href=\"#DISTINCT\" class=\"headerlink\" title=\"DISTINCT\"\u003e\u003c/a\u003e\u003ccode\u003eDISTINCT\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e说到要去重，自然会想到 \u003ccode\u003eDISTINCT\u003c/code\u003e。但是在 Hive SQL 里，它有两个问题。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDISTINCT\u003c/code\u003e 会以 \u003ccode\u003eSELECT\u003c/code\u003e 出的全部列作为 key 进行去重。也就是说，只要有一列的数据不同，\u003ccode\u003eDISTINCT\u003c/code\u003e 就认为是不同数据而保留。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDISTINCT\u003c/code\u003e 会将全部数据打到一个 reducer 上执行，造成严重的数据倾斜，耗时巨大。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"ROW-NUMBER-OVER\"\u003e\u003ca href=\"#ROW-NUMBER-OVER\" class=\"headerlink\" title=\"ROW_NUMBER() OVER\"\u003e\u003c/a\u003e\u003ccode\u003eROW_NUMBER() OVER\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eDISTINCT\u003c/code\u003e 的两个问题，用 \u003ccode\u003eROW_NUMBER() OVER\u003c/code\u003e 可解。比如，如果我们要按 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 两列为 key 去重，就会写出这样的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eWITH\u003c/span\u003e temp_table \u003cspan class=\"keyword\"\u003eAS\u003c/span\u003e (\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    key1,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    key2,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    [columns]...,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eROW_NUMBER\u003c/span\u003e() \u003cspan class=\"keyword\"\u003eOVER\u003c/span\u003e (\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003ePARTITION\u003c/span\u003e \u003cspan class=\"keyword\"\u003eBY\u003c/span\u003e key1, key2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      \u003cspan class=\"keyword\"\u003eORDER\u003c/span\u003e \u003cspan class=\"keyword\"\u003eBY\u003c/span\u003e \u003cspan class=\"keyword\"\u003ecolumn\u003c/span\u003e \u003cspan class=\"keyword\"\u003eASC\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ) \u003cspan class=\"keyword\"\u003eAS\u003c/span\u003e rn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003etable\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  key1,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  key2,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  [columns]...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  temp_table\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eWHERE\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  rn \u003cspan class=\"operator\"\u003e=\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样，Hive 会按 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 为 key，将数据打到不同的 mapper 上，然后对 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 都相同的一组数据，按 \u003ccode\u003ecolumn\u003c/code\u003e 升序排列，并最终在每组中保留排列后的第一条数据。借此就完成了按 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 两列为 key 的去重任务。\u003c/p\u003e\n\u003cp\u003e注意 \u003ccode\u003ePARTITION BY\u003c/code\u003e 在此起到的作用：一是按 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 打散数据，解决上述问题 (2)；二是与 \u003ccode\u003eORDER BY\u003c/code\u003e 和 \u003ccode\u003ern = 1\u003c/code\u003e 的条件结合，按 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 对数据进行分组去重，解决上述问题 (1)。\u003c/p\u003e\n\u003cp\u003e但显然，这样做十分不优雅（not-elegant），并且不难想见其效率比较低。\u003c/p\u003e\n\u003ch2 id=\"GROUP-BY-和-COLLECT-SET-x2F-COLLECT-LIST\"\u003e\u003ca href=\"#GROUP-BY-和-COLLECT-SET-x2F-COLLECT-LIST\" class=\"headerlink\" title=\"GROUP BY 和 COLLECT_SET/COLLECT_LIST\"\u003e\u003c/a\u003e\u003ccode\u003eGROUP BY\u003c/code\u003e 和 \u003ccode\u003eCOLLECT_SET\u003c/code\u003e/\u003ccode\u003eCOLLECT_LIST\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eROW_NUMBER() OVER\u003c/code\u003e 的解法的一个核心是利用 \u003ccode\u003ePARTITION BY\u003c/code\u003e 对数据按 key 分组，同样的功能用 \u003ccode\u003eGROUP BY\u003c/code\u003e 也可以实现。但是，\u003ccode\u003eGROUP BY\u003c/code\u003e 需要与聚合函数搭配使用。\u003ccode\u003eORDER BY\u003c/code\u003e 和 \u003ccode\u003ern = 1\u003c/code\u003e 的条件结合起来实现了「保留第一条」的功能。我们需要考虑，什么样的聚合函数能实现或者间接实现这样的功能呢？不难想到有 \u003ccode\u003eCOLLECT_SET\u003c/code\u003e 和 \u003ccode\u003eCOLLECT_LIST\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e于是有这样的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight sql\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eSELECT\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  key1,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  key2,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  [COLLECT_LIST(\u003cspan class=\"keyword\"\u003ecolumn\u003c/span\u003e)[\u003cspan class=\"number\"\u003e1\u003c/span\u003e] \u003cspan class=\"keyword\"\u003eAS\u003c/span\u003e \u003cspan class=\"keyword\"\u003ecolumn\u003c/span\u003e]...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eFROM\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  temp_table\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eGROUP\u003c/span\u003e \u003cspan class=\"keyword\"\u003eBY\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  key1, key2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于 \u003ccode\u003ekey1\u003c/code\u003e 和 \u003ccode\u003ekey2\u003c/code\u003e 以外的列，我们用 \u003ccode\u003eCOLLECT_LIST\u003c/code\u003e 将他们收集起来，然后输出第一个收集进来的结果。这里使用 \u003ccode\u003eCOLLECT_LIST\u003c/code\u003e 而非 \u003ccode\u003eCOLLECT_SET\u003c/code\u003e 的原因在于 SET 内是无序的，因此你无法保证输出的 columns 都来自同一条数据。若对于此没有要求或限制，则可以使用 \u003ccode\u003eCOLLECT_SET\u003c/code\u003e，它会更节省资源。\u003c/p\u003e\n\u003cp\u003e相比前一种办法，由于省略了排序和（可能的）落盘动作，所以效率会高不少。但是因为（可能）不落盘，所以 \u003ccode\u003eCOLLECT_LIST\u003c/code\u003e 中的数据都会缓存在内存当中。如果重复数量特别大，这种方法可能会触发 OOM。此时应考虑将数据进一步打散，然后再合并；或者干脆换用前一种办法。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-05-14T02:17:16Z",
  "Author": "Liam Huang"
}