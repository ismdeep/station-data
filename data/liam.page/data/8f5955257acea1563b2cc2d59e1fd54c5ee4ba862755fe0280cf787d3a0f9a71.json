{
  "Source": "liam.page",
  "Title": "字符串匹配：KMP 算法",
  "Link": "https://liam.page/2016/12/20/KMP-Algorithm/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e所谓字符串匹配，就是拿着一个字符串（也称为模式串），去到另一个字符串（母串）里去查找完全相同的子串的过程。显然，只要能定义相等关系，那么字符串匹配算法可以扩展到任意的序列匹配算法。因此，这会是一类用途很广的算法。\u003c/p\u003e\n\u003cp\u003e解决字符串匹配问题，最朴素的办法就是拿着模式串逐字符地沿着待匹配的串去比对，每次向前移动一个字符，直到完全匹配或者找不到匹配。显然，这个算法的复杂度是 $O(n\\cdot m)$（$n$ 表示母串的长度，$m$ 表示模式串的长度），是比较高的。\u003c/p\u003e\n\u003cp\u003e这里介绍的 KMP 算法，能够在 $O(n)$ 时间内完成任务，它是由 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Donald_Knuth\"\u003eDonald Knuth\u003c/a\u003e/\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/James_H._Morris\"\u003eJames H. Morris\u003c/a\u003e/\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Vaughan_Pratt\"\u003eVaughan Pratt\u003c/a\u003e 发明的。当然，你也可以称之为「看毛片算法」——你高兴就好。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"从朴素算法开始\"\u003e\u003ca href=\"#从朴素算法开始\" class=\"headerlink\" title=\"从朴素算法开始\"\u003e\u003c/a\u003e从朴素算法开始\u003c/h2\u003e\u003cp\u003e为了体现 KMP 算法的优势，也为了更容易地说明问题，我们先从最朴素的算法开始。\u003c/p\u003e\n\u003cp\u003e假设有\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e母串 \u003ccode\u003eS\u003c/code\u003e: \u003ccode\u003eababaababc\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e模式串 \u003ccode\u003eP\u003c/code\u003e: \u003ccode\u003eababc\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在我们的任务是在母串中找到与模式串完全相同的子串。朴素地算法是这样的：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e将母串与模式串从头对齐；\u003c/li\u003e\n\u003cli\u003e从模式串的头部开始与母串对比\u003cbr/\u003ea. 若字符相同，则继续对比；\u003cbr/\u003eb. 若字符相同，且当前字符是模式串的最后一个字符，则匹配成功；\u003cbr/\u003ec. 若字符不同，则将模式串沿着母串向后移动一位，再从头开始匹配；\u003cbr/\u003ed. 若字符不同，且当前字符是母串的最后一个字符，则匹配失败。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在我们的示例里，具体的操作流程是这样的。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 从头开始匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabab|aababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabab|c\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ea|babaababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e |ababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eababa|ababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  aba|bc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eaba|baababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   |ababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eababa|ababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    a|babc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eababaababc|\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e     ababc|\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配成功，返回子串在母串中的位置\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"对多余工作的分析\"\u003e\u003ca href=\"#对多余工作的分析\" class=\"headerlink\" title=\"对多余工作的分析\"\u003e\u003c/a\u003e对多余工作的分析\u003c/h2\u003e\u003cp\u003e优化算法一个很重要的方法，就是寻找重复/多余的工作，然后用合适的方法去除它们。因此，我们应该试着分析上述朴素算法，看看有哪些工作是多余的，或者是重复的。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 从头开始匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabab|aababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabab|c\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-\u0026gt; \u003cspan class=\"comment\"\u003e# 匹配失败，移动一位，继续尝试匹配\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ea|babaababc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e |ababc\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们来观察第一次匹配失败，沿着母串移动模式串的位置的过程。匹配失败，是因为 \u003ccode\u003eS[0:4] == P[0:4]\u003c/code\u003e 但是 \u003ccode\u003eS[4] != P[4]\u003c/code\u003e。于是我们将 \u003ccode\u003eP[0]\u003c/code\u003e 对齐 \u003ccode\u003eS[1]\u003c/code\u003e，继续尝试匹配。但是，实际上在验证 \u003ccode\u003eS[0:4] == P[0:4]\u003c/code\u003e 的过程中，我们已经知道了 \u003ccode\u003eS[0] == P[0] and S[0] != S[1]\u003c/code\u003e。因此，如果将 \u003ccode\u003eP[0]\u003c/code\u003e 与 \u003ccode\u003eS[1]\u003c/code\u003e 对齐，那么必然是匹配失败的。\u003c/p\u003e\n\u003cp\u003e既然在匹配的过程中，我们获得的信息，已经足够说明仅仅移动一位，必然匹配失败。那么这就是多余的工作，我们应该想办法规避掉这些多余的工作。那么，我们应该怎么办呢？\u003c/p\u003e\n\u003cp\u003e注意，在第一次尝试匹配的过程中，我们确定了 \u003ccode\u003eS[0:4] == P[0:4]\u003c/code\u003e，又容易观察，对于模式串 \u003ccode\u003eP\u003c/code\u003e 来说，有 \u003ccode\u003eP[0:2] == P[4 - 2:4]\u003c/code\u003e；即模式串 \u003ccode\u003eP\u003c/code\u003e 成功匹配的部分中，它的首两个字符与末两个字符完全相同。于是，因为 \u003ccode\u003eS[0:4] == P[0:4]\u003c/code\u003e，所以我们有 \u003ccode\u003eS[4 - 2:4] == P[4 - 2:4] == P[0:2]\u003c/code\u003e。这也就是说，如果将模式串对齐 \u003ccode\u003eS[4 - 2]\u003c/code\u003e 位置，我们天然就能确认两个位置的匹配，只需要接着向后尝试匹配就可以了——KMP 算法就是这样做的。\u003c/p\u003e\n\u003cp\u003e总结起来就是：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e S[i:i + j] == P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:j] \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e S[i + j] != P[j]: \u003cspan class=\"comment\"\u003e# i + j \u0026lt; n and j \u0026lt; m\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    k = argmax(k){P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:k] == P[j - k:j]} \u003cspan class=\"comment\"\u003e# 0 \u0026lt;= k \u0026lt; j\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    align P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e] to S[i + j - k]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这个优化中，我们让模式串尽可能快地沿着母串向前跳跃；同时尽可能多地保留了已匹配的信息，避免接下来重复匹配。这一优化的关键，就是对每一个 \u003ccode\u003ej\u003c/code\u003e，在模式串中寻找最大的 \u003ccode\u003ek\u003c/code\u003e，使得 \u003ccode\u003eP[0:k] == P[j - k:j]\u003c/code\u003e。显然，对于给定的模式串 \u003ccode\u003eP\u003c/code\u003e，\u003ccode\u003ek\u003c/code\u003e 的取值只与 \u003ccode\u003ej\u003c/code\u003e 有关；我们记作 $k = f(j;P)$，并称之为模式串 \u003ccode\u003eP\u003c/code\u003e 的部分匹配函数。接下来，我们要看看如何快速地得到这个部分匹配函数。\u003c/p\u003e\n\u003ch2 id=\"部分匹配函数\"\u003e\u003ca href=\"#部分匹配函数\" class=\"headerlink\" title=\"部分匹配函数\"\u003e\u003c/a\u003e部分匹配函数\u003c/h2\u003e\u003cp\u003e根据定义，不难发现\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e$$ \\begin{aligned} f(1) \u0026amp;{}= 0. \\end{aligned} $$\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e接下来我们看一个稍微复杂一点的模式串 \u003ccode\u003eP = ababacb\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ej:    \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e \u003cspan class=\"number\"\u003e2\u003c/span\u003e \u003cspan class=\"number\"\u003e3\u003c/span\u003e \u003cspan class=\"number\"\u003e4\u003c/span\u003e \u003cspan class=\"number\"\u003e5\u003c/span\u003e \u003cspan class=\"number\"\u003e6\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eP:    a b a b a c b\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ef(j):   \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"number\"\u003e1\u003c/span\u003e \u003cspan class=\"number\"\u003e2\u003c/span\u003e \u003cspan class=\"number\"\u003e3\u003c/span\u003e ?\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们来验证一下\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ej == \u003cspan class=\"number\"\u003e2\u003c/span\u003e: P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e0\u003c/span\u003e](\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e) == P[j - \u003cspan class=\"number\"\u003e0\u003c/span\u003e:j](\u003cspan class=\"literal\"\u003eNone\u003c/span\u003e) \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e1\u003c/span\u003e](a)    != P[j - \u003cspan class=\"number\"\u003e1\u003c/span\u003e:j](b)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ej == \u003cspan class=\"number\"\u003e3\u003c/span\u003e: P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e1\u003c/span\u003e](a)    == P[j - \u003cspan class=\"number\"\u003e1\u003c/span\u003e:j](a)    \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e2\u003c/span\u003e](ab)   != P[j - \u003cspan class=\"number\"\u003e2\u003c/span\u003e:j](ba)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ej == \u003cspan class=\"number\"\u003e4\u003c/span\u003e: P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e2\u003c/span\u003e](ab)   == P[j - \u003cspan class=\"number\"\u003e2\u003c/span\u003e:j](ab)   \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e3\u003c/span\u003e](aba)  != P[j - \u003cspan class=\"number\"\u003e3\u003c/span\u003e:j](bab)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ej == \u003cspan class=\"number\"\u003e5\u003c/span\u003e: P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e3\u003c/span\u003e](aba)  == P[j - \u003cspan class=\"number\"\u003e3\u003c/span\u003e:j](aba)  \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e P[\u003cspan class=\"number\"\u003e0\u003c/span\u003e:\u003cspan class=\"number\"\u003e4\u003c/span\u003e](abab) != P[j - \u003cspan class=\"number\"\u003e4\u003c/span\u003e:j](baba)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e很好，没有问题。接下来我们看 $f(6)$ 是多少。遇到这样的问题，我们就会想，$f(j)$ 组成的序列，后项是否会与前项有关，存在某种递推关系呢？因此我们会做这样的分析。\u003c/p\u003e\n\u003cp\u003e首先，因为 $f(5) = 3$，所以我们知道 \u003ccode\u003eP[0:3] == P[5 - 3:5] == P[2:5]\u003c/code\u003e。现在，如果有 \u003ccode\u003eP[3] == P[5]\u003c/code\u003e，也就是 \u003ccode\u003eP[f(5)] == P[5]\u003c/code\u003e，那么 $f(6) = f(5) + 1$。但是现在 \u003ccode\u003eP[3] == b != P[5] == c\u003c/code\u003e，因此 $f(6) = f(5) + 1$ 不成立。\u003c/p\u003e\n\u003cp\u003e接下来，我们考虑 $f(f(5)) = f(3) = 1$。为什么考虑 $f(3)$ 而不是 $f(4)$ 呢？这是因为，我们已知 $f(5) = 3$，所以有 \u003ccode\u003eP[0:3] == P[2:5]\u003c/code\u003e；同时已知 $f(3) = 1$，就有 \u003ccode\u003eP[0:1] == P[2:3] == P[4:5]\u003c/code\u003e。而 \u003ccode\u003eP[4:5]\u003c/code\u003e 与当前待考虑的字符 \u003ccode\u003eP[5]\u003c/code\u003e 是紧挨着的。于是，如果我们有 \u003ccode\u003eP[f(3)] == P[5]\u003c/code\u003e，那么 $f(6) = f(3) + 1$。但是现在 \u003ccode\u003eP[1] == b != P[5] == c\u003c/code\u003e，因此 $f(6) = f(3) + 1$ 也不成立。\u003c/p\u003e\n\u003cp\u003e按照同样的分析，我们接下来应该考虑 $f(f(f(5))) = f(1) = 0$。但显然，\u003ccode\u003eP[0] == a != P[5] == c\u003c/code\u003e，因此 $f(6) = f(1) + 1$ 也不成立；于是只能是 $f(6) = 0$ 了。\u003c/p\u003e\n\u003cp\u003e也就是说，对于已经求得前 $k$ 项部分匹配的模式串 \u003ccode\u003eP\u003c/code\u003e 来说，起第 $k + 1$ 项的部分匹配函数的值可以这样计算：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ep_table = [-\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e, ...]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eptr = k\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e ptr \u0026gt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e pattern[k] != pattern[res[ptr]]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ptr = p_table[ptr]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    p_table.append(p_table[ptr] + \u003cspan class=\"number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这样一来，我们就能快速地计算任意的模式串 \u003ccode\u003eP\u003c/code\u003e 的部分匹配表了。\u003c/p\u003e\n\u003ch2 id=\"KMP-算法的实现示例\"\u003e\u003ca href=\"#KMP-算法的实现示例\" class=\"headerlink\" title=\"KMP 算法的实现示例\"\u003e\u003c/a\u003eKMP 算法的实现示例\u003c/h2\u003e\u003cp\u003e经过上面的分析，我们很自然地就能得到 KMP 算法（以下是一个用 Python 的实现）。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003egetPartialTable\u003c/span\u003e(\u003cspan class=\"params\"\u003epattern\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"keyword\"\u003enot\u003c/span\u003e pattern:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    lp = \u003cspan class=\"built_in\"\u003elen\u003c/span\u003e(pattern)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    res = [-\u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e lp \u0026gt; \u003cspan class=\"number\"\u003e1\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e curr \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e xrange(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, lp):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            ptr = curr\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e ptr \u0026gt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e pattern[curr] != pattern[res[ptr]]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                ptr = res[ptr]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                res.append(res[ptr] + \u003cspan class=\"number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e res\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"title function_\"\u003ematchPatternKMP\u003c/span\u003e(\u003cspan class=\"params\"\u003estring, pattern\u003c/span\u003e):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"keyword\"\u003enot\u003c/span\u003e string \u003cspan class=\"keyword\"\u003eor\u003c/span\u003e \u003cspan class=\"keyword\"\u003enot\u003c/span\u003e pattern:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    p_table = getPartialTable(pattern)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    start, matched = \u003cspan class=\"number\"\u003e0\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ls, lp  = \u003cspan class=\"built_in\"\u003elen\u003c/span\u003e(string), \u003cspan class=\"built_in\"\u003elen\u003c/span\u003e(pattern)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    stop    = ls - lp + \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    res     = \u003cspan class=\"built_in\"\u003elist\u003c/span\u003e()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e matched == lp \u003cspan class=\"keyword\"\u003eor\u003c/span\u003e string[start + matched] != pattern[matched]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e matched == lp:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                res.append(start)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            start   += matched - p_table[matched]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            matched  = \u003cspan class=\"built_in\"\u003emax\u003c/span\u003e(\u003cspan class=\"number\"\u003e0\u003c/span\u003e, p_table[matched])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"keyword\"\u003enot\u003c/span\u003e start \u0026lt; stop:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e res\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            matched += \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e __name__ == \u003cspan class=\"string\"\u003e\u0026#39;__main__\u0026#39;\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    string  = \u003cspan class=\"string\"\u003e\u0026#39;abababaababacbababacb\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    pattern = \u003cspan class=\"string\"\u003e\u0026#39;aaa\u0026#39;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprint\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026#39;string:\\t\\t%s\\npattern:\\t%s\u0026#39;\u003c/span\u003e % (string, pattern)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprint\u003c/span\u003e matchPatternKMP(string, pattern)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"复杂度分析\"\u003e\u003ca href=\"#复杂度分析\" class=\"headerlink\" title=\"复杂度分析\"\u003e\u003c/a\u003e复杂度分析\u003c/h2\u003e\u003cp\u003e好了，现在我们知道为什么 KMP 算法很快，也有了具体的实现。但是，它到底有多快呢？换句话说，它的时间复杂度是怎样的呢？\u003c/p\u003e\n\u003cp\u003e我们先来看算法的主体部分：\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e \u003cspan class=\"literal\"\u003eTrue\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e matched == lp \u003cspan class=\"keyword\"\u003eor\u003c/span\u003e string[start + matched] != pattern[matched]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e matched == lp:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            res.append(start)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        start   += matched - p_table[matched]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        matched  = \u003cspan class=\"built_in\"\u003emax\u003c/span\u003e(\u003cspan class=\"number\"\u003e0\u003c/span\u003e, p_table[matched])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"keyword\"\u003enot\u003c/span\u003e start \u0026lt; stop:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e res\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        matched += \u003cspan class=\"number\"\u003e1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先注意到，在 \u003ccode\u003ewhile\u003c/code\u003e 循环内部，算法执行的操作数目是固定的；同时，每次循环失败，都可能执行最多 $m - 1$ 次 \u003ccode\u003ematched += 1\u003c/code\u003e。因此，整个算法的总体复杂度，就取决于 \u003ccode\u003ewhile\u003c/code\u003e 循环会被执行多少次。而要确定循环执行的次数，就要观察循环变量的初始值、中间变化和终止条件。\u003c/p\u003e\n\u003cp\u003e无疑，循环的终止条件与 \u003ccode\u003estart\u003c/code\u003e 有关：它从 \u003ccode\u003e0\u003c/code\u003e 开始，每次进入循环体都会自增，直到 \u003ccode\u003estart \u0026lt; stop\u003c/code\u003e 的条件被破坏。因此，整个循环最多被执行 \u003ccode\u003estop\u003c/code\u003e 次；整个算法最多有 $(n - m)\\cdot m$ 次操作。看起来，这是一个复杂度为 $O(n\\cdot m)$ 的算法。然而这是一个足够严格的渐进界限吗？答案是否定的，我们需要使用摊还分析来处理这个算法。\u003c/p\u003e\n\u003cp\u003e所谓摊还分析，就是抓住某一个变量（或者函数）的性质和行为，对零散、杂乱或不规则的执行进行累计，得到比一般方法更严格的上界。在这里，我们观察 \u003ccode\u003ematched\u003c/code\u003e 变量。它具有这样的性质：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0 \u0026lt;= matched \u0026lt;= m\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e只在第 10 行增加，每次增加 1；\u003c/li\u003e\n\u003cli\u003e只在第 6 行有可能减少。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e考虑到循环的终止条件，第 10 行最多被执行 \u003ccode\u003estop\u003c/code\u003e 次；也就是 \u003ccode\u003ematched\u003c/code\u003e 最多自增 \u003ccode\u003estop\u003c/code\u003e 次。考虑到 \u003ccode\u003ematched\u003c/code\u003e 必须保证非负，并且每次执行到第 6 行 \u003ccode\u003ematched\u003c/code\u003e 都会至少减小 \u003ccode\u003e1\u003c/code\u003e，所以第 6 行也最多被执行 \u003ccode\u003estop\u003c/code\u003e 次。这也就是说，整个部分最多有 $2 \\cdot \\text{stop}$ 次操作。因此，它的时间复杂度不超过 $O(n)$。\u003c/p\u003e\n\u003cp\u003e同样的，我们可以用摊还分析的方法，分析部分匹配表的算法。\u003c/p\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efor\u003c/span\u003e curr \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e xrange(\u003cspan class=\"number\"\u003e1\u003c/span\u003e, lp):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ptr = curr\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e ptr \u0026gt; \u003cspan class=\"number\"\u003e0\u003c/span\u003e \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e pattern[curr] != pattern[res[ptr]]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        ptr = res[ptr]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        res.append(res[ptr] + \u003cspan class=\"number\"\u003e1\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在这里，我们观察 \u003ccode\u003eres\u003c/code\u003e 这个部分匹配表；它具有这样的性质：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e0\u0026lt;= res[ptr] \u0026lt;= lp\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eres[res[ptr]] \u0026lt; res[ptr]\u003c/code\u003e，只在第 4 行出现 \u003ccode\u003eres[ptr]\u003c/code\u003e 当前值减小的情况；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eres[ptr] \u0026lt;= res[ptr - 1] + 1\u003c/code\u003e，只在第 6 行有可能成立等号。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e很眼熟，对吗？这个分析过程和 KMP 算法的主体几乎一模一样。事实上，求得部分匹配表的过程，就是拿模式串自己匹配自己的过程；无怪乎它和算法主体很相似了。同样，考虑到循环的终止条件，求得部分匹配表的过程，复杂度不超过 $O(m)$。\u003c/p\u003e\n\u003cp\u003e因此，考虑到总是有 $m \u0026lt; n$，整个 KMP 算法的时间复杂度不超过 $O(n)$。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-12-20T04:53:08Z",
  "Author": "Liam Huang"
}