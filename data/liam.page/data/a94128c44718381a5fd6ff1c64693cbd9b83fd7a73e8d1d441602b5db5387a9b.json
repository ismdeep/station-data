{
  "Source": "liam.page",
  "Title": "取得一个整型变量二进制表示的最后一个「1」",
  "Link": "https://liam.page/2015/10/02/how-to-get-the-last-1-bit-of-an-integer/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e在实际工作中，我需要取得一个整数二进制表示的最后一个「1」在哪里。\u003c/p\u003e\n\u003cp\u003e最朴素的办法，是用短除法，逐次取余数。高明一点的办法，可以是将目标整数向右逐次右移 1 位，然后与常数 \u003ccode\u003e1\u003c/code\u003e 按位取与，结合计数器判断「1」的位置。\u003c/p\u003e\n\u003cp\u003e这里，我们介绍一个更加「聪明」的办法。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"原码、反码和补码\"\u003e\u003ca href=\"#原码、反码和补码\" class=\"headerlink\" title=\"原码、反码和补码\"\u003e\u003c/a\u003e原码、反码和补码\u003c/h2\u003e\u003cp\u003e原码、反码和补码，是讨论整数在计算机中存储方式时用到的术语。\u003c/p\u003e\n\u003cp\u003e原码最好理解，对人类来说最直观。原码用最高位（最左边的二进制位）表示正负号，余下的部分表示数值。比如：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e 20 = 0001 0100(原)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-20 = 1001 0100(原)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于正数来说，其反码和原码一致。对负数来说，反码就是对除去最高符号位之外的所有二进制位取反。比如：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e 20 = 0001 0100(原) = 0001 0100(反)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-20 = 1001 0100(原) = 1110 1011(反)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于正数来说，其补码与反码一致。对负数来说，补码就是对反码做通常意义上的加一操作（含进位）。比如：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e 20 = 0001 0100(原) = 0001 0100(反) = 0001 0100(补)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-20 = 1001 0100(原) = 1110 1011(反) = 1110 1100(补)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e整数在计算机中是以补码的形式储存的，这就是为什么我们要介绍原码、反码和补码。补码的好处，其一是明确了整数「0」的表示（否则可以有 \u003ccode\u003e0000 0000\u003c/code\u003e 和 \u003ccode\u003e1000 0000\u003c/code\u003e 两种方式表示），其二是对整数的加法只需要统一的一套电路来处理即可。\u003c/p\u003e\n\u003ch2 id=\"一点观察\"\u003e\u003ca href=\"#一点观察\" class=\"headerlink\" title=\"一点观察\"\u003e\u003c/a\u003e一点观察\u003c/h2\u003e\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e 20 = 0001 0100(补)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-20 = 1110 1100(补)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上面的例子中，我们注意到两个事实：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e20 的最后一个非零二进制位是倒数第三位（\u003ccode\u003e0100\u003c/code\u003e），-20 的最后一个非零二进制位也恰好是倒数第三位（\u003ccode\u003e1100\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e从倒数第四位开始往前，20 和 -20 的二进制补码，一一对应，两两互补。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这样一来，很容易看出：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e0000 0100(补) = 4 = 20 \u0026amp; -20 = 0001 0100(补) \u0026amp; 1110 1100(补)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e也就是说，20 与其相反数按位取与，就得到了它二进制表示的最后一个「1」；同理，-20 与其相反数按位取于，也能得到想要的结果。\u003c/p\u003e\n\u003cp\u003e这是一个普遍规律吗？让我们多看几个例子。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e0000 0010(补) = 2 = 54 \u0026amp; -54 = 0011 0110(补) \u0026amp; 1100 1010(补)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0000 0001(补) = 1 = 11 \u0026amp; -11 = 0000 1011(补) \u0026amp; 1111 0101(补)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0100 0000(补) = 64 = 64 \u0026amp; -64 = 0100 0000(补) \u0026amp; 1100 0000(补)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e毫无例外，测试的三个整数，都符合我们发现的规律。看起来，这会是一个普遍的规律，因此我们考虑来证明它。\u003c/p\u003e\n\u003ch2 id=\"规律的证明\"\u003e\u003ca href=\"#规律的证明\" class=\"headerlink\" title=\"规律的证明\"\u003e\u003c/a\u003e规律的证明\u003c/h2\u003e\u003cp\u003e现在我们要去证明：任何整数，其二进制补码表示的最后一个「1」，可由该整数与其相反数按位取与得到。\u003c/p\u003e\n\u003ch3 id=\"零的处理\"\u003e\u003ca href=\"#零的处理\" class=\"headerlink\" title=\"零的处理\"\u003e\u003c/a\u003e零的处理\u003c/h3\u003e\u003cp\u003e零的二进制补码：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e0 = 0000 0000(原) = 0000 0000(反) = 0000 0000(补)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-0 = 0 = 0000 0000(原) = 0000 0000(反) = 0000 0000(补)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e显然，\u003ccode\u003e0 \u0026amp; -0 = 0\u003c/code\u003e，说明 0 的二进制表示中没有 1。因此结论对 0 成立。\u003c/p\u003e\n\u003ch3 id=\"非零的处理\"\u003e\u003ca href=\"#非零的处理\" class=\"headerlink\" title=\"非零的处理\"\u003e\u003c/a\u003e非零的处理\u003c/h3\u003e\u003cp\u003e命题是对偶的。显然，如果证明了命题对正整数成立，那么对负整数也成立。因此，我们只需要考虑正整数的情况。\u003c/p\u003e\n\u003cp\u003e现假设，一个正整数二进制表示的最低 k 位均为 0，也就是：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e0(高位部分)1(k 个 0)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e那么，其相反数的反码则是：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1(高位部分按位取反)0(k 个 1)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e按照补码的定义，对相反数的反码做通常意义上的二进制加一操作，注意低位逐次进位，得到：\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1(高位部分按位取反)1(k 个 0)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意到 \u003ccode\u003e0 \u0026amp; 0 = 0 \u0026amp; 1 = 1 \u0026amp; 0 = 0\u003c/code\u003e，所以除了二进制表示中最后一个「1」，在相反数按位取与之后，所有的二进制位都是零。\u003c/p\u003e\n\u003cp\u003e这样一来，我们就证明了结论。\u003c/p\u003e\n\u003ch2 id=\"Cpp-实现\"\u003e\u003ca href=\"#Cpp-实现\" class=\"headerlink\" title=\"Cpp 实现\"\u003e\u003c/a\u003eCpp 实现\u003c/h2\u003e\u003cp\u003e简单用 Cpp 实现了一个测试小工具，用来验证上面的结论：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;iostream\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;stack\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eusing\u003c/span\u003e \u003cspan class=\"keyword\"\u003enamespace\u003c/span\u003e std;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e \u003cspan class=\"params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eint\u003c/span\u003e int_wk;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34;Enter an integer:\u0026#34;\u003c/span\u003e \u0026lt;\u0026lt; endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cin \u0026gt;\u0026gt; int_wk;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eprintBits\u003c/span\u003e \u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e int_input)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintBits\u003c/span\u003e(int_wk);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintBits\u003c/span\u003e(-int_wk);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003eprintBits\u003c/span\u003e((int_wk \u0026amp; -int_wk));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eprintBits\u003c/span\u003e \u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e int_input)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e uns_length = \u003cspan class=\"number\"\u003e8\u003c/span\u003e * \u003cspan class=\"built_in\"\u003esizeof\u003c/span\u003e(int_input);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    stack\u0026lt;\u003cspan class=\"type\"\u003eint\u003c/span\u003e\u0026gt; stack_bits;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e c_int_one = \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34;Parsing the bits of: \u0026#34;\u003c/span\u003e \u0026lt;\u0026lt; int_input \u0026lt;\u0026lt; endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e i = \u003cspan class=\"number\"\u003e0\u003c/span\u003e; i != uns_length; ++i) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003econst\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e tmp = int_input \u0026amp; c_int_one;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        stack_bits.\u003cspan class=\"built_in\"\u003epush\u003c/span\u003e(tmp);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        int_input = int_input \u0026gt;\u0026gt; \u003cspan class=\"number\"\u003e1\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eunsigned\u003c/span\u003e uns_counter = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ewhile\u003c/span\u003e (!stack_bits.\u003cspan class=\"built_in\"\u003eempty\u003c/span\u003e()) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        cout \u0026lt;\u0026lt; stack_bits.\u003cspan class=\"built_in\"\u003etop\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        stack_bits.\u003cspan class=\"built_in\"\u003epop\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (++uns_counter % \u003cspan class=\"number\"\u003e4\u003c/span\u003e == \u003cspan class=\"number\"\u003e0\u003c/span\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            cout \u0026lt;\u0026lt; \u003cspan class=\"string\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cout \u0026lt;\u0026lt; endl;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg data-src=\"/attachment/attachment/images/Cpp/last-nonzero-bit.png\"/\u003e\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2015-10-02T08:29:09Z",
  "Author": "Liam Huang"
}