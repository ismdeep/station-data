{
  "Source": "liam.page",
  "Title": "C++ 中的 typename 及 class 关键字的区别",
  "Link": "https://liam.page/2018/03/16/keywords-typename-and-class-in-Cxx/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e其实这是一个老掉牙的问题，网络上已有很多辨析。但看下来都有遗漏其中一个区别，所以有了这篇文章。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"共同点\"\u003e\u003ca href=\"#共同点\" class=\"headerlink\" title=\"共同点\"\u003e\u003c/a\u003e共同点\u003c/h2\u003e\u003cp\u003e如果两个事物没有任何共同点，那么也就没必要讨论他们的区别——因为他们所有的特性都是区别。所以这里我们首先来看一下 \u003ccode\u003etypename\u003c/code\u003e 和 \u003ccode\u003eclass\u003c/code\u003e 关键字的共同点。\u003c/p\u003e\n\u003cp\u003e在定义类模板或者函数模板时，\u003ccode\u003etypename\u003c/code\u003e 和 \u003ccode\u003eclass\u003c/code\u003e 关键字都可以用于指定模板参数中的类型。也就是说，以下两种用法是完全等价的。这在大多数文章中都有提到。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e T\u0026gt; \u003cspan class=\"comment\"\u003e/* class or function declaration */\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eT\u003c/span\u003e\u0026gt;    \u003cspan class=\"comment\"\u003e/* class or function declaration */\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e关于这个问题，Stan Lippman 曾在其\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://web.archive.org/web/20060619131004/http://blogs.msdn.com/slippman/archive/2004/08/11/212768.aspx\"\u003e博客\u003c/a\u003e中表示，最早 Stroustrup 使用 \u003ccode\u003eclass\u003c/code\u003e 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来委员会认为这样混用可能造成概念上的混淆才加上了 \u003ccode\u003etypename\u003c/code\u003e 关键字。\u003c/p\u003e\n\u003ch2 id=\"typename-独有的功能\"\u003e\u003ca href=\"#typename-独有的功能\" class=\"headerlink\" title=\"typename 独有的功能\"\u003e\u003c/a\u003e\u003ccode\u003etypename\u003c/code\u003e 独有的功能\u003c/h2\u003e\u003cp\u003e除此之外，\u003ccode\u003etypename\u003c/code\u003e 还有其独有的功能。\u003c/p\u003e\n\u003cp\u003e由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 \u003ccode\u003eType::foo\u003c/code\u003e 的写法具体指的是一个类型还是类内成员。\u003c/p\u003e\n\u003cp\u003e例如在以下代码中，类模板 \u003ccode\u003eBar\u003c/code\u003e 的原意是使用类 \u003ccode\u003eFoo\u003c/code\u003e 实例化，而后引用其中的 \u003ccode\u003ebar_type\u003c/code\u003e 定义名为 \u003ccode\u003ebar\u003c/code\u003e 的类内成员。然而，就 \u003ccode\u003eT::bar_type\u003c/code\u003e 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 \u003ccode\u003etypename\u003c/code\u003e 关键字来辅助编译器的判断。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFoo\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003etypedef\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e bar_type;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e\u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e T\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eBar\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"comment\"\u003e/* typename */\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e T::bar_type bar;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这在大多数文章中也都有提到。\u003c/p\u003e\n\u003cp\u003e值得一提的是，在编译期能够判断的情形，例如在上例中直接使用 \u003ccode\u003eFoo::bar_type\u003c/code\u003e 时，使用冗余的 \u003ccode\u003etypename\u003c/code\u003e 会报错。\u003c/p\u003e\n\u003cp\u003e只有少数文章提到了这一点。\u003c/p\u003e\n\u003ch2 id=\"class-独有的功能\"\u003e\u003ca href=\"#class-独有的功能\" class=\"headerlink\" title=\"class 独有的功能\"\u003e\u003c/a\u003e\u003ccode\u003eclass\u003c/code\u003e 独有的功能\u003c/h2\u003e\u003cp\u003e\u003ccode\u003eclass\u003c/code\u003e 关键字最众所周知的功能是声明或定义一个类。这当然是其相对 \u003ccode\u003etypename\u003c/code\u003e 的一个独有功能。为了完整性，这里也列出。\u003c/p\u003e\n\u003cp\u003e除此之外，在模板的使用中，\u003ccode\u003eclass\u003c/code\u003e 关键字也有其特有的功能。而这是绝大多数文章不会提及的。\u003c/p\u003e\n\u003cp\u003eC++ 的标准模板库中有名为 \u003ccode\u003estd::stack\u003c/code\u003e 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e T, \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e Containter = std::deque\u0026lt;T\u0026gt; \u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e stack;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e因此，在使用中，我们可以使用 \u003ccode\u003estd::stack\u0026lt;int\u0026gt;\u003c/code\u003e 来声明一个以 \u003ccode\u003estd::deque\u0026lt;int\u0026gt;\u003c/code\u003e 保存整型变量的栈；也可以使用 \u003ccode\u003estd::stack\u0026lt;int, std::vector\u0026lt;int\u0026gt; \u0026gt;\u003c/code\u003e 来声明一个以 \u003ccode\u003estd::vector\u0026lt;int\u0026gt;\u003c/code\u003e 保存整型变量的栈。\u003c/p\u003e\n\u003cp\u003e现在的问题是，是否有可能以类似 \u003ccode\u003eStack\u0026lt;int, std::vector\u0026gt;\u003c/code\u003e 的形式，来达到同样的目的？\u003c/p\u003e\n\u003cp\u003e为此，我们需要有类似这样的声明\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e T,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003etemplate\u003c/span\u003e \u0026lt;\u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e E, \u003cspan class=\"keyword\"\u003etypename\u003c/span\u003e = std::allocater\u0026lt;E\u0026gt; \u0026gt; \u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e Container = std::deque\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e Stack;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e由于 \u003ccode\u003eContainer\u003c/code\u003e 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，\u003ccode\u003eContainer\u003c/code\u003e 之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器。\u003c/p\u003e\n\u003cp\u003e此处 \u003ccode\u003eclass\u003c/code\u003e 特有的功能，体现在 \u003ccode\u003eclass Container\u003c/code\u003e 之处。此处虽然是在声明 \u003ccode\u003eStack\u003c/code\u003e 这个类模板，但是此处的 \u003ccode\u003eclass\u003c/code\u003e 不能替换为 \u003ccode\u003etypename\u003c/code\u003e；否则编译器会报错。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e不过，在 C++17 标准中，此处也允许使用 \u003ccode\u003etypename\u003c/code\u003e 了。参见\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4051.html\"\u003e此处\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n    \u003c/div\u003e",
  "Date": "2018-03-16T03:20:04Z",
  "Author": "Liam Huang"
}