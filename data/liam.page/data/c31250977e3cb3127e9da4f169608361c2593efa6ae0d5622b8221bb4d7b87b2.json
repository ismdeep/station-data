{
  "Source": "liam.page",
  "Title": "gperftools 中 CPU Profiler 不工作问题的解法",
  "Link": "https://liam.page/2020/06/22/CPU-Profiler-in-gperftools-not-working/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e为了分析服务性能瓶颈，今次我们计划用 gperftools 当中的 CPU Profiler 来打印服务当中的性能热点。按\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://gperftools.github.io/gperftools/cpuprofile.html\"\u003e官网介绍\u003c/a\u003e，以下三种方式之一，可开启 CPU Profiler。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e运行时，用 \u003ccode\u003eLD_PRELOAD\u003c/code\u003e 环境变量加载 CPU Profiler 的共享对象（动态库）。例如 \u003ccode\u003eenv LD_PRELOAD=\u0026#34;/usr/lib/libprofiler.so\u0026#34; /path/to/elf_bin\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e链接时，加上 \u003ccode\u003e-lprofiler\u003c/code\u003e（或者 \u003ccode\u003e-ltcmalloc_and_profiler\u003c/code\u003e，如果还需要 TCMalloc 的话），而后在运行时通过 \u003ccode\u003eenv CPUPROFILE=foo.prof /path/to/elf_bin\u003c/code\u003e 将性能分析文件写入 \u003ccode\u003efoo.prof\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在加上链接参数 \u003ccode\u003e-lprofiler\u003c/code\u003e 的基础上，在代码内引入头文件 \u003ccode\u003e#include \u0026lt;gperftools/profiler.h\u0026gt;\u003c/code\u003e，而后在需要分析性能的代码块前后加上 \u003ccode\u003eProfilerStart(\u0026#34;/path/to/foo.prof\u0026#34;)\u003c/code\u003e 及 \u003ccode\u003eProfilerStop()\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这里 (1) 不需要重新编译，但是一看就很山寨；(3) 在分析特定代码片块的性能时很有效，但在意图分析整个程序的性能时就很鸡肋。目光集中在 (2) 上面。\u003c/p\u003e\n\u003cp\u003e尝试 (2) 时，遇到一个问题。不管如何设置 \u003ccode\u003eCPUPROFILE\u003c/code\u003e，程序都不会将性能分析文件转储出来。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e经过分析，原因水落石出。链接器在链接 \u003ccode\u003elibprofiler\u003c/code\u003e 时，会根据程序中的符号引用情况，将未被引用的符号都删掉。由于我们的代码里，没有引用任何 CPU Profiler 的函数，相当于整个 \u003ccode\u003elibprofiler\u003c/code\u003e 其实没有被链入程序当中。\u003c/p\u003e\n\u003cp\u003e为解决这个问题，最标准的解法，是在 \u003ccode\u003e-lprofiler\u003c/code\u003e 前后加上链接器参数，抑制这种行为：\u003ccode\u003e--no-as-needed\u003c/code\u003e 和 \u003ccode\u003e--as-needed\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果因为种种原因，无法给链接器传参，则可考虑在 \u003ccode\u003emain\u003c/code\u003e 函数返回之前，加入这段代码：\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003evolatile\u003c/span\u003e \u003cspan class=\"type\"\u003ebool\u003c/span\u003e tmp = \u003cspan class=\"literal\"\u003efalse\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (tmp) \u003cspan class=\"built_in\"\u003eProfilerStop\u003c/span\u003e();\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，布尔变量 \u003ccode\u003etmp\u003c/code\u003e 被 \u003ccode\u003evolatile\u003c/code\u003e 修饰，因而编译器不会将其优化掉。而因为我们没有机会改变 \u003ccode\u003etmp\u003c/code\u003e 的值，所以 \u003ccode\u003eProfilerStop()\u003c/code\u003e 没有机会被执行。但是，虽然我们知道这一点，但编译器并不知道。因此，在得到的目标文件之中，会有针对 \u003ccode\u003eProfilerStop\u003c/code\u003e 及相关符号的引用。这样，哪怕不加 \u003ccode\u003e--no-as-needed\u003c/code\u003e 和 \u003ccode\u003e--as-needed\u003c/code\u003e 参数，链接器也会将需要的符号链入程序当中。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2020-06-22T13:01:30Z",
  "Author": "Liam Huang"
}