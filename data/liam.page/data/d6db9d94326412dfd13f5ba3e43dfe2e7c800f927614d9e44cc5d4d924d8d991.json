{
  "Source": "liam.page",
  "Title": "程序员的自我修养（三）：fork() 安全",
  "Link": "https://liam.page/2017/01/17/fork-safe/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e这个系列的文章，已有两篇（\u003ca href=\"/2016/08/30/review-of-hardware-development/\"\u003e一\u003c/a\u003e、\u003ca href=\"/2017/01/17/layers-and-operation-system/\"\u003e二\u003c/a\u003e）。本文将接着第二篇的叙述，探讨一个与多进程、多线程相关的问题：\u003ccode\u003efork()\u003c/code\u003e-安全。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"抛出异常\"\u003e\u003ca href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"\u003e\u003c/a\u003e抛出异常\u003c/h2\u003e\u003cp\u003e首先我们来看这样的代码\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003emutex_deadlock.cpp\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// compile: g++ ‐‐std=c++11 ‐lpthread mutex_deadlock.cpp\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// execute: ./a.out\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;pthread.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eusing\u003c/span\u003e \u003cspan class=\"keyword\"\u003enamespace\u003c/span\u003e std;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003epthread_mutex_t\u003c/span\u003e mutex = PTHREAD_MUTEX_INITIALIZER;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e* \u003cspan class=\"title\"\u003edoit\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e*)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_lock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title class_\"\u003etimespec\u003c/span\u003e ts = {\u003cspan class=\"number\"\u003e20\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003enanosleep\u003c/span\u003e(\u0026amp;ts, \u003cspan class=\"number\"\u003e0\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_unlock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003epthread_t\u003c/span\u003e t;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_create\u003c/span\u003e(\u0026amp;t, \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e, doit, \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (fork() == \u003cspan class=\"number\"\u003e0\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003edoit\u003c/span\u003e(\u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_join\u003c/span\u003e(t, \u003cspan class=\"number\"\u003e0\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在代码里，我们首先用 \u003ccode\u003epthread_create()\u003c/code\u003e 创建了一个子线程。在子线程里，\u003ccode\u003edoit()\u003c/code\u003e 工作函数会持有一把互斥锁，然后睡 20 秒后再释放这把锁。而后，与子线程同时进行的，在主线程中，我们调用 \u003ccode\u003efork()\u003c/code\u003e 函数，创建一个子进程。并且，在子进程里，我们也调用 \u003ccode\u003edoit()\u003c/code\u003e 函数，尝试获取互斥锁。\u003c/p\u003e\n\u003ch2 id=\"捕获异常\"\u003e\u003ca href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"\u003e\u003c/a\u003e捕获异常\u003c/h2\u003e\u003cp\u003e现在我们观察一下，这个程序的运行状态。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ ps ‐ef | grep \u003cspan class=\"string\"\u003e\u0026#34;a.out\u0026#34;\u003c/span\u003e | grep ‐v grep\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   16629    10449   340  0 11:25 pts/90   00:00:00 ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e   16629    10451 10449  0 11:25 pts/90   00:00:00 ./a.out\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e可以看到，等到我们有机会查看程序的运行状态时，子进程已经被创建出来了。显而易见，\u003ccode\u003e10449\u003c/code\u003e 是主进程，而 \u003ccode\u003e10451\u003c/code\u003e 是子进程。我们用 \u003ccode\u003estrace\u003c/code\u003e 跟踪主进程试试看。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ strace -p 10449 -f\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eProcess 10449 attached with 2 threads - interrupt to quit\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[pid 10450] restart_syscall(\u0026lt;... resuming interrupted call ...\u0026gt; \u0026lt;unfinished ...\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[pid 10449] futex(0x41c279d0, FUTEX_WAIT, 10450, NULL \u0026lt;unfinished ...\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[pid 10450] \u0026lt;... restart_syscall resumed\u0026gt; ) = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[pid 10450] _exit(0)                    = ?\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eProcess 10450 detached\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026lt;... futex resumed\u0026gt; )                   = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eexit_group(0)                           = ?\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eProcess 10449 detached\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不难发现，\u003ccode\u003estrace\u003c/code\u003e 提示主进程里有 2 个线程，其中主线程正在等待子线程释放互斥锁。待子线程释放互斥锁并退出后，主线程就获取到锁，而后退出了。这表明，主进程运行正常。\u003c/p\u003e\n\u003cp\u003e现在看看子进程的状态。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ps -ef | grep \u003cspan class=\"string\"\u003e\u0026#34;a.out\u0026#34;\u003c/span\u003e | grep -v grep\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16629    10451     1  0 11:25 pts/90   00:00:00 ./a.out\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$ strace -p 10451 -f\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eProcess 10451 attached - interrupt to quit\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efutex(0x600e20, FUTEX_WAIT_PRIVATE, 2, NULL\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里有几处值得注意的地方\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e执行 \u003ccode\u003eps -ef\u003c/code\u003e 的时候，主进程已经退出了，但是子进程依然存活。这时候，子进程变为孤儿，过继给 1 号进程 \u003ccode\u003einit\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e执行 \u003ccode\u003estrace\u003c/code\u003e 发现，子进程只有一个线程（而不是 2 个线程）。\u003c/li\u003e\n\u003cli\u003e并且，子进程的线程，在不断尝试获取互斥锁而不得，陷入了死锁状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"异常分析\"\u003e\u003ca href=\"#异常分析\" class=\"headerlink\" title=\"异常分析\"\u003e\u003c/a\u003e异常分析\u003c/h2\u003e\u003cp\u003e子进程陷入死锁，因而等主进程退出后就变成孤儿进程。这件事情符合逻辑，不需要做额外的探讨。但是不符合逻辑的地方有两处：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主进程显而易见有两个线程，为什么经由其 \u003ccode\u003efork()\u003c/code\u003e 得到的子进程却只有 1 个线程？\u003c/li\u003e\n\u003cli\u003e既然子进程只有 1 个线程，为什么会陷入死锁？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为了解答这两个疑惑，我们需要更加深入地了解一下 \u003ccode\u003efork()\u003c/code\u003e 函数的行为。阅读 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://man7.org/linux/man-pages/man2/fork.2.html\"\u003e\u003ccode\u003efork()\u003c/code\u003e 函数的说明\u003c/a\u003e，我们可以发现有这样一段话：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe child process is created with a single thread --- the one that called \u003ccode\u003efork()\u003c/code\u003e. The entire virtual address space of the parent is replicated in the child, including the states of mutexes, condition variables, and other pthreads objects; the use of \u003ccode\u003epthread_atfork()\u003c/code\u003e may be helpful for dealing with problems that this can cause.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e翻译过来就是：经由 \u003ccode\u003efork()\u003c/code\u003e 创建的子进程，其中只有一个线程。\u003cstrong\u003e子进程里仅存的线程，对应着主进程里调用 \u003ccode\u003efork()\u003c/code\u003e 函数的线程\u003c/strong\u003e。此外，主进程的整个虚存空间都被复制到了子进程。因而，\u003cstrong\u003e包括互斥锁、条件变量、其余线程的内部对象等，都保持着原样\u003c/strong\u003e。由此引发的问题，可以考虑用 \u003ccode\u003epthread_atfork()\u003c/code\u003e 函数解决。\u003c/p\u003e\n\u003cp\u003e打住！我们似乎发现了什么……\u003c/p\u003e\n\u003cp\u003e回过头来看代码。在 \u003ccode\u003efork()\u003c/code\u003e 执行时，子线程还持有着 \u003ccode\u003emutex\u003c/code\u003e 互斥锁。而当 \u003ccode\u003efork()\u003c/code\u003e 执行之后，子进程里的子线程就蒸发掉了，但是 \u003ccode\u003emutex\u003c/code\u003e 互斥锁依然保持着被持有的状态。而子进程里仅存的线程，马上就进入 \u003ccode\u003edoit()\u003c/code\u003e 函数，尝试获取锁——它在尝试获取一个永远不会被释放的锁，形成死锁。\u003c/p\u003e\n\u003cp\u003e这是一个刻意构造的例子，说明当子线程持有锁的时候，由主线程进行 \u003ccode\u003efork()\u003c/code\u003e 操作是不安全的。在生产实际中，这种现象不总是发生，但是在概率的意义上是必然发生的。因此，我们有必要考虑怎样解决这个问题。好在，\u003ccode\u003efork()\u003c/code\u003e 的文档中给出了提示：使用 \u003ccode\u003epthread_atfork()\u003c/code\u003e 函数。\u003c/p\u003e\n\u003ch2 id=\"pthread-atfork-函数\"\u003e\u003ca href=\"#pthread-atfork-函数\" class=\"headerlink\" title=\"pthread_atfork() 函数\"\u003e\u003c/a\u003e\u003ccode\u003epthread_atfork()\u003c/code\u003e 函数\u003c/h2\u003e\u003cp\u003e\u003ccode\u003epthread_atfork()\u003c/code\u003e 和 \u003ccode\u003ephread_create()\u003c/code\u003e 函数一样，由 \u003ccode\u003epthread\u003c/code\u003e 库提供。它的原型是\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title function_\"\u003epthread_atfork\u003c/span\u003e \u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e (*prepare) (\u003cspan class=\"type\"\u003evoid\u003c/span\u003e), \u003cspan class=\"type\"\u003evoid\u003c/span\u003e (*parent) (\u003cspan class=\"type\"\u003evoid\u003c/span\u003e), \u003cspan class=\"type\"\u003evoid\u003c/span\u003e (*child) (\u003cspan class=\"type\"\u003evoid\u003c/span\u003e))\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e它接收三个参数，分别是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eprepare\u003c/code\u003e: 将在 \u003ccode\u003efork()\u003c/code\u003e 之前执行；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eparent\u003c/code\u003e: 将在父进程 \u003ccode\u003efork()\u003c/code\u003e 即将 \u003ccode\u003ereturn\u003c/code\u003e 的地方执行；\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003echild\u003c/code\u003e: 将在子进程 \u003ccode\u003efork()\u003c/code\u003e 即将 \u003ccode\u003ereturn\u003c/code\u003e 的地方执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个函数实际上是一个注册机，它可以被执行多次，而后将诸多 \u003ccode\u003eprepare\u003c/code\u003e 函数压入堆栈中，在 \u003ccode\u003efork()\u003c/code\u003e 之前依次弹栈执行（执行顺序与注册的顺序相反）；将诸多 \u003ccode\u003eparent\u003c/code\u003e 和 \u003ccode\u003echild\u003c/code\u003e 函数分别填入队列中，在 \u003ccode\u003efork()\u003c/code\u003e 函数即将 \u003ccode\u003ereturn\u003c/code\u003e 的地方依次执行（执行顺序与注册顺序相同）。按照设计的意图，程序员可以在 \u003ccode\u003efork()\u003c/code\u003e 之前，做好清理工作，以便 \u003ccode\u003efork()\u003c/code\u003e 能够安全地调用；并且在 \u003ccode\u003efork()\u003c/code\u003e 返回之前，对函数做初始化，以便后续代码能够顺利执行。\u003c/p\u003e\n\u003cp\u003e据此，对上面的代码，我们可以有这样的修改\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003cfigcaption\u003e\u003cspan\u003emutex_deadlock_fix.cpp\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e34\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e35\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e36\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e37\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e38\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e39\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e40\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e41\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e42\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e43\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// compile: g++ ‐‐std=c++11 ‐lpthread mutex_deadlock_fix.cpp\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// execute: ./a.out\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;pthread.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;time.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e#\u003cspan class=\"keyword\"\u003einclude\u003c/span\u003e \u003cspan class=\"string\"\u003e\u0026lt;unistd.h\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eusing\u003c/span\u003e \u003cspan class=\"keyword\"\u003enamespace\u003c/span\u003e std;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003epthread_mutex_t\u003c/span\u003e mutex = PTHREAD_MUTEX_INITIALIZER;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e* \u003cspan class=\"title\"\u003edoit\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e*)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_lock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title class_\"\u003etimespec\u003c/span\u003e ts = {\u003cspan class=\"number\"\u003e20\u003c/span\u003e, \u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003enanosleep\u003c/span\u003e(\u0026amp;ts, \u003cspan class=\"number\"\u003e0\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_unlock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eprepare\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_lock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eparent\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_unlock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003echild\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_mutex_unlock\u003c/span\u003e(\u0026amp;mutex);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003emain\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e)\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_atfork\u003c/span\u003e(prepare, parent, child);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003epthread_t\u003c/span\u003e t;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_create\u003c/span\u003e(\u0026amp;t, \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e, doit, \u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (fork() == \u003cspan class=\"number\"\u003e0\u003c/span\u003e) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"built_in\"\u003edoit\u003c/span\u003e(\u003cspan class=\"literal\"\u003enullptr\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"built_in\"\u003epthread_join\u003c/span\u003e(t, \u003cspan class=\"number\"\u003e0\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不难验证，死锁的问题已经解决。\u003c/p\u003e\n\u003ch2 id=\"没有银弹\"\u003e\u003ca href=\"#没有银弹\" class=\"headerlink\" title=\"没有银弹\"\u003e\u003c/a\u003e没有银弹\u003c/h2\u003e\u003cp\u003e不幸的是，\u003ccode\u003epthread_atfork()\u003c/code\u003e 函数并不是解决此类问题的银弹。事实上，\u003ccode\u003epthread_atfork()\u003c/code\u003e 本身就可能造成死锁的问题。\u003c/p\u003e\n\u003cp\u003e实际上，因为库作者不可能知道其它第三方库对锁的使用，因此每个库必须自己调用 \u003ccode\u003epthread_atfork()\u003c/code\u003e 来处理自己的环境。然而，在实际环境中，各个 \u003ccode\u003epthread_atfork()\u003c/code\u003e 函数调用的时机是不确定的；也因此，各个 \u003ccode\u003eprepare\u003c/code\u003e 函数的调用顺序是不确定的。这有可能会造成问题，例如可能有下面的情况发生\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThread 1 调用 \u003ccode\u003efork()\u003c/code\u003e 函数。\u003c/li\u003e\n\u003cli\u003eThread 1 执行 \u003ccode\u003elibc\u003c/code\u003e 中注册的 \u003ccode\u003eprepare\u003c/code\u003e 函数，获取 \u003ccode\u003elibc\u003c/code\u003e 中的 \u003ccode\u003emutex\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003eThread 2 中，第三方库 A 获取了它自己的互斥锁 \u003ccode\u003eAM\u003c/code\u003e；接下来 Thread 2 尝试获取 \u003ccode\u003elibc\u003c/code\u003e 的 \u003ccode\u003emutex\u003c/code\u003e 以便继续清理环境；而此时 \u003ccode\u003emutex\u003c/code\u003e 已经在 Thread 1 中被持有，因此 Thread 2 进入等待状态。\u003c/li\u003e\n\u003cli\u003eThread 1 现在尝试清理第三方库 A 的环境，于是它要去获取 \u003ccode\u003eAM\u003c/code\u003e；然而 \u003ccode\u003eAM\u003c/code\u003e 在 Thread 2 手里，于是 Thread 1 进入等待状态。\u003c/li\u003e\n\u003cli\u003e产生死锁。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这件事情的不可解之处在于，死锁的产生和程序员自身的编码没有任何关系：使用任何第三方库，在多线程的环境下执行 \u003ccode\u003efork()\u003c/code\u003e，都可能死锁。由此，我们得出结论：\u003cstrong\u003e在多线程环境下，执行 \u003ccode\u003efork()\u003c/code\u003e 函数是不安全的\u003c/strong\u003e。也因此，必须\u003cstrong\u003e慎重使用多进程和多线程混搭的模型\u003c/strong\u003e。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-01-17T12:55:05Z",
  "Author": "Liam Huang"
}