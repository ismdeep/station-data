{
  "Source": "liam.page",
  "Title": "C++ 中的 mutable 关键字",
  "Link": "https://liam.page/2017/05/25/the-mutable-keyword-in-Cxx/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e此篇介绍 C++ 中的 \u003ccode\u003emutable\u003c/code\u003e 关键字。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"类中的-mutable\"\u003e\u003ca href=\"#类中的-mutable\" class=\"headerlink\" title=\"类中的 mutable\"\u003e\u003c/a\u003e类中的 \u003ccode\u003emutable\u003c/code\u003e\u003c/h2\u003e\u003cp\u003e\u003ccode\u003emutable\u003c/code\u003e 从字面意思上来说，是「可变的」之意。\u003c/p\u003e\n\u003cp\u003e若是要「顾名思义」，那么这个关键词的含义就有些意思了。显然，「可变的」只能用来形容变量，而不可能是「函数」或者「类」本身。然而，既然是「变量」，那么它本来就是可变的，也没有必要使用 \u003ccode\u003emutable\u003c/code\u003e 来修饰。那么，\u003ccode\u003emutable\u003c/code\u003e 就只能用来形容某种不变的东西了。\u003c/p\u003e\n\u003cp\u003eC++ 中，不可变的变量，称之为常量，使用 \u003ccode\u003econst\u003c/code\u003e 来修饰。然而，若是 \u003ccode\u003econst mutable\u003c/code\u003e 联用，未免让人摸不着头脑——到底是可变还是不可变呢？\u003c/p\u003e\n\u003cp\u003e事实上，\u003ccode\u003emutable\u003c/code\u003e 是用来修饰一个 \u003ccode\u003econst\u003c/code\u003e 示例的部分可变的数据成员的。如果要说得更清晰一点，就是说 \u003ccode\u003emutable\u003c/code\u003e 的出现，将 C++ 中的 \u003ccode\u003econst\u003c/code\u003e 的概念分成了两种。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e二进制层面的 \u003ccode\u003econst\u003c/code\u003e，也就是「绝对的」常量，在任何情况下都不可修改（除非用 \u003ccode\u003econst_cast\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e引入 \u003ccode\u003emutable\u003c/code\u003e 之后，C++ 可以有逻辑层面的 \u003ccode\u003econst\u003c/code\u003e，也就是对一个常量实例来说，从外部观察，它是常量而不可修改；但是内部可以有非常量的状态。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当然，所谓的「逻辑 \u003ccode\u003econst\u003c/code\u003e」，在 C++ 标准中并没有这一称呼。这只是为了方便理解，而创造出来的名词。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e显而易见，\u003ccode\u003emutable\u003c/code\u003e 只能用来修饰类的数据成员；而被 \u003ccode\u003emutable\u003c/code\u003e 修饰的数据成员，可以在 \u003ccode\u003econst\u003c/code\u003e 成员函数中修改。\u003c/p\u003e\n\u003cp\u003e这里举一个例子，展现这类情形。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eHashTable\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e//...\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"function\"\u003estd::string \u003cspan class=\"title\"\u003elookup\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003econst\u003c/span\u003e std::string\u0026amp; key)\u003c/span\u003e \u003cspan class=\"type\"\u003econst\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e    \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e (key == last_key_) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e last_value_;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        std::string value{\u003cspan class=\"keyword\"\u003ethis\u003c/span\u003e-\u0026gt;\u003cspan class=\"built_in\"\u003elookupInternal\u003c/span\u003e(key)};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        last_key_   = key;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        last_value_ = value;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e value;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003emutable\u003c/span\u003e std::string last_key_\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003emutable\u003c/span\u003e std::string last_value_;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，我们呈现了一个哈希表的部分实现。显然，对哈希表的查询操作，在逻辑上不应该修改哈希表本身。因此，\u003ccode\u003eHashTable::lookup\u003c/code\u003e 是一个 \u003ccode\u003econst\u003c/code\u003e 成员函数。在 \u003ccode\u003eHashTable::lookup\u003c/code\u003e 中，我们使用了 \u003ccode\u003elast_key_\u003c/code\u003e 和 \u003ccode\u003elast_value_\u003c/code\u003e 实现了一个简单的「缓存」逻辑。当传入的 \u003ccode\u003ekey\u003c/code\u003e 与前次查询的 \u003ccode\u003elast_key_\u003c/code\u003e 一致时，直接返回 \u003ccode\u003elast_value_\u003c/code\u003e；否则，则返回实际查询得到的 \u003ccode\u003evalue\u003c/code\u003e 并更新 \u003ccode\u003elast_key_\u003c/code\u003e 和 \u003ccode\u003elast_value_\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e在这里，\u003ccode\u003elast_key_\u003c/code\u003e 和 \u003ccode\u003elast_value_\u003c/code\u003e 是 \u003ccode\u003eHashTable\u003c/code\u003e 的数据成员。按照一般的理解，\u003ccode\u003econst\u003c/code\u003e 成员函数是不允许修改数据成员的。但是，另一方面，\u003ccode\u003elast_key_\u003c/code\u003e 和 \u003ccode\u003elast_value_\u003c/code\u003e 从逻辑上说，修改它们的值，外部是无有感知的；因此也就不会破坏逻辑上的 \u003ccode\u003econst\u003c/code\u003e。为了解决这一矛盾，我们用 \u003ccode\u003emutable\u003c/code\u003e 来修饰 \u003ccode\u003elast_key_\u003c/code\u003e 和 \u003ccode\u003elast_value_\u003c/code\u003e，以便在 \u003ccode\u003elookup\u003c/code\u003e 函数中更新缓存的键值。\u003c/p\u003e\n\u003ch2 id=\"Lambda-表达式中的-mutable\"\u003e\u003ca href=\"#Lambda-表达式中的-mutable\" class=\"headerlink\" title=\"Lambda 表达式中的 mutable\"\u003e\u003c/a\u003eLambda 表达式中的 \u003ccode\u003emutable\u003c/code\u003e\u003c/h2\u003e\u003cp\u003eC++11 引入了 Lambda 表达式，程序员可以凭此创建匿名函数。在 Lambda 表达式的设计中，捕获变量有几种方式；其中按值捕获（Caputre by Value）的方式不允许程序员在 Lambda 函数的函数体中修改捕获的变量。而以 \u003ccode\u003emutable\u003c/code\u003e 修饰 Lambda 函数，则可以打破这种限制。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e x{\u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e f1 = [=]() \u003cspan class=\"keyword\"\u003emutable\u003c/span\u003e {x = \u003cspan class=\"number\"\u003e42\u003c/span\u003e;};  \u003cspan class=\"comment\"\u003e// okay, 创建了一个函数类型的实例\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e f2 = [=]()         {x = \u003cspan class=\"number\"\u003e42\u003c/span\u003e;};  \u003cspan class=\"comment\"\u003e// error, 不允许修改按值捕获的外部变量的值\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e需要注意的是，上述 \u003ccode\u003ef1\u003c/code\u003e 的函数体中，虽然我们给 \u003ccode\u003ex\u003c/code\u003e 做了赋值操作，但是这一操作仅只在函数内部生效——即，实际是给拷贝至函数内部的 \u003ccode\u003ex\u003c/code\u003e 进行赋值——而外部的 \u003ccode\u003ex\u003c/code\u003e 的值依旧是 \u003ccode\u003e0\u003c/code\u003e。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-05-25T10:16:50Z",
  "Author": "Liam Huang"
}