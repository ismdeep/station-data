{
  "Source": "liam.page",
  "Title": "初识 Docker",
  "Link": "https://liam.page/2016/05/29/say-hi-to-docker/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cblockquote\u003e\n\u003cp\u003e本文部分译自 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://bencane.com/2015/12/01/getting-started-with-docker-by-dockerizing-this-blog/?utm_source=feedburner\u0026amp;utm_medium=feed\u0026amp;utm_campaign=Feed:+bencane/SAUo+(Benjamin+Cane)\"\u003eBenjamin Cane 的博文\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eDocker 是目前风靡全球的虚拟化技术。然而在两年前，Docker 还仅仅是设计者脑海中的概念而已。\u003c/p\u003e\n\u003cp\u003e本篇将介绍 Docker 的一些基本情况，以及基本操作。顺带着，我们将能见识到 Docker 一些有趣的特性。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"容器技术与虚拟机\"\u003e\u003ca href=\"#容器技术与虚拟机\" class=\"headerlink\" title=\"容器技术与虚拟机\"\u003e\u003c/a\u003e容器技术与虚拟机\u003c/h2\u003e\u003cp\u003e同样作为操作系统虚拟化的方法，容器并不如虚拟机那样出名。它们有相似之处，但也有一些差别。\u003c/p\u003e\n\u003cp\u003e由于 Hypervisor 向虚拟机提供了虚拟化的硬件，虚拟机可以包含一整个操作系统、系统软件包，以及一些应用程序。因此，在一个宿主机上，可以运行许多独立的客户机。运行在同一宿主机上的虚拟机，提供完整的操作系统环境，共享宿主机上的同一套物理资源。\u003c/p\u003e\n\u003cp\u003e与之对应，容器技术使得单一的宿主机能够运行多种操作系统环境。在这一点上，容器技术和虚拟机很相似。只不过，容器技术提供的虚拟环境，并不是完整的操作系统。一般来说，容器技术只包含了必要的系统软件包以及应用程序，而不包含整个操作系统或是虚拟化的硬件。因此，容器技术比传统的虚拟机技术占用资源少。容器技术将同一宿主机上的进程相互隔离，互不影响。事实上，与其拿来与虚拟机相较，不如说容器技术与 BSD Jails 以及 \u003ccode\u003echroot\u003c/code\u003e 更相似。\u003c/p\u003e\n\u003ch2 id=\"Docker-究竟做了什么？\"\u003e\u003ca href=\"#Docker-究竟做了什么？\" class=\"headerlink\" title=\"Docker 究竟做了什么？\"\u003e\u003c/a\u003eDocker 究竟做了什么？\u003c/h2\u003e\u003cp\u003eDocker 其实是个很难定位的技术，我们很难说清 Docker 究竟算不算是容器技术，但它的一些特性又让人无法否认这一点。这似乎有点不可知论的意思了。\u003c/p\u003e\n\u003cp\u003eDocker 支持 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://blog.docker.com/2015/08/docker-oracle-solaris-zones/\"\u003eSolaris Zones\u003c/a\u003e 和 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://wiki.freebsd.org/Docker\"\u003eBSD Jails\u003c/a\u003e 这两种容器技术，提供了管理、打包以及部署容器的手段。虚拟机多多少少有类似的功能；但在过往的容器技术里，则几乎看不到——即使有，也很不好用。\u003c/p\u003e\n\u003cp\u003e容器技术本身不是 Docker 的重点。相反，管理、打包和部署容器的能力，才是 Docker 的杀手锏。\u003c/p\u003e\n\u003ch2 id=\"安装-Docker\"\u003e\u003ca href=\"#安装-Docker\" class=\"headerlink\" title=\"安装 Docker\"\u003e\u003c/a\u003e安装 Docker\u003c/h2\u003e\u003cp\u003eDocker 通常没有默认安装在系统中，所以我们首先要装好它。\u003c/p\u003e\n\u003cp\u003e在 Ubuntu 里，我们可以用 \u003ccode\u003eapt-get install docker.io\u003c/code\u003e 来简单地安装它。在 \u003ccode\u003eyum\u003c/code\u003e 系的 Linux 中，也是类似。在 OS X 里，则可以用 Homebrew 来安装。这里我们以 Ubuntu 为例：\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# apt-get install docker.io\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eReading package lists... Done\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eBuilding dependency tree\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eReading state information... Done\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe following extra packages will be installed:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  aufs-tools cgroup-lite git git-man liberror-perl\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eSuggested packages:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  btrfs-tools debootstrap lxc rinse git-daemon-run git-daemon-sysvinit git-doc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  git-el git-email git-gui gitk gitweb git-arch git-bzr git-cvs git-mediawiki\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  git-svn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThe following NEW packages will be installed:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  aufs-tools cgroup-lite docker.io git git-man liberror-perl\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e0 upgraded, 6 newly installed, 0 to remove and 0 not upgraded.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eNeed to get 7,553 kB of archives.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eAfter this operation, 46.6 MB of additional disk space will be used.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDo you want to \u003cspan class=\"built_in\"\u003econtinue\u003c/span\u003e? [Y/n] y\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在终端里执行 \u003ccode\u003edocker ps\u003c/code\u003e 可以查看当前运行着的容器。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker ps\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e顾名思义。\u003ccode\u003edocker ps\u003c/code\u003e 和 *nix 系统中的 \u003ccode\u003eps\u003c/code\u003e 命令具有类似的功能。\u003ccode\u003edocker ps\u003c/code\u003e 会打印所有可用的 Docker 容器以及它们当前的状态。因为我们什么也没做，所以命令显示当前没有运行着的容器。\u003c/p\u003e\n\u003ch2 id=\"部署打包好的-nginx-Docker-容器\"\u003e\u003ca href=\"#部署打包好的-nginx-Docker-容器\" class=\"headerlink\" title=\"部署打包好的 nginx Docker 容器\"\u003e\u003c/a\u003e部署打包好的 nginx Docker 容器\u003c/h2\u003e\u003cp\u003eDocker 可以像 \u003ccode\u003eyum\u003c/code\u003e 以及 \u003ccode\u003eapt-get\u003c/code\u003e 那样部署软件包，这一特性十分讨喜。这次，我们用 \u003ccode\u003edocker run\u003c/code\u003e 命令，实际部署 nginx 服务器看看。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker run -d nginx\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eUnable to find image \u003cspan class=\"string\"\u003e\u0026#39;nginx\u0026#39;\u003c/span\u003e locally\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ePulling repository nginx\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5c82215b03d1: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ee2a4fb18da48: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e58016a5acc80: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e657abfa43d82: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edcb2fe003d16: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ec79a417d7c6f: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabb90243122c: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ed6137c9e2964: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e85e566ddc7ef: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e69f100eb42b5: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecd720b803060: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7cc81e9a118a: Download complete\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e接受 \u003ccode\u003edocker run\u003c/code\u003e 命令后，Docker 会寻找置顶的 Docker 镜像并运行。默认情况下，Docker 容器会在前台执行。也就是说，你的 shell 会与 Docker 控制台及容器中正在运行的进程绑定。加上 \u003ccode\u003e-d\u003c/code\u003e (detach) 选项，Docker 容器就会在后台执行了。\u003c/p\u003e\n\u003c!--\n`docker`命令的`run`选项，用来通知Docker去寻找一个指定的Docker镜像，然后开启运行着该镜像的容器。默认情况下，Docker容器在前台运行，这意味着当你运行`docker run`命令的时候，你的shell会被绑定到容器的控制台以及运行在容器中的进程。为了能在后台运行该Docker容器，我们可以使用`-d` (detach)标志。\n--\u003e\n\n\u003cp\u003e再次执行 \u003ccode\u003edocker ps\u003c/code\u003e命令，我们就能看到 nginx 容器正在了。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker ps\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS               NAMES\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ef6d31ab01fc9        nginx:latest        nginx -g \u003cspan class=\"string\"\u003e\u0026#39;daemon off   4 seconds ago       Up 3 seconds        443/tcp, 80/tcp     desperate_lalande\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不难看出，容器 \u003ccode\u003edesperate_lalande\u003c/code\u003e 正在运行，它由 \u003ccode\u003enginx:latest\u003c/code\u003e 镜像构建而来。\u003c/p\u003e\n\u003c!--\n从上面的打印信息中，我们可以看到正在运行的名为`desperate_lalande`的容器，它是由`nginx:latest image`（译者注：nginx最新版本的镜像）构建而来得。\n--\u003e\n\n\u003ch3 id=\"Docker-镜像\"\u003e\u003ca href=\"#Docker-镜像\" class=\"headerlink\" title=\"Docker 镜像\"\u003e\u003c/a\u003eDocker 镜像\u003c/h3\u003e\u003cp\u003e镜像是 Docker 的核心特征之一。与虚拟机镜像类似，Docker 的镜像是一个打包存档的容器。与此同时，Docker 并未就此止步——Docker 还能通过 Docker 仓库发布这些镜像。Docker 仓库扮演的角色，类似于软件包仓库，因此，Docker 可以像 \u003ccode\u003eyum\u003c/code\u003e 那样工作。让我们回顾一下 \u003ccode\u003edocker run\u003c/code\u003e 的输出。\u003c/p\u003e\n\u003c!--\n镜像是Docker的核心特征之一，类似于虚拟机镜像。和虚拟机镜像一样，Docker镜像是一个被保存并打包的容器。当然，Docker不只是创建镜像，它还可以通过Docker仓库发布这些镜像，Docker仓库和包仓库的概念差不多，它让Docker能够模仿`yum`部署包的方式来部署镜像。为了更好地理解这是怎么工作的，我们来回顾`docker run`执行后的输出。\n--\u003e\n\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker run -d nginx\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eUnable to find image \u003cspan class=\"string\"\u003e\u0026#39;nginx\u0026#39;\u003c/span\u003e locally\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先，Docker 表示在本地没有找到 nginx 镜像。这是因为，执行 \u003ccode\u003edocker run\u003c/code\u003e 时，我们希望 Docker 启动名为 nginx 的容器；而启动容器，需要找到对应的镜像。Docker 首先会在本地寻找相应名称的镜像；若是找不到，则会联网在远程 Docker 仓库寻找。\u003c/p\u003e\n\u003c!--\n我们可以看到第一条信息是，Docker不能在本地找到名叫nginx的镜像。这是因为当我们执行`docker run`命令时，告诉Docker运行一个基于nginx镜像的容器。既然Docker要启动一个基于特定镜像的容器，那么Docker首先需要知道那个指定镜像。在检查远程仓库之前，Docker首先检查本地是否存在指定名称的本地镜像。\n--\u003e\n\n\u003cp\u003e由于 Docker 是刚安装的，自然不存在名为 nginx 的镜像。于是，Docker 将会连接远程仓库下载它。\u003c/p\u003e\n\u003c!--\n因为系统是崭新的，不存在nginx镜像，Docker将选择从Docker仓库下载之。\n--\u003e\n\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ePulling repository nginx\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5c82215b03d1: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ee2a4fb18da48: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e58016a5acc80: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e657abfa43d82: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edcb2fe003d16: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ec79a417d7c6f: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eabb90243122c: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ed6137c9e2964: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e85e566ddc7ef: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e69f100eb42b5: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecd720b803060: Download complete\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7cc81e9a118a: Download complete\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e接下来，Docker 打印了这些信息。默认情况下，Docker 会连接 Docker 公司维护的 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://hub.docker.com/\"\u003eDocker Hub\u003c/a\u003e仓库。\u003c/p\u003e\n\u003c!--\n这就是第二部分打印信息显示给我们的内容。默认，Docker会使用[Docker Hub](https://hub.docker.com/)仓库，该仓库由Docker公司维护。\n--\u003e\n\n\u003cp\u003e与 GitHub 相同，在 Docker Hub 上创建公开仓库是免费的，创建私有仓库则是收费的。你也可以部署你自己的 Docker 仓库——只需要运行 \u003ccode\u003edocker run registry\u003c/code\u003e 就好了。不过，本文不会讨论这一块内容。\u003c/p\u003e\n\u003c!--\n和Github一样，在Docker Hub创建公共仓库是免费的，私人仓库就需要缴纳费用了。当然，部署你自己的Docker仓库也是可以实现的，事实上只需要简单地运行`docker run registry`命令就行了。但在这篇文章中，我们的重点将不是讲解如何部署一个定制的注册服务。\n--\u003e\n\n\u003ch3 id=\"停止并移除容器\"\u003e\u003ca href=\"#停止并移除容器\" class=\"headerlink\" title=\"停止并移除容器\"\u003e\u003c/a\u003e停止并移除容器\u003c/h3\u003e\u003cp\u003e在我们创建自己的 Docker 容器之前，让我们先清理一下 Docker 环境。首先，我们要停止运行着的容器，然后移除它。\u003c/p\u003e\n\u003c!--\n在我们继续构建定制容器之前，我们先清理Docker环境，我们将关闭先前的容器，并移除它。\n--\u003e\n\n\u003cp\u003e与 \u003ccode\u003edocker run\u003c/code\u003e 对应，\u003ccode\u003edocker kill \u0026lt;container-name\u0026gt;\u003c/code\u003e 会停止正在运行的容器。\u003c/p\u003e\n\u003c!--\n我们利用`docker`命令和`run`选项运行一个容器，所以，为了停止该相同的容器，我们简单地在执行`docker`命令时，使用`kill`选项，并指定容器名。\n--\u003e\n\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker kill desperate_lalande\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edesperate_lalande\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e再次执行 \u003ccode\u003edocker ps\u003c/code\u003e 可以发现，容器已经不再运行了。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker ps\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003edocker kill\u003c/code\u003e 关闭了容器；虽然它不再运行，但仍然存在于 Docker 系统中。\u003ccode\u003edocker ps\u003c/code\u003e 默认只显示正在运行的容器，\u003ccode\u003edocker ps -a\u003c/code\u003e 则会显示所有容器（包括未运行的）。\u003c/p\u003e\n\u003c!--\n但是，此时，我们这是停止了容器；虽然它不再运行，但仍然存在。默认情况下，`docker ps`只会显示正在运行的容器，如果我们附加`-a` (all) 标识，它会显示所有运行和未运行的容器。\n--\u003e\n\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker ps -a\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eCONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                           PORTS               NAMES\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ef6d31ab01fc9        5c82215b03d1        nginx -g \u003cspan class=\"string\"\u003e\u0026#39;daemon off   4 weeks ago         Exited (-1) About a minute ago                       desperate_lalande\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们可以用 \u003ccode\u003edocker rm\u003c/code\u003e 来完全地移除容器。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker rm desperate_lalande\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edesperate_lalande\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不过，虽然容器被移走了，但是 Docker 系统中仍有缓存的 nginx 镜像。因此，若然此时执行 \u003ccode\u003edocker run -d nginx\u003c/code\u003e，Docker 会直接调用本地的镜像启动容器，而无需联网下载。\u003c/p\u003e\n\u003c!--\n虽然容器被移除了；但是我们仍拥有可用的nginx镜像（译者注：镜像缓存）。如果我们重新运行`docker run -d nginx`，Docker就无需再次拉取nginx镜像，即可启动容器。这是因为我们本地系统中已经保存了一个副本。\n--\u003e\n\n\u003cp\u003e\u003ccode\u003edocker image\u003c/code\u003e 会列出所有本地可用的镜像。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# docker images\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eREPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003enginx               latest              9fab4090484a        5 days ago          132.8 MB\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n    \u003c/div\u003e",
  "Date": "2016-05-29T15:53:54Z",
  "Author": "Liam Huang"
}