{
  "Source": "liam.page",
  "Title": "为 Hexo 博客创建本地搜索引擎",
  "Link": "https://liam.page/2017/09/21/local-search-engine-in-Hexo-site/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e自 2014 年，始终博客就开始使用 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://hexo.io/zh-cn/index.html\"\u003eHexo\u003c/a\u003e 这个静态站点生成工具了；犹记得当时参考的文章，是 Bruce 的 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://ibruce.info/2013/11/22/hexo-your-blog/\"\u003eHexo 你的博客\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e始终博客采用的主题，是 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/iissnan/\"\u003eiissan\u003c/a\u003e 创建的 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/iissnan/hexo-theme-next\"\u003eNexT\u003c/a\u003e。NexT 主题默认提供了两个站内搜索解决方案：swiftype 和 tinysou。早年时候，始终博客采用了 swiftype 作为站内搜索方案；但后来因为 swiftype 改版而失效，就放弃了。\u003c/p\u003e\n\u003cp\u003e近期，随着始终博客的文章数量不断增加，陆续有友人建议应该为博客加上搜索功能。然而，出于几方面的考虑，我一直没有加上搜索功能：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不愿意受限于第三方服务，第三方服务可能说变就变——曾经的各种博客网站，以及 swiftype 就是如此；\u003c/li\u003e\n\u003cli\u003e不喜欢第三方服务的样式，与博客样式脱节；\u003c/li\u003e\n\u003cli\u003e使用第三方服务，需要应用第三方的 JavaScript 脚本等内容，可能存在安全风险。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e经过检索之后，我发现 Hexo 已有可以接受的解决方案了。本文来介绍如何在 Hexo 博客中建立自己的本地搜索引擎。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"思路分析\"\u003e\u003ca href=\"#思路分析\" class=\"headerlink\" title=\"思路分析\"\u003e\u003c/a\u003e思路分析\u003c/h2\u003e\u003cp\u003e对于大型搜索引擎来说，在抓取并处理好网页之后，就要建立所谓的「倒排索引」了。所谓倒排索引，指的是以检索词的 term 为键，以包含该 term 的文档列表为值。如此一来，我们就可以根据检索词中的各个 term，获取若干列表。而后，对这些列表求交集，就能得到「包含检索词中所有 term」的文档了。\u003c/p\u003e\n\u003cp\u003e在个人网站上，特别是 Hexo 生成的静态站点，做类似的工作是不太容易的。这里原因有几点，分列如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHexo 生成的是静态站点，因此无法利用服务器做数据库的存储和相关计算；\u003c/li\u003e\n\u003cli\u003e这就制约了倒排索引的存储和求交；\u003c/li\u003e\n\u003cli\u003e另外一方面，制作倒排索引的过程，需要应用完善的 NLP 分词，这一工程量相对巨大。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e考虑到我们无法在服务器上做数据库存储，我们就必须以文件的形式保存索引，让用户以浏览器下载该文件。此外，考虑到我们无法在服务器上做计算，我们就必须依赖可在浏览器上执行的代码，处理用户的检索任务。因此，我们说，仿照大型搜索引擎制作站内搜索，对于静态站点来说，是不现实的。\u003c/p\u003e\n\u003cp\u003e那么，我们可以怎样做呢？既然标准的方案无法达成，那我们就只能退而求其次。\u003c/p\u003e\n\u003cp\u003e首先，不管怎样「求其次」，都必须要有一个索引文件。这是因为，在索引文件当中进行各种操作，总是要比直接对网页页面进行操作来得要方便和快捷的。因此，首先我们需要一个能够嵌入 Hexo 的工具，方便地生成这样的索引文件。其次，有了索引，我们需要一个有效的算法：根据用户输入的检索词，返回包含检索词的文章列表。考虑到这样的算法需要在用户的浏览器上执行，我们选择使用 JavaScript 和 jQuery 来实现。接下来，为了与用户交互：接受检索词和返回结果；我们需要在页面的合适位置展示搜索框和输出结果。最后，还有一些细节问题需要处理。例如说，搜索框和输出结果的样式要如何设计；例如说，索引文件通常比较大，随页面一起下载会导致页面加载缓慢，要如何解决这个问题。\u003c/p\u003e\n\u003cp\u003e我们依次来解决这些问题。\u003c/p\u003e\n\u003ch2 id=\"用-hexo-generator-search-生成索引\"\u003e\u003ca href=\"#用-hexo-generator-search-生成索引\" class=\"headerlink\" title=\"用 hexo-generator-search 生成索引\"\u003e\u003c/a\u003e用 \u003ccode\u003ehexo-generator-search\u003c/code\u003e 生成索引\u003c/h2\u003e\u003cp\u003eHaHack 参考 Christian Fei 的 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/christian-fei/Simple-Jekyll-Search\"\u003eSimple Jekyll Search\u003c/a\u003e 实现了名为 \u003ccode\u003ehexo-generator-search\u003c/code\u003e 的生成器。安装该生成器之后，在执行 \u003ccode\u003ehexo generate\u003c/code\u003e 的过程中，会按照配置生成一个 XML 文件，用于保存全站的文档数据。这个 XML 文件只是简单地做了数据的结构化存储，而完全没有考虑分词、倒排等问题。\u003c/p\u003e\n\u003cp\u003e安装 \u003ccode\u003ehexo-generator-search\u003c/code\u003e 非常简单，只需要在 Hexo 项目目录下执行下列命令即可。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003enpm install --save hexo-generator-search\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如此一来，我们只需在站点配置文件 \u003ccode\u003e_config.yml\u003c/code\u003e 当中写入如下配置，即可为全站的文档生成索引文件了。\u003c/p\u003e\n\u003cfigure class=\"highlight plaintext\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003esearch:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  path: search.xml\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  field: post\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e具体来说，\u003ccode\u003ehexo-generator-search\u003c/code\u003e 会为全站所有 \u003ccode\u003epost\u003c/code\u003e 类型的页面生成结构化的数据，并保存在本站的 \u003ccode\u003e/search.xml\u003c/code\u003e 当中。若想让 \u003ccode\u003epage\u003c/code\u003e 类型的页面也纳入索引，则可以将 \u003ccode\u003efield\u003c/code\u003e 的值修改为 \u003ccode\u003eall\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"用-JavaScript-和-jQuery-实现检索算法\"\u003e\u003ca href=\"#用-JavaScript-和-jQuery-实现检索算法\" class=\"headerlink\" title=\"用 JavaScript 和 jQuery 实现检索算法\"\u003e\u003c/a\u003e用 JavaScript 和 jQuery 实现检索算法\u003c/h2\u003e\u003cp\u003e另外一方面，HaHack 建议以 jQuery 的文本匹配为基础，在前端界面上运行站内搜索。主要的处理流程是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e载入 \u003ccode\u003esearch.xml\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e解析 \u003ccode\u003esearch.xml\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e解析检索词；\u003c/li\u003e\n\u003cli\u003e在索引中进行字符串匹配；\u003c/li\u003e\n\u003cli\u003e展现结果。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我对官方的版本进行了少许的修改（后详），并加入了注释。这样应该相对比较好理解了。你可以在 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Liam0205/hexo-search-plugin-snippets/blob/master/snippets/search.js\"\u003eGitHub\u003c/a\u003e 上看到我修改的版本。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e需要注意的是，\u003ccode\u003esearch.js\u003c/code\u003e 依赖 jQuery。因此，你需要在引入 \u003ccode\u003esearch.js\u003c/code\u003e 之前，引入 jQuery 的脚本。比如，你可以在 head 部分这样做：\u003ccode\u003e\u0026lt;script src=\u0026#34;//cdn.bootcss.com/jquery/3.2.1/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"在合适的位置展示搜索框\"\u003e\u003ca href=\"#在合适的位置展示搜索框\" class=\"headerlink\" title=\"在合适的位置展示搜索框\"\u003e\u003c/a\u003e在合适的位置展示搜索框\u003c/h2\u003e\u003cp\u003e接下来，我们需要在合适的位置，呈现一个搜索框。\u003c/p\u003e\n\u003cfigure class=\"highlight html\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003eform\u003c/span\u003e \u003cspan class=\"attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;site-search-form\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003einput\u003c/span\u003e \u003cspan class=\"attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;text\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;local-search-input\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;st-search-input\u0026#34;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003eform\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003ediv\u003c/span\u003e \u003cspan class=\"attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;local-search-result\u0026#34;\u003c/span\u003e \u003cspan class=\"attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;local-search-result-cls\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"tag\"\u003e\u0026lt;/\u003cspan class=\"name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此处，\u003ccode\u003elocal-search-input\u003c/code\u003e 是一个输入框，用于接收用户输入的检索词；\u003ccode\u003elocal-search-result\u003c/code\u003e 是用于展现搜索结果的 \u003ccode\u003ediv\u003c/code\u003e 标签。这部分代码，我也已上传到 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Liam0205/hexo-search-plugin-snippets/blob/master/snippets/search.swig\"\u003eGitHub\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"其他一些细节\"\u003e\u003ca href=\"#其他一些细节\" class=\"headerlink\" title=\"其他一些细节\"\u003e\u003c/a\u003e其他一些细节\u003c/h2\u003e\u003ch3 id=\"调用函数\"\u003e\u003ca href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"\u003e\u003c/a\u003e调用函数\u003c/h3\u003e\u003cp\u003e现在，我们已经有了索引文件、搜索算法和搜索框。但是，现在而言，搜索框是孤立的：用户在搜索框中输入内容，并不会触发搜索算法。换而言之，搜索函数并没有调用。因此，我们需要调用定义在 \u003ccode\u003esearch.js\u003c/code\u003e 当中定义的 \u003ccode\u003esearchFunc\u003c/code\u003e。\u003c/p\u003e\n\u003cfigure class=\"highlight javascript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003evar\u003c/span\u003e path = \u003cspan class=\"string\"\u003e\u0026#34;/search.xml\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"title function_\"\u003esearchFunc\u003c/span\u003e(path, \u003cspan class=\"string\"\u003e\u0026#39;local-search-input\u0026#39;\u003c/span\u003e, \u003cspan class=\"string\"\u003e\u0026#39;local-search-result\u0026#39;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"在何时的时候触发搜索函数\"\u003e\u003ca href=\"#在何时的时候触发搜索函数\" class=\"headerlink\" title=\"在何时的时候触发搜索函数\"\u003e\u003c/a\u003e在何时的时候触发搜索函数\u003c/h3\u003e\u003cp\u003e像上面这样调用搜索函数，有一个潜在的问题。调用搜索函数时，首先会尝试载入并解析 \u003ccode\u003esearch.xml\u003c/code\u003e 文件。这个文件包含了站点里所有博文的所有内容；因此，通常来说它的体积非常大。这样一来，如果不做任何限制，函数将在网页加载时被调用；因而，体积庞大的索引文件也将在网页加载的时候引入。这会导致网页整体加载的速度非常缓慢，对用户体验是一种伤害。\u003c/p\u003e\n\u003cp\u003e因此，我们会考虑，在激活搜索框时，我们才去调用搜索函数。\u003c/p\u003e\n\u003cfigure class=\"highlight javascript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003evar\u003c/span\u003e inputArea       = \u003cspan class=\"variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;#local-search-input\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003einputArea.\u003cspan class=\"property\"\u003eonclick\u003c/span\u003e   = \u003cspan class=\"keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"params\"\u003e\u003c/span\u003e){ \u003cspan class=\"title function_\"\u003egetSearchFile\u003c/span\u003e() }\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此处，我们通过 \u003ccode\u003einputArea\u003c/code\u003e 这个变量，监控搜索框的状态。只有当用户用鼠标点击搜索框时，才会触发 \u003ccode\u003egetSearchFile\u003c/code\u003e 函数，载入索引文件并执行 \u003ccode\u003esearchFunc\u003c/code\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003egetSearchFile\u003c/code\u003e 函数定义在 \u003ccode\u003esearch.js\u003c/code\u003e 脚本当中了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e不过，这还不够。因为，如此一来，每次用户点击搜索框时，都会触发一次 \u003ccode\u003esearchFunc\u003c/code\u003e 函数，并加载一次 \u003ccode\u003esearch.xml\u003c/code\u003e 索引文件。我们期待的是，只有当用户第一次点击搜索框之后，才去下载索引文件；之后的搜索行为，直接复用上一次加载的文件即可。\u003c/p\u003e\n\u003cp\u003e为此，我们需要在执行好 \u003ccode\u003egetSearchFile\u003c/code\u003e 函数之后，禁用 \u003ccode\u003eonclick\u003c/code\u003e 时间的 handler。\u003c/p\u003e\n\u003cfigure class=\"highlight javascript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003evar\u003c/span\u003e inputArea       = \u003cspan class=\"variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#34;#local-search-input\u0026#34;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003einputArea.\u003cspan class=\"property\"\u003eonclick\u003c/span\u003e   = \u003cspan class=\"keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"params\"\u003e\u003c/span\u003e){ \u003cspan class=\"title function_\"\u003egetSearchFile\u003c/span\u003e(); \u003cspan class=\"variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"property\"\u003eonclick\u003c/span\u003e = \u003cspan class=\"literal\"\u003enull\u003c/span\u003e }\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"在搜索框中屏蔽回车\"\u003e\u003ca href=\"#在搜索框中屏蔽回车\" class=\"headerlink\" title=\"在搜索框中屏蔽回车\"\u003e\u003c/a\u003e在搜索框中屏蔽回车\u003c/h3\u003e\u003cp\u003e由于我们在搜索框中使用了 \u003ccode\u003einput\u003c/code\u003e 标签。这是一个表单，但我们不希望它具有一些表单的行为。例如说，我们的搜索结果是实时呈现的；我们不希望用户在输入检索词之后，误按回车键，导致页面刷新。\u003c/p\u003e\n\u003cp\u003e为此，我们可以这样做。\u003c/p\u003e\n\u003cfigure class=\"highlight javascript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003einputArea.\u003cspan class=\"property\"\u003eonkeydown\u003c/span\u003e = \u003cspan class=\"keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"params\"\u003e\u003c/span\u003e){ \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e(event.\u003cspan class=\"property\"\u003ekeyCode\u003c/span\u003e == \u003cspan class=\"number\"\u003e13\u003c/span\u003e) \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003efalse\u003c/span\u003e }\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"在加载索引文件时，给用户一个提示\"\u003e\u003ca href=\"#在加载索引文件时，给用户一个提示\" class=\"headerlink\" title=\"在加载索引文件时，给用户一个提示\"\u003e\u003c/a\u003e在加载索引文件时，给用户一个提示\u003c/h3\u003e\u003cp\u003e我们为了保护页面加载的速度，将加载索引文件的过程，后移到用户点击搜索框时进行。然而，如前所述，索引文件通常是比较大的；加载并解析索引文件通常会耗费不少时间。在这个过程中，用户可能已经输入了一些检索词；这些检索词，会因为尚未加载完毕索引文件，而得不到任何的检索结果。这当然是不合适的。\u003c/p\u003e\n\u003cp\u003e因此，我们需要在加载和解析索引文件的过程中，给用户一个清晰的提示。为此，我们需要修改 \u003ccode\u003esearch.js\u003c/code\u003e 脚本。\u003c/p\u003e\n\u003cfigure class=\"highlight javascript\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003evar\u003c/span\u003e $resultContent = \u003cspan class=\"variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"string\"\u003e\u0026#39;local-search-result\u0026#39;\u003c/span\u003e);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e$resultContent.\u003cspan class=\"property\"\u003einnerHTML\u003c/span\u003e = \u003cspan class=\"variable constant_\"\u003eBTN\u003c/span\u003e + \u003cspan class=\"string\"\u003e\u0026#34;\u0026lt;ul\u0026gt;\u0026lt;span class=\u0026#39;local-search-empty\u0026#39;\u0026gt;首次搜索，正在载入索引文件，请稍后……\u0026lt;span\u0026gt;\u0026lt;/ul\u0026gt;\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e将这段代码放在加载和解析索引文件之前，就能在 \u003ccode\u003elocal-search-result\u003c/code\u003e 中提示「正在载入索引文件」了。\u003c/p\u003e\n\u003ch3 id=\"样式表\"\u003e\u003ca href=\"#样式表\" class=\"headerlink\" title=\"样式表\"\u003e\u003c/a\u003e样式表\u003c/h3\u003e\u003cp\u003e最后，我们可以通过样式表来控制这一系列内容的呈现形式。始终博客使用的样式表可以在 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Liam0205/hexo-search-plugin-snippets/blob/master/snippets/search.stylus\"\u003eGitHub\u003c/a\u003e 上找到。\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e做完了这些工作，就可以查看效果啦。始终博客的搜索框位于页面的右上角。\u003c/p\u003e\n\u003cp\u003e参考资料：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://hahack.com/codes/local-search-engine-for-hexo/\"\u003ehttp://hahack.com/codes/local-search-engine-for-hexo/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://moxfive.xyz/2016/05/31/hexo-local-search/\"\u003ehttp://moxfive.xyz/2016/05/31/hexo-local-search/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.barretlee.com/blog/2017/06/04/hexo-search-insite/\"\u003ehttp://www.barretlee.com/blog/2017/06/04/hexo-search-insite/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/barretlee/hexo-search-plugin-snippets\"\u003ehttps://github.com/barretlee/hexo-search-plugin-snippets\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/Liam0205/hexo-search-plugin-snippets\"\u003ehttps://github.com/Liam0205/hexo-search-plugin-snippets\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n    \u003c/div\u003e",
  "Date": "2017-09-21T09:04:53Z",
  "Author": "Liam Huang"
}