{
  "Source": "liam.page",
  "Title": "最佳搭档：利用正反 SSH 隧道穿透防火墙访问内网服务器",
  "Link": "https://liam.page/2018/04/11/break-firewall-by-the-use-of-SSH-tunnel/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eSSH 最基本的用法相信你已经了解。这次我们要用 SSH 来做一些特别的事情：建立正反 SSH 隧道，穿透防火墙，访问本不可见的内网服务器。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"管道和隧道\"\u003e\u003ca href=\"#管道和隧道\" class=\"headerlink\" title=\"管道和隧道\"\u003e\u003c/a\u003e管道和隧道\u003c/h2\u003e\u003cp\u003e我们先来看最简单的 SSH 命令。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh [-p \u0026lt;onPort\u0026gt;] [\u0026lt;user\u0026gt;@] \u0026lt;connectToHost\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此处方括号内的内容是可以省略的，尖括号内的内容是根据实际情况可修改的参数。这条命令表示，自执行命令的本机，向 \u003ccode\u003econnectToHost\u003c/code\u003e 的 \u003ccode\u003eonPort\u003c/code\u003e 端口发起请求，尝试以 \u003ccode\u003euser\u003c/code\u003e 身份登录。在上述 SSH 命令执行成功之后，我们就建立了从本机到 \u003ccode\u003econnectToHost\u003c/code\u003e 的连接。具体来说，本机的 SSH client 与 \u003ccode\u003econnectToHost\u003c/code\u003e 的 SSH server 建立了连接。我们可以将这一连接想像成一个有方向的管道；它的起点是本机的某个端口，而终点是 \u003ccode\u003econnectToHost\u003c/code\u003e 上的 \u003ccode\u003eonPort\u003c/code\u003e 端口。\u003c/p\u003e\n\u003cp\u003eSSH 的 \u003ccode\u003e-L\u003c/code\u003e 和 \u003ccode\u003e-R\u003c/code\u003e 选项，允许用户在上述管道内部，再创建一个有向隧道。大体上，你可以将其想像为外部的大号管道套住了内部的小号隧道。隧道的两端与管道的两端相同，起点则由 \u003ccode\u003e-L\u003c/code\u003eocal/\u003ccode\u003e-R\u003c/code\u003eemote 决定。使用 \u003ccode\u003e-L\u003c/code\u003e 选项时，本机的某个端口是起点；这种隧道称之为正向隧道；而使用 \u003ccode\u003e-R\u003c/code\u003e 选项时，起点是 \u003ccode\u003econnectToHost\u003c/code\u003e 上的 \u003ccode\u003eonPort\u003c/code\u003e 端口，这种隧道称之为反向隧道。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/Linux/HbSEM.png\"/\u003e\u003cbr/\u003e来自：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://unix.stackexchange.com/a/46271/140887\"\u003ehttps://unix.stackexchange.com/a/46271/140887\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"隧道与转发\"\u003e\u003ca href=\"#隧道与转发\" class=\"headerlink\" title=\"隧道与转发\"\u003e\u003c/a\u003e隧道与转发\u003c/h2\u003e\u003cp\u003e上述隧道可在已建立的 SSH 连接（管道）的基础上进行端口转发。我们从其语法开始说起，首先以 \u003ccode\u003e-L\u003c/code\u003e 为例。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh -L [\u0026lt;bindHost\u0026gt;:]\u0026lt;sourcePort\u0026gt;:\u0026lt;forwardToHost\u0026gt;:\u0026lt;onPort\u0026gt; \u0026lt;connectToHost\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这条命令表示，本机的 SSH 客户端将与 \u003ccode\u003econnectToHost\u003c/code\u003e 建立连接（管道），并在管道内建立从本机到 \u003ccode\u003econnectToHost\u003c/code\u003e 的隧道。此后，本机将把所有来自 \u003ccode\u003ebindHost\u003c/code\u003e 发往本机的 \u003ccode\u003esourcePort\u003c/code\u003e 端口的消息，通过上述隧道转交给 \u003ccode\u003econnectToHost\u003c/code\u003e，并由 \u003ccode\u003econnectToHost\u003c/code\u003e 负责发往 \u003ccode\u003eforwardToHost\u003c/code\u003e 的 \u003ccode\u003eonPort\u003c/code\u003e 端口。此处有两点值得注意。其一，\u003ccode\u003ebindHost\u003c/code\u003e 省略时或置为 \u003ccode\u003e*\u003c/code\u003e 时，表示本机将转发所有主机发往 \u003ccode\u003esourcePort\u003c/code\u003e 的消息。其二，\u003ccode\u003eforwardToHost\u003c/code\u003e 是站在 \u003ccode\u003econnectToHost\u003c/code\u003e 的视角看待的，因此若 \u003ccode\u003eforwardToHost\u003c/code\u003e 的值是 \u003ccode\u003elocalhost\u003c/code\u003e，则在此语境下表示 \u003ccode\u003econnectToHost\u003c/code\u003e 这台主机的本地回环。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/Linux/a28N8.png\"/\u003e\u003cbr/\u003e来自：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://unix.stackexchange.com/a/118650/140887\"\u003ehttps://unix.stackexchange.com/a/118650/140887\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e于是，\u003ccode\u003e-R\u003c/code\u003e 的版本也就容易理解了。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh -R [\u0026lt;bindHost\u0026gt;:]\u0026lt;sourcePort\u0026gt;:\u0026lt;forwardToHost\u0026gt;:\u0026lt;onPort\u0026gt; \u0026lt;connectToHost\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这条命令表示，本机的 SSH 客户端将与 \u003ccode\u003econnectToHost\u003c/code\u003e 建立连接（管道），并在管道内建立从 \u003ccode\u003econnectToHost\u003c/code\u003e 到本机的隧道。此后，\u003ccode\u003econnectToHost\u003c/code\u003e 将把所有来自 \u003ccode\u003ebindHost\u003c/code\u003e 发往 \u003ccode\u003econnectToHost\u003c/code\u003e 的 \u003ccode\u003esourcePort\u003c/code\u003e 端口的消息，通过上述隧道转交给本机，并由本机负责发往 \u003ccode\u003eforwardToHost\u003c/code\u003e 的 \u003ccode\u003eonPort\u003c/code\u003e 端口。至于 \u003ccode\u003ebindHost\u003c/code\u003e 和 \u003ccode\u003eforwardToHost\u003c/code\u003e 的语义则与 \u003ccode\u003e-L\u003c/code\u003e 版本类似。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cimg data-src=\"/uploads/images/Linux/4iK3b.png\"/\u003e\u003cbr/\u003e来自：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://unix.stackexchange.com/a/118650/140887\"\u003ehttps://unix.stackexchange.com/a/118650/140887\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"相关参数\"\u003e\u003ca href=\"#相关参数\" class=\"headerlink\" title=\"相关参数\"\u003e\u003c/a\u003e相关参数\u003c/h2\u003e\u003cp\u003e在使用隧道之前，还应了解一些参数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e-f\u003c/code\u003e：使 SSH 在建立连接之后保持在后台运行。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-N\u003c/code\u003e：告诉 SSH，我们只希望建立隧道，而不会在远程主机上执行任何指令。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-T\u003c/code\u003e：告诉 SSH，我们只希望建立隧道，因而不需要创建虚拟终端。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e-C\u003c/code\u003e：允许 SSH 压缩数据。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"穿透防火墙\"\u003e\u003ca href=\"#穿透防火墙\" class=\"headerlink\" title=\"穿透防火墙\"\u003e\u003c/a\u003e穿透防火墙\u003c/h2\u003e\u003cp\u003e我们做如下假设。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eHOST_A\u003c/code\u003e：目标机器；内网机器，位于防火墙之后，可以访问外网，但无法从外网访问。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHOST_B\u003c/code\u003e：跳板机；外网机器，位于防火墙之前，可以访问外网，但无法访问内网机器。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eHOST_C\u003c/code\u003e：工作机；外网机器，网络环境与 \u003ccode\u003eHOST_B\u003c/code\u003e 类似。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们的目的是希望 \u003ccode\u003eHOST_C\u003c/code\u003e 上能够随时随地访问 \u003ccode\u003eHOST_A\u003c/code\u003e，那么需要怎么做呢？\u003c/p\u003e\n\u003ch3 id=\"分析\"\u003e\u003ca href=\"#分析\" class=\"headerlink\" title=\"分析\"\u003e\u003c/a\u003e分析\u003c/h3\u003e\u003cp\u003e由于所有位于外网的机器都不可见 \u003ccode\u003eHOST_A\u003c/code\u003e，因此最终连接到 \u003ccode\u003eHOST_A\u003c/code\u003e 的方式必然在根本上从 \u003ccode\u003eHOST_A\u003c/code\u003e 发起，而后又将流量反向交给 \u003ccode\u003eHOST_A\u003c/code\u003e。因此，不难发现，在 \u003ccode\u003eHOST_A\u003c/code\u003e 上应当向跳板机 \u003ccode\u003eHOST_B\u003c/code\u003e 发起 SSH 连接，并通过反向隧道将流量返回 \u003ccode\u003eHOST_A\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e至此，跳板机 \u003ccode\u003eHOST_B\u003c/code\u003e 上已有一个端口可以连接到目标机器 \u003ccode\u003eHOST_A\u003c/code\u003e。现在的问题是，如何将连向跳板机的 SSH 连接转发到跳板机上的这个特殊端口。为此，我们可以在跳板机上向其自身建立一个 SSH 连接，而后通过正向隧道将流量在跳板机内部转发到上述端口。\u003c/p\u003e\n\u003ch3 id=\"实际操作看看\"\u003e\u003ca href=\"#实际操作看看\" class=\"headerlink\" title=\"实际操作看看\"\u003e\u003c/a\u003e实际操作看看\u003c/h3\u003e\u003cp\u003e首先在 \u003ccode\u003eHOST_A\u003c/code\u003e 上执行：\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh -fNTCR localhost:1556:localhost:22 HOST_B\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，\u003ccode\u003eHOST_A\u003c/code\u003e 向 \u003ccode\u003eHOST_B\u003c/code\u003e 发起 SSH 连接，建立了一个管道。而后，在管道内建立了一个从 \u003ccode\u003eHOST_B\u003c/code\u003e 到 \u003ccode\u003eHOST_A\u003c/code\u003e 的反向隧道。\u003ccode\u003eHOST_B\u003c/code\u003e 会将所有来自（第一个）\u003ccode\u003elocalhost\u003c/code\u003e（即 \u003ccode\u003eHOST_B\u003c/code\u003e 本机）的发往 \u003ccode\u003eHOST_B\u003c/code\u003e 1556 端口的流量，经由上述隧道转交给 \u003ccode\u003eHOST_A\u003c/code\u003e 本机，而后转发给（第二个）\u003ccode\u003elocalhost\u003c/code\u003e（即 \u003ccode\u003eHOST_A\u003c/code\u003e）的 22 端口。\u003c/p\u003e\n\u003cp\u003e而后在 \u003ccode\u003eHOST_B\u003c/code\u003e 上执行：\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh -fNTCL *:1555:localhost:1556 localhost\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，\u003ccode\u003eHOST_B\u003c/code\u003e 向自身（第二个 \u003ccode\u003elocalhost\u003c/code\u003e）发起 SSH 连接，建立了一个管道。而后，在管道内建立了一个从 \u003ccode\u003eHOST_B\u003c/code\u003e（本机）到 \u003ccode\u003eHOST_B\u003c/code\u003e（\u003cbr/\u003e这里，\u003ccode\u003eHOST_B\u003c/code\u003e 向自身（第二个 \u003ccode\u003elocalhost\u003c/code\u003e）的正向隧道。\u003ccode\u003eHOST_B\u003c/code\u003e（本机）会将来自任意主机的发往其 1555 端口的流量，经由上述隧道转交给 \u003ccode\u003eHOST_B\u003c/code\u003e（第二个 \u003ccode\u003elocalhost\u003c/code\u003e），而后转发给（第一个）\u003ccode\u003elocalhost\u003c/code\u003e（即 \u003ccode\u003eHOST_B\u003c/code\u003e）的 1556 端口。\u003c/p\u003e\n\u003cp\u003e如此一来，所有发往 \u003ccode\u003eHOST_B\u003c/code\u003e 的 1555 端口的流量，会先转发到 \u003ccode\u003eHOST_B\u003c/code\u003e 的 1556 端口，再转发到 \u003ccode\u003eHOST_A\u003c/code\u003e 的 22 端口。因此，只需要在 \u003ccode\u003eHOST_C\u003c/code\u003e 上对 \u003ccode\u003eHOST_B\u003c/code\u003e 的 1555 端口发起 SSH 连接，就相当于是对 \u003ccode\u003eHOST_A\u003c/code\u003e 的 22 端口发起连接。\u003c/p\u003e\n\u003cfigure class=\"highlight bash\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003essh -p 1555 HOST_B\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如此即可。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2018-04-11T05:25:08Z",
  "Author": "Liam Huang"
}