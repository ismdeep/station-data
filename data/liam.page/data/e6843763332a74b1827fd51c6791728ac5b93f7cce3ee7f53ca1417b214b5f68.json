{
  "Source": "liam.page",
  "Title": "编写 iOS 越狱插件：速览 Objective-C",
  "Link": "https://liam.page/2023/01/21/Build-an-iOS-Jailbreak-Tweak-Objective-C-the-quick-start/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003eObjective-C 在很长时间内都是 iOS 上的主流编程语言。2014 年 Apple 发布 Swift 之后，这一情况才逐渐改变。但是，在开发 Tweak 时，用得更多的依旧是 Objective-C。因此有必要对 Objective-C 有一个快速的了解。\u003c/p\u003e\n\u003cp\u003e这里假定你对 C-like 语言有一个较为全面的了解。若你是 C/C++ 的熟练使用者则更好。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003ch2 id=\"简介\"\u003e\u003ca href=\"#简介\" class=\"headerlink\" title=\"简介\"\u003e\u003c/a\u003e简介\u003c/h2\u003e\u003cp\u003eObjective-C 是 C 语言的严格超集。即是说，在 C 编译器下能够编译的代码，应当可以不加修改地使用 Objective-C 的编译器来编译。（尽管可能行为不完全相同）另一方面，在 Objective-C 当中，可以混合使用 C 风格的代码。\u003c/p\u003e\n\u003ch2 id=\"文件扩展名\"\u003e\u003ca href=\"#文件扩展名\" class=\"headerlink\" title=\"文件扩展名\"\u003e\u003c/a\u003e文件扩展名\u003c/h2\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e头文件\u003c/th\u003e\n\u003cth\u003e实现文件\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eC\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.h\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.c\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eC++\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.h\u003c/code\u003e/\u003ccode\u003e.hpp\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.cc\u003c/code\u003e/\u003ccode\u003e.cpp\u003c/code\u003e/\u003ccode\u003e.cxx\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eObjective-C\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.h\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.m\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eObjective-C++\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.h\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e.mm\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e为了兼容 C，我们依然可以使用预处理器指令 \u003ccode\u003e#include\u003c/code\u003e 来包含头文件。但是 Objective-C 提供了另一选项 \u003ccode\u003e#import\u003c/code\u003e。它与 \u003ccode\u003e#include\u003c/code\u003e 的作用几乎完全相同，但可以保证在一个编译单元中每个头文件都只被引入一次。即是说，它起到了传统 C/C++ 变成中 \u003ccode\u003e#pragma once\u003c/code\u003e 或是 Guard Macro 的作用。\u003c/p\u003e\n\u003ch2 id=\"基本类型\"\u003e\u003ca href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"\u003e\u003c/a\u003e基本类型\u003c/h2\u003e\u003cp\u003eObjective-C/C++ 中的基本类型和 C/C++ 中的差不多。几种基本类型在 Objective-C/C++ 中的长度分别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003echar\u003c/code\u003e: 1B\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eint\u003c/code\u003e: 4B\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003efloat\u003c/code\u003e: 4B\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edouble\u003c/code\u003e: 8B\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e此外，Objective-C/C++ 中也有 \u003ccode\u003eshort\u003c/code\u003e/\u003ccode\u003elong\u003c/code\u003e/\u003ccode\u003elong long\u003c/code\u003e/\u003ccode\u003esigned\u003c/code\u003e/\u003ccode\u003eunsigned\u003c/code\u003e 之类的修饰。含义也和 C/C++ 中的相同。\u003c/p\u003e\n\u003ch2 id=\"字符串\"\u003e\u003ca href=\"#字符串\" class=\"headerlink\" title=\"字符串\"\u003e\u003c/a\u003e字符串\u003c/h2\u003e\u003cp\u003eObjective-C 支持 C-style 字符串，并且也遵循 C 语言当中对引号使用的约定。亦即，使用单引号表示字符（例 \u003ccode\u003e\u0026#39;c\u0026#39;\u003c/code\u003e），使用双引号表示字符串（null termination）。但在 Objective-C 中也有实现 \u003ccode\u003eNSString\u003c/code\u003e 类（类似 C++ 中的 \u003ccode\u003estd::string\u003c/code\u003e 但更强大）。它更常用。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 字符类型字面量\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e\u0026#34;hello world\u0026#34;\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// C-style string\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"string\"\u003e@\u0026#34;hello world\u0026#34;\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// Objective-C NSString\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e此外，\u003ccode\u003eNSString\u003c/code\u003e 也支持 \u003ccode\u003eprintf\u003c/code\u003e 风格的字符串构造方法，以及支持从 C-style 字符串中构造。\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// construct a NSString object from literal\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSString\u003c/span\u003e* myString = \u003cspan class=\"string\"\u003e@\u0026#34;My String\\n\u0026#34;\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// construct a NSString object from printf formatter\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSString\u003c/span\u003e* anotherString = [\u003cspan class=\"built_in\"\u003eNSString\u003c/span\u003e stringWithFormat: \u003cspan class=\"string\"\u003e@\u0026#34;%d %s\u0026#34;\u003c/span\u003e, \u003cspan class=\"number\"\u003e1\u003c/span\u003e, \u003cspan class=\"string\"\u003e@\u0026#34;String\u0026#34;\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// construct a NSString object from C-style string\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSString\u003c/span\u003e*  fromCString = [\u003cspan class=\"built_in\"\u003eNSString\u003c/span\u003e stringWithCString: \u003cspan class=\"string\"\u003e\u0026#34;A C string\u0026#34;\u003c/span\u003e encoding: \u003cspan class=\"built_in\"\u003eNSASCIIStringEncoding\u003c/span\u003e];\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"逻辑控制\"\u003e\u003ca href=\"#逻辑控制\" class=\"headerlink\" title=\"逻辑控制\"\u003e\u003c/a\u003e逻辑控制\u003c/h2\u003e\u003ch3 id=\"if\"\u003e\u003ca href=\"#if\" class=\"headerlink\" title=\"if\"\u003e\u003c/a\u003e\u003ccode\u003eif\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eObjective-C 中的 \u003ccode\u003eif\u003c/code\u003e 语句和 C/C++ 中的基本一致。唯独，在 Objective-C 中以 \u003ccode\u003e0\u003c/code\u003e 表示 \u003ccode\u003efalse\u003c/code\u003e，而以其他值表示 \u003ccode\u003etrue\u003c/code\u003e。例如说，其他任何数值，或是任何字符串，在 \u003ccode\u003eObjective-C\u003c/code\u003e 中都会被认为是 \u003ccode\u003etrue\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"for-x2F-while\"\u003e\u003ca href=\"#for-x2F-while\" class=\"headerlink\" title=\"for/while\"\u003e\u003c/a\u003e\u003ccode\u003efor\u003c/code\u003e/\u003ccode\u003ewhile\u003c/code\u003e\u003c/h3\u003e\u003cp\u003eObjective-C 中的 \u003ccode\u003efor\u003c/code\u003e/\u003ccode\u003ewhile\u003c/code\u003e 和 C 中的完全一致。\u003c/p\u003e\n\u003ch2 id=\"函数调用\"\u003e\u003ca href=\"#函数调用\" class=\"headerlink\" title=\"函数调用\"\u003e\u003c/a\u003e函数调用\u003c/h2\u003e\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e\u003c/th\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e代码风格\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\u003ctr\u003e\n\u003ctd\u003eC/C++\u003c/td\u003e\n\u003ctd\u003e对象成员函数调用\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003eobj.method(args)\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eObjective-C/C++\u003c/td\u003e\n\u003ctd\u003e向对象传递消息\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003e[obj method: args]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\u003c/table\u003e\n\u003cp\u003e在 C++/Java 中，类中定义有成员函数/成员方法。我们可以通过类似 \u003ccode\u003eobj.method(args)\u003c/code\u003e 的方式调用 \u003ccode\u003eobj\u003c/code\u003e 对象的 \u003ccode\u003emethod\u003c/code\u003e 成员函数。如果 \u003ccode\u003emethod\u003c/code\u003e 在 \u003ccode\u003eobj\u003c/code\u003e 所属的类中没有定义，则在编译期就会报错。\u003c/p\u003e\n\u003cp\u003eObjective-C 则继承了 Smalltalk 的消息传递模型。在这一模型中，调用成员函数被视作是向对象发送一个消息。例如，\u003ccode\u003eobj.method(args)\u003c/code\u003e 式的调用会被写作是 \u003ccode\u003e[obj method: args]\u003c/code\u003e。这种写法的意思是，向 \u003ccode\u003eobj\u003c/code\u003e 这个对象发送名为 \u003ccode\u003emethod\u003c/code\u003e 的消息，\u003ccode\u003eargs\u003c/code\u003e 则是消息附带的参数。与 C++/Java 风格的调用不同，\u003ccode\u003eobj\u003c/code\u003e 所属的类即便没有定义名为 \u003ccode\u003emethod\u003c/code\u003e 的成员函数，我们在代码中依旧可以向 \u003ccode\u003eobj\u003c/code\u003e 发送这一消息。Objective-C 的编译器不会为此报错，但在程序执行时则会抛出一个异常。\u003c/p\u003e\n\u003cp\u003e对比下来，消息传递模型中类和成员函数的关系较为松散，这种调用方式总是在运行期动态绑定。于是，它不需要 C++ 当中的 \u003ccode\u003evirtual\u003c/code\u003e/\u003ccode\u003eoverride\u003c/code\u003e 关键字。当然，这种做法也存在一定额外开销。（显然）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e空对象（\u003ccode\u003enil\u003c/code\u003e）接受消息后默认不做任何事情。因此向 \u003ccode\u003enil\u003c/code\u003e 传递消息是安全的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"类的声明与数据成员\"\u003e\u003ca href=\"#类的声明与数据成员\" class=\"headerlink\" title=\"类的声明与数据成员\"\u003e\u003c/a\u003e类的声明与数据成员\u003c/h2\u003e\u003cp\u003e在 C++ 中，我们称之为「声明一个类」。在 Objective-C/C++ 中，我们说「定义类的接口（interface）」。\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e在 C++ 中，定义一个空的类形如\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFoo\u003c/span\u003e {};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意，它不需要继承自一个作为占位符的父类。在 Objective-C/C++ 中，定义一个空类形如\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e : \u003cspan class=\"title\"\u003eNSObject\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意，和 Python 中所有类都继承自 \u003ccode\u003eobject\u003c/code\u003e 类似，Objective-C 中所有类都继承自 \u003ccode\u003eNSObject\u003c/code\u003e。\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e在 C++ 中，定义一个包含有数据成员的类形如\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFoo\u003c/span\u003e : \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e Bar {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003eprotected\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003eint\u003c/span\u003e data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003eprivate\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003eint\u003c/span\u003e private_data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e类比在 Objective-C/C++ 中则是\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e : \u003cspan class=\"title\"\u003eBar\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003eint\u003c/span\u003e data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@implementation\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"type\"\u003eint\u003c/span\u003e private_data;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eObjective-C 的类分为接口（interface）和实现（implementation）。接口部分通常包含了类声明以及其中数据成员的定义，以及相关成员函数的声明。实现部分通常包含了成员函数的实现代码。\u003c/p\u003e\n\u003cp\u003e注意，C++ 中，\u003ccode\u003eclass\u003c/code\u003e 中的数据成员默认是 \u003ccode\u003eprivate\u003c/code\u003e 的；在 Objective-C/C++ 中，\u003ccode\u003e@interface\u003c/code\u003e 段定义的数据成员默认是 \u003ccode\u003eprotected\u003c/code\u003e 的，\u003ccode\u003e@implementation\u003c/code\u003e 段定义的数据成员默认是 \u003ccode\u003eprivate\u003c/code\u003e 的。为了保持访问控制一致，额外在 C++ 代码中加上了 \u003ccode\u003eprotected\u003c/code\u003e 关键字来指定 \u003ccode\u003edata\u003c/code\u003e 的访问控制类型。\u003c/p\u003e\n\u003ch2 id=\"成员函数\"\u003e\u003ca href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"\u003e\u003c/a\u003e成员函数\u003c/h2\u003e\u003cp\u003e在 C++ 中，成员函数的声明形如\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title class_\"\u003eFoo\u003c/span\u003e : \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e Bar {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e \u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e:  \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003estatic\u003c/span\u003e \u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eclass_method\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003einstance_method1\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 3.a\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003einstance_method2\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e p1)\u003c/span\u003e\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 3.b\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"function\"\u003e\u003cspan class=\"type\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003einstance_method3\u003c/span\u003e\u003cspan class=\"params\"\u003e(\u003cspan class=\"type\"\u003eint\u003c/span\u003e p1, \u003cspan class=\"type\"\u003eint\u003c/span\u003e p2)\u003c/span\u003e\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 4.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e};\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e类比在 Objective-C 中，则是如下形式\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e: \u003cspan class=\"title\"\u003eBar\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e+(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e) class_method;  \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e) instance_method1;  \u003cspan class=\"comment\"\u003e// 3.a\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e) instance_method2: (\u003cspan class=\"type\"\u003eint\u003c/span\u003e) p1;  \u003cspan class=\"comment\"\u003e// 3.b\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e) instance_method3: (\u003cspan class=\"type\"\u003eint\u003c/span\u003e) p1 and: (\u003cspan class=\"type\"\u003eint\u003c/span\u003e) p2;  \u003cspan class=\"comment\"\u003e// 4.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e首先关注 (1)。在 C++ 中，\u003ccode\u003eclass\u003c/code\u003e 内的访问控制默认是 \u003ccode\u003eprivate\u003c/code\u003e。因此，要使声明的成员函数可用，我们需要显式地指明 \u003ccode\u003epublic\u003c/code\u003e。在 Objective-C 中，\u003ccode\u003e@interface\u003c/code\u003e 段的方法默认是 \u003ccode\u003e@public\u003c/code\u003e 的。\u003c/p\u003e\n\u003cp\u003e接下来关注 (2)。在 C++ 中有所谓的 \u003ccode\u003estatic\u003c/code\u003e-成员函数。此类成员函数是属于整个类的，不能修改类的对象内部的数据成员。Objective-C 中也有类似设定，即所谓的类方法（class method）。具体形式是在方法前加上一个 \u003ccode\u003e+\u003c/code\u003e 记号。\u003c/p\u003e\n\u003cp\u003e现在关注 (3)。这是典型的成员函数的声明方式。这样的成员函数是与具体的类的对象绑定的，必须要有一个构造好的对象才能执行这些成员函数。在 Objective-C 中，这是所谓的对象方法（instance method），也称为一般方法。\u003c/p\u003e\n\u003cp\u003e(4) 处也声明了一般意义上的成员函数，但在 Objective-C 这里稍有不同。对 Objective-C 的版本，它的函数全名（签名）是 \u003ccode\u003einstance_method3:and:\u003c/code\u003e。即是说，在声明时，函数的名称和参数列表交织在一起；每个冒号后面都带有一次参数传递。调用它的时候则类似：\u003ccode\u003e[obj instance_method3: 0 and: 1]\u003c/code\u003e。这是 Objective-C/C++ 特有的。\u003c/p\u003e\n\u003ch2 id=\"属性\"\u003e\u003ca href=\"#属性\" class=\"headerlink\" title=\"属性\"\u003e\u003c/a\u003e属性\u003c/h2\u003e\u003cp\u003e尽管我们也可以在 Objective-C 中定义数据成员，但实际上更好的方式是使用属性。例如\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e: \u003cspan class=\"title\"\u003eNSObject\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@property\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e age;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e它等价于\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@interface\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e: \u003cspan class=\"title\"\u003eNSObject\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@property\u003c/span\u003e \u003cspan class=\"type\"\u003eint\u003c/span\u003e age;  \u003cspan class=\"comment\"\u003e// 1.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@implementation\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@synthesize\u003c/span\u003e age = _age;  \u003cspan class=\"comment\"\u003e// 2.\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这里，(1) 声明了类 \u003ccode\u003eFoo\u003c/code\u003e 的一个属性。它的类型是 \u003ccode\u003eint\u003c/code\u003e，名字是 \u003ccode\u003eage\u003c/code\u003e。如果没有显式地如 (2) 这样将属性和变量关联起来，则编译器会自动产生一个变量，并做这样的关联。注意，属性的声明应当位于 \u003ccode\u003e@interface\u003c/code\u003e 段，属性与变量的关联则应放在 \u003ccode\u003e@implementation\u003c/code\u003e 段。\u003c/p\u003e\n\u003cp\u003e你也可以使用别的变量与属性进行关联。例如 \u003ccode\u003e@synthesize age = internal_age;\u003c/code\u003e。这样会将 \u003ccode\u003eage\u003c/code\u003e 这个属性与 \u003ccode\u003einternal_age\u003c/code\u003e 这个数据成员进行关联。\u003c/p\u003e\n\u003cp\u003e声明属性，则编译器会为我们自动生成相应的 setter/getter 方法。例如说，上面的代码，大致相当于会生成这样的代码：\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003e@implementation\u003c/span\u003e \u003cspan class=\"title\"\u003eFoo\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-(\u003cspan class=\"type\"\u003evoid\u003c/span\u003e) setAge: (\u003cspan class=\"type\"\u003eint\u003c/span\u003e) n {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eself\u003c/span\u003e-\u0026gt;_age = n;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-(\u003cspan class=\"type\"\u003eint\u003c/span\u003e) age {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"keyword\"\u003eself\u003c/span\u003e-\u0026gt;_age;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003e@end\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e也就是说，通过属性，我们将类的数据成员封装了起来。外部不能直接操作类的数据成员，而要通过 setter/getter 来操作。此外，Objective-C 还为此提供了类似 C++ 中成员访问运算符（\u003ccode\u003e.\u003c/code\u003e）的语法糖。我们可以写出类似下面的代码\u003c/p\u003e\n\u003cfigure class=\"highlight objectivec\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ep.age = \u003cspan class=\"number\"\u003e10\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// 1.a\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e[p setAge: \u003cspan class=\"number\"\u003e10\u003c/span\u003e];  \u003cspan class=\"comment\"\u003e// 1.b\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSLog\u003c/span\u003e(\u003cspan class=\"string\"\u003e@\u0026#34;age is: %d\u0026#34;\u003c/span\u003e, p.age);  \u003cspan class=\"comment\"\u003e// 2.a\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eNSLog\u003c/span\u003e(\u003cspan class=\"string\"\u003e@\u0026#34;age is: %d\u0026#34;\u003c/span\u003e, [p age]);  \u003cspan class=\"comment\"\u003e// 2.b\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e其中 (1.a) 和 (1.b) 的含义相同，(2.a) 和 (2.b) 的含义也相同。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2023-01-21T01:32:37Z",
  "Author": "Liam Huang"
}