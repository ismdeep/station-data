{
  "Source": "liam.page",
  "Title": "程序员的自我修养（十）：C++ 的内存模型",
  "Link": "https://liam.page/2021/06/05/memory-model-cpp/",
  "Content": "\u003cdiv class=\"post-body\" itemprop=\"articleBody\"\u003e\n\n      \n        \u003cp\u003e上一次写这个系列好像还是 COVID-19 疫情爆发之前。此篇讨论一下 C++ 当中的内存模型。文中内容基本上是 CPP reference 上\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/memory_model\"\u003e对应页面\u003c/a\u003e的翻译，有删减和补充。\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\n\u003cp\u003e内存模型为 C++ 抽象机器定义了计算机内存存储语义。\u003c/p\u003e\n\u003cp\u003eC++ 程序可用的内存是一个或多个连续的字节序列。每个字节有自己独有的内存地址。\u003c/p\u003e\n\u003ch2 id=\"字节（Byte）\"\u003e\u003ca href=\"#字节（Byte）\" class=\"headerlink\" title=\"字节（Byte）\"\u003e\u003c/a\u003e字节（Byte）\u003c/h2\u003e\u003cp\u003e字节是内存中的最小可寻址单元，由连续的多个比特组成。C++ 中，\u003ccode\u003echar\u003c/code\u003e/\u003ccode\u003eunsigned char\u003c/code\u003e/\u003ccode\u003esigned char\u003c/code\u003e 的对象存储和\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/object\"\u003e值表示\u003c/a\u003e均使用恰好 1 字节。于是，字节中有多少比特，可以通过 \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://en.cppreference.com/w/cpp/types/numeric_limits\"\u003e\u003ccode\u003estd::numeric_limits\u0026lt;unsigned char\u0026gt;::digits\u003c/code\u003e\u003c/a\u003e取得。\u003c/p\u003e\n\u003ch2 id=\"内存位置（Memory-Location）\"\u003e\u003ca href=\"#内存位置（Memory-Location）\" class=\"headerlink\" title=\"内存位置（Memory Location）\"\u003e\u003c/a\u003e内存位置（Memory Location）\u003c/h2\u003e\u003cp\u003e内存位置是\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/type\"\u003e标量类型\u003c/a\u003e（算数类型、指针类型、枚举类型或是 \u003ccode\u003estd::nullptr_t\u003c/code\u003e）的对象；\u003c/li\u003e\n\u003cli\u003e或是，长度不为零的\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/bit_field\"\u003e位域\u003c/a\u003e组成的最长连续序列。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title class_\"\u003eS\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003echar\u003c/span\u003e a;     \u003cspan class=\"comment\"\u003e// memory location #1\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eint\u003c/span\u003e b : \u003cspan class=\"number\"\u003e5\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// memory location #2\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"type\"\u003eint\u003c/span\u003e c : \u003cspan class=\"number\"\u003e11\u003c/span\u003e, \u003cspan class=\"comment\"\u003e// memory location #2 (continued)\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e          : \u003cspan class=\"number\"\u003e0\u003c/span\u003e,  \u003cspan class=\"comment\"\u003e// zero-length, as a delimiter of continued sequence of bit-fields\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        d : \u003cspan class=\"number\"\u003e8\u003c/span\u003e;  \u003cspan class=\"comment\"\u003e// memory location #3\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"type\"\u003eint\u003c/span\u003e ee : \u003cspan class=\"number\"\u003e8\u003c/span\u003e; \u003cspan class=\"comment\"\u003e// memory location #4\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    } e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e} obj; \u003cspan class=\"comment\"\u003e// The object \u0026#39;obj\u0026#39; consists of 4 separate memory locations\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e注意：语言中的许多特性会引入额外的内存位置。这些内存位置程序无法访问，而是为编译器实现自行管理。这些特性例如：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/reference\"\u003e引用\u003c/a\u003e和\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/virtual\"\u003e虚函数\u003c/a\u003e。\u003c/p\u003e\n\u003ch2 id=\"线程与数据竞争（Thread-and-data-races）\"\u003e\u003ca href=\"#线程与数据竞争（Thread-and-data-races）\" class=\"headerlink\" title=\"线程与数据竞争（Thread and data races）\"\u003e\u003c/a\u003e线程与数据竞争（Thread and data races）\u003c/h2\u003e\u003cp\u003e程序中的线程是自 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/thread/thread/thread\"\u003e\u003ccode\u003estd::thread::thread\u003c/code\u003e\u003c/a\u003e, \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/thread/async\"\u003e\u003ccode\u003estd::async\u003c/code\u003e\u003c/a\u003e 或者其他方式调用顶层函数开始的控制流。\u003c/p\u003e\n\u003cp\u003e任一线程都可能访问程序中的任意对象。其中，原子及\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/storage_duration\"\u003e线程内部存储\u003c/a\u003e亦可能为其它线程通过指针或引用来访问。\u003c/p\u003e\n\u003cp\u003e在没有同步或阻塞的情况下，不同线程可并发访问（读/写）不同内存位置。\u003c/p\u003e\n\u003cp\u003e若一个表达式求值对某一内存位置进行写操作，而另一求值过程对同一内存位置进行读或写操作，则两个求值过程存在冲突。除非满足下列条件，程序中冲突的求值操作将引发数据竞争：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e存在冲突的求值操作在同一线程中执行，或在同一\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/utility/program/signal#Signal_handler\"\u003e信号处理函数\u003c/a\u003e中执行；或者\u003c/li\u003e\n\u003cli\u003e存在冲突的求值操作均是原子操作（参见 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/atomic\"\u003e\u003ccode\u003estd::atomic\u003c/code\u003e\u003c/a\u003e）；或者\u003c/li\u003e\n\u003cli\u003e存在冲突的求值操作，其一\u003cins\u003e先于（happens-before）\u003c/ins\u003e另一发生（参见 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e\u003ccode\u003estd::memory_order\u003c/code\u003e\u003c/a\u003e）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e数据竞争将导致未定义行为。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e cnt = \u003cspan class=\"number\"\u003e0\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e f = [\u0026amp;]{ cnt++; };\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread t1{f}, t2{f}, t3{f};  \u003cspan class=\"comment\"\u003e// undefined behavior\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003estd::atomic\u0026lt;\u003cspan class=\"type\"\u003eint\u003c/span\u003e\u0026gt; cnt{\u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e f = [\u0026amp;]{ cnt++; };\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread t1{f}, t2{f}, t3{f};  \u003cspan class=\"comment\"\u003e// OK, by using atomic variable\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e特别地，对于同一个 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/thread/mutex\"\u003e\u003ccode\u003estd::mutex\u003c/code\u003e\u003c/a\u003e，在一个线程中释放它与在另一线程中获取它是\u003cins\u003e同步的（synchronized-with）\u003c/ins\u003e，故而释放动作\u003cins\u003e先于（happens-before）\u003c/ins\u003e获取动作。因此，可用 \u003ccode\u003estd::mutex\u003c/code\u003e 来避免数据竞争。\u003c/p\u003e\n\u003cfigure class=\"highlight cpp\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"type\"\u003eint\u003c/span\u003e cnt{\u003cspan class=\"number\"\u003e0\u003c/span\u003e};\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::mutex mtx;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eauto\u003c/span\u003e f = [\u0026amp;]{ std::lock_guard\u0026lt;std::mutex\u0026gt; \u003cspan class=\"built_in\"\u003elk\u003c/span\u003e(mtx); cnt++; };\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estd::thread t1{f}, t2{f}, t3{f};  \u003cspan class=\"comment\"\u003e// OK, by using mutex to ensure happens-before semantic\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"内存顺序（Memory-Order）\"\u003e\u003ca href=\"#内存顺序（Memory-Order）\" class=\"headerlink\" title=\"内存顺序（Memory Order）\"\u003e\u003c/a\u003e内存顺序（Memory Order）\u003c/h2\u003e\u003cp\u003e线程自某个内存位置取值时，读到的可能是它的初始值，也可能是当前线程写入的值，亦可能是其他线程写入的值。有关内存顺序的细节可参见 \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic/memory_order\"\u003e\u003ccode\u003estd::memory_order\u003c/code\u003e\u003c/a\u003e；其中讨论了线程的写入操作在其他线程可见性的问题。\u003c/p\u003e\n\u003ch2 id=\"前向执行（Forward-Progress）\"\u003e\u003ca href=\"#前向执行（Forward-Progress）\" class=\"headerlink\" title=\"前向执行（Forward Progress）\"\u003e\u003c/a\u003e前向执行（Forward Progress）\u003c/h2\u003e\u003ch3 id=\"无阻塞（Obstruction-freedom）\"\u003e\u003ca href=\"#无阻塞（Obstruction-freedom）\" class=\"headerlink\" title=\"无阻塞（Obstruction freedom）\"\u003e\u003c/a\u003e无阻塞（Obstruction freedom）\u003c/h3\u003e\u003cp\u003e仅有一个未被标准库函数阻塞的线程在执行无锁\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/atomic\"\u003e原子函数（atomic function）\u003c/a\u003e时，该原子函数必能执行完毕（标准库内所有无锁操作均\u003ca href=\"obstruction-free\"\u003e无阻塞\u003c/a\u003e）。\u003c/p\u003e\n\u003ch3 id=\"无锁（Lock-freedom）\"\u003e\u003ca href=\"#无锁（Lock-freedom）\" class=\"headerlink\" title=\"无锁（Lock freedom）\"\u003e\u003c/a\u003e无锁（Lock freedom）\u003c/h3\u003e\u003cp\u003e一个或更多无锁原子函数并发执行时，至少其中之一必能执行完毕（标准库内所有无所操作均\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom\"\u003e无锁\u003c/a\u003e——编译器实现会保证它们不会被一直锁住，例如持续地被窃走缓存行（cache-line stealing；一种因为执行其他线程的 CPU 核心对内存数据做预取而导致当前 CPU 核心缓存行变脏的现象））。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关于 cache-line stealing，参见：\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.researchgate.net/publication/221497089_Tackling_Cache-Line_Stealing_Effects_Using_Run-Time_Adaptation\"\u003e这篇论文\u003c/a\u003e。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"执行之担保（Progress-guarantee）\"\u003e\u003ca href=\"#执行之担保（Progress-guarantee）\" class=\"headerlink\" title=\"执行之担保（Progress guarantee）\"\u003e\u003c/a\u003e执行之担保（Progress guarantee）\u003c/h3\u003e\u003cp\u003e在正确的 C++ 程序当中，所有线程终将执行到下列情形之一：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e终止；\u003c/li\u003e\n\u003cli\u003e调用 I/O 库的函数；\u003c/li\u003e\n\u003cli\u003e经由\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.cppreference.com/w/cpp/language/cv\"\u003e易变（volatile）\u003c/a\u003e的左值（lvalue）或者将亡值（xvalue）——拥有内存地址的长寿对象——访问外部设备；\u003c/li\u003e\n\u003cli\u003e执行原子操作或是同步操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e若一个线程执行上述任一操作（I/O, volatile, 原子操作或是同步操作），或是阻塞在标准库函数当中，亦或是因其他为阻塞线程正在并发执行导致调用一个无锁原子操作却尚未完成，则称该线程\u003cins\u003e有进展（make progress）\u003c/ins\u003e。\u003c/p\u003e\n\u003ch3 id=\"并发前向执行（Concurrent-forward-progress-since-C-17）\"\u003e\u003ca href=\"#并发前向执行（Concurrent-forward-progress-since-C-17）\" class=\"headerlink\" title=\"并发前向执行（Concurrent forward progress; since C++17）\"\u003e\u003c/a\u003e并发前向执行（Concurrent forward progress; since C++17）\u003c/h3\u003e\u003cp\u003e若某线程有\u003cins\u003e并发前向执行之担保（concurrent forward progress guarantee）\u003c/ins\u003e，则在它终止之前，无论其他线程（若有）是否有进展，它都将于有限时间内取得如上定义之\u003cins\u003e进展（make progress）\u003c/ins\u003e。\u003c/p\u003e\n\u003cp\u003eC++ 标准鼓励（但并不强求）主线程和其他由 \u003ccode\u003estd::thread\u003c/code\u003e 启动的线程提供\u003cins\u003e并发前向执行之担保\u003c/ins\u003e。\u003c/p\u003e\n\u003ch3 id=\"并行前向执行（Parallel-forward-progress-since-C-17）\"\u003e\u003ca href=\"#并行前向执行（Parallel-forward-progress-since-C-17）\" class=\"headerlink\" title=\"并行前向执行（Parallel forward progress; since C++17）\"\u003e\u003c/a\u003e并行前向执行（Parallel forward progress; since C++17）\u003c/h3\u003e\u003cp\u003e若某线程有\u003cins\u003e并行前向执行之担保（parallel forward progress guarantee）\u003c/ins\u003e，则\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在它尚未执行任何步骤（I/O, volatile, 原子操作或是同步操作）时，编译器实现不保证它在有限时间内有\u003cins\u003e进展\u003c/ins\u003e；\u003c/li\u003e\n\u003cli\u003e而一旦它执行了某一步骤，它提供\u003cins\u003e并发前向执行之担保\u003c/ins\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e此规则表明，线程池中的线程可以按照任意顺序执行任务。\u003c/p\u003e\n\u003ch3 id=\"弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）\"\u003e\u003ca href=\"#弱并行前向执行（Weakly-parallel-forward-progress-since-C-17）\" class=\"headerlink\" title=\"弱并行前向执行（Weakly parallel forward progress; since C++17）\"\u003e\u003c/a\u003e弱并行前向执行（Weakly parallel forward progress; since C++17）\u003c/h3\u003e\u003cp\u003e若某线程有\u003cins\u003e弱并行前向执行之担保（weakly parallel forward progress guarantee）\u003c/ins\u003e，则无论其他线程是否有\u003cins\u003e进展\u003c/ins\u003e，它都不保证它在有限时间内有\u003cins\u003e进展\u003c/ins\u003e。\u003c/p\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-06-05T02:36:41Z",
  "Author": "Liam Huang"
}