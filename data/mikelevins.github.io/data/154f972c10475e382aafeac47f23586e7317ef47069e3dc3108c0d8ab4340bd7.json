{
  "Source": "mikelevins.github.io",
  "Title": "Programming as teaching",
  "Link": "https://mikelevins.github.io/posts/2020-02-03-programming-as-teaching/",
  "Content": "\u003cdiv class=\"post\"\u003e\n\n\t\t\t\t\t\u003cdiv class=\"post-heading\"\u003e\n\t\t\t\t\t\t\u003ch1\u003eProgramming as teaching\u003c/h1\u003e\n\t\t\t\t\t\t\u003cspan class=\"post-date\"\u003e\u003ca href=\"https://mikelevins.github.io/posts/2020-02-03-programming-as-teaching/\"\u003e# Feb 3, 2020\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003cp\u003eMost programming uses an approach that we might call \u003cstrong\u003eprogramming as\ncarpentry\u003c/strong\u003e. We start with some idea of an artifact we want to\nbuild. We analyze the idea into a set of needed parts. We set to work\non our workbench to craft the needed parts and assemble them into a\nfinished product, then we examine and measure the result to determine\nhow close we came to our goal.\u003c/p\u003e\n\u003cp\u003eNext we repeat the process to correct details that have fallen short\nof what we want, either because we made mistakes in construction, or\nbecause our original plan was wrong in some way.\u003c/p\u003e\n\u003cp\u003eThere’s a different way to approach programming. We might call it\n\u003cstrong\u003eprogramming as teaching\u003c/strong\u003e. In this approach, we begin by starting up\na runtime that already knows how to be a working program; it just\ndoesn’t know how to be our particular application. By talking to the\nruntime interactively, we incrementally teach it the features we need\nit to have. When it knows how to provide all those features, we’re\ndone. We can save the accumulated changes to an artifact, and that\nartifact becomes our product.\u003c/p\u003e\n\u003cp\u003eIt’s less like nailing together an artifact on a workbench, and more\nlike teaching a student a new set of skills.\u003c/p\u003e\n\u003cp\u003eProgramming as carpentry is far better known and more widely used than\nprogramming as teaching. I’d venture to say that most programmers\naren’t even aware that programming as teaching is an option. That’s a\nshame, I think, because for some people it’s a better option.\u003c/p\u003e\n\u003cp\u003eI don’t claim that the teaching paradigm is absolutely and objectively\nbetter. I claim only that it’s better for some people. Take me, for\nexample: programming as teaching makes me much happier, faster, and\nmore productive in my work.\u003c/p\u003e\n\u003cp\u003eI’m not the only one. There are many other programmers who prefer the\nteaching paradigm. The reason it’s an obscure minority paradigm is\nthat there are even more programmers—vastly more—who are familiar with\nprogramming as carpentry.\u003c/p\u003e\n\u003cp\u003eThe fact that most programmers don’t seem to even know that the\nteaching paradigm exists suggests to me that if it were more widely\nknown, then more people would use it. What are the odds that everyone\nwho prefers the obscure paradigm is already using it, when most people\ndon’t know it exists?\u003c/p\u003e\n\u003cp\u003eIn some sense, it doesn’t matter. The great majority of software is\ndeveloped in the carpentry paradigm, and the industry prospers. Is it\nreally important to evangelize a different paradigm? Probably not, at\nleast for the sake of the industry as a whole.\u003c/p\u003e\n\u003cp\u003eOn the other hand, I think it is important for the sake of us as\nprogrammers. If I hadn’t been exposed to programming as teaching, I\nprobably never would have known how happy and productive I can be in\nmy work. A world in which I know about the teaching paradigm is a\nbetter world, at least for me. If there are other programmers who\nwould prefer the teaching paradigm, and who don’t know about it, then\nthere’s a better world awaiting them. All they need is to find out\nabout it.\u003c/p\u003e\n\u003cp\u003eSo if programming as teaching is such a great idea—even if it’s only\ngreat for a minority of programmers—why isn’t it better known? I think\nit’s because programming as teaching requires some tools over and\nabove what programming as carpentry requires. You have to expend extra\nwork to make those tools available, and you have to know about them\nbefore you can decide to do that.\u003c/p\u003e\n\u003cp\u003eYou can build a solid carpentry workbench without knowing anything\nabout the teaching paradigm. The reverse isn’t true. A good\nprogramming-as-teaching system is going to need all the tools of the\ncarpentry workbench. It’s going to need parsers and data structures\nand code-walkers and code generators. It’s going to need file I/O and\nperformance tools and debuggers, and so forth. It’s going to need all\nthat stuff, but it’s going to need some other stuff, too.\u003c/p\u003e\n\u003cp\u003eProgramming as teaching means starting the application running before\nit’s defined, then defining and redefining features while it runs. It\nmeans inspecting the contents of its memory, stopping control\nstructures in the middle of executing, and inspecting and changing and\nredefining their dynamic context. It means updating the definitions of\nfunctions that are pending on the stack and of datatypes that are used\nby existing instances, and relying on the application to keep working\nreasonably while you’re tinkering around in its guts.\u003c/p\u003e\n\u003cp\u003eAll of those features require substantial runtime support, and if you\nwant it to work well, the runtime needs to be designed from the start\nto support it.\u003c/p\u003e\n\u003cp\u003eSmalltalk systems have thorough support for that kind of\nprogramming. So do Common Lisp and other old-fashioned Lisp\nsystems. Outside Smalltalk and Common Lisp and, to some extent FORTH\nsystems, there aren’t many development systems with the full suite of\nprogramming-as-teaching features.\u003c/p\u003e\n\u003cp\u003eSome of these features exist in some form in modern\nprogramming-as-carpentry systems, but they don’t amount to a\nprogramming-as-teaching system. To build a working\nprogramming-as-teaching system, you need to design the whole runtime\nfrom the ground up to support it. Let me give you an example of what I\nmean.\u003c/p\u003e\n\u003cp\u003eThe ANSI Common Lisp standard defines a generic function named\nUPDATE-INSTANCE-FOR-REDEFINED-CLASS. When the runtime detects a value\nwhose class has been redefined since it was instantiated, it\nautomatically calls this function to restructure the value so that it\nconforms to the new definition. In effect, it retroactively makes the\nvalue an instance of the new definition instead of the old one.\u003c/p\u003e\n\u003cp\u003eYou can specialize UPDATE-INSTANCE-FOR-REDEFINED-CLASS to correctly\nreinitialize instances to conform to their new definitions. If you\ndon’t, then the runtime drops you into an interactive session in which\nyou can provide the new initialization interactively. You can then\nresume execution and the affected value behaves as if it was\noriginally instantiated from the updated definition.\u003c/p\u003e\n\u003cp\u003eIf you’re coming from programming-as-carpentry, you might reasonably\nwonder why you would ever want a function like that at all, much less\nwhy you would want it to be part of a language standard. But Common\nLisp was designed by experienced Lisp users and implementors. They\nwere steeped in the practice of programming as teaching (though they\ndidn’t call it that; they just called it “programming”).\u003c/p\u003e\n\u003cp\u003eTo the designers of Common Lisp, the normal way of developing a\nprogram was to start the Lisp and then teach it, definition by\ndefinition, how to be the program they wanted. They wouldn’t expect to\nhave to restart their Lisp just because they redefined something;\nthat’s silly. Redefining things was nearly all they did! No, their\nexpectation was that you redefine things and keep going. It’s the job\nof the runtime to adapt in a reasonable way to the changes that you\ntell it about. It’s also the job of the runtime to ask you for help\nwhen it doesn’t know what to do.\u003c/p\u003e\n\u003cp\u003eUPDATE-INSTANCE-FOR-REDEFINED-CLASS is one element of a whole standard\nprotocol defined by ANSI Common Lisp for changing and redefining\nthings while the program you’re developing continues to run. The\nstandard describes facilities for defining classes and functions,\nupdating bindings, catching errors by dropping into an interactive\nsession where you can inspect and change everything about the dynamic\nenvironment, then tell the function where the error occurred to resume\nexecution with the new definitions, and generally for accomplishing\nevery aspect of building and deploying a program through an\ninteractive conversation with the running program itself.\u003c/p\u003e\n\u003cp\u003eSmalltalk systems have the same kind of design.\u003c/p\u003e\n\u003cp\u003eThis kind of development environment is a whole that is greater than\nthe sum of its parts. To get it, you have to design the language and\nruntime from the start to support it. You can’t convert a carpentry\nsystem to a teaching system by patching in one feature at a time.\u003c/p\u003e\n\u003cp\u003eVery few development toolchains support the full suite of\nprogramming-as-teaching features. Most of the ones that do have been\naround for a long time. Newer languages and runtimes are mostly\ndesigned without any knowledge or understanding of the whole-system\nprogramming paradigm that is embodied in old Lisp and Smalltalk\nsystems. Even some newer Lisps have been designed without that\nunderstanding.\u003c/p\u003e\n\u003cp\u003eI worry sometimes that programming-as-teaching is fading away, and I\nfeel sad that my favorite paradigm might someday disappear altogether.\u003c/p\u003e\n\u003cp\u003eI don’t think that if it does it’ll be the end of software\ndevelopment, or anything apocalyptic like that. I do think that I’ll\nmiss it when it’s gone, and I think it’ll be sad if new generations of\nprogrammers never have the opportunity to experience it.\u003c/p\u003e\n\u003cp\u003eThere’s something magical about gradually turning a program into the\napplication you want by talking to it while it runs. For some fraction\nof programmers, it’s the best way of working. I’d hate to lose it.\u003c/p\u003e\n\n\n\t\t\t\t\u003c/div\u003e",
  "Date": "2020-02-03T00:00:00Z",
  "Author": "mikel evins"
}