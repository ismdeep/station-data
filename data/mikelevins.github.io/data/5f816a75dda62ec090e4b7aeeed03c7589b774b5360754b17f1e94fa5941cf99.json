{
  "Source": "mikelevins.github.io",
  "Title": "Categories",
  "Link": "https://mikelevins.github.io/posts/2009-08-13-categories/",
  "Content": "\u003cdiv class=\"post\"\u003e\n\n\t\t\t\t\t\u003cdiv class=\"post-heading\"\u003e\n\t\t\t\t\t\t\u003ch1\u003eCategories\u003c/h1\u003e\n\t\t\t\t\t\t\u003cspan class=\"post-date\"\u003e\u003ca href=\"https://mikelevins.github.io/posts/2009-08-13-categories/\"\u003e# Aug 13, 2009\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003cp\u003eThere are a few things I’ve written that I see cited or quoted\nrepeatedly. The oldest is a quip about omnipotent beings that I wrote\neighteen years ago in a USENET discussion:\u003c/p\u003e\n\u003cp\u003e“Perhaps this morning there were only three Euclidean solids, but god\nchanged its mind retroactively at lunchtime, remaking the whole\nhistory of the universe.  That’s the way it is with omnipotent\nbeings.”\u003c/p\u003e\n\u003cp\u003eMore recent is an explanation I once gave of the concept of “natural\nlaw” in politics. There are a couple of basic theories of law; one of\nthem is called “natural law”. Because that phrase is also used to mean\n“law of nature”, people sometimes confuse the two concepts, often, I\nthink, because they’re not aware that the legal one exists, or are not\naware of what it is. This was my attempt to succinctly summarize it in\none discussion:\u003c/p\u003e\n\u003cp\u003e“People will naturally and predictably find some methods for resolving\n[…] conflicts more congenial than others. There are some classes of\nconflict for which people will naturally and predictably find certain\nkinds of resolutions more congenial than others. The procedures people\nfind more congenial will also produce the resolutions people find more\ncongenial. And the procedures and resolutions that people find more\ncongenial will tend to resemble each other across times and cultures.”\u003c/p\u003e\n\u003cp\u003eTwo others are more technical articles that I wrote early in the 1990s\nabout programming. They were published in a magazine aimed at Mac\ndevelopers, called Frameworks.\u003c/p\u003e\n\u003cp\u003e“Objects Without Classes” was republished by the ACM’s Computer\nmagazine in Volume 27 , Issue 3 (March 1994) . It’s a basic\ndescription of prototype-based object systems, such as those found in\nlanguages like Self and Javascript. Languages with prototype-based\nobject systems probably seemed novel to more people then than they do\nnow. Lots of people use Javascript now, but at that time you might\nnever have heard of prototype-based object systems unless you were at\nSun working on Self, or in the AI business, working with frame\nlanguages, or at Apple working on Newton or SK8.\u003c/p\u003e\n\u003cp\u003eThe topic of this post is the ideas presented in “Protocols,”\noriginally published in the March, 1994 issue of Frameworks, and\narchived at\n\u003ca href=\"http://www.mactech.com/articles/frameworks/8_2/Protocol_Evins.html\"\u003ehttp://www.mactech.com/articles/frameworks/8_2/Protocol_Evins.html\u003c/a\u003e. It’s\nan article about how representation, behavior, and taxonomy are\ndistinct concepts that can be handled separately, despite the fact\nthat object-oriented languages tend to confuse them.\u003c/p\u003e\n\u003cp\u003eThose points need clarifying, I know.\u003c/p\u003e\n\u003cp\u003eBy “representation,” I mean how we concretely lay out data. As an\nexample, you can represent an array as a contiguous sequence of memory\nlocations, or as a table of indexes paired with pointers, or as a tree\nof cells in which bit patterns are mapped to subtrees, or, of course,\nin many other ways. There are circumstances in which each of the\ndifferent approaches might be advantageous. These are different\n\u003cem\u003erepresentations\u003c/em\u003e of a common abstract concept that I have here called\nan “array”.\u003c/p\u003e\n\u003cp\u003eBy “behavior,” I mean the set of operations that is defined on any\ngiven set of values. Taking the abovementioned abstract concept of an\n“array” as an example, you can use any of the mentioned\nrepresentations to support a common behavior. You can\nstraightforwardly implement functions that fetch an element of an\narray by index, that iterate over the members of an array, that write\na new value to the array at some specified index. The implementation\nand performance details will differ, of course, because the\nrepresentation differs, but the behavior—that is, the API and what it\naccomplishes—is the same.\u003c/p\u003e\n\u003cp\u003eBy “taxonomy,” I mean the relationship between one defined set of\nvalues and another. Types are categories of values. They are (possibly\nunbounded) collections of data objects. Types naturally have subtypes;\na collection of values has a natural relation to a smaller collection\nof some of the same values: the smaller set is a subtype of the larger\none. It’s natural to think of obtaining the smaller set by starting\nwith the larger one and adding restrictions that filter out some\nvalues. You can think of taxonomies of types, such as the class\nhierarchies in languages like Smalltalk and Java, as sets of values\nthat begin with a very inclusive type, like Java’s Object, and\ndevelops more and more refined types by adding more and more exclusive\nrestrictions. Object is all the values (I know; it’s not really all of\nthem.) Number excludes all those objects that aren’t representations\nof magnitudes. Integer excludes all that are not representations of\nwhole numbers. And so on.\u003c/p\u003e\n\u003cp\u003eThese three concepts, representation, behavior, and taxonomy, are\nquite distinct, but most object-oriented languages conflate at least\ntwo of them. Some combine all three. Smalltalk classes, for example,\nare representation, behavior, and taxonomy all rolled into one. The\nrepresentation is in the instance variables; the behavior is in the\nmethods; the taxonomy is in the subclass/superclass relations. THe\ntrouble with that approach is that when you ask for one of the three,\nyou get the other two whether you want them or not. For example, if\nyou create a new subclass, you inherit representation, behavior, and\ntaxonomy, even if all you wanted was behavior. If you create some\nsubclass because you want a certain taxonomic relation, you also get a\nrepresentation and a behavior that may or may not be what you need.\u003c/p\u003e\n\u003cp\u003eThe claim of the “Prototypes” article was that you can treat these\nthree concepts separately, and by doing so develop a discipline that\nmakes object-oriented design and implementation feasible in any\nlanguage. Furthermore, by doing so, you can develop APIs that are\nlanguage independent. To take the “array” example, what makes it an\n“array” is that you can get and set elements by index, and iterate\nover them in index order. That’s behavior. If representation,\nbehavior, and taxonomy are properly separated, you can represent\n“arrays” any way you like, and you can arrange for them to be subtypes\nof any type you like, and they’ll still be arrays, because they\nsupport “array” behavior. Representation and taxonomy can be treated\nindependently as well, but not if your tools insist on conflating\nthem.\u003c/p\u003e\n\u003cp\u003eI still think that’s true, and useful, but I was always interested in\ncodifying the ideas of that article more concretely. I was interested\nin working with an object system designed around clearly\ndistinguishing representation, behavior, and taxonomy.\u003c/p\u003e\n\u003cp\u003eOne language that pretty much nails it is Haskell. In Haskell,\nrepresentation is the province of datatypes. Behavior is handled by\nfunctions. Taxonomy belongs to typeclasses.\u003c/p\u003e\n\u003cp\u003eFor those unfamiliar with Haskell, the terminology is probably\nconfusing. Without some experience with Haskell, it’s probably not at\nall clear how and why “datatypes” and “typeclasses” are\ndifferent. Briefly, a Haskell datatype is a named description of an\narrangement of data. A typeclass is a named description of a set of\noperations. You can make a datatype into a member of a typeclass by\ndefining functions that implement the operations specified by the\ntypeclass.\u003c/p\u003e\n\u003cp\u003eThis is pretty close to what I was talking about in “Protocols;” it’s\nprobably closer than anything else I’ve seen to language support for\nthose concepts. The next closest thing, I think, is the style of\nobject system exemplified by CLOS (the Common Lisp Object System). In\nCLOS, classes describe representation and taxonomy. Generic functions\nand methods describe behavior. It’s easy and convenient to describe\nbehavior in CLOS independently of representation or taxonomy. CLOS\ndoes still conflate representation with taxonomy, though it provides\nfacilities for modifying itself that enable you to work around that\nconflation if you really want to.\u003c/p\u003e\n\u003cp\u003eIn February of 2009 I had been using the new Lisp dialect, Clojure,\nfor about five months on some projects, and was generally pretty happy\nwith it. One area I wasn’t happy with, though, was Clojure’s approach\nto types and polymorphic functions. Clojure doesn’t really have a type\nsystem as such. It has a small number of well-chosen and well-designed\ntypes, and it can transparently use Java’s types (Clojure’s main\nimplementation is built on the JVM). For most uses, these two\nfacilities are more than sufficient, and they work very well. They\nfell a little short of what I wanted for some of my work, though. One\nof my projects requires ways to specify a large number of structured\ndata elements with taxonomic relations. The set of elements is open,\nand expected to grow over time, so I need a convenient way to add\ndescriptions of new ones, and ways to ensure that relevant APIs are\ndefined to work in the proper way over all the values currently\ndescribed, and over all those that are yet to be described.\u003c/p\u003e\n\u003cp\u003eClojure gives me a lot of what I want to support this scenario, but\nnot all of it. Clojure’s maps provide a great way to describe\nstructured data, but not a great way to place restrictions on it. I\ncan say that Foo has fields A, B, and C, but there’s no convenient way\nto say that A is an automobile and B is a hypotenuse; nor is there a\nconvenient way to say that a Foo has A,B, and C, and nothing else.\u003c/p\u003e\n\u003cp\u003eI was even more dissatisfied with the facilities that Clojure provided\nfor defining taxonomy. Clojure’s documentation, and its justifiably\nenthusiastic users, make much of the fact that Clojure’s derive\nfunction and its polymorphic MultiFns make it possible to define\narbitrary taxonomies. That’s true for small values of “arbitrary”. You\ncan easily construct any taxonomy, as long as it’s a taxonomy that\nClojure was designed to easily construct. Mine wasn’t.\u003c/p\u003e\n\u003cp\u003eThe details of the problems don’t matter. My main point is that I ran\ninto a couple of insoluble problems with Clojure’s MultiFns, derive,\nand hierarchies, and, after some discussion, satisfied myself that the\nClojure community regarded those obstacles as features rather than\nbugs. So I did what any sensible Lisp hacker does in a situation like\nthat: I wrote my own object system.\u003c/p\u003e\n\u003cp\u003eIt began as an existence proof of an alternative way of handling\npolymorphic dispatch. There was a little bit of interest in it from a\ncouple of people, but for the most part the Clojure community reacted\nwith a shrug. On the whole, they’re happy with Clojure’s\napproach. More power to them.\u003c/p\u003e\n\u003cp\u003eAs I tweaked a few things to respond to casually-mentioned\nhypothetical objections, I started to like what I had. I was testing\nit by reimplementing important parts of some production code I was\nworking on. I realized pretty early that the subsystem I was builiding\nbore more than a passing resemblance to the ideas in “Protocols”. I\nrefactored it a few times. I tried a couple of different\nimplementation strategies. It got faster, simpler, and more appealing\n(to me, that is). Somewhere along the way, I started calling it\nCategories.\u003c/p\u003e\n\u003cp\u003eI have a couple of implementations of it in Clojure now, with somewhat\ndifferent APIs. More recently, I ported it to Scheme, so that I can\ntry it out in a different application context. The API mutated a\nlittle more. I’m still refactoring things to try to make the surface\nAPI simpler and easier to understand.\u003c/p\u003e\n\u003cp\u003eCategories represents the concepts from “Protocols” pretty\nstraightforwardly. The basic concepts are:\u003c/p\u003e\n\u003cp\u003eTypes: descriptions of how data are laid out.\u003c/p\u003e\n\u003cp\u003eFunctions: operations that accept zero or more values as parameters,\nand that compute and return zero or more values as results.\u003c/p\u003e\n\u003cp\u003eDomains: descriptions of relations among types.\u003c/p\u003e\n\u003cp\u003eFunctions are polymorphic, and are defined in terms of domains. In\nother words, a functions looks at its arguments at runtime and decides\nwhich actual code to run based on what it sees. This is like any other\nobject-oriented language, as far as it goes. The distinguishing\ncharacteristic of the system is how a function choses a method.\u003c/p\u003e\n\u003cp\u003eWhen you construct a function, one parameter to its constructor is a\ndomain. A domain contains a catalog of types, and a set of rules\n(represented as functions) that describe how the types are\nrelated. Domains can tell you things like whether a type is a member\nof the domain, whether one type is a subtype of another, and whether a\nmethod can be applied to a particular set of argument values.\u003c/p\u003e\n\u003cp\u003eImportantly, you can have as many domains as you want, and each one\ncan work differently. How you represent the relations among types is\nentirely up to you. This means that you can pretty easily implement\nany kind of dispatching you want. Smaltalk-style, Java-style,\nCLOS-style, predicate dispatch—it’s all good. The Categories subsystem\ndefines a default domain that implements a dispatch scheme very\nsimilar to those of CLOS and Dylan (because I like those schemes and\nam comfortable with them), but the default is just one domain. If you\nwant something different, it’s easy enough to build it. Just to make\nsure, I wrote implementations of Clojure’s dispatch and of a\npredicate-dispatch scheme. They were easy to do.\u003c/p\u003e\n\u003cp\u003eWhen I was first discussing these ideas, someone mentioned some\nconcern that it wouldn’t be possible to implement such a system\nefficiently, or to optimize it. In practice, it hasn’t been a\nproblem. There is a tradeoff between exposing the API you need to\nimplement a domain efficiently, and making the domain API\nunderstandable, and that’s been a major issue I’m dealing with in\nrewrites of Categories. It seems clear at this point, though, that\nefficient implementations are doable. The trick is setting things up\nso that you can write domains that are efficient without exposing a\nconfusing array of knobs and switches. I’m still working on striking\nthe right balance.\u003c/p\u003e\n\u003cp\u003eYou can’t get a current working version of Categories right now; I\nstill have its guts out on the table so I can tinker with them. Some\nof its early predecessors are readily available if you really want\nthem, but if you read this and are really interested in Categories,\nI’d counsel patience. I’m folding it into some product code right now,\nand making corrections and improvements as that process reveals the\nneed. It’s my intention to nail it down and ship a product that uses\nit, then port that version back over to Clojure to support some other\nwork I’m doing in that language. Once I reach that point, if you ask\nme for it, I’ll give it to you.\u003c/p\u003e\n\u003cp\u003eWhy would you want it? I dunno; you might not. I sure did, though,\nenough to build it. Soon I’ll see if it was a waste of time, or a\ngreat new tool for my toolbox.\u003c/p\u003e\n\n\n\t\t\t\t\u003c/div\u003e",
  "Date": "2009-08-13T00:00:00Z",
  "Author": "mikel evins"
}