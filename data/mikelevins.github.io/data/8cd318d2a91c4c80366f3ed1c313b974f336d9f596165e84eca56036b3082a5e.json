{
  "Source": "mikelevins.github.io",
  "Title": "More joy",
  "Link": "https://mikelevins.github.io/posts/2009-04-26-more-joy/",
  "Content": "\u003cdiv class=\"post\"\u003e\n\n\t\t\t\t\t\u003cdiv class=\"post-heading\"\u003e\n\t\t\t\t\t\t\u003ch1\u003eMore joy\u003c/h1\u003e\n\t\t\t\t\t\t\u003cspan class=\"post-date\"\u003e\u003ca href=\"https://mikelevins.github.io/posts/2009-04-26-more-joy/\"\u003e# Apr 26, 2009\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003cp\u003eProgrammers inevitably spend a certain amount of our time fighting\nwith our tools. There’s always something wrong with them, always some\ncase that they handle badly, always some work we have to do, not\nbecause of the job we’re doing, but because of limitations of the\nstupid tool.\u003c/p\u003e\n\u003cp\u003eProgramming can be a joy, even programming for a living. I’m lucky in\nthat it’s been a joy for me more often than it hasn’t. But fighting\nwith the tools is not a source of joy. In fact, it’s the\nopposite. More fighting with tools means less joy.\u003c/p\u003e\n\u003cp\u003eLess joy is bad.\u003c/p\u003e\n\u003cp\u003eThat’s why I remain a Lisp programmer: the various forms of Lisp have\ngiven me by far the best return on investment I ever experienced in\nterms of joy per unit fighting. I can write code in other\nlanguages. I’ve written lots of it. I’ve been paid a lot of money to\nwrite a lot of lines of C, C++, Python, shell script, Java, ML,\nObjective-C…just lots of languages, on lots of jobs, in lots of\ncircumstances. I’m still writing Lisp code because of that\njoy-to-fighting ratio.\u003c/p\u003e\n\u003cp\u003eMore joy is good.\u003c/p\u003e\n\u003cp\u003eSo what’s my favorite programming language?\u003c/p\u003e\n\u003cp\u003eWell…\u003c/p\u003e\n\u003cp\u003eI used to say it was 1992-era Dylan. Dylan was a Lisp that Apple\ninvented. I worked for several years on Apple’s Newton project. Newton\nwas initially written mostly in Dylan, and I got to write a lot of OS\ncode in Dylan. That was a time of high joy in my programming life.\u003c/p\u003e\n\u003cp\u003eIt didn’t last, of course. The story of Newton’s abandonment of Dylan\nand its other adventures makes entertaining reading, but the short of\nit is that eventually I had to stop programming in Dylan.\u003c/p\u003e\n\u003cp\u003eLess joy is bad.\u003c/p\u003e\n\u003cp\u003eHalfway through 2008, one of the original designers and implementors\nof Dylan pointed out to me this new Lisp dialect named Clojure:\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://clojure.org/\"\u003ehttp://clojure.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe reason she noticed it was that it’s a Lisp whose name is a\nmisspelling of the world “closure”, and she’s a partner in a Lisp\ncompany named “Clozure Associates”. Fun coincidence!\u003c/p\u003e\n\u003cp\u003eIt turned out that this new Lisp, named Clojure, was pretty good. In\nfact, the more little projects I ported to it, the happier I\nbecame. More joy is good.\u003c/p\u003e\n\u003cp\u003eThree quarters of a year later, Clojure has become my favorite\nprogramming language for personal projects. Whenever I think about\nwriting something, I immediately think about Clojure, and if\ndeployment on the JVM is at all reasonable, then Clojure is probably\nwhat I’ll use.\u003c/p\u003e\n\u003cp\u003eI guess Clojure is my favorite programming language now.\u003c/p\u003e\n\u003cp\u003eAll is not entirely well, though. There’s a lot of joy, but there’s\nstill just a little bit too much fighting.\u003c/p\u003e\n\u003cp\u003eEvery time I do anything significant in Clojure, I inevitably stumble\nover something that makes me wish I was using Dylan instead.\u003c/p\u003e\n\u003cp\u003eBother.\u003c/p\u003e\n\u003cp\u003eI never used to wish I was using Clojure back in the day, instead of\nDylan. Well, of course, Clojure didn’t exist then, but I never wished\nI was using anything instead of Dylan.\u003c/p\u003e\n\u003cp\u003eSo why don’t I just use Dylan? It’s still around, right?\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.opendylan.org/\"\u003ehttp://www.opendylan.org/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eWell…something happened to Dylan over the past seventeen years. It’s\nnot bad or anything. It just doesn’t excite me that way its ancestral\nform did. It doesn’t feel like a Lisp anymore. Less joy is bad.\u003c/p\u003e\n\u003cp\u003eStill, when I use Clojure, I often wish I had Dylan. When I used\nDylan, I never wished I had something else. What’s the problem?\u003c/p\u003e\n\u003cp\u003eSometimes I’m working on an application that has certain requirements\non its data. I’d like to just clearly and concisely write down those\nrequirements. In Dylan (or a zillion other languages) I’d write a type\ndefinition (Dylan calls them classes). There’s nothing like that in\nClojure.\u003c/p\u003e\n\u003cp\u003eNow, Clojure is a Lisp. You can write whatever facilities you need, if\nthey’re not there already. So I wrote my own implementation of record\ntypes, so that I could write down my data requirements\nsuccinctly. Problem solved. Still: more fighting, less joy.\u003c/p\u003e\n\u003cp\u003ePolymorphic functions are really handy. With polymorphic functions you\ncan easily write abstract protocols and then implement them for\nvarious different data types without needing to rewrite any of the\nprotocol code. Very useful, especially when you’re writing some big\napplication that you expect to evolve over time, that you expect to\nneed to encompass new and evolving data types.\u003c/p\u003e\n\u003cp\u003eClojure has its own idea about how polymorphic functions should\nwork. I don’t want to get into the details, because it would get long\nand eye-glazing and I’d probably start to froth at the mouth. Let’s\njust say that Clojure’s creator and some of its other users believe\nthat Clojure’s approach is a better way to approach polymorphism,\nwhereas I think it’s like someone giggling hysterically as they break\nall your toys and poke sharp sticks in your eyes.\u003c/p\u003e\n\u003cp\u003eMore fighting; less joy.\u003c/p\u003e\n\u003cp\u003eSo I wrote my own generic functions subsystem. Now I can make APIs\nthat don’t randomly burst into flame when someone writes code that\nuses them. Once again, it’s nice that Clojure is a Lisp: it gives me\nthe tools I need to patch things like this. Still, less joy continues\nto be bad.\u003c/p\u003e\n\u003cp\u003eOne of the great things about Clojure is that it’s designed to be\nhosted on the JVM, and to interoperate seamlessly with Java. That’s\nquite a useful feature, and Clojure’s Java interface is really easy\nand convenient. So easy and convenient, in fact, that it’s probably\neasier to use Java libraries from Clojure than it is to use them from\nJava.\u003c/p\u003e\n\u003cp\u003eOn the other hand, Clojure sort of has more than one type system, and\neach of the type systems is sort of not really comprehensive. I mean,\non the one hand, every Clojure value is in fact a Java value, but, on\nthe other hand, knowing that two different values are both instances\nof PersistentHashMap may not be all that helpful if each has different\n:type metatdata, and your application includes some code somewhere\nthat distinguishes them on that basis.\u003c/p\u003e\n\u003cp\u003eWhat exactly is the type of Clojure value? Well, there’s its Java\nclass, which may or may not be a helpful thing to know, depending on\ncontext. Then there’s its metadata, if it’s a kind of value that can\nhave metadata, and if it is, there might or might not be a :type in\nthat metadata, and that type might or might not be something your code\ncan use for something useful. It sort of feels like Common Lisp’s\ntypes before CLOS came along and absorbed all types into its grand\ngalactic scheme.\u003c/p\u003e\n\u003cp\u003eAnd what if you want to make your own types? Well, there isn’t really\nany Clojure facility for doing that, but it’s a Lisp, right? You can\nmake whatever kind of type system you want. Of course, the more type\nsystems you have, the more you have to keep track of, and none of them\nare really comprehensive over all possible Clojure values. Well,\nexcept Java’s. You can always fall back to Java classes. Except that\nif you want to define new ones you have to kind of jump through a few\nhoops.\u003c/p\u003e\n\u003cp\u003eYou know what I’m going to say: more fighting, less joy.\u003c/p\u003e\n\u003cp\u003eNo doubt someone will skim this and assume I’m bashing Clojure. I’m\nnot bashing Clojure. It’s my favorite programming language right\nnow. I just noticed that, hey, I keep wishing it was something\nelse. That’s weird. The last time I was doing a lot of work in my\nfavorite programming language, I didn’t ever wish it was something\nelse. What’s up with that?\u003c/p\u003e\n\u003cp\u003eMaybe it’s that Clojure is still very young and is evolving rapidly\n(except, hmm…Dylan was really young back then and evolving very\nrapidly, too…)\u003c/p\u003e\n\u003cp\u003eOr maybe it’s that Clojure approximates the Lisp I really want,\nwithout actually being it. If so, then Dylan was apparently a closer\napproximation, but one that grew farther away over time, rather than\ncloser.\u003c/p\u003e\n\u003cp\u003eI guess I’ll have to do some thinking about what both Dylan and\nClojure are approximations of.\u003c/p\u003e\n\n\n\t\t\t\t\u003c/div\u003e",
  "Date": "2009-04-26T00:00:00Z",
  "Author": "mikel evins"
}