{
  "Source": "mikelevins.github.io",
  "Title": "Gambit considered helpful",
  "Link": "https://mikelevins.github.io/posts/2009-10-18-gambit-considered-helpful/",
  "Content": "\u003cdiv class=\"post\"\u003e\n\n\t\t\t\t\t\u003cdiv class=\"post-heading\"\u003e\n\t\t\t\t\t\t\u003ch1\u003eGambit considered helpful\u003c/h1\u003e\n\t\t\t\t\t\t\u003cspan class=\"post-date\"\u003e\u003ca href=\"https://mikelevins.github.io/posts/2009-10-18-gambit-considered-helpful/\"\u003e# Oct 18, 2009\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003cp\u003eI’ve just packed up Delectus(tm) 1.0 Alpha 2 and shipped it off to my\ntesters. Delectus is an application for keeping track of collections\nof things. The inspiration for it was an ancient and hoary program my\nmother used to keep track of her movies. She has around a thousand\nmovies, the majority of them still on videocassettes. Each cassette\nhas a catalog number on it, and she uses a database program to\nassociate those numbers with information like the title, star, genre,\nand so forth, so that she can quickly find a particular movie in her\nstacks of shelves. Recently the software, which is over twenty years\nold, finally became obsolete. As we were looking for a replacement, I\ndecided I’d just write one, and that became the genesis of Delectus.\u003c/p\u003e\n\u003cp\u003eThe basic design of Delectus is very simple. A Delectus document\nstores a list of rows and a list of columns. Each column has a text\nlabel. Each row contains a list of text fields. The number of fields\nis the same in every row, and it’s also the same as the number of\ncolumns. So you can create a document with the columns “Title”,\n“Genre”, and “Star”, and every row will then have three fields. You\ncan make a new row and put the title of a movie into the “Title”\nfield, the star into the “Star” field, and the genre into the “Genre”\nfield.\u003c/p\u003e\n\u003cp\u003eDelectus doesn’t decide for you how many columns to create or what the\nnames will be. Instead, a new Delectus document has no rows and no\ncolumns. You can add new rows and new columns at any time, and you can\ndelete them at any time, too. This flexibility makes it easy to set up\nyour databases any way that is convenient for you. You can sort a\ndocument’s entries, forward or backward, by clicking the heading of a\ncolumn. If every entry in a column is a number, Delectus detects that\nautomatically, and sorts by number instead of lexicographically.\u003c/p\u003e\n\u003cp\u003eDelectus uses a trash can, like OS X’s trash can. When you delete a\nrow or column, it’s not really gone, but tossed into the trash. Click\na trash button, and Delectus shows the trash to you, integrated in the\ndocument, but displayed in a different color, so you can easily tell\nwhich items are deleted. Empty the trash, of course, and the deleted\nitems are gone forever.\u003c/p\u003e\n\u003cp\u003eDelectus is mainly written in Scheme. The Scheme compiler I’m using is\nGambit-C. A few weeks ago, I wrote a post about the happy discovery\nthat Gambit-C made it easy to work with Mac OS X’s Cocoa frameworks. I\nsaid Gambit was a great platform for Cocoa development. That opinion\ndrew some fire, but I haven’t changed it. To the contrary, I’ve grown\nhappier with Gambit as I’ve developed Delectus.\u003c/p\u003e\n\u003cp\u003eSome people grumbled that I’m not allowed to call it a great platform\nif I still have to deal with C code. Now, that’s silly. You know, I\nactually had a Lisp system once in which I never had to deal with C\ncode. It was called a Symbolics Lisp Machine, Every other Lisp I’ve\nused–and I’ve used a lot of them in twenty one years of\nprogramming–has had to deal with C in one way or another, at one time\nor another. Heck, even when I was writing Lisp code for an operating\nsystem written in Lisp (an unshipped version of Apple’s Newton), we\nhad to deal with C code. If your eyes are damaged by the sight of\nsemicolons, a hard road awaits you. C code is in the underpinnings of\nevery system you are ever likely to use. At least Gambit makes it easy\nto wrap our beloved parentheses around it, so that the hothouse\nflowers in our midst are protected from the hot exhaust bits spewing\nforth from the C code beneath our feet.\u003c/p\u003e\n\u003cp\u003eThe other common complaint seems to be that I made a grammatical error\nin using the adjective “great” to modify a set of development tools\nthat does not include an IDE. To paraphrase Yoda, “IDEs not make one\ngreat.”  Sure, there have been great IDEs. Smalltalk-80 was a great\nIDE. Xerox Interlisp was a great IDE. Most IDEs are not great. Most\nIDEs are \u003cem\u003egoing\u003c/em\u003e to be great, someday. That is, they’re going to be\ngreat, right up to the point where the weight of the implementation\ncollapses the envelope of optimism providing their buoyancy, and they\ncrumple into a heap of random features, slowly and inexorably sinking\nunder their combined mass.\u003c/p\u003e\n\u003cp\u003eIDEs are large, complicated systems that require serious design and\nengineering. They are major cost centers to anyone who is not in the\nbusiness of selling IDEs, and the market for them is small. It should\nnot be surprising that they’re mostly not all that good.\u003c/p\u003e\n\u003cp\u003eWhat’s more, the benefit of even a great IDE is, let’s face it,\nmarginal, as long as the basic tools are comprehensive and good. So\nyeah, I’d like to have a great IDE. I’m not holding my breath. Maybe\nI’ll like the Factor IDE. It looks pretty good. But I’m working in\nScheme, right now.\u003c/p\u003e\n\u003cp\u003eSo, yeah, folks who never want to see a line of C code, you’re not\ngoing to like the tools I’m using. Ditto for anyone who must have his\nprojects managed by a digital valet in an impeccably-tailored suit of\ncolor-coordinated windows. There’s nothing for you guys to see here;\nmove along.\u003c/p\u003e\n\u003cp\u003eFor me, though, Gambit has definitely been great. In the development\nof Delectus, I’ve ditched XCode (but not Interface Builder). In Alpha\n2, 83% of the application code by linecount is Scheme code. The\nremaining 17% is Objective-C. Basically, there’s just enough\nObjective-C to load the nibfiles that define the app’s windows and\nmenus, and hook their event-handlers to the Scheme code that does all\nthe real work.\u003c/p\u003e\n\u003cp\u003eAfter some experimentation, I partitioned the application into the\nfollowing parts:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003eThe back-end: this is pure Scheme code that handles all the data\nstructures, as well as sorting, filtering, and updating. It also\nhandles serializing and deserializing data as CSV and a native\nbinary format, and writing to and reading from disk files.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe UI: this is Objective-C code that loads the nibfiles, sets up\ncalls into the back-end, responds to notifications that originate\nin the back-end, and provides the minor customizations I needed\nto make Apple’s UI elements look just the way I wanted. This part\nis less than 700 lines of code, total.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eThe bridge. This is a small amount of Scheme code, and an even\nsmaller amount of Objective-C code, in a couple of files. It\nprovides simple utilities like a means of converting Scheme\nstrings to NSString objects when the UI needs to fetch a string\nfrom the back-end, without being prodigal about allocation of\nstrings. It provides a mechanism for notifying the Objective-C\ncode from Scheme code, so that the pure-Scheme back-end can post\nerror messages, update requests, and other notifications, without\nany code that is actually aware that an Objective-C component\nexists.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eThe last point is maybe interesting. There is a very small amount of\nmixed Scheme/C code that enables the Objective-C UI to interact\nproductively with the Scheme back-end. I could easily have put that\ncode into the main body of the back-end proper, and at first, that’s\nwhat I did. After all, there’s only a little of it; what’s the harm?\u003c/p\u003e\n\u003cp\u003eBefore long though, I refactored the code to completely separate all\nthat code into a bridge layer. The reason, basically, is that I like\nto have a fairly comprehensive set of unit tests around my major\napplication functionality. With such a set of tests in place, it’s\nvery easy to detect when a change in the code makes an application\nfeature fail, and it’s easy to find what broke it. By factoring all of\nthe mixed code out into its own small layer, I was able to make the\nback-end pure Scheme code, with no reference anywhere to any foreign\nfunctions. That means that I can load the entire back-end into an\ninteractive repl and exercise it. I can run all the unit tests at\nonce, or run particular ones interactively. If one breaks, I can use\nthe interactive debugger to crawl around inside the back-end’s runtime\nand figure out what’s wrong.\u003c/p\u003e\n\u003cp\u003eFurthermore, by factoring things this way, I create a circumscribed\nand coherent API for calling into the back-end and getting data from\nit. That makes it very easy to hook up the Cocoa UI, simply by having\nevent-handlers call the appropriate API functions. UI calls into the\nback-end are almost always one or two lines of code. That means that,\neven when a bug is in the UI rather than the back-end, the way the app\nis factored makes that easy to detect. And since there is so little\nfront-end code, it’s easy to find and fix.\u003c/p\u003e\n\u003cp\u003eObviously, you could structure any Cocoa app similarly, whether the\nback-end is Scheme or C or ML or whatever. What makes Gambit great for\nme, a Lisp hacker by preference, is that over eighty percent of the\ncode I work with is pure Scheme code that I can work with\ninteractively, in the way I prefer.\u003c/p\u003e\n\u003cp\u003eYou could argue that Delectus is really a C program, on the grounds\nthat Gambit-C compiles Scheme to C, before subsequently compiling it\nto native code. That suits me fine, as long as I can continue to write\nmy C code in Scheme.\u003c/p\u003e\n\u003cp\u003eI’ll say it again: Gambit-C has been a great platform for developing a\nCocoa app. I’ll enthusiastically use it again in the future to do the\nsame kind of work. I would recommend it to anyone who wants to use\nLisp to write a Cocoa app, provided that they’re not allergic to C\ncode, and provided that they’re okay with using compilers and editors\nwithout an IDE to command the servants for them.\u003c/p\u003e\n\u003cp\u003eDelectus should be out soon. The gating factor right now is the\nopinion of the testers. When they’re happy with the feature set and\nthe stability of the product, I’ll release it.\u003c/p\u003e\n\u003cp\u003eAfter the release of Delectus, I’ll begin work on a web application\naimed at MMORPG players. Most likely, the server side of that\napplication will be written in Clojure.\u003c/p\u003e\n\u003cp\u003eA little while ago, I promised interested people that they would soon\nbe able to get their hands on my Categories object system. The object\nsystem had to take a back seat to revenue-generating work, but when\nDelectus is out, I’ll be working on a release of Categories. I intend\nto use it in my next product anyway, and so I may as well also package\nit for release to the tiny community of people who are interested in\nsuch things.\u003c/p\u003e\n\u003cp\u003eThe current working prototype of Categories runs on Gambit, and it’s\nlikely that’s the version I’ll clean up and release first. Then I’ll\nport it back to Clojure (which is where I developed the first versions\nof it), and make that available as well. It may be a little while\nbefore I do either; we must now wait on the verdict of my\ntesters. When they say Delectus is done, then I can move forward.\u003c/p\u003e\n\u003cp\u003eI have several other plans in the works, including the resurrection of\nsome old friends. After six years, I still occasionally get fan mail\nabout Alpaca, the text editor. Those few fans may be glad to know that\na new version of Alpaca is on the roadmap. Another old project that\nI’m still sometimes asked about is Bosco, a simple set of tools for\nbuilding a Cocoa application in Clozure Common Lisp. Well, Bosco was\nabsorbed into Clozure Common Lisp a couple of years ago, but there\nstlll seems to be a place under the sun for a small package of files\nthat shows how to build a minimal Cocoa application with the smallest\npossible amount of Lisp code. I have another project called Apis that\ncan serve that purpose, among others. Apis, and other things derived\nfrom it, are also on the roadmap.\u003c/p\u003e\n\u003cp\u003eThere are other things, but they’re even further down the road. For\nnow, I’m still squarely in the midst of Delectus, and loving\nGambit. Turns out it’s still a great platform for developing Cocoa\napps.\u003c/p\u003e\n\n\n\t\t\t\t\u003c/div\u003e",
  "Date": "2009-10-18T00:00:00Z",
  "Author": "mikel evins"
}