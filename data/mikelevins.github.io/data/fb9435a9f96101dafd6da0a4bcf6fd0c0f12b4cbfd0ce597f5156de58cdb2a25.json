{
  "Source": "mikelevins.github.io",
  "Title": "On repl-driven programming",
  "Link": "https://mikelevins.github.io/posts/2020-12-18-repl-driven/",
  "Content": "\u003cdiv class=\"post\"\u003e\n\n\t\t\t\t\t\u003cdiv class=\"post-heading\"\u003e\n\t\t\t\t\t\t\u003ch1\u003eOn repl-driven programming\u003c/h1\u003e\n\t\t\t\t\t\t\u003cspan class=\"post-date\"\u003e\u003ca href=\"https://mikelevins.github.io/posts/2020-12-18-repl-driven/\"\u003e# Dec 18, 2020\u003c/a\u003e\u003c/span\u003e\n\t\t\t\t\t\u003c/div\u003e\n\n\t\t\t\t\t\u003cp\u003eOnce upon a time, someone with the handle “entha_saava” posted this question on \u003ca href=\"https://news.ycombinator.com/item?id=23791152\"\u003eHacker News\u003c/a\u003e:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCan someone knowledgeable explain how are lisp REPLs different from\nPython / Ruby REPLs? What is the differentiating point of REPL\ndriven development?\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe answer is that there is a \u003ca href=\"https://mikelevins.github.io/posts/2020-02-03-programming-as-teaching/\"\u003eparticular kind of programming\u003c/a\u003e\nin which you build a program by \u003cem\u003einteracting\u003c/em\u003e with it as it runs, and\nthere are certain languages and runtimes that are designed from the\nground up to support that kind of programming.\u003c/p\u003e\n\u003cp\u003ePython and Ruby are not examples of such languages.\u003c/p\u003e\n\u003cp\u003eWhy not? That’s the crux of entha_saava’s question, right? What are\nthese \u003cstrong\u003erepl-driven\u003c/strong\u003e programming systems, and what makes them\ndifferent from Python and Ruby and every other language that offers a\nrepl?\u003c/p\u003e\n\u003cp\u003eFor that matter, what’s a repl?\u003c/p\u003e\n\u003cp\u003eThe word \u003cstrong\u003erepl\u003c/strong\u003e is an acronym that stands for \u003cstrong\u003eread-eval-print\nloop\u003c/strong\u003e. The term comes from the history of Lisp. From the start, sixty\nyears ago, the standard way of working with a Lisp has been to start a\nlanguage processor, type expressions at its prompt, and wait for it to\nevaluate the expressions and print their results, before prompting for\nanother expression. Read, eval, print. Loop.\u003c/p\u003e\n\u003cp\u003eNowadays, repls are all the rage. Every language and its brother\noffers a repl. There’s a website, \u003ca href=\"https://repl.it/\"\u003erepl.it\u003c/a\u003e, whose\nentire purpose is to provide all the repls.\u003c/p\u003e\n\u003cp\u003eIt doesn’t actually provide \u003cem\u003eall\u003c/em\u003e the repls, of course. What’s\nparticularly ironic is that it doesn’t provide either of the canonical\nrepl-driven development environments: Common Lisp and Smalltalk.\u003c/p\u003e\n\u003cp\u003eThat brings us back to entha_saava’s question: if Common Lisp and\nSmalltalk are repl-driven environments, and Python and Ruby are not,\nwhat’s the difference? What do Lisp and Smalltalk have that Python and\nRuby don’t?\u003c/p\u003e\n\u003cp\u003eWhat they have is a language and runtime system that are designed from\nthe ground up with the assumption that you’re going to develop\nprograms by starting the language engine and talking to it, teaching\nit how to be your program \u003cem\u003einteractively\u003c/em\u003e, by changing it \u003cem\u003ewhile it\nruns\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eI can hear the objections formulating already. I’ve seen them\nbefore. Yes, every language with a repl can do some things in the\nrepl. Obviously that’s true; if it weren’t, then the repl would be\nentirely useless.\u003c/p\u003e\n\u003cp\u003eBeing able to do \u003cem\u003esome\u003c/em\u003e things in the repl does not make an engine\ninto a repl-driven programming environment. What distinguishes\nold-fashioned Lisp and Smalltalk environments is that you can do\n\u003cem\u003eeverything\u003c/em\u003e in the repl. They place no gratuitous limitations on what\nyou can do; if the language and runtime can do it, then the repl can\ndo it.\u003c/p\u003e\n\u003cp\u003eFor example, you can ask the current version of Clozure Common Lisp to\nrebuild itself from scratch by evaluating the following expression at\nthe repl prompt:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(rebuild-ccl :full t)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eCCL responds by completely rebuilding itself from source.\u003c/p\u003e\n\u003cp\u003eThe point is not that you would want to rebuild CCL this way all the\ntime. The point is that there are no artificial limitations on what\nthe repl can do. The full range of the development system’s\ncapabilities is accessible from the repl.\u003c/p\u003e\n\u003cp\u003eThat’s one of the first things I notice when using newer, lesser\nrepls: I’m always running into things I can’t do from the repl.\u003c/p\u003e\n\u003cp\u003eIt’s not just about freedom from restrictions, though. Proper support\nfor interactive programming means that the language and its runtime\nhave positive features that support changing your program \u003cem\u003ewhile it\nruns\u003c/em\u003e.\u003c/p\u003e\n\u003cp\u003eTry this in your favorite repl:\u003c/p\u003e\n\u003cp\u003eDefine a function, \u003ccode\u003efoo\u003c/code\u003e, that calls some other function, \u003ccode\u003ebar\u003c/code\u003e, that\nis not yet defined. Now call \u003ccode\u003efoo\u003c/code\u003e. What happens?\u003c/p\u003e\n\u003cp\u003eObviously, the call to \u003ccode\u003efoo\u003c/code\u003e breaks, because \u003ccode\u003ebar\u003c/code\u003e is not defined. But\nwhat happens when it breaks? What happens next?\u003c/p\u003e\n\u003cp\u003eIf your favorite repl is Python’s or Ruby’s or any of a few dozen\nother modern repls, the answer is most likely that it prints an error\nmessage and returns to its prompt. In some cases, perhaps it crashes.\u003c/p\u003e\n\u003cp\u003eSo what’s my point, right? What else could it do?\u003c/p\u003e\n\u003cp\u003eThe answer to that question is the “differentiating point” of\nrepl-driven programming. In an old-fashioned Lisp or Smalltalk\nenvironment, the break in \u003ccode\u003efoo\u003c/code\u003e drops you into a \u003cstrong\u003ebreakloop\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eA \u003cstrong\u003ebreakloop\u003c/strong\u003e is a full-featured repl, complete with all of the\ntools of the main repl, but it exists inside the dynamic environment\nof the broken function. From the breakloop you can roam up and down\nthe suspended call stack, examining all variables that are lexically\nvisible from each stack frame. In fact, you can inspect all live data\nin the running program.\u003c/p\u003e\n\u003cp\u003eWhat’s more, you can \u003cem\u003eedit\u003c/em\u003e all live data in the program. If you think\nthat a break was caused by a wrong value in some particular variable\nor field, you can interactively change it and resume the suspended\nfunction. If it now works correctly, then congratulations; you found\nthe problem!\u003c/p\u003e\n\u003cp\u003eMoreover, because the entire language and development system are\navailable, unrestricted, in the repl, you can define the missing\nfunction \u003ccode\u003ebar\u003c/code\u003e, resume \u003ccode\u003efoo\u003c/code\u003e, and get a sensible result.\u003c/p\u003e\n\u003cp\u003eIn fact, there’s a style of programming, well known in Lisp and\nSmalltalk circles, in which you define a toplevel function with calls\nto other functions that don’t yet exist, and then define those\nfunctions as you go in the resulting breakloops. It’s a fast way to\nimplement a procedure when you already know how it should work.\u003c/p\u003e\n\u003cp\u003eIf you’re a user of old-fashioned Lisp or Smalltalk systems then this\nall sounds obvious to you, but that reaction is not common. Surprise\nis much more common, or even suspicion: what’s the catch?\u003c/p\u003e\n\u003cp\u003eThe catch is that the designers of your language system had to think\nthat facility through in the planning stages. You don’t get a decent\nimplementation of it by bolting it on after the fact. Breakloops need\n\u003cem\u003efull\u003c/em\u003e access to the \u003cem\u003eentire\u003c/em\u003e development system, interactively, with\na computation and its call stack suspended in the breakloop’s\nenvironment.\u003c/p\u003e\n\u003cp\u003eLet’s take another example of a facility designed to support\ninteractive programming. Once again, try this in your favorite repl:\u003c/p\u003e\n\u003cp\u003eDefine a datatype. I mean a class, a struct, a record type–whatever\nuser-defined type your favorite language supports. Make some instances\nof it. Write some functions (or methods, or procedures, or whatever)\nto operate on them.\u003c/p\u003e\n\u003cp\u003eNow change the definition of the type. What happens?\u003c/p\u003e\n\u003cp\u003eDoes your language runtime notice that the definition of the type has\nchanged? Does it realize that the existing instances have a new\ndefinition? When something touches one of them, does it automatically\nreinitialize it to conform to the new definition, or, if it doesn’t\nknow how to do that, does it start a breakloop and ask you what to do\nabout it?\u003c/p\u003e\n\u003cp\u003eIf the answer is “yes,” then you’re probably using a Lisp or Smalltalk\nsystem. If the answer is “no,” then you’re missing a crucial element\nof repl-driven development.\u003c/p\u003e\n\u003cp\u003eRemember: the point is to support programming \u003cem\u003einteractively\u003c/em\u003e. You\ndon’t want to have to kill your program and rebuild it from scratch\njust because you changed a definition. That’s silly; adding and\nchanging definitions is most of what you do! If your development\nenvironment is going to support interactive development, then it had\nbetter know how to keep your program running when you change some\ndefinitions.\u003c/p\u003e\n\u003cp\u003eOld-fashioned Lisp and Smalltalk system know how to do that. There are\nalso a few other kinds of systems, mostly older ones, that know how to\ndo it.\u003c/p\u003e\n\u003cp\u003eThese are not eccentric new ideas out of left field. They’ve been\naround for half a century. They contribute materially to productivity\nin interactive development.\u003c/p\u003e\n\u003cp\u003eThey’re what sets \u003cstrong\u003erepl-driven development\u003c/strong\u003e apart from mere\ndevelopment with a repl.\u003c/p\u003e\n\u003cp\u003eNow, not every programmer prefers that kind of development. Some\nprogrammers prefer to think of development as a process of designing,\nplanning, making blueprints, and assembling parts on a\nworkbench. There’s nothing wrong with that. Indeed, a\nmultibillion-dollar international industry has been built upon it.\u003c/p\u003e\n\u003cp\u003eBut if you prefer interactive development, if it’s more natural to\nyou, then it can make you enormously more productive, not to mention\nhappier in your work.\u003c/p\u003e\n\u003cp\u003eInteractive development with a proper repl-driven environment is the\nexception. Most programming is done in other ways.\u003c/p\u003e\n\u003cp\u003eAs a consequence, there are a lot of programmers out there who’ve\nnever even heard of it, who have no idea that it exists. My intuition\nis that some fraction of those programmers would prefer well-supported\ninteractive programming, and would benefit from it, if they just knew\nwhat it was.\u003c/p\u003e\n\u003cp\u003eMaybe if enough programmers are exposed to that style of programming\nthen we’ll begin to see new tools that embrace it.\u003c/p\u003e\n\n\n\t\t\t\t\u003c/div\u003e",
  "Date": "2020-12-18T00:00:00Z",
  "Author": "mikel evins"
}