{
  "Source": "morningspace",
  "Title": "Kubernetes网络篇——自己动手写CNI插件(上)",
  "Link": "https://morningspace.github.io/tech/k8s-net-cni-coding-shell/",
  "Content": "\u003cdiv class=\"page__inner-wrap\"\u003e\n      \n\n      \u003csection class=\"page__content e-content\" itemprop=\"text\"\u003e\n        \n          \u003caside class=\"sidebar__right sticky\"\u003e\n            \u003cnav class=\"toc\"\u003e\n              \u003cheader\u003e\u003ch4 class=\"nav__title\"\u003e\u003ci class=\"fas fa-file-alt\"\u003e\u003c/i\u003e 在本页上\u003c/h4\u003e\u003c/header\u003e\n              \u003cul class=\"toc__menu\"\u003e\u003cli\u003e\u003ca href=\"#cni插件编程\"\u003eCNI插件编程\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#第一个插件logger\"\u003e第一个插件：logger\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#代码实现\"\u003e代码实现\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#代码运行\"\u003e代码运行\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\n\n            \u003c/nav\u003e\n          \u003c/aside\u003e\n        \n        \u003cp\u003e注：\n本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"\u003e知识共享署名-相同方式共享 4.0 国际许可协议\u003c/a\u003e进行许可。\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"\u003e\u003cimg alt=\"知识共享许可协议\" style=\"border-width:0\" src=\"https://i.creativecommons.org/l/by-sa/4.0/80x15.png\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e有没有想过自己写一个CNI插件呢？也许大多数时候我们都没必要自己开发插件。不过，出于学习的目的，或者为了排查错误，也许你会读到别人写的插件。这个时候，如果事先对CNI插件编程有一定了解，那就会事半功倍。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/cni-shell.png\" alt=\"\" class=\"align-center\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"cni插件编程\"\u003eCNI插件编程\u003c/h2\u003e\n\n\u003cp\u003e如果看过这一系列的前面两篇文章，大家一定知道，CNI插件和遵循CNI规范的容器系统之间是通过配置文件加环境变量，并借助标准输入输出设备来进行通信的，每个CNI插件都是一个标准的可执行文件。正是因为这样的设计，决定了CNI插件可以用任何编程语言来实现，只要按照CNI的标准接口，我们的插件就可以适用于任何支持CNI的容器系统。\u003c/p\u003e\n\n\u003cp\u003e本文，我们将使用shell语言来实现一个非常简单的CNI插件，用日志输出的方式来演示CNI所提供的命令和容器生命周期之间的关系。在下一篇文章里，我们将使用go语言，结合CNI项目提供的go工具库，开发一个接近真实的更复杂一些的插件。它和CNI的标准插件bridge类似，会为我们在宿主机上创建一个bridge，并把容器连接到bridge上。\u003c/p\u003e\n\n\u003ch2 id=\"第一个插件logger\"\u003e第一个插件：logger\u003c/h2\u003e\n\n\u003cp\u003e接下来，我们就用shell语言来开发一个非常简单的CNI插件：logger。它并不对网络配置做真正的修改，而只是在容器从启动到停止的过程中，把容器系统传给它的信息输出到终端显示器。\u003c/p\u003e\n\n\u003ch2 id=\"代码实现\"\u003e代码实现\u003c/h2\u003e\n\n\u003cp\u003e下面一起来看一下代码：\u003c/p\u003e\n\n\u003cdiv class=\"language-text highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e#!/bin/bash                                 ①\n\nlog () {\n  \u0026gt;\u0026amp;2 echo \u0026#34;$1\u0026#34;                             ②\n}\n\nlog \u0026#34;Command: $CNI_COMMAND\u0026#34;                 ③\nlog \u0026#34;Container Id: $CNI_CONTAINERID\u0026#34;\nlog \u0026#34;Path to Network Namespace: $CNI_NETNS\u0026#34;\nlog \u0026#34;Network Interface: $CNI_IFNAME\u0026#34;\nlog \u0026#34;Path to CNI Plugins: $CNI_PATH\u0026#34;\nlog \u0026#34;Network Configuration:\u0026#34;                ④\nwhile IFS=\u0026#39;\u0026#39; read line\ndo\n  log \u0026#34;$line\u0026#34;\ndone \u0026lt; /dev/stdin                           ⑤\n\nif [[ $CNI_COMMAND == \u0026#34;ADD\u0026#34; ]]; then\n  echo \u0026#34;{}\u0026#34;                                 ⑥\nfi\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，用shell写一个最简单的CNI插件不需要几行代码。下面我们就来解释一下这段代码：\u003c/p\u003e\n\n\u003cp\u003e行①：这里指明了，我们所采用的shell语言为bash shell。\u003c/p\u003e\n\n\u003cp\u003e行②：这是我们用来向终端显示器输出日志的逻辑。由于CNI规范定义了，容器系统是通过标准输入(stdin)和输出设备(stdout)和插件进行交互的，因此我们通过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e\u0026gt;\u0026amp;2\u003c/code\u003e，把日志输出重定向到了标准错误输出设备(stderr)。这里的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e2\u003c/code\u003e对应的就是stderr的设备号（stdout的设备号为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1\u003c/code\u003e）。这样，我们的日志输出结果就不会干扰容器系统和插件的正常通信了。\u003c/p\u003e\n\n\u003cp\u003e行③：从这一行开始，我们陆续把一系列由容器系统通过环境变量传给插件的信息输出成了日志，比如：执行的CNI命令，容器Id，network namespace路径等。\u003c/p\u003e\n\n\u003cp\u003e行④：从这一行开始，我们输出的是通过行⑤的标准输入设备(stdin)传入插件的JSON格式的网络配置文件。代码通过一个循环，逐行读取配置文件，并输出成日志。\u003c/p\u003e\n\n\u003cp\u003e行⑥：可以看到，我们在这一行直接向标准输出设备(stdout)打印了一对空的大括号。这主要是因为，CNI规范里规定了，对于ADD操作，要求插件在返回之前把执行结果以JSON格式打印到标准输出设备。这里，我们为了演示，只是简单的输出了一个“{}”。\u003c/p\u003e\n\n\u003ch2 id=\"代码运行\"\u003e代码运行\u003c/h2\u003e\n\n\u003cp\u003e接下来，我们用rkt作为容器运行时环境来验证我们logger插件。关于在rkt里运行CNI插件的详细情况，大家可以参考\u003ca href=\"/tech/k8s-net-cni-docker-rkt/\"\u003eKubernetes网络篇——将CNI用于容\u003c/a\u003e一文的后半部分。\u003c/p\u003e\n\n\u003cp\u003e根据rkt的文档，它会在特定路径下搜索CNI插件的可执行文件，比如：\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/usr/lib/rkt/plugins/net\u003c/code\u003e，\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/rkt/net.d\u003c/code\u003e，后者也是rkt读取网络配置文件的路径。我们把上面的代码以文件形式保存到\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/rkt/net.d\u003c/code\u003e目录下，取名为logger，并为其赋予可执行权限：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003echmod\u003c/span\u003e +x ./logger\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后再在同一目录下创建网络配置文件，取名\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elab-test-net-1.conf\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecat \u003c/span\u003elab-test-net-1.conf\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"s2\"\u003e\u0026#34;cniVersion\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;0.4.0\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;lab-test-net-1\u0026#34;\u003c/span\u003e,   ①\n  \u003cspan class=\"s2\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;logger\u0026#34;\u003c/span\u003e            ②\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里：\u003c/p\u003e\n\n\u003cp\u003e行①指定了我们所定义的网络名称。当我们用rkt命令启动容器时，务必要保证\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--net\u003c/code\u003e参数所指定的网络名称和这里定义的名称是保持一致的，否则rkt会报错；\u003c/p\u003e\n\n\u003cp\u003e行②指定了我们要调用的CNI插件的名称，它和我们的插件可执行文件名是保持一致的，rkt会根据这里的配置，在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/rkt/net.d\u003c/code\u003e目录下寻找并执行我们编写的插件；\u003c/p\u003e\n\n\u003cp\u003e现在，我们来执行下面的命令，启动一个busybox容器：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003erkt run \u003cspan class=\"nt\"\u003e--insecure-options\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eimage \u003cspan class=\"nt\"\u003e--interactive\u003c/span\u003e \u003cspan class=\"nt\"\u003e--net\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003elab-test-net-1 docker://busybox\nrun: disabling overlay support: \u003cspan class=\"s2\"\u003e\u0026#34;overlay entry not present in /proc/filesystems\u0026#34;\u003c/span\u003e\nCommand: ADD\nContainer Id: 1ebcb360-bcf6-4c3f-b38e-a8826eac7f9b\nPath to Network Namespace: /var/run/netns/cni-d59164ee-3cc1-0a62-a4ec-b486b3028dae\nNetwork Interface: eth0\nPath to CNI Plugins: /etc/rkt/net.d:/usr/lib/rkt/plugins/net:stage1/rootfs/usr/lib/rkt/plugins/net\nNetwork Configuration:\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"s2\"\u003e\u0026#34;cniVersion\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;0.4.0\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;lab-test-net-1\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;logger\u0026#34;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从输出结果中可以看到，我们的logger插件被成功调用了。输出的Command值显示，rkt在启动容器的时候会调用CNI插件的ADD命令。同时，它还会把刚刚创建的busybox容器的Id，对应network namespace的路径，以及默认的网络接口名称(eth0)等信息，也都传进来。最后是从标准输入设备读到的网络配置信息，和我们之前定义的完全一致。\u003c/p\u003e\n\n\u003cp\u003e如果这个时候输入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip addr show\u003c/code\u003e查看网络接口：\u003c/p\u003e\n\u003cdiv class=\"language-plaintext highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e/ # ip addr sh\n1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue \n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到只有一个默认的loopback网络接口，并没有eth0，那是因为我们的脚本只是简单地显示了日志，并没有实际创建网络接口。当然，如果你有兴趣的话，也可以对这个插件进行改造，让它具备更加丰富的功能。比如：利用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eip link add\u003c/code\u003e命令为容器创建真正的网络接口。\u003c/p\u003e\n\n\u003cp\u003e接下来，我们输入\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCtrl + ]]]\u003c/code\u003e从容器退回到宿主机。然后执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003erkt rm\u003c/code\u003e并传入容器Id，把容器删除掉。这里的容器Id，可以从前面执行ADD命令时的输出结果里找到。并且，我们只要从完整的Id值里取前面几位就可以了：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003erkt \u003cspan class=\"nb\"\u003erm \u003c/span\u003e1ebcb360\nCommand: DEL\nContainer Id: 1ebcb360-bcf6-4c3f-b38e-a8826eac7f9b\nPath to Network Namespace: /var/run/netns/cni-d59164ee-3cc1-0a62-a4ec-b486b3028dae\nNetwork Interface: eth0\nPath to CNI Plugins: /etc/rkt/net.d:/usr/lib/rkt/plugins/net:stage1/rootfs/usr/lib/rkt/plugins/net\nNetwork Configuration:\n\u003cspan class=\"o\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"s2\"\u003e\u0026#34;cniVersion\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;0.4.0\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;lab-test-net-1\u0026#34;\u003c/span\u003e,\n  \u003cspan class=\"s2\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan class=\"s2\"\u003e\u0026#34;logger\u0026#34;\u003c/span\u003e\n\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003cspan class=\"s2\"\u003e\u0026#34;1ebcb360-bcf6-4c3f-b38e-a8826eac7f9b\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e可以看到，我们的logger插件再一次被调用了，这次执行的是DEL命令。\u003c/p\u003e\n\n        \n      \u003c/section\u003e\n\n      \u003cfooter class=\"page__meta\"\u003e\n        \n        \n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-tags\" aria-hidden=\"true\"\u003e\u003c/i\u003e 标签: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/tags/#dummies\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#dummies-kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies_kubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003ekubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#lab\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003elab\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n\n\n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-folder-open\" aria-hidden=\"true\"\u003e\u003c/i\u003e 分类: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/categories/#tech\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003etech\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n        \n\n  \u003cp class=\"page__date\"\u003e\u003cstrong\u003e\u003ci class=\"fas fa-fw fa-calendar-alt\" aria-hidden=\"true\"\u003e\u003c/i\u003e 更新时间:\u003c/strong\u003e \u003ctime class=\"dt-published\" datetime=\"2021-03-28T00:00:00+08:00\"\u003eMarch 28, 2021\u003c/time\u003e\u003c/p\u003e\n\n      \u003c/footer\u003e\n\n      \u003csection class=\"page__share\"\u003e\n  \n    \u003ch4 class=\"page__share-title\"\u003e分享\u003c/h4\u003e\n  \n\n  \u003ca href=\"https://twitter.com/intent/tweet?text=Kubernetes%E7%BD%91%E7%BB%9C%E7%AF%87%E2%80%94%E2%80%94%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%86%99CNI%E6%8F%92%E4%BB%B6%28%E4%B8%8A%29%20https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-cni-coding-shell%2F\" class=\"btn btn--twitter\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Twitter\"\u003e\u003ci class=\"fab fa-fw fa-twitter\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Twitter\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-cni-coding-shell%2F\" class=\"btn btn--facebook\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Facebook\"\u003e\u003ci class=\"fab fa-fw fa-facebook\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Facebook\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.linkedin.com/shareArticle?mini=true\u0026amp;url=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-cni-coding-shell%2F\" class=\"btn btn--linkedin\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 LinkedIn\"\u003e\u003ci class=\"fab fa-fw fa-linkedin\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e LinkedIn\u003c/span\u003e\u003c/a\u003e\n\u003c/section\u003e\n\n\n      \n  \u003cnav class=\"pagination\"\u003e\n    \n      \u003ca href=\"/tech/k8s-net-cni-docker-rkt/\" class=\"pagination--pager\" title=\"Kubernetes网络篇——将CNI用于容器\n\"\u003e向前\u003c/a\u003e\n    \n    \n      \u003ca href=\"/tech/k8s-net-cni-coding-go/\" class=\"pagination--pager\" title=\"Kubernetes网络篇——自己动手写CNI插件(下)\n\"\u003e向后\u003c/a\u003e\n    \n  \u003c/nav\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-03-28T00:00:00+08:00",
  "Author": "MornigSpace"
}