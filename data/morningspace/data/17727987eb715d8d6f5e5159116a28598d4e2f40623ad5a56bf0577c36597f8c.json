{
  "Source": "morningspace",
  "Title": "Launch multi-node Kubernetes cluster locally in one minute, and more…",
  "Link": "https://morningspace.github.io/tech/k8s-run/",
  "Content": "\u003cdiv class=\"page__inner-wrap\"\u003e\n      \n\n      \u003csection class=\"page__content e-content\" itemprop=\"text\"\u003e\n        \n          \u003caside class=\"sidebar__right sticky\"\u003e\n            \u003cnav class=\"toc\"\u003e\n              \u003cheader\u003e\u003ch4 class=\"nav__title\"\u003e\u003ci class=\"fas fa-file-alt\"\u003e\u003c/i\u003e 在本页上\u003c/h4\u003e\u003c/header\u003e\n              \u003cul class=\"toc__menu\"\u003e\u003cli\u003e\u003ca href=\"#motivation\"\u003eMotivation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#kubeadm--dind\"\u003ekubeadm + DIND\u003c/a\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#similar-project\"\u003eSimilar Project\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#basic-usage\"\u003eBasic Usage\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#speed-up\"\u003eSpeed Up!\u003c/a\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#using-private-registry\"\u003eUsing Private Registry\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#run-offline\"\u003eRun Offline\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#skip-dashboard\"\u003eSkip Dashboard\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#more-usages\"\u003eMore Usages\u003c/a\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#latest-dashboard\"\u003eLatest Dashboard\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#helm-installation\"\u003eHelm Installation\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#use-different-versions\"\u003eUse Different Versions\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#launch-from-source\"\u003eLaunch from Source\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\n\n            \u003c/nav\u003e\n          \u003c/aside\u003e\n        \n        \u003cblockquote\u003e\n  \u003cp\u003eNote: For those who are interested in the video tutorial corresponding to this post, you can find them all on \u003ca href=\"https://www.youtube.com/watch?v=0uVdF3Inv48\u0026amp;list=PLVQM6jLkNkfqHgd0aX7TnjioOiQrqsXIa\"\u003eYouTube\u003c/a\u003e, or \u003ca href=\"https://v.youku.com/v_show/id_XNDI2Mzk1NDcyMA==.html?f=52221532\"\u003eYouKu\u003c/a\u003e.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"motivation\"\u003eMotivation\u003c/h2\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/kubernetes.png\" alt=\"\" class=\"align-center\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTo quickly deploy and launch Kubernetes cluster on your local machine is very useful in variant scenarios such as local testing or self-learning on Kubernetes deployment, and even the development of Kubernetes itself.\u003c/p\u003e\n\n\u003cp\u003eThere are different ways to deploy Kubernetes cluster locally. For example, \u003ca href=\"https://github.com/kubernetes/minikube\"\u003eMinikube\u003c/a\u003e implements a local Kubernetes cluster on macOS, Linux, and Windows. Docker Desktop also has integrated Kubernetes on \u003ca href=\"https://docs.docker.com/docker-for-mac/kubernetes/\"\u003eMac\u003c/a\u003e and \u003ca href=\"https://docs.docker.com/docker-for-windows/kubernetes/\"\u003eWindows\u003c/a\u003e since version 18.06. This makes it really convenient. However, they currently only support single node cluster. Single node cluster has its own limitation. For example, it cannot work with scheduler-related tasks or run tests that require multiple nodes.\u003c/p\u003e\n\n\u003cp\u003eAnother disadvantage for some of these approaches is that you may not be able to specify a particular version of Kubernetes very easy. For example, my Docker Desktop uses Kubernetes v1.10.3. If you want to try some new features that are only available in newer or the latest version, you may have to seek for other solutions.\u003c/p\u003e\n\n\u003cp\u003eIn this post, I will introduce a great tool, \u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster\"\u003ekubeadm-dind-cluster\u003c/a\u003e, that can deploy multi-node cluster on a single machine based on \u003ca href=\"https://kubernetes.io/docs/setup/independent/install-kubeadm/\"\u003ekubeadm\u003c/a\u003e and \u003ca href=\"https://github.com/jpetazzo/dind\"\u003eDIND(Docker in Docker)\u003c/a\u003e. It can not only switch among different Kubernetes versions easily, but can also use the latest snapshot by building from source.\u003c/p\u003e\n\n\u003cp\u003eMoreover, to optimize the use of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e and make the bootstrap of Kubernetes cluster more efficient, I created a demo project, \u003ca href=\"https://github.com/morningspace/lab-k8s-playground\"\u003elab-k8s-playground\u003c/a\u003e. It is based on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e with some additional optimizations that I will describe later in this post. At the end of this post, you will see that we can launch a three-node Kubernetes cluster in less than one minute even without network connection!\u003c/p\u003e\n\n\u003ch2 id=\"kubeadm--dind\"\u003ekubeadm + DIND\u003c/h2\u003e\n\n\u003cp\u003eInstead of using bare metal or virtual machine, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e uses Docker container to run cluster node. With that, all nodes can be deployed and run as containers on a single machine, typically your local machine. Application containers that previously run on Kubernetes nodes will in turn run in containerized nodes. That’s where DIND comes into play as it allows one Docker container to run in another Docker container!\u003c/p\u003e\n\n\u003cp\u003eThis is not only valuable for local development and testing, but also for CI (Continuous Integration), because in many cases mordern CI environment is containerized itself too. To run application container in CI container, it requires DIND. When use \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e, it can be run in CI environment without having issues with such kind of nested virtualization.\u003c/p\u003e\n\n\u003ch3 id=\"similar-project\"\u003eSimilar Project\u003c/h3\u003e\n\n\u003cp\u003eA similar project, \u003ca href=\"https://github.com/marun/nkube\"\u003enkube\u003c/a\u003e, starts Kubernetes clusters in Kubernetes (so-called nested Kubernetes). Essentially, it is also based on DIND, but requires a Kubernetes cluster (usually Minikube) to be run prior, then deploy the target Kubernetes on top of it. It is not very straightforward.\u003c/p\u003e\n\n\u003cp\u003eSo, if you’re feeling yourself adventurous like me, you may give \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e a try!\u003c/p\u003e\n\n\u003ch2 id=\"basic-usage\"\u003eBasic Usage\u003c/h2\u003e\n\n\u003cp\u003eIt is easy to launch Kubernetes using \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e. Just follow the \u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster\"\u003eREADME\u003c/a\u003e to download the pre-configured script \u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster/releases\"\u003ehere\u003c/a\u003e, e.g. the latest version at the time of this writing is \u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster/releases/download/v0.2.0/dind-cluster-v1.14.sh\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edind-cluster-v1.14.sh\u003c/code\u003e\u003c/a\u003e. It maps to Kubernetes v1.14. Then run below command:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./dind-cluster-v1.14.sh up\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eIt will take a bit longer for the first launch because it requires to pull images and download dependencies from public network. Any other launch after then will be much faster, because it will create a snapshot locally after its first run so that can restore from snapshot quickly anytime later. When the launch is finished, by default it will bring up a three-node cluster, one master and two workers. This is configurable.\u003c/p\u003e\n\n\u003cp\u003eIf you want to take down the cluster for some reason, use \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edown\u003c/code\u003e command and this will keep the snapshot, so that can restore from it next time when you run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eup\u003c/code\u003e command:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./dind-cluster-v1.14.sh down\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eFor a clean launch without using snapshot, run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclean\u003c/code\u003e instead of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edown\u003c/code\u003e. This will remove the snapshot.\u003c/p\u003e\n\n\u003ch2 id=\"speed-up\"\u003eSpeed Up!\u003c/h2\u003e\n\n\u003ch3 id=\"using-private-registry\"\u003eUsing Private Registry\u003c/h3\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/docker-registry.png\" alt=\"\" class=\"align-center\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTo restore from snapshot makes Kubernetes launch faster. It can be much faster for clean start if we use private Docker registries. As I mentioned earlier, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e pulls images from public Docker registries such as \u003ca href=\"https://cloud.google.com/container-registry\"\u003eGoogle Container Registry\u003c/a\u003e and \u003ca href=\"https://hub.docker.com\"\u003eDocker Hub\u003c/a\u003e during the launch. The below list summarizes all required images from \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek8s.gcr.io\u003c/code\u003e in order to setup a Kubernetes cluster:\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth style=\"text-align: left\"\u003eImages\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003ek8s.gcr.io/pause\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003ek8s.gcr.io/etcd\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003ek8s.gcr.io/coredns\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd style=\"text-align: left\"\u003ek8s.gcr.io/kubernetes-dashboard-amd64\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eIf we copy these images to a private Docker registry that is co-located with the Kubernetes cluster on the same machine or in the same LAN, and have the cluster pull images from there, it will make the bootstrap dramatically faster!\u003c/p\u003e\n\n\u003cp\u003eThis has been added into \u003ca href=\"https://github.com/morningspace/lab-k8s-playground\"\u003elab-k8s-playground\u003c/a\u003e, where you can find all private Docker registries configured in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edocker-compose.yml\u003c/code\u003e including \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ek8s.gcr.io\u003c/code\u003e. Each registry itself is also a container that can be launched by Docker on the same machine where our Kubernetes cluster runs. All registries have a shared volume \u003ccode class=\"language-plaintext highlighter-rouge\"\u003evol-registries.io\u003c/code\u003e to store images, as well as a shared bridge network \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enet-registries\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eFor those who are interested in how to import upstream images from public Docker registries to a local private one, please check my other two posts: \u003ca href=\"/tech/reg-cli-tutorial-1/\"\u003eDocker Registry CLI Tutorial - Basic Use\u003c/a\u003e and \u003ca href=\"/tech/reg-cli-tutorial-2/\"\u003eDocker Registry CLI Tutorial - More Use\u003c/a\u003e. After the private registries are populated, we can launch them by simply running below command:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edocker-compose up \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThen we can run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edind-cluster-wrapper.sh\u003c/code\u003e in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elab-k8s-playground\u003c/code\u003e to launch the Kubernetes cluster. The shell script is actually a simple wrapper of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edind-cluster-vx.xx.sh\u003c/code\u003e. It downloads specific version of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edind-cluster-vx.xx.sh\u003c/code\u003e from GitHub repository to the current folder on your local machine if it is not existed. You can specify \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_K8S_VERSION\u003c/code\u003e as the Kubernetes version and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_COMMIT\u003c/code\u003e as the corresponding Git commit id, or use the latest version by default.\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eNote: The \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e Docker image required to launch the cluster is tagged by both \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_K8S_VERSION\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_COMMIT\u003c/code\u003e. It is because there could be multiple tags for a specific Kubernetes version. You can find all tags with there commit ids \u003ca href=\"https://hub.docker.com/r/mirantis/kubeadm-dind-cluster/tags\"\u003ehere\u003c/a\u003e, then pick up one as needed.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003eSince it’s just a wrapper, you can use the same set of commands as you do when run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edind-cluster-vx.xx.sh\u003c/code\u003e, e.g. \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eup\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edown\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eclean\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eBefore run the shell script, we need to configure \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e to recognize the network shared by the Docker registries so that \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e can pull images from there. Also, if the registries are not TLS/SSL enabled, we need to let \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e know. These can be done by exporting the below two environment variables:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eDIND_CUSTOM_NETWORK\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003enet-registry\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eDIND_INSECURE_REGISTRIES\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;[\u0026#34;k8s.gcr.io\u0026#34;, \u0026#34;gcr.io\u0026#34;]\u0026#39;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"run-offline\"\u003eRun Offline\u003c/h3\u003e\n\n\u003cp\u003eSince we now use private registries to pull images, and it runs on the same machine. We can even cut off the network connection during the cluster launch! The only thing you need to do prior that is to set the environment variable \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_SKIP_PULL\u003c/code\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eDIND_SKIP_PULL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThe \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e image is pulled from Docker Hub. But it doesn’t have to be pulled all the time if we have it cached at local after first launch. This flag tells the shell script not to connect to Docker Hub to detect and download the image. With that, you can cut off your network connection, and see the bootstrap still runs perfect!\u003c/p\u003e\n\n\u003ch3 id=\"skip-dashboard\"\u003eSkip Dashboard\u003c/h3\u003e\n\n\u003cp\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e deploys \u003ca href=\"https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/\"\u003eKubernetes Dashboard\u003c/a\u003e by default. In some cases, this is not necessary. For example, we don’t need Web UI if we just focus on command-line interface \u003ca href=\"https://kubernetes.io/docs/reference/kubectl/\"\u003ekubectl\u003c/a\u003e. In such case, to skip Dashboard deployment during the launch will make the bootstrap even faster! This is also supported by specifying environment variable \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSKIP_DASHBOARD\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eSKIP_DASHBOARD\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e1\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eWith all the optimizations above, a launch that restores from snapshot only takes 40+ seconds on my local machine! A clean start that pulls images from private registries and skips Dashboard deployment only takes 2 mins and a half! And, all can happen without network connection! That is amazing!\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"more-usages\"\u003eMore Usages\u003c/h2\u003e\n\n\u003cp\u003eThere are some other usages that you may be interested.\u003c/p\u003e\n\n\u003ch3 id=\"latest-dashboard\"\u003eLatest Dashboard\u003c/h3\u003e\n\n\u003cp\u003eSometimes we may need Dashboard. By default, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e deploys Dashboard v1.6 which is an old version. To use newer or the latest version, you can set the download URL for the Dashboard deployment YAML using environment variable \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDASHBOARD_URL\u003c/code\u003e.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eDASHBOARD_URL\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended/kubernetes-dashboard.yaml\u0026#34;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThere’s one thing to note: since version 1.7, Kubernetes Dashboard enforces its security and can only be accessed over HTTPS by default. The access URL will be printed to the console at last when the cluster launch is finished. Make sure to pick up the right URL based on which version that you deploy and whether or not HTTPs is enabled. Here are sample URLs:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eIf 1.6:  http://127.0.0.1:33000/api/v1/namespaces/kube-system/services/http:kubernetes-dashboard:/proxy\u003c/li\u003e\n  \u003cli\u003eIf 1.10 and HTTPs enabled: http://127.0.0.1:33000/api/v1/namespaces/kube-system/services/https:kubernetes-dashboard:/proxy\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"helm-installation\"\u003eHelm Installation\u003c/h3\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/helm.png\" alt=\"\" class=\"align-center\"/\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://helm.sh/\"\u003eHelm\u003c/a\u003e is another great tool that people frequently use to deploy applications into Kubernetes cluster. I’m not going to describe how to install it here. You can find all the installation details \u003ca href=\"https://helm.sh/docs/using_helm/#installing-helm\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ehelm\u003c/code\u003e CLI is installed, after \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e brings up the cluster, you can run below command to install \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eTiller\u003c/code\u003e, the server portion of Helm, into your cluster:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ehelm init\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThen run below command to verify the installation. You will see the Server version information after Tiller is installed:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ehelm version\nClient: \u0026amp;version.Version\u003cspan class=\"o\"\u003e{\u003c/span\u003eSemVer:\u003cspan class=\"s2\"\u003e\u0026#34;v2.12.1\u0026#34;\u003c/span\u003e, GitCommit:\u003cspan class=\"s2\"\u003e\u0026#34;02a47c7249b1fc6d8fd3b94e6b4babf9d818144e\u0026#34;\u003c/span\u003e, GitTreeState:\u003cspan class=\"s2\"\u003e\u0026#34;clean\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\nServer: \u0026amp;version.Version\u003cspan class=\"o\"\u003e{\u003c/span\u003eSemVer:\u003cspan class=\"s2\"\u003e\u0026#34;v2.12.1\u0026#34;\u003c/span\u003e, GitCommit:\u003cspan class=\"s2\"\u003e\u0026#34;02a47c7249b1fc6d8fd3b94e6b4babf9d818144e\u0026#34;\u003c/span\u003e, GitTreeState:\u003cspan class=\"s2\"\u003e\u0026#34;clean\u0026#34;\u003c/span\u003e\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eFinally, don’t forget to create a snapshot by running \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esnapshot\u003c/code\u003e command:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e./dind-cluster-wrapper.sh snapshot\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eSo, next time when you bring up the cluster by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e, you will not have to reinstall it.\u003c/p\u003e\n\n\u003ch3 id=\"use-different-versions\"\u003eUse Different Versions\u003c/h3\u003e\n\n\u003cp\u003eAs I mentioned earlier, we can choose which Kubernetes version we use to launch. This is done by setting the environment variable \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDIND_K8S_VERSION\u003c/code\u003e, e.g. this is going to launch Kubernetes v1.12:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ DIND_K8S_VERSION\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ev1.12 ./dind-cluster-wrapper.sh up\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"launch-from-source\"\u003eLaunch from Source\u003c/h3\u003e\n\n\u003cp\u003eWe can even run the latest snapshot of Kubernetes by building from source. This is natively supported by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubeadm-dind-cluster\u003c/code\u003e and inherited by \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elab-k8s-playground\u003c/code\u003e. You just need to git clone Kubernetes source, set \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBUILD_KUBEADM\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBUILD_HYPERKUBE\u003c/code\u003e to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ey\u003c/code\u003e:\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eBUILD_KUBEADM\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003eexport \u003c/span\u003e\u003cspan class=\"nv\"\u003eBUILD_HYPERKUBE\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ey\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThen run the wrapper from the root folder of Kubernetes source code.\u003c/p\u003e\n\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003ecd \u003c/span\u003ekubernetes\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e../lab-k8s-playground/dind-cluster-wrapper.sh up\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThe first run can be slow because it needs to build the base image and Kubernetes binaries. But subsequent runs are much faster.\u003c/p\u003e\n\n\u003cp\u003e(The end)\u003c/p\u003e\n\n\u003chr/\u003e\n\u003cp\u003e\u003cem\u003eHave fun!\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eMorningSpace Lab\u003c/em\u003e\u003c/p\u003e\n\n        \n      \u003c/section\u003e\n\n      \u003cfooter class=\"page__meta\"\u003e\n        \n        \n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-tags\" aria-hidden=\"true\"\u003e\u003c/i\u003e 标签: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/tags/#dummies\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#dummies-kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies_kubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003ekubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#lab\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003elab\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n\n\n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-folder-open\" aria-hidden=\"true\"\u003e\u003c/i\u003e 分类: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/categories/#tech\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003etech\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n        \n\n  \u003cp class=\"page__date\"\u003e\u003cstrong\u003e\u003ci class=\"fas fa-fw fa-calendar-alt\" aria-hidden=\"true\"\u003e\u003c/i\u003e 更新时间:\u003c/strong\u003e \u003ctime class=\"dt-published\" datetime=\"2019-06-29T00:00:00+08:00\"\u003eJune 29, 2019\u003c/time\u003e\u003c/p\u003e\n\n      \u003c/footer\u003e\n\n      \u003csection class=\"page__share\"\u003e\n  \n    \u003ch4 class=\"page__share-title\"\u003e分享\u003c/h4\u003e\n  \n\n  \u003ca href=\"https://twitter.com/intent/tweet?text=Launch+multi-node+Kubernetes+cluster+locally+in+one+minute%2C+and+more...%20https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-run%2F\" class=\"btn btn--twitter\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Twitter\"\u003e\u003ci class=\"fab fa-fw fa-twitter\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Twitter\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-run%2F\" class=\"btn btn--facebook\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Facebook\"\u003e\u003ci class=\"fab fa-fw fa-facebook\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Facebook\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.linkedin.com/shareArticle?mini=true\u0026amp;url=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-run%2F\" class=\"btn btn--linkedin\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 LinkedIn\"\u003e\u003ci class=\"fab fa-fw fa-linkedin\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e LinkedIn\u003c/span\u003e\u003c/a\u003e\n\u003c/section\u003e\n\n\n      \n  \u003cnav class=\"pagination\"\u003e\n    \n      \u003ca href=\"/misc/gallery/morningspace-gallery/\" class=\"pagination--pager\" title=\"晴耕影廊栏目正式上线\n\"\u003e向前\u003c/a\u003e\n    \n    \n      \u003ca href=\"/tech/lab/intro-kubeadm-dind-cluster/\" class=\"pagination--pager\" title=\"极速搭建Kubernetes集群的新方案！\n\"\u003e向后\u003c/a\u003e\n    \n  \u003c/nav\u003e\n\n    \u003c/div\u003e",
  "Date": "2019-06-29T00:00:00+08:00",
  "Author": "MornigSpace"
}