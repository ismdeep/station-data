{
  "Source": "morningspace",
  "Title": "Kubernetes网络篇——Service网络(上)",
  "Link": "https://morningspace.github.io/tech/k8s-net-service-1/",
  "Content": "\u003cdiv class=\"page__inner-wrap\"\u003e\n      \n\n      \u003csection class=\"page__content e-content\" itemprop=\"text\"\u003e\n        \n          \u003caside class=\"sidebar__right sticky\"\u003e\n            \u003cnav class=\"toc\"\u003e\n              \u003cheader\u003e\u003ch4 class=\"nav__title\"\u003e\u003ci class=\"fas fa-file-alt\"\u003e\u003c/i\u003e 在本页上\u003c/h4\u003e\u003c/header\u003e\n              \u003cul class=\"toc__menu\"\u003e\u003cli\u003e\u003ca href=\"#pod和service\"\u003ePod和Service\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#定义service\"\u003e定义Service\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#从节点访问\"\u003e从节点访问\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#从pod访问\"\u003e从Pod访问\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#通过dns访问\"\u003e通过DNS访问\u003c/a\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"#kube-dns\"\u003ekube-dns\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#resolvconf\"\u003eresolv.conf\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#使用nslookup\"\u003e使用nslookup\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\n\n            \u003c/nav\u003e\n          \u003c/aside\u003e\n        \n        \u003cp\u003e注：\n本文采用\u003ca rel=\"license\" href=\"http://creativecommons.org/licenses/by-sa/4.0/\"\u003e知识共享署名-相同方式共享 4.0 国际许可协议\u003c/a\u003e进行许可。\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003e作为Kubernetes最基本的执行单元，Pod是Kubernetes网络的基础。但它也是有局限的，我们访问Pod用的是IP，当Pod出问题，或因重启而发生IP地址变化时，原来的IP就失效了，这时就需要Service了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/service-1.png\" alt=\"\" class=\"align-center\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"pod和service\"\u003ePod和Service\u003c/h2\u003e\n\n\u003cp\u003e在\u003ca href=\"/tech/k8s-net-pod-1/\"\u003eKubernetes网络篇——Pod网络(上)\u003c/a\u003e和\u003ca href=\"/tech/k8s-net-pod-2/\"\u003eKubernetes网络篇——Pod网络(下)\u003c/a\u003e里，我们已经了解了Pod网络的工作原理。如果集群里有一个Pod想访问另一个Pod里的服务，那它就需要知道这个Pod的IP地址。这种做法的问题在于，它没有办法适应动态变化的情况：Pod可能会因为故障而被重启，而重启之后的Pod，其IP地址以及所在的节点，都有可能会改变。\u003c/p\u003e\n\n\u003cp\u003e在Kubernetes里，我们是通过Service来解决这一问题的。Kubernetes允许我们为Pod添加标签（label），并通过标签来对Pod进行分组。在定义Service时，可以通过声明\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eselector\u003c/code\u003e把Service和一组Pod关联起来。每个Service都有一个属于自己的虚拟IP（Virtual IP，简称VIP）作为前端（front-end），它可以和后端（back-end）的一组Pod相关联，并提供负载均衡的能力。\u003c/p\u003e\n\n\u003cp\u003e下面，我们通过对一个Service的部署，来学习访问Service的几种方法。\u003c/p\u003e\n\n\u003ch2 id=\"定义service\"\u003e定义Service\u003c/h2\u003e\n\n\u003cp\u003e这里，我们继续沿用之前基于\u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster\"\u003ekubeadm-dind-cluster\u003c/a\u003e的实验环境，有关如何使用kubeadm-dind-cluster，以及笔者对它所做的优化，可以参考Kuberntes系列的热身篇\u003ca href=\"/tech/k8s-run/\"\u003eLaunch multi-node Kubernetes cluster locally in one minute, and more…\u003c/a\u003e一文。假定大家在阅读前面有关Pod网络的文章时，已经在实验环境里部署过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-pod\u003c/code\u003e这个Pod了，接下来我们为Pod定义一个Service：\u003c/p\u003e\n\u003cdiv class=\"language-yaml highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"na\"\u003ekind\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003eService\u003c/span\u003e\n\u003cspan class=\"na\"\u003eapiVersion\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003ev1\u003c/span\u003e\n\u003cspan class=\"na\"\u003emetadata\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"na\"\u003ename\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003etest-svc\u003c/span\u003e\n\u003cspan class=\"na\"\u003espec\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n  \u003cspan class=\"na\"\u003eselector\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"na\"\u003eapp\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003elab-web\u003c/span\u003e\n  \u003cspan class=\"na\"\u003eports\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e\n    \u003cspan class=\"pi\"\u003e-\u003c/span\u003e \u003cspan class=\"na\"\u003eport\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"m\"\u003e80\u003c/span\u003e\n      \u003cspan class=\"na\"\u003etargetPort\u003c/span\u003e\u003cspan class=\"pi\"\u003e:\u003c/span\u003e \u003cspan class=\"s\"\u003eweb-port\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e这里，Service的名字叫\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-svc\u003c/code\u003e。通过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eselector\u003c/code\u003e，我们定义了所有\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eapp\u003c/code\u003e标签为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003elab-web\u003c/code\u003e的Pod和\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-svc\u003c/code\u003e相关联。除此以外，我们还对端口号做了定义：\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eport\u003c/code\u003e：定义了作为Service前端的虚拟IP所监听的端口号；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etargetPort\u003c/code\u003e：指明了与Service关联的后端Pod所监听的端口号。\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e在定义\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etargetPort\u003c/code\u003e的时候，我们没有直接引用端口号的具体值，而是用了端口名称。如果大家留意前面的文章，我们在为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-pod\u003c/code\u003e定义端口的时候，除了指定端口号的具体值以外，还为它指定了一个名称。这样，即使端口号发生变化，只要名称不变，其他引用或依赖这个端口的地方就都不用改变；\u003c/p\u003e\n\n\u003cp\u003e我们把上述内容以文件形式保存到实验环境里master节点上的\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/root/test-k8s-net\u003c/code\u003e目录下，并取名\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-svc.yaml\u003c/code\u003e。然后执行如下命令进行部署：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl create \u003cspan class=\"nt\"\u003e-f\u003c/span\u003e test-svc.yaml\nservice \u003cspan class=\"s2\"\u003e\u0026#34;test-svc\u0026#34;\u003c/span\u003e created\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e通过执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubectl get services\u003c/code\u003e命令可以看到，我们的Service已经成功部署到集群里了，它的虚拟IP地址为\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.98.114.171\u003c/code\u003e：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl get services\nNAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT\u003cspan class=\"o\"\u003e(\u003c/span\u003eS\u003cspan class=\"o\"\u003e)\u003c/span\u003e   AGE\nkubernetes   ClusterIP   10.96.0.1       \u0026lt;none\u0026gt;        443/TCP   22d\ntest-svc     ClusterIP   10.107.169.79   \u0026lt;none\u0026gt;        80/TCP    14s\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"从节点访问\"\u003e从节点访问\u003c/h2\u003e\n\n\u003cp\u003e我们可以在集群里的任何一个节点上执行\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecurl\u003c/code\u003e命令对这个Service进行访问。比如在master节点上：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ecurl http://10.107.169.79\n\u0026lt;\u003cspan class=\"o\"\u003e!\u003c/span\u003eDOCTYPE html\u0026gt;\n\u0026lt;html\u0026gt;\n\u0026lt;\u003cspan class=\"nb\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt;\n\u0026lt;style\u0026gt;\n    body \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        width: 35em\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        margin: 0 auto\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        font-family: Tahoma, Verdana, Arial, sans-serif\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u0026lt;/style\u0026gt;\n\u0026lt;/head\u0026gt;\n... ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"从pod访问\"\u003e从Pod访问\u003c/h2\u003e\n\n\u003cp\u003e我们也可以通过集群里的其他Pod访问这个Service。这里我们使用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emr.io/lab-sleeper\u003c/code\u003e镜像生成的Pod进行测试：\u003c/p\u003e\n\u003cdiv class=\"language-dockerfile highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003eFROM\u003c/span\u003e\u003cspan class=\"s\"\u003e centos\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003eRUN \u003c/span\u003eyum \u003cspan class=\"nt\"\u003e-y\u003c/span\u003e update \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e yum \u003cspan class=\"nt\"\u003e-y\u003c/span\u003e \u003cspan class=\"nb\"\u003einstall \u003c/span\u003eiproute bind-utils \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e yum clean all\n\n\u003cspan class=\"k\"\u003eCMD\u003c/span\u003e\u003cspan class=\"s\"\u003e [\u0026#34;/bin/bash\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;echo Sleeping...; trap : TERM INT; sleep 365d \u0026amp; wait\u0026#34;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e为了方便在本地做测试的时候，能够让集群里的节点快速拉取镜像，我们把镜像在本地构建出来以后，推送到了本地的私有Docker注册表\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emr.io\u003c/code\u003e上：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edocker build \u003cspan class=\"nt\"\u003e-t\u003c/span\u003e mr.io/lab-sleeper \u003cspan class=\"nb\"\u003e.\u003c/span\u003e\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003edocker push mr.io/lab-sleeper\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e然后利用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ekubectl run\u003c/code\u003e命令，把\u003ccode class=\"language-plaintext highlighter-rouge\"\u003emr.io/lab-sleeper\u003c/code\u003e镜像部署到集群里：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl create deployment lab-sleeper \u003cspan class=\"nt\"\u003e--image\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003emr.io/lab-sleeper\ndeployment.apps/lab-sleeper created\n\n\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl get pods \u003cspan class=\"nt\"\u003e-o\u003c/span\u003e wide\nNAME                           READY   STATUS    RESTARTS   AGE     IP           NODE          NOMINATED NODE   READINESS GATES\nlab-sleeper-7ff95f64d7-6p7bh   1/1     Running   0          28s     10.244.3.5   kube-node-2   \u0026lt;none\u0026gt;           \u0026lt;none\u0026gt;\ntest-pod-9dd7d4f7b-56znc       1/1     Running   0          3h52m   10.244.2.4   kube-node-1   \u0026lt;none\u0026gt;           \u0026lt;none\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e现在，我们可以在lab-sleeper对应的Pod里，通过Service的虚拟IP地址，访问lab-web对应的Pod了：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl \u003cspan class=\"nb\"\u003eexec \u003c/span\u003elab-sleeper-7ff95f64d7-6p7bh curl http://10.107.169.79\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:-- \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:-- \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:--     0\u0026lt;\u003cspan class=\"o\"\u003e!\u003c/span\u003eDOCTYPE html\u0026gt;\n\u0026lt;html\u0026gt;\n\u0026lt;\u003cspan class=\"nb\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt;\n\u0026lt;style\u0026gt;\n    body \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        width: 35em\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        margin: 0 auto\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        font-family: Tahoma, Verdana, Arial, sans-serif\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u0026lt;/style\u0026gt;\n\u0026lt;/head\u0026gt;\n... ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch2 id=\"通过dns访问\"\u003e通过DNS访问\u003c/h2\u003e\n\n\u003cp\u003e我们还可以借助Kubernetes提供的DNS服务——kube-dns，通过Service名称来访问Service。这样，我们就不需要知道Service的IP地址了，因为IP地址是可以由kube-dns通过Service名称解析得到的。\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl \u003cspan class=\"nb\"\u003eexec \u003c/span\u003elab-sleeper-7ff95f64d7-6p7bh curl http://test-svc     \n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n100   612  100   612    0     0  27818      0 \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:-- \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:-- \u003cspan class=\"nt\"\u003e--\u003c/span\u003e:--:-- 27818\n\u0026lt;\u003cspan class=\"o\"\u003e!\u003c/span\u003eDOCTYPE html\u0026gt;\n\u0026lt;html\u0026gt;\n\u0026lt;\u003cspan class=\"nb\"\u003ehead\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u0026lt;title\u0026gt;Welcome to nginx!\u0026lt;/title\u0026gt;\n\u0026lt;style\u0026gt;\n    body \u003cspan class=\"o\"\u003e{\u003c/span\u003e\n        width: 35em\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        margin: 0 auto\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        font-family: Tahoma, Verdana, Arial, sans-serif\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u0026lt;/style\u0026gt;\n\u0026lt;/head\u0026gt;\n... ...\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3 id=\"kube-dns\"\u003ekube-dns\u003c/h3\u003e\n\n\u003cp\u003e和普通应用一样，Kubernetes的DNS服务也是通过Pod + Service的方式部署到集群里的，只不过它是位于kube-system名字空间下的。所有Kubernetes提供的系统级服务都被部署在这个名字空间下。\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl get pods \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e kube-system\nNAMESPACE     NAME                                  READY     STATUS    RESTARTS   AGE\ncoredns-fb8b8dccf-nggnj               1/1     Running   0          47m\netcd-kube-master                      1/1     Running   3          46m\nkube-apiserver-kube-master            1/1     Running   3          46m\nkube-controller-manager-kube-master   1/1     Running   3          46m\nkube-proxy-f2d74                      1/1     Running   5          22d\nkube-proxy-px4g4                      1/1     Running   5          22d\nkube-proxy-qkvwj                      1/1     Running   5          22d\nkube-scheduler-kube-master            1/1     Running   3          46m\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e从Kubernetes v1.12开始，CoreDNS替代了原来的Kube-DNS成为Kubernetes推荐的默认DNS方案，目的是为了解决Kube-DNS在性能，安全性，以及稳定性方面的缺陷。但为了保持兼容，Service名称还是沿用的kube-dns。因为我本地的实验环境选择了v1.13版本的Kubernetes，所以我们看到kube-system里部署的Pod是coredns，但Service却是kube-dns：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl get services \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e kube-system\nNAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT\u003cspan class=\"o\"\u003e(\u003c/span\u003eS\u003cspan class=\"o\"\u003e)\u003c/span\u003e                  AGE\nkube-dns   ClusterIP   10.96.0.10   \u0026lt;none\u0026gt;        53/UDP,53/TCP,9153/TCP   22d\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e当然，你也可以选择其他版本，\u003ca href=\"https://github.com/kubernetes-sigs/kubeadm-dind-cluster\"\u003ekubeadm-dind-cluster\u003c/a\u003e支持多个Kubernetes版本的快速部署，具体方法参见Kuberntes系列的热身篇\u003ca href=\"/tech/k8s-run/\"\u003eLaunch multi-node Kubernetes cluster locally in one minute, and more…\u003c/a\u003e一文。\u003c/p\u003e\n\n\u003ch3 id=\"resolvconf\"\u003eresolv.conf\u003c/h3\u003e\n\n\u003cp\u003e当我们对Service有创建，更新，或删除操作的时候，kube-dns会监听到来自Kubernetes API的事件，并根据需要更新DNS记录。每个Pod的容器里都有一个文件叫\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e/etc/resolv.conf\u003c/code\u003e，其中包含了DNS的配置信息，比如：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl \u003cspan class=\"nb\"\u003eexec \u003c/span\u003elab-sleeper-7ff95f64d7-6p7bh \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e /etc/resolv.conf     \nnameserver 10.96.0.10\nsearch default.svc.cluster.local svc.cluster.local cluster.local\noptions ndots:5\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003ekubelet会负责修改这个文件，把里面的nameserver设置成kube dns的cluster IP，在我们的例子是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.96.0.10\u003c/code\u003e，并更新搜索域名(search domain)，利用搜索域名，我们可以在用名称访问Pod时使用更短形式的主机名(hostname)。\u003c/p\u003e\n\n\u003cp\u003ekube-dns服务的Cluster IP和搜索域名，都可以在启动kubelet时通过参数来指定。比如，如果在我们的实验环境里查看kubelet的启动参数：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003eps axuw | \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ecluster-dns\nroot       351  4.7  1.4 925132 119008 ?       Ssl  02:54   2:27 /k8s/hyperkube kubelet \u003cspan class=\"nt\"\u003e--kubeconfig\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/etc/kubernetes/kubelet.conf \u003cspan class=\"nt\"\u003e--config\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/var/lib/kubelet/config.yaml \u003cspan class=\"nt\"\u003e--cgroup-driver\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecgroupfs \u003cspan class=\"nt\"\u003e--network-plugin\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecni \u003cspan class=\"nt\"\u003e--pod-infra-container-image\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ek8s.gcr.io/pause:3.1 \u003cspan class=\"nt\"\u003e--pod-manifest-path\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/etc/kubernetes/manifests \u003cspan class=\"nt\"\u003e--allow-privileged\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003etrue\u003c/span\u003e \u003cspan class=\"nt\"\u003e--network-plugin\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecni \u003cspan class=\"nt\"\u003e--cni-conf-dir\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/etc/cni/net.d \u003cspan class=\"nt\"\u003e--cni-bin-dir\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/opt/cni/bin \u003cspan class=\"nt\"\u003e--cluster-dns\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e10.96.0.10 \u003cspan class=\"nt\"\u003e--cluster-domain\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecluster.local \u003cspan class=\"nt\"\u003e--eviction-hard\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ememory.available\u0026lt;100Mi,nodefs.available\u0026lt;100Mi,nodefs.inodesFree\u0026lt;1000 \u003cspan class=\"nt\"\u003e--fail-swap-on\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003efalse\u003c/span\u003e \u003cspan class=\"nt\"\u003e--bootstrap-kubeconfig\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/etc/kubernetes/bootstrap-kubelet.conf \u003cspan class=\"nt\"\u003e--feature-gates\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003eDynamicKubeletConfig\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nb\"\u003etrue\u003c/span\u003e \u003cspan class=\"nt\"\u003e--v\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e4\nroot     22649  0.0  0.0  11108   944 pts/0    S+   03:46   0:00 \u003cspan class=\"nb\"\u003egrep \u003c/span\u003ecluster-dns\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e就会发现，里面有和DNS相关的参数：\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--cluster-dns\u003c/code\u003e，DNS服务的Cluster IP，我们的例子里是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e10.96.0.10\u003c/code\u003e；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--cluster-domain\u003c/code\u003e，集群使用的域名，我们的例子里是\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecluster.local\u003c/code\u003e；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch3 id=\"使用nslookup\"\u003e使用nslookup\u003c/h3\u003e\n\n\u003cp\u003e把\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eresolv.conf\u003c/code\u003e文件里定义的搜索域名作为后缀，我们在访问Service的时候就不用给出完整的域名，而是只要提供Service的名称就可以了。\u003c/p\u003e\n\n\u003cp\u003e比如，当我们用\u003ccode class=\"language-plaintext highlighter-rouge\"\u003enslookup\u003c/code\u003e命令查询test-svc服务的域名和IP地址时，可以直接使用Service的名称\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-svc\u003c/code\u003e作为输入参数：\u003c/p\u003e\n\u003cdiv class=\"language-shell highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003ekubectl \u003cspan class=\"nb\"\u003eexec \u003c/span\u003elab-sleeper-7ff95f64d7-6p7bh nslookup test-svc\nServer:\t\t10.96.0.10\nAddress:\t10.96.0.10#53\n\nName:\ttest-svc.default.svc.cluster.local\nAddress: 10.107.169.79\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e返回结果里包含了test-svc的完整域名和IP地址。其中：\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefault\u003c/code\u003e代表名字空间，我们的test-svc是部署在\u003ccode class=\"language-plaintext highlighter-rouge\"\u003edefault\u003c/code\u003e下的；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003esvc\u003c/code\u003e代表Service；\u003c/li\u003e\n  \u003cli\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecluster.local\u003c/code\u003e就是前面\u003ccode class=\"language-plaintext highlighter-rouge\"\u003e--cluster-domain\u003c/code\u003e参数定义的值；\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e这样一来，跑在容器里的应用程序就可以通过\u003ccode class=\"language-plaintext highlighter-rouge\"\u003etest-svc\u003c/code\u003e解析出对应的IP地址了。\u003c/p\u003e\n\n\u003cp\u003e下图给出了test-pod以及test-svc的网络拓扑。需要注意的是，和Pod以及容器不同，Service在Kubernetes里更多的是逻辑上的概念，所以它在网络拓扑里并没有物理实体存在。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/images/lab/k8s/test-svc-1.png\" alt=\"\"/\u003e\u003c/p\u003e\n\n        \n      \u003c/section\u003e\n\n      \u003cfooter class=\"page__meta\"\u003e\n        \n        \n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-tags\" aria-hidden=\"true\"\u003e\u003c/i\u003e 标签: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/tags/#dummies\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#dummies-kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003edummies_kubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#kubernetes\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003ekubernetes\u003c/a\u003e\u003cspan class=\"sep\"\u003e, \u003c/span\u003e\n    \n      \u003ca href=\"/tags/#lab\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003elab\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n\n\n  \n\n\n  \n\n  \u003cp class=\"page__taxonomy\"\u003e\n    \u003cstrong\u003e\u003ci class=\"fas fa-fw fa-folder-open\" aria-hidden=\"true\"\u003e\u003c/i\u003e 分类: \u003c/strong\u003e\n    \u003cspan itemprop=\"keywords\"\u003e\n    \n      \u003ca href=\"/categories/#tech\" class=\"page__taxonomy-item p-category\" rel=\"tag\"\u003etech\u003c/a\u003e\n    \n    \u003c/span\u003e\n  \u003c/p\u003e\n\n\n        \n\n  \u003cp class=\"page__date\"\u003e\u003cstrong\u003e\u003ci class=\"fas fa-fw fa-calendar-alt\" aria-hidden=\"true\"\u003e\u003c/i\u003e 更新时间:\u003c/strong\u003e \u003ctime class=\"dt-published\" datetime=\"2021-04-24T00:00:00+08:00\"\u003eApril 24, 2021\u003c/time\u003e\u003c/p\u003e\n\n      \u003c/footer\u003e\n\n      \u003csection class=\"page__share\"\u003e\n  \n    \u003ch4 class=\"page__share-title\"\u003e分享\u003c/h4\u003e\n  \n\n  \u003ca href=\"https://twitter.com/intent/tweet?text=Kubernetes%E7%BD%91%E7%BB%9C%E7%AF%87%E2%80%94%E2%80%94Service%E7%BD%91%E7%BB%9C%28%E4%B8%8A%29%20https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-service-1%2F\" class=\"btn btn--twitter\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Twitter\"\u003e\u003ci class=\"fab fa-fw fa-twitter\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Twitter\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-service-1%2F\" class=\"btn btn--facebook\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 Facebook\"\u003e\u003ci class=\"fab fa-fw fa-facebook\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e Facebook\u003c/span\u003e\u003c/a\u003e\n\n  \u003ca href=\"https://www.linkedin.com/shareArticle?mini=true\u0026amp;url=https%3A%2F%2Fmorningspace.github.io%2Ftech%2Fk8s-net-service-1%2F\" class=\"btn btn--linkedin\" onclick=\"window.open(this.href, \u0026#39;window\u0026#39;, \u0026#39;left=20,top=20,width=500,height=500,toolbar=1,resizable=0\u0026#39;); return false;\" title=\"分享 LinkedIn\"\u003e\u003ci class=\"fab fa-fw fa-linkedin\" aria-hidden=\"true\"\u003e\u003c/i\u003e\u003cspan\u003e LinkedIn\u003c/span\u003e\u003c/a\u003e\n\u003c/section\u003e\n\n\n      \n  \u003cnav class=\"pagination\"\u003e\n    \n      \u003ca href=\"/tech/k8s-net-pod-2/\" class=\"pagination--pager\" title=\"Kubernetes网络篇——Pod网络(下)\n\"\u003e向前\u003c/a\u003e\n    \n    \n      \u003ca href=\"/tech/k8s-net-service-2/\" class=\"pagination--pager\" title=\"Kubernetes网络篇——Service网络(下)\n\"\u003e向后\u003c/a\u003e\n    \n  \u003c/nav\u003e\n\n    \u003c/div\u003e",
  "Date": "2021-04-24T00:00:00+08:00",
  "Author": "MornigSpace"
}