{
  "Source": "qiwsir.github.io",
  "Title": "写给小白：K近邻算法入门",
  "Link": "https://qiwsir.github.io/2020/03/30/ml-knn/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e写给小白：K近邻算法入门\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-03-30\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e作者：Philipp Muens\u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003cp\u003e与本文相关的图书推荐：《数据准备和特征工程》（电子工业出版社天猫旗舰店有售）\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B2_20200114135935.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e本文的代码，均发布到百度AI Studio的在线平台中，关注微信公众号「\u003cstrong\u003e老齐教室\u003c/strong\u003e」，并回复：\u003ccode\u003e#真实姓名+手机号+‘案例’#\u003c/code\u003e，申请加入含有苯问案例的《机器学习案例》课程，得到包含本案例在内的更多机器学习案例。\u003cstrong\u003e注意：\u003c/strong\u003e 回复信息中（1）必须以\u003ccode\u003e#\u003c/code\u003e开始和结尾（2）必须是真实姓名和手机号。\u003c/p\u003e\n\u003cp\u003eK近邻（简称K-NN或KNN）是一种简单而优雅的机器学习算法，用于根据现有数据对不可见的数据进行分类。该算法的优点是不需要传统的训练阶段。如果存在分类问题和标记数据，则可以利用现有的已分类数据，预测任何不可见的数据类别。\u003c/p\u003e\n\u003cp\u003e让我们仔细看看核心思想背后相关的数学知识和将这些转化为代码的过程。\u003c/p\u003e\n\u003ch2 id=\"原理\"\u003e\u003ca href=\"#原理\" class=\"headerlink\" title=\"原理\"\u003e\u003c/a\u003e原理\u003c/h2\u003e\u003cp\u003e想象一下，我们邀请了100个养狗的人带着他们的狗过来做一个我们想做的统计实验。每只参与实验的狗是我们感兴趣的4个不同犬种中的1个。在这些狗及其主人的配合下，我们测量每只狗的3种不同属性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eweight: 重量（千克）\u003c/li\u003e\n\u003cli\u003eheight: 高度（厘米）\u003c/li\u003e\n\u003cli\u003ealertness: 警觉性（从0到1[1=非常警觉，0=几乎没有警觉]）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e测量完成后，我们将测量值标准化，使其在000到111之间。\u003c/p\u003e\n\u003cp\u003e在收集了每只狗的数据后，我们得到了100个测量值，每个测量值都标有相应的狗品种。\u003c/p\u003e\n\u003cp\u003e下面是一个例子：\u003c/p\u003e\n\u003cp\u003e$$\\begin{bmatrix}0.5\\0.8\\0.1\\end{bmatrix}=Podenco$$\u003c/p\u003e\n\u003cp\u003e为了更好地理解数据，最好把它标出来。由于我们收集了3种不同的测量数据（重量、高度和警惕性），因此可以将所有100个数据点投影到三维空间中，并根据其标签为每个数据点上色（例如，把“Podenco”的标签涂上棕色）。\u003c/p\u003e\n\u003cp\u003e不幸的是，我们在试图绘制此数据时遇到问题，因为我们忘了标注其中的一个测量数据。我们确实有狗的重量，高度和警觉性，但由于某种原因，我们忘记写下这只狗的品种。\u003c/p\u003e\n\u003cp\u003e既然我们已经有其他狗的测量数据，有没有可能推测出这只狗的品种呢？我们仍然可以将未标记的数据添加到现有三维空间中，所有其他的彩色数据点都在这个空间里。但我们该怎么给这个推测的数据点上色呢？\u003c/p\u003e\n\u003cp\u003e一个可能的解决方案是查看问题数据点周围的5个邻居，看看它们是什么颜色的。如果这些数据点中的大多数标记为“Podenco”，那么我们的测量数据很可能也是从Podenco中获取的。\u003c/p\u003e\n\u003cp\u003e这正是K-NN算法（k近邻算法）的作用。该算法根据一个不可见数据点的K近邻和这些K近邻的绝大多数类型，来预测该数据点的类。让我们从数学的角度来仔细研究一下这个问题。\u003c/p\u003e\n\u003ch2 id=\"两个概念\"\u003e\u003ca href=\"#两个概念\" class=\"headerlink\" title=\"两个概念\"\u003e\u003c/a\u003e两个概念\u003c/h2\u003e\u003cp\u003e为了通过K-NN对数据进行分类，我们只需要实现两个概念。\u003c/p\u003e\n\u003cp\u003e如上所述，该算法通过查看K个最近邻和它们各自的大多数类来对数据进行分类。\u003c/p\u003e\n\u003cp\u003e因此我们需要实现两个函数：距离函数和投票函数。前者用于计算两点之间距离的，后者返回给定的任意标签列表中最常见的标签。\u003c/p\u003e\n\u003ch3 id=\"距离函数\"\u003e\u003ca href=\"#距离函数\" class=\"headerlink\" title=\"距离函数\"\u003e\u003c/a\u003e距离函数\u003c/h3\u003e\u003cp\u003e考虑到“最近邻”的概念，我们需要计算“待分类”数据点与所有其他数据点之间的距离，以找到距离最近的点。\u003c/p\u003e\n\u003cp\u003e有几个不同的距离函数。对于我们的实现，将使用欧几里德距离，因为它计算简单，可以很容易地扩展到多维。\u003c/p\u003e\n\u003cp\u003e用数学符号表示如下：\u003c/p\u003e\n\u003cp\u003e$$d(x, y)=d(y, x)=\\sqrt{\\sum_{i=1}^N(x_i-y_i)^2}$$\u003c/p\u003e\n\u003cp\u003e让我们通过一个例子来解释这个公式。假设有两个向量$\\overrightarrow{a}$和$\\overrightarrow{b}$，两者之间的欧氏距离计算如下:\u003c/p\u003e\n\u003cp\u003e$$\\overrightarrow{a}=\\begin{pmatrix}1\\2\\3\\4\\end{pmatrix} \\overrightarrow{b}=\\begin{pmatrix}5\\6\\7\\8\\end{pmatrix}$$\u003c/p\u003e\n\u003cp\u003e$$d(\\overrightarrow{a},\\overrightarrow{b})=d(\\overrightarrow{b},\\overrightarrow{a})=\\sqrt{(1-5)^2+(2-6)^2+(3-7)^2+(4-8)^2}$$$$=\\sqrt{64}=8$$\u003c/p\u003e\n\u003cp\u003e将其转化为代码的结果如下:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef distance(x: List[float], y: List[float]) -\u0026gt; float:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    assert len(x) == len(y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    interim_res: float = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for i, _ in enumerate(x):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        interim_res += (x[i] - y[i]) ** 2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return sqrt(interim_res)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eassert distance([1, 2, 3, 4], [5, 6, 7, 8]) == 8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e太好了。我们刚刚实现了第一个构建：一个欧氏距离函数。\u003c/p\u003e\n\u003ch3 id=\"投票函数\"\u003e\u003ca href=\"#投票函数\" class=\"headerlink\" title=\"投票函数\"\u003e\u003c/a\u003e投票函数\u003c/h3\u003e\u003cp\u003e接下来我们需要实现投票函数。投票函数接受一个标签列表作为输入，并返回该列表的“最常见”标签。虽然这听起来很容易实现，但我们应该后退一步，考虑可能遇到的潜在的极端情况。\u003c/p\u003e\n\u003cp\u003e其中一种情况是，我们有两个或多个“最常见”标签：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# Do we return `a` or `b`?\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elabels: List[str] = [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e对于这些场景，我们需要实现一个决策机制。\u003c/p\u003e\n\u003cp\u003e有几种方法可以解决这个问题。一种解决办法可能是随机挑选一个标签。然而，在我们的例子中，我们不应该孤立地考虑投票函数，因为我们知道：距离函数和投票函数共同来确定对未分类数据的预测。\u003c/p\u003e\n\u003cp\u003e我们可以利用这一事实。假设我们的投票函数输入了一个标签列表，这个列表是按距离从近到远排序的。有了这一条件，就很容易打破平局。我们需要做的就是递归地删除列表中的最后一个条目（也就是最远的条目），直到只有一个标签明显胜出。\u003c/p\u003e\n\u003cp\u003e下面根据以上的标签示例演示此过程：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# Do we return `a` or `b`?\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elabels: List[str] = [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Remove one entry. We\u0026#39;re still unsure if we should return `a` or `b`\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elabels: List[str] = [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Remove another entry. Now it\u0026#39;s clear that `a` is the \u0026#34;winner\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003elabels: List[str] = [\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e我们把这个算法转换成一个函数，并且称之为\u003ccode\u003emajority_vote\u003c/code\u003e:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef majority_vote(labels: List[str]) -\u0026gt; str:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    counted: Counter = Counter(labels)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    winner: List[str] = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    max_num: int = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    most_common: List[Tuple[str, int]]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for most_common in counted.most_common():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        label: str = most_common[0]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        num: int = most_common[1]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        if num \u0026lt; max_num:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            break\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        max_num = num\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        winner.append(label)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if len(winner) \u0026gt; 1:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return majority_vote(labels[:-1])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return winner[0]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eassert majority_vote([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) == \u0026#39;b\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eassert majority_vote([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;]) == \u0026#39;b\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eassert majority_vote([\u0026#39;a\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) == \u0026#39;a\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e测试表明，我们的\u003ccode\u003emajority_vote\u003c/code\u003e函数能够可靠地处理上述极端情况（边缘情况）。\u003c/p\u003e\n\u003ch2 id=\"K-NN算法\"\u003e\u003ca href=\"#K-NN算法\" class=\"headerlink\" title=\"K-NN算法\"\u003e\u003c/a\u003eK-NN算法\u003c/h2\u003e\u003cp\u003e既然我们已经研究并编写了两个函数，现在是时候把它们结合起来了。我们即将实现的knn函数会输入带标签的数据列表、一个新的度量值（我们要分类的数据点）和一个参数k。参数k决定了：在通过\u003ccode\u003emajority_vote\u003c/code\u003e函数投票给新标签时，我们要考虑多少个邻居。\u003c/p\u003e\n\u003cp\u003eknn算法的首要任务是计算新数据点和所有其他现有数据点之间的距离。之后，我们需要从最近到最远的距离排序，并提取数据点标签。然后截断此有序列表，使其仅包含k个最近的数据点标签。最后一步是将此列表传递给投票函数，该函数用于计算预测标签。\u003c/p\u003e\n\u003cp\u003e将所述步骤转换为代码，将产生以下knn函数：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef knn(labeled_data: List[LabeledData], new_measurement, k: int = 5) -\u0026gt; Prediction:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    class Distance(NamedTuple):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        label: str\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        distance: float\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    distances: List[Distance] = [Distance(data.label, distance(new_measurement, data.measurements))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                                         for data in labeled_data]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    distances = sorted(distances, key=attrgetter(\u0026#39;distance\u0026#39;))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    labels = [distance.label for distance in distances][:k]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    label: str = majority_vote(labels)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return Prediction(label, new_measurement)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e就是这样。这就是从头开始实现的k近邻算法!\u003c/p\u003e\n\u003ch2 id=\"鸢尾花分类\"\u003e\u003ca href=\"#鸢尾花分类\" class=\"headerlink\" title=\"鸢尾花分类\"\u003e\u003c/a\u003e鸢尾花分类\u003c/h2\u003e\u003cp\u003e现在是时候看看我们的自制k-NN实现效果是否像宣传的那样了。为了测试我们编写的代码，我们将使用臭名昭著的鸢尾花数据集。\u003c/p\u003e\n\u003cp\u003e该数据集由三种不同的鸢尾花的50个样本组成:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIris Setosa\u003c/li\u003e\n\u003cli\u003eIris Virginica\u003c/li\u003e\n\u003cli\u003eIris Versicolor\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对每一个样品，收集了4种不同的测量数据：萼片的宽度和长度以及花瓣的宽度和长度。\u003c/p\u003e\n\u003cp\u003e下面是数据集中的一个示例行，其中前4个数字是萼片长度、萼片宽度、花瓣长度、花瓣宽度，最后一个字符串表示这些测量数据的标签。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e6.9,3.1,5.1,2.3,Iris-virginica\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e探索这些数据的最好方法是可视化。不幸的是，很难绘制和检查四维数据。然而，我们可以选择两个特征（如花瓣长度和花瓣宽度）并绘制二维散点图。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efig = px.scatter(x=xs, y=ys, color=text, hover_name=text, labels={\u0026#39;x\u0026#39;: \u0026#39;Petal Length\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;Petal Width\u0026#39;})\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efig.show()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/iris1_20200329104636.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们可以清楚地看到数据点的分类情况，每个类别的数据点有着相同的颜色，因此具有相同的标签。\u003c/p\u003e\n\u003cp\u003e现在假设我们有一个新的、未标记的数据点：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003enew_measurement: List[float] = [7, 3, 4.8, 1.5]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e将这个数据点添加到现有的散点图，结果如下:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efig = px.scatter(x=xs, y=ys, color=text, hover_name=text, labels={\u0026#39;x\u0026#39;: \u0026#39;Petal Length\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;Petal Width\u0026#39;})\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efig.add_annotation(\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    go.layout.Annotation(\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            x=new_measurement[petal_length_idx],\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            y=new_measurement[petal_width_idx],\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            text=\u0026#34;The measurement we want to classify\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efig.update_annotations(dict(\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            xref=\u0026#34;x\u0026#34;,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            yref=\u0026#34;y\u0026#34;,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            showarrow=True,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            arrowhead=7,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            ax=0,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            ay=-40,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            borderwidth=2,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            borderpad=4,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            bgcolor=\u0026#34;#c3c3c3\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efig.show()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/iris2_20200329104719.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e即使我们只是在二维中绘制花瓣的长度和宽度，新的测量值似乎也可能来自“变色鸢尾”。\u003c/p\u003e\n\u003cp\u003e让我们用knn函数得到一个明确的答案：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eknn(labeled_data, new_measurement, 5)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e果然，我们得到的结果表明，我们正在处理一个“变色鸢尾”：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ePrediction(label=\u0026#39;Iris-versicolor\u0026#39;, measurements=[7, 3, 4.8, 1.5])\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"结论\"\u003e\u003ca href=\"#结论\" class=\"headerlink\" title=\"结论\"\u003e\u003c/a\u003e结论\u003c/h2\u003e\u003cp\u003ek近邻分类算法是一种非常强大的分类算法，它可以根据已有标签的数据来标记缺失标签的数据。k-NNs的主要思想是：利用新的“待分类”数据点的K个最近邻来“投票”选出它应有的标签。\u003c/p\u003e\n\u003cp\u003e因此，我们需要两个核心函数来实现k-NN。第一个函数计算两个数据点之间的距离，以便找到最近的邻居。第二个函数执行多数投票，以便可以决定哪个标签在给定的邻域中最常见。\u003c/p\u003e\n\u003cp\u003e同时使用这两个函数可以使k-NN发挥积极作用，并且可以可靠地标记未显示的数据点。\u003c/p\u003e\n\u003cp\u003e我希望这篇文章是有帮助的，它揭开了k近邻算法的内部工作原理的神秘面纱。\u003c/p\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://philippmuens.com/k-nearest-neighbors-from-scratch/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://philippmuens.com/k-nearest-neighbors-from-scratch/\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e搜索技术问答的公众号：老齐教室\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在公众号中回复：\u003cstrong\u003e老齐\u003c/strong\u003e，可查看所有文章、书籍、课程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp style=\"text-align:right\"\u003e\u003cstrong style=\"max-width: 100%;color: rgb(255, 255, 255);background-color: rgb(234, 6, 13);box-sizing: border-box !important;overflow-wrap: break-word !important;\"\u003e觉得好看，就点赞转发\u003c/strong\u003e\u003c/p\u003e\n\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/03/28/python-math-symbole/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          用Python实现各类数学符号运算\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/03/31/pandas-huge-data/\"\u003e\n        \n          利用Pandas和SQLite提升超大数据的读取速度\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-03-30T00:00:00Z",
  "Author": "老齐教室"
}