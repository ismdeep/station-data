{
  "Source": "qiwsir.github.io",
  "Title": "线程：概念和应用(1)",
  "Link": "https://qiwsir.github.io/2020/02/14/python-thread-one/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e线程：概念和应用(1)\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-02-14\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003cp\u003e译者注：与本文相关图书推荐：《Python大学实用教程》《跟老齐学Python：轻松入门》\u003c/p\u003e\n\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E6%9D%BE%E5%85%A5%E9%97%A8_20200122130623.png\" style=\"zoom:50%;\"/\u003e\n\n\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/my_book4_20200116132005.png\" style=\"zoom:50%;\"/\u003e\n\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e本文将分两部分刊发。\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"第一部分\"\u003e\u003ca href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"\u003e\u003c/a\u003e第一部分\u003c/h1\u003e\u003chr/\u003e\n\u003cp\u003ePython线程允许程序的不同部分同时运行，并可以简化设计。如果你对Python有一些经验，并且希望使用线程为程序加速，那么本文就是为你准备的！\u003c/p\u003e\n\u003ch2 id=\"什么是线程？\"\u003e\u003ca href=\"#什么是线程？\" class=\"headerlink\" title=\"什么是线程？\"\u003e\u003c/a\u003e什么是线程？\u003c/h2\u003e\u003cp\u003e线程是一个独立的流，这意味着你的程序可以同时做两件事，但是，对于大多数Python程序，不同的线程实际上并不同时执行，它们只是看起来像是同时执行。\u003c/p\u003e\n\u003cp\u003e人们很容易认为线程是在程序上运行两个（或更多）不同的处理器，每个处理器同时执行一个独立的任务。这种看法大致正确，线程可能在不同的处理器上运行，但一个处理器一次只能运行一个线程。\u003c/p\u003e\n\u003cp\u003e要同时运行多个任务，不能用Python的标准方式实现，可以用不同的编程语言，或者多个进程实现，这样做的开发成本就高了。\u003c/p\u003e\n\u003cp\u003e由于用CPython实现了Python业务，线程可能不会加速所有任务，这是GIL（全称Global Interpreter Lock）的原因，一次只能运行一个Python线程。\u003c/p\u003e\n\u003cp\u003e如果某项任务需要花费大量时间等待外部事件，那么就可以应用多线程。如果是需要对CPU占用高并且花费很少时间等待外部事件，多线程可能枉费。\u003c/p\u003e\n\u003cp\u003e对于用Python编写并在标准CPython实现上运行的代码，这是正确的。如果你的线程是用C编写的，那么它们就能够释放GIL、并发运行。如果你在不同的Python实现上运行，也可以查看文档，了解它如何处理线程。\u003c/p\u003e\n\u003cp\u003e如果你正在运行一个标准的Python程序，只使用Python编写，并且有一个CPU受限的问题，那么你应该用多进程解决此问题。\u003c/p\u003e\n\u003cp\u003e将程序架构为使用线程也可以提高设计的清晰度。你将在下文中学习的大多数示例不一定会运行得更快，因为它们使用线程。在这些示例中使用线程有助于使设计更清晰、更易于推理。\u003c/p\u003e\n\u003cp\u003e所以，让我们停止谈论线程并开始使用它！\u003c/p\u003e\n\u003ch2 id=\"创建一个线程\"\u003e\u003ca href=\"#创建一个线程\" class=\"headerlink\" title=\"创建一个线程\"\u003e\u003c/a\u003e创建一个线程\u003c/h2\u003e\u003cp\u003e现在你已经知道了什么是线程，让我们来学习如何制作线程。Python标准库提供了线程模块\u003ccode\u003ethreading\u003c/code\u003e，它包含了你将在本文中看到的大部分内容。在这个模块中，\u003ccode\u003eThread\u003c/code\u003e是对线程的封装，提供了简单的实现接口。\u003c/p\u003e\n\u003cp\u003e要创建一个线程，需要创建\u003ccode\u003eThread\u003c/code\u003e的实例，然后调用它的\u003ccode\u003e.start()\u003c/code\u003e方法:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport logging\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport threading\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport time\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef thread_function(name):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Thread %s: starting\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    time.sleep(2)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Thread %s: finishing\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#34;__main__\u0026#34;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    format = \u0026#34;%(asctime)s: %(message)s\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.basicConfig(format=format, level=logging.INFO,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        datefmt=\u0026#34;%H:%M:%S\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Main : before creating thread\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    x = threading.Thread(target=thread_function, args=(1,))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Main : before running thread\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    x.start()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Main : wait for the thread to finish\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # x.join()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Main : all done\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如果你查看日志，可以看到在\u003ccode\u003emain\u003c/code\u003e部分正在创建和启动线程:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ex = threading.Thread(target=thread_function, args=(1,))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ex.start()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e用函数\u003ccode\u003ethread_function()\u003c/code\u003e和\u003ccode\u003earg(1,)\u003c/code\u003e创建一个\u003ccode\u003eThread\u003c/code\u003e实例。在本文中用整数作为线程的名称，\u003ccode\u003ethreading.get_ident()\u003c/code\u003e可以返回线程的名称，但可读性较差。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethread_function()\u003c/code\u003e函数的作用不大，它只是记录一些日志消息，在这些消息之间加上\u003ccode\u003etime.sleep()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e当你执行此程序时，输出将如下所示:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./single_thread.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before creating thread\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before running thread\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : wait for the thread to finish\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : all done\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e你会注意到代码的\u003ccode\u003emain\u003c/code\u003e部分结束之后，\u003ccode\u003eThread\u003c/code\u003e才结束。后面会揭示这么做的原因。\u003c/p\u003e\n\u003ch3 id=\"守护线程\"\u003e\u003ca href=\"#守护线程\" class=\"headerlink\" title=\"守护线程\"\u003e\u003c/a\u003e守护线程\u003c/h3\u003e\u003cp\u003e在计算机科学中，\u003ccode\u003edaemon\u003c/code\u003e是在后台运行的程序。\u003c/p\u003e\n\u003cp\u003ePython的\u003ccode\u003ethreading\u003c/code\u003e模块对\u003ccode\u003edaemon\u003c/code\u003e有更具体的含义。当程序退出时，守护线程会立即关闭。考虑这些定义的一种方法是将\u003ccode\u003edaemon\u003c/code\u003e视为在后台运行的线程，而不必担心关闭它。\u003c/p\u003e\n\u003cp\u003e如果程序中正在执行的\u003ccode\u003eThreads\u003c/code\u003e不是\u003ccode\u003edaemons\u003c/code\u003e，则程序将在终止之前等待这些线程完成。然而，如果\u003ccode\u003eThreads\u003c/code\u003e是\u003ccode\u003edaemons\u003c/code\u003e，当程序退出时，它们就终止了。\u003c/p\u003e\n\u003cp\u003e让我们更仔细地看看上面程序的输出，最后两行是有点意思的。当运行这个程序时，在\u003ccode\u003e__main__\u003c/code\u003e打印完\u003ccode\u003eall done\u003c/code\u003e后以及线程结束之前会暂停大约2秒。\u003c/p\u003e\n\u003cp\u003e这个暂停是Python等待非后台线程完成。当Python程序结束时，关闭操作是清除线程中的程序。\u003c/p\u003e\n\u003cp\u003e如果查看\u003ccode\u003ethreading\u003c/code\u003e模块的源代码，你将看到\u003ccode\u003ethreading._shutdown()\u003c/code\u003e方法，它会遍历所有正在运行的线程，并在每一个没有设置\u003ccode\u003edaemon\u003c/code\u003e标志的线程上调用\u003ccode\u003e.join()\u003c/code\u003e方法。\u003c/p\u003e\n\u003cp\u003e因此，程序在退出时会等待，因为线程本身正在sleep（\u003ccode\u003etime.sleep(2)\u003c/code\u003e）中。一旦完成并打印了消息，\u003ccode\u003e.join()\u003c/code\u003e 将返回，程序才可以退出。\u003c/p\u003e\n\u003cp\u003e通常，这是你想要的，但是我们还有其他的选择。让我们首先使用一个\u003ccode\u003edaemon\u003c/code\u003e线程来重复这个程序。你可以修改\u003ccode\u003eThread\u003c/code\u003e实例化时的参数，添加\u003ccode\u003edaemon=True\u003c/code\u003e:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ex = threading.Thread(target=thread_function, args=(1,), daemon=True)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e现在运行程序时，应看到以下输出：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./daemon_thread.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before creating thread\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before running thread\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : wait for the thread to finish\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : all done\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e与前面不同的是，前面所输出的最后一行在这里没有了。\u003ccode\u003ethread_function()\u003c/code\u003e没有执行完，它是一个\u003ccode\u003edaemon\u003c/code\u003e线程，所以当\u003ccode\u003e_main__\u003c/code\u003e执行到达它的末尾时，程序结束，后台线程也就结束了。\u003c/p\u003e\n\u003ch3 id=\"线程实例的-join-方法\"\u003e\u003ca href=\"#线程实例的-join-方法\" class=\"headerlink\" title=\"线程实例的.join()方法\"\u003e\u003c/a\u003e线程实例的\u003ccode\u003e.join()\u003c/code\u003e方法\u003c/h3\u003e\u003cp\u003e守护线程很方便，但是，如果要实现线程完全执行，而不是被迫退出，应该怎么办？现在让我们回到原始程序，看看注释掉的那一行:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# x.join()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e要让一个线程等待另一个线程完成，可以调用\u003ccode\u003e.join()\u003c/code\u003e。取消对该行的注释，主线程将暂停并等待线程\u003ccode\u003ex\u003c/code\u003e，直到它运行结束。\u003c/p\u003e\n\u003cp\u003e你是否在程序中用守护线程或普通线程测试了这个问题？这并不重要。如果执行某个线程的\u003ccode\u003e.join()\u003c/code\u003e方法，该语句将一直等待，直到每个线程都完成。\u003c/p\u003e\n\u003ch2 id=\"使用多线程\"\u003e\u003ca href=\"#使用多线程\" class=\"headerlink\" title=\"使用多线程\"\u003e\u003c/a\u003e使用多线程\u003c/h2\u003e\u003cp\u003e到目前为止，示例代码只使用了两个线程：一个是主线程，另一个是以\u003ccode\u003ethreading.Thread\u003c/code\u003e对象开始的线程。\u003c/p\u003e\n\u003cp\u003e通常，您会希望启动更多线程并让它们做一些有趣的工作。我们先来看看比复杂的方法，然后再看比较简单的方法。\u003c/p\u003e\n\u003cp\u003e启动多线程比较复杂的方法是你已经知道的:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport logging\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport threading\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport time\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef thread_function(name):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Thread %s: starting\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    time.sleep(2)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Thread %s: finishing\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#34;__main__\u0026#34;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    format = \u0026#34;%(asctime)s: %(message)s\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.basicConfig(format=format, level=logging.INFO,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        datefmt=\u0026#34;%H:%M:%S\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    threads = list()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for index in range(3):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Main : create and start thread %d.\u0026#34;, index)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        x = threading.Thread(target=thread_function, args=(index,))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        threads.append(x)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        x.start()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for index, thread in enumerate(threads):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Main : before joining thread %d.\u0026#34;, index)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        thread.join()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Main : thread %d done\u0026#34;, index)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这段代码使用与上面看到的相同机制来启动线程，创建一个\u003ccode\u003eThread\u003c/code\u003e实例对象，然后调用\u003ccode\u003e.start()\u003c/code\u003e。程序中生成一个由\u003ccode\u003eThread\u003c/code\u003e实例组成的列表，后面再调用每个实例\u003ccode\u003e.join()\u003c/code\u003e方法。\u003c/p\u003e\n\u003cp\u003e多次运行此代码可能会产生一些有趣的结果。下面是我的机器的输出示例：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./multiple_threads.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : create and start thread 0.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : create and start thread 1.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : create and start thread 2.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 2: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before joining thread 0.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 2: finishing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: finishing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : thread 0 done\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before joining thread 1.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : thread 1 done\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : before joining thread 2.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMain : thread 2 done\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如果仔细检查输出，你将看到所有三个线程都按照你可能期望的顺序开始，但在本例中，它们是按照相反的顺序完成的！多次运行将产生不同的排序，可以通过查找\u003ccode\u003eThread x: finishing\u003c/code\u003e消息来了解每个线程何时完成。\u003c/p\u003e\n\u003cp\u003e线程的运行顺序由操作系统决定，很难预测，它可能（而且很可能）因运行而异，因此在设计使用线程的算法时需要注意这一点。\u003c/p\u003e\n\u003cp\u003e幸运的是，Python提供了几个模块，你稍后将看到这些模块用来帮助协调线程并使它们一起运行。在此之前，让我们看看如何更简单地管理一组线程。\u003c/p\u003e\n\u003ch2 id=\"使用ThreadPoolExecutor\"\u003e\u003ca href=\"#使用ThreadPoolExecutor\" class=\"headerlink\" title=\"使用ThreadPoolExecutor\"\u003e\u003c/a\u003e使用ThreadPoolExecutor\u003c/h2\u003e\u003cp\u003e有一种比上面看到的更容易启动多线程的方法，它被称为\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e，是标准库中的\u003ccode\u003econcurrent.futures\u003c/code\u003e的一员（从Python3.2开始）。 \u003c/p\u003e\n\u003cp\u003e创建它的最简单方法是使用上下文管理器的\u003ccode\u003ewith\u003c/code\u003e语句，用它实现对线程池的创建和销毁。\u003c/p\u003e\n\u003cp\u003e下面是为了使用\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e而重写的上一个示例中的\u003ccode\u003e__main__\u003c/code\u003e部分代码：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport concurrent.futures\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# [rest of code]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#34;__main__\u0026#34;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    format = \u0026#34;%(asctime)s: %(message)s\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.basicConfig(format=format, level=logging.INFO,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        datefmt=\u0026#34;%H:%M:%S\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        executor.map(thread_function, range(3))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e代码创建了一个\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e作为上下文管理器，告诉它需要在线程池中有多少个工作线程。然后它使用\u003ccode\u003e.map()\u003c/code\u003e遍历可迭代对象，在上面的例子中是\u003ccode\u003erange(3)\u003c/code\u003e，将每个可迭代对象传递给线程池中的一个线程。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ewith\u003c/code\u003e语句块的尾部，默认会调用\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e的每个线程的\u003ccode\u003e.join()\u003c/code\u003e方法，建议你尽可能使用\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e作为上下文管理器，这样你就永远不会忘记对执行线程\u003ccode\u003e.join()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意：使用\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e可能会导致一些混乱的错误。\u003c/p\u003e\n\u003cp\u003e例如，如果调用不带参数的函数，但在\u003ccode\u003e.map()\u003c/code\u003e中传了参数，则线程应当抛出异常。\u003c/p\u003e\n\u003cp\u003e不幸的是，\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e隐藏了该异常，并且（在上面的情况下）程序将在没有输出的情况下终止。一开始调试可能会很混乱。\u003c/p\u003e\n\u003cp\u003e运行正确的示例代码将生成如下输出：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./executor.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 2: starting\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: finishing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 2: finishing\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e同样，请注意\u003ccode\u003eThread 1\u003c/code\u003e是在\u003ccode\u003eThread 0\u003c/code\u003e之前完成的，线程执行顺序的调度是由操作系统完成的，所遵循的计划也不易理解。\u003c/p\u003e\n\u003cp\u003e（\u003cstrong\u003e未完待续\u003c/strong\u003e）\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关注微信公众号：老齐教室。读深度文章，得精湛技艺，享绚丽人生。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#Python 线程\"\u003e\n    \u003cspan class=\"tag-code\"\u003ePython 线程\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/02/13/data-and-feature/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          这本书，帮你解决AI项目中最难最烦的工作\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/02/15/crawler-nCon-2019/\"\u003e\n        \n          【公开课】用网络爬虫技术获取新冠病毒疫情数据\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-02-14T00:00:00Z",
  "Author": "老齐教室"
}