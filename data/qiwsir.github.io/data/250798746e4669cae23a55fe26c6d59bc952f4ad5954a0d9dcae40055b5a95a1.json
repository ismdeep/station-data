{
  "Source": "qiwsir.github.io",
  "Title": "手把手教你使用图像处理利器OpenCV",
  "Link": "https://qiwsir.github.io/2020/03/22/learn-opencv/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e手把手教你使用图像处理利器OpenCV\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-03-22\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e作者：Muhammad Junaid Khalid\u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003cp\u003e与本文相关的图书推荐：《数据准备和特征工程》\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B2_20200114135935.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2 id=\"概要\"\u003e\u003ca href=\"#概要\" class=\"headerlink\" title=\"概要\"\u003e\u003c/a\u003e概要\u003c/h2\u003e\u003cp\u003e在本文中，将学习如何使用Python语言进行图像处理，我们不会局限于一个单独的库或框架，然而，有一个库的使用率将会是最高的，那就是OpenCV。我们一开始会讨论一些图像处理，然后继续探讨不同的应用/场景，也就是图像处理的用武之地。开始吧!\u003c/p\u003e\n\u003ch2 id=\"什么是图像处理\"\u003e\u003ca href=\"#什么是图像处理\" class=\"headerlink\" title=\"什么是图像处理?\"\u003e\u003c/a\u003e什么是图像处理?\u003c/h2\u003e\u003cp\u003e在深入研究图像处理的方法之前，重要的是要了解什么是图像处理，特别是这项技术在处理大量图片方面的角色。图像处理完整的说法是“数字图像处理”，经常使用图像处理的领域是“计算机视觉”。对这两个术语不要混淆，图像处理算法和计算机视觉(CV)算法都以图像为输入，然而，在图像处理中，输出也是图像，而在计算机视觉中，输出可以是关于图像的一些特征或信息。\u003c/p\u003e\n\u003ch2 id=\"为什么需要图像处理\"\u003e\u003ca href=\"#为什么需要图像处理\" class=\"headerlink\" title=\"为什么需要图像处理?\"\u003e\u003c/a\u003e为什么需要图像处理?\u003c/h2\u003e\u003cp\u003e我们收集或生成的数据大部分是原始数据，也就是说，由于一些可能的原因，这些数据不适合直接用于应用程序。因此，我们需要首先分析它，执行必要的预处理，然后使用它——特别推荐《数据准备和特征工程》，此书即为这方面最佳读物。\u003c/p\u003e\n\u003cp\u003e例如，我们正在尝试构建一个关于猫的分类器。我们的程序会把一个图像作为输入，然后告诉我们这个图像是否包含一只猫。构建这个分类器的第一步是收集数百张含有猫的图片。一个常见的问题是，收集的所有图片的大小都不相同，因此在将它们提供给模型进行训练之前，需要调整它们的大小或者把它们进行预处理，使尺寸符合标准。\u003c/p\u003e\n\u003cp\u003e为什么图像处理对于任何计算机视觉应用序都是必不可少的？以上提到的只是众多原因之一。\u003c/p\u003e\n\u003ch2 id=\"预备知识\"\u003e\u003ca href=\"#预备知识\" class=\"headerlink\" title=\"预备知识\"\u003e\u003c/a\u003e预备知识\u003c/h2\u003e\u003cp\u003e为了轻松地学习本文内容，你需要已经具备如下知识。\u003c/p\u003e\n\u003cp\u003e首先，应该具备一定的编程语言技能，本文使用的是Python语言，如果尚未掌握此语言，推荐阅读《跟老齐学Python：轻松入门》或《Python大学实用教程》。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E6%9D%BE%E5%85%A5%E9%97%A8_20200122130623.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e其次，你应该了解什么是机器学习以及它的基本工作原理。因为在本文中我们将使用一些机器学习算法来进行图像处理。\u003c/p\u003e\n\u003cp\u003e另外，如果你之前接触过或掌握了OpenCV的基本知识，也会有所帮助。但这不是必需的。\u003c/p\u003e\n\u003cp\u003e还有，你一定要了解图像在内存中究竟是如何表示的。每幅图像都由一组像素表示，即像素值矩阵。对于灰度图像，像素值的范围是0到255，它们表示该像素的强度。例如，如果你有一个20×20维的图像，它将由一个20x20的矩阵表示(像素值总共是400)。\u003c/p\u003e\n\u003cp\u003e如果你正在处理彩色图像，你应该知道它有三个通道——红、绿、蓝(RGB)。因此，一个彩色图像有三个这样的矩阵。\u003c/p\u003e\n\u003ch2 id=\"安装\"\u003e\u003ca href=\"#安装\" class=\"headerlink\" title=\"安装\"\u003e\u003c/a\u003e安装\u003c/h2\u003e\u003cp\u003e注意: 由于我们将通过Python使用OpenCV，所以你必须会实用它，前面推荐了关于Python的书籍。下面依次说明在不同操作系统中OpenCV的安装方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWindows\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ pip install opencv-python\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003eMacOS\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ brew install opencv3 --with-contrib --with-python3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cul\u003e\n\u003cli\u003eLinux\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ sudo apt-get install libopencv-dev python-opencv\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e要检查是否安装成功，请在Python交互模式中运行以下命令:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport cv2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"必备的基础知识\"\u003e\u003ca href=\"#必备的基础知识\" class=\"headerlink\" title=\"必备的基础知识\"\u003e\u003c/a\u003e必备的基础知识\u003c/h2\u003e\u003cp\u003e在进行图像处理之前，要先做一些准备。\u003c/p\u003e\n\u003cp\u003e在本文中，我们将使用以下图像:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose1_20200321193726.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e注意: 为了在本文中显示该图像，对其进行了缩放，但是我们使用的图像原始大小约为1180x786。\u003c/p\u003e\n\u003cp\u003e你可能注意到图像现在是彩色的，这意味着它由三个颜色通道表示，即红色、绿色和蓝色。我们将把图像转换成灰度，并使用下面的代码将图像分割成单独的通道。\u003c/p\u003e\n\u003ch3 id=\"找到图像细节\"\u003e\u003ca href=\"#找到图像细节\" class=\"headerlink\" title=\"找到图像细节\"\u003e\u003c/a\u003e找到图像细节\u003c/h3\u003e\u003cp\u003e使用\u003ccode\u003eimread()\u003c/code\u003e函数加载图像后，我们可以得到关于它的一些简单属性，比如像素的数量和尺寸:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport cv2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimg = cv2.imread(\u0026#39;rose.jpg\u0026#39;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;Image Properties\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;- Number of Pixels: \u0026#34; + str(img.size))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;- Shape/Dimensions: \u0026#34; + str(img.shape))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eOutput:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eImage Properties\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e- Number of Pixels: 2782440\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e- Shape/Dimensions: (1180, 786, 3)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"将图像分割成单独的通道\"\u003e\u003ca href=\"#将图像分割成单独的通道\" class=\"headerlink\" title=\"将图像分割成单独的通道\"\u003e\u003c/a\u003e将图像分割成单独的通道\u003c/h3\u003e\u003cp\u003e现在，我们将使用OpenCV将图像分割成红色、绿色和蓝色的部分，并显示它们:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom google.colab.patches import cv2_imshow\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eblue, green, red = cv2.split(img)    # Split the image into its channels\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimg_gs = cv2.imread(\u0026#39;rose.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE)    # Convert image to grayscale\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(red) # Display the red channel in the image\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(blue) # Display the red channel in the image\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(green) # Display the red channel in the image\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(img_gs) # Display the grayscale version of image\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e为了简单起见，我们只显示灰度图像。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose2_20200321193815.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"图像阈值\"\u003e\u003ca href=\"#图像阈值\" class=\"headerlink\" title=\"图像阈值\"\u003e\u003c/a\u003e图像阈值\u003c/h2\u003e\u003cp\u003e阈值的概念非常简单。正如上面在图像表示中所讨论的，像素值可以是0到255之间的任何值。假设我们想要将一幅图像转二值化，即指定一个像素值为0或1。为此，我们可以设置阈值。例如，如果阈值(T)为125，那么所有大于125的像素将被赋值为1，所有小于或等于该值的像素将被赋值为0。下面，我们通过代码来更好地理解它。\u003c/p\u003e\n\u003cp\u003e将下面的图像用上述方法进行转换：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose3_20200321193909.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport cv2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Read image\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimg = cv2.imread(\u0026#39;image.png\u0026#39;, 0)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Perform binary thresholding on the image with T = 125\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003er, threshold = cv2.threshold(img, 125, 255, cv2.THRESH_BINARY)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(threshold)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose4_20200321193943.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e正如你所看到的, 二值化之后，出现了两个区域，即黑色区域(像素值0)和白色区域(像素值1)。原来, 我们设置的阈值正好在图像的中间，这就是为什么黑白值在那里被分割。\u003c/p\u003e\n\u003ch2 id=\"应用\"\u003e\u003ca href=\"#应用\" class=\"headerlink\" title=\"应用\"\u003e\u003c/a\u003e应用\u003c/h2\u003e\u003ch3 id=\"1-去除图像中的噪声\"\u003e\u003ca href=\"#1-去除图像中的噪声\" class=\"headerlink\" title=\"1:去除图像中的噪声\"\u003e\u003c/a\u003e1:去除图像中的噪声\u003c/h3\u003e\u003cp\u003e现在你已经对图像处理的概念和用途有了基本的了解，接下来让我们来了解一下它的一些具体应用。\u003c/p\u003e\n\u003cp\u003e在大多数情况下，我们收集的原始数据有噪声，也就是说，不需要的特征使图像很难被感知。虽然这些图像可以直接用于特征抽取，但是算法的准确性会受到很大的影响。这就是为什么在将图像传递给算法以获得更好的精度之前，要对图像进行处理的原因。\u003c/p\u003e\n\u003cp\u003e有许多不同类型的噪声，如高斯噪声，椒盐噪声等。我们可以通过应用滤波器来去除图像中的噪声，或者至少将其影响降到最低。在滤波器方面也有很多选择，每一个滤波器都有不同的优点。因此，对于特定类型的噪声来说，总有一个是最好的。\u003c/p\u003e\n\u003cp\u003e为了更好地理解这一点，我们将在上面的玫瑰色图像的灰度版本中添加“盐和胡椒粉”噪声，然后尝试使用不同的滤波器去除图像中的噪声，看看哪一个最适合这种类型。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e31\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e32\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e33\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport numpy as np\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Adding salt \u0026amp; pepper noise to an image\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef salt_pepper(prob):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      # Extract image dimensions\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      row, col = img_gs.shape\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      # Declare salt \u0026amp; pepper noise ratio\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      s_vs_p = 0.5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      output = np.copy(img_gs)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      # Apply salt noise on each pixel individually\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      num_salt = np.ceil(prob * img_gs.size * s_vs_p)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      coords = [np.random.randint(0, i - 1, int(num_salt))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            for i in img_gs.shape]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      output[coords] = 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      # Apply pepper noise on each pixel individually\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      num_pepper = np.ceil(prob * img_gs.size * (1. - s_vs_p))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      coords = [np.random.randint(0, i - 1, int(num_pepper))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            for i in img_gs.shape]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      output[coords] = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      cv2_imshow(output)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      return output\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Call salt \u0026amp; pepper function with probability = 0.5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# on the grayscale image of rose\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esp_05 = salt_pepper(0.5)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Store the resultant image as \u0026#39;sp_05.jpg\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2.imwrite(\u0026#39;sp_05.jpg\u0026#39;, sp_05)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e好的，我们已经把噪声添加到玫瑰图像，这是它现在的样子：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose5_20200321194023.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e让我们现在应用不同的滤波器，并记下观察结果，即每个滤波器降噪的效果。\u003c/p\u003e\n\u003ch4 id=\"锐化滤波器\"\u003e\u003ca href=\"#锐化滤波器\" class=\"headerlink\" title=\"锐化滤波器\"\u003e\u003c/a\u003e锐化滤波器\u003c/h4\u003e\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# Create our sharpening kernel, the sum of all values must equal to one for uniformity\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ekernel_sharpening = np.array([[-1,-1,-1],\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                              [-1, 9,-1],\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                              [-1,-1,-1]])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Applying the sharpening kernel to the grayscale image \u0026amp; displaying it.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;\\n\\n--- Effects on S\u0026amp;P Noise Image with Probability 0.5 ---\\n\\n\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Applying filter on image with salt \u0026amp; pepper noise\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esharpened_img = cv2.filter2D(sp_05, -1, kernel_sharpening)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(sharpened_img)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在有椒盐噪声的图像上应用滤波器得到的图像如下所示。通过与原始灰度图的对比，我们可以看出，它把图像调得太亮了，也无法突出玫瑰上的亮点。因此，我们可以得出结论，锐化滤波器并不能去除噪声。\u003c/p\u003e\n\u003cp\u003e锐化滤波器输出:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose6_20200321194102.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"中值滤波器\"\u003e\u003ca href=\"#中值滤波器\" class=\"headerlink\" title=\"中值滤波器\"\u003e\u003c/a\u003e中值滤波器\u003c/h4\u003e\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom scipy.ndimage import maximum_filter, minimum_filter\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef midpoint(img):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    maxf = maximum_filter(img, (3, 3))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    minf = minimum_filter(img, (3, 3))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    midpoint = (maxf + minf) / 2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    cv2_imshow(midpoint)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;\\n\\n---Effects on S\u0026amp;P Noise Image with Probability 0.5---\\n\\n\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emidpoint(sp_05)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e在有噪声的图像上应用中值滤波器，得到的图像如下所示。通过与原始灰度图像的对比，我们可以看出，与上面的核方法一样，图像的亮度调高了很多，然而，它能够突出玫瑰上的亮斑（即噪声）。因此，我们可以说，中值滤波器是比锐化滤波器更好的选择，但它仍然不能完全恢复原始图像。\u003c/p\u003e\n\u003cp\u003e中值滤波器输出:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose7_20200321194145.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch4 id=\"逆谐波均值滤波器\"\u003e\u003ca href=\"#逆谐波均值滤波器\" class=\"headerlink\" title=\"逆谐波均值滤波器\"\u003e\u003c/a\u003e逆谐波均值滤波器\u003c/h4\u003e\u003cp\u003e注意: 对这些滤波器的工作原理的阐述，超出了本文范畴，读者可以在网上搜索，我们还是从应用的层面来研究。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef contraharmonic_mean(img, size, Q):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    num = np.power(img, Q + 1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    denom = np.power(img, Q)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    kernel = np.full(size, 1.0)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    result = cv2.filter2D(num, -1, kernel) / cv2.filter2D(denom, -1, kernel)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return result\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;\\n\\n--- Effects on S\u0026amp;P Noise Image with Probability 0.5 ---\\n\\n\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2_imshow(contraharmonic_mean(sp_05, (3,3), 0.5))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在有椒盐噪声的图像上应用逆谐波均值滤波器(\u003ca href=\"https://en.wikipedia.org/wiki/Contraharmonic_mean)得到的图像如下图所示。通过与原始灰度图像的对比，我们可以看到：它几乎完美再现了原始图像。它的强度或亮度级别与原图是相同的，它突出了玫瑰上的亮点。因此，我们可以得出结论，逆谐波均值滤波器在处理椒盐噪声方面是非常有效的。\" target=\"_blank\" rel=\"noopener\"\u003ehttps://en.wikipedia.org/wiki/Contraharmonic_mean)得到的图像如下图所示。通过与原始灰度图像的对比，我们可以看到：它几乎完美再现了原始图像。它的强度或亮度级别与原图是相同的，它突出了玫瑰上的亮点。因此，我们可以得出结论，逆谐波均值滤波器在处理椒盐噪声方面是非常有效的。\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e逆谐波均值滤波器输出:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/rose8_20200321194227.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e现在我们已经找到了最佳滤波器，它可以有效地把有噪声的图像恢复到原始图像。我们可以继续下一个应用了。\u003c/p\u003e\n\u003ch3 id=\"2-使用Canny算子进行边缘检测\"\u003e\u003ca href=\"#2-使用Canny算子进行边缘检测\" class=\"headerlink\" title=\"2:使用Canny算子进行边缘检测\"\u003e\u003c/a\u003e2:使用Canny算子进行边缘检测\u003c/h3\u003e\u003cp\u003e到目前为止，我们使用的玫瑰图像的背景是不变的，也就是黑色的，因此，我们将把这个应用用于不同的图像，以更好地展示算法的功效。原因是，如果背景是恒定的，边缘检测任务就变得相当简单，这不是我们所希望的。\u003c/p\u003e\n\u003cp\u003e在本文开始部分，我们提到了一个关于猫的分类器。现在我们延用这个例子，看看图像处理如何在其中扮演一个完整的角色。\u003c/p\u003e\n\u003cp\u003e在分类算法中，首先扫描图像寻找“对象”。也就是说，当你输入一幅图像时，算法会找到图像中的所有对象，然后将它们与你试图寻找的对象进行特征比较。对于猫分类器，它会将在图像中找到的所有对象与猫图像的特征进行比较，如果找到匹配项，它会告诉我们输入图像中包含了一只猫。\u003c/p\u003e\n\u003cp\u003e对于这个猫分类器，仅以一张猫的图像为例，以下是我们将要使用的图像:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/cat1_20200321194307.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport cv2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport numpy as np\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efrom matplotlib import pyplot as plt\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Declaring the output graph\u0026#39;s size\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.figure(figsize=(16, 16))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Convert image to grayscale\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimg_gs = cv2.imread(\u0026#39;cat.jpg\u0026#39;, cv2.IMREAD_GRAYSCALE)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecv2.imwrite(\u0026#39;gs.jpg\u0026#39;, img_gs)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Apply canny edge detector algorithm on the image to find edges\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eedges = cv2.Canny(img_gs, 100,200)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Plot the original image against the edges\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.subplot(121), plt.imshow(img_gs)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.title(\u0026#39;Original Gray Scale Image\u0026#39;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.subplot(122), plt.imshow(edges)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.title(\u0026#39;Edge Image\u0026#39;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# Display the two images\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.show()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e边缘检测输出:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/cat2_20200321194340.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e正如你所看到的，图像中包含对象的部分（在本例中是一只猫）已经通过边缘检测用虚线标出或分隔开。现在你一定想知道，什么是边缘检测的Canny算子，它是怎么工作的？现在就讨论一下。\u003c/p\u003e\n\u003cp\u003e要理解上述内容，需要讨论三个关键步骤。首先，它对图像进行降噪，降噪方式与前面讨论的方式类似。其次，它使用每个像素的一阶导数来找到边缘。这背后的逻辑是，在边缘存在的地方，会有一个突然的强度变化，导致一阶导数值达到峰值，从而使该像素成为“边缘像素”。\u003c/p\u003e\n\u003cp\u003e最后，进行滞后阈值化；上面我们说过，在一个边缘的一阶导数值会有一个峰值，但是我们没有说：这个峰值需要有多高，才能被归类为一个边缘——这叫做阈值!在本文的前面，我们讨论了什么是简单的阈值。迟滞阈值法是在此基础上的一种改进，它利用两个阈值来代替一个阈值。这背后的原因是，如果阈值过高，我们可能会错过一些真正的边缘(真负例)，如果阈值过低，我们会得到很多被归类为边缘的点，而实际上不是边缘(假正例)。一个阈值设置为高，一个设置为低，将所有高于“高阈值”的点标识为边缘，然后对所有高于“低阈值”但低于“高阈值”的点进行评估；边缘上的点确定之后，与边缘点靠近或相邻的点也被确定为边缘，其余的点被丢弃。\u003c/p\u003e\n\u003cp\u003e这些是Canny算子用于识别图像边缘的基本概念/方法。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e译者注：\u003c/strong\u003e Canny算子是澳洲计算机科学家约翰·坎尼（John F. Canny）于1986年开发出来的一个多级边缘检测算法，其目标是找到一个最优的边缘.\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca href=\"#结论\" class=\"headerlink\" title=\"结论\"\u003e\u003c/a\u003e结论\u003c/h2\u003e\u003cp\u003e在本文中，我们学习了如何在不同的平台(如Windows、MacOS和Linux)上安装OpenCV，以及如何验证安装成功。OpenCV是Python中最流行的图像处理库。\u003c/p\u003e\n\u003cp\u003e接着我们讨论了什么是图像处理，以及它在机器学习的计算机视觉领域中的应用。我们讨论了一些常见的噪声类型，以及如何使用不同的滤波器将噪声从图像中去除，以便在应用中使用这些图像。\u003c/p\u003e\n\u003cp\u003e此外，我们还了解了图像处理如何在高端应用（如：对象检测或分类）中发挥不可或缺的作用。请注意，这篇文章只是冰山一角，数字图像处理还有更多的内容，不可能在一篇短文中全部涵盖。请关注微信公众号「老齐教室」，这里还会刊发有关图像处理的文章。\u003c/p\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://stackabuse.com/introduction-to-image-processing-in-python-with-opencv/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackabuse.com/introduction-to-image-processing-in-python-with-opencv/\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e搜索技术问答的公众号：老齐教室\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在公众号中回复：\u003cstrong\u003e老齐\u003c/strong\u003e，可查看所有文章、书籍、课程。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#OpenCV 图像处理 数据准备 特征工程\"\u003e\n    \u003cspan class=\"tag-code\"\u003eOpenCV 图像处理 数据准备 特征工程\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/03/20/lasso-regression/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          写给初学者的LASSO回归\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/03/23/python-asterisk/\"\u003e\n        \n          Python初学者应该了解的星号（*）\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-03-22T00:00:00Z",
  "Author": "老齐教室"
}