{
  "Source": "qiwsir.github.io",
  "Title": "通俗易懂讲算法：快速排序",
  "Link": "https://qiwsir.github.io/2020/02/04/quicksort/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e通俗易懂讲算法：快速排序\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-02-04\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e作者：Marcus Sanatan \u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2 id=\"介绍\"\u003e\u003ca href=\"#介绍\" class=\"headerlink\" title=\"介绍\"\u003e\u003c/a\u003e介绍\u003c/h2\u003e\u003cp\u003e快速排序是一种流行的排序算法，经常与归并排序一起使用。快速排序是一个高效的排序算法，平均复杂度为O(nlogn)。它受欢迎的部分原因还在于易于实施。\u003c/p\u003e\n\u003cp\u003e在本文中，我们将先使用整数集合演示快速排序算法，然后会用自定义对象深入探讨这种算法的实现方式。\u003c/p\u003e\n\u003cp\u003e在分治法、原地排序和非稳定排序中，都有快速排序算法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在分治法中，对大数组使用递归进行排序之前，使用快速排序算法将数组拆分为更小的数组，直到最后得到一个空数组或只有一个元素的数组。\u003c/li\u003e\n\u003cli\u003e在原地排序中，快速排序不创建数组的任何副本，它在内存中完成所有的操作。\u003c/li\u003e\n\u003cli\u003e稳定排序指相同的值在数组中的顺序也是相同的，非稳定的排序算法不能保证这一点，只能说这样的顺序当然有可能出现，但不能保证。这在针对对象排序而不是对基本类型排序时变得很重要。例如，假设有几个自定义的\u003ccode\u003ePerson\u003c/code\u003e类实例具有相同的\u003ccode\u003eage\u003c/code\u003e，即21岁的Dave和21岁的Mike。如果要对包含Dave和Mike的集合使用快速排序法按年龄排序，则无法保证每次运行算法时Dave都会出现在Mike之前，反之亦然。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"快速排序\"\u003e\u003ca href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"\u003e\u003c/a\u003e快速排序\u003c/h2\u003e\u003cp\u003e快速排序算法的执行流程如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将集合分成两个（大致）相等的部分，取一个伪随机元素并将其用作主元（\u003cstrong\u003e注：\u003c/strong\u003e “主元”，原文中pivot，在多数介绍快速排序算法的中文资料中，并不对齐单独命名，只简单说成是“分割点”，即划分集合的元素，但本文作者使用了pivot这个词来表示“分割点”，译者认为很便于理解和表述，并将其翻译为“主元”）。\u003c/li\u003e\n\u003cli\u003e小于主元的元素将移动到其左侧，大于主元的元素将移动到其的右侧。\u003c/li\u003e\n\u003cli\u003e分别对于主元左侧和右侧的元素，重复此上述，直到对整个数组完成排序。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当我们将某个元素描述为比另一个元素“大”或“小”时，并不一定意味着这些元素是整数，我们可以自定义对象，并根据选择的任何属性进行排序。\u003c/p\u003e\n\u003cp\u003e假设有一个自定义类\u003ccode\u003ePerson\u003c/code\u003e，每个实例都有\u003ccode\u003ename\u003c/code\u003e和\u003ccode\u003eage\u003c/code\u003e属性，我们可以按姓名（词典顺序）或按年龄（升序或降序）进行排序。\u003c/p\u003e\n\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E6%9D%BE%E5%85%A5%E9%97%A8_20200122130623.png\" style=\"zoom:67%;\" align=\"middle\"/\u003e\n\n\u003ch2 id=\"快速排序算法的原理\"\u003e\u003ca href=\"#快速排序算法的原理\" class=\"headerlink\" title=\"快速排序算法的原理\"\u003e\u003c/a\u003e快速排序算法的原理\u003c/h2\u003e\u003cp\u003e对于快速排序算法，很多时候，数组是不能等分的，这是因为整个过程取决于如何选择主元。我们需要选择一个主元，使其比一半的元素大，比另一半的元素小。尽管这个过程看起来很直观，但很难做到。\u003c/p\u003e\n\u003cp\u003e想一想：如何为数组选择合适的主元？关于这个问题的解决方法，在快速排序算法的发展史上有过好多种。如果随机选择，是行不通的，因为这不能保障主元是合适的，随机选择的代价会非常“昂贵”。此外，还曾经有人提出从中间选择一个元元素，或者选择第一个、或者后半部分中间的，设置用更复杂的递归公式选择，等等。\u003c/p\u003e\n\u003cp\u003e最直接的最简单的方法是选择第一个（或最后一个）元素作为主元，具有讽刺意味的是，这会导致快速排序法对已经排序（或几乎排序了）的数组执行效果非常糟糕。\u003c/p\u003e\n\u003cp\u003e但是，大多数人还是用这种方法来实现快速排序算法，因为它很简单，而且这种选择主元的方式是一种非常有效的操作（我们需要重复执行），这也正是我们下面要做的。\u003c/p\u003e\n\u003cp\u003e既然我们选择了一个主元，接下来该用它做些什么？同样，有几种方法可以处理各个分区。我们要设置三个指针，有一个指向主元，另外两个分别指向“较小”元素和“较大”元素。\u003c/p\u003e\n\u003cp\u003e然后移动元素，使所有小于主元的元素都在左侧，而所有较大的元素都在右侧。更小或更大的元素不一定会被排序，我们只希望它们位于主元的适当的一侧。然后，用递归方法遍历主元的左侧和右侧。\u003c/p\u003e\n\u003cp\u003e一步一步来看看我们计划要做的事情，从而理解以上所说的快速排序算法的执行过程。使用下面显示的数组，我们选择了第一个元素作为主元（29），low表示指向较小元素的指针，最右边的high表示指向较大元素的指针。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e29是第一主元，low指向99，high指向44\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e29 | 99 (low),27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,21,44 (high)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ehigh从右向左移动，直到找到一个小于主元的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e29 | 99 (low),27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,21 (high),44\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e现在high指向了21，它是一个比主元小的元素，我们想在数组的开头附近找到一个值，使之可以用于与21交换。用一个比主元还小的值交换是没有意义的，所以如果low指向一个更小的元素，我们试着找到一个更大的元素。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e将low变量向右移动，直到找到一个大于主元的元素。幸运的是，low已经定位在99，它就比主元大\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e交换high和low指向的元素：\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e29 | 21 (low),27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,99 (high),44\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003e在我们这样做之后，就将high继续向左移动，将low向右边移动（21和99现在所处的位置是正确的）。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e再次，将high向左移动，下一个数字就是小于主元的12。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003e现在我们通过将low向右移动来找一个大于主元的值，就是41了，它是第一个这样的值\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不断重复上述过程，直到low指针和high指针最终在某个元素相遇：\u003c/p\u003e\n\u003cp\u003e29 | 21,27,12,19,28 (low/high),44,78,87,66,31,76,58,88,83,97,41,99,44\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不再使用29作为主元了，所以剩下唯一要做的就是交换主元和high所指元素28，然后我们就完成了这个递归步骤：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e28,21,27,12,19,29,44,78,87,66,31,76,58,88,83,97,41,99,44\u003c/p\u003e\n\u003cp\u003e如你所见，我们已经让小于29的所有值现在都在29的左侧，大于29的所有值都在右侧。\u003c/p\u003e\n\u003cp\u003e然后，算法对28、21、27、12、19（左侧）集合和44、78、87、66、31、76、58、88、83、97、41、99、44（右侧）集合执行相同的操作。\u003c/p\u003e\n\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/Django2%E7%AB%8B%E4%BD%93%E5%9B%BE_20200117164816.png\" style=\"zoom:67%;\"/\u003e\n\n\u003ch2 id=\"实现\"\u003e\u003ca href=\"#实现\" class=\"headerlink\" title=\"实现\"\u003e\u003c/a\u003e实现\u003c/h2\u003e\u003ch3 id=\"对数组排序\"\u003e\u003ca href=\"#对数组排序\" class=\"headerlink\" title=\"对数组排序\"\u003e\u003c/a\u003e对数组排序\u003c/h3\u003e\u003cp\u003e快速排序是一种自然递归算法，将输入数组分成较小的数组，将元素移动到主元的适当一侧，然后重复。\u003c/p\u003e\n\u003cp\u003e让我们来看看几个递归调用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当第一次调用算法时，我们考虑所有的元素——从索引0到n-1，其中n是数组中的元素数量。\u003c/li\u003e\n\u003cli\u003e如果主元最终位于位置k，那么我们将对从0到k-1和从k+1到n-1的元素重复该过程。\u003c/li\u003e\n\u003cli\u003e在将元素从k+1排到n-1时，当前主元将在某个位置p结束。然后我们将元素从k+1序到p-1，从p+1排序到n-1，依此类推。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e也就是说，我们将使用两个函数： \u003ccode\u003epartition()\u003c/code\u003e和\u003ccode\u003equick_sort()\u003c/code\u003e。\u003ccode\u003equick_sort()\u003c/code\u003e函数将首先用\u003ccode\u003epartition()\u003c/code\u003e函数对集合分组，然后在每组上递归调用自己。\u003c/p\u003e\n\u003cp\u003e下面从\u003ccode\u003epartition()\u003c/code\u003e函数开始：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e30\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef partition(array, start, end):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    pivot = array[start]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    low = start + 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    high = end\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    while True:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # If the current value we\u0026#39;re looking at is larger than the pivot\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # it\u0026#39;s in the right place (right side of pivot) and we can move left,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # to the next element.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # We also need to make sure we haven\u0026#39;t surpassed the low pointer, since that\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # indicates we have already moved all the elements to their correct side of the pivot\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        while low \u0026lt;= high and array[high] \u0026gt;= pivot:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            high = high - 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # Opposite process of the one above\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        while low \u0026lt;= high and array[low] \u0026lt;= pivot:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            low = low + 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # We either found a value for both high and low that is out of order\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        # or low is higher than high, in which case we exit the loop\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        if low \u0026lt;= high:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            array[low], array[high] = array[high], array[low]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            # The loop continues\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            # We exit out of the loop\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            break\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    array[start], array[high] = array[high], array[start]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return high\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e最后，让我们实现\u003ccode\u003equick_sort()\u003c/code\u003e函数:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef quick_sort(array, start, end):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if start \u0026gt;= end:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    p = partition(array, start, end)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    quick_sort(array, start, p-1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    quick_sort(array, p+1, end)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e有了这两个函数，就可以对一个简单的数组执行\u003ccode\u003equick_sort()\u003c/code\u003e:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003earray = [29,99,27,41,66,28,44,78,87,19,31,76,58,88,83,97,12,21,44]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003equick_sort(array, 0, len(array) - 1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(array)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[12, 19, 21, 27, 28, 29, 31, 41, 44, 44, 58, 66, 76, 78, 83, 87, 88, 97, 99]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e由于此算法是非稳定的，所以不能保证这两个44的顺序总是这样的，也许会交换 —— 虽然这在整数数组中意义不大。\u003c/p\u003e\n\u003ch3 id=\"对自定义对象进行排序\"\u003e\u003ca href=\"#对自定义对象进行排序\" class=\"headerlink\" title=\"对自定义对象进行排序\"\u003e\u003c/a\u003e对自定义对象进行排序\u003c/h3\u003e\u003cp\u003e有几种方法可以重写此算法，以便在Python中对自定义对象进行排序。一种非常典型的Python方法是实现给定类的比较运算符，这意味着我们实际上不需要更改算法实现，因为\u003ccode\u003e\u0026gt;\u003c/code\u003e、\u003ccode\u003e=\u003c/code\u003e、\u003ccode\u003e\u0026lt;=\u003c/code\u003e等也可以应用于类对象。\u003c/p\u003e\n\u003cp\u003e另一个选择是以参数的方式给函数传入一个比较函数，用这个方法来执行对象的实际比较。用这种方式重写算法函数以用于自定义对象是相当简单的。但是请记住，算法并不稳定。\u003c/p\u003e\n\u003cp\u003e让我们从\u003ccode\u003ePerson\u003c/code\u003e类开始：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eclass Person:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __init__(self, name, age):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.name = name\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.age = age\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __str__(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return self.name\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这是一个非常基本的类，只有两个属性，\u003ccode\u003ename\u003c/code\u003e和\u003ccode\u003eage\u003c/code\u003e。我们希望使用\u003ccode\u003eage\u003c/code\u003e作为排序键，这将通过为排序算法提供自定义lambda函数来实现。\u003c/p\u003e\n\u003cp\u003e但首先，让我们看看如何在函数中实现算法。我们没有直接使用\u003ccode\u003e\u0026lt;=\u003c/code\u003e或\u003ccode\u003e\u0026gt;=\u003c/code\u003e运算符进行比较，而是在函数中来判断哪个\u003ccode\u003ePerson\u003c/code\u003e实例的年龄更高：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef partition(array, start, end, compare_func):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    pivot = array[start]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    low = start + 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    high = end\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    while True:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        while low \u0026lt;= high and compare_fun(array[high], pivot):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            high = high - 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        while low \u0026lt;= high and not compare_fun(array[low], pivot):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            low = low + 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        if low \u0026lt;= high:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            array[low], array[high] = array[high], array[low]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            break\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    array[start], array[high] = array[high], array[start]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return high\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef quick_sort(array, start, end, compare_func):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if start \u0026gt;= end:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    p = partition(array, start, end, compare_func)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    quick_sort(array, start, p-1, compare_func)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    quick_sort(array, p+1, end, compare_func)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e现在，让我们对这些实例对象的集合进行排序。你可以看到，在\u003ccode\u003equick_sort\u003c/code\u003e函数的参数中，有lambda函数，它会对\u003ccode\u003eage\u003c/code\u003e属性的值进行实际的比较:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ep1 = Person(\u0026#34;Dave\u0026#34;, 21)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ep2 = Person(\u0026#34;Jane\u0026#34;, 58)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ep3 = Person(\u0026#34;Matthew\u0026#34;, 43)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ep4 = Person(\u0026#34;Mike\u0026#34;, 21)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ep5 = Person(\u0026#34;Tim\u0026#34;, 10)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003earray = [p1,p2,p3,p4,p5]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003equick_sort(array, 0, len(array) - 1, lambda x, y: x.age \u0026lt; y.age)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efor person in array:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    print(person)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出是:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eTim\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eDave\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMike\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eMatthew\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eJane\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e通过这种方式实现算法，只要提供适当的比较函数，它就可以用于我们选择的任何自定义对象。\u003c/p\u003e\n\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/my_book4_20200116132005.png\" style=\"zoom:67%;\"/\u003e\n\n\u003ch2 id=\"优化快速排序算法\"\u003e\u003ca href=\"#优化快速排序算法\" class=\"headerlink\" title=\"优化快速排序算法\"\u003e\u003c/a\u003e优化快速排序算法\u003c/h2\u003e\u003cp\u003e考虑到快速排序独立地对给定数组的“一半”进行排序，那么它就非常便于实现并行计算。我们可以用一个单独的线程对数组的每个“一半”进行排序，理想情况下，可以将排序所需的时间减半。\u003c/p\u003e\n\u003cp\u003e但是，如果我们在选择主元时特别不走运，快速排序法可能会递归太深，此时即使用并行计算，其效率也不如归并排序。\u003c/p\u003e\n\u003cp\u003e对小数组进行排序时，建议使用非递归算法。即使是像插入排序这样的简单操作，在小数组上也比快速排序更有效。因此，理想情况下，我们可以检查排序对象是否只有少量元素（大多数建议是10个或更少），如果是这样，就用插入排序代替。\u003c/p\u003e\n\u003cp\u003e快速排序的一个流行变体是多主元快速排序，它使用n-1个主元将原始数组分解为n个较小的数组。然而，大多数情况下只使用两个主元，而不是更多。\u003c/p\u003e\n\u003cp\u003e有趣的事实：Java 7的排序实现中使用了双主元快速排序，针对较小数组的则是插入排序。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca href=\"#结论\" class=\"headerlink\" title=\"结论\"\u003e\u003c/a\u003e结论\u003c/h2\u003e\u003cp\u003e正如我们前面提到的，快速排序的效率很大程度上取决于主元的选择——它可以成就或突破算法时间（和堆栈空间）的复杂度。在使用自定义对象时，算法的非稳定性也是一个潜在的问题。\u003c/p\u003e\n\u003cp\u003e然而，尽管如此，快速排序的平均时间复杂度O(nlogn)和相对低的内存使用、简单的实现方法，使它成为一种非常有效和流行的算法。\u003c/p\u003e\n\u003cp\u003e如果你想了解更多信息，请参阅微信公众号“老齐教室”发布相关排序算法的系列文章。\u003c/p\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://stackabuse.com/quicksort-in-python/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackabuse.com/quicksort-in-python/\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关注微信公众号：老齐教室。读深度文章，得精湛技艺，享绚丽人生。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#算法 快速排序 QuickSort 排序\"\u003e\n    \u003cspan class=\"tag-code\"\u003e算法 快速排序 QuickSort 排序\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/02/01/%E5%B0%8F%E8%8D%B7%E6%89%8D%E9%9C%B2%E5%B0%96%E5%B0%96%E8%A7%92/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          小荷才露尖尖角\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/02/05/speed-python/\"\u003e\n        \n          让Python程序轻松加速的方法\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-02-04T00:00:00Z",
  "Author": "老齐教室"
}