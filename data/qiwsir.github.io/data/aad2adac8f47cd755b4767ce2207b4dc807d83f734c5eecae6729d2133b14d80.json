{
  "Source": "qiwsir.github.io",
  "Title": "线程：概念和实现（2）",
  "Link": "https://qiwsir.github.io/2020/02/16/python-thread-two/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e线程：概念和实现（2）\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-02-16\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003cp\u003e译者注：与本文相关图书推荐：《Python大学实用教程》《跟老齐学Python：轻松入门》\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E6%9D%BE%E5%85%A5%E9%97%A8_20200122130623.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/my_book4_20200116132005.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003ch1 id=\"第二部分\"\u003e\u003ca href=\"#第二部分\" class=\"headerlink\" title=\"第二部分\"\u003e\u003c/a\u003e第二部分\u003c/h1\u003e\u003ch2 id=\"竞态条件\"\u003e\u003ca href=\"#竞态条件\" class=\"headerlink\" title=\"竞态条件\"\u003e\u003c/a\u003e竞态条件\u003c/h2\u003e\u003cp\u003e在讨论Python线程的其他特性之前，让我们先讨论一下编写线程程序时遇到的一个更困难的问题：竞态条件。\u003c/p\u003e\n\u003cp\u003e一旦你了解了什么是竞态条件，并看到了正在发生的情况，然后就使用标准库提供的模块，以防止这些竞态条件的出现。\u003c/p\u003e\n\u003cp\u003e当两个或多个线程访问共享数据或资源时，可能会出现竞态情况。在本例中，你将创建一个每次都发生的大型竞态条件，但请注意，大多数它并不是很明显。示例中的情况通常很少发生，而且会产生令人困惑的结果。可以想象，因为竞态条件而引起的bug很难被发现。\u003c/p\u003e\n\u003cp\u003e幸运的是，在下述示例中竞态问题每次都会发生，你将详细地了解它以便解释发生了什么。\u003c/p\u003e\n\u003cp\u003e对于本例，将编写一个更新数据库的类。你不会真的有一个数据库：你只是要伪造它，因为这不是本文的重点。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFakeDatabase\u003c/code\u003e类中有\u003ccode\u003e.__init__()\u003c/code\u003e 和 \u003ccode\u003e.update()\u003c/code\u003e方法：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eclass FakeDatabase:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __init__(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.value = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def update(self, name):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Thread %s: starting update\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        local_copy = self.value\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        local_copy += 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        time.sleep(0.1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.value = local_copy\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Thread %s: finishing update\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eFakeDatabase\u003c/code\u003e中的属性\u003ccode\u003e.value\u003c/code\u003e，用于作为竞态条件中共享的数据。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.__init__()\u003c/code\u003e中将\u003ccode\u003e.value\u003c/code\u003e值初始化为\u003ccode\u003e0.\u003c/code\u003e，到目前为止，一切正常。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.update()\u003c/code\u003e 看起来有点奇怪，它模拟从数据库中读取一个值，对其进行一些计算，然后将一个新值写回数据库。\u003c/p\u003e\n\u003cp\u003e所谓从数据库中读取，即将\u003ccode\u003e.value\u003c/code\u003e的值复制到本地变量。计算就是在原值上加1，然后\u003ccode\u003e.sleep()\u003c/code\u003e 一小会儿。最后，它通过将本地值复制回\u003ccode\u003e.value\u003c/code\u003e，将值写回去。\u003c/p\u003e\n\u003cp\u003e下面是\u003ccode\u003eFakeDatabase\u003c/code\u003e的使用方法：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#34;__main__\u0026#34;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    format = \u0026#34;%(asctime)s: %(message)s\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.basicConfig(format=format, level=logging.INFO,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e                        datefmt=\u0026#34;%H:%M:%S\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    database = FakeDatabase()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Testing update. Starting value is %d.\u0026#34;, database.value)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for index in range(2):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            executor.submit(database.update, index)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    logging.info(\u0026#34;Testing update. Ending value is %d.\u0026#34;, database.value)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e程序中创建了两个\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e，然后对每个线程调用\u003ccode\u003e.submit()\u003c/code\u003e，告诉它们运行\u003ccode\u003edatabase.update()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e.submit()\u003c/code\u003e有一个明显特征，它允许将位置参数和命名参数传给线程中运行的函数:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e.submit(function, *args, **kwargs)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上面的用法中，\u003ccode\u003eindex\u003c/code\u003e作为第一个也是唯一一个位置参数传给\u003ccode\u003edatabase.update()\u003c/code\u003e。你将在本文后面看到，可以用类似的方式传多个参数。\u003c/p\u003e\n\u003cp\u003e由于每个线程都运行\u003ccode\u003e.update()\u003c/code\u003e，而\u003ccode\u003e.update()\u003c/code\u003e会让\u003ccode\u003e.value\u003c/code\u003e的值加1，因此在最后打印时，你可能会希望\u003ccode\u003edatabase.value\u003c/code\u003e为2。但如果是这样的话，你就不会看这个例子了。如果运行上述代码，则输出如下：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./racecond.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting unlocked update. Starting value is 0.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting unlocked update. Ending value is 1.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e你可能已经预料到这种情况会发生，但是让我们来看看实际情况的细节，因为这将使这个问题的解决方案更容易理解。\u003c/p\u003e\n\u003ch3 id=\"单线程\"\u003e\u003ca href=\"#单线程\" class=\"headerlink\" title=\"单线程\"\u003e\u003c/a\u003e单线程\u003c/h3\u003e\u003cp\u003e在用两个线程深入讨论这个问题之前，让我们先退一步，谈谈线程工作流程的一些细节。\u003c/p\u003e\n\u003cp\u003e我们不会在这里深入讨论所有的细节，因为这种全面深入的讨论现在并不重要。我们还将简化一些事情，这种做法虽然在技术上并不准确，但会让你对正在发生的事情有正确的认识。\u003c/p\u003e\n\u003cp\u003e当你告诉\u003ccode\u003eThreadPoolExecutor\u003c/code\u003e运行每个线程时，也就是告诉它要运行哪个函数以及要传给它的参数：\u003ccode\u003eexecutor.submit(database.update, index)\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e其结果是线程池中的每个线程都将调用\u003ccode\u003edatabase.update(index)\u003c/code\u003e。注意，\u003ccode\u003edatabase\u003c/code\u003e是\u003ccode\u003e__main__\u003c/code\u003e中创建的\u003ccode\u003eFakeDatabase\u003c/code\u003e实例对象，调用它的方法\u003ccode\u003e.update()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e每个线程都将引用同一个\u003ccode\u003eFakeDatabase\u003c/code\u003e的实例\u003ccode\u003edatabase\u003c/code\u003e，每个线程还将有一个唯一的值\u003ccode\u003eindex\u003c/code\u003e。为了让上述过程更容易理解，请看下图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/intro-threading-shared-database_20200215134649.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e当某线程开始运行\u003ccode\u003e.update()\u003c/code\u003e时，它有此方法的本地的数据，即\u003ccode\u003e.update()\u003c/code\u003e中的\u003ccode\u003elocal_copy\u003c/code\u003e。这绝对是件好事，否则，在两个线程中运行同一个函数就会互相干扰了。这意味着该函数的所有作用域（或本地）变量对于线程来说都是安全的。\u003c/p\u003e\n\u003cp\u003e现在，你已经理解，如果使用单个线程和对\u003ccode\u003e.update()\u003c/code\u003e的单个调用来运行上面的程序会发生什么情况。\u003c/p\u003e\n\u003cp\u003e如果只运行一个线程，如下图所示，会一步一步地执行\u003ccode\u003e.update()\u003c/code\u003e。下图中，语句显示在上面，下面用图示方式演示了线程中的\u003ccode\u003elocal_value\u003c/code\u003e和共享的\u003ccode\u003edatabase.value\u003c/code\u003e 中的值的变化:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/intro-threading-single-thread_20200215134746.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e按照时间顺序，从上到下观察上面的示意图，从创建线程\u003ccode\u003eThread 1\u003c/code\u003e开始，到\u003ccode\u003eThread 1\u003c/code\u003e结束终止。\u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eThread 1\u003c/code\u003e启动时，\u003ccode\u003eFakeDatabase.value\u003c/code\u003e为零。方法中的第一行代码\u003ccode\u003elocal_copy=self.value\u003c/code\u003e将0复制到局部变量。接下来，使用\u003ccode\u003elocal_copy+=1\u003c/code\u003e语句增加\u003ccode\u003elocal_copy\u003c/code\u003e的值。你可以看到\u003ccode\u003eThread 1\u003c/code\u003e中的\u003ccode\u003e.value\u003c/code\u003e值为1。\u003c/p\u003e\n\u003cp\u003e然后，调用下一个\u003ccode\u003etime.sleep()\u003c/code\u003e，这将使当前线程暂停并允许其他线程运行。因为在这个例子中只有一个线程，所以这没有影响。\u003c/p\u003e\n\u003cp\u003e当\u003ccode\u003eThread 1\u003c/code\u003e唤醒并继续时，它将新值从\u003ccode\u003elocal_copy\u003c/code\u003e复制到\u003ccode\u003eFakeDatabase.value\u003c/code\u003e，然后线程完成。你可以看到\u003ccode\u003edatabase.value\u003c/code\u003e为1。\u003c/p\u003e\n\u003cp\u003e到目前为止，一切正常。你只运行了一次\u003ccode\u003e.update()\u003c/code\u003e并且将\u003ccode\u003eFakeDatabase.value\u003c/code\u003e递增为1。\u003c/p\u003e\n\u003ch3 id=\"两个线程\"\u003e\u003ca href=\"#两个线程\" class=\"headerlink\" title=\"两个线程\"\u003e\u003c/a\u003e两个线程\u003c/h3\u003e\u003cp\u003e回到竞态条件，两个线程并行，但不是同时运行。每个线程都有自己的\u003ccode\u003elocal_copy\u003c/code\u003e，并指向相同的\u003ccode\u003edatabase\u003c/code\u003e，正是这个共享数据库对象导致了这些问题。\u003c/p\u003e\n\u003cp\u003e程序还是从\u003ccode\u003eThread 1\u003c/code\u003e执行\u003ccode\u003e.update()\u003c/code\u003e开始:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/intro-threading-two-threads-part1_20200215134844.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e当\u003ccode\u003eThread 1\u003c/code\u003e调用\u003ccode\u003etime.sleep()\u003c/code\u003e时，它允许另一个线程开始运行。这就是事情变得有趣的地方。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eThread 2\u003c/code\u003e启动并执行相同的操作。它也将\u003ccode\u003edatabase.value\u003c/code\u003e复制到其私有的\u003ccode\u003elocal_copy\u003c/code\u003e，而此时共享的\u003ccode\u003edatabase.value\u003c/code\u003e尚未更新：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/intro-threading-two-threads-part2_20200215135535.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e当\u003ccode\u003eThread 1\u003c/code\u003e进入睡眠状态时，共享的\u003ccode\u003edatabase.value\u003c/code\u003e仍然未被修改，还是0，而此时的\u003ccode\u003elocal_copy\u003c/code\u003e的两个私有版本的值都为1。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eThread 1\u003c/code\u003e现在醒来并保存其\u003ccode\u003elocal_copy\u003c/code\u003e的值，然后线程终止，给\u003ccode\u003eThread 2\u003c/code\u003e机会。\u003ccode\u003eThread 2\u003c/code\u003e不知道在它睡眠时\u003ccode\u003eThread 1\u003c/code\u003e运行并更新了\u003ccode\u003edatabase.value\u003c/code\u003e的值。\u003ccode\u003eThread 2\u003c/code\u003e也将它的\u003ccode\u003elocal_copy\u003c/code\u003e值存储到\u003ccode\u003edatabase.value\u003c/code\u003e中，并将其设置为1：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/intro-threading-two-threads-part3_20200215135631.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e这两个线程交替访问一个共享对象，覆盖彼此的结果。当一个线程释放内存或在另一个线程完成访问之前关闭文件句柄时，可能会出现类似的竞态。\u003c/p\u003e\n\u003ch3 id=\"为什么这不是一个愚蠢的示例\"\u003e\u003ca href=\"#为什么这不是一个愚蠢的示例\" class=\"headerlink\" title=\"为什么这不是一个愚蠢的示例\"\u003e\u003c/a\u003e为什么这不是一个愚蠢的示例\u003c/h3\u003e\u003cp\u003e上面的例子是刻意而为，目的是确保每次运行程序时都会发生竞态。因为操作系统可以在任何时候交换线程，所以在读取\u003ccode\u003ex\u003c/code\u003e的值之后，并且在写回递增的值之前，可以中断类似\u003ccode\u003ex=x+1\u003c/code\u003e的语句。\u003c/p\u003e\n\u003cp\u003e发生这种情况的原因细节非常有趣，但这篇文章的其余部分并不需要这些细节，所以可以跳过这个隐藏的部分。\u003c/p\u003e\n\u003cp\u003e既然你已经看到了运行过程中的竞态条件，让我们找出解决问题的方法！\u003c/p\u003e\n\u003ch2 id=\"使用锁实现同步\"\u003e\u003ca href=\"#使用锁实现同步\" class=\"headerlink\" title=\"使用锁实现同步\"\u003e\u003c/a\u003e使用锁实现同步\u003c/h2\u003e\u003cp\u003e有很多方法可以避免或解决竞态。你不会在这里看到所有这些方法，但是有一些方法是经常使用的。让我们从\u003ccode\u003eLock\u003c/code\u003e开始。\u003c/p\u003e\n\u003cp\u003e要解决上述竞态条件，需要找到一种方法，使得在代码的“读-修改-写”操作中一次只允许一个线程。最常见的方法是使用Python中名为\u003ccode\u003eLock\u003c/code\u003e的方法。在其他的一些语言中，类似的被称为\u003ccode\u003eMutex\u003c/code\u003e，\u003ccode\u003eMutex\u003c/code\u003e源于MUTual EXclusion，这正是\u003ccode\u003eLock\u003c/code\u003e的作用。\u003c/p\u003e\n\u003cp\u003e \u003ccode\u003eLock\u003c/code\u003e像是通行证，一次只能有一个线程拥有\u003ccode\u003eLock\u003c/code\u003e，任何其他想要\u003ccode\u003eLock\u003c/code\u003e的线程都必须等到\u003ccode\u003eLock\u003c/code\u003e的所有者放弃它。\u003c/p\u003e\n\u003cp\u003e执行此操作的基本函数是\u003ccode\u003e.acquire()\u003c/code\u003e 和 \u003ccode\u003e.release()\u003c/code\u003e。线程将调用\u003ccode\u003emy_lock.acquire()\u003c/code\u003e来获取自己的锁。如果锁已经被其他线程所有，则将等待它被释放。这里有一点很重要，如果一个线程得到了锁，但尚未返回，你的程序将被卡住。你稍后会读到更多关于这方面的内容。\u003c/p\u003e\n\u003cp\u003e幸运的是，Python的\u003ccode\u003eLock\u003c/code\u003e也将作为上下文管理器运行，因此你可以在一个带有with的语句中使用它，并且当with代码块由于任何原因退出时，锁也会自动释放。\u003c/p\u003e\n\u003cp\u003e让我们看看添加了锁的\u003ccode\u003eFakeDatabase\u003c/code\u003e，其所调用函数保持不变：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eclass FakeDatabase:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __init__(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.value = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self._lock = threading.Lock()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def locked_update(self, name):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Thread %s: starting update\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.debug(\u0026#34;Thread %s about to lock\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        with self._lock:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            logging.debug(\u0026#34;Thread %s has lock\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            local_copy = self.value\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            local_copy += 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            time.sleep(0.1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            self.value = local_copy\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            logging.debug(\u0026#34;Thread %s about to release lock\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.debug(\u0026#34;Thread %s after release\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        logging.info(\u0026#34;Thread %s: finishing update\u0026#34;, name)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e除了添加一堆调试日志以便更清楚地看到锁操作之外，这里的大变化是添加一个名为\u003ccode\u003e._lock\u003c/code\u003e的属性，它是一个\u003ccode\u003ethreading.Lock()\u003c/code\u003e实例对象。这个\u003ccode\u003e._lock\u003c/code\u003e在未锁定状态下初始化，并由with语句锁定和释放。\u003c/p\u003e\n\u003cp\u003e这里值得注意的是，运行此方法的线程将一直保持\u003ccode\u003eLock\u003c/code\u003e，直到完全完成对数据库的更新。在这种情况下，这意味着函数将在复制、更新、休眠时保持锁定，然后将值写回数据库。\u003c/p\u003e\n\u003cp\u003e如果在日志记录设置为警告级别的情况下运行此版本，你将看到以下内容：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./fixrace.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting locked update. Starting value is 0.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting locked update. Ending value is 2.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e看看这个。你的程序终于成功了！\u003c/p\u003e\n\u003cp\u003e在\u003ccode\u003e__main__\u003c/code\u003e中配置日志输出后，可以通过添加以下语句将级别设置为\u003ccode\u003eDEBUG\u003c/code\u003e来打开完整日志记录：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003elogging.getLogger().setLevel(logging.DEBUG)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在启用\u003ccode\u003eDEBUG\u003c/code\u003e后，运行此程序，如下所示：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e$ ./fixrace.py\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting locked update. Starting value is 0.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0 about to lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0 has lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: starting update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1 about to lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0 about to release lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0 after release\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 0: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1 has lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1 about to release lock\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1 after release\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eThread 1: finishing update\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTesting locked update. Ending value is 2.\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在输出中，你可以看到\u003ccode\u003eThread 0\u003c/code\u003e得到了锁，并在进入睡眠状态时仍保持锁定。然后\u003ccode\u003eThread 1\u003c/code\u003e启动并尝试获取相同的锁。因为\u003ccode\u003eThread 0\u003c/code\u003e仍在持有锁，\u003ccode\u003eThread 1\u003c/code\u003e必须等待。这就是\u003ccode\u003eLock\u003c/code\u003e的互斥性。\u003c/p\u003e\n\u003cp\u003e本文其余部分中的许多示例将日志设置为\u003ccode\u003eWARNING\u003c/code\u003e和\u003ccode\u003eDEBUG\u003c/code\u003e级别。我们通常只是\u003ccode\u003eDEBUG\u003c/code\u003e级别的输出，因为\u003ccode\u003eDEBUG\u003c/code\u003e日志可能非常长。在日志记录打开的情况下尝试这些程序，看看它们能做什么。\u003c/p\u003e\n\u003ch2 id=\"死锁\"\u003e\u003ca href=\"#死锁\" class=\"headerlink\" title=\"死锁\"\u003e\u003c/a\u003e死锁\u003c/h2\u003e\u003cp\u003e在继续探索之前，应该先看看使用锁时的一个常见问题。如你所见，如果已经获取了\u003ccode\u003eLock\u003c/code\u003e，则对\u003ccode\u003e.acquire()\u003c/code\u003e的二次调用将等到持有\u003ccode\u003eLock\u003c/code\u003e的线程调用\u003ccode\u003e.release()\u003c/code\u003e。运行此代码时，你认为会发生什么情况？\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport threading\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003el = threading.Lock()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;before first acquire\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003el.acquire()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;before second acquire\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003el.acquire()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#34;acquired lock twice\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e当程序第二次调用\u003ccode\u003el.acquire()\u003c/code\u003e时，该函数将挂起，等待\u003ccode\u003eLock\u003c/code\u003e的释放。在本例中，可以通过删除第二次调用来修复死锁，但死锁通常发生在以下两个微妙的事情之一：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e未正确释放\u003ccode\u003eLock\u003c/code\u003e的错误。\u003c/li\u003e\n\u003cli\u003e设计问题，其中一个函数需要由某些函数调用，这些函数可能具有或可能不具有\u003ccode\u003eLock\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e第一种情况有时会发生，但使用\u003ccode\u003eLock\u003c/code\u003e作为上下文管理器会大大减少错误出现的频率。建议尽可能使用上下文管理器编写代码，因为它们有助于避免异常跳过\u003ccode\u003e.release()\u003c/code\u003e调用的情况。\u003c/p\u003e\n\u003cp\u003e在某些语言中，设计问题可能要复杂一些。值得庆幸的是，Python线程的又一个对象\u003ccode\u003eRLock\u003c/code\u003e就是为这种情况而设计的。它允许线程在调用\u003ccode\u003e.release()\u003c/code\u003e之前多次通过\u003ccode\u003e.acquire()\u003c/code\u003e实现\u003ccode\u003eRLock\u003c/code\u003e。该线程中调用\u003ccode\u003e.release()\u003c/code\u003e的次数与调用\u003ccode\u003e.acquire()\u003c/code\u003e的次数相同。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eLock\u003c/code\u003e和\u003ccode\u003eRLock\u003c/code\u003e是线程中用来防止竞态条件的两个基本工具，还有一些其他工具以不同的方式发挥作用。在你查看它们之前，让我们转到一个稍微不同的问题上。\u003c/p\u003e\n\u003cp\u003e（\u003cstrong\u003e未完待续\u003c/strong\u003e）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://itdiffer.com/2020/02/14/python-thread-one/\" target=\"_blank\" rel=\"noopener\"\u003e线程：概念和实现（1）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://realpython.com/intro-to-python-threading/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://realpython.com/intro-to-python-threading/\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关注微信公众号：老齐教室。读深度文章，得精湛技艺，享绚丽人生。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#python 线程\"\u003e\n    \u003cspan class=\"tag-code\"\u003epython 线程\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/02/15/crawler-nCon-2019/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          【公开课】用网络爬虫技术获取新冠病毒疫情数据\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/02/18/how-programming-run/\"\u003e\n        \n          【公开课】程序是怎么跑起来的\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-02-16T00:00:00Z",
  "Author": "老齐教室"
}