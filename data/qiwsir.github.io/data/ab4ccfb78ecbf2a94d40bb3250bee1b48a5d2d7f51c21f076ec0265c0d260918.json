{
  "Source": "qiwsir.github.io",
  "Title": "How to Write Unit Tests in Python",
  "Link": "https://qiwsir.github.io/2021/03/24/unit-tests-part-1/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003eHow to Write Unit Tests in Python\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2021-03-24\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003ch1 id=\"用Python进行单元测试\"\u003e\u003ca href=\"#用Python进行单元测试\" class=\"headerlink\" title=\"用Python进行单元测试\"\u003e\u003c/a\u003e用Python进行单元测试\u003c/h1\u003e\u003cp\u003ePython编程语言，不仅仅在机器学习、数据分析等领域大放异彩，在web开发中等软件开发中，使用者也越来越多。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-3-24/1616550424499-p.jpeg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e在软件开发中，有一种被提倡的开发范式：测试驱动开发。在这种开发范式中，编写单元测试是必不可少的。如果不实施严格的测试驱动开发，编写单元测试程序也是必要的。\u003c/p\u003e\n\u003cp\u003e对于单元测试而言，最基本的模块是\u003ca href=\"https://docs.pytest.org/en/stable/\" target=\"_blank\" rel=\"noopener\"\u003epytest\u003c/a\u003e，在本文中会对这个模块给予简要介绍。此外，还有一个现在很流行的模块\u003ca href=\"https://en.wikipedia.org/wiki/Fizz_buzz\" target=\"_blank\" rel=\"noopener\"\u003efizz buzz\u003c/a\u003e，本文也会向读者推荐。\u003c/p\u003e\n\u003ch2 id=\"为什么要自动化测试\"\u003e\u003ca href=\"#为什么要自动化测试\" class=\"headerlink\" title=\"为什么要自动化测试\"\u003e\u003c/a\u003e为什么要自动化测试\u003c/h2\u003e\u003cp\u003e并非所有人都理解自动化测试的必要性，有人甚至认为纯粹是个负担，他们认为自己在编写代码的时候，就已经发现了程序中的BUG，并且已经及时修复了。\u003c/p\u003e\n\u003cp\u003e这么说，也不是完全没道理。因为我们在开发的时候，就是边写代码、边执行程序，如果有问题，肯定会及时修改。特别是对有丰富开发经验的程序员，编写的代码中错误的确很少。\u003c/p\u003e\n\u003cp\u003e不过，BUG是难免的。一般情况下，我们都使用已有的框架或者库进行开发，并非从头开始写每一行代码。还有可能是维护、修改、升级原有的功能。在这些情况下，程序中出现BUG的概率就更高了。\u003c/p\u003e\n\u003cp\u003e因此，自动化测试就不可缺少了。开发者应该将自动化测试视为代码的保险策略，防止由于增加新功能致使BUG产生。\u003c/p\u003e\n\u003cp\u003e另外一个要实施自动化测试的缘由，是因为人工测试在某些时候是难以完成对程序的所有功能测试。例如，一段程序是从第三方API那个获取一些数据，如果用人工测试，无法测试出对方服务在出现问题是程序获得的异常信息。但是，如果用自动化测试，则能轻易实现。\u003c/p\u003e\n\u003ch2 id=\"单元测试、集成测试和功能测试\"\u003e\u003ca href=\"#单元测试、集成测试和功能测试\" class=\"headerlink\" title=\"单元测试、集成测试和功能测试\"\u003e\u003c/a\u003e单元测试、集成测试和功能测试\u003c/h2\u003e\u003cp\u003e先简单罗列一下这三种测试的含义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单元测试（Unit tests）：又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法$^{[2]}$。\u003c/li\u003e\n\u003cli\u003e整合测试（Integration tests）：又称组装测试，即对程序模块采用一次性或增值方式组装起来，对系统的接口进行正确性检验的测试工作。整合测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作$^{[3]}$。 \u003c/li\u003e\n\u003cli\u003e功能测试（Functional tests）：功能测试就是对产品的各功能进行验证，根据功能测试用例，逐项测试，检查产品是否达到用户要求的功能$^{[4]}$。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如你所见，三种测试各司其职。在编写代码是，通常会用单元测试，这个更简单快捷，便于执行。所以，本文仅讨论单元测试。\u003c/p\u003e\n\u003ch2 id=\"用Python进行单元测试-1\"\u003e\u003ca href=\"#用Python进行单元测试-1\" class=\"headerlink\" title=\"用Python进行单元测试\"\u003e\u003c/a\u003e用Python进行单元测试\u003c/h2\u003e\u003cp\u003ePython中的单元测试，就是编写一个测试函数，在其中执行一小段应用程序，检验代码是否正确，如果有问题，会抛出异常。例如，函数\u003ccode\u003eforty_two()\u003c/code\u003e返回值是\u003ccode\u003e42\u003c/code\u003e，针对这个函数编写的单元测试如下：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom app import forty_two\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef test_forty_two():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    result = forty_two()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    assert result == 42\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这个例子非常简单，在实际的开发过程中会比这复杂，\u003ccode\u003eassert\u003c/code\u003e语句也可能不止一条。\u003c/p\u003e\n\u003cp\u003e要执行这个单元测试，则需将其保存为一个Python文件，然后执行该文件，就能完成测试过程。\u003c/p\u003e\n\u003cp\u003eTwo of the most popular frameworks in Python to write and run unit tests are the \u003ca href=\"https://docs.python.org/3/library/unittest.html\" target=\"_blank\" rel=\"noopener\"\u003eunittest\u003c/a\u003e package from the Python standard library and the \u003ca href=\"https://docs.pytest.org/en/stable/\" target=\"_blank\" rel=\"noopener\"\u003epytest\u003c/a\u003e package. For this series of articles I’m going to use a hybrid testing  solution that incorporates parts of both packages, as follows:\u003c/p\u003e\n\u003cp\u003e在Python中有两个非常流行的单元测试框架，一个是标准库中的\u003ca href=\"https://docs.python.org/3/library/unittest.html\" target=\"_blank\" rel=\"noopener\"\u003eunittest\u003c/a\u003e，另外一个是\u003ca href=\"https://docs.pytest.org/en/stable/\" target=\"_blank\" rel=\"noopener\"\u003epytest\u003c/a\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe object-oriented approach based on the \u003ccode\u003eTestCase\u003c/code\u003e class of the \u003ccode\u003eunittest\u003c/code\u003e package will be used to structure and organize the unit tests.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003eassert\u003c/code\u003e statement from Python will be used to write assertions. The \u003ccode\u003epytest\u003c/code\u003e package includes some enhancements to the \u003ccode\u003eassert\u003c/code\u003e statement to provide more verbose output when there is a failure.\u003c/li\u003e\n\u003cli\u003eThe \u003ccode\u003epytest\u003c/code\u003e test runner will be used to run the tests, as it is required to use the enhanced \u003ccode\u003eassert\u003c/code\u003e. This test runner has full support for the \u003ccode\u003eTestCase\u003c/code\u003e class from the \u003ccode\u003eunittest\u003c/code\u003e package.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDon’t worry if some of these things don’t make much sense yet. The examples that are coming will make it more clear.\u003c/p\u003e\n\u003ch2 id=\"Testing-a-Fizz-Buzz-Application\"\u003e\u003ca href=\"#Testing-a-Fizz-Buzz-Application\" class=\"headerlink\" title=\"Testing a Fizz Buzz Application\"\u003e\u003c/a\u003eTesting a Fizz Buzz Application\u003c/h2\u003e\u003cp\u003eThe “Fizz Buzz” game consists in counting from 1 to 100, but  replacing the numbers that are divisible by 3 with the word “Fizz”, the  ones that are divisible by 5 with “Buzz”, and the ones that are  divisible by both with “FizzBuzz”. This game is intended to help kids  learn division, but has been made into a very popular coding interview  question.\u003c/p\u003e\n\u003cp\u003eI googled for implementations of the “Fizz Buzz” problem in Python and this one came up first:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efor i in range(1, 101):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if i % 15 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(\u0026#34;FizzBuzz\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 3 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(\u0026#34;Fizz\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 5 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(\u0026#34;Buzz\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(i)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eAfter you’ve seen the \u003ccode\u003eforty_two()\u003c/code\u003e unit test example  above, testing this code seems awfully difficult, right? For starters  there is no function to call from a unit test. And nothing is returned,  the program just prints results to the screen, so how can you verify  what is printed to the terminal?\u003c/p\u003e\n\u003cp\u003eTo test this code in this original form you would need to write a  functional test that runs it, captures the output, and then ensures it  is correct. Instead of doing that, however, it is possible to refactor  the application to make it more unit testing friendly. This is an  important point that you should remember: if a piece of code proves  difficult to test in an automated way, you should consider refactoring  it so that testing becomes easier.\u003c/p\u003e\n\u003cp\u003eHere is a new version of the “Fizz Buzz” program above that is  functionally equivalent but has a more robust structure that will lend  better to writing tests for it:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef fizzbuzz(i):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if i % 15 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;FizzBuzz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 3 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;Fizz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 5 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;Buzz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return i\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef main():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for i in range(1, 101):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(fizzbuzz(i))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#39;__main__\u0026#39;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    main()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eWhat I did here is to encapsulate the main logic of the application in the \u003ccode\u003efizzbuzz()\u003c/code\u003e function. This function takes a number as input argument and returns what needs to be printed for that number, which can be \u003ccode\u003eFizz\u003c/code\u003e, \u003ccode\u003eBuzz\u003c/code\u003e, \u003ccode\u003eFizzBuzz\u003c/code\u003e or the number.\u003c/p\u003e\n\u003cp\u003eWhat’s left after that is the loop that iterates over the numbers.  Instead of leaving that in the global scope I moved it into a \u003ccode\u003emain()\u003c/code\u003e function, and then I added a standard \u003ca href=\"https://docs.python.org/3/library/__main__.html\" target=\"_blank\" rel=\"noopener\"\u003etop-level script check\u003c/a\u003e so that this function is automatically executed when the script is run  directly, but not when it is imported by another script. This is  necessary because the unit test will need to import this code.\u003c/p\u003e\n\u003cp\u003eI hope you now see that there is some hope and that testing the refactored code might be possible, after all.\u003c/p\u003e\n\u003ch3 id=\"Writing-a-test-case\"\u003e\u003ca href=\"#Writing-a-test-case\" class=\"headerlink\" title=\"Writing a test case\"\u003e\u003c/a\u003eWriting a test case\u003c/h3\u003e\u003cp\u003eSince this is going to be a hands-on exercise, copy the refactored code from the previous section and save it to a file named \u003cem\u003efizzbuzz.py\u003c/em\u003e in an empty directory in your computer. Open a terminal or command  prompt window and enter this directory. Set up a new Python virtual  environment using your favorite tool.\u003c/p\u003e\n\u003cp\u003eSince you will be using \u003ccode\u003epytest\u003c/code\u003e in a little bit, install it in your virtual environment:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pip install pytest\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThe \u003ccode\u003efizzbuzz()\u003c/code\u003e function can be tested by feeding a few  different numbers and asserting that the correct response is given for  each one. To keep things nicely organized, separate unit tests can be  written to test for “Fizz”, “Buzz” and “FizzBuzz” numbers.\u003c/p\u003e\n\u003cp\u003eHere is a \u003ccode\u003eTestCase\u003c/code\u003e class that includes a method to test for “Fizz”:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport unittest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efrom fizzbuzz import fizzbuzz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eclass TestFizzBuzz(unittest.TestCase):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [3, 6, 9, 18]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;Fizz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis has some similarities with the \u003ccode\u003eforty_two()\u003c/code\u003e unit test, but now the test is a method within a class, not a function as before. The \u003ccode\u003eunittest\u003c/code\u003e framework’s \u003ccode\u003eTestCase\u003c/code\u003e class is used as a base class to the \u003ccode\u003eTestFizzBuzz\u003c/code\u003e class. Organizing tests as methods of a test case class is useful to  keep several related tests together. The benefits are not going to be  evident with the simple application that is the testing subject in this  article, so for now you’ll have to bear with me and trust me in that  this makes it easier to write more complex unit tests.\u003c/p\u003e\n\u003cp\u003eSince testing for “Fizz” numbers can be done really quickly, the  implementation of this test runs a few numbers instead of just one, so a loop is used to go through a list of several “Fizz” numbers and  asserting that all of them are reported as such.\u003c/p\u003e\n\u003cp\u003eSave this code in a file named \u003cem\u003etest_fizzbuzz.py\u003c/em\u003e in the same directory as the main \u003cem\u003efizzbuzz.py\u003c/em\u003e file, and then type \u003ccode\u003epytest\u003c/code\u003e in your terminal:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.1.2, py-1.9.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 1 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py .                                                 [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 1 passed in 0.03s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThe \u003ccode\u003epytest\u003c/code\u003e command is smart and automatically detects unit tests. In general it will assume that any Python files named with the \u003cem\u003etest_[something].py\u003c/em\u003e or \u003cem\u003e[something]_test.py\u003c/em\u003e patterns contain unit tests. It will also look for files with this  naming patterns in subdirectories. A common way to keep unit tests  nicely organized in a larger project is to put them in a \u003cem\u003etests\u003c/em\u003e package, separately from the application source code.\u003c/p\u003e\n\u003cp\u003eIf you want to see how does a test failure looks like, edit the list  of numbers used in this test to include 4 or some other number that is  not divisible by 3. Then run \u003ccode\u003epytest\u003c/code\u003e again:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.1.2, py-1.9.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 1 item\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py F                                                 [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e================================ FAILURES ================================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e_________________________ TestFizzBuzz.test_fizz _________________________\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eself = \u0026lt;test_fizzbuzz.TestFizzBuzz testMethod=test_fizz\u0026gt;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [3, 4, 6, 9, 18]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;           assert fizzbuzz(i) == \u0026#39;Fizz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eE           AssertionError: assert 4 == \u0026#39;Fizz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eE            +  where 4 = fizzbuzz(4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py:9: AssertionError\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-------------------------- Captured stdout call --------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etesting 3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etesting 4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e======================== short test summary info =========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eFAILED test_fizzbuzz.py::TestFizzBuzz::test_fizz - AssertionError: asse...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 1 failed in 0.13s ===========================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eNote how the test stopped as soon as one of the numbers failed to  test as a “Fizz” number. To help you in figuring out exactly what part  of the test failed, \u003ccode\u003epytest\u003c/code\u003e shows you the source code lines  around the failure and the expected and actual results for the failed  assertion. It also captures any output that the test prints and includes it in the report. Above you can see that the test went through numbers 3 and 4 and that’s when the assertion for 4 failed, causing the test to  end. After you experiment with test failures revert the test to its  original passing condition.\u003c/p\u003e\n\u003cp\u003eNow that you’ve seen how “Fizz” numbers are tested, it is easy to add two more unit tests for “Buzz” and “FizzBuzz” numbers:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport unittest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efrom fizzbuzz import fizzbuzz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eclass TestFizzBuzz(unittest.TestCase):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [3, 6, 9, 18]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;Fizz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_buzz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [5, 10, 50]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;Buzz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizzbuzz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [15, 30, 75]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;FizzBuzz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eRunning \u003ccode\u003epytest\u003c/code\u003e once again now shows that there are three unit tests and that all are passing:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.1.2, py-1.9.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 3 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ...                                               [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 3 passed in 0.04s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch3 id=\"Test-Coverage\"\u003e\u003ca href=\"#Test-Coverage\" class=\"headerlink\" title=\"Test Coverage\"\u003e\u003c/a\u003eTest Coverage\u003c/h3\u003e\u003cp\u003eAre the three tests above good enough? What do you think?\u003c/p\u003e\n\u003cp\u003eWhile you are going to have to use your own judgement to decide how  much automated testing you need to have confidence that your tests give  adequate protection against failures in the future, there is one tool  called \u003cem\u003ecode coverage\u003c/em\u003e that can help you get a better picture.\u003c/p\u003e\n\u003cp\u003eCode coverage is a technique that consists in watching the code as it executes in the interpreter and keeping track of which lines run and  which do not. When code coverage is combined with unit tests, it can be  used to get a report of all the lines of code that your unit tests did  not exercise.\u003c/p\u003e\n\u003cp\u003eThere is a plugin for \u003ccode\u003epytest\u003c/code\u003e called \u003ca href=\"https://pytest-cov.readthedocs.io/en/latest/\" target=\"_blank\" rel=\"noopener\"\u003epytest-cov\u003c/a\u003e that adds code coverage support to a test run. Let’s install it into the virtual environment:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pip install pytest-cov\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThe command \u003ccode\u003epytest --cov=fizzbuzz\u003c/code\u003e runs the unit tests with code coverage tracking enabled for the \u003ccode\u003efizzbuzz\u003c/code\u003e module:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest --cov=fizzbuzz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplugins: cov-2.11.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 3 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ...                                               [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------- coverage: platform darwin, python 3.8.6-final-0 -----------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eName          Stmts   Miss  Cover\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efizzbuzz.py      13      4    69%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTOTAL            13      4    69%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 3 passed in 0.07s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eNote that when running tests with code coverage it is useful to  always limit coverage to the application module or package, which is  passed as an argument to the \u003ccode\u003e--cov\u003c/code\u003e option as seen above. If the scope is not restricted, then code coverage will apply to the  entire Python process, which will include functions from the Python  standard library and third-party dependencies, resulting in a very noisy report at the end.\u003c/p\u003e\n\u003cp\u003eWith this report you know that the three unit tests cover 69% of the \u003cem\u003efizzbuzz.py\u003c/em\u003e code. I’m sure you agree that it would be useful to know exactly what  parts of the application make up that other 31% of the code that the  tests are currently missing, right? This could help you determine what  other tests need to be written.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003epytest-cov\u003c/code\u003e plugin can generate the final report in several formats. The one you’ve seen above is the most basic one, called \u003ccode\u003eterm\u003c/code\u003e because it is printed to the terminal. A variant of this report is called \u003ccode\u003eterm-missing\u003c/code\u003e, which adds the lines of code that were not covered:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest --cov=fizzbuzz --cov-report=term-missing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplugins: cov-2.11.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 3 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ...                                               [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------- coverage: platform darwin, python 3.8.6-final-0 -----------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eName          Stmts   Miss  Cover   Missing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efizzbuzz.py      13      4    69%   9, 13-14, 18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e-------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTOTAL            13      4    69%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 3 passed in 0.07s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThe \u003ccode\u003eterm-missing\u003c/code\u003e report shows the list of line numbers that did not execute during the tests. Lines 13 and 14 are the body of the \u003ccode\u003emain()\u003c/code\u003e function, which were intentionally left out of the tests. Recall that  when I refactored the original application I decided to split the logic  into the \u003ccode\u003emain()\u003c/code\u003e and \u003ccode\u003efizzbuzz()\u003c/code\u003e functions with the intention to have the core logic in \u003ccode\u003efizzbuzz()\u003c/code\u003e to make it easy to test. There is nothing in the current tests that attempts to run the \u003ccode\u003emain()\u003c/code\u003e function, so it is expected those lines will appear as missing in terms of test coverage.\u003c/p\u003e\n\u003cp\u003eLikewise, line 18 is the last line of the application, which only runs when the \u003cem\u003efizzbuzz.py\u003c/em\u003e file is invoked as the main script, so it is also expected this line will not run during the tests.\u003c/p\u003e\n\u003cp\u003eLine 9, however, is inside the \u003ccode\u003efizzbuzz()\u003c/code\u003e function. It  looks like one aspect of the logic in this function is not currently  being tested. Can you see what it is? Line 9 is the last line of the  function, which returns the input number after it was determined that  the number isn’t divisible by 3 or by 5. This is an important case in  this application, so a unit test should be added to check for numbers  that are not “Fizz”, “Buzz” or “FizzBuzz”. \u003c/p\u003e\n\u003cp\u003eOne detail that this report isn’t still being accurate about are  lines that have conditionals in them. When you have a line with an \u003ccode\u003eif\u003c/code\u003e statement such as lines 2, 4, 6 and 17 in \u003cem\u003efizzbuzz.py\u003c/em\u003e, saying that the line is covered does not give you the full picture,  because these lines can execute in two very distinct ways based on the  condition evaluating to \u003ccode\u003eTrue\u003c/code\u003e or \u003ccode\u003eFalse\u003c/code\u003e. The  code coverage analysis can also be configured to treat lines with  conditionals as needing double coverage to account for the two possible  outcomes. This is called \u003cem\u003ebranch coverage\u003c/em\u003e and is enabled with the \u003ccode\u003e--cov-branch\u003c/code\u003e option:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest --cov=fizzbuzz --cov-report=term-missing --cov-branch\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplugins: cov-2.11.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 3 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ...                                               [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------- coverage: platform darwin, python 3.8.6-final-0 -----------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eName          Stmts   Miss Branch BrPart  Cover   Missing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efizzbuzz.py      13      4     10      2    65%   6-\u0026gt;9, 9, 13-14, 17-\u0026gt;18, 18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTOTAL            13      4     10      2    65%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 3 passed in 0.07s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eAdding branch coverage has lowered the covered percentage to 65%. And the “Missing” column not only shows lines 9, 13, 14 and 18, but also  adds those lines with conditionals that have been covered only for one  of the two possible outcomes. The \u003ccode\u003eif\u003c/code\u003e statement in line 17, which was reported as fully covered before, now appears as not been covered for the \u003ccode\u003eTrue\u003c/code\u003e case, which would move on to line 18. And the \u003ccode\u003eelif\u003c/code\u003e in line 6 is not covered for a \u003ccode\u003eFalse\u003c/code\u003e condition, where execution would jump to line 9.\u003c/p\u003e\n\u003cp\u003eAs mentioned above, a test is missing to cover numbers that are not  divisible by 3 or 5. This is evident not only because line 9 is reported as missing, but also because of the missing \u003ccode\u003e6-\u0026gt;9\u003c/code\u003e conditional. Let’s add a fourth unit test:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport unittest\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efrom fizzbuzz import fizzbuzz\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eclass TestFizzBuzz(unittest.TestCase):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [3, 6, 9, 18]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;Fizz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_buzz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [5, 10, 50]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;Buzz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_fizzbuzz(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [15, 30, 75]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == \u0026#39;FizzBuzz\u0026#39;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def test_number(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in [2, 4, 88]:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            print(\u0026#39;testing\u0026#39;, i)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            assert fizzbuzz(i) == i\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eLet’s run \u003ccode\u003epytest\u003c/code\u003e one more time to see how this new test helped improve coverage:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest --cov=fizzbuzz --cov-report=term-missing --cov-branch\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplugins: cov-2.11.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 4 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ....                                              [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------- coverage: platform darwin, python 3.8.6-final-0 -----------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eName          Stmts   Miss Branch BrPart  Cover   Missing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efizzbuzz.py      13      3     10      1    74%   13-14, 17-\u0026gt;18, 18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTOTAL            13      3     10      1    74%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 4 passed in 0.08s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis is looking much better. Coverage is now at 74%, and in particular all the lines that belong to the \u003ccode\u003efizzbuzz()\u003c/code\u003e function, which are the core logic of the application, are covered.\u003c/p\u003e\n\u003ch3 id=\"Code-Coverage-Exceptions\"\u003e\u003ca href=\"#Code-Coverage-Exceptions\" class=\"headerlink\" title=\"Code Coverage Exceptions\"\u003e\u003c/a\u003eCode Coverage Exceptions\u003c/h3\u003e\u003cp\u003eThe four unit tests now do a good job at keeping the main logic  tested, but the coverage report still shows lines 13, 14 and 18 as not  covered, plus the conditional on line 17 as partially covered.\u003c/p\u003e\n\u003cp\u003eI’m sure you will agree that lines 17 and 18 are pretty safe, so it  is an annoyance to have to see them listed in every coverage report. For cases where you as a developer make a conscious decision that a piece  of code does not need to be tested, it is possible to mark these lines  as an exception, and with that they will be counted as covered and will  not appear in coverage reports as missing. This is done by adding a  comment with the text \u003ccode\u003epragma: no cover\u003c/code\u003e to the line or lines in question. Here is the updated \u003cem\u003efizzbuzz.py\u003c/em\u003e with an exception made for lines 17 and 18:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef fizzbuzz(i):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if i % 15 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;FizzBuzz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 3 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;Fizz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    elif i % 5 == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return \u0026#34;Buzz\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return i\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef main():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for i in range(1, 101):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        print(fizzbuzz(i))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif __name__ == \u0026#39;__main__\u0026#39;:  # pragma: no cover\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    main()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eNote how the comment was only added in line 17. This is because when  an exception is added in a line that begins a control structure, it is  applied to the whole code block.\u003c/p\u003e\n\u003cp\u003eLet’s run the tests one more time:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(venv) $ pytest --cov=fizzbuzz --cov-report=term-missing --cov-branch\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e========================== test session starts ===========================\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplatform darwin -- Python 3.8.6, pytest-6.2.2, py-1.10.0, pluggy-0.13.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003erootdir: /Users/miguel/testing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplugins: cov-2.11.1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecollected 4 items\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003etest_fizzbuzz.py ....                                              [100%]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------- coverage: platform darwin, python 3.8.6-final-0 -----------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eName          Stmts   Miss Branch BrPart  Cover   Missing\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efizzbuzz.py      11      2      8      0    79%   13-14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e---------------------------------------------------------\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTOTAL            11      2      8      0    79%\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e=========================== 4 passed in 0.07s ============================\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eThis final report looks much cleaner. Should lines 13 and 14 also be  marked as exempt from coverage? That is really up to you to decide. I’m  always willing to exclude lines that I’m 100% sure I’ll never need to  test, but I’m not really sure the \u003ccode\u003emain()\u003c/code\u003e function in lines 13 and 14 falls into that category.\u003c/p\u003e\n\u003cp\u003eWriting a unit test for this function is going to be tricky because of the \u003ccode\u003eprint()\u003c/code\u003e statements, and it is definitely out of scope for this introductory  article. It is not impossible to do it, though. My preference is to  leave those lines alone, as a reminder that at some point I could figure out a good testing strategy for them. The alternative point of view  would be to say that this is a piece of code that is stable and unlikely to change, so the return of investment for writing unit tests for it is very low, and in that case it would also be okay to exempt it from code coverage. If you add an exception for lines 13 and 14 then the coverage report will show 100% code coverage.\u003c/p\u003e\n\u003ch2 id=\"Conclusion\"\u003e\u003ca href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"\u003e\u003c/a\u003eConclusion\u003c/h2\u003e\u003cp\u003eI hope this was a good introduction to unit testing in Python. In the following articles in the series I’ll be looking at testing more  complex code. My intention is to be very thorough and cover many  different types of applications and testing techniques. If you have a  particular problem related to unit testing feel free to mention it to me in the comments so that I keep it in mind for future articles!\u003c/p\u003e\n\u003ch2 id=\"参考文献\"\u003e\u003ca href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"\u003e\u003c/a\u003e参考文献\u003c/h2\u003e\u003cp\u003e[1]. \u003ca href=\"https://blog.miguelgrinberg.com/post/how-to-write-unit-tests-in-python-part-1-fizz-buzz\" target=\"_blank\" rel=\"noopener\"\u003eHow to Write Unit Tests in Python, Part 1: Fizz Buzz\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[2]. \u003ca href=\"https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\"\u003e维基百科-单元测试\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[3]. \u003ca href=\"https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\"\u003e维基百科-集成测试\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e[4]. \u003ca href=\"https://www.jianshu.com/p/7716ccc68814\" target=\"_blank\" rel=\"noopener\"\u003ehttps://www.jianshu.com/p/7716ccc68814\u003c/a\u003e\u003c/p\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2021/03/16/loop-better/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          深入理解循环和迭代\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2021/04/19/Python%E8%BF%90%E7%AE%97%E7%AC%A6/\"\u003e\n        \n          Python运算符\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2021-03-24T00:00:00Z",
  "Author": "老齐教室"
}