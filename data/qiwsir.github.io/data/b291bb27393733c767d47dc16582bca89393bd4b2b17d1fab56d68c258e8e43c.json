{
  "Source": "qiwsir.github.io",
  "Title": "Python中几种实现斐波那契数列的方法",
  "Link": "https://qiwsir.github.io/2020/03/17/fibs-seq/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003ePython中几种实现斐波那契数列的方法\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-03-17\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e作者：Elliott Saslow\u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003cp\u003e与本文相关的图书推荐：《Python大学实用教程》《跟老齐学Python：轻松入门》\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/my_book4_20200116132005.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E8%BD%BB%E6%9D%BE%E5%85%A5%E9%97%A8_20200122130623.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e众所周知，斐波那契数列是一种非常重要的数列。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e0,1,1,2,3,5,8,13,21,34,55,...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e用递归的方式，可以这样定义斐波那契数列：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/f1_20200315141435.jpeg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e按照上面的公式，可以用Python语言直接写出实现它的函数：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef fib_recursive(n):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if n == 0: return 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if n == 1: return 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else: return(fib_recursive(n-1)+fib_recursive(n-2))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e不管什么时候，我们遇到某个算法的实现，总要问一问下面的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e正确吗？正确\u003c/li\u003e\n\u003cli\u003e耗时多少？\u003c/li\u003e\n\u003cli\u003e是否可以改进？可以\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在，无需深入了解具体细节，用递归方式，属于贪心算法，需要花费大量计算步骤来完成。因此，让我们尝试使用列表来完成此操作，下面的方法可以加快处理速度并简化计算。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef fib_poly(n):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    #注意0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if n == 0:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    #用列表保存数值\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        f = np.zeros(n+1)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        f[0] = 0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        f[1] = 1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        for i in range(2,n+1):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e            f[i] = f[i-1] + f[i-2]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return f[n]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003eOk，来看看它的表现。下图显示了执行上面两个函数的所用时间比较。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/f2_20200315141544.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e哇！注意观察它们所用时间的差别！后面这个函数比前面的递归方法快多了。\u003c/p\u003e\n\u003cp\u003e下面的图示中很明显地表示了二者执行时间的差异。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/f3_20200315141622.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e哇！ 令人难以置信，递归居然如此慢。还有更快的方法呢？ 应该有：\u003c/p\u003e\n\u003cp\u003e如下所示，可以用矩阵的方法计算斐波那契数列，会更快。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/f4_20200315141707.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport numpy as np\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef fib_matrix(n):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    Matrix = np.matrix([[0,1],[1,1]])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    vec = np.array([[0],[1]])\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return np.matmul(Matrix**n,vec)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/f5_20200315141740.jpg\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e这真的很酷，在整个测试过程中，矩阵算法在几乎恒定的时间内执行。关于用矩阵实现斐波那契数列的方法，可以参考 \u003cstrong\u003e《跟老齐学Python：数据分析》\u003c/strong\u003e ，书中有相关说明。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注：\u003c/strong\u003e 此外，斐波那契数列还能够用生成器、迭代器方式实现，这些实现方法，可以到 \u003cstrong\u003e《Python大学实用教程》\u003c/strong\u003e 查阅。\u003c/p\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://medium.com/future-vision/fibonacci-sequence-algorithm-5eebae4e85be\" target=\"_blank\" rel=\"noopener\"\u003ehttps://medium.com/future-vision/fibonacci-sequence-algorithm-5eebae4e85be\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e搜索技术问答的公众号：老齐教室\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在公众号中回复：\u003cstrong\u003e老齐\u003c/strong\u003e，可查看所有文章归类。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/03/15/jupyter-introduce/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          Jupyter不断演进的三大动力\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/03/20/lasso-regression/\"\u003e\n        \n          写给初学者的LASSO回归\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-03-17T00:00:00Z",
  "Author": "老齐教室"
}