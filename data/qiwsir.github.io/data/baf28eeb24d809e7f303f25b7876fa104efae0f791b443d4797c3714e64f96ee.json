{
  "Source": "qiwsir.github.io",
  "Title": "计算相似度",
  "Link": "https://qiwsir.github.io/2021/02/06/similarity-md/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003e计算相似度\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2021-02-06\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e在机器学习中，经常要度量两个对象的相似度，例如k-最近邻算法，即通过度量数据的相似度而进行分类。在无监督学习中，K-Means算法是一种聚类算法，它通过欧几里得距离计算指定的数据点与聚类中心的距离。在推荐系统中，也会用到相似度的计算（当然还有其他方面的度量）。\u003c/p\u003e\n\u003cp\u003e本文中，将介绍业务实践中最常用的几种相似度的度量方法。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e基于相似性的度量\u003cul\u003e\n\u003cli\u003e皮尔逊相关系数\u003c/li\u003e\n\u003cli\u003e斯皮尔曼秩相关系数\u003c/li\u003e\n\u003cli\u003e肯德尔秩相关系数\u003c/li\u003e\n\u003cli\u003e余弦相似度\u003c/li\u003e\n\u003cli\u003e雅卡尔相似度\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e基于距离的度量\u003cul\u003e\n\u003cli\u003e欧几里得距离\u003c/li\u003e\n\u003cli\u003e曼哈顿距离\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"1-基于相似性的度量\"\u003e\u003ca href=\"#1-基于相似性的度量\" class=\"headerlink\" title=\"1. 基于相似性的度量\"\u003e\u003c/a\u003e1. 基于相似性的度量\u003c/h2\u003e\u003ch3 id=\"1-1-皮尔逊相关系数\"\u003e\u003ca href=\"#1-1-皮尔逊相关系数\" class=\"headerlink\" title=\"1.1 皮尔逊相关系数\"\u003e\u003c/a\u003e1.1 皮尔逊相关系数\u003c/h3\u003e\u003cp\u003e皮尔逊相关系数度量两个随机变量之间的线性关系，包括相关程度和方向。这两个随机变量可以是连续型，也可以是离散型。\u003c/p\u003e\n\u003cp\u003e计算公式如下：\u003c/p\u003e\n\u003cp\u003e$ Corr(X, Y) = \\frac{\\sum_{i=1}^n(x_i-\\overline x)(y_i - \\overline y)}{\\sqrt{\\sum_{i=1}^n(x_i-\\overline x)^2}\\sqrt{\\sum_{i=1}^n(y_i-\\overline y)^2}} $\u003c/p\u003e\n\u003cp\u003e其中，$ \\overline x = \\frac{1}{n}\\sum_{i=1}^nx_i, \\overline y = \\frac{1}{n}y_i $。\u003cbr/\u003e皮尔逊相关系数的范围在 $ [-1,1] $， -1意味着两者负相关，1代表正相关。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612581953725-x1.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e用python实现皮尔逊相关系数的计算：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport numpy as np\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efrom scipy.stats import pearsonr\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eimport matplotlib.pyplot as plt。\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# 设置随机数的种子\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003enp.random.seed(42)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# 创建随机数\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ex = np.random.randn(15)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ey = x + np.random.randn(15)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# 作图\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.scatter(x, y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.plot(np.unique(x), np.poly1d(np.polyfit(x, y, 1))(np.unique(x)))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.xlabel(\u0026#39;x\u0026#39;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.ylabel(\u0026#39;y\u0026#39;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eplt.show()\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612582133929-x2.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e# 计算皮尔逊相关系数\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecorr, _ = pearsonr(x, y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#39;Pearsons correlation: %.3f\u0026#39; % corr)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003ccode\u003ePearsons correlation: 0.810\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"1-2-斯皮尔曼秩相关系数\"\u003e\u003ca href=\"#1-2-斯皮尔曼秩相关系数\" class=\"headerlink\" title=\"1.2 斯皮尔曼秩相关系数\"\u003e\u003c/a\u003e1.2 斯皮尔曼秩相关系数\u003c/h3\u003e\u003cp\u003e斯皮尔曼秩相关系数（Spearman’s  correlation）常用于非参数统计。所谓非参数统计，即概率分布不依靠参数（常见的正态分布、二项分布等都是参数统计）。最常见的非参数统计，是统计数据的秩，而不是原始的值。斯皮尔曼秩相关系数的计算方法，与皮尔逊相关系数类似，区别就在于斯皮尔曼相关系数中使用的是数据的秩。\u003c/p\u003e\n\u003cp\u003e为了计算斯皮尔曼相关系数，我们首先需要将每个原始数据转化为等级数据，建立如下映射关系：\u003c/p\u003e\n\u003cp\u003e$ \\begin{split}X \\to X^r \\quad \u0026amp; x_i \\to x_i^r \\ Y \\to Y^r \\quad \u0026amp; x_i \\to y_i^r\\end{split} $\u003c/p\u003e\n\u003cp\u003e例如，原始数据为 [0, -5, 4, 7]，则对应的等级数据为[2, 1, 3, 4]。\u003c/p\u003e\n\u003cp\u003e用以下方法计算斯皮尔曼相关系数:\u003c/p\u003e\n\u003cp\u003e $ SCorr(X, Y) = \\frac{\\sum_{i=1}^n(x^r_i - \\overline x^r)(y^r_i - \\overline y^r)}{\\sqrt{\\sum_{i=1}^n(x^r_i - \\overline x^r)^2}\\sqrt{\\sum_{i=1}^n(y^r_i - \\overline y^r)}} $\u003c/p\u003e\n\u003cp\u003e其中 $ \\overline x^r = \\frac{1}{n}\\sum_{i=1}^nx^r_i, \\overline y^r = \\frac{1}{n}\\sum_{i=1}^n y^r_i $。\u003c/p\u003e\n\u003cp\u003e斯皮尔曼秩相关系数可以度量两个量之间的非线性相似度，这是和皮尔逊相关系数的重要区别。它的取值范围从-1到+1。\u003c/p\u003e\n\u003cp\u003e下面的图显示了了皮尔逊相关系数和斯皮尔曼相关系数之间的差异。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612582252122-x3.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e图中的数据是呈非线性单调，如果用皮尔逊相关系数——它度量线性关系，得到的相关系数是 0.88 ，而斯皮尔曼秩相关系数是 1 。\u003c/p\u003e\n\u003cp\u003e在研究数据的相似度时，根据经验，建议分别计算皮尔逊相关系数和斯皮尔曼秩相关系数。\u003c/p\u003e\n\u003cp\u003e在Python中，实现斯皮尔曼秩相关系数的方法如下：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom scipy.stats import spearmanr\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# 计算斯皮尔曼秩相关系数\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecorr, _ = spearmanr(x, y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(‘Spearmans correlation: %.3f’ % corr)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出结果：\u003ccode\u003eSpearmans correlation: 0.836\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"1-3-肯德尔秩相关系数\"\u003e\u003ca href=\"#1-3-肯德尔秩相关系数\" class=\"headerlink\" title=\"1.3 肯德尔秩相关系数\"\u003e\u003c/a\u003e1.3 肯德尔秩相关系数\u003c/h3\u003e\u003cp\u003e肯德尔秩相关系数与斯皮尔曼相关系数类似，都是非参数统计中度量相似度的方法，都依据原始数据的等级数据进行计算，不是原始数据。\u003c/p\u003e\n\u003cp\u003e肯德尔秩相关系数的值也是在 -1 和 +1 之间，其中 -1 表示两个变量之间的强负相关，1 表示两个变量之间的强正相关。\u003c/p\u003e\n\u003cp\u003e相对于斯皮尔曼秩相关系数，肯德尔秩相关系数具有统计学上的优势，如果样本量比较大了，对肯德尔秩相关系数的影响较小，特别是手工计算时，体现出了优势。但是，如果用程序实现计算，从算法的角度看，斯皮尔曼秩相关系数的时间复杂度是 $O(nlog(n))$ ，肯德尔秩相关系数的时间复杂度是 $O(n^2)$ ，即斯皮尔曼秩相关系数在计算速度上有优势。\u003c/p\u003e\n\u003cp\u003e计算肯德尔秩相关系数的第一步与前述斯皮尔曼秩相关系数一样，也是要得到原始数据的等级数据，然后依据下面的公式计算：\u003c/p\u003e\n\u003cp\u003e$ Tau(X, Y) = \\frac{2}{n(n-1)}\\sum_{i\\lt j}sgn(x_i^r - x_j^r)sgn(y_i^r - y_i^r) $\u003c/p\u003e\n\u003cp\u003e其中\u003c/p\u003e\n\u003cp\u003e$ sgn(x_i^r-x_j^r)=\\begin{cases}-1,\\quad \u0026amp;(x_i^r \\lt x_j^r) \\ 0, \u0026amp;(x_i^r = x_j^r) \\ 1 \u0026amp;(x_i^r \\gt x_j^r)\\end{cases},(i \\lt j) $\u003c/p\u003e\n\u003cp\u003e在Python中实现肯德尔相关系数的计算，方法如下：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom scipy.stats import kendalltau\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecorr, _ = kendalltau(x, y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(‘Kendalls tau: %.3f’ % corr)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出结果：\u003ccode\u003eKendalls tau: 0.695\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"1-4-余弦相似度\"\u003e\u003ca href=\"#1-4-余弦相似度\" class=\"headerlink\" title=\"1.4 余弦相似度\"\u003e\u003c/a\u003e1.4 余弦相似度\u003c/h3\u003e\u003cp\u003e余弦相似度计算两个向量或者随机变量之间夹角的余弦，公式如下：\u003c/p\u003e\n\u003cp\u003e $ S(X,Y) = \\frac{\\pmb{x}\\cdot\\pmb{y}}{\\begin{Vmatrix}\\pmb{x}\\end{Vmatrix}\\begin{Vmatrix}\\pmb{y}\\end{Vmatrix}}=\\frac{\\sum_{i=1}^nx_iy_i}{\\sqrt{\\sum_{i=1}^nx_i^2}\\sqrt{\\sum_{i=1}^ny_i^2}} $\u003c/p\u003e\n\u003cp\u003e下图显示了余弦函数的特点，从中可知，余弦函数的取值在 -1 到 +1 之间。如果向量指向相同的方向，余弦相似度是+1。如果向量指向相反的方向，余弦相似度为-1。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612582905325-x4.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612582935838-x5.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e余弦相似度在文本分析中很常见。它用于确定文档之间的相似程度，而不考虑文档的大小。\u003c/p\u003e\n\u003cp\u003e下面的程序中演示了在Python语言中实现余弦相似度的方法。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom sklearn.metrics.pairwise import cosine_similarity\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ecos_sim = cosine_similarity(x.reshape(1,1),y.reshape(1,-1))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(\u0026#39;Cosine similarity: %.3f\u0026#39; % cos_sim)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出结果：\u003ccode\u003eCosine similarity: 0.773\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"1-5-雅卡尔相似度\"\u003e\u003ca href=\"#1-5-雅卡尔相似度\" class=\"headerlink\" title=\"1.5 雅卡尔相似度\"\u003e\u003c/a\u003e1.5 雅卡尔相似度\u003c/h3\u003e\u003cp\u003e雅卡尔相似度（Jaccard similarity），又称为“雅卡尔指数”（Jaccard index）、“并交比”（Intersection over Union），是用于比较两个集合相似性的统计量。设 A、B 为两个有限样本集合，雅卡尔相似度定义为：\u003c/p\u003e\n\u003cp\u003e $$ J(A, B) = \\frac{|A\\cap{B}|}{|A\\cup{B}|}=\\frac{|A \\cap{B}|}{|A| + |B| - |A \\cap{B}|} $$\u003c/p\u003e\n\u003cp\u003e下图以可视化方式解释了定义式的含义。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612583148584-X6.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e我们可以看到，雅卡尔相似度是交集的大小除以样本集的并集的大小。\u003c/p\u003e\n\u003cp\u003e余弦相似度和雅卡尔相似度都是度量文本相似度的常用方法，但雅卡尔相似度在计算上成本较高，因为它要将一个文档的所有词汇匹配到另一个文档。实践证明，雅卡尔相似度在检测重复项方面很有用——集合运算的特点。\u003c/p\u003e\n\u003cp\u003e用Python实现雅卡尔相似度的计算过程：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom sklearn.metrics import jaccard_score\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eA = [1, 1, 1, 0]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eB = [1, 1, 0, 1]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ejacc = jaccard_score(A,B)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(‘Jaccard similarity: %.3f’ % jacc)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003ccode\u003eJaccard similarity: 0.500\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"2-基于距离的度量\"\u003e\u003ca href=\"#2-基于距离的度量\" class=\"headerlink\" title=\"2. 基于距离的度量\"\u003e\u003c/a\u003e2. 基于距离的度量\u003c/h2\u003e\u003cp\u003e2.1 欧几里得距离\u003c/p\u003e\n\u003cp\u003e欧几里德距离是两个向量之间的直线距离。\u003c/p\u003e\n\u003cp\u003e设两个向量 $\\pmb{x}$ 和 $\\pmb{y}$ ，可以进行如下计算：\u003c/p\u003e\n\u003cp\u003e $ d(\\pmb{x}, \\pmb{y})=\\begin{Vmatrix}\\pmb{x}-\\pmb{y}\\end{Vmatrix}=\\sqrt{\\sum_{i=1}^n(x_i-y_i)^2} $\u003c/p\u003e\n\u003cp\u003e与前述的余弦相似度和雅卡尔相似度相比，欧几里得距离很少用于NLP中，它更适用于计算连续型变量间的距离。要注意，欧几里得距离与度量单位有关，所以，在计算的时候，首先要进行单位统一。\u003c/p\u003e\n\u003cp\u003e在Python中计算欧几里得距离的基本方法是：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom scipy.spatial import distance\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edst = distance.euclidean(x,y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(‘Euclidean distance: %.3f’ % dst)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出结果：\u003ccode\u003eEuclidean distance: 3.273\u003c/code\u003e\u003c/p\u003e\n\u003ch3 id=\"2-2-曼哈顿距离\"\u003e\u003ca href=\"#2-2-曼哈顿距离\" class=\"headerlink\" title=\"2.2 曼哈顿距离\"\u003e\u003c/a\u003e2.2 曼哈顿距离\u003c/h3\u003e\u003cp\u003e曼哈顿距离，也叫做城市街区距离，与欧几里得距离不同，它是从一个向量到另一个向量的距离。可以想象，当你不能穿过建筑物时，这个度量可以用来计算两点之间的距离。\u003c/p\u003e\n\u003cp\u003e计算曼哈顿距离的公式如下:\u003c/p\u003e\n\u003cp\u003e$ d = \\sum_{i=1}^n|x_i-y_i| $\u003c/p\u003e\n\u003cp\u003e下图中的绿线表示欧几里德距离，而紫线表示曼哈顿距离。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://gitee.com/qiwsir/images/raw/master/2021-2-6/1612583307136-x7.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e在许多机器学习应用中，欧几里德距离是首选的度量标准。然而，对于高维数据来说，曼哈顿距离更可取，因为它产生了更有说服力的结果。\u003c/p\u003e\n\u003cp\u003e在Python中实现曼哈顿距离的方法是：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom scipy.spatial import distance\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edst = distance.cityblock(x,y)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(‘Manhattan distance: %.3f’ % dst)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出结果：\u003ccode\u003eManhattan distance: 10.468\u003c/code\u003e\u003c/p\u003e\n\u003ch2 id=\"总结\"\u003e\u003ca href=\"#总结\" class=\"headerlink\" title=\"总结\"\u003e\u003c/a\u003e总结\u003c/h2\u003e\u003cp\u003e本文概述了在实践中度量相似度的常见方法。在实际的问题中，没有简单的“如果. ….. 那么 …… ”流程图来选择使用哪一种相似性度量方法。我们首先需要了解和研究数据。然后，要想为给定的数据科学问题找到量化相似性的正确方法，始终需要针对每一个具体案例做出具体决策。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e注：本文内容是以2021年5月份即将出版的《机器学习数学基础》（作者：齐伟）中的某章节内容为基础编写而成。更详细的相关内容，请参阅此书。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"参考资料\"\u003e\u003ca href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"\u003e\u003c/a\u003e参考资料\u003c/h2\u003e\u003cul\u003e\n\u003cli\u003e齐伟.机器学习数学基础.北京:电子工业出版社（预计2021年5月份出版）\u003c/li\u003e\n\u003cli\u003e齐伟.数据准备和特征工程.北京:电子工业出版社.2020\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://towardsdatascience.com/calculate-similarity-the-most-relevant-metrics-in-a-nutshell-9a43564f533e\" target=\"_blank\" rel=\"noopener\"\u003ehttps://towardsdatascience.com/calculate-similarity-the-most-relevant-metrics-in-a-nutshell-9a43564f533e\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/12/12/their-learing/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          他们的学习\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2021/02/08/functiongraphs/\"\u003e\n        \n          函数及其图像\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2021-02-06T00:00:00Z",
  "Author": "老齐教室"
}