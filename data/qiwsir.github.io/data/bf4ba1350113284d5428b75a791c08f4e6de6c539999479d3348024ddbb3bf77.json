{
  "Source": "qiwsir.github.io",
  "Title": "Python如何实现重载函数",
  "Link": "https://qiwsir.github.io/2020/02/26/python-overload-function/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003ePython如何实现重载函数\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-02-26\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e作者：Arpit\u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003chr/\u003e\n\u003cp\u003e重载函数，即多个函数具有相同的名称，但功能不同。例如一个重载函数\u003ccode\u003efn\u003c/code\u003e，调用它的时候，要根据传给函数的参数判断调用哪个函数，并且执行相应的功能。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eint area(int length, int breadth) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return length * breadth;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efloat area(int radius) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return 3.14 * radius * radius;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e上例是用C++写的代码，函数\u003ccode\u003earea\u003c/code\u003e就是有两个不同功能的重载函数，一个是根据参数length和breadth计算矩形的面积，另一个是根据参数radius（圆的半径）计算圆的面积。如果用\u003ccode\u003earea(7)\u003c/code\u003e的方式调用函数\u003ccode\u003earea\u003c/code\u003e，就会实现第二个函数功能，当\u003ccode\u003earea(3, 4)\u003c/code\u003e时调用的是第一个函数。\u003c/p\u003e\n\u003ch2 id=\"为什么Python中没有重载函数\"\u003e\u003ca href=\"#为什么Python中没有重载函数\" class=\"headerlink\" title=\"为什么Python中没有重载函数\"\u003e\u003c/a\u003e为什么Python中没有重载函数\u003c/h2\u003e\u003cp\u003ePython中本没有重载函数，如果我们在同一命名空间中定义的多个函数是同名的，最后一个将覆盖前面的各函数，也就是函数的名称只能是唯一的。通过执行\u003ccode\u003elocals()\u003c/code\u003e和\u003ccode\u003eglobals()\u003c/code\u003e两个函数，就能看到该命名空间中已经存在的函数。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef area(radius):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return 3.14 * radius ** 2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; locals()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#39;area\u0026#39;: \u0026lt;function area at 0x10476a440\u0026gt;,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e定义了一个函数之后，执行\u003ccode\u003elocals()\u003c/code\u003e函数，返回了一个字典，其中是本地命名空间中所定义所有变量，键是变量，值则是它的引用。如果有另外一个同名函数，就会将本地命名空间的内容进行更新，不会有两个同名函数共存。所以，Python不支持重载函数，这是发明这个语言的设计理念，但是这并不能阻挡我们不能实现重载函数。下面就做一个试试。\u003c/p\u003e\n\u003ch2 id=\"在Python中实现重载函数\"\u003e\u003ca href=\"#在Python中实现重载函数\" class=\"headerlink\" title=\"在Python中实现重载函数\"\u003e\u003c/a\u003e在Python中实现重载函数\u003c/h2\u003e\u003cp\u003e我们应该知道Python怎么管理命名空间，如果我们要实现重载函数，必须：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在稳定的虚拟命名空间管理所定义的函数\u003c/li\u003e\n\u003cli\u003e根据参数调用合适的函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e为了简化问题，我们将实现具有相同名称的重载函数，它们的区别就是参数的个数。\u003c/p\u003e\n\u003ch2 id=\"封装函数\"\u003e\u003ca href=\"#封装函数\" class=\"headerlink\" title=\"封装函数\"\u003e\u003c/a\u003e封装函数\u003c/h2\u003e\u003cp\u003e创建一个名为\u003ccode\u003eFunction\u003c/code\u003e的类，并重写实现调用的\u003ccode\u003e__call__\u003c/code\u003e方法，再写一个名为\u003ccode\u003ekey\u003c/code\u003e的方法，它会返回一个元组，这样让就使得此方法区别于其他方法。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e28\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e29\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom inspect import getfullargspec\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eclass Function:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;Function is a wrap over standard python function.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def __init__(self, fn):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    self.fn = fn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def __call__(self, *args, **kwargs):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;when invoked like a function it internally invokes\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    the wrapped function and returns the returned value.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return self.fn(*args, **kwargs)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def key(self, args=None):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;Returns the key that will uniquely identify\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    a function (even when it is overloaded).\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # if args not specified, extract the arguments from the\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # function definition\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if args is None:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      args = getfullargspec(self.fn).args\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return tuple([\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      self.fn.__module__,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      self.fn.__class__,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      self.fn.__name__,\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      len(args or []),\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ])\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上面的代码片段中，\u003ccode\u003ekey\u003c/code\u003e方法返回了一个元组，其中的元素包括：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e函数所属的模块\u003c/li\u003e\n\u003cli\u003e函数所属的类\u003c/li\u003e\n\u003cli\u003e函数名称\u003c/li\u003e\n\u003cli\u003e函数的参数长度\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在重写的\u003ccode\u003e__call__\u003c/code\u003e方法中调用作为参数的函数，并返回计算结果。这样，实例就如同函数一样调用，它的表现效果与作为参数的函数一样。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef area(l, b):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return l * b\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; func = Function(area)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; func.key()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e(\u0026#39;__main__\u0026#39;, \u0026lt;class \u0026#39;function\u0026#39;\u0026gt;, \u0026#39;area\u0026#39;, 2)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; func(3, 4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上面的举例中，函数\u003ccode\u003earea\u003c/code\u003e作为\u003ccode\u003eFunction\u003c/code\u003e实例化的参数，\u003ccode\u003ekey()\u003c/code\u003e返回的元组中，第一个元素是模块的名称\u003ccode\u003e__main__\u003c/code\u003e，第二个是类\u003ccode\u003e\u0026lt;class \u0026#39;function\u0026#39;\u0026gt;\u003c/code\u003e，第三个是函数的名字\u003ccode\u003earea\u003c/code\u003e，第四个则是此函数的参数个数\u003ccode\u003e2\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e从上面的示例中，还可以看出，调用实例\u003ccode\u003efunc\u003c/code\u003e的方式，就和调用\u003ccode\u003earea\u003c/code\u003e函数一样，提供参数\u003ccode\u003e3\u003c/code\u003e和\u003ccode\u003e4\u003c/code\u003e，就返回\u003ccode\u003e12\u003c/code\u003e，前面调用\u003ccode\u003earea(3, 4)\u003c/code\u003e也是同样结果。这种方式，会在后面使用装饰器的时候很有用。\u003c/p\u003e\n\u003ch2 id=\"构建虚拟命名空间\"\u003e\u003ca href=\"#构建虚拟命名空间\" class=\"headerlink\" title=\"构建虚拟命名空间\"\u003e\u003c/a\u003e构建虚拟命名空间\u003c/h2\u003e\u003cp\u003e我们所构建的虚拟命名空间，会保存所定义的所有函数。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eclass Namespace(object):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;Namespace is the singleton class that is responsible\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  for holding all the functions.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  __instance = None\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def __init__(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if self.__instance is None:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      self.function_map = dict()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      Namespace.__instance = self\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    else:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      raise Exception(\u0026#34;cannot instantiate a virtual Namespace again\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  @staticmethod\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def get_instance():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    if Namespace.__instance is None:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      Namespace()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return Namespace.__instance\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def register(self, fn):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;registers the function in the virtual namespace and returns\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    an instance of callable Function that wraps the\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    function fn.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    func = Function(fn)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    self.function_map[func.key()] = fn\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return func\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eNamespace\u003c/code\u003e类中的方法\u003ccode\u003eregister\u003c/code\u003e以函数\u003ccode\u003efn\u003c/code\u003e为参数，在此方法内，利用\u003ccode\u003efn\u003c/code\u003e创建了\u003ccode\u003eFunction\u003c/code\u003e类的实例，还将它作为字典的值。那么，方法\u003ccode\u003eregister\u003c/code\u003e的返回值，也是一个可调用对象，其功能与前面封装的\u003ccode\u003efn\u003c/code\u003e函数一样。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef area(l, b):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return l * b\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; namespace = Namespace.get_instance()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; func = namespace.register(area)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; func(3, 4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003ch2 id=\"用装饰器做钩子\"\u003e\u003ca href=\"#用装饰器做钩子\" class=\"headerlink\" title=\"用装饰器做钩子\"\u003e\u003c/a\u003e用装饰器做钩子\u003c/h2\u003e\u003cp\u003e我们已经定义了一个虚拟命名空间，并且可以向其中注册一个函数，下面就需要一个钩子，在该函数生命周期内调用它，为此使用Python的装饰器。在Python中，装饰器是一种封装的函数，可以将它加到一个已有函数上，并不需要理解其内部结构。装饰器接受函数\u003ccode\u003efn\u003c/code\u003e作为参数，并且返回另外一个函数，在这个函数被调用的时候，可以用\u003ccode\u003eargs\u003c/code\u003e和\u003ccode\u003ekwargs\u003c/code\u003e为参数，并得到返回值。\u003c/p\u003e\n\u003cp\u003e下面是一个简单的封装器示例：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e26\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e27\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eimport time\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef my_decorator(fn):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;my_decorator is a custom decorator that wraps any function\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  and prints on stdout the time for execution.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  def wrapper_function(*args, **kwargs):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    start_time = time.time()\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # invoking the wrapped function and getting the return value.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    value = fn(*args, **kwargs)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    print(\u0026#34;the function execution took:\u0026#34;, time.time() - start_time, \u0026#34;seconds\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # returning the value got after invoking the wrapped function\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return value\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return wrapper_function\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e@my_decorator\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef area(l, b):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return l * b\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; area(3, 4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ethe function execution took: 9.5367431640625e-07 seconds\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在上面的示例中，定义了名为\u003ccode\u003emy_decorator\u003c/code\u003e的装饰器，并用它装饰函数\u003ccode\u003earea\u003c/code\u003e，在交互模式中调用，打印出\u003ccode\u003earea(3,4)\u003c/code\u003e的执行时间。\u003c/p\u003e\n\u003cp\u003e装饰器\u003ccode\u003emy_decorator\u003c/code\u003e装饰了一个函数之后，当执行函数的时候，该装饰器函数也每次都要调用，所以，装饰器函数是一个理想的钩子，借助它可以向前述定义的虚拟命名空间中注册函数。下面创建一个名为\u003ccode\u003eoverload\u003c/code\u003e的装饰器，用它在虚拟命名空间注册函数，并返回一个可执行对象。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef overload(fn):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;overload is the decorator that wraps the function\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  and returns a callable object of type Function.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return Namespace.get_instance().register(fn)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003ccode\u003eoverload\u003c/code\u003e装饰器返回\u003ccode\u003eFunction\u003c/code\u003e实例，作为\u003ccode\u003e.register()\u003c/code\u003e的命名空间。现在，不论什么时候通过\u003ccode\u003eoverload\u003c/code\u003e调用函数，都会返回\u003ccode\u003e.register()\u003c/code\u003e，即\u003ccode\u003eFunction\u003c/code\u003e实例，并且，在调用的时候，\u003ccode\u003e__call__\u003c/code\u003e也会执行。\u003c/p\u003e\n\u003ch2 id=\"从命名空间中查看函数\"\u003e\u003ca href=\"#从命名空间中查看函数\" class=\"headerlink\" title=\"从命名空间中查看函数\"\u003e\u003c/a\u003e从命名空间中查看函数\u003c/h2\u003e\u003cp\u003e除通常的模块类和名称外，消除歧义的范围是函数接受的参数数，因此我们在虚拟命名空间中定义了一个称为\u003ccode\u003eget\u003c/code\u003e的方法，该方法接受Python命名空间中的函数（将是最后一个同名定义 - 因为我们没有更改 Python 命名空间的默认行为）和调用期间传递的参数（我们的非义化因子），并返回要调用的消除歧义函数。\u003c/p\u003e\n\u003cp\u003e此\u003ccode\u003eget\u003c/code\u003e函数的作用是决定调用函数的实现（如果重载）。获取适合函数的过程非常简单，从函数和参数创建使用\u003ccode\u003ekey\u003c/code\u003e函数的唯一键（在注册时完成），并查看它是否存在于函数注册表中，如果在，就执行获取针对它存储操作。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef get(self, fn, *args):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;get returns the matching function from the virtual namespace.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return None if it did not fund any matching function.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  func = Function(fn)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return self.function_map.get(func.key(args=args))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e在\u003ccode\u003eget\u003c/code\u003e函数中创建了\u003ccode\u003eFunction\u003c/code\u003e的实例，它可以用\u003ccode\u003ekey\u003c/code\u003e方法得到唯一的键，并且不会在逻辑上重复，然后使用这个键在函数注册表中得到相应的函数。\u003c/p\u003e\n\u003ch2 id=\"调用函数\"\u003e\u003ca href=\"#调用函数\" class=\"headerlink\" title=\"调用函数\"\u003e\u003c/a\u003e调用函数\u003c/h2\u003e\u003cp\u003e如上所述，每当被\u003ccode\u003eoverload\u003c/code\u003e装饰器装饰的函数被调用时，类\u003ccode\u003eFunction\u003c/code\u003e中的方法\u003ccode\u003e__call__\u003c/code\u003e也被调用，从而通过命名空间的\u003ccode\u003eget\u003c/code\u003e函数得到恰当的函数，实现重载函数功能。\u003ccode\u003e__call__\u003c/code\u003e方法的实现如下：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef __call__(self, *args, **kwargs):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;Overriding the __call__ function which makes the\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  instance callable.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  # fetching the function to be invoked from the virtual namespace\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  # through the arguments.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  fn = Namespace.get_instance().get(self.fn, *args)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  if not fn:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    raise Exception(\u0026#34;no matching function found.\u0026#34;)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  # invoking the wrapped function and returning the value.\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return fn(*args, **kwargs)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e这个方法从虚拟命名空间中得到恰当的函数，如果它没有找到，则会发起异常。\u003c/p\u003e\n\u003ch2 id=\"重载函数实现\"\u003e\u003ca href=\"#重载函数实现\" class=\"headerlink\" title=\"重载函数实现\"\u003e\u003c/a\u003e重载函数实现\u003c/h2\u003e\u003cp\u003e将上面的代码规整到一起，定义两个名字都是\u003ccode\u003earea\u003c/code\u003e的函数，一个计算矩形面积，另一个计算圆的面积，两个函数均用装饰器\u003ccode\u003eoverload\u003c/code\u003e装饰。\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e@overload\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef area(l, b):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return l * b\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e@overload\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef area(r):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  import math\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  return math.pi * r ** 2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; area(3, 4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u0026gt;\u0026gt;\u0026gt; area(7)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e153.93804002589985\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e当我们给调用的\u003ccode\u003earea\u003c/code\u003e传一个参数时，返回圆的面积，两个参数时则计算了矩形面积，这样就实现了重载函数\u003ccode\u003earea\u003c/code\u003e。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca href=\"#结论\" class=\"headerlink\" title=\"结论\"\u003e\u003c/a\u003e结论\u003c/h2\u003e\u003cp\u003ePython不支持函数重载，但通过使用常规的语法，我们找到了它的解决方案。我们使用修饰器和用户维护的命名空间来重载函数，并使用参数数作为消除歧义因素。还可以使用参数的数据类型（在修饰中定义）来消除歧义—— 它允许具有相同参数数但不同类型的函数重载。重载的粒度只受函数\u003ccode\u003egetfullargspec\u003c/code\u003e和我们的想象力的限制。更整洁、更简洁、更高效的方法也可用于上述构造。\u003c/p\u003e\n\u003cp\u003e原文链接：\u003ca href=\"https://arpitbhayani.me/blogs/function-overloading\" target=\"_blank\" rel=\"noopener\"\u003ehttps://arpitbhayani.me/blogs/function-overloading\u003c/a\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关注微信公众号：老齐教室。读深度文章，得精湛技艺，享绚丽人生。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#重载函数 python\"\u003e\n    \u003cspan class=\"tag-code\"\u003e重载函数 python\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/02/25/make-blog-by-django/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          【公开课】用Django快速做博客\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/03/02/django-group-by/\"\u003e\n        \n          Django中用SQL实现分组查询\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-02-26T00:00:00Z",
  "Author": "老齐教室"
}