{
  "Source": "qiwsir.github.io",
  "Title": "Python中的堆排序",
  "Link": "https://qiwsir.github.io/2020/01/16/%E5%A0%86%E6%8E%92%E5%BA%8F/",
  "Content": "\u003carticle class=\"post-article\"\u003e\n    \u003ch2\u003ePython中的堆排序\u003c/h2\u003e\n    \u003cp class=\"post-date\"\u003e2020-01-16\u003c/p\u003e\n    \u003csection class=\"markdown-content\"\u003e\u003cp\u003e来源：\u003ca href=\"https://stackabuse.com/heap-sort-in-python/\" target=\"_blank\" rel=\"noopener\"\u003ehttps://stackabuse.com/heap-sort-in-python/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e作者：Olivera Popović \u003c/p\u003e\n\u003cp\u003e翻译：老齐\u003c/p\u003e\n\u003chr/\u003e\n\u003ch2 id=\"介绍\"\u003e\u003ca href=\"#介绍\" class=\"headerlink\" title=\"介绍\"\u003e\u003c/a\u003e介绍\u003c/h2\u003e\u003cp\u003e堆排序是高效排序算法的另一个例子，它的主要优点是，无论输入数据如何，它的最坏情况运行时间都是O(n*logn)。\u003c/p\u003e\n\u003cp\u003e顾名思义，堆排序在很大程度上依赖于堆数据结构——优先级队列的常见实现。\u003c/p\u003e\n\u003cp\u003e毫无疑问，堆排序是一种简单的排序算法，而且与其他简单实现相比，堆排序是更有效，也很常见。\u003c/p\u003e\n\u003ch2 id=\"堆排序\"\u003e\u003ca href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"\u003e\u003c/a\u003e堆排序\u003c/h2\u003e\u003cp\u003e堆排序的工作原理是从堆逐个“移除”元素并将它们添加到已排序的数组里，在进一步解释和重新访问堆数据结构之前，我们应该了解堆排序本身的一些属性。\u003c/p\u003e\n\u003cp\u003e它是一种原地算法（\u003cstrong\u003e译者注\u003c/strong\u003e：in-place algorithm，多数翻译为“原地算法”，少数也翻译为“就地算法”。这种算法是使用小的、固定数量的额外内存空间来转换资料的算法。），意味着它需要恒定数量的内存，即所需内存不取决于初始数组本身的大小，而取决于存储该数组所需的内存。\u003c/p\u003e\n\u003cp\u003e例如，不需要原始数组的副本，也不需要递归和递归调用堆栈。最简单的堆排序实现通常使用第二个数组来存储排序后的值。我们将使用这种方法，因为它在代码中更直观、更易于实现，但它也是百分百的原地算法。\u003c/p\u003e\n\u003cp\u003e堆排序不稳定，意思是相等的值，并不会在同样的相对位次上。对于整数、字符串等这些基本类型，不会出现这类问题，但当我们对复杂类型的对象排序时，可能会遇到。\u003c/p\u003e\n\u003cp\u003e例如，假设我们有一个自定义类\u003ccode\u003ePerson\u003c/code\u003e带有\u003ccode\u003eage\u003c/code\u003e和\u003ccode\u003ename\u003c/code\u003e属性，在一个数组中几个此类的实例对象，比如按顺序出现19岁的名叫“Mike”的人和一个19岁的名叫“David”的人。\u003c/p\u003e\n\u003cp\u003e如果我们决定按年龄对这些人进行排序，就不能在排序数组中保证“Mike”会出现在“David”之前，即使他们在初始数组中是按这个顺序出现的。“Mike”有可能出现在“David”之前，但不能保证百分之百如此。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/my_book4_20200116132005.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"堆数据结构\"\u003e\u003ca href=\"#堆数据结构\" class=\"headerlink\" title=\"堆数据结构\"\u003e\u003c/a\u003e堆数据结构\u003c/h2\u003e\u003cp\u003e堆是计算机科学中最流行和最常用的一种数据结构——\u003cstrong\u003e更不用说在软件工程面试中非常流行了\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e我们将讨论跟踪最小元素（最小堆）的堆，但它们也可以很容易地实现对最大元素（最大堆）的跟踪。\u003c/p\u003e\n\u003cp\u003e简单地说，最小堆是一种基于树的数据结构，其中每个节点比其所有子节点都小。通常使用二叉树。堆有三个基本操作——\u003ccode\u003edelete_minimum()\u003c/code\u003e、\u003ccode\u003eget_minimum()\u003c/code\u003e和\u003ccode\u003eadd()\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e每次，你只能删除堆中的第一个元素，然后对其进行“重新排序”。在添加或删除元素后，堆对自己会“重新排序”，以便最小的元素始终处于第一个位置。\u003c/p\u003e\n\u003cp\u003e注意：这绝不意味着堆是排序的数组。每个节点都小于其子节点这一事实不足以保证整个堆是按升序排列的。\u003c/p\u003e\n\u003cp\u003e我们来看一个关于堆的例子：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/heap-sort-in-python-1_20200111093942.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003cp\u003e正如我们看到的，上面的例子确实符合堆的描述，但是没有排序。我们不会详细讨论堆实现，因为这不是本文的重点。当在堆排序中使用堆数据结构时，我们所利用的堆数据结构的关键优势是：下一个最小的元素始终是堆中的第一个元素。\u003c/p\u003e\n\u003ch2 id=\"实现\"\u003e\u003ca href=\"#实现\" class=\"headerlink\" title=\"实现\"\u003e\u003c/a\u003e实现\u003c/h2\u003e\u003ch3 id=\"数组排序\"\u003e\u003ca href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"\u003e\u003c/a\u003e数组排序\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e译者注：\u003c/strong\u003e 作者在本文中并没有严格区分Python中的列表和数组，而是将列表看做了数组，这对于列表中的元素是同一种类型的元素而言，无可厚非。对于排序，只有是同一种类型的元素，才有意义。\u003c/p\u003e\n\u003cp\u003ePython提供了创建和使用堆的方法，所以我们不必自己单独为了实现它们去写代码了:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eheappush(list, item)\u003c/code\u003e：向堆中添加一个元素，然后对其重新排序，使其保持堆状态。可用于空列表。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheappop(list)\u003c/code\u003e：删除第一个（最小的）元素并返回该元素。此操作之后，堆仍然是一个堆，因此我们不必调用\u003ccode\u003eheapify()\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheapify(list)\u003c/code\u003e：将给定的列表变成一个堆。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e现在我们知道了这些，堆排序的实现就相当简单了：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom heapq import heappop, heappush\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003edef heap_sort(array):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    heap = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for element in array:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        heappush(heap, element)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ordered = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    # While we have elements left in the heap\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    while heap:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        ordered.append(heappop(heap))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return ordered\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003earray = [13, 21, 15, 5, 26, 4, 17, 18, 24, 2]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eprint(heap_sort(array))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e[2, 4, 5, 13, 15, 17, 18, 21, 24, 26]\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e如我们所见，堆数据结构的繁重工作已经完成，我们所要做的只是添加所需的所有元素并逐个删除它们。它就像一台硬币计数机，根据输入的硬币的价值对它们进行分类，然后我们可以取出它们。\u003c/p\u003e\n\u003ch3 id=\"自定义对象排序\"\u003e\u003ca href=\"#自定义对象排序\" class=\"headerlink\" title=\"自定义对象排序\"\u003e\u003c/a\u003e自定义对象排序\u003c/h3\u003e\u003cp\u003e当使用自定义类时，事情会变得更加复杂。通常，为了使用我们的排序算法，建议不要重写类中的比较运算符，而是建议重写该算法，以便使用lambda函数比较。\u003c/p\u003e\n\u003cp\u003e但是，由于我们的实现依赖于内置堆方法，因此不能在这里这样做。\u003c/p\u003e\n\u003cp\u003ePython确实提供了以下方法：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eheapq.nlargest(*n*, *iterable*, *key=None*)\u003c/code\u003e：返回一个列表，其中包含由\u003ccode\u003eiterable\u003c/code\u003e定义的数据集中的n个最大元素。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eheapq.nsmallest(*n*, *iterable*, *key=None*)\u003c/code\u003e：返回一个列表，其中包含由\u003ccode\u003eiterable\u003c/code\u003e定义的数据集中的n个最小元素。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们可以使用它来简单地获取\u003ccode\u003en = len(array)\u003c/code\u003e最大/最小元素，但是方法本身不使用堆排序，本质上等同于只调用\u003ccode\u003esorted()\u003c/code\u003e方法。\u003c/p\u003e\n\u003cp\u003e我们留给自定义类的唯一解决方案是实际重写比较运算符。遗憾的是，这使我们局限于对每个类只能进行一种比较。在我们的示例中，我们被局限于按年份对\u003ccode\u003eMovie\u003c/code\u003e对象进行排序。\u003c/p\u003e\n\u003cp\u003e但是，它确实让我们演示了在自定义类上使用堆排序。我们来定义\u003ccode\u003eMovie\u003c/code\u003e类：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003efrom heapq import heappop, heappush\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eclass Movie:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __init__(self, title, year):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.title = title\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        self.year = year\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __str__(self):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return str.format(\u0026#34;Title: {}, Year: {}\u0026#34;, self.title, self.year)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __lt__(self, other):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return self.year \u0026lt; other.year\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __gt__(self, other):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return other.__lt__(self)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __eq__(self, other):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return self.year == other.year\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    def __ne__(self, other):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        return not self.__eq__(other)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e现在，让我们稍微修改一下\u003ccode\u003eheap_sort()\u003c/code\u003e函数：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003edef heap_sort(array):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    heap = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    for element in array:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        heappush(heap, element)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ordered = []\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    while heap:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        ordered.append(heappop(heap))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return ordered\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e最后，让我们实例化一些电影，将它们放入一个数组中，然后对它们进行排序：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emovie1 = Movie(\u0026#34;Citizen Kane\u0026#34;, 1941)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emovie2 = Movie(\u0026#34;Back to the Future\u0026#34;, 1985)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emovie3 = Movie(\u0026#34;Forrest Gump\u0026#34;, 1994)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emovie4 = Movie(\u0026#34;The Silence of the Lambs\u0026#34;, 1991);\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emovie5 = Movie(\u0026#34;Gia\u0026#34;, 1998)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003earray = [movie1, movie2, movie3, movie4, movie5]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003efor movie in heap_sort(array):\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    print(movie)\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e输出：\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eTitle: Citizen Kane, Year: 1941\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTitle: Back to the Future, Year: 1985\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTitle: The Silence of the Lambs, Year: 1991\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTitle: Forrest Gump, Year: 1994\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eTitle: Gia, Year: 1998\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\n\u003cp\u003e\u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B2_20200114135935.png\" alt=\"\"/\u003e\u003c/p\u003e\n\u003ch2 id=\"与其他排序算法的比较\"\u003e\u003ca href=\"#与其他排序算法的比较\" class=\"headerlink\" title=\"与其他排序算法的比较\"\u003e\u003c/a\u003e与其他排序算法的比较\u003c/h2\u003e\u003cp\u003e堆排序被广泛使用，主要原因是它的可靠性，尽管它经常被运行良好的“快速排序”法所超越（\u003cstrong\u003e译者注：\u003c/strong\u003e 本文的微信公众号“老齐教室”以系列文章，介绍各种排序算法，并且用Python语言实现，敬请关注）。\u003c/p\u003e\n\u003cp\u003e堆排序的主要优点是时间复杂度上的O(n*logn)上限以及安全性。Linux内核开发人员给出了使用堆排序而不是快速排序的以下理由：\u003c/p\u003e\n\u003cp\u003e堆排序的平均排序时间和最坏排序时间均为\u003ccode\u003eO(n*logn)\u003c/code\u003e，虽然qsort的平均速度快了20%，但不得不容忍\u003ccode\u003eO(n*n)\u003c/code\u003e的最坏可能情形和额外的内存支出，这使它不太适合在操作系统内核中使用。\u003c/p\u003e\n\u003cp\u003e此外，快速排序算法法在可预测的情况下表现不佳。并且，如果对内部实现有足够的了解，你可能会意识到它造成的安全风险（主要是DDoS攻击），因为不良的\u003ccode\u003eO(n^2)\u003c/code\u003e行为很容易被触发。\u003c/p\u003e\n\u003cp\u003e经常被用来与堆排序比较的另一种算法是归并排序算法（\u003cstrong\u003e译者注：\u003c/strong\u003e 本微信公众号也会刊发相关文章给予介绍，敬请关注），它们具有相同的时间复杂度。\u003c/p\u003e\n\u003cp\u003e归并排序的优点是稳定、可并行运算，而堆排序两者都做不到。\u003c/p\u003e\n\u003cp\u003e另一个注意事项是：即使复杂度相同，堆排序在大多数情况下也比归并排序慢，因为堆排序具有较大的常数因子。\u003c/p\u003e\n\u003cp\u003e然而，堆排序比归并排序更容易实现，因此当内存比速度更重要时，它是首选。\u003c/p\u003e\n\u003ch2 id=\"结论\"\u003e\u003ca href=\"#结论\" class=\"headerlink\" title=\"结论\"\u003e\u003c/a\u003e结论\u003c/h2\u003e\u003cp\u003e正如我们所看到的，堆排序不像其他高效的通用算法那么流行，但是它的可预测行为（而不是不稳定的行为）使它成为一个很好的算法，适用于内存和安全性比稍快的运行速度更重要的场合。\u003c/p\u003e\n\u003cp\u003e实现和利用Python提供的内置功能是非常直观的，我们实际上要做的就是将元素放在一个堆中并取出它们，就像对待硬币计数器一样。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关注微信公众号：老齐教室。读深度文章，得精湛技艺，享绚丽人生。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003c/section\u003e\n    \u003c!-- Tags START --\u003e\n    \n      \u003cdiv class=\"tags\"\u003e\n        \u003cspan\u003eTags:\u003c/span\u003e\n        \n  \u003ca href=\"/tags#Python 堆 排序\"\u003e\n    \u003cspan class=\"tag-code\"\u003ePython 堆 排序\u003c/span\u003e\n  \u003c/a\u003e\n\n      \u003c/div\u003e\n    \n    \u003c!-- Tags END --\u003e\n    \u003c!-- NAV START --\u003e\n    \n  \u003cdiv class=\"nav-container\"\u003e\n    \u003c!-- reverse left and right to put prev and next in a more logic postition --\u003e\n    \n      \u003ca class=\"nav-left\" href=\"/2020/01/14/%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%8F%98%E9%87%8F/\"\u003e\n        \u003cspan class=\"nav-arrow\"\u003e← \u003c/span\u003e\n        \n          数据准备过程中如何创建虚拟变量\n        \n      \u003c/a\u003e\n    \n    \n      \u003ca class=\"nav-right\" href=\"/2020/01/17/%E8%B7%91%E5%BE%97%E6%9B%B4%E5%BF%AB/\"\u003e\n        \n          让Python程序跑得更快\n        \n        \u003cspan class=\"nav-arrow\"\u003e →\u003c/span\u003e\n      \u003c/a\u003e\n    \n  \u003c/div\u003e\n\n    \u003c!-- NAV END --\u003e\n    \u003c!-- 打赏 START --\u003e\n    \n      \u003cdiv class=\"money-like\"\u003e\n        \u003cdiv class=\"reward-btn\"\u003e\n          赏\n          \u003cspan class=\"money-code\"\u003e\n            \u003cspan class=\"alipay-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用支付宝打赏\u003c/b\u003e\n            \u003c/span\u003e\n            \u003cspan class=\"wechat-code\"\u003e\n              \u003cdiv class=\"code-image\"\u003e\u003c/div\u003e\n              \u003cb\u003e使用微信打赏\u003c/b\u003e\n            \u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cp class=\"notice\"\u003e若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏\u003c/p\u003e\n      \u003c/div\u003e\n    \n    \u003c!-- 打赏 END --\u003e\n    \u003c!-- 二维码 START --\u003e\n    \u003c!--% if (theme.qrcode) { %--\u003e\n      \u003cdiv class=\"qrcode\"\u003e\n        \u003c!--canvas id=\"share-qrcode\"\u003e\u003c/!--canvas--\u003e\n        \u003cimg src=\"https://public-tuchuang.oss-cn-hangzhou.aliyuncs.com/WechatIMG6_20200109154827.jpeg\" width=\"400\"/\u003e\n        \u003cp class=\"notice\"\u003e关注微信公众号，读文章、听课程，提升技能\u003c/p\u003e\n      \u003c/div\u003e\n    \u003c!--% } %--\u003e\n    \u003c!-- 二维码 END --\u003e\n    \n      \u003c!-- No Comment --\u003e\n    \n  \u003c/article\u003e",
  "Date": "2020-01-16T00:00:00Z",
  "Author": "老齐教室"
}