{
  "Source": "raphlinus.github.io",
  "Title": "The smooth resize test",
  "Link": "https://raphlinus.github.io/rust/gui/2019/06/21/smooth-resize-test.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eWhen I was young, as we traveled my dad had a quick test for the quality of a Chinese restaurant: if the tea wasn’t good, chances were the food wouldn’t be great either. One time, we left before ordering, and I don’t think we missed out on much.\u003c/p\u003e\n\n\u003cp\u003eToday is an exciting point in the evolution of native GUI in Rust. There is much exploration, and a number of promising projects, but I also think we don’t yet know the recipe to make GUI truly great. As I develop my own vision in this space, \u003ca href=\"https://github.com/xi-editor/druid\"\u003edruid\u003c/a\u003e, I hope more that the efforts will learn from each other and that an excellent synthesis will emerge, more so than simply hoping that druid will win.\u003c/p\u003e\n\n\u003cp\u003eIn my work, I have come across a problem that is as seemingly simple, yet as difficult to get right, as making decent tea: handling smooth window resizing. Very few GUI toolkits get it perfect, with some failing spectacularly. This is true across platforms, though Windows poses special challenges. It’s also pretty easy to test (as opposed to requiring sophisticated latency measurements, which I also plan to develop). I suggest it become one of the basic tests to evaluate a GUI toolkit.\u003c/p\u003e\n\n\u003cp\u003eTo apply the test, open an app built in your favorite GUI toolkit, and grab the \u003cem\u003eleft\u003c/em\u003e edge of the window. Drag it back and forth, and check to see whether the right edge of the app is stable, especially if it has scrollbars.\u003c/p\u003e\n\n\u003cp\u003eWhy this particular test? Among other things, it’s at the confluence of a number of subsystems, including interfaces with the underlying desktop OS. It also exposes some fundamental architectural decisions, especially regarding asynchrony.\u003c/p\u003e\n\n\u003cp\u003eThe smooth resizing test also exposes issues at multiple layers – the staging of layout vs drawing within the GUI toolkit, whether requests from the platform can be handled synchronously, and complex interactions between graphics and window management in the platform itself, which the app \u003cem\u003emay\u003c/em\u003e be able to control to at least some extent. I’ll go through these from low level to high level.\u003c/p\u003e\n\n\u003ch2 id=\"synchronization-with-window-manager\"\u003eSynchronization with window manager\u003c/h2\u003e\n\n\u003cp\u003eResizing a window kicks off two cascades of actions, which are at risk of getting desynchronized. One is the window frame, and the other is the window contents, custom-drawn for the size of the window.\u003c/p\u003e\n\n\u003cp\u003eThis is what it looks like when it goes wrong. It’s a lightly adapted version of the “Hello Triangle” example from Apple.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/wobbly_hello_triangle.gif\" alt=\"wobbly red triangle\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe fundamental problem here is that the 3D graphics pipeline is essentially asynchronous. Requests go in, get rendered by the GPU, then actually presented on the screen at some later time. For ordinary game-like content when you’re not resizing, this is fine, and the asynchronous approach has performance advantages, in particular it lets you do work on the CPU and GPU at the same time. But without some explicit synchronization, you get wobbling as above.\u003c/p\u003e\n\n\u003cp\u003eMany people have struggled with this issue, both on macOS and Windows. For example, iTerm2 switches to software rendering while resizing, for this reason. Fortunately, Tristan Hume has recently figured out a recipe to make it work, which you can read in the \u003ca href=\"http://thume.ca/2019/06/19/glitchless-metal-window-resizing/\"\u003eglitchless Metal window resizing\u003c/a\u003e blog post. The key insight is to use \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCAMetalLayer\u003c/code\u003e instead of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eMTKView\u003c/code\u003e, and set \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epresentsWithTransaction\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eWindows has a similar issue; with newer \u003ca href=\"https://docs.microsoft.com/en-us/windows/desktop/direct3ddxgi/for-best-performance--use-dxgi-flip-model\"\u003eflip model\u003c/a\u003e presentation modes optimized for performance, the content goes out of sync with the window drawing. Older presentation modes (which copy the full window contents to a “redirection buffer”) are synchronized, so not all UI toolkits are affected. It’s mostly an issue when the toolkit is also trying to optimize performance, especially latency, for which there are mechanisms such as wait objects that only work with the flip model.\u003c/p\u003e\n\n\u003cp\u003eI spent a \u003cem\u003elot\u003c/em\u003e of time experimenting with this on Windows, and finally came up with a \u003ca href=\"https://github.com/xi-editor/xi-win/pull/21\"\u003eworkable recipe\u003c/a\u003e. The short answer is that it switches to rendering in the redirection buffer when sizing (using \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWM_ENTERSIZEMOVE\u003c/code\u003e), then back to flip mode at the end of resizing (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWM_EXITSIZEMOVE\u003c/code\u003e). That specific code is tuned for Direct2D, and uses a \u003ca href=\"https://docs.microsoft.com/en-us/windows/desktop/api/d2d1/nn-d2d1-id2d1hwndrendertarget\"\u003eHwndRenderTarget\u003c/a\u003e for the sizing case (and on Windows 7), but it could be adapted to Direct3D as well. I think the trick is to use the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eDXGI_SWAP_EFFECT_SEQUENTIAL\u003c/code\u003e presentation mode, which in my testing has similar behavior, copying to the redirection buffer and synchronizing with the window manager.\u003c/p\u003e\n\n\u003cp\u003eThis exploration was a big part of my decision to do my own window creation in \u003ca href=\"https://github.com/xi-editor/druid\"\u003edruid\u003c/a\u003e, as opposed to using \u003ca href=\"https://github.com/rust-windowing/winit\"\u003ewinit\u003c/a\u003e. I \u003ca href=\"https://github.com/rust-windowing/winit/issues/786\"\u003efiled an issue\u003c/a\u003e on winit, but it seems clear they’re not able to handle the druid use case yet.\u003c/p\u003e\n\n\u003ch2 id=\"synchronous-delivery-of-events\"\u003eSynchronous delivery of events\u003c/h2\u003e\n\n\u003cp\u003eAll GUI frameworks are based on an “event loop,” which is quite similar to the \u003ca href=\"http://gameprogrammingpatterns.com/game-loop.html\"\u003egame loop\u003c/a\u003e. Unfortunately, the event loop often has complex, messy requirements, especially around threading and reentrancy. I think this is mostly for legacy reasons, as the foundations of UI were laid well before threading entered its modern age.\u003c/p\u003e\n\n\u003cp\u003eIn an attempt to simplify the programming model, \u003ca href=\"https://github.com/rust-windowing/winit\"\u003ewinit\u003c/a\u003e ran its own event loop in one thread, and the app logic in another, with asychronous coupling using channels between them. For the typical game pipeline, this was indeed a simplification, as the application thread could just be a normal Rust thread, without having to worry about which calls are thread-safe.\u003c/p\u003e\n\n\u003cp\u003eHowever, for smooth window resizing, the completion of draw needs to be synchronized with the window frame resize. This is fundamentally the same issue above, but inside the application logic rather than deep in the platform’s swapchain handling.\u003c/p\u003e\n\n\u003cp\u003eFortunately, winit now has an “event loop 2.0” model that gets rid of the extra thread on Windows and allows synchronous events. So it’s one step closer to being able to do smooth resize.\u003c/p\u003e\n\n\u003ch2 id=\"staging-of-layout-and-drawing\"\u003eStaging of layout and drawing\u003c/h2\u003e\n\n\u003cp\u003eIn typical immediate mode GUI (imgui), both layout and drawing happen in the same call hierarchy. To keep things reasonably deterministic, it’s common for layout to be computed and stored, then drawing based on the \u003cem\u003elast\u003c/em\u003e frame’s layout, in other words a \u003ca href=\"https://twitter.com/jdryg/status/950640715213795329\"\u003eone-frame delay\u003c/a\u003e for layout to take hold.\u003c/p\u003e\n\n\u003cp\u003eI use imgui as an example because this phenomenon is well known, and is a tradeoff for the simplification that imgui brings. But it can happen in any system where there isn’t rigorous staging of layout and drawing. To do this right, before any drawing occurs, there needs to be a layout phase where the size and position of each widget is determined, then drawing. Most GUI toolkits do get this right, but some don’t.\u003c/p\u003e\n\n\u003ch2 id=\"discussion\"\u003eDiscussion\u003c/h2\u003e\n\n\u003cp\u003eThere are many things that can go wrong when doing window resizing. Therefore, it is a sensitive test for careful platform integration and architectural issues. I’ve tried hard to get it right in druid, and hope the result of that exploration can be useful to others trying to build desktop GUI.\u003c/p\u003e\n\n\u003cp\u003eThanks to Tristan Hume for making the triangle GIF, and for figuring out the correct recipe on macOS Metal.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2019-06-21T19:50:42Z",
  "Author": "raphlinus"
}