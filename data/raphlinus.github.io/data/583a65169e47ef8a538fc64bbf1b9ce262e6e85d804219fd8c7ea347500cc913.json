{
  "Source": "raphlinus.github.io",
  "Title": "Minikin retrospective",
  "Link": "https://raphlinus.github.io/text/2022/11/08/minikin.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThere’s a lot of new interest in open source text layout projects, including \u003ca href=\"https://github.com/pop-os/cosmic-text\"\u003ecosmic-text\u003c/a\u003e, and the \u003ca href=\"https://github.com/dfrg/parley\"\u003eparley\u003c/a\u003e work being done by Chad Brokaw. I’m hopeful we’ll get a good Rust solution soon.\u003c/p\u003e\n\n\u003cp\u003eI encourage people working on text to study existing open source code bases, as much of the knowledge is arcane, and there is unfortunately no good textbook on the subject. Obviously browser engines facilitate extremely sophisticated layout, but because of their complexity and the constraints of HTML and CSS compatibility, they may be hard going. The APIs of \u003ca href=\"https://learn.microsoft.com/en-us/windows/win32/directwrite/direct-write-portal\"\u003eDirectWrite\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/documentation/coretext\"\u003eCore Text\u003c/a\u003e are also worthy of study, but unfortunately their implementations remain closed.\u003c/p\u003e\n\n\u003cp\u003eAn interesting codebase is \u003ca href=\"https://android.googlesource.com/platform/frameworks/minikin/\"\u003eMinikin\u003c/a\u003e. It powers text layout in the Android framework. I wrote the original version starting back around 2013, but it is since maintained by the very capable Android text team.\u003c/p\u003e\n\n\u003cp\u003eA bit of additional context. The design of Minikin was constrained by compatibility with the existing Android text API (mostly exposed through Java, though these days there is a nontrivial \u003ca href=\"https://developer.android.com/ndk/reference/group/font\"\u003eNDK surface\u003c/a\u003e as well). There is a higher level layer, responsible for rich text representation, editing, and other things, while Minikin is the lower level that powers that and does shaping, itemization, hit testing, and so on. (See \u003ca href=\"https://raphlinus.github.io/text/2020/10/26/text-layout.html\"\u003eText layout is a loose hierarchy of segmentation\u003c/a\u003e if these terms are unfamiliar). For the most part, the interface between the higher and lower levels is \u003cem\u003eruns\u003c/em\u003e of text. Line breaking is an interesting case where the responsibility for crossing levels is shared across the layer boundary. For the most part, the higher level iterates its own rich text representation and hands runs to Minikin.\u003c/p\u003e\n\n\u003cp\u003eA special feature of Minikin is its optimized line breaking algorithm, strongly inspired by Knuth-Plass. This was motivated largely by the need to handle small screens better, but has some tweaks to make it even better for mobile. The heuristics try not to place a word by itself on the last line, and in general try to balance line lengths. Line breaking generally follows ICU rules, but does special case email addresses and URLs, as those are very common on mobile and the ICU rules work poorly.\u003c/p\u003e\n\n\u003cp\u003eThere’s also fun stuff in there for grapheme boundaries, deciding between color and text emoji presentation forms, and calculating exactly what should be deleted on backspace (the logic for that is surprisingly complicated and as far as I know has not been written down anywhere).\u003c/p\u003e\n\n\u003cp\u003eMuch of the internal structure of Minikin is dedicated to itemization, which is done largely on the basis of the cmap coverage of the fonts in the fallback chain. Doing that query font-by-font for every character would be expensive, so there are fancy bitmap acceleration structures. A good, general, cross-platform way to do itemization and fallback is a hard problem, but I think this solution works well for Android’s specific needs.\u003c/p\u003e\n\n\u003cp\u003eWhile there’s unfortunately no excellent documentation on Minkin’s internals, there are some resources, and part of the purpose of this blog is to point people to them. I’ve just gotten permission to publish the \u003ca href=\"/assets/Project_Minikin.pdf\"\u003eProject Minikin slide deck\u003c/a\u003e from 2013 (PDF), which explains the motivation and some of the early design ideas. There’s also an \u003ca href=\"https://lwn.net/Articles/662569/\"\u003elwn article\u003c/a\u003e which goes into some detail, largely based on my 2015 ATypI talk (\u003ca href=\"https://www.youtube.com/watch?v=L8LD0BM-Vjk\"\u003evideo\u003c/a\u003e, \u003ca href=\"https://docs.google.com/presentation/d/1-b1loWe23QNk0ydrmEBG31iVABYWSpE28JmdXDHs73E/edit\"\u003eslides\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003eFlutter’s \u003ca href=\"https://github.com/flutter/flutter/issues/35994\"\u003eLibTxt\u003c/a\u003e was originally based on Minikin, but no doubt has diverged considerably since then, as they have fairly different requirements and of course are not bound by compatibility with Android.\u003c/p\u003e\n\n\u003cp\u003eBut if you have deep interest in this, I recommend studying the code, as that’s the ultimate source of truth. It’s extremely fortunate that Android’s open source development model gives us access to it!\u003c/p\u003e\n\n\u003cp\u003eIf you have questions, let me know (an issue on this repo is a good way, or you can ask on Mastodon), and I’ll do my best to answer.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2022-11-08T18:40:42Z",
  "Author": "raphlinus"
}