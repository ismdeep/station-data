{
  "Source": "raphlinus.github.io",
  "Title": "Flattening quadratic Béziers",
  "Link": "https://raphlinus.github.io/graphics/curves/2019/12/23/flatten-quadbez.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cstyle\u003e\n  svg {\n    touch-action: none;\n  }\n\u003c/style\u003e\n\n\u003cscript type=\"text/x-mathjax-config\"\u003e\n        MathJax.Hub.Config({\n                tex2jax: {\n                        inlineMath: [['$', '$']]\n                }\n        });\n\u003c/script\u003e\n\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" type=\"text/javascript\"\u003e\u003c/script\u003e\n\n\u003cp\u003eA classic approach to rendering Bézier curves is to \u003cem\u003eflatten\u003c/em\u003e them to polylines. There are other possibilities, including working with the Bézier curves analytically, as is done for example in \u003ca href=\"http://hhoppe.com/proj/ravg/\"\u003eRandom Access Vector Graphics\u003c/a\u003e, but converting to polylines still has legs, largely because it’s easier to build later stages of a rendering pipeline (especially on a GPU) that work with polylines.\u003c/p\u003e\n\n\u003cp\u003eA similarly classic approach to flattening Béziers to polylines is recursive subdivision. Briefly stated, the algorithm measures the error between the chord connecting the endpoints and the curve. If this is within tolerance, it returns the chord. Otherwise, it splits the Bézier in half (using de Casteljau subdivision) and recursively applies the algorithm to the two halves. This process is described in more detail in the paper \u003ca href=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.162\u0026amp;rep=rep1\u0026amp;type=pdf\"\u003ePiecewise Linear Approximation\u003c/a\u003e. However, there are several reasons to be dissatisfied with this approach. For one, while it’s pretty good, it’s not particularly close to optimum in the number of curve segments. Perhaps of greater concern to a modern audience, the recursive approach adapts poorly any form of parallel evaluation, including GPU and SIMD. Allocation is also difficult, as the approach doesn’t tell you in advance how many subdivisions will be needed to achieve the specified tolerance.\u003c/p\u003e\n\n\u003cp\u003eThe interactive demo below lets you switch between the recursive subdivision method and the new technique described in this blog, so you can see how the new technique achieves the error tolerance with significantly fewer segments.\u003c/p\u003e\n\n\u003cstyle\u003e\nsvg .handle {\n    pointer-events: all;\n}\nsvg .handle:hover {\n    r: 6;\n}\nsvg .quad {\n    stroke-width: 6px;\n    stroke: #bbb;\n}\nsvg .hull {\n    stroke: #c44;\n}\nsvg .polyline {\n}\nsvg text {\n    font-family: sans-serif;\n}\nsvg .button {\n    fill: #aad;\n    stroke: #44f;\n}\nsvg .button:hover {\n    fill: #bbf;\n}\nsvg text {\n    pointer-events: none;\n}\nsvg #grid line {\n    stroke: #ccc;\n}\nimg {\n  margin: auto;\n  margin: auto;\n  display: block;\n}\n\u003c/style\u003e\n\n\u003csvg id=\"s\" width=\"700\" height=\"500\"\u003e\n    \u003cg id=\"grid\"\u003e\u003c/g\u003e\n    \u003crect class=\"button\" x=\"50\" y=\"30\" width=\"80\" height=\"30\"\u003e\u003c/rect\u003e\n    \u003crect class=\"button\" x=\"200\" y=\"30\" width=\"110\" height=\"30\"\u003e\u003c/rect\u003e\n\u003c/svg\u003e\n\u003cscript\u003e\nconst svgNS = \"http://www.w3.org/2000/svg\";\n\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    lerp(p2, t) {\n        return new Point(this.x + (p2.x - this.x) * t, this.y + (p2.y - this.y) * t);\n    }\n\n    dist(p2) {\n        return Math.hypot(p2.x - this.x, p2.y - this.y);\n    }\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\n// This isn't especially good but will do.\nfunction approx_myint(x) {\n   const d = 0.67; \n   return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of the function above.\n// This is better.\nfunction approx_inv_myint(x) {\n    const b = 0.39;\n    return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\nclass QuadBez {\n    constructor(x0, y0, x1, y1, x2, y2) {\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    to_svg_path() {\n        return `M${this.x0} ${this.y0} Q${this.x1} ${this.y1} ${this.x2} ${this.y2}`\n    }\n\n    eval(t) {\n        const mt = 1 - t;\n        const x = this.x0 * mt * mt + 2 * this.x1 * t * mt + this.x2 * t * t;\n        const y = this.y0 * mt * mt + 2 * this.y1 * t * mt + this.y2 * t * t;\n        return new Point(x, y);\n    }\n\n    subsegment(t0, t1) {\n        const p0 = this.eval(t0);\n        const p2 = this.eval(t1);\n        const dt = t1 - t0;\n        const p1x = p0.x + (this.x1 - this.x0 + t0 * (this.x2 - 2 * this.x1 + this.x0)) * dt;\n        const p1y = p0.y + (this.y1 - this.y0 + t0 * (this.y2 - 2 * this.y1 + this.y0)) * dt;\n        return new QuadBez(p0.x, p0.y, p1x, p1y, p2.x, p2.y);\n    }\n\n    // The maximum error between a chord and the quadratic Bézier.\n    // Note: this isn't quite right for extreme examples.\n    error() {\n        const x1 = this.x1 - this.x0;\n        const y1 = this.y1 - this.y0;\n        const x2 = this.x2 - this.x0;\n        const y2 = this.y2 - this.y0;\n        const t = (x1 * x2 + y1 * y2) / (x2 * x2 + y2 * y2);\n        const u = Math.min(Math.max(t, 0), 1);\n        const p = new Point(this.x0, this.y0).lerp(new Point(this.x2, this.y2), u);\n        return 0.5 * p.dist(new Point(this.x1, this.y1));\n    }\n\n    // Determine the x values and scaling to map to y=x^2\n    map_to_basic() {\n        const ddx = 2 * this.x1 - this.x0 - this.x2;\n        const ddy = 2 * this.y1 - this.y0 - this.y2;\n        const u0 = (this.x1 - this.x0) * ddx + (this.y1 - this.y0) * ddy;\n        const u2 = (this.x2 - this.x1) * ddx + (this.y2 - this.y1) * ddy;\n        const cross = (this.x2 - this.x0) * ddy - (this.y2 - this.y0) * ddx;\n        const x0 = u0 / cross;\n        const x2 = u2 / cross;\n        // There's probably a more elegant formulation of this...\n        const scale = Math.abs(cross) / (Math.hypot(ddx, ddy) * Math.abs(x2 - x0));\n        return {x0: x0, x2: x2, scale: scale, cross: cross};\n    }\n\n    recurse_subdiv_inner(tol, t0, t1, result) {\n        const q = this.subsegment(t0, t1);\n        if (q.error() \u003c= tol) {\n            result.push(t1);\n        } else {\n            const tm = (t0 + t1) * 0.5;\n            this.recurse_subdiv_inner(tol, t0, tm, result);\n            this.recurse_subdiv_inner(tol, tm, t1, result);\n        }\n    }\n\n    recurse_subdiv(tol) {\n        const result = [0]\n        this.recurse_subdiv_inner(tol, 0, 1, result);\n        return result;\n    }\n\n    // Subdivide using fancy algorithm.\n    my_subdiv(tol) {\n        const params = this.map_to_basic();\n        const a0 = approx_myint(params.x0);\n        const a2 = approx_myint(params.x2);\n        const count =  0.5 * Math.abs(a2 - a0) * Math.sqrt(params.scale / tol);\n        const n = Math.ceil(count);\n        const u0 = approx_inv_myint(a0);\n        const u2 = approx_inv_myint(a2);\n        let result = [0];\n        for (let i = 1; i \u003c n; i++) {\n            const u = approx_inv_myint(a0 + ((a2 - a0) * i) / n);\n            const t = (u - u0) / (u2 - u0);\n            result.push(t);\n        }\n        result.push(1);\n        return result;\n    }\n\n    // Subdivide using method from Sederberg's CAGD notes\n    subdiv_sederberg(tol, round_to_pow2) {\n        const ddx = 2 * this.x1 - this.x0 - this.x2;\n        const ddy = 2 * this.y1 - this.y0 - this.y2;\n        const dd = Math.hypot(ddx, ddy);\n        let n = Math.ceil(Math.sqrt(0.25 * dd / tol));\n        if (round_to_pow2) {\n            n = 1 \u003c\u003c 32 - Math.clz32(n - 1);\n        }\n        let result = [];\n        for (let i = 0; i \u003c n; i++) {\n            const t = i / n;\n            result.push(t);\n        }\n        result.push(1);\n        return result;\n    }\n}\n\n//for (let i = 0; i \u003c sub.length - 1; i++) {\n//    console.log(qb.subsegment(sub[i], sub[i + 1]).error());\n//}\n\nclass QuadUi {\n    constructor(id) {\n        this.root = document.getElementById(id);\n\n        this.root.addEventListener(\"pointerdown\", e =\u003e {\n            this.root.setPointerCapture(e.pointerId);\n            this.onPointerDown(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        this.root.addEventListener(\"pointermove\", e =\u003e {\n            this.onPointerMove(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        this.root.addEventListener(\"pointerup\", e =\u003e {\n            this.root.releasePointerCapture(e.pointerId);\n            this.onPointerUp(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        window.addEventListener(\"keydown\", e =\u003e this.onKeyDown(e));\n\n        this.pts = [new Point(200, 450), new Point(400, 450), new Point(600, 50)];\n        this.quad = this.make_stroke();\n        this.quad.classList.add(\"quad\");\n        this.polyline = this.make_stroke();\n        this.polyline.classList.add(\"polyline\");\n        this.hull = this.make_stroke();\n        this.hull.classList.add(\"hull\");\n        this.handles = [];\n        for (let pt of this.pts) {\n            this.handles.push(this.make_handle(pt));\n        }\n        this.n_label = this.make_text(500, 50);\n        this.type_label = this.make_text(90, 50);\n        this.type_label.setAttribute(\"text-anchor\", \"middle\");\n        this.thresh_label = this.make_text(210, 50);\n        this.pips = [];\n        this.method = \"analytic\";\n        this.grid = 20;\n        this.thresh = 1.0;\n        this.renderGrid(true);\n        this.update();\n\n        this.current_obj = null;\n    }\n\n    getCoords(e) {\n        const rect = this.root.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        return new Point(x, y);\n    }\n\n    onPointerDown(e) {\n        const pt = this.getCoords(e);\n        const x = pt.x;\n        const y = pt.y;\n        if (x \u003e= 50 \u0026\u0026 x \u003c= 130 \u0026\u0026 y \u003e= 30 \u0026\u0026 y \u003c= 60) {\n            if (this.method == \"analytic\") {\n                this.method = \"recursive\";\n            } else {\n                this.method = \"analytic\";\n            }\n            this.update();\n            return;\n        }\n        if (x \u003e= 200 \u0026\u0026 x \u003c= 310 \u0026\u0026 y \u003e= 30 \u0026\u0026 y \u003c= 60) {\n            if (this.thresh == 1.0) {\n                this.thresh = 0.5;\n            } else if (this.thresh == 0.5) {\n                this.thresh = 0.2;\n            } else if (this.thresh == 0.2) {\n                this.thresh = 0.1;\n            } else if (this.thresh == 0.1) {\n                this.thresh = 10.0;\n            } else if (this.thresh == 10.0) {\n                this.thresh = 5.0;\n            } else if (this.thresh == 5.0) {\n                this.thresh = 2.0;\n            } else if (this.thresh == 2.0) {\n                this.thresh = 1.0;\n            }\n            this.update();\n            return;\n        }\n        for (let i = 0; i \u003c this.pts.length; i++) {\n            if (Math.hypot(x - this.pts[i].x, y - this.pts[i].y) \u003c 10) {\n                this.current_obj = i;\n            }\n        }\n    }\n\n    onPointerMove(e) {\n        const pt = this.getCoords(e);\n        if (this.current_obj !== null) {\n            const i = this.current_obj;\n            this.pts[i] = pt;\n            this.handles[i].setAttribute(\"cx\", pt.x);\n            this.handles[i].setAttribute(\"cy\", pt.y);\n            this.update();\n        }\n    }\n\n    onPointerUp(e) {\n        this.current_obj = null;\n    }\n\n    onKeyDown(e) {\n        if (e.key == 's') {\n            this.method = \"sederberg\";\n            this.update();\n        } else if (e.key == 'r') {\n            this.method = \"recursive\";\n            this.update();\n        } else if (e.key == 'a') {\n            this.method = \"analytic\";\n            this.update();\n        } else if (e.key == 'w') {\n            this.method = \"wang\";\n            this.update();\n        }\n    }\n\n    renderGrid(visible) {\n        let grid = document.getElementById(\"grid\");\n        //this.ui.removeAllChildren(grid);\n        if (!visible) return;\n        let w = 700;\n        let h = 500;\n        for (let i = 0; i \u003c w; i += this.grid) {\n            let line = document.createElementNS(svgNS, \"line\");\n            line.setAttribute(\"x1\", i);\n            line.setAttribute(\"y1\", 0);\n            line.setAttribute(\"x2\", i);\n            line.setAttribute(\"y2\", h);\n            grid.appendChild(line);\n        }\n        for (let i = 0; i \u003c h; i += this.grid) {\n            let line = document.createElementNS(svgNS, \"line\");\n            line.setAttribute(\"x1\", 0);\n            line.setAttribute(\"y1\", i);\n            line.setAttribute(\"x2\", w);\n            line.setAttribute(\"y2\", i);\n            grid.appendChild(line);\n        }\n    }\n\n    make_handle(p) {\n        const circle = this.plot(p.x, p.y, \"blue\", 5);\n        circle.classList.add(\"handle\");\n        return circle;\n    }\n\n    make_stroke(qb) {\n        const path = document.createElementNS(svgNS, \"path\");\n        path.setAttribute(\"fill\", \"none\");\n        path.setAttribute(\"stroke\", \"blue\");\n        this.root.appendChild(path);\n        return path;\n    }\n\n    make_text(x, y) {\n        const text = document.createElementNS(svgNS, \"text\");\n        text.setAttribute(\"x\", x);\n        text.setAttribute(\"y\", y);\n        this.root.appendChild(text);\n        return text;\n    }\n\n    plot(x, y, color = \"black\", r = 2) {\n        let circle = document.createElementNS(svgNS, \"circle\");\n        circle.setAttribute(\"cx\", x);\n        circle.setAttribute(\"cy\", y);\n        circle.setAttribute(\"r\", r);\n        circle.setAttribute(\"fill\", color)\n        this.root.appendChild(circle);\n        return circle;\n    }\n\n    update() {\n        for (let pip of this.pips) {\n            pip.remove();\n        }\n        this.pips = [];\n        const p0 = this.pts[0];\n        const p1 = this.pts[1];\n        const p2 = this.pts[2];\n        const qb = new QuadBez(p0.x, p0.y, p1.x, p1.y, p2.x, p2.y);\n        this.quad.setAttribute(\"d\", qb.to_svg_path());\n\n        const h = `M${p0.x} ${p0.y}L${p1.x} ${p1.y}L${p2.x} ${p2.y}`;\n        this.hull.setAttribute(\"d\", h);\n\n        const tol = this.thresh;\n        let sub;\n        if (this.method == \"analytic\") {\n            sub = qb.my_subdiv(tol);\n        } else if (this.method == \"recursive\") {\n            sub = qb.recurse_subdiv(tol);\n        } else if (this.method == \"sederberg\") {\n            sub = qb.subdiv_sederberg(tol, false);\n        } else if (this.method == \"wang\") {\n            sub = qb.subdiv_sederberg(tol, true);\n        }\n        const n = sub.length - 1;\n        let p = \"\";\n        for (let t of sub) {\n            const xy = qb.eval(t);\n            this.pips.push(this.plot(xy.x, xy.y));\n            if (p == \"\") {\n                p = `M${xy.x} ${xy.y}`;\n            } else {\n                p += `L${xy.x} ${xy.y}` \n            }\n        }\n        this.polyline.setAttribute(\"d\", p);\n        this.n_label.textContent = `n = ${n}`;\n        this.type_label.textContent = this.method;\n        this.thresh_label.textContent = `threshold: ${this.thresh}`;\n    }\n}\n\nnew QuadUi(\"s\");\n\u003c/script\u003e\n\n\u003cp\u003eA few other discussions of the recursive subdivision idea are on \u003ca href=\"https://web.archive.org/web/20190329074058/http://antigrain.com:80/research/adaptive_bezier/index.html\"\u003eantigrain\u003c/a\u003e, \u003ca href=\"http://www.caffeineowl.com/graphics/2d/vectorial/bezierintro.html\"\u003ecaffeineowl\u003c/a\u003e, and \u003ca href=\"https://stackoverflow.com/questions/9247564/convert-bezier-curve-to-polygonal-chain\"\u003eStack Overflow\u003c/a\u003e. The latter thread also links to some other approaches. A common sentiment is “maybe we shouldn’t subdivide exactly in half, but be smarter exactly where to subdivide.” This blog post is basically about how to be smarter.\u003c/p\u003e\n\n\u003cp\u003eWorking with cubic Bézier curves is tricky, but quadratic Bézier curves are pleasantly simple; they are something of a halfway station between cubics and straight lines. In this blog post, we present an analytical approach to flattening quadratic Bézier curves into polylines. It is so good that it’s probably best to flatten other curve types (including cubic Béziers) by converting them to quadratics first, then applying the technique of this blog post.\u003c/p\u003e\n\n\u003ch2 id=\"how-many-segments\"\u003eHow many segments?\u003c/h2\u003e\n\n\u003cp\u003eThe core insight of this blog post is a closed-form analytic expression for the number of line segments needed in the continuous limit.\u003c/p\u003e\n\n\u003cp\u003eFor a small curve segment, the maximum distance between curve and chord can be approximated as $ \\Delta y \\approx \\frac{1}{8}\\kappa \\Delta s^2 $. Here, $\\kappa$ represents curvature, and we use $s$ to represent an infinitesimal distance, not to be confused with $t$ as commonly used to represent the parameter for the Bézier equation.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/chord_error.svg\" alt=\"Diagram of error\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eTo simplify the presentation of the math here, we’ll solve the basic parabola $y = x^2$, rather than more general quadratic Béziers. However, all quadratic Béziers are equivalent to a segment of this parabola, modulo rotation, translation, and scaling. The first two factors don’t affect flattening, and the last can be taken into account by scaling the tolerance threshold. (For the curious, this transformation is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emap_to_basic\u003c/code\u003e in the \u003ca href=\"https://github.com/raphlinus/raphlinus.github.io/tree/master/_posts/2019-12-23-flatten-quadbez.md\"\u003ecode\u003c/a\u003e for this post.) Note that $x$ in this transformed version is a linear transform of $t$ in the source Bézier: it can be written $x = x_0 + t(x_1 - x_0)$.\u003c/p\u003e\n\n\u003cp\u003eThe basic parabola has nice, simple expressions of curvature and infinitesimal arclength in terms of the parameter $x$:\u003c/p\u003e\n\n\\[\\kappa = \\frac{2}{(1 + 4x^2)^\\frac{3}{2}}\\]\n\n\\[\\Delta s = \\sqrt{1 + 4x^2} \\Delta x\\]\n\n\u003cp\u003ePlugging these into the above formula, we get an expression for the error:\u003c/p\u003e\n\n\\[\\Delta y = \\frac{(1 + 4x^2) \\Delta x^2}{4(1 + 4x^2)^\\frac{3}{2}}\\]\n\n\u003cp\u003eHolding the error fixed, we can now simplify and solve this for the step size of the parameter $x$ per segment.\u003c/p\u003e\n\n\\[\\Delta x = 2  \\sqrt{\\Delta y} \\sqrt[4]{1 + 4x^2}\\]\n\n\u003cp\u003eThe rate at which segments occur is the reciprocal of the step size (here I’m also sneaking in a change to the continuous realm).\u003c/p\u003e\n\n\\[\\frac{\\mathrm{d}\\; \\mbox{segments}}{\\mathrm{d}x} = \\frac{1}{2\\sqrt{\\Delta y}\\sqrt[4]{1 + 4x^2}}\\]\n\n\u003cp\u003eTaking this to the continuous limit, we can finally write a closed form expression for the number of segments required for the parabola segment from $x_0$ to $x_1$:\u003c/p\u003e\n\n\\[\\mbox{segments} =  \\frac{1}{2\\sqrt{\\Delta y}} \\int_{x_0}^{x_1} \\frac{1}{\\sqrt[4]{1 + 4x^2}} dx\\]\n\n\u003cp\u003eAs it turns out, this integral has a closed form solution, thanks to \u003ca href=\"https://en.wikipedia.org/wiki/Hypergeometric_function\"\u003ehypergeometric functions\u003c/a\u003e, though we won’t be making too much use of this fact; we’ll be doing numerical approximations instead. (I’ve left out the constant and am making the natural assumption that $f(0) = 0$, as it’s an odd function).\u003c/p\u003e\n\n\\[f(x) = \\int \\frac{1}{\\sqrt[4]{1 + 4x^2}} dx = x\\; {}_2F_1\\left(\\tfrac{1}{4}, \\tfrac{1}{2}; \\tfrac{3}{2}; -4x^2\\right)\\]\n\n\u003cp\u003eBut no matter how we evaluate this integral, here we have an expression that tells us how many segments we need. To make sure the solution meets or exceeds the error tolerance, we round up to the nearest integer.\u003c/p\u003e\n\n\u003ch3 id=\"actually-subdividing\"\u003eActually subdividing\u003c/h3\u003e\n\n\u003cp\u003eNow we need to come up with $t$ values to know \u003cem\u003ewhere\u003c/em\u003e to subdivide. Fortunately, given the mechanisms we’ve developed, this is fairly straightforward. I’ll actually show the code, as it’s probably clearer than trying to describe it in prose:\u003c/p\u003e\n\n\u003cdiv class=\"language-javascript highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e    \u003cspan class=\"nx\"\u003emy_subdiv\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003etol\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Map quadratic bezier segment to y = x^2 parabola.\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003eparams\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003emap_to_basic\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Compute approximate integral for x at both endpoints.\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ea0\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eapprox_myint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eparams\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ex0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ea2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eapprox_myint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eparams\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003ex2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.5\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nb\"\u003eMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea2\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003ea0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nb\"\u003eMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003esqrt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003eparams\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003escale\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"nx\"\u003etol\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003en\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nb\"\u003eMath\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003eceil\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ex0\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eapprox_inv_myint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ex2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eapprox_inv_myint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003eresult\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e\n        \u003cspan class=\"c1\"\u003e// Subdivide evenly and compute approximate inverse integral.\u003c/span\u003e\n        \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kd\"\u003elet\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e \u003cspan class=\"nx\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"o\"\u003e++\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"nx\"\u003eapprox_inv_myint\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ea0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e((\u003c/span\u003e\u003cspan class=\"nx\"\u003ea2\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003ea0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nx\"\u003ei\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"nx\"\u003en\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"c1\"\u003e// Map x parameter back to t parameter for the original segment.\u003c/span\u003e\n            \u003cspan class=\"kd\"\u003econst\u003c/span\u003e \u003cspan class=\"nx\"\u003et\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003ex0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003ex2\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"nx\"\u003ex0\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n            \u003cspan class=\"nx\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003epush\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nx\"\u003et\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n        \u003cspan class=\"nx\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"nx\"\u003epush\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nx\"\u003eresult\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cp\u003eEssentially we’re subdividing the interval in “count space” into $n$ equal parts, then evaluating the \u003cem\u003einverse function\u003c/em\u003e of the integral at each of those points. This loop could easily be evaluated in parallel, and, as we’ll see below, the actual formula for the approximate inverse integral is quite simple.\u003c/p\u003e\n\n\u003ch2 id=\"numerical-techniques\"\u003eNumerical techniques\u003c/h2\u003e\n\n\u003cp\u003eA great way to evaluate this integral is Legendre-Gauss quadrature, as described in my previous \u003ca href=\"https://raphlinus.github.io/curves/2018/12/28/bezier-arclength.html\"\u003earclength\u003c/a\u003e blog. But we don’t actually need to compute this very precisely; we’re rounding up to an integer. I played around and found a nice efficient function with roughly the same shape (including asymptotic behavior). Blue is the true curve, orange is our approximation.\u003c/p\u003e\n\n\\[f(x) \\approx \\frac{x}{0.33 + \\sqrt[4]{0.67^4 + \\frac{1}{4}x^2}}\\]\n\n\u003c!-- Todo: I'd like better images, these are screenshots from colab --\u003e\n\u003cp\u003e\u003cimg src=\"/assets/flatten_approx.png\" alt=\"Approximation of the integral\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eReading this graph is fairly intuitive; the slope is the rate at which subdivisions are needed. That’s higher in the center of the graph where the curvature is highest.\u003c/p\u003e\n\n\u003cp\u003eI actually had even better luck with the inverse function of the integral, which is in some ways more important; this is the one that’s evaluated (potentially in parallel) for each intermediate point.\u003c/p\u003e\n\n\\[f^{-1}(x) \\approx x \\left(0.61 + \\sqrt{0.39^2 + \\tfrac{1}{4}x^2}\\right)\\]\n\n\u003cp\u003e\u003cimg src=\"/assets/flatten_inverse_approx.png\" alt=\"Approximation of the inverse of the integral\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eEssentially, the first approximation gives a direct and fairly accurate solution to determining the number of segments needed, and the second gives a direct and even more accurate solution to determining the $t$ parameter values for the subdivision, so that the error is evenly divided among all the segments.\u003c/p\u003e\n\n\u003cp\u003eAn exercise for the reader is to come up with a better approximation for the first function.\u003c/p\u003e\n\n\u003ch2 id=\"comparison-to-related-work\"\u003eComparison to related work\u003c/h2\u003e\n\n\u003cp\u003eProbably the closest existing literature is the \u003ca href=\"https://pdfs.semanticscholar.org/8963/c06a92d6ca8868348b0930bbb800ff6e7920.pdf\"\u003ePrecise Flattening of Cubic Bézier Segments\u003c/a\u003e work, which is also the basis of the flattening algorithm in the \u003ca href=\"https://docs.rs/lyon/0.4.1/lyon/Bézier/index.html#flattening\"\u003elyon\u003c/a\u003e library. This approach also uses parabolas as an approximation, and greedily generates segments of the requested error tolerance.\u003c/p\u003e\n\n\u003cp\u003eMy technique is both more efficient to evaluate, and also more accurate. Because we round the segment count up to the nearest integer, the error is always within the tolerance. Because “fractional segments” wouldn’t make sense, the error of at least one segment is in general considerably less than the threshold. Using a greedy approach, that lower error belongs to the final lucky segment. But our approach distributes the error evenly.\u003c/p\u003e\n\n\u003cp\u003eThough the theory is perhaps a bit math-intensive, the code is refreshingly simple. It can probably be used as a drop-in replacement in many implementations that use recursive subdivision for flattening.\u003c/p\u003e\n\n\u003cp\u003eAnd of course, the fact that it can be evaluated in parallel, as well as predict the number of generated segments in advance, means that it’s especially well suited for GPU. I’ll very likely use this technique as I reboot \u003ca href=\"https://github.com/linebender/piet-metal\"\u003epiet-metal\u003c/a\u003e, though I’ll likely be exploring analytical approaches to rendering quadratic Béziers.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate 2019-12-25:\u003c/strong\u003e Alan MacKinnon pointed me to Sederberg’s \u003ca href=\"https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=1000\u0026amp;context=facpub#section.10.6\"\u003eCAGD notes\u003c/a\u003e, which has a simpler approach to the problem based on an error bound computed from the second derivative. This solution \u003cem\u003eis\u003c/em\u003e quite well suited to parallel evaluation, and is easy to understand, but is less than optimum especially when the curvature varies a lot within the segment. Alan also pointed to a reference to Wang’s method in the book “Pyramid Algorithms” by Ron Goldman. You can experiment with these by pressing the “s” or “w” key in the demo above.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2019-12-23T19:05:42Z",
  "Author": "raphlinus"
}