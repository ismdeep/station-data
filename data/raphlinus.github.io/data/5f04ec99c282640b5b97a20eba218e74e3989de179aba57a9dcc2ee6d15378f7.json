{
  "Source": "raphlinus.github.io",
  "Title": "Font fallback deep dive",
  "Link": "https://raphlinus.github.io/rust/skribo/text/2019/04/04/font-fallback.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eOne of the main functions of \u003ca href=\"https://github.com/linebender/skribo\"\u003eskribo\u003c/a\u003e is “font fallback,” or choosing fonts to render an arbitrary string of text. This post is a deep dive into the topic, motivating the problem and explaining the approaches to solve it.\u003c/p\u003e\n\n\u003cp\u003eWhen buying fully into the platform’s text stack, font fallback is usually handled transparently. But when doing the layout ourselves, as is done in skribo (and as is generally necessary in Web browsers), we have to query deeply into the system to find the fonts.\u003c/p\u003e\n\n\u003cp\u003eTo some extent, this blog post is explaining what’s going on in \u003ca href=\"https://github.com/pcwalton/font-kit/issues/37\"\u003efont-kit#37\u003c/a\u003e. Feel free to dig into that issue for more detail, or of course if you’d like to help out.\u003c/p\u003e\n\n\u003cp\u003eThere are two crates involved in this work: font-kit wraps the system functions for enumerating and loading fonts, and skribo does text layout using fonts obtained from font-kit; skribo contains no platform-specific code.\u003c/p\u003e\n\n\u003ch2 id=\"what-is-font-fallback\"\u003eWhat is font fallback?\u003c/h2\u003e\n\n\u003cp\u003eNo one font can cover all of Unicode, so text stacks rely on a patchwork, each of which covers some subset of scripts. A typical modern system has around 30 to 80 such fonts. Depending on the scripts used, a string might then require a bunch of different fonts to render. The problem of font fallback is to choose the fonts needed. That breaks down into the following main subproblems:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eDetermine (from the sytem) which fonts are available.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eDetermine, based on the string and the Unicode coverage of those fonts, which fonts to use.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eWhen multiple fonts have Unicode coverage, choose the best.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThat last bit is especially complex, as we’ll see. The major complications are:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eResolve \u003ca href=\"https://en.wikipedia.org/wiki/Han_unification\"\u003eHan unification\u003c/a\u003e, or more generally, prioritize based on locale.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eTry to find a font that matches the style of the primary font.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"han-unification\"\u003eHan unification\u003c/h2\u003e\n\n\u003cp\u003eOne thing that makes font choice particularly tricky is \u003ca href=\"https://en.wikipedia.org/wiki/Han_unification\"\u003eHan unification\u003c/a\u003e. Han unification was a deliberate choice by the Unicode consortium, probably motivated by the desire to make Unicode 1.0 fit in a 16 bit space, to reuse the same code point for ideographs shared by multiple scripts. A rough analogy is to use the same code point to encode Latin capital A and Greek capital alpha (“A” and “Α”). These might render the same or differently, depending on font choices. Similarly for CJK languages, there is a preference based on the language. If this preference is not respected, the text is still readable, but will look wrong. Getting Han unification right is a requirement for a modern text stack.\u003c/p\u003e\n\n\u003cp\u003eIn the following example, the text is the same sequence of Unicode code points. Only the locale is set differently, and this has significant effect on the rendering.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/shaping_cjk_locale.png\" width=\"341\" height=\"171\" alt=\"CJK shaping example\" style=\"margin-left: auto; margin-right: auto; display: block\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAn immediate consequence is that code point is not adequate for choosing a font, the locale must be an input as well. In HTML, locale can be set explicitly through the “lang” attribute. Failing that, a number of heuristics determine it, and in the last resort the system locale settings.\u003c/p\u003e\n\n\u003cp\u003eAnother consequence is that a fallback font set can’t be just a list of fonts. There must at the least be metadata indicating language preference for Han unification (and in general choosing between alternate fonts based on language, though CJK is the most prominent case).\u003c/p\u003e\n\n\u003ch2 id=\"finding-the-system-fonts\"\u003eFinding the system fonts\u003c/h2\u003e\n\n\u003cp\u003eAt the core of font fallback is finding the system fonts suitable for the fallback chain. Note that in some cases this might not be necesary: it’s possible to bundle a high quality set of free fonts such as the \u003ca href=\"https://www.google.com/get/noto/\"\u003eNoto fonts\u003c/a\u003e, and more are being developed. That would give consistent rendering across platforms and avoid the need to query the system. But it’s a large download (tens of MB at least, more if more styles and weights are desired), so most of the time we want to get the fonts from the system.\u003c/p\u003e\n\n\u003cp\u003eThere is no standard way to do this. Most platforms want you to buy in to their text stacks completely. Yet, largely motivated by Web browsers, there’s usually a way to get to the fallback fonts that’s not a complete hack. Of course, a complete hack is sometimes viable, you can just hard-code a list of fonts by system, along with knowledge of their CJK preferences.\u003c/p\u003e\n\n\u003cp\u003eThe methods for finding fallback fonts vary by system, and within a system vary by time; often methods more suitable to Web use cases are available only in newer versions.\u003c/p\u003e\n\n\u003ch3 id=\"windows\"\u003eWindows\u003c/h3\u003e\n\n\u003cp\u003eFor Windows 8.1 and later, there is a pretty good API for finding the fallback fonts: the \u003ca href=\"https://docs.microsoft.com/en-us/windows/desktop/api/dwrite_2/nn-dwrite_2-idwritefontfallback\"\u003eIDWriteFontFallback\u003c/a\u003e interface. This is a query \u003cem\u003eby string,\u003c/em\u003e so it will need to be queried often, and it is difficult to cache the results. A good feature is that it doesn’t bother with unused fonts.\u003c/p\u003e\n\n\u003cp\u003eOn older versions of Windows, there are a number of approaches, probably the best is to do layout for the string using the platform renderer, and then use a custom “renderer” that doesn’t actually render, but instead collects references to the fonts. Firefox does a version of this. Chrome does something similar but uses the older Uniscribe as well (this is compatible all the way back to XP).\u003c/p\u003e\n\n\u003ch3 id=\"macos\"\u003emacOS\u003c/h3\u003e\n\n\u003cp\u003eIt would be too much to ask for other platforms to provide a similar interface. The best way to find fallback fonts on macOS is \u003ca href=\"https://developer.apple.com/documentation/coretext/1509992-ctfontcopydefaultcascadelistforl\"\u003eCTFontCopyDefaultCascadeListForLanguages\u003c/a\u003e, which provides a list of fonts. To handle Han unification, it accepts a locale, so it will order the CJK fonts with the preferred language first. This API is not well-documented, but is fairly widely used.\u003c/p\u003e\n\n\u003cp\u003eMost of the time an app uses only one locale. In that case, it’s possible to call this function once and retain the results. It is very unusual to use more than a handful of unique locales. The flip side, though, is that you get dozens of fonts back and have to analyze them for Unicode coverage.\u003c/p\u003e\n\n\u003ch3 id=\"linux--fontconfig\"\u003eLinux / Fontconfig\u003c/h3\u003e\n\n\u003cp\u003eI haven’t researched this as much as the others, but already I see some big problems. The \u003ca href=\"https://www.freedesktop.org/wiki/Software/fontconfig/\"\u003eFontconfig\u003c/a\u003e API is rich enough to enumerate the fallback fonts, and contains language metadata, but it seems to me that at least Debian simply doesn’t have a correct config. I’ve found a number of blog posts (\u003ca href=\"http://www.linuxfromscratch.org/blfs/view/svn/x/tuning-fontconfig.html\"\u003eTuning Fontconfig\u003c/a\u003e, \u003ca href=\"https://wiki.ubuntu.com/BetterCJKSupportSpecification/FontConfig\"\u003eUbuntu better CJK\u003c/a\u003e, \u003ca href=\"https://utcc.utoronto.ca/~cks/space/blog/linux/LinuxXTermFreeTypeCJKFonts\"\u003ePicking CJK fonts\u003c/a\u003e) explaining how users can tweak their configs, but this seems like it shouldn’t be necessary. I also haven’t done a survey of distros other than Debian.\u003c/p\u003e\n\n\u003cp\u003eMeanwhile, it seems that browsers work around this by hardcoding the names of common CJK fonts at least, which in turn reduces the pressure to fix the configs - things kinda work most of the time, as is typical for Linux.\u003c/p\u003e\n\n\u003cp\u003eThis is an area where I would love some help, both to figure out the best way to use existing infrastructure, and also to drive improvements in the default configs of distros.\u003c/p\u003e\n\n\u003ch3 id=\"android\"\u003eAndroid\u003c/h3\u003e\n\n\u003cp\u003eAndroid is a platform with not one but two different mechanisms. The classic mechanism is a \u003ca href=\"https://android.googlesource.com/platform/frameworks/base/+/master/data/fonts/fonts.xml\"\u003efonts.xml\u003c/a\u003e file which lists out all the fonts along with their preferred language. That’s enough data to make this work. Probably one of the easiest and most efficient ways to adapt it is to provide the same interface as macOS above, then you just get a list of fonts appropriately prioritized for the locale.\u003c/p\u003e\n\n\u003cp\u003eBut at the top of the fonts.xml file is a scary warning that it is going away in “the next release”. There’s a new API called \u003ca href=\"https://developer.android.com/reference/android/graphics/fonts/SystemFonts\"\u003eSystemFonts\u003c/a\u003e, for which documentation is available for the Java but not yet NDK version. It’s likely that there will be an “itemize” method that will behave similarly as the \u003ca href=\"https://docs.microsoft.com/en-us/windows/desktop/api/dwrite_2/nf-dwrite_2-idwritefontfallback-mapcharacters\"\u003eMapCharacters\u003c/a\u003e method on recent Windows.\u003c/p\u003e\n\n\u003cp\u003eSo the approach is to check version and do one or the other.\u003c/p\u003e\n\n\u003ch2 id=\"performance-considerations\"\u003ePerformance considerations\u003c/h2\u003e\n\n\u003cp\u003eThese fallback queries can be expensive, so it’s important to minimize their impact. The two major approaches each have their challenges.\u003c/p\u003e\n\n\u003cp\u003eWhen the platform does itemization (as in Windows and new Android), you get fonts back, but no obvious way to tell that it’s the same font as a previous query. This is important for reuse of resources derived from a font, such as rendered glyphs.\u003c/p\u003e\n\n\u003cp\u003eFor this purpose, Skia implements a unique ID per font, but its implementation is heuristic - in particular, it would be pretty easy to trick it by construction of malicious fonts. As far as I know, there’s no reliable way to do this on Windows, and we’ll see about Android. It’s possible we can use pointer equality for system fonts. I’m still looking into it; \u003ca href=\"https://github.com/pcwalton/font-kit/issues/40\"\u003efont-kit#40\u003c/a\u003e tracks that work.\u003c/p\u003e\n\n\u003cp\u003eWhen the platform gives a list of suitable fonts (as in macOS and old Android), the major problem is digging through the fonts to determine which actually have the right Unicode coverage. It’s important to avoid copying font data, otherwise loading those fonts could take tens of MB of RAM, and quite a bit of time for allocating, copying, and analysis.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eI’m spending more time on font fallback than I originally planned. That said, I think I’m on track to largely solve it, and hopeful that this will be a very useful resource for the Rust ecosystem. I think the general problem of making abstractions for platform services is one of the main areas in Rust that needs work now, and one of the great potential strengths of the language - most other languages either aren’t suitable for performant, low level work, or have gaps in their platform coverage, or both.\u003c/p\u003e\n\n\u003cp\u003eIn investigating the issue, I’ve read lots of open source code, especially Qt, Blink, and Gecko. A lot of the knowledge around text is arcane, but it is out there in the form of working code.\u003c/p\u003e\n\n\u003cp\u003eThanks again to the Servo people for supporting this work.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2019-04-04T19:03:42Z",
  "Author": "raphlinus"
}