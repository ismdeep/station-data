{
  "Source": "raphlinus.github.io",
  "Title": "Low level text layout kickoff",
  "Link": "https://raphlinus.github.io/rust/skribo/text/2019/02/27/text-layout-kickoff.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThis post is to announce a new Rust library for low-level text layout, called “\u003ca href=\"https://github.com/linebender/skribo\"\u003eskribo\u003c/a\u003e” (the Esperanto word for “writing”). This has been a major gap in the Rust ecosystem, and I hope the new crate can improve text handling across the board.\u003c/p\u003e\n\n\u003ch2 id=\"multiple-shaping-engines\"\u003eMultiple shaping engines\u003c/h2\u003e\n\n\u003cp\u003eThe skribo library doesn’t do shaping itself; it is basically a glue library on top of an actual shaping engine. Most users will use \u003ca href=\"https://www.freedesktop.org/wiki/Software/HarfBuzz/\"\u003eHarfBuzz\u003c/a\u003e for this, the industry-standard library. However, a goal for skribo is that it abstracts over the details of the shaping engine. Other choices include platform text (DirectWrite on Windows, CoreText on macOS and iOS). Also, if and when a Rust-native shaping library emerges, we want to make it easy to switch to that.\u003c/p\u003e\n\n\u003cp\u003eThe choice of whether to use HarfBuzz or platform shaping is a tradeoff. Using HarfBuzz means more consistency across platforms, and thus an easier testing story. Using platform text means more consistency with other apps on the platform, and less code in the critical path (so shorter compile times and smaller executables).\u003c/p\u003e\n\n\u003cp\u003eShaping is essential to complex scripts such as Devanagari and Arabic, but important even in Latin to improve quality through ligatures and kerning. On the left is text without shaping (rendered with Cairo’s “toy text API”), on the right properly shaped text (rendered with DirectWrite):\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/shaping_comparison.png\" width=\"480\" height=\"120\" alt=\"CJK shaping example\" style=\"margin-left: auto; margin-right: auto; display: block\"/\u003e\u003c/p\u003e\n\n\u003ch2 id=\"expected-users\"\u003eExpected users\u003c/h2\u003e\n\n\u003cp\u003eThis work is funded by Mozilla Research to be used in Servo. Doing text layout for the Web is a very complex problem. The higher level representation of rich text is very tightly bound to the DOM and CSS. All that logic needs to live in Servo, with the lower level providing a clean interface to lay out a span of text with a \u003cem\u003esingle\u003c/em\u003e style and a single \u003ca href=\"https://en.wikipedia.org/wiki/Bi-directional_text\"\u003eBiDi\u003c/a\u003e direction.\u003c/p\u003e\n\n\u003cp\u003eThe second major use case is \u003ca href=\"https://github.com/linebender/piet\"\u003epiet\u003c/a\u003e, the 2D graphics abstraction I’ve been working on. Currently for the Cairo back-end piet uses the “toy text API,” which is of course \u003ca href=\"https://github.com/linebender/piet/issues/10\"\u003einadequate\u003c/a\u003e. The idea is that skribo handles text layout for Cairo and all future low-level drawing back-ends (including any future back-end using WebRender or direct Vulkan drawing). A requirement for both Web layout and text editing within GUI apps (including potential front-end work for \u003ca href=\"https://xi-editor.io/\"\u003exi-editor\u003c/a\u003e) is fine-grained measurement of text, including positioning of carets within text as well as width measurement of spans of text.\u003c/p\u003e\n\n\u003cp\u003eAdditionally, just about every game engine currently being implemented in Rust uses a simplistic approach to text layout, just looking up each codepoint in the font’s cmap and then using its advance width to build a layout. I want to encourage all such engines to migrate to skribo, and want to make that experience smooth. In short, if you’re using \u003ca href=\"https://github.com/redox-os/rusttype\"\u003erusttype\u003c/a\u003e, you should consider using skribo.\u003c/p\u003e\n\n\u003ch2 id=\"problems-to-solve\"\u003eProblems to solve\u003c/h2\u003e\n\n\u003cp\u003eAside from being glue abstracting over implementation details, the main actual problem skribo addresses is choosing fonts from a “font collection”, which is similar to a “font stack” in CSS. In general, this will contain custom fonts as well as a set of system fallback fonts. This might seem like a relatively simple problem, but there are tons of tricky details – no doubt, I’ll write a blog post on just this topic.\u003c/p\u003e\n\n\u003cp\u003eAnother major problem is making sure locale information affects layout properly. One of the most important to solve is \u003ca href=\"https://en.wikipedia.org/wiki/Han_unification\"\u003eHan unification\u003c/a\u003e, which is the fact that Chinese, Japanese, and Korean share unicode codepoints even though they can be considered different scripts. Often, they should be rendered with different fonts (meaning that Unicode coverage is not the only criterion for selecting fonts). Alternatively, fonts like \u003ca href=\"https://blogs.adobe.com/CCJKType/2018/11/shsans-v2-technical-tidbits.html\"\u003eSource Han Sans\u003c/a\u003e have variant glyphs for all CJK languages, and use the “locl” OpenType feature to select them. A good layout library handles both, transparently to applications.\u003c/p\u003e\n\n\u003cp\u003eHere’s a visual example of the effect of locale on the rendering of CJK text. In all cases, the ideographs are the same sequence of Unicode code points:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/shaping_cjk_locale.png\" width=\"341\" height=\"171\" alt=\"CJK shaping example\" style=\"margin-left: auto; margin-right: auto; display: block\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eOther problems within scope are figuring out logic for “fake bold” and “fake italic” when the font collection doesn’t provide true versions, as well as adding \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/letter-spacing\"\u003eletter-spacing\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eLooking forward, \u003ca href=\"https://docs.microsoft.com/en-us/typography/opentype/spec/otvaroverview\"\u003efont variations\u003c/a\u003e affect layout, so one of the goals is to plumb this through to the underlying shaping engine, where supported.\u003c/p\u003e\n\n\u003ch2 id=\"performance\"\u003ePerformance\u003c/h2\u003e\n\n\u003cp\u003eUnfortunately, OpenType shaping is a fairly expensive operation. A lot of optimization has gone into HarfBuzz, but it’s still potentially a major contribution to overall layout time. The Web has struggled with this. For a long time, Chrome had both a “simple path” and a “complex path”, where shaping was disabled in the simple path. This degrades the experience and exposes this detail to users. So a few years ago Chrome implemented a word cache to accelerate the complex path, making it suitable for all use, and the simple path was \u003ca href=\"https://www.chromium.org/teams/layout-team/eliminating-simple-text\"\u003eremoved\u003c/a\u003e in October 2016. All this is described in a \u003ca href=\"http://www.unicodeconference.org/presentations/S5T2-R%C3%B6ttsches-Esfahbod.pdf\"\u003eUnicode presentation on Chrome text\u003c/a\u003e (PDF).\u003c/p\u003e\n\n\u003cp\u003eSimilarly, the design of skribo will include a word cache. This should be transparent to most users. There will be careful attention to the design of the cache key, as the locale, OpenType features, and other style attributes need to be included along with the text, and complex data structures can be a significant performance issue in hashtable-based caches.\u003c/p\u003e\n\n\u003ch2 id=\"out-of-scope\"\u003eOut of scope\u003c/h2\u003e\n\n\u003cp\u003eA number of problems are best handled at a higher level and are out of scope for this library:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eParagraph level formatting including line breaking.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eHyphenation.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eRepresentation of rich text.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eBiDi.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eMany of these problems \u003cem\u003eare\u003c/em\u003e solved by comparable platform text libraries such as DirectWrite and CoreText. I can imagine a higher level text layout crate that solves some of these problems, but for the time being this would need to be a community effort, I am not driving it as part of the skribo effort.\u003c/p\u003e\n\n\u003ch2 id=\"inspirations\"\u003eInspirations\u003c/h2\u003e\n\n\u003cp\u003eThe scope of skribo is similar to \u003ca href=\"https://www.pango.org/\"\u003epango\u003c/a\u003e, which is well-established in the free software world. However, its implementation will hew even more closely to \u003ca href=\"https://android.googlesource.com/platform/frameworks/minikin/\"\u003eMinikin\u003c/a\u003e, the low-level text layout library in Android. I’m biased of course, having written the first version of minikin, but I think there are many good reasons to use it as a basis, and am not alone; the \u003ca href=\"https://github.com/flutter/flutter/issues/11092\"\u003elibtxt\u003c/a\u003e layout engine used by Flutter is also based on a fork of Minikin.\u003c/p\u003e\n\n\u003cp\u003eSince one of the main use cases is web layout, existing open source implementations of Web layout, in Chrome (Blink) and Firefox (Gecko) will also be major sources.\u003c/p\u003e\n\n\u003ch2 id=\"what-next\"\u003eWhat next?\u003c/h2\u003e\n\n\u003cp\u003eI’ll be putting together a requirements document, then a design document. There’s a bit more detail on the \u003ca href=\"https://drive.google.com/open?id=1aw41q_izail-p99mN8dHrJeh9tMQ-Pldi54W6m7MHU8\"\u003eproject roadmap\u003c/a\u003e. I really want feedback on both of those, especially from potential users of the library. Then, over the next few weeks I will be intensively prototyping and refining the design.\u003c/p\u003e\n\n\u003cp\u003eThis project is explicitly intended to teach and engage the community, rather than just being a black-box chunk of code. As I work, I expect to write a series of blog posts that explains problems in text layout that I’m solving. So a good way to follow the work is this blog. Feel free to ask questions also!\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2019-02-27T18:16:42Z",
  "Author": "raphlinus"
}