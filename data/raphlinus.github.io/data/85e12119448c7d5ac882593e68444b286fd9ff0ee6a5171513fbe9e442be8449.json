{
  "Source": "raphlinus.github.io",
  "Title": "Parallel curves of cubic BÃ©ziers",
  "Link": "https://raphlinus.github.io/curves/2022/09/09/parallel-beziers.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003c!-- I should figure out a cleaner way to do this include, rather than cutting and pasting. Ah well.--\u003e\n\u003cscript type=\"text/x-mathjax-config\"\u003e\n\tMathJax.Hub.Config({\n\t\ttex2jax: {\n\t\t\tinlineMath: [['$', '$']]\n\t\t}\n\t});\n\u003c/script\u003e\n\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" type=\"text/javascript\"\u003e\u003c/script\u003e\n\n\u003cstyle\u003e\n    svg {\n        touch-action: pinch-zoom;\n        overflow: visible;\n    }\n    svg .handle {\n        pointer-events: all;\n    }\n    svg .handle:hover {\n        r: 6;\n    }\n    svg .quad {\n        stroke-width: 1.5px;\n        stroke: #222;\n    }\n    svg .hull {\n        stroke: #a6c;\n    }\n    svg .approx_handle {\n        stroke: #444;\n    }\n    svg .polyline {\n    }\n    svg text {\n        font-family: sans-serif;\n    }\n    svg .button {\n        fill: #aad;\n        stroke: #44f;\n    }\n    svg .button:hover {\n        fill: #bbf;\n    }\n    svg text {\n        pointer-events: none;\n    }\n    svg #grid line {\n        stroke: #e4e4e4;\n    }\n    svg .band {\n        fill: #fda;\n        opacity: 0.3;\n    }\n    img {\n        margin: auto;\n        margin: auto;\n        display: block;\n    }\n    input#d {\n        width: 300px;\n    }\n    input#tol {\n        width: 4em;\n    }\n    input#alg {\n        width: 4em;\n    }\n    .controls {\n        display: grid;\n        grid-template-columns: repeat(3, max-content);\n        column-gap: 20px;\n        margin-bottom: 15px;\n    }\n\u003c/style\u003e\n\n\u003csvg id=\"s\" width=\"700\" height=\"500\"\u003e\n    \u003cg id=\"grid\"\u003e\u003c/g\u003e\n\u003c/svg\u003e\n\u003cdiv class=\"controls\"\u003e\n    \u003cdiv\u003eDistance\u003c/div\u003e\n    \u003cdiv\u003eAccuracy\u003c/div\u003e\n    \u003cdiv\u003eMethod\u003c/div\u003e\n    \u003cdiv\u003e\u003cinput type=\"range\" min=\"1\" max=\"100\" value=\"40\" id=\"d\"/\u003e\u003c/div\u003e\n    \u003cdiv\u003e\u003cinput type=\"button\" id=\"tol\" value=\"1\"/\u003e\u003c/div\u003e\n    \u003cdiv\u003e\u003cinput type=\"button\" id=\"alg\" value=\"Fit\"/\u003e\u003c/div\u003e\n\u003c/div\u003e\n\u003cscript\u003e\n// Copyright 2022 Google LLC\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n\n//     https://www.apache.org/licenses/LICENSE-2.0\n\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nconst svgNS = \"http://www.w3.org/2000/svg\";\n\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    lerp(p2, t) {\n        return new Point(this.x + (p2.x - this.x) * t, this.y + (p2.y - this.y) * t);\n    }\n\n    dist(p2) {\n        return Math.hypot(p2.x - this.x, p2.y - this.y);\n    }\n\n    hypot2() {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    hypot() {\n        return Math.sqrt(this.hypot2());\n    }\n\n    dot(other) {\n        return this.x * other.x + this.y * other.y;\n    }\n\n    cross(other) {\n        return this.x * other.y - this.y * other.x;\n    }\n\n    plus(other) {\n        return new Point(this.x + other.x, this.y + other.y);\n    }\n\n    minus(other) {\n        return new Point(this.x - other.x, this.y - other.y);\n    }\n\n    atan2() {\n        return Math.atan2(this.y, this.x);\n    }\n}\n\nclass Affine {\n    constructor(c) {\n        this.c = c;\n    }\n\n    apply_pt(p) {\n        const c = this.c;\n        const x = c[0] * p.x + c[2] * p.y + c[4];\n        const y = c[1] * p.x + c[3] * p.y + c[5];\n        return new Point(x, y);\n    }\n\n    apply_cubic(cu) {\n        const c = this.c;\n        const new_c = new Float64Array(8);\n        for (let i = 0; i \u003c 8; i += 2) {\n            new_c[i] = c[0] * cu.c[i] + c[2] * cu.c[i + 1] + c[4];\n            new_c[i + 1] = c[1] * cu.c[i] + c[3] * cu.c[i + 1] + c[5];\n        }\n        return new CubicBez(new_c);\n    }\n\n    static rotate(th) {\n        const c = new Float64Array(6);\n        c[0] = Math.cos(th);\n        c[1] = Math.sin(th);\n        c[2] = -c[1];\n        c[3] = c[0];\n        return new Affine(c);\n    }\n}\n\n// Compute an approximation to int (1 + 4x^2) ^ -0.25 dx\n// This isn't especially good but will do.\nfunction approx_myint(x) {\n   const d = 0.67; \n   return x / (1 - d + Math.pow(Math.pow(d, 4) + 0.25 * x * x, 0.25));\n}\n\n// Approximate the inverse of the function above.\n// This is better.\nfunction approx_inv_myint(x) {\n    const b = 0.39;\n    return x * (1 - b + Math.sqrt(b * b + 0.25 * x * x));\n}\n\nclass QuadBez {\n    constructor(x0, y0, x1, y1, x2, y2) {\n        this.x0 = x0;\n        this.y0 = y0;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n    }\n\n    to_svg_path() {\n        return `M${this.x0} ${this.y0} Q${this.x1} ${this.y1} ${this.x2} ${this.y2}`\n    }\n\n    eval(t) {\n        const mt = 1 - t;\n        const x = this.x0 * mt * mt + 2 * this.x1 * t * mt + this.x2 * t * t;\n        const y = this.y0 * mt * mt + 2 * this.y1 * t * mt + this.y2 * t * t;\n        return new Point(x, y);\n    }\n\n    eval_deriv(t) {\n        const mt = 1 - t;\n        const x = 2 * (mt * (this.x1 - this.x0) + t * (this.x2 - this.x1));\n        const y = 2 * (mt * (this.y1 - this.y0) + t * (this.y2 - this.y1));\n        return new Point(x, y);\n    }\n\n    weightsum(c0, c1, c2) {\n        const x = c0 * this.x0 + c1 * this.x1 + c2 * this.x2;\n        const y = c0 * this.y0 + c1 * this.y1 + c2 * this.y2;\n        return new Point(x, y);\n    }\n\n    subsegment(t0, t1) {\n        const p0 = this.eval(t0);\n        const p2 = this.eval(t1);\n        const dt = t1 - t0;\n        const p1x = p0.x + (this.x1 - this.x0 + t0 * (this.x2 - 2 * this.x1 + this.x0)) * dt;\n        const p1y = p0.y + (this.y1 - this.y0 + t0 * (this.y2 - 2 * this.y1 + this.y0)) * dt;\n        return new QuadBez(p0.x, p0.y, p1x, p1y, p2.x, p2.y);\n    }\n}\n\nconst GAUSS_LEGENDRE_COEFFS_8 = [\n    0.3626837833783620, -0.1834346424956498,\n    0.3626837833783620, 0.1834346424956498,\n    0.3137066458778873, -0.5255324099163290,\n    0.3137066458778873, 0.5255324099163290,\n    0.2223810344533745, -0.7966664774136267,\n    0.2223810344533745, 0.7966664774136267,\n    0.1012285362903763, -0.9602898564975363,\n    0.1012285362903763, 0.9602898564975363,\n];\n\nconst GAUSS_LEGENDRE_COEFFS_8_HALF = [\n    0.3626837833783620, 0.1834346424956498,\n    0.3137066458778873, 0.5255324099163290,\n    0.2223810344533745, 0.7966664774136267,\n    0.1012285362903763, 0.9602898564975363,\n];\n\nconst GAUSS_LEGENDRE_COEFFS_16_HALF = [\n    0.1894506104550685, 0.0950125098376374,\n    0.1826034150449236, 0.2816035507792589,\n    0.1691565193950025, 0.4580167776572274,\n    0.1495959888165767, 0.6178762444026438,\n    0.1246289712555339, 0.7554044083550030,\n    0.0951585116824928, 0.8656312023878318,\n    0.0622535239386479, 0.9445750230732326,\n    0.0271524594117541, 0.9894009349916499,\n];\n\nconst GAUSS_LEGENDRE_COEFFS_24_HALF = [\n    0.1279381953467522, 0.0640568928626056,\n    0.1258374563468283, 0.1911188674736163,\n    0.1216704729278034, 0.3150426796961634,\n    0.1155056680537256, 0.4337935076260451,\n    0.1074442701159656, 0.5454214713888396,\n    0.0976186521041139, 0.6480936519369755,\n    0.0861901615319533, 0.7401241915785544,\n    0.0733464814110803, 0.8200019859739029,\n    0.0592985849154368, 0.8864155270044011,\n    0.0442774388174198, 0.9382745520027328,\n    0.0285313886289337, 0.9747285559713095,\n    0.0123412297999872, 0.9951872199970213,\n];\n\nconst GAUSS_LEGENDRE_COEFFS_32 = [\n    0.0965400885147278, -0.0483076656877383,\n    0.0965400885147278, 0.0483076656877383,\n    0.0956387200792749, -0.1444719615827965,\n    0.0956387200792749, 0.1444719615827965,\n    0.0938443990808046, -0.2392873622521371,\n    0.0938443990808046, 0.2392873622521371,\n    0.0911738786957639, -0.3318686022821277,\n    0.0911738786957639, 0.3318686022821277,\n    0.0876520930044038, -0.4213512761306353,\n    0.0876520930044038, 0.4213512761306353,\n    0.0833119242269467, -0.5068999089322294,\n    0.0833119242269467, 0.5068999089322294,\n    0.0781938957870703, -0.5877157572407623,\n    0.0781938957870703, 0.5877157572407623,\n    0.0723457941088485, -0.6630442669302152,\n    0.0723457941088485, 0.6630442669302152,\n    0.0658222227763618, -0.7321821187402897,\n    0.0658222227763618, 0.7321821187402897,\n    0.0586840934785355, -0.7944837959679424,\n    0.0586840934785355, 0.7944837959679424,\n    0.0509980592623762, -0.8493676137325700,\n    0.0509980592623762, 0.8493676137325700,\n    0.0428358980222267, -0.8963211557660521,\n    0.0428358980222267, 0.8963211557660521,\n    0.0342738629130214, -0.9349060759377397,\n    0.0342738629130214, 0.9349060759377397,\n    0.0253920653092621, -0.9647622555875064,\n    0.0253920653092621, 0.9647622555875064,\n    0.0162743947309057, -0.9856115115452684,\n    0.0162743947309057, 0.9856115115452684,\n    0.0070186100094701, -0.9972638618494816,\n    0.0070186100094701, 0.9972638618494816,\n];\n\nconst GAUSS_LEGENDRE_COEFFS_32_HALF = [\n    0.0965400885147278, 0.0483076656877383,\n    0.0956387200792749, 0.1444719615827965,\n    0.0938443990808046, 0.2392873622521371,\n    0.0911738786957639, 0.3318686022821277,\n    0.0876520930044038, 0.4213512761306353,\n    0.0833119242269467, 0.5068999089322294,\n    0.0781938957870703, 0.5877157572407623,\n    0.0723457941088485, 0.6630442669302152,\n    0.0658222227763618, 0.7321821187402897,\n    0.0586840934785355, 0.7944837959679424,\n    0.0509980592623762, 0.8493676137325700,\n    0.0428358980222267, 0.8963211557660521,\n    0.0342738629130214, 0.9349060759377397,\n    0.0253920653092621, 0.9647622555875064,\n    0.0162743947309057, 0.9856115115452684,\n    0.0070186100094701, 0.9972638618494816,\n];\n\nfunction tri_sign(x0, y0, x1, y1) {\n    return x1 * (y0 - y1) - y1 * (x0 - x1);\n}\n\n// Return distance squared\nfunction line_nearest_origin(x0, y0, x1, y1) {\n    const dx = x1 - x0;\n    const dy = y1 - y0;\n    let dotp = -dx * x0 - dy * y0;\n    let d_sq = dx * dx + dy * dy;\n    if (dotp \u003c= 0) {\n        return x0 * x0 + y0 * y0;\n    } else if (dotp \u003e= d_sq) {\n        return x1 * x1 + y1 * y1;\n    } else {\n        const t = dotp / d_sq;\n        const x = x0 + t * (x1 - x0);\n        const y = y0 + t * (y1 - y0);\n        return x * x + y * y;\n    }\n}\n\nclass CubicBez {\n    /// Argument is array of coordinate values [x0, y0, x1, y1, x2, y2, x3, y3].\n    constructor(coords) {\n        this.c = coords;\n    }\n\n    static from_pts(p0, p1, p2, p3) {\n        const c = new Float64Array(8);\n        c[0] = p0.x;\n        c[1] = p0.y;\n        c[2] = p1.x;\n        c[3] = p1.y;\n        c[4] = p2.x;\n        c[5] = p2.y;\n        c[6] = p3.x;\n        c[7] = p3.y;\n        return new CubicBez(c);\n    }\n\n    p0() {\n        return new Point(this.c[0], this.c[1]);\n    }\n\n    p1() {\n        return new Point(this.c[2], this.c[3]);\n    }\n\n    p2() {\n        return new Point(this.c[4], this.c[5]);\n    }\n\n    p3() {\n        return new Point(this.c[6], this.c[7]);\n    }\n\n    to_svg_path() {\n        const c = this.c;\n        return `M${c[0]} ${c[1]}C${c[2]} ${c[3]} ${c[4]} ${c[5]} ${c[6]} ${c[7]}`\n    }\n\n    weightsum(c0, c1, c2, c3) {\n        const x = c0 * this.c[0] + c1 * this.c[2] + c2 * this.c[4] + c3 * this.c[6];\n        const y = c0 * this.c[1] + c1 * this.c[3] + c2 * this.c[5] + c3 * this.c[7];\n        return new Point(x, y);\n    }\n\n    eval(t) {\n        const mt = 1 - t;\n        const c0 = mt * mt * mt;\n        const c1 = 3 * mt * mt * t;\n        const c2 = 3 * mt * t * t;\n        const c3 = t * t * t;\n        return this.weightsum(c0, c1, c2, c3);\n    }\n\n    eval_deriv(t) {\n        const mt = 1 - t;\n        const c0 = -3 * mt * mt;\n        const c3 = 3 * t * t;\n        const c1 = -6 * t * mt - c0;\n        const c2 = 6 * t * mt - c3;\n        return this.weightsum(c0, c1, c2, c3);\n    }\n\n    // quadratic bezier with matching endpoints and minimum max vector error\n    midpoint_quadbez() {\n        const p1 = this.weightsum(-0.25, 0.75, 0.75, -0.25);\n        return new QuadBez(this.c[0], this.c[1], p1.x, p1.y, this.c[6], this.c[7]);\n    }\n\n    subsegment(t0, t1) {\n        let c = new Float64Array(8);\n        const p0 = this.eval(t0);\n        const p3 = this.eval(t1);\n        c[0] = p0.x;\n        c[1] = p0.y;\n        const scale = (t1 - t0) / 3;\n        const d1 = this.eval_deriv(t0);\n        c[2] = p0.x + scale * d1.x;\n        c[3] = p0.y + scale * d1.y;\n        const d2 = this.eval_deriv(t1);\n        c[4] = p3.x - scale * d2.x;\n        c[5] = p3.y - scale * d2.y;\n        c[6] = p3.x;\n        c[7] = p3.y;\n        return new CubicBez(c);\n    }\n\n    area() {\n        const c = this.c;\n        return (c[0] * (6 * c[3] + 3 * c[5] + c[7])\n            + 3 * (c[2] * (-2 * c[1] + c[5] + c[7]) - c[4] * (c[1] + c[3] - 2 * c[7]))\n            - c[6] * (c[1] + 3 * c[3] + 6 * c[5]))\n            * 0.05;\n    }\n\n    chord() {\n        return new Line([this.c[0], this.c[1], this.c[6], this.c[7]]);\n    }\n\n    deriv() {\n        const c = this.c;\n        return new QuadBez(\n            3 * (c[2] - c[0]), 3 * (c[3] - c[1]),\n            3 * (c[4] - c[2]), 3 * (c[5] - c[3]),\n            3 * (c[6] - c[4]), 3 * (c[7] - c[5])\n        );\n    }\n\n    // A pretty good algorithm; kurbo does more sophisticated error analysis.\n    arclen(accuracy) {\n        return this.arclen_rec(accuracy, 0);\n    }\n\n    arclen_rec(accuracy, depth) {\n        const c = this.c;\n        const d03x = c[6] - c[0];\n        const d03y = c[7] - c[1];\n        const d01x = c[2] - c[0];\n        const d01y = c[3] - c[1];\n        const d12x = c[4] - c[2];\n        const d12y = c[5] - c[3];\n        const d23x = c[6] - c[4];\n        const d23y = c[7] - c[5];\n        const lp_lc = Math.hypot(d01x, d01y) + Math.hypot(d12x, d12y)\n            + Math.hypot(d23x, d23y) - Math.hypot(d03x, d03y);\n        const dd1x = d12x - d01x;\n        const dd1y = d12y - d01y;\n        const dd2x = d23x - d12x;\n        const dd2y = d23y - d12y;\n        const dmx = 0.25 * (d01x + d23x) + 0.5 * d12x;\n        const dmy = 0.25 * (d01y + d23y) + 0.5 * d12y;\n        const dm1x = 0.5 * (dd2x + dd1x);\n        const dm1y = 0.5 * (dd2y + dd1y);\n        const dm2x = 0.25 * (dd2x - dd1x);\n        const dm2y = 0.25 * (dd2y - dd1y);\n        const co_e = GAUSS_LEGENDRE_COEFFS_8;\n        let est = 0;\n        for (let i = 0; i \u003c co_e.length; i += 2) {\n            const xi = co_e[i + 1];\n            const dx = dmx + dm1x * xi + dm2x * (xi * xi);\n            const dy = dmy + dm1y * xi + dm2y * (xi * xi);\n            const ddx = dm1x + dm2x * (2 * xi);\n            const ddy = dm1y + dm2y * (2 * xi);\n            est += co_e[i] * (ddx * ddx + ddy * ddy) / (dx * dx + dy * dy);\n        }\n        const est3 = est * est * est;\n        const est_gauss8_err = Math.min(est3 * 2.5e-6, 3e-2) * lp_lc;\n        let co = null;\n        if (Math.min(est3 * 2.5e-6, 3e-2) * lp_lc \u003c accuracy) {\n            co = GAUSS_LEGENDRE_COEFFS_8_HALF;\n        } else if (Math.min(est3 * est3 * 1.5e-11, 9e-3) * lp_lc \u003c accuracy) {\n            co = GAUSS_LEGENDRE_COEFFS_16_HALF;\n        } else if (Math.min(est3 * est3 * est3 * 3.5e-16, 3.5e-3) * lp_lc \u003c accuracy\n            || depth \u003e= 20)\n        {\n            co = GAUSS_LEGENDRE_COEFFS_24_HALF;\n        } else {\n            const c0 = this.subsegment(0, 0.5);\n            const c1 = this.subsegment(0.5, 1);\n            return c0.arclen_rec(accuracy * 0.5, depth + 1)\n                + c1.arclen_rec(accuracy * 0.5, depth + 1);\n        }\n        let sum = 0;\n        for (let i = 0; i \u003c co.length; i += 2) {\n            const xi = co[i + 1];\n            const wi = co[i];\n            const dx = dmx + dm2x * (xi * xi);\n            const dy = dmy + dm2y * (xi * xi);\n            const dp = Math.hypot(dx + dm1x * xi, dy + dm1y * xi);\n            const dm = Math.hypot(dx - dm1x * xi, dy - dm1y * xi);\n            sum += wi * (dp + dm);\n        }\n        return 1.5 * sum;\n    }\n\n    inv_arclen(s, accuracy) {\n        if (s \u003c= 0) {\n            return 0;\n        }\n        const total_arclen = this.arclen(accuracy);\n        if (s \u003e= total_arclen) {\n            return 1;\n        }\n        // For simplicity, measure arclen from 0 rather than stateful delta.\n        const f = t =\u003e this.subsegment(0, t).arclen(accuracy) - s;\n        const epsilon = accuracy / total_arclen;\n        return solve_itp(f, 0, 1, epsilon, 1, 2, -s, total_arclen -s);\n    }\n\n    find_offset_cusps(d) {\n        const q = this.deriv();\n        // x'' cross x' is a quadratic polynomial in t\n        const d0x = q.x0;\n        const d0y = q.y0;\n        const d1x = 2 * (q.x1 - q.x0);\n        const d1y = 2 * (q.y1 - q.y0);\n        const d2x = q.x0 - 2 * q.x1 + q.x2;\n        const d2y = q.y0 - 2 * q.y1 + q.y2;\n        const c0 = d1x * d0y - d1y * d0x;\n        const c1 = 2 * (d2x * d0y - d2y * d0x);\n        const c2 = d2x * d1y - d2y * d1x;\n        const cusps = new CuspAccumulator(d, q, c0, c1, c2);\n        this.find_offset_cusps_rec(d, cusps, 0, 1, c0, c1, c2);\n        return cusps.reap();\n    }\n\n    find_offset_cusps_rec(d, cusps, t0, t1, c0, c1, c2) {\n        cusps.report(t0);\n        const dt = t1 - t0;\n        const q = this.subsegment(t0, t1).deriv();\n        // compute interval for ds/dt, using convex hull of hodograph\n        const d1 = tri_sign(q.x0, q.y0, q.x1, q.y1);\n        const d2 = tri_sign(q.x1, q.y1, q.x2, q.y2);\n        const d3 = tri_sign(q.x2, q.y2, q.x0, q.y0);\n        const z = !((d1 \u003c 0 || d2 \u003c 0 || d3 \u003c 0) \u0026\u0026 (d1 \u003e 0 || d2 \u003e 0 || d3 \u003e 0));\n        const ds0 = q.x0 * q.x0 + q.y0 * q.y0;\n        const ds1 = q.x1 * q.x1 + q.y1 * q.y1;\n        const ds2 = q.x2 * q.x2 + q.y2 * q.y2;\n        const max_ds = Math.sqrt(Math.max(ds0, ds1, ds2)) / dt;\n        const m1 = line_nearest_origin(q.x0, q.y0, q.x1, q.y1);\n        const m2 = line_nearest_origin(q.x1, q.y1, q.x2, q.y2);\n        const m3 = line_nearest_origin(q.x2, q.y2, q.x0, q.y0);\n        const min_ds = z ? 0 : Math.sqrt(Math.min(m1, m2, m3)) / dt;\n        //console.log('ds interval', min_ds, max_ds, 'iv', t0, t1);\n        let cmin = Math.min(c0, c0 + c1 + c2);\n        let cmax = Math.max(c0, c0 + c1 + c2);\n        const t_crit = -0.5 * c1 / c2;\n        const c_at_t = (c2 * t_crit + c1) * t_crit + c0;\n        if (t_crit \u003e 0 \u0026\u0026 t_crit \u003c 1) {\n            let c_at_t = (c2 * t_crit + c1) * t_crit + c0;\n            cmin = Math.min(cmin, c_at_t);\n            cmax = Math.max(cmax, c_at_t);\n        }\n        const min3 = min_ds * min_ds * min_ds;\n        const max3 = max_ds * max_ds * max_ds;\n        // TODO: signs are wrong, want min/max of c * d\n        // But this is a suitable starting place for clipping.\n        if (cmin * d \u003e -min3 || cmax * d \u003c -max3) {\n            //return;\n        }\n        const rmax = solve_quadratic(c0 * d + max3, c1 * d, c2 * d);\n        const rmin = solve_quadratic(c0 * d + min3, c1 * d, c2 * d);\n        let ts;\n        // TODO: length = 1 cases. Also maybe reduce case explosion?\n        if (rmax.length == 2 \u0026\u0026 rmin.length == 2) {\n            if (c2 \u003e 0) {\n                ts = [rmin[0], rmax[0], rmax[1], rmin[1]];\n            } else {\n                ts = [rmax[0], rmin[0], rmin[1], rmax[1]];\n            }\n        } else if (rmin.length == 2) {\n            if (c2 \u003e 0) {\n                ts = rmin;\n            } else {\n                ts = [t0, rmin[0], rmin[1], t1];\n            }\n        } else if (rmax.length == 2) {\n            if (c2 \u003e 0) {\n                ts = [t0, rmax[0], rmax[1], t1];\n            } else {\n                ts = rmax;\n            }\n        } else {\n            const c_at_t0 = (c2 * t0 + c1) * t0 + c0;\n            if (c_at_t0 * d \u003c -min3 \u0026\u0026 c_at_t0 * d \u003e -max3) {\n                ts = [t0, t1];\n            } else {\n                ts = [];\n            }\n        }\n        for (let i = 0; i \u003c ts.length; i += 2) {\n            const new_t0 = Math.max(t0, ts[i]);\n            const new_t1 = Math.min(t1, ts[i + 1]);\n            if (new_t1 \u003e new_t0) {\n                if (new_t1 - new_t0 \u003c 1e-9) {\n                    cusps.report(new_t0);\n                    cusps.report(new_t1);\n                } else if (new_t1 - new_t0 \u003e 0.5 * dt) {\n                    const tm = 0.5 * (new_t0 + new_t1);\n                    this.find_offset_cusps_rec(d, cusps, new_t0, tm, c0, c1, c2);\n                    this.find_offset_cusps_rec(d, cusps, tm, new_t1, c0, c1, c2);\n                } else {\n                    this.find_offset_cusps_rec(d, cusps, new_t0, new_t1, c0, c1, c2);\n                }\n                //console.log('iv', new_t0, new_t1);\n            }\n        }\n        cusps.report(t1);\n        //console.log(rmax);\n        //console.log(rmin);\n        //console.log('ts:', ts);\n    }\n\n    /*\n    // This is a brute-force solution; a more robust one is started above.\n    // Output is a partition of (0..1) into ranges, with signs.\n    find_offset_cusps(d) {\n        const result = [];\n        const n = 100;\n        const q = this.deriv();\n        // x'' cross x' is a quadratic polynomial in t\n        const d0x = q.x0;\n        const d0y = q.y0;\n        const d1x = 2 * (q.x1 - q.x0);\n        const d1y = 2 * (q.y1 - q.y0);\n        const d2x = q.x0 - 2 * q.x1 + q.x2;\n        const d2y = q.y0 - 2 * q.y1 + q.y2;\n        const c0 = d1x * d0y - d1y * d0x;\n        const c1 = 2 * (d2x * d0y - d2y * d0x);\n        const c2 = d2x * d1y - d2y * d1x;\n        let ya;\n        let last_t;\n        let t0 = 0;\n        for (let i = 0; i \u003c= n; i++) {\n            const t = i / n;\n            const ds2 = q.eval(t).hypot2();\n            const k = (((c2 * t + c1) * t) + c0) / (ds2 * Math.sqrt(ds2));\n            const yb = k * d + 1;\n            if (i != 0) {\n                if (ya \u003e= 0 != yb \u003e= 0) {\n                    let tx = (yb * last_t - ya * t) / (yb - ya);\n                    const iv = {'t0': t0, 't1': tx, 'sign': Math.sign(ya)};\n                    result.push(iv);\n                    t0 = tx;\n                }\n            }\n            ya = yb;\n            last_t = t;\n        }\n        const last_iv = {'t0': t0, 't1': 1, 'sign': Math.sign(ya)};\n        result.push(last_iv);\n        return result;\n    }\n    */\n\n    // Find intersections of ray from point p with tangent d\n    intersect_ray(p, d) {\n        const c = this.c\n        const px0 = c[0];\n        const px1 = 3 * c[2] - 3 * c[0];\n        const px2 = 3 * c[4] - 6 * c[2] + 3 * c[0];\n        const px3 = c[6] - 3 * c[4] + 3 * c[2] - c[0];\n        const py0 = c[1];\n        const py1 = 3 * c[3] - 3 * c[1];\n        const py2 = 3 * c[5] - 6 * c[3] + 3 * c[1];\n        const py3 = c[7] - 3 * c[5] + 3 * c[3] - c[1];\n        const c0 = d.y * (px0 - p.x) - d.x * (py0 - p.y);\n        const c1 = d.y * px1 - d.x * py1;\n        const c2 = d.y * px2 - d.x * py2;\n        const c3 = d.y * px3 - d.x * py3;\n        return solve_cubic(c0, c1, c2, c3).filter(t =\u003e t \u003e 0 \u0026\u0026 t \u003c 1);\n    }\n}\n\nclass CuspAccumulator {\n    constructor(d, q, c0, c1, c2) {\n        this.d = d;\n        this.q = q;\n        this.c0 = c0;\n        this.c1 = c1;\n        this.c2 = c2;\n        this.t0 = 0;\n        this.last_t = 0;\n        this.last_y = this.eval(0);\n        this.result = [];\n    }\n\n    eval(t) {\n        const ds2 = this.q.eval(t).hypot2();\n        const k = (((this.c2 * t + this.c1) * t) + this.c0) / (ds2 * Math.sqrt(ds2));\n        return k * this.d + 1;\n    }\n\n    report(t) {\n        const yb = this.eval(t);\n        const ya = this.last_y;\n        if (ya \u003e= 0 != yb \u003e= 0) {\n            // More wired: use ITP\n            let tx = (yb * this.last_t - ya * t) / (yb - ya);\n            const iv = {'t0': this.t0, 't1': tx, 'sign': Math.sign(ya)};\n            this.result.push(iv);\n            this.t0 = tx;\n        }\n        this.last_t = t;\n        this.last_y = yb;\n    }\n\n    reap() {\n        const last_iv = {'t0': this.t0, 't1': 1, 'sign': Math.sign(this.last_y)};\n        this.result.push(last_iv);\n        return this.result;\n    }\n}\n\nclass Line {\n    /// Argument is array of coordinate values [x0, y0, x1, y1].\n    constructor(coords) {\n        this.c = coords;\n    }\n\n    area() {\n        return (this.c[0] * this.c[3] - this.c[1] * this.c[2]) * 0.5;\n    }\n}\n\nfunction copysign(x, y) {\n    const a = Math.abs(x);\n    return y \u003c 0 ? -a : a;\n}\n\nfunction solve_quadratic(c0, c1, c2) {\n    const sc0 = c0 / c2;\n    const sc1 = c1 / c2;\n    if (!(isFinite(sc0) \u0026\u0026 isFinite(sc1))) {\n        const root = -c0 / c1;\n        if (isFinite(root)) {\n            return [root];\n        } else if (c0 == 0 \u0026\u0026 c1 == 0) {\n            return [0];\n        } else {\n            return [];\n        }\n    }\n    const arg = sc1 * sc1 - 4 * sc0;\n    let root1 = 0;\n    if (isFinite(arg)) {\n        if (arg \u003c 0) {\n            return [];\n        } else if (arg == 0) {\n            return [-0.5 * sc1];\n        }\n        root1 = -.5 * (sc1 + copysign(Math.sqrt(arg), sc1));\n    } else {\n        root1 = -sc1;\n    }\n    const root2 = sc0 / root1;\n    if (isFinite(root2)) {\n        if (root2 \u003e root1) {\n            return [root1, root2];\n        } else {\n            return [root2, root1];\n        }\n    }\n    return [root1];\n}\n\n// See kurbo common.rs\nfunction solve_cubic(in_c0, in_c1, in_c2, in_c3) {\n    const c2 = in_c2 / (3 * in_c3);\n    const c1 = in_c1 / (3 * in_c3);\n    const c0 = in_c0 / in_c3;\n    if (!(isFinite(c0) \u0026\u0026 isFinite(c1) \u0026\u0026 isFinite(c2))) {\n        return solve_quadratic(in_c0, in_c1, in_c2);\n    }\n    const d0 = -c2 * c2 + c1;\n    const d1 = -c1 * c2 + c0;\n    const d2 = c2 * c0 - c1 * c1;\n    const d = 4 * d0 * d2 - d1 * d1;\n    const de = -2 * c2 * d0 + d1;\n    if (d \u003c 0) {\n        const sq = Math.sqrt(-0.25 * d);\n        const r = -0.5 * de;\n        const t1 = Math.cbrt(r + sq) + Math.cbrt(r - sq);\n        return [t1 - c2];\n    } else if (d == 0) {\n        const t1 = copysign(Math.sqrt(-d0), de);\n        return [t1 - c2, -2 * t1 - c2];\n    } else {\n        const th = Math.atan2(Math.sqrt(d), -de) / 3;\n        const r0 = Math.cos(th);\n        const ss3 = Math.sin(th) * Math.sqrt(3);\n        const r1 = 0.5 * (-r0 + ss3);\n        const r2 = 0.5 * (-r0 - ss3);\n        const t = 2 * Math.sqrt(-d0);\n        return [t * r0 - c2, t * r1 - c2, t * r2 - c2];\n    }\n}\n\n// Factor a quartic polynomial into two quadratics. Based on Orellana and De Michele\n// and very similar to the version in kurbo.\nfunction solve_quartic(c0, c1, c2, c3, c4) {\n    // This doesn't special-case c0 = 0.\n    if (c4 == 0) {\n        return solve_cubic(c0, c1, c2, c3);\n    }\n    const a = c3 / c4;\n    const b = c2 / c4;\n    const c = c1 / c4;\n    const d = c0 / c4;\n    let result = solve_quartic_inner(a, b, c, d, false);\n    if (result !== null) {\n        return result;\n    }\n    const K_Q = 7.16e76;\n    for (let i = 0; i \u003c 2; i++) {\n        result = solve_quartic_inner(a / K_Q, b / (K_Q * K_Q), c / (K_Q * K_Q * K_Q),\n            d / (K_Q * K_Q * K_Q * K_Q), i != 0);\n        if (result !== null) {\n            for (let j = 0; j \u003c result.length; j++) {\n                result[j] *= K_Q;\n            }\n            return result;\n        }\n    }\n    // Really bad overflow happened.\n    return [];\n}\n\nfunction eps_rel(raw, a) {\n    return a == 0 ? Math.abs(raw) : Math.abs((raw - a) / a);\n}\n\nfunction solve_quartic_inner(a, b, c, d, rescale) {\n    let result = factor_quartic_inner(a, b, c, d, rescale);\n    if (result !== null \u0026\u0026 result.length == 4) {\n        let roots = [];\n        for (let i = 0; i \u003c 2; i++) {\n            const a = result[i * 2];\n            const b = result[i * 2 + 1];\n            roots = roots.concat(solve_quadratic(b, a, 1));\n        }\n        return roots;\n    }\n}\n\nfunction factor_quartic_inner(a, b, c, d, rescale) {\n    function calc_eps_q(a1, b1, a2, b2) {\n        const eps_a = eps_rel(a1 + a2, a);\n        const eps_b = eps_rel(b1 + a1 * a2 + b2, b);\n        const eps_c = eps_rel(b1 * a2 + a1 * b2, c);\n        return eps_a + eps_b + eps_c;\n    }\n    function calc_eps_t(a1, b1, a2, b2) {\n        return calc_eps_q(a1, b1, a2, b2) + eps_rel(b1 * b2, d);\n    }\n    const disc = 9 * a * a - 24 * b;\n    const s = disc \u003e= 0 ? -2 * b / (3 * a + copysign(Math.sqrt(disc), a)) : -0.25 * a;\n    const a_prime = a + 4 * s;\n    const b_prime = b + 3 * s * (a + 2 * s);\n    const c_prime = c + s * (2 * b + s * (3 * a + 4 * s));\n    const d_prime = d + s * (c + s * (b + s * (a + s)));\n    let g_prime = 0;\n    let h_prime = 0;\n    const K_C = 3.49e102;\n    if (rescale) {\n        const a_prime_s = a_prime / K_C;\n        const b_prime_s = b_prime / K_C;\n        const c_prime_s = c_prime / K_C;\n        const d_prime_s = d_prime / K_C;\n        g_prime = a_prime_s * c_prime_s - (4 / K_C) * d_prime_s - (1. / 3) * b_prime_s * b_prime_s;\n        h_prime = (a_prime_s * c_prime_s - (8 / K_C) * d_prime_s - (2. / 9) * b_prime_s * b_prime_s)\n            * (1. / 3) * b_prime_s\n            - c_prime_s * (c_prime_s / K_C)\n            - a_prime_s * a_prime_s * d_prime_s;\n    } else {\n        g_prime = a_prime * c_prime - 4 * d_prime - (1. / 3) * b_prime * b_prime;\n        h_prime = (a_prime * c_prime + 8 * d_prime - (2. / 9) * b_prime * b_prime) * (1. / 3) * b_prime\n            - c_prime * c_prime\n            - a_prime * a_prime * d_prime;\n    }\n    if (!isFinite(g_prime) \u0026\u0026 isFinite(h_prime)) {\n        return null;\n    }\n    let phi = depressed_cubic_dominant(g_prime, h_prime);\n    if (rescale) {\n        phi *= K_C;\n    }\n    const l_1 = a * 0.5;\n    const l_3 = (1. / 6) * b + 0.5 * phi;\n    const delt_2 = c - a * l_3;\n    const d_2_cand_1 = (2. / 3) * b - phi - l_1 * l_1;\n    const l_2_cand_1 = 0.5 * delt_2 / d_2_cand_1;\n    const l_2_cand_2 = 2 * (d - l_3 * l_3) / delt_2;\n    const d_2_cand_2 = 0.5 * delt_2 / l_2_cand_2;\n    let d_2_best = 0;\n    let l_2_best = 0;\n    for (let i = 0; i \u003c 3; i++) {\n        const d_2 = i == 1 ? d_2_cand_2 : d_2_cand_1;\n        const l_2 = i == 0 ? l_2_cand_1 : l_2_cand_2;\n        const eps_0 = eps_rel(d_2 + l_1 * l_1 + 2 * l_3, b);\n        const eps_1 = eps_rel(2 * (d_2 * l_2 + l_1 * l_3), c);\n        const eps_2 = eps_rel(d_2 * l_2 * l_2 + l_3 * l_3, d);\n        const eps_l = eps_0 + eps_1 + eps_2;\n        if (i == 0 || eps_l \u003c eps_l_best) {\n            d_2_best = d_2;\n            l_2_best = l_2;\n            eps_l_best = eps_l;\n        }\n    }\n    const d_2 = d_2_best;\n    const l_2 = l_2_best;\n    let alpha_1 = 0;\n    let beta_1 = 0;\n    let alpha_2 = 0;\n    let beta_2 = 0;\n    if (d_2 \u003c 0.0) {\n        const sq = Math.sqrt(-d_2);\n        alpha_1 = l_1 + sq;\n        beta_1 = l_3 + sq * l_2;\n        alpha_2 = l_1 - sq;\n        beta_2 = l_3 - sq * l_2;\n        if (Math.abs(beta_2) \u003c Math.abs(beta_1)) {\n            beta_2 = d / beta_1;\n        } else if (Math.abs(beta_2) \u003e Math.abs(beta_1)) {\n            beta_1 = d / beta_2;\n        }\n        if (Math.abs(alpha_1) != Math.abs(alpha_2)) {\n            let a1_cands = null;\n            let a2_cands = null;\n            if (Math.abs(alpha_1) \u003c Math.abs(alpha_2)) {\n                const a1_cand_1 = (c - beta_1 * alpha_2) / beta_2;\n                const a1_cand_2 = (b - beta_2 - beta_1) / alpha_2;\n                const a1_cand_3 = a - alpha_2;\n                a1_cands = [a1_cand_3, a1_cand_1, a1_cand_2];\n                a2_cands = [alpha_2, alpha_2, alpha_2];\n            } else {\n                const a2_cand_1 = (c - alpha_1 * beta_2) / beta_1;\n                const a2_cand_2 = (b - beta_2 - beta_1) / alpha_1;\n                const a2_cand_3 = a - alpha_1;\n                a1_cands = [alpha_1, alpha_1, alpha_1];\n                a2_cands = [a2_cand_3, a2_cand_1, a2_cand_2];\n            }\n            let eps_q_best = 0;\n            for (let i = 0; i \u003c 3; i++) {\n                const a1 = a1_cands[i];\n                const a2 = a2_cands[i];\n                if (isFinite(a1) \u0026\u0026 isFinite(a2)) {\n                    const eps_q = calc_eps_q(a1, beta_1, a2, beta_2);\n                    if (i == 0 || eps_q \u003c eps_q_best) {\n                        alpha_1 = a1;\n                        alpha_2 = a2;\n                        eps_q_best = eps_q;\n                    }\n                }\n            }\n        }\n    } else if (d_2 == 0) {\n        const d_3 = d - l_3 * l_3;\n        alpha_1 = l_1;\n        beta_1 = l_3 + Math.sqrt(-d_3);\n        alpha_2 = l_1;\n        beta_2 = l_3 - Math.sqrt(-d_3);\n        if (Math.abs(beta_1) \u003e Math.abs(beta_2)) {\n            beta_2 = d / beta_1;\n        } else if (Math.abs(beta_2) \u003e Math.abs(beta_1)) {\n            beta_1 = d / beta_2;\n        }\n    } else {\n        // No real solutions\n        return [];\n    }\n    let eps_t = calc_eps_t(alpha_1, beta_1, alpha_2, beta_2);\n    for (let i = 0; i \u003c 8; i++) {\n        if (eps_t == 0) {\n            break;\n        }\n        const f_0 = beta_1 * beta_2 - d;\n        const f_1 = beta_1 * alpha_2 + alpha_1 * beta_2 - c;\n        const f_2 = beta_1 + alpha_1 * alpha_2 + beta_2 - b;\n        const f_3 = alpha_1 + alpha_2 - a;\n        const c_1 = alpha_1 - alpha_2;\n        const det_j = beta_1 * beta_1 - beta_1 * (alpha_2 * c_1 + 2 * beta_2)\n            + beta_2 * (alpha_1 * c_1 + beta_2);\n        if (det_j == 0) {\n            break;\n        }\n        const inv = 1 / det_j;\n        const c_2 = beta_2 - beta_1;\n        const c_3 = beta_1 * alpha_2 - alpha_1 * beta_2;\n        const dz_0 = c_1 * f_0 + c_2 * f_1 + c_3 * f_2 - (beta_1 * c_2 + alpha_1 * c_3) * f_3;\n        const dz_1 = (alpha_1 * c_1 + c_2) * f_0\n            - beta_1 * (c_1 * f_1 + c_2 * f_2 + c_3 * f_3);\n        const dz_2 = -c_1 * f_0 - c_2 * f_1 - c_3 * f_2 + (alpha_2 * c_3 + beta_2 * c_2) * f_3;\n        const dz_3 = -(alpha_2 * c_1 + c_2) * f_0\n            + beta_2 * (c_1 * f_1 + c_2 * f_2 + c_3 * f_3);\n        const a1 = alpha_1 - inv * dz_0;\n        const b1 = beta_1 - inv * dz_1;\n        const a2 = alpha_2 - inv * dz_2;\n        const b2 = beta_2 - inv * dz_3;\n        const new_eps_t = calc_eps_t(a1, b1, a2, b2);\n        if (new_eps_t \u003c eps_t) {\n            alpha_1 = a1;\n            beta_1 = b1;\n            alpha_2 = a2;\n            beta_2 = b2;\n            eps_t = new_eps_t;\n        } else {\n            break;\n        }\n    }\n    return [alpha_1, beta_1, alpha_2, beta_2];\n}\n\nfunction depressed_cubic_dominant(g, h) {\n    const q = (-1. / 3) * g;\n    const r = 0.5 * h;\n    let phi_0;\n    let k = null;\n    if (Math.abs(q) \u003e= 1e102 || Math.abs(r) \u003e= 1e164) {\n        if (Math.abs(q) \u003c Math.abs(r)) {\n            k = 1 - q * (q / r) * (q / r);\n        } else {\n            k = Math.sign(q) * ((r / q) * (r / q) / q - 1);\n        }\n    }\n    if (k !== null \u0026\u0026 r == 0) {\n        if (g \u003e 0) {\n            phi_0 = 0;\n        } else {\n            phi_0 = Math.sqrt(-g);\n        }\n    } else if (k !== null ? k \u003c 0 : r * r \u003c q * q * q) {\n        const t = k !== null ? r / q / Math.sqrt(q) : r / Math.sqrt(q * q * q);\n        phi_0 = -2 * Math.sqrt(q) * copysign(Math.cos(Math.acos(Math.abs(t)) * (1. / 3)), t);\n    } else {\n        let a;\n        if (k !== null) {\n            if (Math.abs(q) \u003c Math.abs(r)) {\n                a = -r * (1 + Math.sqrt(k));\n            } else {\n                a = -r - copysign(Math.sqrt(Math.abs(q)) * q * Math.sqrt(k), r);\n            }\n        } else {\n            a = Math.cbrt(-r - copysign(Math.sqrt(r * r - q * q * q), r));\n        }\n        const b = a == 0 ? 0 : q / a;\n        phi_0 = a + b;\n    }\n    let x = phi_0;\n    let f = (x * x + g) * x + h;\n    const EPS_M = 2.22045e-16;\n    if (Math.abs(f) \u003c EPS_M * Math.max(x * x * x, g * x, h)) {\n        return x;\n    }\n    for (let i = 0; i \u003c 8; i++) {\n        const delt_f = 3 * x * x + g;\n        if (delt_f == 0) {\n            break;\n        }\n        const new_x = x - f / delt_f;\n        const new_f = (new_x * new_x + g) * new_x + h;\n        if (new_f == 0) {\n            return new_x;\n        }\n        if (Math.abs(new_f) \u003e= Math.abs(f)) {\n            break;\n        }\n        x = new_x;\n        f = new_f;\n    }\n    return x;\n}\n\n// For testing.\nfunction vieta(x1, x2, x3, x4) {\n    const a = -(x1 + x2 + x3 + x4);\n    const b = x1 * (x2 + x3) + x2 * (x3 + x4) + x4 * (x1 + x3);\n    const c = -x1 * x2 * (x3 + x4) - x3 * x4 * (x1 + x2);\n    const d = x1 * x2 * x3 * x4;\n    const roots = solve_quartic(d, c, b, a, 1);\n    return roots;\n}\n\n// See common.rs in kurbo\nfunction solve_itp(f, a, b, epsilon, n0, k1, ya, yb) {\n    const n1_2 = Math.max(Math.ceil(Math.log2((b - a) / epsilon)) - 1, 0);\n    const nmax = n0 + n1_2;\n    let scaled_epsilon = epsilon * Math.exp(nmax * Math.LN2);\n    while (b - a \u003e 2 * epsilon) {\n        const x1_2 = 0.5 * (a + b);\n        const r = scaled_epsilon - 0.5 * (b - a);\n        const xf = (yb * a - ya * b) / (yb - ya);\n        const sigma = x1_2 - xf;\n        const delta = k1 * (b - a) * (b - a);\n        const xt = delta \u003c= Math.abs(x1_2 - xf) ? xf + copysign(delta, sigma) : x1_2;\n        const xitp = Math.abs(xt - x1_2) \u003c= r ? xt : x1_2 - copysign(r, sigma);\n        const yitp = f(xitp);\n        if (yitp \u003e 0) {\n            b = xitp;\n            yb = yitp;\n        } else if (yitp \u003c 0) {\n            a = xitp;\n            ya = yitp;\n        } else {\n            return xitp;\n        }\n        scaled_epsilon *= 0.5\n    }\n    return 0.5 * (a + b);\n}\n\nfunction ray_intersect(p0, d0, p1, d1) {\n    const det = d0.x * d1.y - d0.y * d1.x;\n    const t = (d0.x * (p0.y - p1.y) - d0.y * (p0.x - p1.x)) / det;\n    return new Point(p1.x + d1.x * t, p1.y + d1.y * t);\n}\n\nclass CubicOffset {\n    constructor(c, d) {\n        this.c = c;\n        this.q = c.deriv();\n        this.d = d;\n    }\n\n    eval_offset(t) {\n        const dp = this.q.eval(t);\n        const s = this.d / dp.hypot();\n        return new Point(-s * dp.y, s * dp.x);\n    }\n\n    eval(t) {\n        return this.c.eval(t).plus(this.eval_offset(t));\n    }\n\n    eval_deriv(t) {\n        const dp = this.q.eval(t);\n        const ddp = this.q.eval_deriv(t);\n        const h = dp.hypot2();\n        const turn = ddp.cross(dp) * this.d / (h * Math.sqrt(h));\n        const s = 1 + turn;\n        return new Point(s * dp.x, s * dp.y);\n    }\n\n    // Compute area and x moment\n    calc() {\n        let arclen = 0;\n        let area = 0;\n        let moment_x = 0;\n        const co = GAUSS_LEGENDRE_COEFFS_32;\n        for (let i = 0; i \u003c co.length; i += 2) {\n            const t = 0.5 * (1 + co[i + 1]);\n            const wi = co[i];\n            const dp = this.eval_deriv(t);\n            const p = this.eval(t);\n            const d_area = wi * dp.x * p.y;\n            arclen += wi * dp.hypot();\n            area += d_area;\n            moment_x += p.x * d_area; \n        }\n        return {'arclen': 0.5 * arclen, 'area': 0.5 * area, 'mx': 0.5 * moment_x };\n    }\n\n    sample_pts(n) {\n        const result = [];\n        let arclen = 0;\n        // Probably overkill, but keep it simple\n        const co = GAUSS_LEGENDRE_COEFFS_32;\n        const dt = 1 / (n + 1);\n        for (let i = 0; i \u003c n; i++) {\n            for (let j = 0; j \u003c co.length; j += 2) {\n                const t = dt * (i + 0.5 + 0.5 * co[j + 1]);\n                arclen += co[j] * this.eval_deriv(t).hypot();\n            }\n            const t = dt * (i + 1);\n            const d = this.eval_offset(t);\n            const p = this.c.eval(t).plus(d);\n            result.push({'arclen': arclen * 0.5 * dt, 'p': p, 'd': d});\n        }\n        return result;\n    }\n\n    rotate_to_x() {\n        const p0 = this.c.p0().plus(this.eval_offset(0));\n        const p1 = this.c.p3().plus(this.eval_offset(1));\n        const th = p1.minus(p0).atan2();\n        const a = Affine.rotate(-th);\n        const ct = CubicBez.from_pts(\n            a.apply_pt(this.c.p0().minus(p0)),\n            a.apply_pt(this.c.p1().minus(p0)),\n            a.apply_pt(this.c.p2().minus(p0)),\n            a.apply_pt(this.c.p3().minus(p0))\n        );\n        const co = new CubicOffset(ct, this.d);\n        return {'c': co, 'th': th, 'p0': p0};\n    }\n\n    // Error evaluation logic from Tiller and Hanson.\n    est_cubic_err(cu, samples, tolerance) {\n        let err = 0;\n        let tol2 = tolerance * tolerance;\n        for (let sample of samples) {\n            let best_err = null;\n            // Project sample point onto approximate curve along normal.\n            let samples = cu.intersect_ray(sample.p, sample.d);\n            if (samples.length == 0) {\n                // In production, if no rays intersect we probably want\n                // to reject this candidate altogether. But we sample the\n                // endpoints so you can get a plausible number.\n                samples = [0, 1];\n            }\n            for (let t of samples) {\n                const p_proj = cu.eval(t);\n                const this_err = sample.p.minus(p_proj).hypot2();\n                if (best_err === null || this_err \u003c best_err) {\n                    best_err = this_err;\n                }\n            }\n            err = Math.max(err, best_err);\n            if (err \u003e tol2) {\n                break;\n            }\n        }\n        return Math.sqrt(err);\n    }\n\n    cubic_approx(tolerance, sign) {\n        const r = this.rotate_to_x();\n        const end_x = r.c.c.c[6] + r.c.eval_offset(1).x;\n        const metrics = r.c.calc();\n        const arclen = metrics.arclen;\n        const th0 = Math.atan2(sign * r.c.q.y0, sign * r.c.q.x0);\n        const th1 = -Math.atan2(sign * r.c.q.y2, sign * r.c.q.x2);\n        const ex2 = end_x * end_x;\n        const ex3 = ex2 * end_x;\n        const cands = cubic_fit(th0, th1, metrics.area / ex2, metrics.mx / ex3);\n        const c = new Float64Array(6);\n        const cx = end_x * Math.cos(r.th);\n        const sx = end_x * Math.sin(r.th);\n        c[0] = cx;\n        c[1] = sx;\n        c[2] = -sx;\n        c[3] = cx;\n        c[4] = r.p0.x;\n        c[5] = r.p0.y;\n        const a = new Affine(c);\n        const samples = this.sample_pts(10);\n        let best_c = null;\n        let best_err;\n        let errs = [];\n        for (let raw_cand of cands) {\n            const cand = a.apply_cubic(raw_cand);\n            const err = this.est_cubic_err(cand, samples, tolerance);\n            errs.push(err);\n            if (best_c === null || err \u003c best_err) {\n                best_err = err;\n                best_c = cand;\n            }\n        }\n        //console.log(errs);\n        if (best_c === null) {\n            return null;\n        }\n        return {'c': best_c, 'err': best_err};\n    }\n\n    cubic_approx_other(conf, sign) {\n        let c;\n        if (conf.method == 'T-H') {\n            c = this.tiller_hanson();\n        } else if (conf.method == 'Shape') {\n            c = this.shape_control();\n        }\n        if (c === null) {\n            return null;\n        }\n        const samples = this.sample_pts(10);\n        const err = this.est_cubic_err(c, samples, conf.tolerance);\n        return {'c': c, 'err': err};\n    }\n\n    cubic_approx_seq(conf, sign) {\n        let approx;\n        if (conf.method == 'Fit') {\n            approx = this.cubic_approx(conf.tolerance, sign);\n        } else {\n            approx = this.cubic_approx_other(conf, sign);\n        }\n        if (approx !== null \u0026\u0026 approx.err \u003c= conf.tolerance) {\n            return [approx.c];\n        } else {\n            const co0 = this.subsegment(0, 0.5);\n            const co1 = this.subsegment(0.5, 1);\n            const seq0 = co0.cubic_approx_seq(conf, sign);\n            const seq1 = co1.cubic_approx_seq(conf, sign);\n            return seq0.concat(seq1);\n        }\n    }\n\n    subsegment(t0, t1) {\n        const cu = this.c.subsegment(t0, t1);\n        return new CubicOffset(cu, this.d);\n    }\n\n    tiller_hanson() {\n        const q = this.c.deriv();\n        const d0 = this.eval_offset(0);\n        const d1 = this.eval_offset(1);\n        const p0 = this.c.p0().plus(d0);\n        const p3 = this.c.p3().plus(d1);\n        const c_p1 = this.c.p1();\n        const c_p2 = this.c.p2();\n        const d12 = c_p2.minus(c_p1);\n        const s = this.d / d12.hypot();\n        const pm = new Point(c_p1.x - s * d12.y, c_p1.y + s * d12.x);\n        const pm2 = new Point(c_p2.x - s * d12.y, c_p2.y + s * d12.x);\n        const p1 = ray_intersect(p0, q.eval(0), pm, d12);\n        const p2 = ray_intersect(p3, q.eval(1), pm, d12);\n        return CubicBez.from_pts(p0, p1, p2, p3);\n    }\n\n    shape_control() {\n        const c = this.c.c;\n        const q = this.c.deriv();\n        const p0 = this.c.p0().plus(this.eval_offset(0));\n        const p3 = this.c.p3().plus(this.eval_offset(1));\n        const p = this.eval(0.5);\n        const a11 = c[2] - c[0];\n        const a12 = c[4] - c[6];\n        const a21 = c[3] - c[1];\n        const a22 = c[5] - c[7];\n        const b1 = (8. / 3) * (p.x - 0.5 * (p0.x + p3.x));\n        const b2 = (8. / 3) * (p.y - 0.5 * (p0.y + p3.y));\n        const det = a11 * a22 - a12 * a21;\n        if (det == 0) {\n            return null;\n        }\n        const a = (b1 * a22 - a12 * b2) / det;\n        const b = (a11 * b2 - b1 * a21) / det;\n        const p1 = new Point(p0.x + a * a11, p0.y + a * a21);\n        const p2 = new Point(p3.x + b * a12, p3.y + b * a22);\n        return CubicBez.from_pts(p0, p1, p2, p3);\n    }\n}\n\nfunction cubic_seq_to_svg(cu_seq) {\n    const c0 = cu_seq[0].c;\n    let str = `M${c0[0]} ${c0[1]}`;\n    for (cu of cu_seq) {\n        const ci = cu.c;\n        str += `C${ci[2]} ${ci[3]} ${ci[4]} ${ci[5]} ${ci[6]} ${ci[7]}`;\n    }\n    return str;\n}\n\nfunction cubic_seq_to_svg_handles(cu_seq) {\n    let str = '';\n    for (cu of cu_seq) {\n        const ci = cu.c;\n        str += `M${ci[0]} ${ci[1]}L${ci[2]} ${ci[3]}M${ci[4]} ${ci[5]}L${ci[6]} ${ci[7]}`;\n    }\n    return str;\n}\n\n/// Returns an array of candidate cubics matching given metrics.\nfunction cubic_fit(th0, th1, area, mx) {\n    //console.log(th0, th1, area, mx);\n    const c0 = Math.cos(th0);\n    const s0 = Math.sin(th0);\n    const c1 = Math.cos(th1);\n    const s1 = Math.sin(th1);\n    const a4 = -9\n        * c0\n        * (((2 * s1 * c1 * c0 + s0 * (2 * c1 * c1 - 1)) * c0 - 2 * s1 * c1) * c0\n            - c1 * c1 * s0);\n    const a3 = 12\n        * ((((c1 * (30 * area * c1 - s1) - 15 * area) * c0 + 2 * s0\n            - c1 * s0 * (c1 + 30 * area * s1))\n            * c0\n            + c1 * (s1 - 15 * area * c1))\n            * c0\n            - s0 * c1 * c1);\n    const a2 = 12\n        * ((((70 * mx + 15 * area) * s1 * s1 + c1 * (9 * s1 - 70 * c1 * mx - 5 * c1 * area))\n            * c0\n            - 5 * s0 * s1 * (3 * s1 - 4 * c1 * (7 * mx + area)))\n            * c0\n            - c1 * (9 * s1 - 70 * c1 * mx - 5 * c1 * area));\n    const a1 = 16\n        * (((12 * s0 - 5 * c0 * (42 * mx - 17 * area)) * s1\n            - 70 * c1 * (3 * mx - area) * s0\n            - 75 * c0 * c1 * area * area)\n            * s1\n            - 75 * c1 * c1 * area * area * s0);\n    const a0 = 80 * s1 * (42 * s1 * mx - 25 * area * (s1 - c1 * area));\n    //console.log(a0, a1, a2, a3, a4);\n    let roots;\n    const EPS = 1e-12;\n    if (Math.abs(a4) \u003e EPS) {\n        const a = a3 / a4;\n        const b = a2 / a4;\n        const c = a1 / a4;\n        const d = a0 / a4;\n        const quads = factor_quartic_inner(a, b, c, d, false);\n        /*\n        const solved = solve_quartic(a0, a1, a2, a3, a4);\n        for (let x of solved) {\n            const y = (((a4 * x + a3) * x + a2) * x + a1) * x + a0;\n            console.log(x, y);\n        }\n        */\n        roots = [];\n        for (let i = 0; i \u003c quads.length; i += 2) {\n            const c1 = quads[i];\n            const c0 = quads[i + 1];\n            const q_roots = solve_quadratic(c0, c1, 1);\n            if (q_roots.length \u003e 0) {\n                roots = roots.concat(q_roots)\n            } else {\n                // Real part of pair of complex roots\n                roots.push(-0.5 * c1);\n            }\n        }\n    } else {\n        // Question: do we ever care about complex roots in these cases?\n        if (Math.abs(a3) \u003e EPS) {\n            roots = solve_cubic(a0, a1, a2, a3)\n        } else {\n            roots = solve_quadratic(a0, a1, a2);\n        }\n    }\n    const s01 = s0 * c1 + s1 * c0;\n    //console.log(roots);\n    const cubics = [];\n    for (let d0 of roots) {\n        let d1 = (2 * d0 * s0 - area * (20 / 3.)) / (d0 * s01 - 2 * s1);\n        if (d0 \u003c 0) {\n            d0 = 0;\n            d1 = s0 / s01;\n        } else if (d1 \u003c 0) {\n            d0 = s1 / s01;\n            d1 = 0;\n        }\n        if (d0 \u003e= 0 \u0026\u0026 d1 \u003e= 0) {\n            const c = new Float64Array(8);\n            c[2] = d0 * c0;\n            c[3] = d0 * s0;\n            c[4] = 1 - d1 * c1;\n            c[5] = d1 * s1;\n            c[6] = 1;\n            cubics.push(new CubicBez(c));\n        }\n    }\n    return cubics;\n}\n\n// One manipulable cubic bezier\nclass CubicUi {\n    constructor(ui, pts) {\n        this.ui = ui\n        this.pts = pts;\n        this.curve = ui.make_stroke();\n        this.curve.classList.add(\"quad\");\n        this.hull = ui.make_stroke();\n        this.hull.classList.add(\"hull\");\n        this.handles = [];\n        for (let pt of pts) {\n            this.handles.push(ui.make_handle(pt));\n        }\n    }\n\n    onPointerDown(e) {\n        const pt = this.ui.getCoords(e);\n        const x = pt.x;\n        const y = pt.y;\n        for (let i = 0; i \u003c this.pts.length; i++) {\n            if (Math.hypot(x - this.pts[i].x, y - this.pts[i].y) \u003c 10) {\n                this.current_obj = i;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    onPointerMove(e) {\n        const i = this.current_obj;\n        const pt = this.ui.getCoords(e);\n        this.pts[i] = pt;\n        this.handles[i].setAttribute(\"cx\", pt.x);\n        this.handles[i].setAttribute(\"cy\", pt.y);\n    }\n\n    getCubic() {\n        const p0 = this.pts[0];\n        const p1 = this.pts[1];\n        const p2 = this.pts[2];\n        const p3 = this.pts[3];\n        let c = new Float64Array(8);\n        c[0] = p0.x;\n        c[1] = p0.y;\n        c[2] = p1.x;\n        c[3] = p1.y;\n        c[4] = p2.x;\n        c[5] = p2.y;\n        c[6] = p3.x;\n        c[7] = p3.y;\n        return new CubicBez(c);\n    }\n\n    update() {\n        const cb = this.getCubic();\n        const pts = this.pts;\n        this.curve.setAttribute(\"d\", cb.to_svg_path());\n        const h = `M${pts[0].x} ${pts[0].y}L${pts[1].x} ${pts[1].y}M${pts[2].x} ${pts[2].y}L${pts[3].x} ${pts[3].y}`;\n        this.hull.setAttribute(\"d\", h);\n    }\n}\n\nclass OffsetUi {\n    constructor(id) {\n        const n_cubics = 2;\n        this.root = document.getElementById(id);\n\n        this.root.addEventListener(\"pointerdown\", e =\u003e {\n            this.root.setPointerCapture(e.pointerId);\n            this.onPointerDown(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        this.root.addEventListener(\"pointermove\", e =\u003e {\n            this.onPointerMove(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        this.root.addEventListener(\"pointerup\", e =\u003e {\n            this.root.releasePointerCapture(e.pointerId);\n            this.onPointerUp(e);\n            e.preventDefault();\n            e.stopPropagation();\n        });\n        document.getElementById('d').addEventListener('input', e =\u003e this.update());\n        document.getElementById('tol').addEventListener('click', e =\u003e this.click_tol());\n        document.getElementById('alg').addEventListener('click', e =\u003e this.click_alg());\n        window.addEventListener(\"keydown\", e =\u003e this.onKeyDown(e));\n\n        const pts_foo = [new Point(67, 237), new Point(374, 471), new Point(321, 189), new Point(633, 65)];\n        this.cubic_foo = new CubicUi(this, pts_foo);\n        this.xs = [200, 600];\n        this.quad = this.make_stroke();\n        this.quad.classList.add(\"quad\");\n        this.approx_offset = this.make_stroke();\n        this.approx_handles = this.make_stroke();\n        this.approx_handles.classList.add(\"approx_handle\");\n        this.n_label = this.make_text(500, 55);\n        this.type_label = this.make_text(90, 55);\n        this.type_label.setAttribute(\"text-anchor\", \"middle\");\n        this.thresh_label = this.make_text(210, 55);\n        this.pips = [];\n        this.method = 'Fit';\n        this.grid = 20;\n        this.tolerance = 1;\n        this.renderGrid(true);\n        this.update();\n\n        this.current_obj = null;\n    }\n\n    getCoords(e) {\n        const rect = this.root.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        return new Point(x, y);\n    }\n\n    onPointerDown(e) {\n        const pt = this.getCoords(e);\n        const x = pt.x;\n        const y = pt.y;\n        if (this.cubic_foo.onPointerDown(e)) {\n            this.current_obj = 'cubic';\n            return;\n        }\n    }\n\n    onPointerMove(e) {\n        // Maybe use object oriented dispatch?\n        if (this.current_obj == 'cubic') {\n            this.cubic_foo.onPointerMove(e);\n            this.update();\n        }\n        const pt = this.getCoords(e);\n    }\n\n    onPointerUp(e) {\n        this.current_obj = null;\n    }\n\n    onKeyDown(e) {\n        if (e.key == 's') {\n            this.method = \"sederberg\";\n            this.update();\n        } else if (e.key == 'r') {\n            this.method = \"recursive\";\n            this.update();\n        } else if (e.key == 'a') {\n            this.method = \"analytic\";\n            this.update();\n        } else if (e.key == 'w') {\n            this.method = \"wang\";\n            this.update();\n        }\n    }\n\n    renderGrid(visible) {\n        let grid = document.getElementById(\"grid\");\n        //this.ui.removeAllChildren(grid);\n        if (!visible) return;\n        let w = 700;\n        let h = 500;\n        for (let i = 0; i \u003c w; i += this.grid) {\n            let line = document.createElementNS(svgNS, \"line\");\n            line.setAttribute(\"x1\", i);\n            line.setAttribute(\"y1\", 0);\n            line.setAttribute(\"x2\", i);\n            line.setAttribute(\"y2\", h);\n            grid.appendChild(line);\n        }\n        for (let i = 0; i \u003c h; i += this.grid) {\n            let line = document.createElementNS(svgNS, \"line\");\n            line.setAttribute(\"x1\", 0);\n            line.setAttribute(\"y1\", i);\n            line.setAttribute(\"x2\", w);\n            line.setAttribute(\"y2\", i);\n            grid.appendChild(line);\n        }\n    }\n\n    make_handle(p) {\n        const circle = this.plot(p.x, p.y, \"blue\", 4);\n        circle.classList.add(\"handle\");\n        return circle;\n    }\n\n    make_stroke() {\n        const path = document.createElementNS(svgNS, \"path\");\n        path.setAttribute(\"fill\", \"none\");\n        path.setAttribute(\"stroke\", \"blue\");\n        this.root.appendChild(path);\n        return path;\n    }\n\n    make_clip_path(id) {\n        const clip_path = document.createElementNS(svgNS, \"clipPath\");\n        clip_path.setAttribute(\"id\", id)\n        const path = document.createElementNS(svgNS, \"path\");\n        this.root.appendChild(clip_path);\n        clip_path.appendChild(path);\n        return path;\n    }\n\n    make_text(x, y) {\n        const text = document.createElementNS(svgNS, \"text\");\n        text.setAttribute(\"x\", x);\n        text.setAttribute(\"y\", y);\n        this.root.appendChild(text);\n        return text;\n    }\n\n    plot(x, y, color = \"black\", r = 2) {\n        let circle = document.createElementNS(svgNS, \"circle\");\n        circle.setAttribute(\"cx\", x);\n        circle.setAttribute(\"cy\", y);\n        circle.setAttribute(\"r\", r);\n        circle.setAttribute(\"fill\", color)\n        this.root.appendChild(circle);\n        return circle;\n    }\n\n    click_tol() {\n        const vals = [1, 0.1, 0.01, 0.001, 1e9, 10];\n        let tol = 1;\n        for (let i = 0; i \u003c vals.length - 1; i++) {\n            if (this.tolerance == vals[i]) {\n                tol = vals[i + 1];\n                break;\n            }\n        }\n        this.tolerance = tol;\n        document.getElementById('tol').value = tol == 1e9 ? '\\u221e' : `${tol}`;\n        this.update();\n    }\n\n    click_alg() {\n        let alg = 'Fit';\n        if (this.method == 'Fit') {\n            alg = 'T-H';\n        } else if (this.method == 'T-H') {\n            alg = 'Shape';\n        }\n        this.method = alg;\n        document.getElementById('alg').value = alg;\n        this.update();\n    }\n\n    update() {\n        for (let pip of this.pips) {\n            pip.remove();\n        }\n        this.pips = [];\n\n        const cb = this.cubic_foo.getCubic();\n        const conf = {\n            'd': document.getElementById('d').value,\n            'tolerance': this.tolerance,\n            'method': this.method,\n        };\n        const cusps = cb.find_offset_cusps(conf.d);\n        this.cubic_foo.update();\n        const c_off = new CubicOffset(cb, conf.d);\n        //console.log(c_off.sample_pts(10));\n        /*\n        const approx = c_off.cubic_approx();\n        const c = approx.c;\n        this.approx_offset.setAttribute('d', approx.c.to_svg_path());\n        this.type_label.textContent = `${approx.err}`;\n        const z = c.c;\n        const h = `M${z[0]} ${z[1]}L${z[2]} ${z[3]}M${z[6]} ${z[7]}L${z[4]} ${z[5]}`;\n        this.approx_handles.setAttribute('d', h);\n        */\n        let seq = [];\n        for (let cusp of cusps) {\n            const co_seg = c_off.subsegment(cusp.t0, cusp.t1);\n            seq = seq.concat(co_seg.cubic_approx_seq(conf, cusp.sign));\n        }\n        this.approx_offset.setAttribute('d', cubic_seq_to_svg(seq));\n        this.approx_handles.setAttribute('d', cubic_seq_to_svg_handles(seq));\n        this.type_label.textContent = `subdivisions: ${seq.length}`;\n    }\n}\n\nnew OffsetUi(\"s\");\n\u003c/script\u003e\n\n\u003cp\u003eThe problem of \u003ca href=\"https://en.wikipedia.org/wiki/Parallel_curve\"\u003eparallel\u003c/a\u003e or offset curves has remained challenging for a long time. Parallel curves have applications in 2D graphics (for drawing strokes and also adding weight to fonts), and also robotic path planning and manufacturing, among others. The exact offset curve of a cubic BÃ©zier can be described (it is an analytic curve of degree 10) but it not tractable to work with. Thus, in practice the approach is almost always to compute an approximation to the true parallel curve. A single cubic BÃ©zier might not be a good enough approximation to the parallel curve of the source cubic BÃ©zier, so in those cases it is sudivided into multiple BÃ©zier segments.\u003c/p\u003e\n\n\u003cp\u003eA number of algorithms have been published, of varying quality. Many popular algorithms arenât very accurate, yielding either visually incorrect results or excessive subdivision, depending on how carefully the error metric has been implemented. This blogpost gives a practical implementation of a nearly optimal result. Essentially, it tries to find \u003cem\u003ethe\u003c/em\u003e cubic BÃ©zier thatâs closest to the desired curve. To this end, we take a curve-fitting approach and apply an array of numerical techniques to make it work. The result is a visibly more accurate curve even when only one BÃ©zier is used, and a minimal number of subdivisions when a tighter tolerance is applied. In fact, we claim $O(n^6)$ scaling: if a curve is divided in half, the error of the approximation will decrease by a factor of 64. I suggested a previous approach, \u003ca href=\"https://raphlinus.github.io/curves/2021/02/19/parallel-curves.html\"\u003eCleaner parallel curves with Euler spirals\u003c/a\u003e, with $O(n^4)$ scaling, in other words only a 16-fold reduction of error.\u003c/p\u003e\n\n\u003cp\u003eThough there are quite a number of published algorithms, the need for a really good solution remains strong. Some really good reading is the \u003ca href=\"https://github.com/paperjs/paper.js/issues/371\"\u003ePaper.js issue\u003c/a\u003e on adding an offset function. After much discussion and prototyping, there is still no consensus on the best approach, and the feature has not landed in Paper.js despite obvious demand. Thereâs also some interesting discussion of stroking in an \u003ca href=\"https://github.com/googlefonts/colr-gradients-spec/issues/276\"\u003eissue in the COLRv1 spec repo\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"outline-of-approach\"\u003eOutline of approach\u003c/h2\u003e\n\n\u003cp\u003eThe fundamental concept is \u003cem\u003ecurve fitting,\u003c/em\u003e or finding the parameters for a cubic BÃ©zier that most closely approximate the desired curve. We also employ a sequence of numerical techniques in support of that basic concept:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eFinding the cusps and subdividing the curve at the cusp points.\u003c/li\u003e\n  \u003cli\u003eComputing area and moment of the target curve\n    \u003cul\u003e\n      \u003cli\u003eGreenâs theorem to convert double integral into a single integral\u003c/li\u003e\n      \u003cli\u003eGauss-Legendre quadrature for efficient numerical integration\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n  \u003cli\u003eQuartic root finding to solve for cubic BÃ©ziers with desired area and moment\u003c/li\u003e\n  \u003cli\u003eMeasure error to choose best candidate and decide whether to subdivide\n    \u003cul\u003e\n      \u003cli\u003eCubic BÃ©zier/ray intersection\u003c/li\u003e\n    \u003c/ul\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eEach of these numeric techniques has its own subtleties.\u003c/p\u003e\n\n\u003ch2 id=\"cusp-finding\"\u003eCusp finding\u003c/h2\u003e\n\n\u003cp\u003eOne of the challenges of parallel curves in general is \u003cem\u003ecusps.\u003c/em\u003e These happen when the curvature of the source curve is equal to one over the offset distance. Cubic BÃ©ziers have fairly complex curvature profiles, so there can be a number of cusps - itâs easy to find examples with four, and it wouldnât be surprising to me if there were more. By contrast, Euler spirals have simple curvature profiles, and the location of the cusp is extremely simple to determine.\u003c/p\u003e\n\n\u003cp\u003eThe general equation for curvature of a parametric curve is as follows:\u003c/p\u003e\n\n\\[\\kappa = \\frac{\\mathbf{x}\u0026#39;\u0026#39;(t) \\times \\mathbf{x}\u0026#39;(t)}{|\\mathbf{x}\u0026#39;(t)|^3}\\]\n\n\u003cp\u003eThe cusp happens when $\\kappa d + 1 = 0$. With a bit of rewriting, we get\u003c/p\u003e\n\n\\[(\\mathbf{x}\u0026#39;\u0026#39;(t) \\times \\mathbf{x}\u0026#39;(t))d + |\\mathbf{x}\u0026#39;(t)|^3 = 0\\]\n\n\u003cp\u003eAs with many such numerical root-finding approaches, missing a cusp is a risk. The approach \u003cem\u003ecurrently\u003c/em\u003e used in the code in this blog post is a form of interval arithmetic: over the (t0..t1) interval, a minimum and maximum value of $|\\mathbf{x}â|$ is computed, while the cross product is quadratic in t. Solving that partitions the interval into ranges where the curvature is definitely above or below the threshold for a cusp, and a (hopefully) smaller interval where itâs possible.\u003c/p\u003e\n\n\u003cp\u003eThis algorithm is robust, but convergence is not super-fast - it often hits the case where it has to subdivide in half, so convergence is similar to a bisection approach for root-finding. Iâm exploring another approach of computing bounding parabolas, and that seems to have cubic convergence, but is a bit more complicated and fiddly.\u003c/p\u003e\n\n\u003cp\u003eIn cases where you \u003cem\u003eknow\u003c/em\u003e you have one simple cusp, a simple and generic root-finding method like ITP (about more which below) would be effective. But that leaves the problem of detecting when thatâs the case. Robust detection of possible cusps generally also gives the locations of the cusps when iterated.\u003c/p\u003e\n\n\u003ch2 id=\"computing-area-and-moment-of-the-target-curve\"\u003eComputing area and moment of the target curve\u003c/h2\u003e\n\n\u003cp\u003eThe primary input to the curve fitting algorithm is a set of parameters for the curve. Not control points of a BÃ©zier, but other measurements of the curve. The position of the endpoints and the tangents can be determined directly, which, just counting parameters, leaves two free. Those are the area and x-moment. These are generally described as integrals. For an arbitrary parametric curve (a family which easily includes offsets of BÃ©ziers), Greenâs theorem is a powerful and efficient technique for approximating these integrals.\u003c/p\u003e\n\n\u003cp\u003eFor area, the specific instance of Greenâs theorem weâre looking for is this. Let the curve be defined as x(t) and y(t), where t goes from 0 to 1. Let D be the region enclosed by the curve. If the curve is closed, then we have this relation:\u003c/p\u003e\n\n\\[\\iint_D dx \\,dy = \\int_0^1 y(t)\\, x\u0026#39;(t)\\, dt\\]\n\n\u003cp\u003eI wonât go into the details here, but all this still works even when the curve is open (one way to square up the accounting is to add the return path of the chord, from the end point back to the start), and when the area contains regions of both positive and negative signs, which can be the case for S-shaped curves. The x moment is also very similar and just involves an additional $x$ term:\u003c/p\u003e\n\n\\[\\iint_D x \\, dx \\,dy = \\int_0^1 x(t)\\, y(t)\\, x\u0026#39;(t)\\, dt\\]\n\n\u003cp\u003eEspecially given that the function being integrated is (mostly) smooth, the best way to compute the approximate integral is \u003ca href=\"https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature\"\u003eGauss-Legendre quadrature\u003c/a\u003e, which has an extremely simple implementation: itâs just the dot product between a vector of weights and a vector of the function sampled at certain points, where the weights and points are carefully chosen to minimize error; in particular they result in zero error when the function being integrated is a polynomial of order up to that of the number of samples. The JavaScript code on this page just uses a single quadrature of order 32, but a more sophisticated approach (as is used for arc length computation) would be to first estimate the error and then choose a number of samples based on that.\u003c/p\u003e\n\n\u003cp\u003eNote that the area and moments of a cubic BÃ©zier curve can be efficiently computed analytically and donât need an approximate numerical technique. Adding in the offset term is numerically similar to an arc length computation, bringing it out of the range where analytical techniques are effective, but fortunately similar numerical techniques as for computing arc length are effective.\u003c/p\u003e\n\n\u003ch3 id=\"refinement-of-curve-fitting-approach\"\u003eRefinement of curve fitting approach\u003c/h3\u003e\n\n\u003cp\u003eThe basic approach to curve fitting was described in \u003ca href=\"https://raphlinus.github.io/curves/2021/03/11/bezier-fitting.html\"\u003eFitting cubic BÃ©zier curves\u003c/a\u003e. Those ideas are good, but there were some rough edges to be filled in and other refinements.\u003c/p\u003e\n\n\u003cp\u003eTo recap, the goal is to find the closest BÃ©zier, in the space of all cubic BÃ©ziers, to the desired curve (in this case the parallel curve of a source BÃ©zier, but the curve fitting approach is general). Thatâs a large space to search, but we can immediately nail down some of the parameters. The endpoints should definitely be fixed, and weâll also set the tangent angles at the endpoints to match the desired curve.\u003c/p\u003e\n\n\u003cp\u003eOne loose end was the solving technique. My prototype code used numerical methods, but Iâve now settled on root finding of the quartic equation. A major reason for that is that Iâve found that the quartic solver in the \u003ca href=\"https://cristiano-de-michele.netlify.app/publication/orellana-2020/\"\u003eOrellana and De Michele\u003c/a\u003e paper works well - it is fast, robust, and stable. The JavaScript code on this page uses a fairly direct implementation of that (which I expect may be useful for other applications - all the code on this blog is licensed under Apache 2, so feel free to adapt it within the terms of that license).\u003c/p\u003e\n\n\u003cp\u003eAnother loose end was the treatment of ânear misses.â Those happen when the function comes close to zero but doesnât quite cross it. In terms of roots of a polynomial, those are a conjugate pair of complex roots, and I take the real part of that as a candidate. It would certainly be possible to express this logic by having the quartic solver output complex roots as well as real ones, but I found an effective shortcut: the algorithm actually factors the original quartic equation into two quadratics, one of which always has real roots and the other some of the time, and finding the real part of the roots of a quadratic is trivial (itâs just -b/2a).\u003c/p\u003e\n\n\u003cp\u003eRecently, Cem Yuksel has proposed a variation of Newton-style \u003ca href=\"http://www.cemyuksel.com/research/polynomials/\"\u003epolynomial solving\u003c/a\u003e. Itâs likely this could be used, but there were a few reasons I went with the more analytic approach. For one, I want multiple roots and this works best when only one is desired. Second, itâs hard to bound a priori the interval to search for roots. Third, itâs not easy to get the complex roots (if you did want to do this, the best route is probably deflation). Lastly, the accuracy numbers donât seem as good (the Orellana and De Michele paper presents the results of very careful testing), and in empirical testing I have found that accuracy in root finding is a real problem that can affect the quality of the final results. A Rust implementation of the Orellana and De Michele technique clocks in at 390ns on an M1 Max, which certainly makes it competitive with the fastest techniques out there.\u003c/p\u003e\n\n\u003cp\u003eThe last loose end was the treatment of near-zero slightly negative arm lengths. These are roots of the polynomial but are not acceptable candidate curves, as the tangent would end up pointing the wrong way. My original thought was to clamp the relevant length to zero (on the basis that it is an acceptable curve that is ânearbyâ the numerical solution), but that also doesnât give ideal results. In particular, if you set one length to zero and set the other one based on exact signed area, the tangent at the zero-length side might be wrong (enough to be visually objectionable). After some experimentation, Iâve decided to set the other control point to be the intersection of the tangents, which gets tangents right but possibly results in an error in area, depending on the exact parameters. The general approach is to throw these as candidates into the mix, and let the error measurement sort it out.\u003c/p\u003e\n\n\u003ch3 id=\"error-measurement\"\u003eError measurement\u003c/h3\u003e\n\n\u003cp\u003eA significant amount of total time spent in the algorithm is measuring the distance between the exact curve and the cubic approximation, both to decide when to subdivide and also to choose between multiple candidates from the BÃ©zier fitting. I implemented the technique from Tiller and Hanson and found it to work well. They sample the exact curve at a sequence of points, then for each of those points project that point onto the approximation along the normal. That is equivalent to computing the intersection of a ray and a cubic BÃ©zier. The maximum distance between the projected and true point is the error. This is a fairly good approximation to the \u003ca href=\"https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance\"\u003eFrÃ©chet distance\u003c/a\u003e but significantly cheaper to compute.\u003c/p\u003e\n\n\u003cp\u003eComputing the intersection of a ray and a cubic BÃ©zier is equivalent to finding the root of a cubic polynomial, a challenging numerical problem in its own right. In the course of working on this, I found that the cubic solver in kurbo would sometimes report inaccurate results (especially when the coefficient on the $x^3$ term was near-zero, which can easily happen when cubic BÃ©zier segments are near raised quadratics), and so implemented a \u003ca href=\"https://github.com/linebender/kurbo/pull/224\"\u003ebetter cubic solver\u003c/a\u003e based on a blog post on \u003ca href=\"https://momentsingraphics.de/CubicRoots.html\"\u003ecubics by momentsingraphics\u003c/a\u003e. Thatâs still not perfect, and there is more work to be done to arrive at a gold-plated cubic solver. The Yuksel \u003ca href=\"http://www.cemyuksel.com/research/polynomials/\"\u003epolynomial solving\u003c/a\u003e approach might be a good fit for this, especially as you only care about results for t strictly within the (0..1) range. It might also be worth pointing out that the fma instruction used in the Rust implementation is not available in JavaScript, so the accuracy of the solver here wonât be quite as good.\u003c/p\u003e\n\n\u003cp\u003eThe error metric is a critical component of a complete offset curve algorithm. It accounts for a good part of the total CPU time, and also must be accurate. If it underestimates true error, it risks letting inaccurate results slip through. If it overestimates error, it creates excessive subdivision. Incidentally, I suspect that the error measurement technique in the Elber, Lee and Kim paper (cited below) may be flawed; it seems like it may overestimate error in the case where the two curves being compared differ in parametrization, which will happen commonly with offset problems, particularly near cusps. The Tiller-Hanson technique is largely insensitive to parametrization (though perhaps more care should be taken to ensure that the sample points are actually evenly spaced).\u003c/p\u003e\n\n\u003ch3 id=\"subdivision\"\u003eSubdivision\u003c/h3\u003e\n\n\u003cp\u003eRight now the subdivision approach is quite simple: if none of the candidate cubic BÃ©ziers meet the error bound, then the curve is subdivided at t = 0.5 and each half is fit. The scaling is n^6, so in general that reduces the error by a factor of 64.\u003c/p\u003e\n\n\u003cp\u003eIf generation of an absolute minimum number of output segments is the goal, then a smarter approach to choosing subdivisions would be in order. For absolutely optimal results, in general what you want to do is figure out the minimum number of subdivisions, then adjust the subdivision points so the error of all segments are equal. This technique is described in section 9.6.3 of my \u003ca href=\"https://levien.com/phd/thesis.pdf\"\u003ethesis\u003c/a\u003e. In the limit, it can be expected to reduce the number of subdivisions by a factor of 1.5 compared with âsubdivide in half,â but not a significant improvement when most curves can be rendered with one or two cubic segments.\u003c/p\u003e\n\n\u003ch2 id=\"evaluation\"\u003eEvaluation\u003c/h2\u003e\n\n\u003cp\u003eSomebody evaluating this work for use in production would care about several factors: accuracy of result, robustness, and performance. The interactive demo on this page speaks for itself: the results are accurate, the performance is quite good for interactive use, and it is robust (though I make no claims it handles all adversarial inputs correctly; that always tends to require extra work).\u003c/p\u003e\n\n\u003cp\u003eIn terms of accuracy of result, this work is a dramatic advance over anything in the literature. Iâve implemented and compared it against two other techniques that are widely cited as reasonable approaches to this problem: \u003ca href=\"https://math.stackexchange.com/questions/465782/control-points-of-offset-bezier-curve\"\u003eTiller-Hanson\u003c/a\u003e and the âshape controlâ approach of Yang and Huang. For generating a single segment, it can be considerably more accurate than either.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/parallel-compare.png\" width=\"870\" alt=\"comparison against other approaches\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eIn addition to the accuracy for generating a single line segment, it is interesting to compare the scaling as the number of subdivisions increases, or as the error tolerance decreases. These tend to follow a power law. For this technique, it is $O(n^6)$, meaning that subdividing a curve in half reduces the error by a factor of 64. For the shape control approach, it is $O(n^5)$, and for Tiller-Hanson is is $O(n^2)$. That last is a surprisingly poor result, suggesting that it is only a constant factor better than subdividing the curves into lines.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/parallel-scaling.svg\" width=\"683\" alt=\"chart showing scaling behavior\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe shape control technique has good scaling, but stability issues when the tangents are nearly parallel. That can happen for an S-shaped curve, and also for a U with nearly 180 degrees of arc.\u003c/p\u003e\n\n\u003cp\u003eThe Tiller-Hanson technique is geometrically intuitive; it offsets each edge of the control polygon by the offset amount, as illustrated in the diagram below. It doesnât have the stability issues with nearly-parallel tangents and can produce better results for those âSâ curves, but the scaling is much worse.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/parallel-tiller-hanson.png\" width=\"560\" height=\"250\" alt=\"diagram showing Tiller-Hanson technique\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eRegarding performance, I have preliminary numbers from the JavaScript implementation, about 12Âµs per curve segment generated on an M1 Max running Chrome. I am quite happy with this result, and of course expect the Rust implementation to be even faster when itâs done. There are also significant downstream performance improvements from generating highly accurate results; every cubic segment you generate has some cost to process and render, so the fewer of those, the better.\u003c/p\u003e\n\n\u003cp\u003eI havenât implemented all the techniques in the Elber, Lee and Kim paper, but it is possible to draw some tentative conclusions from the literature. I expect the Klass technique (and its numerical refinement by Sakai and Suenaga) to have good scaling but relatively poor acccuracy for a single segment. The Klass technique is also documented to have poor numerical stability, thanks in part to its reliance on Newton solving techniques. The Hoschek and related (least-squares) approaches will likely produce good results but are quite slow (the Yang and Huang paper reports an eye-popping 49s for calculating a simple case with .001 tolerance, of course on older hardware).\u003c/p\u003e\n\n\u003cp\u003eThe Euler spiral technique in my previous blog post will in general produce considerably more subdivision (with $O(n^4)$ scaling), but perhaps it would be premature to write it off completely. Once the curve is in piecewise Euler spiral form, a result within the given error bounds can be computed directly, with no need to explicitly evaluate an error metric. In addition, the cusps are located robustly with trivial calculation. That said, getting a curve \u003cem\u003einto\u003c/em\u003e piecewise Euler spiral form is still challenging, and my prototype code uses a rather expensive error metric to achieve that.\u003c/p\u003e\n\n\u003ch2 id=\"discussion\"\u003eDiscussion\u003c/h2\u003e\n\n\u003cp\u003eThis post presents a significantly better solution to the parallel curve problem than the current state of the art. It is accurate, robust, and fast. It should be suitable to implement in interactive vector graphics applications, font compilation pipelines, and other contexts.\u003c/p\u003e\n\n\u003cp\u003eWhile parallel curve is an important application, the curve fitting technique is quite general. It can be adapted to generalized strokes, for example where the stroke width is variable, path simplification, distortions and other transforms, conversion from other curve representations, accurate plotting of functions, and Iâm sure there are other applications. Basically the main thing thatâs required is the ability to evaluate area and moment of the source curve, and ability to evaluate the distance to that curve (which can be done readily enough by sampling a series of points with their arc lengths).\u003c/p\u003e\n\n\u003cp\u003eThis work also provides a bit of insight into the nature of cubic BÃ©zier curves. The $O(n^6)$ scaling provides quantitative support to the idea that cubic BÃ©zier curves are extremely expressive; with skillful placement of the control points, they can extremely accurately approximate a wide variety of curves. Parallel curves are challenging for a variety of reasons, including cusps and sudden curvature variations. That said, they do require skill, as geometrically intuitive but unoptimized approaches to setting control points (such as Tiller-Hanson) perform poorly.\u003c/p\u003e\n\n\u003cp\u003eThereâs clearly more work that could be done to make the evalation more rigorous, including more optimization of the code. I believe this result would make a good paper, but my bandwidth for writing papers is limited right now. I would be more than open to collaboration, and invite interested people to get in touch.\u003c/p\u003e\n\n\u003cp\u003eThanks to Linus Romer for helpful discussion and refinement of the polynomial equations regarding quartic solving of the core curve fitting algorithm.\u003c/p\u003e\n\n\u003cp\u003eDiscuss on \u003ca href=\"https://news.ycombinator.com/item?id=32784491\"\u003eHacker News\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\u003cp\u003eHere is a bibliography of some relevant academic papers on the topic.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\u003ca href=\"https://www.sciencedirect.com/science/article/abs/pii/0010448583900192\"\u003eAn offset spline approximation for plane cubic splines\u003c/a\u003e, Klass, 1983\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://ieeexplore.ieee.org/iel5/38/4055906/04055919\"\u003eOffsets of Two-Dimensional Profiles\u003c/a\u003e, Tiller and Hanson, 1984\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.sciencedirect.com/science/article/abs/pii/0167839687900021\"\u003eHigh Accuracy Geometric Hermite Interpolation\u003c/a\u003e, de Boor, HÃ¶llig, Sabin, 1987 (\u003ca href=\"https://minds.wisconsin.edu/bitstream/handle/1793/58822/TR692.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.sciencedirect.com/science/article/abs/pii/0010448588900061\"\u003eOptimal approximate conversion of spline curves and spline approximation of offset curves\u003c/a\u003e, Hoschek and Wissel, 1988 (\u003ca href=\"http://www.norbert-wissel.de/Diplom.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://link.springer.com/chapter/10.1007/978-4-431-68456-5_17\"\u003eA New Shape Control and Classification for Cubic BÃ©zier Curves\u003c/a\u003e, Yang and Huang, 1993 (\u003ca href=\"https://github.com/paperjs/paper.js/files/752955/A.New.Shape.Control.and.Classification.for.Cubic.Bezier.Curves.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://ieeexplore.ieee.org/document/586019/\"\u003eComparing offset curve approximation methods\u003c/a\u003e, Elber, Lee, Kim, 1997 (\u003ca href=\"http://3map.snu.ac.kr/mskim/ftp/comparing.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://www.tandfonline.com/doi/abs/10.1080/00207160108805122\"\u003eCubic spline approximation of offset curves of planar cubic splines\u003c/a\u003e, Sakai and Suenaga, 2001 (\u003ca href=\"https://www.kurims.kyoto-u.ac.jp/~kyodo/kokyuroku/contents/pdf/1198-30.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://dl.acm.org/doi/10.1145/3386241\"\u003eBoosting Efficiency in Solving Quartic Equations with No Compromise in Accuracy\u003c/a\u003e, Orellana and De Michele, 2020 (\u003ca href=\"https://cristiano-de-michele.netlify.app/publication/orellana-2020/\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n  \u003cli\u003e\u003ca href=\"https://dl.acm.org/doi/10.1145/3543865\"\u003eHigh-Performance Polynomial Root Finding for Graphics\u003c/a\u003e, Yuksel, 2022 (\u003ca href=\"http://www.cemyuksel.com/research/polynomials/polynomial_roots_hpg2022.pdf\"\u003ePDF cache\u003c/a\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2022-09-09T17:45:42Z",
  "Author": "raphlinus"
}