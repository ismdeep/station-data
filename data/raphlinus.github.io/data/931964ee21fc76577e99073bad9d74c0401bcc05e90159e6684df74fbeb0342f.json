{
  "Source": "raphlinus.github.io",
  "Title": "Xilem: an architecture for UI in Rust",
  "Link": "https://raphlinus.github.io/rust/gui/2022/05/07/ui-architecture.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eRust is an appealing language for building user interfaces for a variety of reasons, especially the promise of delivering both performance and safety. However, finding a good \u003cem\u003earchitecture\u003c/em\u003e is challenging. Architectures that work well in other languages generally don’t adapt well to Rust, mostly because they rely on shared mutable state and that is not idiomatic Rust, to put it mildly. It is sometimes asserted for this reason that Rust is a poor fit for UI. I have long believed that it is possible to find an architecture for UI well suited to implementation in Rust, but my previous attempts (including the current \u003ca href=\"https://github.com/linebender/druid\"\u003eDruid\u003c/a\u003e architecture) have all been flawed. I have studied a range of other Rust UI projects and don’t feel that any of those have suitable architecture either.\u003c/p\u003e\n\n\u003cp\u003eThis post presents a new architecture, which is a synthesis of existing work and a few new ideas. The goals include expression of modern reactive, declarative UI, in components which easily compose, and a high performance implementation. UI code written in this architecture will look very intuitive to those familiar with state of the art toolkits such as SwiftUI, Flutter, and React, while at the same time being idiomatic Rust.\u003c/p\u003e\n\n\u003cp\u003eThe name “Xilem” is derived from \u003ca href=\"https://en.wikipedia.org/wiki/Xylem\"\u003exylem\u003c/a\u003e, a type of transport tissue in vascular plants, including trees. The word is spelled with an “i” in several languages including Romanian and Malay, and is a reference to \u003ca href=\"https://xi-editor.io/\"\u003exi-editor\u003c/a\u003e, a starting place for explorations into UI in Rust (now on hold).\u003c/p\u003e\n\n\u003cp\u003eLike most modern UI architectures, Xilem is based on a \u003cem\u003eview tree\u003c/em\u003e which is a simple declarative description of the UI. For incremental update, successive versions of the view tree are \u003cem\u003ediffed,\u003c/em\u003e and the results are applied to a widget tree which is more of a traditional retained-mode UI. Xilem also contains at heart an incremental computation engine with precise change propagation, specialized for UI use.\u003c/p\u003e\n\n\u003cp\u003eThe most innovative aspect of Xilem is event dispatching based on an \u003cem\u003eid path,\u003c/em\u003e at each stage providing mutable access to app state. A distinctive feature is Adapt nodes (an evolution of the lensing concept in Druid) which facilitate composition of components. By routing events \u003cem\u003ethrough\u003c/em\u003e Adapt nodes, subcomponents have access to a different mutable state reference than the parent.\u003c/p\u003e\n\n\u003ch2 id=\"a-quick-tour-of-existing-architectures\"\u003eA quick tour of existing architectures\u003c/h2\u003e\n\n\u003cp\u003eThis architecture is designed to address limitations and problems with the existing state of the art, both the current \u003ca href=\"https://github.com/linebender/druid\"\u003eDruid\u003c/a\u003e architecture and other attempts. It’s a little hard to understand some of the motivation without some knowledge of those architectures. That said, a full survey of reactive UI architectures would be quite a long work; this section can only touch the highlights.\u003c/p\u003e\n\n\u003cp\u003eThe existing Druid architecture has some nice features, but we consistently see people struggle with common themes.\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003eThere is a big difference between creating static widget hierarchies and dynamically updating them.\u003c/li\u003e\n  \u003cli\u003eThe app data must have a \u003ca href=\"https://docs.rs/druid/latest/druid/trait.Data.html\"\u003eData\u003c/a\u003e bound, which implies cloning and equality testing. Interior mutability is effectively forbidden.\u003c/li\u003e\n  \u003cli\u003eThe “lens” mechanism is confusing and it is not easy to implement complex binding patterns.\u003c/li\u003e\n  \u003cli\u003eWe never figured out how to integrate async in a compelling way.\u003c/li\u003e\n  \u003cli\u003eThere is an environment mechanism but it is not efficient and doesn’t support fine-grained change propagation.\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eAnother common architecture is immediate mode GUI, both in a relatively pure form and in a modified form. It is popular in Rust because it doesn’t require shared mutable state. It also benefits from overall system simplicity. However, the model is oversimplified in a number of ways, and it is difficult to do sophisticated layout and other patterns that are easier in retained widget systems. There are also numerous papercuts related to sometimes rendering stale state. (I experimented with a retained widget backend emulating an immediate mode API in the “crochet” architecture experiment and concluded that the result was not compelling). The popular \u003ca href=\"https://github.com/emilk/egui\"\u003eegui\u003c/a\u003e crate is solidly an implementation of immediate mode, and \u003ca href=\"https://github.com/makepad/makepad\"\u003emakepad\u003c/a\u003e is also based on it, though it differs in some important ways.\u003c/p\u003e\n\n\u003cp\u003eA particularly common architecture for UI in Rust is \u003ca href=\"https://guide.elm-lang.org/architecture/\"\u003eThe Elm Architecture\u003c/a\u003e, which also does not require shared mutable state. Rather, to support interactions from the UI, gestures and other related UI actions creates \u003cem\u003emessages\u003c/em\u003e which are then sent to an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eupdate\u003c/code\u003e method which takes central app state. \u003ca href=\"https://iced.rs/\"\u003eIced\u003c/a\u003e, \u003ca href=\"https://github.com/antoyo/relm\"\u003erelm\u003c/a\u003e, and \u003ca href=\"https://github.com/vizia/vizia\"\u003eVizia\u003c/a\u003e all use some form of this architecture. Generally it works well, but the need to create an explicit message type and dispatch on it is verbose, and the Elm architecture does not support cleanly factored components as well as some other architectures. The \u003ca href=\"https://guide.elm-lang.org/webapps/structure.html\"\u003eElm documentation\u003c/a\u003e specifically warns against components, saying, “actively trying to make components is a recipe for disaster in Elm.”\u003c/p\u003e\n\n\u003cp\u003eLastly, there are a number of serious attempts to port React patterns to Rust, of which I find \u003ca href=\"https://dioxuslabs.com/\"\u003eDioxus\u003c/a\u003e most promising. These rely on interior mutability and other patterns that I think adapt poorly to Rust, but definitely represent a credible alternative to the ideas presented here. I think we will have to build some things and see how well they work out.\u003c/p\u003e\n\n\u003ch2 id=\"synchronized-trees\"\u003eSynchronized trees\u003c/h2\u003e\n\n\u003cp\u003eThe Xilem architecture is based around generating trees and keeping them synchronized. In that way it is a refinement of the ideas described in my previous blog post, \u003ca href=\"https://raphlinus.github.io/ui/druid/2019/11/22/reactive-ui.html\"\u003eTowards a unified theory of reactive UI\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIn each “cycle,” the app produces a view tree, from which rendering is derived. This tree has fairly short lifetime; each time the UI is updated, a new tree is generated. From this, a widget tree is built (or rebuilt). The view tree is retained only long enough to assist in event dispatching and then be diffed against the next version, at which point it is dropped. The widget tree, by contrast, persists across cycles. In addition to these two trees, there is a third tree containing \u003cem\u003eview state,\u003c/em\u003e which also persists across cycles. (The view state serves a very similar function as React hooks)\u003c/p\u003e\n\n\u003cp\u003eOf existing UI architectures, the view tree most strongly resembles that of SwiftUI - nodes in the view tree are plain value objects. They also contain callbacks, for example specifying the action to be taken on clicking a button. Like SwiftUI, but somewhat unusually for UI in more dynamic languages, the view tree is statically typed, but with a typed-erased escape hatch (Swift’s AnyView) for instances where strict static typing is too restrictive.\u003c/p\u003e\n\n\u003cp\u003eThe Rust expression of these trees is instances of the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e trait, which has two associated types, one for view state and one for the associated widget. The state and widgets are \u003cem\u003ealso\u003c/em\u003e statically typed. The design relies \u003cem\u003eheavily\u003c/em\u003e on the type inference mechanisms of the Rust compiler. In addition to inferring the type of the view tree, it also uses associated types to deduce the type of the associated state tree and widget tree, which are known at compile time. In almost every other comparable system (SwiftUI being the notable exception), these are determined at runtime with a fair amount of allocation, downcasting, and dynamic dispatch.\u003c/p\u003e\n\n\u003ch2 id=\"a-worked-example\"\u003eA worked example\u003c/h2\u003e\n\n\u003cp\u003eWe’ll use the classic counter as a running example. It’s very simple but will give insight into how things work under the hood. For people who want to follow along with the code, check the idiopath directory of the \u003ca href=\"https://github.com/linebender/druid/pull/2183\"\u003eidiopath branch\u003c/a\u003e (in the Druid repo); running \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecargo doc --open\u003c/code\u003e there will reveal a bunch of Rustdoc.\u003c/p\u003e\n\n\u003cp\u003eHere’s the application.\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003eapp\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"nb\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003eimpl\u003c/span\u003e \u003cspan class=\"n\"\u003eView\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nb\"\u003eu32\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003ev_stack\u003c/span\u003e\u003cspan class=\"p\"\u003e((\u003c/span\u003e\n        \u003cspan class=\"nd\"\u003eformat!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Count: {}\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"nf\"\u003ebutton\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;Increment\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e\u003cspan class=\"n\"\u003ecount\u003c/span\u003e \u003cspan class=\"o\"\u003e+=\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e))\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis was carefully designed to be clean and simple. A few notes about this code, then we’ll get in to what happens downstream to actually build and run the UI.\u003c/p\u003e\n\n\u003cp\u003eThis function is run whenever there are significant changes (more on that later). It takes the current app state (in this case a single number, but in general app state can be anything), and returns a view tree. The exact type of the view tree is not specified, rather it uses the \u003ca href=\"https://doc.bccnsoft.com/docs/rust-1.36.0-docs-html/edition-guide/rust-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html\"\u003eimpl Trait\u003c/a\u003e feature to simply assert that it’s something that implements the View trait (parameterized on the type of the app state). The full type happens to be:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"n\"\u003eVStack\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nb\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"nb\"\u003eString\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eButton\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nb\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"n\"\u003eanonymous\u003c/span\u003e \u003cspan class=\"n\"\u003efunction\u003c/span\u003e \u003cspan class=\"n\"\u003eof\u003c/span\u003e \u003cspan class=\"k\"\u003etype\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nv\"\u003e\u0026#39;a\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003eFnMut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"nv\"\u003e\u0026#39;a\u003c/span\u003e \u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"nb\"\u003eu32\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"p\"\u003e()}\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eFor such a simple example, this is not too bad (other than the callback), but would get annoying quickly.\u003c/p\u003e\n\n\u003cp\u003eAnother observation is that three nodes of this tree implement the View trait: VStack and its two children String and Button. Yes, that’s an ordinary Rust string, and it implements the View trait. So will colors and shapes (following SwiftUI; implementation is planned in the prototype but not complete).\u003c/p\u003e\n\n\u003cp\u003eThe view tree returned by the app logic can be visualized as a block diagram:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/xilem_view.svg\" alt=\"Box diagram showing view hierarchy\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThe type of the associated widget is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ewidget::VStack\u003c/code\u003e. Purely as a pragmatic implementation detail, we’ve chosen to type-erase the children of containers. Among other things, this avoids excessive monomorphization. If we wanted fully-typed widget trees, the architecture would support that, and indeed an earlier prototype chose that approach.\u003c/p\u003e\n\n\u003ch3 id=\"identity-and-id-paths\"\u003eIdentity and id paths\u003c/h3\u003e\n\n\u003cp\u003eA specific detail when building the widget tree is assigning a \u003cem\u003estable identity\u003c/em\u003e to each view. These concepts are explained pretty well in the \u003ca href=\"https://developer.apple.com/videos/play/wwdc2021/10022/\"\u003eDemystify SwiftUI\u003c/a\u003e talk. As in SwiftUI, stable identity can be based on \u003cem\u003estructure\u003c/em\u003e (views in the same place in the view tree get to keep their identity across runs), or an \u003cem\u003eexplicit key.\u003c/em\u003e To illustrate the latter, assume a list container, and that two of the elements in the list are swapped. That might play an animation of the visual representations of those two elements changing places.\u003c/p\u003e\n\n\u003cp\u003eThe idea of assigning stable identities is quite standard in declarative UI (it’s also present in basically all non-toy immediate mode GUI implementations), but Xilem adds a distinctive twist, the use of \u003cem\u003eid path\u003c/em\u003e rather than a single id. The id path of a widget is the sequence of all ids on the path from the root to that widget in the widget tree. Thus, the id path of the button in the above is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1, 3]\u003c/code\u003e, while the label is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1, 2]\u003c/code\u003e and the stack is just \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003eTo continue our running example, given the view tree, the build step produces an associated view state tree as well as a widget tree. Here, we’ve annotated the view tree with ids, and also shown how ids and id paths are stored in the newly built structures. Most importantly, the view state for the VStack contains the ids of the child nodes, and the Button widget contains its id path, which is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1, 3]\u003c/code\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/xilem_expanded.svg\" alt=\"Box diagram showing view hierarchy\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eAs it turns out, neither text labels nor buttons require any special view state other than what’s retained in the widget, so those view states are just (), the unit type. Of course, other view nodes may require more associated state, in which case the type would be something other than the unit type.\u003c/p\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003eAdvanced topic: does id identify view or widget?\u003c/summary\u003e\n\nIn writing this explanation, I realized there is some ambiguity whether the id identifies a node in the view tree, or one in the widget tree. In many cases, there is a 1:1 correspondence between the two, so the distinction is not important. In addition, it\u0026#39;s certainly possible to construct a widget tree so that the id of each node is provided during the method call that constructs that widget, and if so, it\u0026#39;s more than reasonable to use the Xilem ids as generated during the reconciliation process. However, that\u0026#39;s not required, and the identity of widgets could be from a disjoint space from Xilem ids assigned to views.\n\nFurther, it\u0026#39;s possible to have a view node that doesn\u0026#39;t directly correspond to a widget. That happens with holders of async futures, environment getters, and potentially other nodes that have reason to receive events. In those cases, ids are associated with views, not widgets. It\u0026#39;s important to be clear, though, that the *lifetime* of an id is persistent across multiple cycles, while the lifetime of nodes in the view tree is shorter.\n\nThus, the most accurate description of Xilem ids is this: they are *persistent* identifiers that correspond to either structural or explicit identity of nodes in the view tree.\n\u003c/details\u003e\n\n\u003ch3 id=\"event-propagation\"\u003eEvent propagation\u003c/h3\u003e\n\n\u003cp\u003eNow let’s click that button. Raw platform events such as mouse movement and keystrokes are handled by the UI infrastructure, and don’t necessarily result in events propagated to the app logic. For example, the mouse can hover over the button (changing the appearance to a hover state), or the window can be resized, and that will all be handled without involving the app. But clicking the button \u003cem\u003edoes\u003c/em\u003e generate an event to be dispatched to the app.\u003c/p\u003e\n\n\u003cp\u003eObviously the goal will be to run that callback and increment the count, but the details of how that happens are subtly different than most declarative UI systems. Probably the “standard” way to do this would be to attach the callback to the button, and have it capture a reference to the chunk of state it mutates. Again, in most declarative systems but not Xilem, setting the new state would be done using some variant of the \u003ca href=\"https://en.wikipedia.org/wiki/Observer_pattern\"\u003eobserver pattern\u003c/a\u003e, for example some kind of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esetState\u003c/code\u003e or other “setter” function to not only update the value but also notify downstream dependencies that it had changed, in this case re-rendering the label.\u003c/p\u003e\n\n\u003cp\u003eThis standard approach works poorly in Rust, though it can be done (see in particular the \u003ca href=\"https://dioxuslabs.com/\"\u003eDioxus\u003c/a\u003e system for an example of one of the most literal transliterations of React patterns, including observer-based state updating, into Rust). The problem is that it requires \u003cem\u003eshared mutable\u003c/em\u003e access to that state, which is clunky at best in Rust (it requires interior mutability). In addition, because Rust doesn’t have built-in syntax for getters and setters, invoking the notification mechanism also requires some kind of explicit call (though perhaps macros or other techniques can be used to hide it or make it less prominent).\u003c/p\u003e\n\n\u003cdetails\u003e\n\u003csummary\u003eAdvanced topic: comparison with Elm\u003c/summary\u003e\n\nThe observer pattern is not the *only* way event propagation works in declarative UI. Another very important and influential pattern is [The Elm Architecture], which, being based on a pure functional language, also does not require shared mutable state. Thus, it is also used successfully as the basis of several Rust UI toolkits, notably Iced.\n\nIn Elm, app state is centralized (this is also a fairly popular pattern in React, using state management packages such as Redux), and events are given to the app through an `update` call. Dispatching is a three-stage process. First, the user defines a *message* type enumerating the various actions that are (globally) possible to trigger through the UI. Second, the UI element *maps* the event type into this user-defined type, identifying which action is desired. Third, the `update` method dispatches the event, delegating if needed to a child handler. Some people like the explicitness of this approach, but it is unquestionably more verbose than a single callback that manipulates state directly, as in React or SwiftUI.\n\u003c/details\u003e\n\n\u003cp\u003eSo what does Xilem do instead? The view tree is also parameterized on the \u003cem\u003eapp state,\u003c/em\u003e which can be any type. This idea is an evolution of Druid’s existing architecture, which also offers mutable access to app state to UI callbacks, but removes some of the limitations. In particular, Druid requires app state to be clonable and diffable, a stumbling block for many new users.\u003c/p\u003e\n\n\u003cp\u003eWhen an event is generated, it is annotated with the path of the UI element that originated it. In the case of the button, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[1, 3]\u003c/code\u003e, and this is sent to the app logic for dispatching. In the case of a button click, there is no \u003cem\u003epayload,\u003c/em\u003e but for a slider it would be the numeric slider value, or for a text input it would be the string.\u003c/p\u003e\n\n\u003cp\u003eEvent dispatching starts at the root of the view tree, and calls to the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eevent\u003c/code\u003e method on the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e trait also contain a mutable borrow of the app state. In this example, the root view node is VStack. It examines the id path of the event, consults its associated view state, and decides that the event should be dispatched to the second child, as the id of that child (3) matches the corresponding id in the id path of the event. It recursively calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eevent\u003c/code\u003e on that child, which is the button. That is a \u003cem\u003eleaf node,\u003c/em\u003e meaning there are no further ids in the id path, and the button handles that event by calling its callback, passing in the mutable borrow of app state that was propagated through the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eevent\u003c/code\u003e traversal. That callback in turn just increments the count value.\u003c/p\u003e\n\n\u003cp\u003eNote that the UI framework retains the view tree a “fairly short” time - long enough to do any event dispatching that’s needed, and also for diffing (see below), but not longer than that.\u003c/p\u003e\n\n\u003ch3 id=\"re-rendering\"\u003eRe-rendering\u003c/h3\u003e\n\n\u003cp\u003eAfter clicking the button and running the callback, the app state consists of the number 1, formerly 0. The app logic function is run, producing a new view tree, and this time the string value is “Count: 1” rather than “Count: 0”. The challenge is then to update the widget tree with the new data.\u003c/p\u003e\n\n\u003cp\u003eAs is completely standard in declarative UI, it is done by diffing the old view tree against the new one, in this case calling the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e method on the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e trait. This method compares the data, updates the associated widget if there are any changes, and also traverses into children. The view tree is retained \u003cem\u003ejust\u003c/em\u003e long enough to do event propagation and to be diffed against the next iteration of the view tree, at which point it is dropped. At any point in time, there are at most two copies of the view tree in existence.\u003c/p\u003e\n\n\u003cp\u003eIn the simplest case, the app builds the full view tree, and that is diffed in full against the previous version. However, as UI scales, this would be inefficient, so there are \u003cem\u003eother\u003c/em\u003e mechanisms to do finer grained change propagation, as described below.\u003c/p\u003e\n\n\u003ch2 id=\"components\"\u003eComponents\u003c/h2\u003e\n\n\u003cp\u003eThe above is the basic architecture, enough to get started. Now we will go into some more advanced techniques.\u003c/p\u003e\n\n\u003cp\u003eIt would be very limiting to have a single “app state” type throughout the application, and require all callbacks to express their state mutations in terms of that global type. So we won’t do that.\u003c/p\u003e\n\n\u003cp\u003eThe main tool for stitching together components is the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAdapt\u003c/code\u003e view node. This node is so named because it adapts between one app state type and another, using a closure that takes mutable access to the parent state, and calls into a child (through a “thunk”, which is just a callback for continuing the propagation to child nodes) with a mutable reference to the child state. We can then define a “component” in the Xilem world as a body of code that outputs a view tree with a different app state type than its parent component.\u003c/p\u003e\n\n\u003cp\u003eIn the simple case where the child component operates independently of the parent, the adapt node is a couple lines of code. It is also an attachment point for richer interactions - the closure can manipulate the parent state in any way it likes. Event handling callbacks of the child component are also allowed to return an arbitrary type (unit by default), for propagation of data upward in the tree, including to parent components.\u003c/p\u003e\n\n\u003cp\u003eIn Elm terminology, the Adapt node is similar to \u003ca href=\"https://package.elm-lang.org/packages/elm/html/latest/Html#map\"\u003eHtml map\u003c/a\u003e, though it manipulates mutable references to state, as opposed to being a pure functional mapping between message types. It is also quite similar to the “lens” concept from the existing Druid architecture, and has some resemblance to \u003ca href=\"https://developer.apple.com/documentation/swiftui/binding\"\u003eBinding\u003c/a\u003e in SwiftUI as well.\u003c/p\u003e\n\n\u003ch2 id=\"finer-grained-change-propagation-memoizing\"\u003eFiner grained change propagation: memoizing\u003c/h2\u003e\n\n\u003cp\u003eGoing back to the counter, every time the app logic is called, it allocates a string for the label, even if it’s the same value as before. That’s not too bad if it’s the only thing going on, but as the UI scales it is potentially wasted work.\u003c/p\u003e\n\n\u003cp\u003eRon Minsky has \u003ca href=\"https://signalsandthreads.com/building-a-ui-framework/#1523\"\u003estated\u003c/a\u003e “hidden inside of every UI framework is some kind of incrementalization framework.” Xilem unapologetically contains at its core a lightweight change propagation engine, similar in scope to the attribute graph of SwiftUI, but highly specialized to the needs of UI, and in particular with a lightweight approach to \u003cem\u003edownward\u003c/em\u003e propagation of dependencies, what in React would be stated as the flow of props into components.\u003c/p\u003e\n\n\u003cp\u003eIn this particular case, that incremental change propagation is best represented as a \u003cem\u003ememoization\u003c/em\u003e node, yet another implementation of the View trait. A memoization node takes a data value (which supports both \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eClone\u003c/code\u003e and equality testing) and a closure which accepts that same data type. On rebuild, it compares the data value with the previous version, and only runs the closure if it has changed. The signature of this node is very similar to \u003ca href=\"https://guide.elm-lang.org/optimization/lazy.html\"\u003eHtml.Lazy\u003c/a\u003e in Elm.\u003c/p\u003e\n\n\u003cp\u003eComparing a number is extremely cheap (especially because all this happens with static typing, so no boxing or downcasting is needed), but the cost of equality comparison is a valid concern for larger, aggregate data structures. Here, immutable data structures (adapted from the existing Druid architecture) can work very well.\u003c/p\u003e\n\n\u003cp\u003eLet’s say there’s a parent object that contains all the app state, including a sizable child component. The type would look something like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nd\"\u003e#[derive(Clone)]\u003c/span\u003e\n\u003cspan class=\"k\"\u003estruct\u003c/span\u003e \u003cspan class=\"n\"\u003eParent\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"n\"\u003estuff\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eStuff\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003eArc\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eChild\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAnd at the top of the tree we can use a memoize node with type \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eArc\u0026lt;Parent\u0026gt;\u003c/code\u003e, and the equality comparison \u003ca href=\"https://doc.rust-lang.org/std/sync/struct.Arc.html#method.ptr_eq\"\u003epointer equality\u003c/a\u003e on the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eArc\u003c/code\u003e rather than a deep traversal into the structure (as might be the case with a derived \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePartialEq\u003c/code\u003e impl). The child component attaches with both a Memoize and an Adapt node.\u003c/p\u003e\n\n\u003cp\u003eThe details of the Adapt node are interesting. Here’s a simple approach:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nf\"\u003eadapt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"nb\"\u003eArc\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eParent\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethunk\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"n\"\u003ethunk\u003c/span\u003e\u003cspan class=\"nf\"\u003e.call\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"nn\"\u003eArc\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003emake_mut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"py\"\u003e.child\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003echild_view\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c\"\u003e// which has Arc\u0026lt;Child\u0026gt; as its app data type\u003c/span\u003e\n\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eWhenever events propagate into the child, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emake_mut\u003c/code\u003e creates a copy of the parent struct, which will then not be pointer-equal to the version stored in the memoize node. If such events are relatively rare, or if they nearly always end up mutating the child state, then this approach is reasonable. However, it is possible to be even finer grain:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nf\"\u003eadapt\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e|\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"nb\"\u003eArc\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eParent\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ethunk\u003c/span\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"py\"\u003e.child\u003c/span\u003e\u003cspan class=\"nf\"\u003e.clone\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n        \u003cspan class=\"n\"\u003ethunk\u003c/span\u003e\u003cspan class=\"nf\"\u003e.call\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"k\"\u003emut\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"o\"\u003e!\u003c/span\u003e\u003cspan class=\"nn\"\u003eArc\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003eptr_eq\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"py\"\u003e.child\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n            \u003cspan class=\"nn\"\u003eArc\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"nf\"\u003emake_mut\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edata\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"py\"\u003e.child\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003echild\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n        \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e},\u003c/span\u003e\n    \u003cspan class=\"nf\"\u003echild_view\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"c\"\u003e// which has Arc\u0026lt;Child\u0026gt; as its app data type\u003c/span\u003e\n\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eThis logic propagates the change up from the child object to the parent object in the app state \u003cem\u003eonly if\u003c/em\u003e the child state has actually changed.\u003c/p\u003e\n\n\u003cp\u003eThe above illustrates how to make the pattern work for structure fields (and is very similar to the “lensing” technique in the existing Druid architecture), but similar ideas will work for collections. Basically you need immutable data structures that support pointer equality and cheap, sparse diffing. I talk about that in some detail in my talk \u003ca href=\"https://www.youtube.com/watch?v=DSuX-LIAU-I\"\u003eA Journey Through Incremental Computation\u003c/a\u003e (\u003ca href=\"https://docs.google.com/presentation/d/1opLymkreSTFfxygjzSLYI_uH7j1YFfE6DLl8RfCiw7E/edit\"\u003eslides\u003c/a\u003e), with a focus on text layout and a list component. Also note that the \u003ca href=\"https://docs.rs/druid-derive/latest/druid_derive/\"\u003edruid_derive\u003c/a\u003e crate automates generation of these lenses for Druid, and no doubt a similar approach would work for adapt/memoize in Xilem. For now, though, I’m seeing how far we can get just using vanilla Rust and not relying on macros. I think all this is a fruitful direction for future work.\u003c/p\u003e\n\n\u003cp\u003eAlso to note: while immutable data structures work \u003cem\u003ewell\u003c/em\u003e in the Xilem architecture, they are not absolutely required. The \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e trait itself can be implemented by anyone, as long as the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e, and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eevent\u003c/code\u003e methods have correct implementation; change propagation is especially the domain of the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e method.\u003c/p\u003e\n\n\u003ch2 id=\"type-erasure\"\u003eType erasure\u003c/h2\u003e\n\n\u003cp\u003eThis section is optional but contains some interesting bits on advanced use of the Rust type system.\u003c/p\u003e\n\n\u003cp\u003eHaving the view tree (and associated view state and widget tree) be fully statically typed has some advantages, but the types can become quite large, and there are cases where it is important to \u003cem\u003eerase\u003c/em\u003e the type, providing functionality very similar to \u003ca href=\"https://developer.apple.com/documentation/swiftui/anyview\"\u003eAnyView\u003c/a\u003e in SwiftUI.\u003c/p\u003e\n\n\u003cp\u003eFor a simple trait, the standard approach would be \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBox\u0026lt;dyn Trait\u0026gt;\u003c/code\u003e, which boxes up the trait implementation and uses dynamic dispatch. However, this approach will not work with Xilem’s View trait, because that trait is not \u003ca href=\"https://huonw.github.io/blog/2015/01/object-safety/\"\u003eobject-safe\u003c/a\u003e. There are actually two separate problems - first, the trait has associated types, and second, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e method takes the previous view tree for diffing purposes as a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSelf\u003c/code\u003e parameter; though the contents of the view trees might differ, the type remains constant.\u003c/p\u003e\n\n\u003cp\u003eFortunately, though simply \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBox\u0026lt;dyn View\u0026gt;\u003c/code\u003e is not possible due to the View trait not being object-safe, there is a pattern (due to David Tolnay) for \u003ca href=\"https://github.com/dtolnay/erased-serde#how-it-works\"\u003etype erasure\u003c/a\u003e. You can look at the code for details, but the gist of it is a separate trait (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAnyView\u003c/code\u003e) with \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAny\u003c/code\u003e in place of the associated type, and a blanket implementation (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimpl\u0026lt;T\u0026gt; AnyView for T where T: View\u003c/code\u003e) that does the needed downcasting.\u003c/p\u003e\n\n\u003cp\u003eThe details of type erasure in Xilem took a fair amount of iteration to get right (special thanks to Olivier Faure and Manmeet Singh for earlier prototypes). An \u003ca href=\"https://github.com/linebender/druid/pull/1669\"\u003eearlier iteration\u003c/a\u003e of this architecture used the Any/downcast pattern everywhere, and I also see that pattern for associated state in \u003ca href=\"https://github.com/audulus/rui\"\u003erui\u003c/a\u003e and \u003ca href=\"https://docs.rs/iced_pure/latest/iced_pure/\"\u003eiced_pure\u003c/a\u003e, even though the main view object is statically typed.\u003c/p\u003e\n\n\u003cp\u003eIn the SwiftUI community, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAnyView\u003c/code\u003e is \u003ca href=\"https://www.swiftbysundell.com/articles/avoiding-anyview-in-swiftui/\"\u003efrowned on\u003c/a\u003e, but it is still useful to have it. While \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimpl Trait\u003c/code\u003e is a powerful tool to avoid having to write out explicit types, it doesn’t work in all cases (specifically as the return type for trait methods), though there is \u003ca href=\"https://github.com/rust-lang/rust/issues/63063\"\u003ework to fix that\u003c/a\u003e. There is an additional motivation for type erasure, namely language bindings.\u003c/p\u003e\n\n\u003ch3 id=\"language-bindings-for-dynamic-languages\"\u003eLanguage bindings for dynamic languages\u003c/h3\u003e\n\n\u003cp\u003eAs part of this exploration, I wanted to see if Python bindings were viable. This goal is potentially quite challenging, as Xilem is fundamentally a (very) strongly typed architecture, and Python is archetypally a loosely typed language. One of the limitations of the existing Druid architecture I wanted to overcome is that there was no satisfying way to create Python bindings. As another negative data point, no dynamic language bindings for SwiftUI have emerged in the approximately 3 years since its introduction.\u003c/p\u003e\n\n\u003cp\u003eYet I was able to create a fairly nice looking proof of concept for Xilem Python bindings. Obviously these bindings rely heavily on type erasure. The essence of the integration is \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimpl View for PyObject\u003c/code\u003e, where the main instance is a Python wrapper around \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBox\u0026lt;dyn AnyView\u0026gt;\u003c/code\u003e as stated above. In addition, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ePyObject\u003c/code\u003e serves as the type for both app state and messages in the Python world; an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAdapt\u003c/code\u003e node serves to interface between these and more native Rust types. Lastly, to make it all work we need \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eimpl ViewSequence for PyTuple\u003c/code\u003e so that Python tuples can serve as the children of containers like VStack, for building view hierarchies.\u003c/p\u003e\n\n\u003cp\u003eI should emphasize, this is a \u003ca href=\"https://github.com/linebender/druid/pull/2185\"\u003eproof of concept\u003c/a\u003e. To do a polished set of language bindings is a fairly major undertaking, with care needed to bridge the impedance mismatch, and especially to provide useful error messages when things go wrong. Even so, it seems promising, and, if nothing else, serves to demonstrate the flexibility of the architecture.\u003c/p\u003e\n\n\u003ch2 id=\"async\"\u003eAsync\u003c/h2\u003e\n\n\u003cp\u003eThe interaction between async and UI is an extremely deep topic and likely warrants a blog post of its own. Even so, I wanted to explore it in the Xilem prototype. Initial prototyping indicates that it can work, and that the integration can be fine grained.\u003c/p\u003e\n\n\u003cp\u003eAsync and change propagation for UI have some common features, and the Xilem approach has parallels to \u003ca href=\"https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html\"\u003eRust’s async ecosystem\u003c/a\u003e. In particular, the id path in Xilem is roughly analogous to the “waker” abstraction in Rust async - they both identify the “target” of the notification change.\u003c/p\u003e\n\n\u003cp\u003eIn fact, in the prototype integration, the waker provided to the Future trait is a thin wrapper around an id path, as well as a callback to notify the platform that it should wake the UI thread if it is sleeping. Somewhat unusually for Rust async, each \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e node holding a future calls \u003ccode class=\"language-plaintext highlighter-rouge\"\u003epoll\u003c/code\u003e on it itself; in some respects, a future-holding view is like a tiny executor of its own. A UI built with Xilem does not provide its own reactor, but rather relies on existing work such as \u003ca href=\"https://tokio.rs/\"\u003etokio\u003c/a\u003e (which was used for the prototype).\u003c/p\u003e\n\n\u003cp\u003eWe refer the interested reader to \u003ca href=\"https://github.com/linebender/druid/pull/2184\"\u003ethe prototype code\u003c/a\u003e for more details. Clearly this is an area that deserves to be explored much more deeply.\u003c/p\u003e\n\n\u003ch2 id=\"environment\"\u003eEnvironment\u003c/h2\u003e\n\n\u003cp\u003eA standard feature of declarative UI is a dynamically scoped \u003cem\u003eenvironment\u003c/em\u003e or \u003cem\u003econtext\u003c/em\u003e in which child nodes can retrieve information, usually in some form of key/value format, from ancestors somewhere higher up in the tree. Most Rust UI architectures have this (including existing Druid), but you should ask: is there fine-grained change propagation, or does it have to rebuild all children when \u003cem\u003eany\u003c/em\u003e environment key changes?\u003c/p\u003e\n\n\u003cp\u003eWe have a design for this, not fully implemented yet. The \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCx\u003c/code\u003e structure threaded through the reconciliation process gains an environment, which is a map from key to (subscribers, value) tuples. The subscribers field is a set of id paths (of child nodes). There are then two \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eView\u003c/code\u003e nodes, one for setting an environment value, which is then available to descendants, and one for retrieving that value. Let’s look at the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e methods for both of those nodes, the setter first.\u003c/p\u003e\n\n\u003cp\u003eThe associated state of the setter is the value and the subscriber set. On \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e it creates that state, with the subscriber set empty. On \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e it compares the new value with that stored in the state (these values must be equality-comparable), and, if they differ, sends a notification to each of the subscribers in the subscriber set, using the id path to dispatch those notifications. In both cases, it recurses to the child node, then pops the key from the environment stack in \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCx\u003c/code\u003e before it returns (here, “pop” means either removing the key from the environment map, or setting the value to what it was before traversing into the setter node, depending on that previous value).\u003c/p\u003e\n\n\u003cp\u003eIn the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e case, it fetches the value and subscriber set from the environment map, and \u003cem\u003eadds\u003c/em\u003e itself to that subscriber set. In either the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e or \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e case, it retrieves the value and calls the closure for its child view tree, passing in the value retrieved from the environment. Note that the “subscriber set” concept is an adaptation of the classic observer pattern to the Xilem architecture.\u003c/p\u003e\n\n\u003cp\u003eOne reason this hasn’t been prototyped is that the implementation details are fairly different depending on whether reconciliation can be multithreaded (a note on that below). It’s possible to do but requires an immutable map data structure to avoid high cloning cost, as well as interior mutability for the subscription set.\u003c/p\u003e\n\n\u003cp\u003eWe have a similar prototype of a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003euseState\u003c/code\u003e mechanism, but not enough data on its usefulness to say for sure whether it carries its weight. Such a mechanism does not seem to be needed in the Elm architecture.\u003c/p\u003e\n\n\u003ch2 id=\"other-topics\"\u003eOther topics\u003c/h2\u003e\n\n\u003cp\u003eSo far, I haven’t deeply explored styling and theming. These operations also potentially ride on an incremental change propagation system, especially because dynamic changes to the style or theme may propagate in nontrivial ways to affect the final appearance.\u003c/p\u003e\n\n\u003cp\u003eAnother topic I’m \u003cem\u003every\u003c/em\u003e interested to explore more fully is accessibility. I \u003cem\u003eexpect\u003c/em\u003e that the retained widget tree will adapt nicely to accessibility work such as Matt Campbell’s [AccessKit], but of course you never know for sure until you actually try it.\u003c/p\u003e\n\n\u003cp\u003eAn especially difficult challenge in UI toolkits is sparse scrolling, where there is the illusion of a very large number of child widgets in the scroll area, but in reality only a small subset of the widgets outside the visible viewport are materialized. I am hopeful that the tight coupling between view and associated widget, as well as a lazy callback-driven creation of widgets, will help with this, but again, we won’t know for sure until it’s built.\u003c/p\u003e\n\n\u003cp\u003eAnother very advanced topic is the ability to exploit parallelism (multiple threads) to reduce latency of the UI. The existing Druid architecture threads a mutable context to almost all widget methods, basically precluding any useful parallelism. In the Xilem architecture, creation of the View tree itself can easily be multithreaded, and I \u003cem\u003ethink\u003c/em\u003e it’s also possible to do multithreaded reconciliation. The key to that is to make the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eCx\u003c/code\u003e object passed to the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ebuild\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003erebuild\u003c/code\u003e methods \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eClone\u003c/code\u003e, which I think is possible. Again, actually realizing performance gains from this approach is a significant challenge.\u003c/p\u003e\n\n\u003ch2 id=\"prospects\"\u003eProspects\u003c/h2\u003e\n\n\u003cp\u003eThe work presented in this blog post is conceptual, almost academic, though it is forged from attempts to build real-world UI in Rust. It comes to you at an early stage; we haven’t \u003cem\u003eyet\u003c/em\u003e built up real UI around the new architecture. Part of the motivation for doing this writeup is so we can gather feedback on whether it will actually deliver on its promise.\u003c/p\u003e\n\n\u003cp\u003eOne way to test that would be to try it in other domains. There are quite a few projects that implement reactive UI ideas over a TUI, and it would also be interesting to try the Xilem architecture on top of Web infrastructure, generating DOM nodes in place of the associated widget tree.\u003c/p\u003e\n\n\u003cp\u003eI’d like to thank a large number of people, though of course the mistakes in this post are my own. The Xilem architecture takes a lot of inspiration from Olivier’s \u003ca href=\"https://github.com/PoignardAzur/panoramix\"\u003ePanoramix\u003c/a\u003e and Manmeet’s \u003ca href=\"https://github.com/Maan2003/olma\"\u003eolma\u003c/a\u003e explorations, as well as Taylor Holliday’s \u003ca href=\"https://github.com/audulus/rui\"\u003erui\u003c/a\u003e. Jan Pochyla provided useful feedback on early versions, and conversations with the entire Druid crew on \u003ca href=\"https://xi.zulipchat.com/\"\u003exi.zulipchat.com\u003c/a\u003e were also informative. Ben Saunders provided valuable insight regarding Rust’s async ecosystem.\u003c/p\u003e\n\n\u003cp\u003eDiscuss on \u003ca href=\"https://news.ycombinator.com/item?id=31297550\"\u003eHacker News\u003c/a\u003e and \u003ca href=\"https://www.reddit.com/r/rust/comments/ukk1p4/xilem_an_architecture_for_ui_in_rust/\"\u003e/r/rust\u003c/a\u003e.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2022-05-07T15:17:42Z",
  "Author": "raphlinus"
}