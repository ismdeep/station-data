{
  "Source": "raphlinus.github.io",
  "Title": "My thoughts on Rust 2019",
  "Link": "https://raphlinus.github.io/rust/2018/12/16/rust-2019.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eRecently, the Rust Core Team \u003ca href=\"https://blog.rust-lang.org/2018/12/06/call-for-rust-2019-roadmap-blogposts.html\"\u003esolicited blog posts\u003c/a\u003e on where Rust should be headed in 2019. Here’s mine.\u003c/p\u003e\n\n\u003ch2 id=\"maturity-life-cycle\"\u003eMaturity life cycle\u003c/h2\u003e\n\n\u003cp\u003eIn this post, I’ll refer to a highly simplified maturity life cycle with three stages: research, development, and polish. Different parts of the Rust ecosystem are at different levels of maturity. It’s important for effort to match the \u003cem\u003eactual\u003c/em\u003e stage in the life cycle, ideally to push it to the next. For example, I consider the language to mostly be in the “polish” stage. Continuing to treat it as research would bring dependent types, \u003ca href=\"http://smallcultfollowing.com/babysteps/blog/2015/10/08/virtual-structs-part-4-extended-enums-and-thin-traits/\"\u003evirtual structs\u003c/a\u003e, etc., which would be interesting but disruptive. Conversely, we don’t know exactly what we want for GUI, so trying to drive that to a standardized solution too early will likely get us to a suboptimal place.\u003c/p\u003e\n\n\u003cp\u003eMany mature products have alternating releases focused on new features, then stabilization (Intel’s tick-tock, Android’s Kit Kat and Marshmallow being stable while Lollipop changed tons of stuff). 2018 has seen a lot of new features, so I think it’s time for a stabilization phase. In this I agree with \u003ca href=\"https://www.jonathanturner.org/2018/12/the-fallow-year.html\"\u003eJonathan Turner\u003c/a\u003e, along with many others.\u003c/p\u003e\n\n\u003ch2 id=\"rust-language\"\u003eRust language\u003c/h2\u003e\n\n\u003cp\u003eI think for the most part, the Rust language is complete. There seems to be pretty strong consensus that we should land existing features in flight (the development stage): async/await, const generics, and getting Chalk landed (which will likely get us \u003ca href=\"https://github.com/rust-lang/rust/issues/44265\"\u003eGAT\u003c/a\u003e). But beyond that, I don’t think we should be filling the pipeline with many more new features.\u003c/p\u003e\n\n\u003cp\u003eChange has a cost. As of 2018, we now have two excellent books, but both are slightly stale – the conventions for qualified paths are different, we now use \u003ccode class=\"language-plaintext highlighter-rouge\"\u003edyn Trait\u003c/code\u003e, etc. The faster the rate of change, the worse these problems are for users.\u003c/p\u003e\n\n\u003cp\u003eThere are a lot of things holding Rust back from wider success; I don’t think most of these are in the language itself.\u003c/p\u003e\n\n\u003ch2 id=\"tooling\"\u003eTooling\u003c/h2\u003e\n\n\u003cp\u003eRust tooling could be a \u003cem\u003elot\u003c/em\u003e better. I’ve experimented with RLS, but have always gone back to using a plain text editor and the commandline cycle. (In fairness, I haven’t tried it very recently). As a longer term effort, I think tooling could go a very long way to easing some of the pain around learning curve. I have some ideas (hopefully I’ll write them up in more detail) about a more forgiving language (which may or may not be realizable) that doesn’t make a sharp distinction between a value and a reference to it, allows use-after-move, etc. Basically, in this language, a string can be treated like a number. The language server accepts programs in this language and offers quick fixes to transform them into valid Rust.\u003c/p\u003e\n\n\u003cp\u003eOf course, RLS is only half of the experience, users interact with it through an editor. Work on \u003ca href=\"https://xi-editor.io\"\u003exi-editor\u003c/a\u003e is going well, even though I’m mostly providing light guidance and support. The community, led by \u003ca href=\"https://github.com/cmyr\"\u003eColin Rofls\u003c/a\u003e, is stepping up to the plate, and I’m excited to see it improve, as well as start using it as my main editor. Language server support is getting there, and new features such as a general annotations mechanism, will make it much more complete in 2019.\u003c/p\u003e\n\n\u003ch2 id=\"library-ecosystem\"\u003eLibrary ecosystem\u003c/h2\u003e\n\n\u003cp\u003eBuilding out Rust’s library ecosystem is now where most of the work lies. Below I’ll talk about things I personally plan to work on.\u003c/p\u003e\n\n\u003cp\u003eOne theme I’d like to lift up is “coherence,” which I believe is one of Rust’s core values, in addition to a \u003ca href=\"http://aturon.github.io/2017/02/06/specialization-and-coherence/\"\u003etechnical feature of its trait system\u003c/a\u003e. A lot of what makes a “game engine” in C++ land is a curated collection of libraries that work together pretty well. But in Rust, a lot of this happens organically. Crates do tend to work together, and clever use of features like \u003ccode class=\"language-plaintext highlighter-rouge\"\u003einto\u003c/code\u003e makes things even better. A particularly striking example of the latter is \u003ca href=\"https://github.com/kvark/mint\"\u003emint\u003c/a\u003e, which makes multiple math crates interoperate, even when they use different conventions for defining vector types, etc.\u003c/p\u003e\n\n\u003ch3 id=\"simd\"\u003eSIMD\u003c/h3\u003e\n\n\u003cp\u003eI believe SIMD libraries are still in the “research” phase. There are multiple wrapper libraries, each offering a different vision and different set of tradeoffs: \u003ca href=\"https://github.com/jackmott/simdeez\"\u003esimdeez\u003c/a\u003e, \u003ca href=\"https://github.com/rust-lang-nursery/packed_simd\"\u003epacked_simd\u003c/a\u003e, \u003ca href=\"https://github.com/AdamNiederer/faster\"\u003efaster\u003c/a\u003e, and of course my own \u003ca href=\"https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html\"\u003efearless_simd\u003c/a\u003e. The tradeoffs are not straightforward; some users will need all the raw performance they can get, and are willing to go extremes to use the best instructions for specific processors. Others will value portability and safety.\u003c/p\u003e\n\n\u003cp\u003eOne of the tricky parts of SIMD is that more work needs to be done in the compiler, not least to land AVX-512 and non-x86 SIMD architectures. It’s also likely that some language changes are needed for wrapper libraries to provide the best experience; for example, inlining and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecfg(target_feature = ...)\u003c/code\u003e interact poorly. This is another research question, in my opinion. Just how far can we go with no additional language support, and which features will lead to a dramatically better experience?\u003c/p\u003e\n\n\u003ch3 id=\"audio\"\u003eAudio\u003c/h3\u003e\n\n\u003cp\u003eThere are usable low-level audio crates, especially \u003ca href=\"https://github.com/tomaka/cpal\"\u003ecpal\u003c/a\u003e. But there are performance problems (it doesn’t always use the real-time thread) and likely missing features. We need to figure out a good path, either improving cpal or developing a new crate that fixes specific problems. We’re exploring a bunch of possibilities, among other things taking a close look at C++ libraries such as \u003ca href=\"https://www.music.mcgill.ca/~gary/rtaudio/\"\u003eRtAudio\u003c/a\u003e that solve these problems well.\u003c/p\u003e\n\n\u003cp\u003eFor higher level audio synthesis, I have big plans for \u003ca href=\"https://synthesize.rs/\"\u003esynthesize-rs\u003c/a\u003e. That won’t be for everybody, but I think will be a good basis for a wide range of synthesis techniques and audio effects. That feels like it’s currently somewhere between research and development phases.\u003c/p\u003e\n\n\u003cp\u003eTo follow this work, check out the \u003ca href=\"https://xi.zulipchat.com/#narrow/stream/147925-synthesizer\"\u003e#synthesizer\u003c/a\u003e stream on our Zulip chat. I gave a \u003ca href=\"https://rust.audio/nov-2018-talk\"\u003etalk\u003c/a\u003e in November, which I plan to rework into blog form soon (I have a fairly large queue of blog posts I intend to write, lately have been focused on other things).\u003c/p\u003e\n\n\u003ch3 id=\"gui\"\u003eGUI\u003c/h3\u003e\n\n\u003cp\u003eGraphical user interfaces are a particular weak point for Rust right now, and I see the topic pop up quite a bit in Rust 2019 posts.\u003c/p\u003e\n\n\u003cp\u003eI personally feel we should consider Rust GUI in the “research” phase. There are a lot of alternative approaches, and there is not universal consensus on what’s actually going to be best. How much of the system’s infrastructure should be used for 2D graphics and other UI primitives, vs implementing the entire stack ourselves? Is deployment to web (through wasm) a requirement? Should the programming experience feel “Rust-native” or should we be adapting to the conventions of a mature object-oriented GUI toolkit? Does the Rust community have the bandwidth to create a new GUI toolkit, and even if so, is it worth it?\u003c/p\u003e\n\n\u003cp\u003eI’ve started \u003ca href=\"https://github.com/xi-editor/druid\"\u003eDruid\u003c/a\u003e to provide the GUI for my synthesizer and game, but also as a research project on building GUI in Rust. It represents a particular vision, choosing answers to each of the questions above, and I believe it has significant advantages. But it’s a research prototype, it would be very silly for other projects to adopt it at this stage.\u003c/p\u003e\n\n\u003cp\u003eThere are lots of other cool GUI projects out there too. I personally feel \u003ca href=\"https://github.com/maps4print/azul\"\u003eAzul\u003c/a\u003e is one of the most promising, as I think WebRender is a good basis for building GUI. Another very promising project is \u003ca href=\"https://gitlab.redox-os.org/redox-os/orbtk\"\u003eOrbTK\u003c/a\u003e, which originates from Redox but is cross platform, and is fairly advanced. There are also good things to be learned from \u003ca href=\"https://github.com/PistonDevelopers/conrod\"\u003eConrod\u003c/a\u003e, \u003ca href=\"https://github.com/ggez/ggez\"\u003eggez\u003c/a\u003e, as well as wrappers for toolkits in other languages.\u003c/p\u003e\n\n\u003cp\u003eIt’s not surprising that much of the activity on GUI in Rust has a focus on games, and I think that’s a good thing. It’s easier to innovate in the game space, and the reasons to use mature toolkits are less urgent. But if an excellent approach to GUI emerges, I think it will be useful for a broad range of applications. Also note that Druid started out as the GUI layer in \u003ca href=\"https://github.com/xi-editor/xi-win\"\u003ethe Windows front-end for xi-editor\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch3 id=\"markdown\"\u003eMarkdown\u003c/h3\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://github.com/raphlinus/pulldown-cmark\"\u003epulldown-cmark\u003c/a\u003e library is pretty widely used, including for rustdoc, but is a bit stale in some regards. It hasn’t kept up with evolution of the CommonMark spec. One reason it’s gotten kinda stuck is that I have an idea for a new parsing algorithm which is better than the old one, but haven’t filled in all the details. Lately, I’ve \u003ca href=\"https://github.com/raphlinus/pulldown-cmark/issues/154\"\u003epicked that work up again\u003c/a\u003e, and am looking forward to shipping it. When the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003enew_algo\u003c/code\u003e branch is merged into master, I think it’ll also be a good place for community contributions to continue to improve it and add new features. I have in mind full GFM compatibility, math, and maybe a few more things along those lines.\u003c/p\u003e\n\n\u003ch2 id=\"support-this-work-on-patreon\"\u003eSupport this work on Patreon\u003c/h2\u003e\n\n\u003cp\u003eI’m very excited about Rust, and look forward to spending a bunch of my time and energy on improving the ecosystem (mostly by writing libraries). That said, I have a lot of potential projects pulling on me, and working on Rust infrastructure doesn’t pay directly. Ideally I need to find a structure of working that’s sustainable, even though I can live off savings for a while. The best way to vote for me putting energy into Rust infrastructure specifically is through my \u003ca href=\"https://www.patreon.com/raphlinus\"\u003ePatreon\u003c/a\u003e. I’ll interpret support at $2 (or $19 if you’re feeling particularly generous) as a request to work on the items in this post.\u003c/p\u003e\n\n\u003cp\u003eThanks to everyone and the Rust community for making the language a place I love.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2018-12-16T14:55:42Z",
  "Author": "raphlinus"
}