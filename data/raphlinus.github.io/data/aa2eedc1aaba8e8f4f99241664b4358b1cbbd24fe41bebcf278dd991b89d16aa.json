{
  "Source": "raphlinus.github.io",
  "Title": "Towards fearless SIMD",
  "Link": "https://raphlinus.github.io/rust/simd/2018/10/19/fearless-simd.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003e\u003ca href=\"https://en.wikipedia.org/wiki/SIMD\"\u003eSIMD\u003c/a\u003e is a powerful performance technique, and is especially valuable in signal and image processing applications. I will be using it very extensively in my \u003ca href=\"https://github.com/raphlinus/synthesizer-io\"\u003esynthesizer\u003c/a\u003e, and also it’s increasingly used in \u003ca href=\"https://github.com/xi-editor/xi-editor\"\u003exi-editor\u003c/a\u003e to optimize string comparisons and similar primitives.\u003c/p\u003e\n\n\u003cp\u003eTraditionally, programming SIMD has been very difficult, for a variety of reasons. Until recently, the most practical approach was writing assembly code, which is very arcane. Today, probably most SIMD code is written in C using processor-specific intrinsics. The future is portable, high level code, but tools aren’t quite there yet. Rust has the potential to be one of the leading languages for SIMD, but the current state is fairly rough. In this post, I’ll set out the challenges, results of some of my explorations, and suggestions for things to improve.\u003c/p\u003e\n\n\u003cp\u003eI call my vision for what I’d like Rust to accomplish “fearless SIMD,” in analogy with “\u003ca href=\"https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html\"\u003efearless concurrency\u003c/a\u003e”. In this vision, the programmer writes the computation using high-level, safe, composable primitives, which then compile down to nearly perfect code for each SIMD capability level of the target architecture, with automatic runtime selection. Simple operations (like doing a map of a scalar function evaluation across a vector) can be written simply. More exotic SIMD operations are exposed, portably if possible, but also with an escape hatch of using processor-specific intrinsics when they’re truly needed.\u003c/p\u003e\n\n\u003cp\u003eI’m very excited by the fact that SIMD is now part of stable Rust, but the current state is very far from “fearless”. I’ve published a crate called \u003ca href=\"https://github.com/raphlinus/fearless_simd\"\u003efearless_simd\u003c/a\u003e, but that name is more of an aspiration than a promise fulfilled. Even so, I think it points one possible way. I plan to use it for music synthesis and visualization in my synthesizer, and invite the commnunity to adapt the ideas, or come up with something better!\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate 2018-10-20:\u003c/strong\u003e See the discussion on \u003ca href=\"https://www.reddit.com/r/rust/comments/9pmwrv/towards_fearless_simd/\"\u003e/r/rust\u003c/a\u003e. Updated this post to fix small typos and add references to \u003ca href=\"https://github.com/jackmott/simdeez\"\u003esimdeez\u003c/a\u003e and \u003ca href=\"https://github.com/ispc/ispc/\"\u003eISPC\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"why-is-simd-hard\"\u003eWhy is SIMD hard?\u003c/h2\u003e\n\n\u003cp\u003eWhile traditional scalar operations are pretty much standardized and available on all reasonable CPUs (with interesting exceptions such as \u003ca href=\"https://en.wikipedia.org/wiki/Hamming_weight\"\u003epopcnt\u003c/a\u003e), SIMD capabilities vary widely from chip to chip. For modern CPUs, ARM (including both 32 and 64 bit variants) has 128 bit wide SIMD types, the bulk of x86_64 CPUs have 256 bit types, and the very newest of those now have 512 bit. Code written for too high a SIMD capability will generally crash (it’s \u003ca href=\"https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html\"\u003eundefined behavior\u003c/a\u003e), while code written for too low a SIMD capability will fall short of the performance available.\u003c/p\u003e\n\n\u003cp\u003eWriting SIMD code for a specific chip is much, much easier than writing code that will run well across diverse chips. The challenges are on two levels. The easier (but still challenging) problem is compiling code to run on a single target chip, selecting at compile time the best of several alternates based on SIMD capaibilities. The next-level challenge is compiling multiple alternates into the same binary, and selecting the best at runtime.\u003c/p\u003e\n\n\u003cp\u003eThe Rust compiler provides a solution for the first level of challenge, at least for the brave programmer. It has a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003etarget-cpu\u003c/code\u003e flag, which directs it to produce code for a specific chip. Then, as part of its \u003ca href=\"https://github.com/rust-lang/rust/issues/48556\"\u003eSIMD support in stable\u003c/a\u003e, there is a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[cfg(target_feature = ...)]\u003c/code\u003e mechanism that conditionally compiles code based on the features available for the selected target CPU. Code protected by such a guard can then use \u003ca href=\"https://doc.rust-lang.org/beta/core/arch/x86_64/index.html\"\u003eSIMD intrinsics\u003c/a\u003e for that level, but these are all marked as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eunsafe\u003c/code\u003e because the compiler doesn’t statically check that the capability is actually present.\u003c/p\u003e\n\n\u003cp\u003eFor runtime selection, the Rust compiler provides some raw tools, but it’s entirely up to the programmer to put them together correctly. There’s an annotation to selectively “turn on” SIMD capabilities for a single function, and an \u003ca href=\"https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eis_x86_feature_detected!\u003c/code\u003e\u003c/a\u003e macro for detecting at runtime. The typical idiom looks something like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"nd\"\u003e#[target_feature(enable\u003c/span\u003e \u003cspan class=\"nd\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;avx\u0026#34;\u003c/span\u003e\u003cspan class=\"nd\"\u003e)]\u003c/span\u003e\n\u003cspan class=\"k\"\u003eunsafe\u003c/span\u003e \u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo_avx\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"mi\"\u003e_\u003c/span\u003e\u003cspan class=\"nf\"\u003emm256_add_ps\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"nd\"\u003eis_x86_feature_detected!\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;avx\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"k\"\u003eunsafe\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"nf\"\u003efoo_avx\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"k\"\u003eelse\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n        \u003cspan class=\"nf\"\u003efoo_fallback\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"o\"\u003e...\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eI’ve left out the additional \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[cfg]\u003c/code\u003e attributes to make sure these variants only compile under x86_64 (or x86) target_architecture for clarity, but it’s obvious this is cumbersome enough. Also note that the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[target_feature(enable)]\u003c/code\u003e attribute \u003cem\u003erequires\u003c/em\u003e the function to be unsafe, as calling it without a runtime check is undefined behavior.\u003c/p\u003e\n\n\u003cp\u003eThis works pretty well when, as is traditional, the SIMD-specific logic is written as a block inside a single function. Things start falling apart when trying to compose the logic from multiple pieces. First, there are \u003ca href=\"https://github.com/rust-lang/rust/issues/50154\"\u003ebugs\u003c/a\u003e that happen when inlining across different calling conventions. More profoundly, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[cfg(target_feature = ...)]\u003c/code\u003e attribute that works so well for compile-time detection no longer works for runtime detection, because it’s resolved too early, and cannot give the answer to the question, “what capabilities have been asserted in the function that’s inlining me”? There’s some \u003ca href=\"https://internals.rust-lang.org/t/packed-simd-cfg-target-feature-does-not-play-well-with-target-feature/8115\"\u003ediscussion\u003c/a\u003e with a pointer to a potential answer, but my personal take is that this is a fundamental problem that ultimately will need deep language changes to address.\u003c/p\u003e\n\n\u003ch2 id=\"existing-higher-level-simd-approaches\"\u003eExisting higher-level SIMD approaches\u003c/h2\u003e\n\n\u003cp\u003eThere are two crates which aim to provide a higher level SIMD experience: \u003ca href=\"https://github.com/rust-lang-nursery/packed_simd\"\u003epacked_simd\u003c/a\u003e, which provides non processor specific types such as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ef32x4\u003c/code\u003e and operations on them, and \u003ca href=\"https://github.com/AdamNiederer/faster\"\u003efaster\u003c/a\u003e, which is an even higher level approach offering iterators and transformers.\u003c/p\u003e\n\n\u003cp\u003eBoth of these show significant promise in allowing higher level code, but neither address the problem of runtime selection of SIMD capability level.\u003c/p\u003e\n\n\u003cp\u003eAnother crate, with considerable overlap in goals, is \u003ca href=\"https://github.com/jackmott/simdeez\"\u003esimdeez\u003c/a\u003e. This crate is designed to facilitate runtime detection, and writing the actual logic without duplication, but leaves the actual writing of architecture specific shims to the user, and still requires nontrivial unsafe code.\u003c/p\u003e\n\n\u003cp\u003eIt’s also worth taking a deeper look at what the C/C++ world is doing, as that’s currently by far the most mature ecosystem for SIMD development. Though SIMD is not part of the standard language, both GCC and Clang have vector extensions. There’s also support for \u003ca href=\"https://lwn.net/Articles/691932/\"\u003eFunction Multi Versioning\u003c/a\u003e, which is particularly well supported on Linux (not sure about other platforms, but I wouldn’t be surprised). I think one of the larger discussions going forward is to what extent to adapt these language and runtime level features into the Rust language.\u003c/p\u003e\n\n\u003cp\u003eIntel’s \u003ca href=\"https://github.com/ispc/ispc/\"\u003eISPC\u003c/a\u003e takes the idea of language extensions for SIMD even further, and is essentially an extension of C designed specifically around compiling portable code to high-performance SIMD. It even targets multi-core parallelism, with similar goals to \u003ca href=\"https://github.com/rayon-rs/rayon\"\u003erayon\u003c/a\u003e. There is even support for ARM Neon, but of course the major focus is Intel chips.\u003c/p\u003e\n\n\u003cp\u003eLastly, the \u003ca href=\"http://halide-lang.org/\"\u003eHalide\u003c/a\u003e language is designed primarily for image processing, and targets not only SIMD but also GPU compute. In playing with it, I’m not sure it’s suitable for audio workloads (smaller chunk sizes, more data dependencies than images), but it’s worth looking at.\u003c/p\u003e\n\n\u003ch2 id=\"approaching-fearless-simd\"\u003eApproaching fearless SIMD\u003c/h2\u003e\n\n\u003cp\u003eWhile I think it’s likely that Rust should evolve to better support SIMD, I wanted to explore how far it’s possible to go using Rust as it exists today. Indeed, \u003ca href=\"https://github.com/raphlinus/fearless_simd\"\u003efearless_simd\u003c/a\u003e works on stable Rust. It’s certainly not a general purpose solution to the problem, but based on my experiments so far, I think it might be usable for some things. I hope to write synthesis and visualization algorithms for my synthesizer using it, and so far it seems to be working - I have samples for both \u003ca href=\"https://github.com/raphlinus/fearless_simd/blob/master/examples/sinewave.rs\"\u003ewaveform generation\u003c/a\u003e and \u003ca href=\"https://github.com/raphlinus/fearless_simd/blob/master/examples/iir.rs\"\u003eIIR filtering\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eThe main theme of this crate is to provide \u003cem\u003etraits\u003c/em\u003e at two levels. On the lowest level are traits representing some SIMD vector, either of a particular width (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eF32x4\u003c/code\u003e) or the native width of the underlying vector (\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSimdF32\u003c/code\u003e). The latter is particularly useful for a simple map operation of a scalar function. Then there are implementations (simple newtypes over arch-specific types such as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e__m256\u003c/code\u003e) that implement these traits. The usual arithmetic operations are provided (using std::ops traits, so you can write \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea + b\u003c/code\u003e rather than having to do \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ea.add_(b)\u003c/code\u003e), They also provide more specialized SIMD operations such as approximate reciprocal square root (see my \u003ca href=\"https://raphlinus.github.io/audio/2018/09/05/sigmoid.html\"\u003esigmoid\u003c/a\u003e post for an application of these; also note that at that time I was only using SSE so not seeing a dramatic improvement, but with AVX it’s almost 2x).\u003c/p\u003e\n\n\u003cp\u003eThese traits are mostly safe methods, wrapping the underlying unsafety, though of course unsafe methods are also provided if needed as an escape hatch. In particular, \u003cem\u003ecreating\u003c/em\u003e a value of a particular SIMD implementation is an unsafe operation, as it depends on runtime detection of SIMD capability.\u003c/p\u003e\n\n\u003cp\u003eThe higher level of trait represents some user-specified computation, generic over all concrete implementations of the SIMD trait. Then, architecture specific runners detect the SIMD level at runtime, and calls into that trait with the appropriate concrete implementation. The runner is safe, using runtime detection to guard its internally unsafe call to the specialized SIMD version. Also, Rust’s monomorphization takes care of automatically generating multiple versions of the code for the multiple SIMD levels, including a scalar fallback that works on any architecture.\u003c/p\u003e\n\n\u003cp\u003eRight now, I have two higher level traits. One represents simple scalar transforms from f32 to f32, and the other is a \u003cem\u003ethunk\u003c/em\u003e which can be pretty much any computation, ie it’s not limited to iterators, and can do random access into slices, etc. I can imagine more, such as \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e(f32, f32) -\u0026gt; f32\u003c/code\u003e functions, but I’ll implement these as I need them.\u003c/p\u003e\n\n\u003cp\u003eUsing these traits requires a somewhat contrived style, but it’s \u003cem\u003emuch\u003c/em\u003e easier than programming SIMD intrinsics directly. The code generation quality is excellent too. Here are unscientific benchmarks for the sinewave generation example:\u003c/p\u003e\n\n\u003cp\u003eThe particular benchmark is generation of a sinewave with less than -100dB disortion, and times are given in ns to generate 64 samples.\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eCPU\u003c/th\u003e\n      \u003cth\u003esimd level\u003c/th\u003e\n      \u003cth style=\"text-align: right\"\u003etime\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ei7 7700HQ\u003c/td\u003e\n      \u003ctd\u003eAVX\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e30\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e”\u003c/td\u003e\n      \u003ctd\u003eSSE 4.2\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e49\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e”\u003c/td\u003e\n      \u003ctd\u003escalar fallback\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e344\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e”\u003c/td\u003e\n      \u003ctd\u003esin() scalar\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e506\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ei5 430M\u003c/td\u003e\n      \u003ctd\u003eSSE4.2\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e303\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e”\u003c/td\u003e\n      \u003ctd\u003escalar fallback\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e717\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e”\u003c/td\u003e\n      \u003ctd\u003esin() scalar\u003c/td\u003e\n      \u003ctd style=\"text-align: right\"\u003e1690\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eNote that this is a performance of approximately 470 picoseconds per sample. Modern computers are fast when running optimized code.\u003c/p\u003e\n\n\u003ch2 id=\"limitations-and-caveats\"\u003eLimitations and caveats\u003c/h2\u003e\n\n\u003cp\u003eI ran into a number of limitations of current Rust while writing this. I think it’s likely some of these will improve. Partly why I’m publishing this crate is to shine a light on where more work might be useful.\u003c/p\u003e\n\n\u003cp\u003eUsing this crate is very sensitive to inlining, an getting it wrong will trigger \u003ca href=\"https://github.com/rust-lang/rust/issues/50154\"\u003erust-lang/rust#50154\u003c/a\u003e. That said, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGeneratorF32\u003c/code\u003e trait is designed so that iterator creation happens inside a target_feature wrapper, which should both reduce the chance of triggering that bug, and improve code quality. In the \u003ca href=\"https://github.com/raphlinus/fearless_simd/blob/master/examples/sinewave.rs\"\u003ewaveform generation\u003c/a\u003e example, the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003esin9_shaper\u003c/code\u003e requires \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[inline(always)]\u003c/code\u003e, or else terrible code results; normally it’s rare to require this attribute, and just \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[inline]\u003c/code\u003e is usually recommended (see \u003ca href=\"https://github.com/rust-lang-nursery/stdsimd/issues/340\"\u003estdsimd#340\u003c/a\u003e for more discussion).\u003c/p\u003e\n\n\u003cp\u003eThat bug is not the only inlining misfeature; the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e#[cfg(target_feature)]\u003c/code\u003e macro is resolved too early and does not report whether the feature is enabled if the function is inlined. This is discussed a bit in a \u003ca href=\"https://internals.rust-lang.org/t/packed-simd-cfg-target-feature-does-not-play-well-with-target-feature/8115\"\u003erust-internals thread\u003c/a\u003e. It’s not clear to me that the \u003ca href=\"https://internals.rust-lang.org/t/using-run-time-feature-detection-in-core/8419\"\u003eproposed approach forward\u003c/a\u003e really fixes the issue, because runtime feature doesn’t always match \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e[target_feature(enabled)]\u003c/code\u003e. For example, runtime feature detection may show that AVX-512 is available, but the user may choose to use only AVX2 for \u003ca href=\"https://lemire.me/blog/2018/09/07/avx-512-when-and-how-to-use-these-new-instructions/\"\u003eperformance reasons\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eI wanted to make the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eGeneratorF32\u003c/code\u003e trait processor-independent and fully generic. In other words, I’d like to be able to write this:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003epub\u003c/span\u003e \u003cspan class=\"k\"\u003etrait\u003c/span\u003e \u003cspan class=\"n\"\u003eGeneratorF32\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eSized\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003etype\u003c/span\u003e \u003cspan class=\"n\"\u003eIter\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eSimdF32\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eIterator\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eItem\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"n\"\u003egen\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ecap\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nn\"\u003eSelf\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eIter\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\u003cp\u003eThis feature is in the works: generic associated types (\u003ca href=\"https://github.com/rust-lang/rust/issues/44265\"\u003erust-lang/rust#44265\u003c/a\u003e).\u003c/p\u003e\n\n\u003cp\u003eIf \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex\u003c/code\u003e has a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSimdF32\u003c/code\u003e value, it is possible to write, say, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex + 1.0\u003c/code\u003e, but at the moment \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e1.0 + x\u003c/code\u003e does not work. The relevant trait bounds do work if added to the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSimdF32\u003c/code\u003e trait, but it would force a lot of boilerplate into client implementations, due to \u003ca href=\"https://github.com/rust-lang/rust/issues/23856\"\u003erust-lang/rust#23856\u003c/a\u003e. That looks like it might get improved when Chalk lands.\u003c/p\u003e\n\n\u003cp\u003eI use the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eSimdFnF32\u003c/code\u003e trait to represent a function is generic in the actual SIMD type. Even better would be something like this:\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003epub\u003c/span\u003e \u003cspan class=\"k\"\u003etrait\u003c/span\u003e \u003cspan class=\"n\"\u003eGeneratorF32\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eSized\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eF\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eself\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ef\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eF\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003ewhere\u003c/span\u003e \u003cspan class=\"n\"\u003eF\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"k\"\u003efor\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eSimdF32\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"nf\"\u003eFn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eS\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eCurrently the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efor\u0026lt;\u0026gt;\u003c/code\u003e syntax works for higher-ranked lifetimes but not higher-ranked generics in general. I’m not sure this will ever happen, but it shows a potential real-world example for why these exotic higher-ranked types might be useful.\u003c/p\u003e\n\n\u003cp\u003eAlso while evaluating the performance through benchmarks, I found that the \u003ca href=\"https://github.com/rust-lang/rust/issues/55107\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eround\u003c/code\u003e operation in Rust is very slow\u003c/a\u003e. I’m actually digging into that and trying to fix it, and it’s a surprisingly deep issue in and of itself, possibly the subject of a future blog post.\u003c/p\u003e\n\n\u003ch2 id=\"prospects\"\u003eProspects\u003c/h2\u003e\n\n\u003cp\u003eI’m not proposing \u003ca href=\"https://github.com/raphlinus/fearless_simd\"\u003efearless_simd\u003c/a\u003e for general usage yet. On the other hand, I do plan to use it as much as possible to develop signal processing and visualization algorithms in my synthesizer, adding capabilities to the library. If other people find it useful, even better. I’ll certainly accept pull requests for use cases broadly aligned with the current direction of the crate.\u003c/p\u003e\n\n\u003cp\u003eI certainly encourage people to experiment with and explore different ways of writing SIMD code. It’s exciting that writing high quality SIMD code in Rust is now possible. The beauty and power of Rust is composing low-level components into higher level systems, using zero-cost abstractions. What are the best traits to represent generic computations that can be implemented efficiently in SIMD? How far can we go using currently stable Rust, and to what extent will extensions to the language enable an even better SIMD experience, perhaps someday fulfilling the promise of fearless SIMD? I’d like to think my exploration contributes to this discussion, and am really looking forward to seeing where it goes.\u003c/p\u003e\n\n\u003ch2 id=\"acknowledgements\"\u003eAcknowledgements\u003c/h2\u003e\n\n\u003cp\u003eErrors (including in judgment for going down this path) are my own, but I’ve benefitted from discussions with many people, including with James McCartney, Andrew Gallant (burntsushi), talchas, Colin Rofls, and Alex Crichton. The approach to newtype wrappers to safely encode both SIMD type and detected SIMD capability is due to burntsushi and is used to good effect in his fast string search crates.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2018-10-19T17:03:42Z",
  "Author": "raphlinus"
}