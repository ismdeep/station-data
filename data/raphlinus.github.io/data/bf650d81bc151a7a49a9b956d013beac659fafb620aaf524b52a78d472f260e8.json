{
  "Source": "raphlinus.github.io",
  "Title": "Blurred rounded rectangles",
  "Link": "https://raphlinus.github.io/graphics/2020/04/21/blurred-rounded-rects.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cscript type=\"text/x-mathjax-config\"\u003e\n    MathJax.Hub.Config({\n        tex2jax: {\n            inlineMath: [['$', '$']]\n        }\n    });\n\u003c/script\u003e\n\n\u003cscript src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML\" type=\"text/javascript\"\u003e\u003c/script\u003e\n\n\u003cp\u003eNote: I’m publishing this with inadequate visuals, as it’s been stuck in my queue for 3 weeks and I want to get it out there. I’d like to return to making proper images, but make no promises when.\u003c/p\u003e\n\n\u003cp\u003eFor now, a quick comparison of exact (computed with numerical integration) results (on the left) with my approximation:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/blurrr_comparison.png\" alt=\"Comparison of exact and approximate solutions\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eThere are two basic ways to render blur in 2D graphics. The general technique is to render the objects into an offscreen buffer, compute a blur, and composite that into the target surface. But in special cases, it’s possible to compute the blurred image directly from the source object, which is much faster.\u003c/p\u003e\n\n\u003cp\u003eSome shapes are easy, particularly rectangles; they have a straightforward closed-form analytical solution. But others require numerical approximations. A few years ago, Evan Wallace posted a solution for \u003ca href=\"http://madebyevan.com/shaders/fast-rounded-rectangle-shadows/\"\u003efast rounded rectangle shadows\u003c/a\u003e, using an analytical solution in one direction and numerical integration in the other. This is a good solution, but I was curious whether it is possible to do better.\u003c/p\u003e\n\n\u003cp\u003eThe solution in this blog post is based on distance fields, a very powerful technique that has been getting more attention because of it adapts so well to GPU evaluation in shaders. \u003ca href=\"https://www.iquilezles.org/\"\u003eInigo Quilez\u003c/a\u003e has been making elaborate 3d scenes built up out mostly out of \u003ca href=\"https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\"\u003edistance field\u003c/a\u003e primitives, a stunning demonstration of the power and flexibility of the technique. This post will sketch out the development of a less artistic but still hopefully useful application. I enjoy playing with the underlying math, and hope this blog post will be educational or at least entertaining for some of my readers.\u003c/p\u003e\n\n\u003cp\u003eDeveloping this required exploring a lot of possibilities, as well as navigating through parameter spaces. It’s most common to use Jupyter notebooks, a JavaScript-based platform such as observable, or a comparable tool. But for this, partly to try it out, I tried Rust, building a \u003ca href=\"https://git.sr.ht/~raph/blurrr\"\u003esimple visualizer application\u003c/a\u003e using \u003ca href=\"https://github.com/xi-editor/druid\"\u003edruid\u003c/a\u003e, a cross-platform GUI toolkit. You can try the \u003ca href=\"https://blurrr.futurepaul.now.sh/\"\u003eWeb version\u003c/a\u003e, ported by Paul Miller.\u003c/p\u003e\n\n\u003ch2 id=\"the-1d-case-blurred-box-function\"\u003eThe 1D case: blurred box function\u003c/h2\u003e\n\n\u003cp\u003eAs a warmup, let’s take the one dimensional case, especially as we’ll be using it as the foundation of the 2D solution. The one dimensional analog of a rectangle is a boxcar function.\u003c/p\u003e\n\n\u003cp\u003eGaussian blur is the convolution of a Gaussian bump with the underlying image. The convolution of a box with a Gaussian has a straightforward analytical solution. A boxcar is the difference of two step functions (offset by the thickness of the line), and the convolution of a step and a Gaussian is \u003ca href=\"https://en.wikipedia.org/wiki/Error_function\"\u003eerf\u003c/a\u003e. Thus, the blurred image is the difference of two erf evaluations.\u003c/p\u003e\n\n\u003cp\u003eIt happens that this solution generalizes to a rectangle. Since a rectangle is the outer product of two box functions, a blurred rectangle is the outer product of their blurs. However, we won’t be using this, as we’re concerned with rounded rectangles, which aren’t separable in this way.\u003c/p\u003e\n\n\u003ch2 id=\"distance-field-of-a-rounded-rect\"\u003eDistance field of a rounded rect\u003c/h2\u003e\n\n\u003cp\u003eInstead, we’ll use distance functions, as they do have the power and flexibility we need.\u003c/p\u003e\n\n\u003cp\u003eThe general approach is to compute a signed distance from an outline, then use that distance as input to a function which computes the actual grayscale value. This approach separates the problem into the \u003cem\u003eshape\u003c/em\u003e of the contour lines and the \u003cem\u003evalues,\u003c/em\u003e which (for reasons we’ll see) are best understood as a cross-section through the minor axis of the rectangle.\u003c/p\u003e\n\n\u003cp\u003eAs Jonathan Blow has \u003ca href=\"https://twitter.com/Jonathan_Blow/status/1244792815512510469\"\u003erecently tweeted\u003c/a\u003e, “The most useful thing I ever learned, about how to do geometric operations in software, is to separate the problem into parallel and orthogonal components. It applies to just about everything.” While this is most obvious for classical geometric problems such as projecting a point onto a line, distance field techniques can be seen as another tool in the toolbox following this general principle. A distance field represents the value of the orthogonal component, with the parallel component filtered out.\u003c/p\u003e\n\n\u003cp\u003eTo visualize contours (the parallel component) better, we’ll quantize the grayscale values. And we can see that for relatively small blur radii these contours look a lot like plain rounded rectangles. This motivates the first solution:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe curve is a rounded rectangle.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe corner radius is computed as a combination of the original corner radius and blur radius.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eThe cross-section of the minor axis is the 1D solution.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe combination cited in the second step is $ \\sqrt{r_c^2 + 1.25 r_b^2} $. The choice of this formula is motivated by the rule for the probability distribution of a \u003ca href=\"https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables\"\u003esum of Gaussians\u003c/a\u003e, with the constant factor chosen empirically.\u003c/p\u003e\n\n\u003ch3 id=\"implementation\"\u003eImplementation\u003c/h3\u003e\n\n\u003cp\u003eThe distance field for a rounded rectangle can be computed exactly, and Inigo Quilez includes the formula in his catalog of \u003ca href=\"https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\"\u003e2D distance functions\u003c/a\u003e. In shader language:\u003c/p\u003e\n\n\u003cdiv class=\"language-glsl highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"nf\"\u003esdRoundedBox\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"kt\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"kt\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"kt\"\u003efloat\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e \u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"kt\"\u003evec2\u003c/span\u003e \u003cspan class=\"n\"\u003eq\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eabs\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ep\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"o\"\u003e-\u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emin\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ey\u003c/span\u003e\u003cspan class=\"p\"\u003e),\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003elength\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emax\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eq\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"mi\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u003c/span\u003e \u003cspan class=\"n\"\u003er\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/rounded_rect_distfield.png\" alt=\"Distance field of rounded rectangle\"/\u003e\n(Image adapted from \u003ca href=\"https://www.shadertoy.com/view/4llXD7\"\u003ehttps://www.shadertoy.com/view/4llXD7\u003c/a\u003e)\u003c/p\u003e\n\n\u003cp\u003eNote the use of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emin\u003c/code\u003e and \u003ccode class=\"language-plaintext highlighter-rouge\"\u003emax\u003c/code\u003e rather than conditional branching. The former is much faster in both shaders and SIMD evaluation.\u003c/p\u003e\n\n\u003cp\u003eFor erf, we’ll use an approximation. It’s one of my \u003ca href=\"https://raphlinus.github.io/audio/2018/09/05/sigmoid.html\"\u003efavorite sigmoids\u003c/a\u003e and we’ll use the techniques from that blog post.\u003c/p\u003e\n\n\u003cdiv class=\"language-rust highlighter-rouge\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre class=\"highlight\"\u003e\u003ccode\u003e\u003cspan class=\"k\"\u003epub\u003c/span\u003e \u003cspan class=\"k\"\u003efn\u003c/span\u003e \u003cspan class=\"nf\"\u003ecompute_erf7\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e:\u003c/span\u003e \u003cspan class=\"nb\"\u003ef64\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"nb\"\u003ef64\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"nn\"\u003estd\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"nn\"\u003ef64\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"nn\"\u003econsts\u003c/span\u003e\u003cspan class=\"p\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eFRAC_2_SQRT_PI\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"n\"\u003exx\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"k\"\u003elet\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.24295\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e0.03395\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"mf\"\u003e0.0104\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003exx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003exx\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003exx\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n    \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e/\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mf\"\u003e1.0\u003c/span\u003e \u003cspan class=\"o\"\u003e+\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"o\"\u003e*\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\u003cspan class=\"nf\"\u003e.sqrt\u003c/span\u003e\u003cspan class=\"p\"\u003e()\u003c/span\u003e\n\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eEvan’s version is based on an approximation from Abramowitz and Stegun, which has \u003ca href=\"https://www.desmos.com/calculator/tcuwxfqyrl\"\u003esimilar accuracy\u003c/a\u003e and likely similar performance, but I like using reciprocal square root - it is particularly well supported in \u003ca href=\"https://www.felixcloutier.com/x86/rsqrtps\"\u003eSIMD\u003c/a\u003e and \u003ca href=\"https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/inversesqrt.xhtml\"\u003eGPU\u003c/a\u003e and is generally about the same speed as simple division.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://www.desmos.com/calculator/tcuwxfqyrl\"\u003e\u003cimg src=\"/assets/erf_approx.png\" alt=\"Comparison of exact and approximate solutions\"/\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch3 id=\"evaluation\"\u003eEvaluation\u003c/h3\u003e\n\n\u003cp\u003eAnd this does indeed work well for small blur radii, compared to the size of the rectangle and the corner radius. But as thr blur radius goes up, we start to see problems. For one, the corner radius gets smaller, achieving a sharp corner in the visible region. For two, the rounded parts butt against the smooth parts rather than joining smoothly.\u003c/p\u003e\n\n\u003ch2 id=\"squircles-to-the-rescue\"\u003eSquircles to the rescue\u003c/h2\u003e\n\n\u003cp\u003eThe contour of the blurred rounded rectangle strongly resembles a \u003ca href=\"https://en.wikipedia.org/wiki/Squircle\"\u003esquircle\u003c/a\u003e or \u003ca href=\"https://en.wikipedia.org/wiki/Superellipse\"\u003esuperellipse\u003c/a\u003e. Such a shape would solve both these problems.\u003c/p\u003e\n\n\u003cp\u003eHere what we want to do is adapt the distance field approach to use a distance-like metric rather than an exact distance to the reference curve. Basically, the game plan is as follows:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eStructure of distance field is same as rounded rect.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eIncrease exponent from 2 (circle) to make superellipse shape.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eCross-section is as above.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eIncreasing the exponent clearly solves the main issues with the pure rounded rectangle shape, namely the sharp interior corners (which generate a visible “x” structure) and the abrupt straight to curved transitions:\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/rounded_rect_distfield_exp.png\" alt=\"Distance field of rounded rectangle with exponent 4\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eA more complete writeup of the final code is a TODO for this blog (along with better visuals), but see \u003ca href=\"https://git.sr.ht/~raph/blurrr/tree/master/src/distfield.rs\"\u003ethe code\u003c/a\u003e for the detailed solution.\u003c/p\u003e\n\n\u003ch3 id=\"further-refinements\"\u003eFurther refinements\u003c/h3\u003e\n\n\u003cp\u003eAs the blur radius goes up, two factors degrade the accuracy of the above solution. For one, the height of the peak in the real solution decreases faster than the 1D case. This is fixed with a constant scale multiplier, derived from the erf of the rectangle’s major axis. For two, the overall shape becomes less eccentric, more like a circle (in the limit, it becomes a radially symmetric blur function). This is fixed by subtracting a correction factor from the major (long) axis of the rectangle.\u003c/p\u003e\n\n\u003cp\u003eWith these corrections in place, the approximation becomes quite accurate over the entire range of parameters. Accuracy is nearly perfect for the original use case - shadows for UI objects, but visually acceptable everywhere.\u003c/p\u003e\n\n\u003ch2 id=\"future-work\"\u003eFuture work\u003c/h2\u003e\n\n\u003cp\u003eA good solution to the blurred rounded rectangle problem is nice but perhaps not that exciting by itself; Evan’s existing solution is almost certainly good enough for most practical uses.\u003c/p\u003e\n\n\u003cp\u003eOne obvious generalization is to more shapes. The easiest by far is to squircle-based rounded rectangle shapes, as these can almost certainly by accomplished by tuning the parameters on the existing pixel shading logic. A case can be made that squircles are better than classical rounded rectangles (certainly \u003ca href=\"https://www.figma.com/blog/desperately-seeking-squircles/\"\u003eApple thinks so\u003c/a\u003e). And the shader can readily be adapted to render both filled and stroked versions of the shape with high quality antialiasing.\u003c/p\u003e\n\n\u003cp\u003eGood approximations to many other blurred shapes are possible, as a rich set of \u003ca href=\"https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\"\u003e2D distance functions\u003c/a\u003e are known and in widespread use in shader circles.\u003c/p\u003e\n\n\u003cp\u003eAlso, perhaps your designer prefers \u003ca href=\"https://en.wikipedia.org/wiki/Bokeh\"\u003ebokehlicious\u003c/a\u003e discs to Gaussian shadows. Doable. Just use a different \u003ca href=\"https://www.wolframalpha.com/input/?i=integral%20sqrt%281-x%5E2%29\"\u003ecross-section function\u003c/a\u003e and tweak the parameters.\u003c/p\u003e\n\n\u003cp\u003eSome fine-tuning on the code can still be done. For example, the “magic constants” were mostly determined through experimentation. A more systematic approach would be to do a global optimization, minimizing the value of some error norm over a range of parameters. Maybe an enterprising reader will take this on!\u003c/p\u003e\n\n\u003ch2 id=\"thanks\"\u003eThanks\u003c/h2\u003e\n\n\u003cp\u003eThanks to Evan Wallace for permission to use his WebGL code (hoped for in a future revision), to Jacob Rus for discussion about the math, and Paul Miller for the wasm port.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2020-04-21T19:24:42Z",
  "Author": "raphlinus"
}