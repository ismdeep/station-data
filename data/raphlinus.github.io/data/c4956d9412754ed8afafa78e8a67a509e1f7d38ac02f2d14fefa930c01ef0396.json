{
  "Source": "raphlinus.github.io",
  "Title": "Entity-Component-System architecture for UI in Rust",
  "Link": "https://raphlinus.github.io/personal/2018/05/08/ecs-ui.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eFor a fun project, I’ve been tinkering with \u003ca href=\"https://github.com/google/xi-win\"\u003exi-win\u003c/a\u003e, an experimental Windows front-end for xi-editor, written in Rust. I’m basically optimizing for performance, so making a number of somewhat unusual decisions. Among other things, I’m writing the UI myself, rather than using an existing toolkit or framework.\u003c/p\u003e\n\n\u003cp\u003eCode for this post: \u003ca href=\"https://github.com/google/xi-win/tree/master/xi-win-ui\"\u003exi-win/xi-win-ui\u003c/a\u003e. If you’re on a Windows machine, try the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecalc\u003c/code\u003e example!\u003c/p\u003e\n\n\u003cp\u003eI’ve heard good things about the \u003ca href=\"https://en.wikipedia.org/wiki/Entity%E2%80%93component%E2%80%93system\"\u003eEntity-Component-System\u003c/a\u003e (ECS) architecture, so wanted to try it. My experience is very positive, so I wanted to write about that in more detail. I strongly commend ECS for anyone trying to build a GUI from scratch in Rust, and I also think the techniques are more generally useful to avoid fighting the borrow checker and having too much \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRefCell\u003c/code\u003e. As evidence, take a look at how simple and concise the code is, compared with most GUI implementations.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eUpdate 2018-05-10:\u003c/strong\u003e this post got some really good \u003ca href=\"https://www.reddit.com/r/rust/comments/8i1z6d/entitycomponentsystem_architecture_for_ui_in_rust/\"\u003ediscussion on Reddit\u003c/a\u003e. It was also mentioned in a \u003ca href=\"https://internals.rust-lang.org/t/thoughts-on-rust-guis/6894\"\u003eRust internals thread on GUI\u003c/a\u003e. There are a lot of other good resources in there, including a good writeup of \u003ca href=\"https://gist.github.com/csherratt/5ea19414e0f6cc9a4ed8f55d97021c52\"\u003eRust UI Difficulties\u003c/a\u003e, which amplifies some of the points I make below.\u003c/p\u003e\n\n\u003cp\u003eThe consensus of the Reddit thread is that what I’m doing is not really ECS. I think it’s more accurate to describe it as a hybrid, inspired by ECS. I’ll be changing that description going forward.\u003c/p\u003e\n\n\u003cp\u003eMany thanks to the commenters!\u003c/p\u003e\n\n\u003cp\u003e(end of update)\u003c/p\u003e\n\n\u003ch2 id=\"why-is-gui-programming-hard-in-rust\"\u003eWhy is GUI programming hard (in Rust)?\u003c/h2\u003e\n\n\u003cp\u003eWriting a graphical user interface is considered difficult coding in just about any language, but more so in Rust. Why?\u003c/p\u003e\n\n\u003cp\u003eA graphical user interface has lots of \u003cem\u003estate,\u003c/em\u003e lots of \u003cem\u003einteractions,\u003c/em\u003e and is very \u003cem\u003edynamic.\u003c/em\u003e The traditional model for this kind of work is to decompose the interface into widget objects, and have them interact by calling methods on each other. Each widget object encapsulates its fragment of the world state, but all this state is effectively available to all other widgets at all times. Further, all widgets are reachable from all other widgets, as a widget will store references to its parent and children.\u003c/p\u003e\n\n\u003cp\u003eThat doesn’t really work in Rust. In Rust, access to mutable state is very controlled; only one mutable reference to an object can exist at a time.\u003c/p\u003e\n\n\u003cp\u003eOne approach is to use \u003ca href=\"https://doc.rust-lang.org/book/second-edition/ch15-05-interior-mutability.html\"\u003e\u003cem\u003einterior mutability,\u003c/em\u003e\u003c/a\u003e typically \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRc\u0026lt;RefCell\u0026lt;T\u0026gt;\u0026gt;\u003c/code\u003e as a reference to an object, which can be shared widely. When code needs to mutate state, it borrows a mutable reference, does the mutation, then promptly releases the borrow. The idea that no two mutable references can exist to the same state is enforced at runtime, through panics. (In the thread-safe variant, \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eArc\u0026lt;Mutex\u0026lt;T\u0026gt;\u0026gt;\u003c/code\u003e you see a deadlock rather than a panic.)\u003c/p\u003e\n\n\u003cp\u003eWhile it’s \u003cem\u003epossible\u003c/em\u003e to program in this style, it’s not fun. For one, the code is noisy with lots of explicit \u003ccode class=\"language-plaintext highlighter-rouge\"\u003e.borrow_mut()\u003c/code\u003e calls, extra braces for shorter scopes so borrows get dropped, etc.\u003c/p\u003e\n\n\u003cp\u003eAnother aspect that makes GUI programming tricky is that, for performance, ideally it should be \u003cem\u003eincremental.\u003c/em\u003e In response to an input, likely most of the GUI state and appearance stays the same, only a small amount actually changes. The key to performance is to do as little work as possible, meaning only touching the state that’s changed, and only repainting the parts of the screen that have changed. In the olden days, an incremental approach was necessary, because repainting the whole window would be noticeably slow. These days, it’s a very common simplification to just draw the world, especially in \u003ca href=\"https://gist.github.com/bkaradzic/853fd21a15542e0ec96f7268150f1b62\"\u003eimmediate mode GUI\u003c/a\u003e. I should point out that my current code doesn’t do incremental present, but I plan to, and I want the architecture to support it.\u003c/p\u003e\n\n\u003ch2 id=\"entity-component-system-architecture\"\u003eEntity-Component-System architecture\u003c/h2\u003e\n\n\u003cp\u003eIn the Entity-Component-System architecture, the system owns all the components \u003cstrong\u003e(update added 2018-05-10: that’s not really accurate, in real ECS the components are stored in a database; my UiState is combining the database and systems roles from ECS)\u003c/strong\u003e. In their terminology, an entity is a small, lightweight object that serves as a reference to a component. In Rust, it’s just a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eusize\u003c/code\u003e, an index into the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eVec\u0026lt;\u0026gt;\u003c/code\u003e that the system uses to hold the components.\u003c/p\u003e\n\n\u003cp\u003eIn ECS (or at least my spin on it), the component is responsible for its specialized behavior, and holds its specialized state (such as the text of a label), but the system holds the state common to all widgets (such as layout geometry). The system also holds the \u003cem\u003erelationships\u003c/em\u003e between the components (in this case, widgets are in a tree) and is responsible for their interactions.\u003c/p\u003e\n\n\u003cp\u003eIn xi-win-ui, most of the interaction is through the \u003ca href=\"https://github.com/google/xi-win/blob/8c5ef020c846a0a8e152cd8ab5d2b79bdb3e6cb1/xi-win-ui/src/widget/mod.rs#L34\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWidget\u003c/code\u003e\u003c/a\u003e trait. In fact, the component is implemented as a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBox\u0026lt;Widget\u0026gt;\u003c/code\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"use-integers-for-graph-node-ids\"\u003eUse integers for graph node id’s\u003c/h2\u003e\n\n\u003cp\u003eAt the heart of the UI is the tree of widgets, which really behaves as more of a graph because the parent/child link can be traversed in both directions. There are multiple ways to represent a graph in Rust. I personally really like storing the node contents in a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eVec\u003c/code\u003e, and using \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eusize\u003c/code\u003e as an identifier. This has all been described before, and I’ll refer readers to \u003ca href=\"https://rust-leipzig.github.io/architecture/2016/12/20/idiomatic-trees-in-rust/\"\u003eIdiomatic tree and graph like structures in Rust\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eThere’s not really a lot to add here, it’s just another datapoint that the pattern works well.\u003c/p\u003e\n\n\u003ch2 id=\"state-splitting\"\u003eState splitting\u003c/h2\u003e\n\n\u003cp\u003ePart of what makes GUI uniquely tricky is that the patterns of mutability are very dynamic. For example, when doing layout, you want the geometry to be mutable, but you also want to take immutable references to the graph. At a different time, when you’re adding widgets to the tree, the graph needs to be mutable but there’s no reason to touch the geometry.\u003c/p\u003e\n\n\u003cp\u003eOne approach is to defer all this to runtime - use interior mutability so all the references you pass around are non-mutable, then take a mutable borrow at just the moment needed.\u003c/p\u003e\n\n\u003cp\u003eI think a more \u003cem\u003eidiomatic\u003c/em\u003e approach is to figure out exactly what mutability is needed, and encode that into the types of the various methods, so it’s enforced at compile time. An advantage is that it’s impossible to get a multiple-borrowing panic as a result, the borrowing patterns are basically proved correct.\u003c/p\u003e\n\n\u003cp\u003eThe key to implementing this pattern is \u003cem\u003estate splitting.\u003c/em\u003e At the entry point, you have a mutable reference to the entire state. Take that state and \u003cem\u003esplit\u003c/em\u003e it into references to individual fields. Depending on what you’re doing, some of the references will be mutable, others not. You can traverse a tree by doing recursive calls, just plumb the references through.\u003c/p\u003e\n\n\u003cp\u003eExamples include \u003ca href=\"https://github.com/google/xi-win/blob/8c5ef020c846a0a8e152cd8ab5d2b79bdb3e6cb1/xi-win-ui/src/lib.rs#L304\"\u003elayout\u003c/a\u003e, which has a mutable references to the component vector and geometry but a non-mutable reference to the graph. The \u003ca href=\"https://github.com/google/xi-win/blob/8c5ef020c846a0a8e152cd8ab5d2b79bdb3e6cb1/xi-win-ui/src/lib.rs#L295\"\u003epaint\u003c/a\u003e method is similar but has immutable geometry and a mutable render target for actually drawing the widget’s appearance. When calling a handler for input events (mouse keyboard), a \u003cem\u003econtext\u003c/em\u003e is passed in, which has enough mutable state for a widget to mark itself as needing redraw, and also for sending further events to a listener. More about listeners below.\u003c/p\u003e\n\n\u003ch2 id=\"data-flow-not-control-flow\"\u003eData flow, not control flow\u003c/h2\u003e\n\n\u003cp\u003eI wanted to adopt the Flutter layout model because it’s efficient and flexible. Flutter layout is a one-pass traversal of the tree in which constraints flow down and sizes flow up. I enjoyed Adam Barth’s talk, \u003ca href=\"https://www.youtube.com/watch?v=UUfXWzp0-DU\"\u003eFlutter’s Rendering Pipeline\u003c/a\u003e as a clear description, but \u003ca href=\"https://proandroiddev.com/understanding-flutter-layout-box-constraints-292cc0d5e807\"\u003eUnderstanding Flutter Layout (Box)Constraints\u003c/a\u003e gets the basics across. (I should point out to avoid confusion that a Flutter \u003ca href=\"https://docs.flutter.io/flutter/rendering/RenderObject-class.html\"\u003eRenderObject\u003c/a\u003e corresponds most closely to a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eWidget\u003c/code\u003e in xi-win-ui; the RenderObject hierarchy is a fairly traditional widget system, while Flutter’s \u003ca href=\"https://docs.flutter.io/flutter/widgets/Widget-class.html\"\u003eWidget\u003c/a\u003e class can be seen as a react-style layer to manage render objects - this \u003ca href=\"https://www.youtube.com/watch?v=dkyY9WCGMi0\"\u003etalk\u003c/a\u003e by Ian Hickson is a good explanation.)\u003c/p\u003e\n\n\u003cp\u003eIn Flutter, the layout method of a container RenderObject recursively calls its children. However, in Rust this would be a problem; the borrow checker would complain. To call the layout method of the parent widget, we need a mutable borrow, which is derived from a mutable borrow from the container that holds the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eBox\u0026lt;Widget\u0026gt;\u003c/code\u003e objects. So to call the child, we’d need another borrow from that container to get a callable reference to the child widget. Oops.\u003c/p\u003e\n\n\u003cp\u003eThe solution used in xi-win-ui is to “smuggle” enough state out from the borrowed context to make progress. It’s something like a continuation, and the style is similar to writing iterators in Rust. For layout specifically, when a widget wants to request the layout of a child, it \u003cem\u003ereturns\u003c/em\u003e a \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRequestChild\u003c/code\u003e result with the id of the child node. The system then computes that layout (traversing into children as needed), then calls the \u003ccode class=\"language-plaintext highlighter-rouge\"\u003elayout\u003c/code\u003e method again with the result.\u003c/p\u003e\n\n\u003cp\u003eA similar approach is used for listeners. In a traditional object-oriented UI, a mouse handler for a button widget would probably call the listeners attached the button. In turn, the listener might do a lot of different things, including adding more widgets to the tree (if the action of the button is open a new tab, say). But none of this would be allowed when the button has a mutable borrow.\u003c/p\u003e\n\n\u003cp\u003eThe solution is similar to layout; instead of immediately invoking the listeners, the widget adds its output event to a queue (the context passed to the handler includes a mutable reference to this queue). Then, when the handler returns, the events in this queue are dispatched to the listeners. The context given to the listener allows mutable access to pretty much all state, so it can “poke” widgets, mutate the widget graph, etc.\u003c/p\u003e\n\n\u003cp\u003eThe event queue also illustrates a good use of Rust’s \u003ca href=\"https://doc.rust-lang.org/std/any/trait.Any.html\"\u003e\u003ccode class=\"language-plaintext highlighter-rouge\"\u003eAny\u003c/code\u003e\u003c/a\u003e trait. Different widgets will send different concrete types, as there are many types useful in such events, but a specific listener attached to a widget will know what type to expect.\u003c/p\u003e\n\n\u003ch2 id=\"state-for-the-application-logic\"\u003eState for the application logic\u003c/h2\u003e\n\n\u003cp\u003eIn the master branch as of the time of this writing, the \u003ca href=\"https://github.com/google/xi-win/blob/8c5ef020c846a0a8e152cd8ab5d2b79bdb3e6cb1/xi-win-ui/examples/calc.rs\"\u003ecalculator\u003c/a\u003e uses an \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRc\u0026lt;RefCell\u0026lt;CalcState\u0026gt;\u0026gt;\u003c/code\u003e to store the calculator state, and this reference is shared among all the listeners for the individual calculator buttons. This demonstrates that it’s possible to mix the interior mutability pattern with the ECS architecture.\u003c/p\u003e\n\n\u003cp\u003eAn \u003ca href=\"https://github.com/google/xi-win/pull/32\"\u003ealternative implementation\u003c/a\u003e uses a custom widget just to store the application state. Individual button listeners send events that bubble up to this widget. No explicit id is required for this plumbing; it’s implicit by being the nearest ancestor that catches the event. The widget cannot directly change the state of other widgets (for example, updating the readout), so it sends events to a listener, which can.\u003c/p\u003e\n\n\u003cp\u003eI’m still figuring out the cleanest and most idiomatic ways to wire up UI in this architecture. The point of this subsection is to illustrate that there are multiple reasonable approaches.\u003c/p\u003e\n\n\u003ch2 id=\"references\"\u003eReferences\u003c/h2\u003e\n\n\u003cp\u003eAnother approach to GUI in Rust is \u003ca href=\"https://github.com/PistonDevelopers/conrod\"\u003econrod\u003c/a\u003e. It uses some of the same techniques (including a Rust-idiomatic graph), but makes quite a number of design decisions differently than what I want in xi-win. Potential users and implementers of GUI in Rust should definitely look at that.\u003c/p\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://github.com/antoyo/relm\"\u003erelm\u003c/a\u003e project addresses a higher level of the stack than xi-win-ui, a functional-reactive layer on top of a traditional widget system. The functional reactive style is known for very concise expression of UI. It might be interesting to integrate such a layer on top of xi-win-ui, but for xi-win I plan to just build the widget tree directly.\u003c/p\u003e\n\n\u003ch2 id=\"conclusion\"\u003eConclusion\u003c/h2\u003e\n\n\u003cp\u003eThe overuse of \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eRefCell\u003c/code\u003e is a sign of unidiomatic Rust code. With the right architecture, it can be avoided entirely. The general techniques apply in many cases where there is dynamic interaction between multiple stateful components. These techniques are: use integers as references to nodes within a graph, split state into mutable and immutable parts when diving in, and explicitly export “continuation” state when too deeply borrowed, rather than transferring control flow directly.\u003c/p\u003e\n\n\u003cp\u003eThe ECS architecture has proved itself valuable in the games world, particularly in C++. It adapts well to Rust, and is equally as suitable to widgets in a UI framework as it is to players in a game.\u003c/p\u003e\n\n\u003cp\u003eThough still experimental, the approach of xi-win-ui looks like it will be suitable for the relatively simple UI needs of xi-win. The code is very simple, with basically no “magic” or macros to hide underlying complexity, just vanilla usage of idiomatic Rust concepts. Designers of future Rust GUI toolkits are strongly encouraged to study this code.\u003c/p\u003e\n\n\u003ch2 id=\"thanks\"\u003eThanks\u003c/h2\u003e\n\n\u003cp\u003eThanks to Connie Hilarides for useful discussions about the ECS architecture, and Rob Tsuk for discussions and prototypes of GUI in Rust.\u003c/p\u003e\n\n  \u003c/div\u003e",
  "Date": "2018-05-08T18:29:03Z",
  "Author": "raphlinus"
}