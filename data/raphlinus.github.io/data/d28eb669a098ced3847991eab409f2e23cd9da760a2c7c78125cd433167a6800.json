{
  "Source": "raphlinus.github.io",
  "Title": "A crate I want: 2d graphics",
  "Link": "https://raphlinus.github.io/rust/graphics/2018/10/11/2d-graphics.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThe Rust ecosystem has lot of excellent crates, and many more new ones being published. I believe one is missing, though, and I’d really like to see it happen: a cross-platform abstraction for 2D graphics. In this post I will set out what I want.\u003c/p\u003e\n\n\u003ch2 id=\"cross-platform-abstractions\"\u003eCross-platform abstractions\u003c/h2\u003e\n\n\u003cp\u003eAn enduring pattern in Rust is a cross-platform abstraction to wrap a system service. Many system services (audio, window creation, networking) require plumbing through to the system. The usual structure is to have platform-specific wrappers as a bottom layer, sometimes a wrapper to add safety and a more Rust idiomatic API, and then a cross-platform abstraction.\u003c/p\u003e\n\n\u003cp\u003eFor reference, here are some examples of the pattern, for basic system services. In many cases, there are other options, this is mostly to illustrate the kinds of things available.\u003c/p\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eservice\u003c/th\u003e\n      \u003cth\u003ecross-platform crate\u003c/th\u003e\n      \u003cth\u003emacOS\u003c/th\u003e\n      \u003cth\u003eLinux\u003c/th\u003e\n      \u003cth\u003eWindows\u003c/th\u003e\n      \u003cth\u003eWeb\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eaudio\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/tomaka/cpal\"\u003ecpal\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/RustAudio/coreaudio-rs\"\u003ecoreaudio\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/diwic/alsa-rs\"\u003ealsa\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/retep998/winapi-rs\"\u003ewinapi\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/koute/stdweb\"\u003estdweb\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003emidi\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/Boddlnagg/midir\"\u003emidir\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/chris-zen/coremidi\"\u003ecoremidi\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/diwic/alsa-rs\"\u003ealsa\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/retep998/winapi-rs\"\u003ewinapi\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eN/A\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003ewindow creation\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/tomaka/winit\"\u003ewinit\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/servo/core-foundation-rs\"\u003ecore-graphics\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/Smithay/wayland-rs\"\u003ewayland\u003c/a\u003e / \u003ca href=\"https://github.com/erlepereira/x11-rs\"\u003ex11\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/retep998/winapi-rs\"\u003ewinapi\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/tomaka/winit/tree/master/src/platform/emscripten\"\u003e(in winit)\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e3D graphics\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/gfx-rs/gfx\"\u003egfx-rs\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/gfx-rs/metal-rs\"\u003emetal\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/MaikKlein/ash\"\u003eash\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/gfx-rs/d3d12-rs\"\u003ed3d12\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eN/A\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eentropy\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://crates.io/crates/rand\"\u003erand\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/rust-lang/libc\"\u003elibc\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/rust-lang/libc\"\u003elibc\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/retep998/winapi-rs\"\u003ewinapi\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://github.com/koute/stdweb\"\u003estdweb\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eThe near-magical result of this pattern is that, very often, it’s possible to \u003ccode class=\"language-plaintext highlighter-rouge\"\u003egit clone\u003c/code\u003e a project, run \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ecargo run\u003c/code\u003e, and have it “just work,” even if running on a different platform than it was developed for.\u003c/p\u003e\n\n\u003ch2 id=\"build-vs-buy\"\u003eBuild vs buy\u003c/h2\u003e\n\n\u003cp\u003eAs with many things, there is a choice between building a 2D graphics engine, or using one that already exists, in particular one provided with the system. And as usual, there are tradeoffs either way.\u003c/p\u003e\n\n\u003cp\u003eAn advantage of “build” is that rendering is more likely to be consistent across multiple platforms; similarly, the testing burden is reduced. In addition, a state-of-the art renderer has the potential to be more performant.\u003c/p\u003e\n\n\u003cp\u003eAn advantage of “buy” is that the amount of Rust code to be compiled is potentially a lot smaller. As an extreme, \u003ca href=\"https://skia.org/\"\u003eSkia\u003c/a\u003e is a 349MB git clone, not counting any of the dependencies (which of course are managed with a \u003ca href=\"https://skia.org/docs/user/download/\"\u003ebespoke tool\u003c/a\u003e). Also, depending on relative quality of implementation, it might also be more performant, as there’s potential. Finally, very mature 2D graphics libraries already exist, while there’s a lot to do to build a new one.\u003c/p\u003e\n\n\u003cp\u003eUltimately I think both choices are valid, it comes down to quantitative issues, and, in an ideal world, it’s a config choice.\u003c/p\u003e\n\n\u003ch3 id=\"some-potential-rust-native-back-ends\"\u003eSome potential Rust-native back-ends\u003c/h3\u003e\n\n\u003cp\u003eGiven a cross-platform abstraction for 2D graphics, several promising projects, both existing and future, could potentially be a back-end. The gfx team is starting discussions on \u003ca href=\"https://github.com/draw2d/rfcs/issues/1\"\u003edraw2d\u003c/a\u003e, which would sit on top of the gfx-rs 3d abstraction.\u003c/p\u003e\n\n\u003cp\u003eIn addition, \u003ca href=\"https://github.com/servo/webrender\"\u003eWebRender\u003c/a\u003e has a good chunk of 2D graphics rendering functionality, though itself is missing general Bezier path rendering. Both \u003ca href=\"https://github.com/pcwalton/pathfinder\"\u003ePathfinder\u003c/a\u003e and \u003ca href=\"https://github.com/nical/lyon\"\u003elyon\u003c/a\u003e provide the needed path functionality, using different approaches to use 3D graphics hardware.\u003c/p\u003e\n\n\u003ch3 id=\"other-back-ends\"\u003eOther back-ends\u003c/h3\u003e\n\n\u003cp\u003eFor maximum compatibility, I imagine \u003ca href=\"https://cairographics.org/\"\u003ecairo\u003c/a\u003e is the most useful back-end when a system-provided library is not available. However, cairo is mostly a software renderer, so performance will be quite poor compared with what GPU hardware can do. (For full disclosure, there are other back-ends, but harder to interface, and none using state of the art rendering techniques, so this is unlikely to be a major effort.)\u003c/p\u003e\n\n\u003ch2 id=\"the-web\"\u003eThe web\u003c/h2\u003e\n\n\u003cp\u003eAn exciting and recent development is the rightmost column in the above table. Increasingly, through wasm, the web is just another compilation target for Rust.\u003c/p\u003e\n\n\u003cp\u003eI think this is an especially good opportunity for a 2D graphics abstraction, as 2D graphics is central to the web. There are lots of applications that could potentially target the web: charts, diagrams, and visualizations.\u003c/p\u003e\n\n\u003ch2 id=\"porting-xi-win-ui\"\u003ePorting xi-win-ui\u003c/h2\u003e\n\n\u003cp\u003eI’m making good, steady progress with xi-win-ui. In addition to xi-win, I’m also building the GUI for my \u003ca href=\"https://github.com/raphlinus/synthesizer-io\"\u003esynthesizer\u003c/a\u003e using it, and plan to use it for the game UI and interaction when I get to that.\u003c/p\u003e\n\n\u003cp\u003eRight now, I’m using \u003ca href=\"https://github.com/Connicpu/direct2d-rs\"\u003edirect2d\u003c/a\u003e, and it’s going well. That said, I’m not happy about the fact that this code is Windows-only. I’d like this 2D graphics abstraction crate to exist sooner rather than later, so I can port the code over.\u003c/p\u003e\n\n\u003ch2 id=\"design-choices\"\u003eDesign choices\u003c/h2\u003e\n\n\u003cp\u003eAs is being discussed on the \u003ca href=\"https://github.com/draw2d/rfcs/issues/1\"\u003edraw2d\u003c/a\u003e thread, there are a number of design choices. Personally, I’d like to see the API generally close to Direct2D, not only because that minimizes porting cost, but also because it’s a relatively modern, performant implementation.\u003c/p\u003e\n\n\u003cp\u003eMost 2D APIs are immediate mode, but WebRender is moving in the direction of retained mode, as they find some performance optimizations when painting similar content from frame to frame. A possible compromise is to use a fundamentally immediate mode API, but with functionality to record and display into a display list; this gives the renderer the possibility to preprocess the elements (tesselating polygons, computing overlap for the purpose of reordering to optimize batching, etc) in the display list.\u003c/p\u003e\n\n\u003cp\u003eThe classic 2D API (I believe most are derived from Java2D, which in turn is inspired by PostScript) is very stateful, generally with push/pop operations to change the transform, set a crop, etc. This style is not ideal for multithreaded apps, and modern 3D APIs have moved very far away from it, Vulkan being an extreme. It could be quite interesting to design a high performance 2D API based on similar ideas, but I’m not sure how important it is in practice; certainly when using existing libraries.\u003c/p\u003e\n\n\u003ch2 id=\"other-related-projects\"\u003eOther related projects\u003c/h2\u003e\n\n\u003cp\u003eOne project to look at is \u003ca href=\"https://github.com/RazrFalcon/resvg\"\u003eresvg\u003c/a\u003e, a pure-Rust SVG implementation. It currently has both a \u003ca href=\"https://cairographics.org/\"\u003ecairo\u003c/a\u003e and a \u003ca href=\"https://www.qt.io/\"\u003eQt\u003c/a\u003e backend. It is probably worth looking at its implementation to see what kind of interface it uses for multiple backends. SVG is also quite a rich graphical model. If the new crate is successful, resvg could perhaps be adapted to use it.\u003c/p\u003e\n\n\u003ch2 id=\"testing-and-performance-evaluation\"\u003eTesting and performance evaluation\u003c/h2\u003e\n\n\u003cp\u003eA major part of the work for this project is evaluating correctness and performance across the multiple backends. The Skia project has an extremely extensive test suite and performance dashboard infrastructure. It might be worth borrowing some of that. Ideally, all backends produce identical results, but of course there will be subtle differences with roundoff, gamma correction, etc.\u003c/p\u003e\n\n\u003cp\u003eHaving such a test suite would also be highly useful for the development of new backends such as draw2d - in my experience, one of the most productive applications of test driven development is when the tests already exist.\u003c/p\u003e\n\n\u003ch2 id=\"text\"\u003eText\u003c/h2\u003e\n\n\u003cp\u003eWhile 2D graphics with only geometric elements and is possible, usually a lot of the content is text. For xi-win-ui, I’m using DirectWrite as a companion to Direct2D.\u003c/p\u003e\n\n\u003cp\u003eText is complex, and has many subfunctions:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003eEnumerating the system fonts (often with metadata, such as figuring out which fonts are suitable for which scripts).\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eShaping text into glyphs (\u003ca href=\"https://www.freedesktop.org/wiki/Software/HarfBuzz/\"\u003eHarfBuzz\u003c/a\u003e is the gold standard here).\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eRasterizing the glyphs (traditionally \u003ca href=\"https://www.freetype.org/\"\u003eFreeType\u003c/a\u003e, but \u003ca href=\"https://github.com/redox-os/rusttype\"\u003erusttype\u003c/a\u003e and \u003ca href=\"https://github.com/raphlinus/font-rs\"\u003efont-rs\u003c/a\u003e are also viable).\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003eMaintaining a glyph cache in a texture atlas.\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003ePainting text.\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eEven painting can be complex, as to match high quality desktop rendering both RGB subpixel rendering and gamma correct blending is desirable. But these aren’t required for games or mobile usage, and even desktop systems are migrating away from RGB subpixel rendering (it’s \u003ca href=\"https://news.ycombinator.com/item?id=17476873\"\u003eoff\u003c/a\u003e by default in Mojave 10.14).\u003c/p\u003e\n\n\u003cp\u003eUsing a texture atlas is the classic technique, but the library should be designed not to force this architecture. I think the future is to do the text rasterizing directly on the GPU, which is potentially much faster when the transform is changing continuously (as in pinch-to-zoom or perspective animation).\u003c/p\u003e\n\n\u003ch2 id=\"prospects\"\u003eProspects\u003c/h2\u003e\n\n\u003cp\u003eHaving such an abstraction is on the critical path for my game eventually, but it won’t be for a while, as I’m happy doing the prototyping Windows-only for now. Thus, I’d love for the Rust community to step up and build this, one way or other.\u003c/p\u003e\n\n\u003cp\u003eI don’t have a lot of extra bandwidth for open source projects right now, but I’m definitely willing to help guide a serious effort. It’d be out of my own pocket, but modest funding might also be available if it would make the difference between this happening or not.\u003c/p\u003e\n\n\u003cp\u003eIdeally, it’s something a lot of people could benefit from, and would help the Rust ecosystem as a whole.\u003c/p\u003e\n\n\u003cp\u003ePlease follow the discussion at \u003ca href=\"https://www.reddit.com/r/rust/comments/9nhhh8/a_crate_i_want_2d_graphics/?ref=share\u0026amp;ref_source=link\"\u003e/r/rust\u003c/a\u003e.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2018-10-11T22:44:03Z",
  "Author": "raphlinus"
}