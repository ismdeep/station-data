{
  "Source": "raphlinus.github.io",
  "Title": "With Undefined Behavior, Anything is Possible",
  "Link": "https://raphlinus.github.io/programming/rust/2018/08/17/undefined-behavior.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003e\u003cimg src=\"/assets/Anything_is_Possible_scaled.jpg\" alt=\"anything is possible\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eUndefined behavior contributes to many serious problems, including security vulnerabilities. It’s also, I believe, poorly understood, and discussions of it tend to become contentious. How did we get here? What are the best ways to deal with it? Is it a good thing or a bad thing, and if the latter, is it even possible to get rid of it? To address these questions will require digging a bit into history.\u003c/p\u003e\n\n\u003ch2 id=\"unportable-semi-portable-and-standard-c\"\u003eUnportable, Semi-portable, and Standard C\u003c/h2\u003e\n\n\u003cp\u003eC programmers are not a homogeneous community. To understand undefined behavior, I divide them into three camps. The principles and practices in one camp can seem alien, even threatening to another.\u003c/p\u003e\n\n\u003ch3 id=\"unportable-c-a-step-up-from-assembler\"\u003eUnportable C: a step up from assembler\u003c/h3\u003e\n\n\u003cp\u003eIn the “unportable C” camp, the ultimate goal is to ship a binary, usually for a single piece of hardware. The C compiler is a tool to help you get to that binary faster. It makes sense to exploit any extensions offered by the compiler. In the event of any confusion about the semantics of the language, the binary (the output of the compiler) is the ultimate source of truth.\u003c/p\u003e\n\n\u003cp\u003eThe computation model is very much the same as assembly language, with details matching those of the target hardware. Pointers are just integers (of a known word size) used in a particular way, integer arithmetic wraps reliably, etc.\u003c/p\u003e\n\n\u003cp\u003eUnportable use of C is increasingly rare, but used to be common practice. An extreme example of unportable C is the book \u003cem\u003eMastering C Pointers: Tools for Programming Power,\u003c/em\u003e which was \u003ca href=\"https://wozniak.ca/blog/2018/06/25/Massacring-C-Pointers/index.html\"\u003ecastigated\u003c/a\u003e recently. To be fair, that book has other flaws rather than being in a different camp, but I think that fuels some of the intensity of passion against it.\u003c/p\u003e\n\n\u003ch3 id=\"semi-portable-c-the-triumph-of-the-ifdef\"\u003eSemi-portable C: the triumph of the #ifdef\u003c/h3\u003e\n\n\u003cp\u003eIn many cases, you don’t want to target a single machine, but maybe a range of them, and a range of operating systems, compilers, and other factors. These machines may be diverse; pointer size can be 16, 32, or 64 bits, and both little and big endian are possible. There’s going to be some form of configuration mechanism (often \u003ca href=\"https://www.gnu.org/software/autoconf/autoconf.html\"\u003eautoconf\u003c/a\u003e in the Unix-y world) that populates preprocessor symbols so that #ifdef directives can choose the right alternative code for that target.\u003c/p\u003e\n\n\u003cp\u003eUse of compiler-specific extensions is to be looked at with suspicion (though in many cases it might make sense to turn them on with #ifdef if it’ll help with performance, debugging, etc.). It makes sense to write code with at least an eye out for portability, rather than making assumptions about the specific target machine.\u003c/p\u003e\n\n\u003cp\u003eThe computation model is pretty much the same as the unportable case, just that the details might vary. In particular, \u003ca href=\"https://blog.regehr.org/archives/959\"\u003etype punning\u003c/a\u003e is fine, as long as care is taken to make sure sizes line up. Sometimes you can get bitten, for example x86 is much more forgiving of unaligned accesses than RISC; sometimes they can cause a serious performance problem, other times they might just crash. Similarly, shifting past bitwidth might do different things on different machines (maybe shifting in all zeros, maybe shifting an amount modulo the bitwidth), but always something reasonable.\u003c/p\u003e\n\n\u003cp\u003eSemi-portable C used to be the mainstream, but is now giving way to standard C in many contexts. But, as we’ll see, there are still (at least partial) hold-outs. When people describe C as “\u003ca href=\"https://stackoverflow.com/questions/3040276/when-did-people-first-start-thinking-c-is-portable-assembler\"\u003ea portable assembly language\u003c/a\u003e” it’s pretty much the semi-portable camp they’re referring to.\u003c/p\u003e\n\n\u003ch3 id=\"standard-c-a-compromise\"\u003eStandard C: a compromise\u003c/h3\u003e\n\n\u003cp\u003eFaced with the above situation, the standards committee had a daunting task: come up with a version of C that could reasonably be implemented by all compilers. It had to be close enough to existing C that it wouldn’t be too difficult or expensive to migrate existing code, but at the same time there was an opportunity to improve the language, in particular to \u003ca href=\"http://ee.hawaii.edu/~tep/EE160/Book/chapapx/node7.html\"\u003eclean up\u003c/a\u003e some of the lack of discipline about function parameter types.\u003c/p\u003e\n\n\u003cp\u003eIn so doing, the committee had to converge on a computational model that would somehow encompass all targets. This turned out to be quite difficult, because there were a lot of targets out there that would be considered strange and exotic; arithmetic is not even guaranteed to be twos complement (the alternative is \u003ca href=\"https://superuser.com/questions/1137182/is-there-any-existing-cpu-implementation-which-uses-ones-complement\"\u003eones complement\u003c/a\u003e), \u003ca href=\"https://retrocomputing.stackexchange.com/questions/4419/how-was-the-c-language-ported-to-architectures-with-non-power-of-2-word-sizes\"\u003eword sizes might not be a power of 2\u003c/a\u003e, and other things.\u003c/p\u003e\n\n\u003cp\u003eC requires rigorous attention to correct use of pointers, to avoid \u003ca href=\"https://www.purehacking.com/blog/lloyd-simon/an-introduction-to-use-after-free-vulnerabilities\"\u003euse-after-free\u003c/a\u003e, \u003ca href=\"https://www.owasp.org/index.php/Double_Free\"\u003edouble-free\u003c/a\u003e, \u003ca href=\"https://cwe.mitre.org/data/definitions/125.html\"\u003eout-of-bounds access\u003c/a\u003e, and other similar memory errors. Any of those can cause symptoms ranging from crashes to subtle memory corruption to silently incorrect results, and very likely different results on different machines. The standards committee invented the concept of “undefined behavior” to capture this range of behavior. Essentially, it’s a license for the implementation to do anything it wants. And that’s reasonable; it’s hard to imagine nailing down the behavior any further without compromising performance or the fundamental nature of the problem.\u003c/p\u003e\n\n\u003cp\u003eBut given this hammer, the committee applied it far more broadly. For example, shift-past-bitwidth is also considered undefined behavior. Many have argued persuasively that it would have been better to treat this particular case as “implementation defined,” so a programmer would be able to count on, for example, always getting the same result for the same inputs on the same chip (though it might be different on a different chip, like endianness). However, that’s not what they decided. Instead, computing \u003ccode class=\"language-plaintext highlighter-rouge\"\u003ex \u0026lt;\u0026lt; 64\u003c/code\u003e is allowed to crash, subtly corrupt memory, or connect to a server to transfer money out of your account. That last is not a joke (along the lines of \u003ca href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\"\u003enasal demons\u003c/a\u003e); undefined behavior is the source of many serious security vulnerabilities, and arithmetic issues (including shifting but especially integer overflow) a respectable subset of those.\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/unicorndraft1.jpg\" alt=\"anything is possible\"/\u003e\u003c/p\u003e\n\n\u003cp\u003eIndeed, there is a very large catalog of potential undefined behaviors: signed integer overflow, reading uninitialized memory, computing (not just dereferencing!) an out-of-bounds pointer, type punning through pointers, etc. I won’t try to give an exhaustive catalog here (John Regehr’s \u003ca href=\"https://blog.regehr.org/archives/213\"\u003eguide\u003c/a\u003e is an excellent introduction), but the point is that it cast such a wide net that essentially all extant programs ran into one or another form of it.\u003c/p\u003e\n\n\u003cp\u003eIn other words, the standard basically broke all existing programs, in the sense that don’t work in the new category of “strictly conforming”. Perhaps the committee felt that programmers could fairly easily clean up the flaws in their programs, much the way they had to change argument syntax, but if so they massively underestimated the task.\u003c/p\u003e\n\n\u003cp\u003eMost of the remainder of this post is dedicated to the implications and consequences of such an expansive definition of undefined behavior\u003c/p\u003e\n\n\u003ch2 id=\"pointers-are-complicated\"\u003ePointers are complicated\u003c/h2\u003e\n\n\u003cp\u003eUndefined behavior is not just for capturing the variation between implementations; another major motivation is to enable optimizations that would otherwise be difficult. One of the trickiest areas is \u003ca href=\"https://blog.regehr.org/archives/1307\"\u003estrict aliasing\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eHere’s a quick sketch of the motivation. Many optimizations depend on “aliasing analysis,” essentially guarantees that pointers don’t alias, or more generally that ranges of memory don’t overlap. In general, alias analysis is intractable. However, in a program that strongly respects typing rules, two values of different types \u003cem\u003ecan’t\u003c/em\u003e overlap. Standard C basically makes the assumption that programs do respect types, therefore two pointers of two different types can’t possibly overlap. Back in the day, lots of people had trouble coming to grips with that, hence slogans such as “Not all of the world is a VAX.”\u003c/p\u003e\n\n\u003cp\u003eAnd it “enforces” this by declaring that any such usage of pointers is undefined behavior. This can’t be done with a simple model where pointers are just numbers. The best way to understand the actual C standard is that programs run on an exotic, complex virtual machine in which pointers are numbers, yes, but annotated with types and valid ranges. Any usage of a pointer that doesn’t strictly follow the rules is immediately undefined behavior.\u003c/p\u003e\n\n\u003cp\u003eThis is the true computational model of standard C. What makes the situation so deceptive is that this complex virtual machine can be easily run on standard hardware, just by stripping out the extra stuff. What’s easy to forget sometimes is that the compiler is allowed to do much more complicated things, and often does so in service of optimization.\u003c/p\u003e\n\n\u003cp\u003eUnderstanding the actual rules is not easy. For an excellent recent discussion digging into more detail, see \u003ca href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\"\u003ePointers Are Complicated, or: What’s in a Byte?\u003c/a\u003e. And for a research paper going into great detail (including evidence that both LLVM and GCC miscompile some programs that technically follow the standard), see \u003ca href=\"http://sf.snu.ac.kr/llvmtwin/\"\u003eReconciling High-level Optimizations and Low-level Code in LLVM\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"a-radical-change-in-slow-motion\"\u003eA radical change, in slow motion\u003c/h2\u003e\n\n\u003cp\u003eC has a reputation for being a stable, mature language. However, the transition to standard C was anything but stable; it broke almost all programs, and in deep, fundamental ways that are difficult to identify. If compilers had actually generated crashing code for all undefined behavior, as allowed in the standard, there would have been open revolt.\u003c/p\u003e\n\n\u003cp\u003eBut compilers didn’t change much at all in early days. Undefined behavior was a convenient way for existing implementations to claim compliance with the standard. Programs routinely violated the letter of the standard, but when you compiled them, they \u003cem\u003eworked.\u003c/em\u003e In practice, everybody was in the semi-portable camp. To use the language of the standard, compilers were “conforming.”\u003c/p\u003e\n\n\u003cp\u003eHowever, compiler authors got bolder over time, feeling that everything allowed in the standard was fair game, at the same time getting more sophisticated in what optimizations could be done with stronger assumptions. This, of course, had the effect of taking all those programs that were broken in theory and making them broken in practice. Understandably, programmers in the semi-portable camp blamed compiler authors in the standard camp for being overly aggressive, optimizing too much. A passionate and recent example is the \u003ca href=\"https://lkml.org/lkml/2018/6/5/769\"\u003erant from Linus Torvalds\u003c/a\u003e critiquing a patch to remove union-based aliasing.\u003c/p\u003e\n\n\u003cp\u003eSimilarly, people in the standard camp (likely, the authors of that patch) view any code that introduces the potential for undefined behavior as dangerous, frequently invoking language of contamination and uncleanliness. From this perspective, it’s not surprising to see \u003ca href=\"https://news.ycombinator.com/item?id=17262643\"\u003ediscussions\u003c/a\u003e get contentious.\u003c/p\u003e\n\n\u003ch2 id=\"threads-memory-models-and-expressivity\"\u003eThreads, memory models, and expressivity\u003c/h2\u003e\n\n\u003cp\u003eThreads are increasingly important, not least because multi-core CPU’s are now ubiquitous. However, they interact in complex ways with languages (like C) that are fundamentally sequential. The prevailing approach at the time of C89 is that thread primitives (such as \u003ca href=\"https://en.wikipedia.org/wiki/POSIX_Threads\"\u003epthreads\u003c/a\u003e) would be provided as a library, and that their behavior would be described entirely in semi-portable concepts.\u003c/p\u003e\n\n\u003cp\u003eA corollary is that the strict “standard C” language was much less expressive than the semi-portable dialog, not being able to represent threaded programs at all. Again, this wasn’t too much of a problem in practice\u003c/p\u003e\n\n\u003cp\u003eThe situation improved considerably with C11, building off the many years of work to arrive at the C++11 memory model (which in turn was quite inspired by the \u003ca href=\"https://en.wikipedia.org/wiki/Java_memory_model\"\u003eJava memory model\u003c/a\u003e, arguably the first successful example of such a thing). Actually understanding these memory models is \u003ca href=\"https://arxiv.org/pdf/1803.04432.pdf\"\u003ecomplicated\u003c/a\u003e, but at least now we can say that the standard dialect has regained much of the expressivity it lost.\u003c/p\u003e\n\n\u003cp\u003eIt’s worth asking: what is the gap in expressivity between semi-portable and standard C today? Much of it is implementation of concepts from much higher level programming languages, such as the \u003ca href=\"http://www.hboehm.info/gc/\"\u003eBoehm-Demers-Weiser garbage collector\u003c/a\u003e, which relies heavily on semi-portable constructs. Similarly, tail recursion and coroutines are popular programming language features that cannot be expressed readily in standard C. Thus, many systems (including many that embed a scripting language) must rely on semi-portable C. The standards committee dream of all programs strictly conforming to the standard is likely a long ways off, if ever.\u003c/p\u003e\n\n\u003ch2 id=\"what-is-to-be-done\"\u003eWhat is to be done?\u003c/h2\u003e\n\n\u003cp\u003eUndefined behavior is a mess. There have been \u003ca href=\"https://blog.regehr.org/archives/1180\"\u003eproposals for a friendly dialect\u003c/a\u003e removing some of the more egregious examples, but ultimately they \u003ca href=\"https://blog.regehr.org/archives/1287\"\u003efailed\u003c/a\u003e, just not being able to get consensus from all the people involved. Compiler writers really like the freedom that aggressive undefined behavior gives them to optimize, and are reluctant to cede any ground that might impact performance. It’s entirely possible that future editions of C will revert some of the most egregious choices, but I suspect that the situation won’t change much.\u003c/p\u003e\n\n\u003cp\u003eOne of the reasons why undefined behavior is so insidious is that it’s so difficult to tell if a program exhibits it or not. It’s very common for it to lie dormant in a codebase for years, until a compiler upgrade triggers it. Fortunately, tools are emerging, for example the \u003ca href=\"https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html\"\u003eundefined behavior sanitizer\u003c/a\u003e from LLVM. Of course, such tools can only detect when a particular run of a program triggers undefined behavior; since so much of the problem is hard-to-trigger behavior from certain (malicious) inputs, these tools also work well in conjunction with fuzzers. Learning and setting up these tools is not easy, but it’s a necessary cost of writing software in C or C++ and having any hope of escaping the problems caused by undefined behavior.\u003c/p\u003e\n\n\u003cp\u003eA word of caution, however. As pointed out by \u003ca href=\"https://blog.regehr.org/archives/1520\"\u003eUndefined Behavior in 2017\u003c/a\u003e, these sanitizers only go so far. Follow that link to read lots more detail about how to mitigate undefined behavior in real systems.\u003c/p\u003e\n\n\u003cp\u003eCommenting on an earlier draft, Thomas Lord writes:\u003c/p\u003e\n\n\u003cblockquote\u003e\n  \u003cp\u003eI think probably many or most working programmers using C are probably doing it wrong. Not that there is only one true way — but.\u003c/p\u003e\n\n  \u003cp\u003eIf one’s interest is in safe, portable code – C can be a very fine choice. One must use it well, though. C should be regarded as a target language. I mean this more broadly than people usually do.\u003c/p\u003e\n\n  \u003cp\u003eC’s sharp edges can be managed safely two ways, at least:\u003c/p\u003e\n\n  \u003cp\u003eOne is through careful use of well-designed coding standards. Large program authors should make key architectural decisions very early on, define a safe, constrained, style – and have the team stick to that style.\u003c/p\u003e\n\n  \u003cp\u003eIn some situations, additionally: code generation tools are appropriate. Those can be hybrids that mix C fragments with other stuff (like lex and yacc) – or higher level languages entirely.\u003c/p\u003e\n\u003c/blockquote\u003e\n\n\u003ch2 id=\"a-problem-with-c-alone\"\u003eA problem with C alone?\u003c/h2\u003e\n\n\u003cp\u003eI’ve been focusing on C, but a good question is the degree to which undefined behavior affects other languages. Java, for example, almost completely avoids it (with the exception of JNI, about which more below). Rust has one of my favorite approaches: the safe dialect is free of undefined behavior, but using unsafe makes the language both potentially unsafe (and more expressive), at the cost of potential undefined behavior. There is a \u003ca href=\"https://www.ralfj.de/blog/2017/07/14/undefined-behavior.html\"\u003eproject underway\u003c/a\u003e to document the rules carefully so the careful programmer can have both.\u003c/p\u003e\n\n\u003cp\u003eMost other languages fall into what I call the “safe-ish” category. The most common compromise is that sequential code has little or no undefined behavior, but that data races can trigger it. It’s very hard to protect against those. Among other things, it used to be thought that data races could be classified into “benign” and dangerous categories, but \u003ca href=\"http://hboehm.info/boehm-hotpar11.pdf\"\u003eresearch\u003c/a\u003e strongly suggests that the former category doesn’t exist.\u003c/p\u003e\n\n\u003cp\u003ePerhaps the biggest persistent problem is that C underlies almost all runtimes (it’s possible to build a system based on some language other than C at the lowest levels, but it would be considered quite exotic), and that \u003ca href=\"https://en.wikipedia.org/wiki/Foreign_function_interface\"\u003eFFI\u003c/a\u003e is almost always needed to stitch these lower levels with higher level languages, even in cases where the higher level language is designed to be rigorously safe.\u003c/p\u003e\n\n\u003cp\u003eAlso note that “modern C++” when properly applied avoids many of the memory corruption issues common to C, but is still subject to integer overflow, as well as more subtle forms such as \u003ca href=\"https://stackoverflow.com/questions/6438086/iterator-invalidation-rules\"\u003eiterator invalidation\u003c/a\u003e. My personal feeling is that careful use of modern C++, and other efforts such as the \u003ca href=\"https://github.com/isocpp/CppCoreGuidelines\"\u003ecore guidelines\u003c/a\u003e, can reduce undefined behavior but can’t provide anywhere nearly the same guarantees as a truly safe language.\u003c/p\u003e\n\n\u003ch2 id=\"been-there-done-that-got-the-t-shirt\"\u003eBeen there, done that, got the t-shirt\u003c/h2\u003e\n\n\u003cp\u003eIf you’ve read this far, now I can reveal that the real point of this post is to flog my \u003ca href=\"https://teespring.com/undefined-behavior-shirt#pid=369\u0026amp;cid=6521\u0026amp;sid=front\"\u003eundefined behavior t-shirt\u003c/a\u003e, with the rainbow and unicorn artwork from the top of the page. It’s a good way to indicate to your friends and colleagues that you appreciate the finer points of undefined behavior, plus I’d like to think it’s colorful and fun. All profits go to Amnesty International.\u003c/p\u003e\n\n\u003ch2 id=\"further-reading\"\u003eFurther reading\u003c/h2\u003e\n\n\u003cul\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://www.ralfj.de/blog/2018/07/24/pointers-and-bytes.html\"\u003ePointers Are Complicated, or: What’s in a Byte?\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://blog.regehr.org/archives/213\"\u003eA Guide to Undefined Behavior in C and C++, Part 1\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://blog.regehr.org/archives/1180\"\u003eProposal for a Friendly Dialect of C\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://blog.regehr.org/archives/1287\"\u003eThe Problem with Friendly C\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"http://sf.snu.ac.kr/llvmtwin/\"\u003eReconciling High-level Optimizations and Low-level Code in LLVM\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n  \u003cli\u003e\n    \u003cp\u003e\u003ca href=\"https://queue.acm.org/detail.cfm?id=3212479\"\u003eC Is Not a Low-level Language\u003c/a\u003e\u003c/p\u003e\n  \u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch2 id=\"discuss\"\u003eDiscuss\u003c/h2\u003e\n\n\u003cp\u003eFollow the discussion threads on \u003ca href=\"https://lobste.rs/s/jrxhr5/with_undefined_behavior_anything_is\"\u003elobste.rs\u003c/a\u003e, \u003ca href=\"https://news.ycombinator.com/item?id=17785470\"\u003eHacker News\u003c/a\u003e, and \u003ca href=\"https://www.reddit.com/r/rust/comments/985id0/with_undefined_behavior_anything_is_possible/\"\u003e/r/rust\u003c/a\u003e.\u003c/p\u003e\n\n\u003ch2 id=\"artwork-credits\"\u003eArtwork credits\u003c/h2\u003e\n\n\u003cp\u003eTop image by \u003ca href=\"https://www.fiverr.com/dbeast32\"\u003edbeast32\u003c/a\u003e. Space unicorn most likely by \u003ca href=\"https://www.deviantart.com/cindarellapop/about\"\u003ecinderellapop\u003c/a\u003e, trying to get in touch with the artist for permission.\u003c/p\u003e\n\n  \u003c/div\u003e",
  "Date": "2018-08-17T18:51:03Z",
  "Author": "raphlinus"
}