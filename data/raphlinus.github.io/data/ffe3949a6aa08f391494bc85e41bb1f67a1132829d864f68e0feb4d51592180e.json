{
  "Source": "raphlinus.github.io",
  "Title": "Rust 2021: GUI",
  "Link": "https://raphlinus.github.io/rust/druid/2020/09/28/rust-2021.html",
  "Content": "\u003cdiv class=\"post-content e-content\" itemprop=\"articleBody\"\u003e\n    \u003cp\u003eThis is a response to the Rust \u003ca href=\"https://blog.rust-lang.org/2020/09/03/Planning-2021-Roadmap.html\"\u003ecall for blogs 2021\u003c/a\u003e and also a followup to \u003ca href=\"https://raphlinus.github.io/rust/druid/2019/10/31/rust-2020.html\"\u003elast year’s entry\u003c/a\u003e. It will be entirely focused on GUI.\u003c/p\u003e\n\n\u003cp\u003eThere is considerable interest in GUI toolkits for Rust. As one data point, it was the 6th highest rated challenge for adoption in the \u003ca href=\"https://blog.rust-lang.org/2020/04/17/Rust-survey-2019.html#rust-adoption---a-closer-look\"\u003e2019 Rust survey\u003c/a\u003e, just behind async I/O. There is also a fair amount of activity towards this goal, though as a community it still feels a bit unfocused. A characteristic sign is that a new GUI toolkit seems to pop up every couple of months or so.\u003c/p\u003e\n\n\u003cp\u003eI believe there is great potential for a high-quality GUI toolkit in Rust. At the same time, it’s an incredibly ambitious task. Subtasks within it, for example accelerated GPU drawing and text layout, are in and of themselves incredibly ambitious tasks. I wouldn’t consider a toolkit “ready” for production use until it supported accessibility, and as far as I know there is nothing in the Rust space even starting to work on this.\u003c/p\u003e\n\n\u003cp\u003eYet, perhaps against my better judgment, I find myself devoting most of my time and energy towards building GUI in Rust. In this post I will set out my hopes but also frankly discuss the challenges.\u003c/p\u003e\n\n\u003ch2 id=\"why-gui-in-rust\"\u003eWhy GUI in Rust?\u003c/h2\u003e\n\n\u003cp\u003eSimply put, I believe that the strengths of Rust translate well to writing GUI applications, and that the missing piece is the existence of a good toolkit. One strength is Rust’s wide “dynamic range” – the ability to describe application logic in high level terms while still being attentive to low level details. Another is \u003cem\u003estrong\u003c/em\u003e cross-platform compatibility. The increasingly rich crate ecosystem is compelling in many domains. And don’t lose sight of the importance of safety. In traditional object-oriented GUI in C++ especially, object lifetimes can be complicated, and it’s not hard to cause crashes, especially on takeoffs and landings.\u003c/p\u003e\n\n\u003cp\u003eI do pay attention to the competitive space, and one thing I see is Electron being used more and more, because it solves real problems. But I also believe that the success of Electron creates a real opportunity for a higher performance, lighter weight alternative. And in general for the projects I see in other languages, I find myself \u003cem\u003ewanting\u003c/em\u003e to compete against them.\u003c/p\u003e\n\n\u003ch2 id=\"about-druid\"\u003eAbout Druid\u003c/h2\u003e\n\n\u003cp\u003eThe \u003ca href=\"https://github.com/linebender/druid\"\u003eDruid\u003c/a\u003e toolkit has made impressive progress in the last year, but is still nowhere near stable or complete. If you are looking for a GUI toolkit to develop your application today, Druid is not it.\u003c/p\u003e\n\n\u003cp\u003eWe are developing the font editor \u003ca href=\"https://github.com/linebender/runebender\"\u003eRunebender\u003c/a\u003e as the primary motivating application, but, while a lot of pieces are in place, it is sadly not yet usable for day to day font creation work. One of my goals for the rest of the year is to start creating a font in it.\u003c/p\u003e\n\n\u003cp\u003eThat said, I am very proud of the work that’s been done in the last year. To hit on some of the highlights, we’re just landing basic but capable \u003ca href=\"https://www.cmyr.net/blog/piet-text-work.html\"\u003erich text layout\u003c/a\u003e. The keyboard event is close to browser quality (based on \u003ca href=\"https://crates.io/crates/keyboard-types\"\u003ekeyboard-types\u003c/a\u003e). There is incremental painting based on damage regions. Multi-window support is solid, with support for controlling window placement and dynamic hi-dpi. There is tab-focusing between text boxes. All of these are hard problems. Even more so, I am pleased that a lot of the work came from people in the community.\u003c/p\u003e\n\n\u003ch2 id=\"converging-a-vision\"\u003eConverging a vision\u003c/h2\u003e\n\n\u003cp\u003eImagine a thought experiment for a bit. Obviously Rust is promising for implementing async, but there isn’t a consensus on the best way to do it. Some people feel it should be done with callbacks, and invest considerable effort into overcoming the serious problems with that approach. Others feel it should be done with a polling future trait, but there are multiple versions of that trait: some get the context from thread local storage, others pass it into the poll method. And of course some people feel the syntax should be \u003ccode class=\"language-plaintext highlighter-rouge\"\u003efuture.await\u003c/code\u003e while others insist on \u003ccode class=\"language-plaintext highlighter-rouge\"\u003eawait!(future)\u003c/code\u003e. Every couple of months somebody pops up on /r/rust with a new crate that promises to solve “the async problem,” complete with a nice-looking echo server demo.\u003c/p\u003e\n\n\u003cp\u003eThat’s about where we are today with GUI toolkits. In many ways, I think converging on a single vision in GUI is a harder problem than for async. For one, people have different things they want to do. I’m personally most interested in things that resemble document editors. Others want 3D or video content. In the future, there might be commercial interest in enterprise line-of-business apps or interfaces for medical devices. These all have quite different requirements in the best ways to express UI logic, and how to build them. Not to mention the endless opportunities to bikeshed.\u003c/p\u003e\n\n\u003cp\u003eI am not (yet) proposing Druid as the singular vision that the Rust community should converge on. I’m enjoying reading codebases and learning from other Rust GUI projects. In particular, I’m finding lots to like about \u003ca href=\"https://github.com/hecrj/iced\"\u003eIced\u003c/a\u003e: it has good solutions to async, 3D graphics (through wgpu), being able to function in a guest window (important for VST plug-ins), among other problems. And I’m getting the sense that it’s easier for developers. The Elm-like reactive architecture maps nicely to Rust, and depending on exactly what you’re trying to do, it’s not hard to figure out how to express your app-specific logic. By contrast, Druid’s reactive model, while efficient and powerful in many ways, has complex concepts such as Haskell-like lenses, and places a burden on the developer to carefully design the “app data” to fit the Druid model. The \u003ca href=\"https://raphlinus.github.io/rust/druid/2020/09/25/principled-reactive-ui.html\"\u003eCrochet research prototype\u003c/a\u003e is an active exploration into making that simpler. I am thankful to Iced (and other toolkits) for being a model to study.\u003c/p\u003e\n\n\u003cp\u003eThe work to build consensus is complex and multifaceted, and it cannot be rushed. From my side, I hope to improve the designs and implementations to the point where they are compelling. I also hope to listen to criticisms, many of which are valid. I also think there is more work the community can be doing here. I’d love to see more active effort in trying to learn from the ongoing work and try to synthesize it. The GUI-related threads on /r/rust are sadly not a place where that happens; they most often consist of a statement of requirements (usually presented very informally), followed by a bit of bikeshedding. I don’t have a good answer for how to improve this situation, but put it out there as a problem I’m feeling.\u003c/p\u003e\n\n\u003cp\u003eWhile I think a converged vision is an admirable and ambitious goal, it may not be necessary for a successful GUI ecosystem in Rust. It’s possible that different types of GUI programs will simply require different infrastructure, so even in the long term it makes sense to have ecosystem diversity. Certainly that’s the case in the short and medium term as well, just to explore the space. And even without a grand unifying vision, there is lots of scope to work on infrastructural crates for important pieces of the GUI story, including text layout and related problems.\u003c/p\u003e\n\n\u003ch2 id=\"learning-and-community\"\u003eLearning and community\u003c/h2\u003e\n\n\u003cp\u003eMany Rust projects these days come with what’s basically a marketing pitch: “adopt this codebase, it’s awesome.” I am starting to see the Druid project in a somewhat different light. I consider its primary mission to be \u003cem\u003eteaching and learning\u003c/em\u003e the knowledge required to build GUI. To that extent, the community we’re building, hosted on \u003ca href=\"https://xi.zulipchat.com/\"\u003eour Zulip instance,\u003c/a\u003e is just as important as the code.\u003c/p\u003e\n\n\u003cp\u003eThe knowledge needed to build GUI has many aspects, and is at all levels. Some of it is at a high level, like the best way to express reactive UI. Some of it is at a low level, like the keyboard event processing. A common thread is that a lot of it is very arcane, not really written down properly anywhere. Fortunately, a lot of it is accessible through reading the code of other open source projects, whether in Rust or in other languages (I’ve found both Chromium and Gecko to be especially useful).\u003c/p\u003e\n\n\u003cp\u003eSo I consider this a goal, a success criterion, of the Druid project. If somebody wants to know how to solve a problem in GUI, the Druid codebase should be one of the best places to look for answers.\u003c/p\u003e\n\n\u003cp\u003eI love research more than most anything, and a lot of my own work has a strong research flavor. That has caused some confusion; some of the things I’m exploring are very speculative and will likely take years to come to fruition. Certainly my research into compute-centric GPU rendering is of that nature; I’m excited about the fact that it promises dramatic performance improvements over the current state of the art, but it’s nowhere near ready to put into production yet. I’m striving for clearer communication so people can have a better idea what is speculative, based on grand futuristic visions, and what is on track to being usable reasonably soon. But both are important aspects of what I consider to be the main mission: fostering learning about how to build GUI.\u003c/p\u003e\n\n\u003ch2 id=\"baby-steps\"\u003eBaby steps\u003c/h2\u003e\n\n\u003cp\u003eWhile I am driven by a long-term, ambitious vision, the goal of Druid in 2021 is not to deliver a general UI toolkit. Rather, we are deliberately continuing to follow a narrow scope. The primary goal remains the font editor project, and we plan to re-focus attention on that. I do think this is an attainable goal. I also think that what we learn from trying to build a real application with users will be extremely valuable to the more ambitious task.\u003c/p\u003e\n\n\u003cp\u003eOne project management technique that is proving effective is “cycles.” Instead of trying to solve the most ambitious version of a problem, we choose up front what to push to a future cycle, reducing the scope for the current implementation cycle. An example is the choice to defer BiDi from our recent text work. This is obviously an essential feature for a real GUI toolkit, but we also know it could take weeks or months to get it right. To have any chance of shipping, we have to carefully budget our time and energy on subprojects that easily could expand to absorb our full attention.\u003c/p\u003e\n\n\u003cp\u003eA common development pattern for a fledgling GUI toolkit is to have a “hero app” that drives development. It really helps clarify requirements, and also makes it easier to change things without having to worry as much about churn in the ecosystem. For Druid, that is the Runebender font editor. We want to increase our focus on that in coming months, and that is also reflected in our approach to community: we will happily mentor Druid features that fit on the Runebender roadmap. Other features that don’t massively stretch the scope can happen, but will really need to be driven by the people in the community. And we will push back against things that are off roadmap and require a huge amount of work, simply because our bandwidth for mentoring and review is finite. Even so, I remain impressed by the scope and quality of contributions from the community.\u003c/p\u003e\n\n\u003ch2 id=\"a-wishlist\"\u003eA wishlist\u003c/h2\u003e\n\n\u003cp\u003eHere are some things I’d especially like from the rest of the Rust community.\u003c/p\u003e\n\n\u003cp\u003eFirst, I’d love for wgpu to become more mature, as I think it is the most promising approach to GPU for the future. Our \u003ca href=\"https://github.com/linebender/druid/issues/891\"\u003eroadmap for 3D\u003c/a\u003e basically depends on it. Much love to that community for the progress they’ve made so far and hope for the future.\u003c/p\u003e\n\n\u003cp\u003eSecond, while we generally find Windows platform bindings to be straightforward, thanks to the excellent winapi bindings (and hopefully a stable \u003ca href=\"https://github.com/microsoft/com-rs\"\u003ecom-rs\u003c/a\u003e shortly), the situation on macOS is not as good. There are real problems interoperating with Objective-C code, including type-safety in wrappers that also allow subclassing, and continual friction around autorelease pools. There are also different, incompatible conventions around wrapping foreign types (foreign_object vs TCFType). None of this is blocking, but it makes developing macOS platform integration less fun. (See \u003ca href=\"https://news.ycombinator.com/item?id=24309565\"\u003ethis HN thread\u003c/a\u003e for a bit more background)\u003c/p\u003e\n\n\u003cp\u003eThird, some perhaps surprisingly good news. I prefer Rust crates when possible rather than relying on C++, but for OpenType font shaping, we would have to call into HarfBuzz. Now not one but two Rust solutions are on the horizon: \u003ca href=\"https://yeslogic.com/blog/allsorts-rust-font-shaping-engine.html\"\u003eAllsorts\u003c/a\u003e from YesLogic, and \u003ca href=\"https://github.com/RazrFalcon/rustybuzz\"\u003erustybuzz\u003c/a\u003e from RazrFalcon. Both are young, but I can see adopting them (primarily for use on Linux, which is still work in progress; on Windows and macOS we use the platform text layout capabilities). I know of no other language besides C++ that has working OpenType font shaping. Almost every language community has its own language-native GUI toolkit project, and most fall short. I do believe that Rust will be different, and seeing projects like this is to me evidence why.\u003c/p\u003e\n\n\u003cp\u003eFourth, if I could have one wishlist from the Rust language, it would be proper keyword arguments, as the builder pattern feels clunky, and the struct-with-default pattern is no better. But overall there’s a lot to be said for the language itself basically being stable, and the primary focus being on implementation, tools, and ecosystem.\u003c/p\u003e\n\n\u003ch2 id=\"to-2021\"\u003eTo 2021\u003c/h2\u003e\n\n\u003cp\u003eGUI is a hard problem, but the Rust community has a track record of solving hard problems, even if the journey is sometimes long. I find the progress so far impressive, both in Druid and other related projects.\u003c/p\u003e\n\n\u003cp\u003eIt is my sincere hope that 2021 will be a year of recovery from trauma, re-building what has been lost, and building new and better things. I’m looking forward to the work on Druid and Runebender, and walking with the Rust community on the journey, hopefully ultimately towards my most ambitious vision of what a high-performance, richly expressive GUI toolkit could look like.\u003c/p\u003e\n\n\u003cp\u003eWork on Druid and Runebender is generously funded by Google Fonts.\u003c/p\u003e\n\n\u003cp\u003eDiscuss on \u003ca href=\"https://news.ycombinator.com/item?id=24631611\"\u003eHacker News\u003c/a\u003e and \u003ca href=\"https://www.reddit.com/r/rust/comments/j24em4/rust_2021_gui/\"\u003e/r/rust\u003c/a\u003e.\u003c/p\u003e\n\n\n  \u003c/div\u003e",
  "Date": "2020-09-28T15:45:42Z",
  "Author": "raphlinus"
}