{
  "Source": "tech.meituan.com",
  "Title": "Android自定义Lint实践2——改进原生Detector",
  "Link": "https://tech.meituan.com/2017/03/09/android-custom-lint2.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e上篇博客\u003ca href=\"http://tech.meituan.com/android_custom_lint.html\"\u003e《Android自定义Lint实践》\u003c/a\u003e中我们介绍了美团App如何使用自定义Lint进行代码检查。\u003c/p\u003e\u003cp\u003e在使用Lint的过程中，我们陆续又发现原生Lint的一些问题和缺陷，本文将介绍我们在实践中提出的解决方案。\u003c/p\u003e\u003cp\u003e上一篇博客中我们提到了对于HashMap检测的改进，但当时我们也在文章中提到：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e代码很简单，总体就是获取变量定义的地方，将泛型值传入原先的检测逻辑。\n当然这里的增强也是有局限的，比如这个变量是成员变量，向前的推断就会有问题，这点我们还在持续的优化中。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e即：当时的检测解决了变量声明和变量赋值在一起的HashMap检测问题。但对于两者不在一起的情况，我们仍然无法检测到。\u003c/p\u003e\u003cp\u003e示例代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static void testHashMap() {\n\t//这种情况可以用上篇博客的检查搞定\n    Map\u0026lt;Integer, String\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;();\n    map1.put(1, \u0026#34;name\u0026#34;);\n    //这种找不到map2的变量声明，所以用上篇博客的检查是无法判断的\n    map2 = new HashMap\u0026lt;\u0026gt;();\n    map2.put(2, \u0026#34;name2\u0026#34;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过我们的探索，目前已经解决了这个问题。\u003c/p\u003e\u003cp\u003e下面我们来详细介绍下：\u003c/p\u003e\u003ch2 id=\"我们需要解决的情况\"\u003e我们需要解决的情况\u003c/h2\u003e\u003col\u003e\u003cli\u003e在同一个类中\n\u003ccode\u003ejava\npublic Map\u0026lt;Integer, String\u0026gt; map;\npublic static Map\u0026lt;Integer, String\u0026gt; map2;\npublic void test() {\n// 1: 成员变量\nmap = new HashMap\u0026lt;\u0026gt;();\nmap.put(1, \u0026#34;name\u0026#34;);\n// 2: 静态变量\nmap2 = new HashMap\u0026lt;\u0026gt;();\nmap2.put(1, \u0026#34;name\u0026#34;);\n}\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e方法参数\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void test1(Map\u0026lt;Integer, String\u0026gt; map) {\n    map = new HashMap\u0026lt;\u0026gt;();\n    map.put(1, \u0026#34;name\u0026#34;);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e变量声明在另一个类中\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class HashMapCase4_2 {\n    public void test() {\n        // 1: 另一个类的静态变量\n        HashMapCase4_1.map2 = new HashMap\u0026lt;\u0026gt;();\n        HashMapCase4_1.map2.put(1, \u0026#34;name\u0026#34;);\n        // 2: 另一个对象的成员变量\n        HashMapCase4_1 case4_1 = new HashMapCase4_1();\n        case4_1.map = new HashMap\u0026lt;\u0026gt;();\n        case4_1.map.put(1, \u0026#34;name\u0026#34;);\n        // 3: 内部类静态变量\n        Sub.map2 = new HashMap\u0026lt;\u0026gt;();\n        // 4: 内部类对象的成员变量\n        Sub sub = new Sub();\n        sub.map = new HashMap\u0026lt;\u0026gt;();\n    }\n    private static class Sub {\n        public Map\u0026lt;Integer, String\u0026gt; map;\n        public static Map\u0026lt;Integer, String\u0026gt; map2;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"解决方案\"\u003e解决方案\u003c/h2\u003e\u003cp\u003e在Google官方提供的资料：\u003ca href=\"http://tools.android.com/tips/lint/writing-a-lint-check\"\u003eWriting a Lint Check\u003c/a\u003e中我们发现了如下描述：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eIn the next version of lint (Tools 27, Gradle plugin 0.9.2+, Android Studio 0.5.3, and ADT 27); Java AST parse tree detectors can both resolve types and declarations. This was just \u003ca href=\"https://android-review.googlesource.com/#/c/87946/\"\u003eadded\u003c/a\u003e to lint, and offers new APIs where you can ask for the resolved type, and the resolved declaration, of a given AST node.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e这里提到了resolved type，那究竟有什么用呢？\u003c/p\u003e\u003cp\u003eGoogle在描述中留下当时的\u003ca href=\"https://android-review.googlesource.com/#/c/87946/\"\u003ecommit\u003c/a\u003e，其中提到：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eAdd type and declaration resolution to Lint’s Java AST\u003c/p\u003e\u003cp\u003eThe AST used by lint, Lombok AST, does not contain type information.\nThat means code which for example sees this code:\u003c/p\u003e\u003cp\u003egetContext().checkPermission(name)\u003c/p\u003e\u003cp\u003ecan’t find out which “checkPermission” method this is. That requires\nfull type resolution.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e根据官方描述，我们可以拿到方法属于哪个类。那resolved type是否可以帮助我们通过变量拿到变量声明呢？\u003c/p\u003e\u003cp\u003e在参考了commit中的代码后，我们尝试使用\u003ccode\u003econtext.resolve\u003c/code\u003e来解析第一种情况中的变量\u003ccode\u003emap\u003c/code\u003e：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/c4ed3b14.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e结果证实确实帮我们解析到了变量声明的类型。\u003c/p\u003e\u003cp\u003e但它可以帮我们把所有情况都分析到么？我们带着怀疑的态度继续尝试，结果发现在第三种情况的\u003ccode\u003ecase4_1.map\u003c/code\u003e和\u003ccode\u003esub.map\u003c/code\u003e出现了问题：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/d40983b8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e即只分析到了\u003ccode\u003emap\u003c/code\u003e所属的对象，而无法拿到\u003ccode\u003emap\u003c/code\u003e的类型。\u003c/p\u003e\u003cp\u003e显然，这个解析出来的节点不仅没有帮助我们，反而让我们偏离了我们要分析的节点。\u003c/p\u003e\u003cp\u003e在查看\u003ca href=\"https://android.googlesource.com/platform/tools/base/+/master/lint/libs/lint-api/src/main/java/com/android/tools/lint/detector/api/JavaContext.java\"\u003eJavaContext\u003c/a\u003e相关代码后我们发现，除了\u003ccode\u003eresolve\u003c/code\u003e还有一个\u003ccode\u003egetType\u003c/code\u003e方法，似乎从名字上看可以解决我们的问题。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e@Nullable\npublic ResolvedNode resolve(@NonNull Node node) {\n    return mParser.resolve(this, node);\n}\n@Nullable\npublic TypeDescriptor getType(@NonNull Node node) {\n    return mParser.getType(this, node);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e尝试后发现，\u003ccode\u003egetType\u003c/code\u003e适合我们列出的所有情况。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/52fd89e2.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e那么，两者区别是什么呢？\u003c/p\u003e\u003cp\u003e通过对Android Gradle Plugin（下文中称Plugin）中Lint相关代码的分析，我们发现：\u003cbr/\u003e在Plugin中，Lint检查依靠ECJ（Eclipse Compiler for Java）来生成抽象语法树，上文代码中提到的\u003ccode\u003emParser\u003c/code\u003e在Plugin中对应的是\u003ccode\u003eEcjParser\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e解析时，对于\u003ccode\u003ecase4_1.map\u003c/code\u003e和\u003ccode\u003esub.map\u003c/code\u003e两个节点，\u003ccode\u003eresolve\u003c/code\u003e利用的是\u003ccode\u003ebinding\u003c/code\u003e，而\u003ccode\u003egetType\u003c/code\u003e调用的是\u003ccode\u003eresolvedType\u003c/code\u003e（注意：这里的\u003ccode\u003eresolvedType\u003c/code\u003e是ECJ中的变量）。\u003c/p\u003e\u003cp\u003e\u003ca href=\"http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST#sec-bindings\"\u003eBindings\u003c/a\u003e是ECJ一个强大的功能，有很多子类型，例如\u003ccode\u003eVariableBinding\u003c/code\u003e、\u003ccode\u003eTypeBinding\u003c/code\u003e等。\u003c/p\u003e\u003cp\u003e对于同一个节点可能还有多个binding（例如\u003ccode\u003eQualifiedNameReference\u003c/code\u003e的\u003ccode\u003eotherBindings\u003c/code\u003e会存放多个，上述例子中可以看到其实有\u003ccode\u003ecase4_1.map\u003c/code\u003e中\u003ccode\u003emap\u003c/code\u003e类型，但在\u003ccode\u003eotherBindings\u003c/code\u003e中)；而\u003ccode\u003eresolvedType\u003c/code\u003e是\u003ccode\u003eTypeBinding\u003c/code\u003e。显然，使用\u003ccode\u003eresolvedType\u003c/code\u003e可以确保我们拿到的是类型。\u003c/p\u003e\u003cp\u003e这里还需要注意的是：虽然上述分析中，我们提到的这些是由ECJ提供的，且Lint中的Node也保留了拿到ECJ Node的能力，即：\u003ca href=\"https://github.com/tnorbye/lombok.ast/blob/master/src/main/lombok/ast/Node.java#L104\"\u003egetNativeNode\u003c/a\u003e。但并不推荐大家直接使用ECJ。\u003c/p\u003e\u003cp\u003e因为Lint使用\u003ca href=\"https://github.com/tnorbye/lombok.ast\"\u003etnorbye/lombok.ast\u003c/a\u003e的本意就是不依赖具体的Parser（\u003ca href=\"http://tools.android.com/tips/lint/writing-a-lint-check\"\u003eWriting a Lint Check\u003c/a\u003e中提到，他们曾经使用了多种parser)，上层Detector应尽量使用Lombok AST。\u003c/p\u003e\u003cp\u003e美团App使用了Retrolambda，当然为了在Retrolambda下Lint能正常运行，我们引入了\u003ca href=\"https://github.com/evant/android-retrolambda-lombok\"\u003eevant/android-retrolambda-lombok\u003c/a\u003e，替换官方AST（抽象语法树）为Retrolambda实现的AST。\u003c/p\u003e\u003cp\u003e但在lambda中写Toast经常会提示没有show， 示例如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void test() {\n\tfindViewById(R.id.button).setOnClickListener(view -\u0026gt; Toast.makeText(MainActivity.this, \u0026#34;xxx\u0026#34;, Toast.LENGTH_SHORT).show());\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eLint检查报告：\u003ccode\u003eToast created but not shown: did you forget to call show() ?\u003c/code\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/f3d8591f.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从代码可以看到，虽然我们写了show，但还是检测说没有show。\u003c/p\u003e\u003cp\u003e这时候如果把Toast相关的代码抽离成单独的方法，检测就又会恢复正常。于是我们决定分析下究竟发生了什么？\u003c/p\u003e\u003cp\u003e通过gradle debug，我们发现ToastDetector在寻找包围Toast方法时出现了问题。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eNode method1 = JavaContext.findSurroundingMethod(node.getParent());\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而findSurroundingMethod方法的实现如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Nullable\npublic static Node findSurroundingMethod(Node scope) {\n    while (scope != null) {\n        Class\u0026lt;? extends Node\u0026gt; type = scope.getClass();\n        // The Lombok AST uses a flat hierarchy of node type implementation classes\n        // so no need to do instanceof stuff here.\n        if (type == MethodDeclaration.class || type == ConstructorDeclaration.class) {\n            return scope;\n        }\n        scope = scope.getParent();\n    }\n    return null;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e到这里总结一下：\u003cbr/\u003e当ToastDetector找到Toast的时候，它会寻找外围的方法，如果是匿名内部类的方法或者其他方法时，他能够判断到并返回这个节点。\u003c/p\u003e\u003cp\u003e但是对于lambda来说，它只能查找到最外层的方法，也就是示例中\u003ccode\u003esetOnClickListener\u003c/code\u003e外围的\u003ccode\u003etest\u003c/code\u003e方法，lambda并不会被识别到。\u003c/p\u003e\u003cp\u003elambda在语句附近能识别到的是\u003ccode\u003elombok.ast.LambdaExpression\u003c/code\u003e，而不是\u003ccode\u003eMethodDeclaration\u003c/code\u003e或者\u003ccode\u003eConstructorDeclaration\u003c/code\u003e，所以会一直找到\u003ccode\u003etest\u003c/code\u003e这个\u003ccode\u003eMethodDeclaration\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e问题搞清楚了，解决办法也就有了：\u003cbr/\u003e我们加入一个\u003ccode\u003eLambdaExpression\u003c/code\u003e判断，提前返回，这样就可以正常识别了。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static boolean isLambdaExpression(Class type) {\n    return \u0026#34;lombok.ast.LambdaExpression\u0026#34;.equals(type.getName());\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里需要说明的是，我们用字符串比对而不是跟\u003ccode\u003eMethodDeclaration\u003c/code\u003e一样去比对class，这是为了更好的兼容所有使用者。\u003c/p\u003e\u003cp\u003e因为\u003ccode\u003eLambdaExpression\u003c/code\u003e是由Retrolambda的AST提供，并不是官方的AST。也就是说如果我们想判断class就必须依赖Retrolambda的AST，我们之前也提到过自定义Lint输出的是一个JAR，并不包含这些依赖，运行时环境中如果没有使用Retrolambda AST的话就会直接ClassNotFound。\u003c/p\u003e\u003cp\u003e所以，这里我们选择了字符串比对，达成目标的同时，也让检测变得更简单。\u003c/p\u003e\u003cp\u003eDetector写好了，但是与HashMap的增强不同，ToastDetector这个实现只能选择替换掉系统实现。因为HashMap两者是增强，可以共存；而ToastDetector如果系统检测正常运行的话，遇到这种情况就会报错。所以我们反射修改内置IssueRegistry（\u003ccode\u003eBuiltinIssueRegistry\u003c/code\u003e) 完成系统Detector的替换。\u003c/p\u003e\u003cp\u003e本文相关示例源码已经开放，见：\u003ca href=\"https://github.com/GavinCT/MeituanLintDemo\"\u003eMeituanLintDemo\u003c/a\u003e。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"http://tools.android.com/tips/lint/writing-a-lint-check\"\u003eWriting a Lint Check\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/eclipse/eclipse.jdt.core\"\u003eeclipse.jdt.core\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://www.eclipse.org/articles/Article-JavaCodeManipulation_AST\"\u003eAbstract Syntax Tree\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/rzwitserloot/lombok.ast\"\u003erzwitserloot/lombok.ast\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/tnorbye/lombok.ast\"\u003etnorbye/lombok.ast\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/evant/android-retrolambda-lombok\"\u003eevant/android-retrolambda-lombok\u003c/a\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e陈潼，美团Android高级工程师，效力于美团平台技术部。2015年加入美团，先后负责代码静态检查、网络层优化等基础设施开发工作。\u003c/p\u003e\u003cp\u003e美团平台技术部客户端技术团队，负责美团平台的基础业务和移动基础设施的开发工作。基于海量用户的美团平台，支撑了美团多条业务线的快速发展。同时，我们也在移动开发技术方面做了一些积极的探索，在动态化、质量保障、开发模型等方面有一定积累。客户端技术团队积极采用开源技术的同时，也把我们的一些积累回馈给开源社区，希望跟业界一起推动移动开发效率、质量的提升。\u003c/p\u003e\u003cp\u003e最后来个硬广告：客户端技术团队长期招聘\u003ca href=\"http://zhaopin.meituan.com/index/search/Android%E6%8A%80%E6%9C%AF%E4%B8%93%E5%AE%B6LYYYL#/search/8305/jobDetail\"\u003e技术专家\u003c/a\u003e，有兴趣的同学可以发送简历到：fangjintao#meituan.com。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-03-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}