{
  "Source": "tech.meituan.com",
  "Title": "Jenkins的Pipeline脚本在美团餐饮SaaS中的实践",
  "Link": "https://tech.meituan.com/2018/08/02/erp-cd-jenkins-pipeline.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"一-背景\"\u003e一、背景\u003c/h2\u003e\u003cp\u003e在日常开发中，我们经常会有发布需求，而且还会遇到各种环境，比如：线上环境（Online），模拟环境（Staging），开发环境（Dev）等。最简单的就是手动构建、上传服务器，但这种方式太过于繁琐，使用持续集成可以完美地解决这个问题，推荐了解一下\u003ca href=\"https://jenkins.io/\"\u003eJenkins\u003c/a\u003e。\u003c/p\u003e\u003cp\u003eJenkins构建也有很多种方式，现在使用比较多的是自由风格的软件项目（Jenkins构建的一种方式，会结合SCM和构建系统来构建你的项目，甚至可以构建软件以外的系统）的方式。针对单个项目的简单构建，这种方式已经足够了，但是针对多个类似且又存在差异的项目，就难以满足要求，否则就需要大量的job来支持，这就存在，一个小的变动，就需要修改很多个job的情况，难以维护。我们团队之前就存在这样的问题。\u003c/p\u003e\u003cp\u003e目前，我们团队主要负责开发和维护多个Android项目，而且每个项目都需要构建，每个构建流程非常类似但又存在一定的差异。比如构建的流程大概如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e克隆代码；\u003c/li\u003e\u003cli\u003e静态代码检查（可选）；\u003c/li\u003e\u003cli\u003e单元测试（可选）；\u003c/li\u003e\u003cli\u003e编译打包APK或者热补丁；\u003c/li\u003e\u003cli\u003eAPK分析，获取版本号（VersionCode），包的Hash值（apkhash）等；\u003c/li\u003e\u003cli\u003e加固；\u003c/li\u003e\u003cli\u003e上传测试分发平台；\u003c/li\u003e\u003cli\u003e存档（可选）；\u003c/li\u003e\u003cli\u003e触发自动化测试（可选）；\u003c/li\u003e\u003cli\u003e通知负责人构建结果等。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e整个流程大体上是相同的，但是又存在一些差异。比如有的构建可以没有单元测试，有的构建不用触发自动化测试，而且构建结果通知的负责人也不同。如果使用自由风格软件项目的普通构建，每个项目都要建立一个job来处理流程（可能会调用其他job）。\u003c/p\u003e\u003cp\u003e这种处理方式原本也是可以的，但是必须考虑到，可能会有新的流程接入（比如二次签名），构建流程也可能存在Bug等多种问题。无论哪种情况，一旦修改主构建流程，每个项目的job都需要修改和测试，就必然会浪费大量的时间。针对这种情况，我们使用了Pipeline的构建方式来解决。\u003c/p\u003e\u003cp\u003e当然，如果有项目集成了React Native，还需要构建JsBundle。在Native修改以后，JsBundle不一定会有更新，如果是构建Native的时候一起构建JsBundle，就会造成很多资源浪费。并且直接把JsBundle这类大文件放在Native的Git仓库里，也不是特别合适。\u003c/p\u003e\u003cp\u003e本文是分享一种\u003ccode\u003ePipeline\u003c/code\u003e的使用经验，来解决这类问题。\u003c/p\u003e\u003ch2 id=\"二-pipeline的介绍\"\u003e二、Pipeline的介绍\u003c/h2\u003e\u003cp\u003ePipeline也就是构建流水线，对于程序员来说，最好的解释是：使用代码来控制项目的构建、测试、部署等。使用它的好处有很多，包括但不限于：\n- 使用Pipeline可以非常灵活的控制整个构建过程；\n- 可以清楚的知道每个构建阶段使用的时间，方便构建的优化；\n- 构建出错，使用stageView可以快速定位出错的阶段；\n- 一个job可以搞定整个构建，方便管理和维护等。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStage View\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/fa2fc49c.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"三-使用pipeline构建\"\u003e三、使用Pipeline构建\u003c/h2\u003e\u003cp\u003e新建一个Pipeline项目，写入Pipeline的构建脚本，就像下面这样:\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ffa5b7d5.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e对于单个项目来说，使用这样的Pipeline来构建能够满足绝大部分需求，但是这样做也有很多缺陷，包括：\u003c/p\u003e\u003cul\u003e\u003cli\u003e多个项目的Pipeline打包脚本不能公用，导致一个项目写一份脚本，维护比较麻烦。一个变动，需要修改多个job的脚本；\u003c/li\u003e\u003cli\u003e多个人维护构建job的时候，可能会覆盖彼此的代码；\u003c/li\u003e\u003cli\u003e修改脚本失败以后，无法回滚到上个版本；\u003c/li\u003e\u003cli\u003e无法进行构建脚本的版本管理，老版本发修复版本需要构建，可能和现在用的job版本已经不一样了，等等。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"四-把pipeline当代码写\"\u003e四、把Pipeline当代码写\u003c/h2\u003e\u003cp\u003e既然存在缺陷，我们就要找更好的方式，其实Jenkins提供了一个更优雅的管理Pipeline脚本的方式，在配置项目Pipeline的时候，选择\u003ccode\u003ePipeline script from SCM\u003c/code\u003e，就像下面这样：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7ebaa8c8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这样，Jenkins在启动job的时候，首先会去仓库里面拉取脚本，然后再运行这个脚本。在脚本里面，我们规定的构建方式和流程，就会按部就班地执行。构建的脚本，可以实现多人维护，还可以Review，避免出错。\u003c/p\u003e\u003cp\u003e以上就算搭建好了一个基础，而针对多个项目时，还有一些事情要做，不可能完全一样，以下是构建的结构图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cdee26c3.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如此以来，我们的构建数据来源分为三部分：job UI界面、仓库的通用Pipeline脚本、项目下的特殊配置，我们分别来看一下。\u003c/p\u003e\u003ch3 id=\"job-ui界面-参数化构建\"\u003ejob UI界面（参数化构建）\u003c/h3\u003e\u003cp\u003e在配置job的时候，选择参数化构建过程，传入项目仓库地址、分支、构建通知人等等。还可以增加更多的参数 ，这些参数的特点是，可能需要经常修改，比如灵活选择构建的代码分支。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/464279c5.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"项目配置\"\u003e项目配置\u003c/h3\u003e\u003cp\u003e在项目工程里面，放入针对这个项目的配置，一般是一个项目固定，不经常修改的参数，比如项目名字，如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/189fd525.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"注入构建信息\"\u003e注入构建信息\u003c/h3\u003e\u003cp\u003eQA提一个Bug，我们需要确定，这是哪次的构建，或者要知道commitId，从而方便进行定位。因此在构建时，可以把构建信息注入到APK之中。\u003c/p\u003e\u003col\u003e\u003cli\u003e把属性注入到\u003ccode\u003egradle.properties\u003c/code\u003e\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e# 应用的后端环境\nAPP_ENV=Beta\n# CI 打包的编号，方便确定测试的版本，不通过 CI 打包，默认是 0\nCI_BUILD_NUMBER=0\n# CI 打包的时间，方便确定测试的版本，不通过 CI 打包，默认是 0\nCI_BUILD_TIMESTAMP=0\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\u003cli\u003e在build.gradle里设置buildConfigField\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e#使用的是gradle.properties里面注入的值\nbuildConfigField \u0026#34;String\u0026#34;, \u0026#34;APP_ENV\u0026#34;, \u0026#34;\\\u0026#34;${APP_ENV}\\\u0026#34;\u0026#34;\nbuildConfigField \u0026#34;String\u0026#34;, \u0026#34;CI_BUILD_NUMBER\u0026#34;, \u0026#34;\\\u0026#34;${CI_BUILD_NUMBER}\\\u0026#34;\u0026#34;\nbuildConfigField \u0026#34;String\u0026#34;, \u0026#34;CI_BUILD_TIMESTAMP\u0026#34;, \u0026#34;\\\u0026#34;${CI_BUILD_TIMESTAMP}\\\u0026#34;\u0026#34;\nbuildConfigField \u0026#34;String\u0026#34;, \u0026#34;GIT_COMMIT_ID\u0026#34;, \u0026#34;\\\u0026#34;${getCommitId()}\\\u0026#34;\u0026#34;\n\n//获取当前Git commitId\nString getCommitId() {\n    try {\n        def commitId = \u0026#39;git rev-parse HEAD\u0026#39;.execute().text.trim()\n        return commitId;\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\u003cli\u003e显示构建信息\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e在App里，找个合适的位置，比如开发者选项里面，把刚才的信息显示出来。QA提Bug时，要求他们把这个信息一起带上\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003emCIIdtv.setText(String.format(\u0026#34;CI 构建号:%s\u0026#34;, BuildConfig.CI_BUILD_NUMBER));\nmCITimetv.setText(String.format(\u0026#34;CI 构建时间:%s\u0026#34;, BuildConfig.CI_BUILD_TIMESTAMP));\nmCommitIdtv.setText(String.format(\u0026#34;Git CommitId:%s\u0026#34;, BuildConfig.GIT_COMMIT_ID));\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"仓库的通用pipeline脚本\"\u003e仓库的通用Pipeline脚本\u003c/h3\u003e\u003cp\u003e通用脚本是抽象出来的构建过程，遇到和项目有关的都需要定义成变量，再从变量里进行读取，不要在通用脚本里写死。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e\nnode {\n\ttry{\n\t\tstage(\u0026#39;检出代码\u0026#39;){//从git仓库中检出代码\n\t    \tgit branch: \u0026#34;${BRANCH}\u0026#34;,credentialsId: \u0026#39;xxxxx-xxxx-xxxx-xxxx-xxxxxxx\u0026#39;, url: \u0026#34;${REPO_URL}\u0026#34;\n\t       \tloadProjectConfig();\n\t  \t}\n\t   \tstage(\u0026#39;编译\u0026#39;){\n\t   \t\t//这里是构建，你可以调用job入参或者项目配置的参数，比如：\n\t   \t\techo \u0026#34;项目名字 ${APP_CHINESE_NAME}\u0026#34;\n\t   \t\t//可以判断\n\t   \t\tif (Boolean.valueOf(\u0026#34;${IS_USE_CODE_CHECK}\u0026#34;)) {\n\t   \t\t\techo \u0026#34;需要静态代码检查\u0026#34;\n\t   \t\t} else {\n\t   \t\t\techo \u0026#34;不需要静态代码检查\u0026#34;\n\t   \t\t}\n\n\t   \t}\n\t   \tstage(\u0026#39;存档\u0026#39;){//这个演示的Android的项目，实际使用中，请根据自己的产物确定\n\t       \tdef apk = getShEchoResult (\u0026#34;find ./lineup/build/outputs/apk -name \u0026#39;*.apk\u0026#39;\u0026#34;)\n\t       \tdef artifactsDir=\u0026#34;artifacts\u0026#34;//存放产物的文件夹\n\t        sh \u0026#34;mkdir ${artifactsDir}\u0026#34;\n\t       \tsh \u0026#34;mv ${apk} ${artifactsDir}\u0026#34;\n\t       \tarchiveArtifacts \u0026#34;${artifactsDir}/*\u0026#34;\n\t   \t}\n\t   \tstage(\u0026#39;通知负责人\u0026#39;){\n\t   \t\temailext body: \u0026#34;构建项目:${BUILD_URL}\\r\\n构建完成\u0026#34;, subject: \u0026#39;构建结果通知【成功】\u0026#39;, to: \u0026#34;${EMAIL}\u0026#34;\n\t   \t}\n\t} catch (e) {\n\t\temailext body: \u0026#34;构建项目:${BUILD_URL}\\r\\n构建失败，\\r\\n错误消息：${e.toString()}\u0026#34;, subject: \u0026#39;构建结果通知【失败】\u0026#39;, to: \u0026#34;${EMAIL}\u0026#34;\n\t} finally{\n\t\t// 清空工作空间\n        cleanWs notFailBuild: true\n\t}\n   \t\n   \n}\n \n// 获取 shell 命令输出内容\ndef getShEchoResult(cmd) {\n    def getShEchoResultCmd = \u0026#34;ECHO_RESULT=`${cmd}`\\necho \\${ECHO_RESULT}\u0026#34;\n    return sh (\n        script: getShEchoResultCmd,\n        returnStdout: true\n    ).trim()\n}\n\n//加载项目里面的配置文件\ndef loadProjectConfig(){\n    def jenkinsConfigFile=\u0026#34;./jenkins.groovy\u0026#34;\n    if (fileExists(\u0026#34;${jenkinsConfigFile}\u0026#34;)) {\n        load \u0026#34;${jenkinsConfigFile}\u0026#34;\n        echo \u0026#34;找到打包参数文件${jenkinsConfigFile}，加载成功\u0026#34;\n    } else {\n        echo \u0026#34;${jenkinsConfigFile}不存在,请在项目${jenkinsConfigFile}里面配置打包参数\u0026#34;\n        sh \u0026#34;exit 1\u0026#34;\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e轻轻的点两下\u003ccode\u003eBuild with Parameters\u003c/code\u003e -\u0026gt; \u003ccode\u003e开始构建\u003c/code\u003e，然后等几分钟的时间，就能够收到邮件。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5bd101bf.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"五-其他构建结构\"\u003e五、其他构建结构\u003c/h2\u003e\u003cp\u003e以上，仅仅是针对我们当前遇到问题的一种不错的解决方案，可能并不完全适用于所有场景，但是可以根据上面的结构进行调整，比如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e根据stage拆分出不同的Pipeline脚本，这样方便CI的维护，一个或者几个人维护构建中的一个stage；\u003c/li\u003e\u003cli\u003e把构建过程中的stage做成普通的\u003ccode\u003e自由风格的软件项目\u003c/code\u003e的job，把它们作为基础服务，在Pipeline中调用这些基础服务等。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"六-当遇上react-native\"\u003e六、当遇上React Native\u003c/h2\u003e\u003cp\u003e当项目引入了React Native以后，因为技术栈的原因，React Native的页面是由前端团队开发，但容器和原生组件是Android团队维护，构建流程也发生了一些变化。\u003c/p\u003e\u003ch3 id=\"方案对比\"\u003e方案对比\u003c/h3\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003e方案\u003c/th\u003e\u003cth align=\"left\"\u003e说明\u003c/th\u003e\u003cth align=\"left\"\u003e缺点\u003c/th\u003e\u003cth align=\"left\"\u003e优点\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e手动拷贝\u003c/td\u003e\u003ctd align=\"left\"\u003e等JsBundle构建好了，再手动把构建完成的产物，拷贝到Native工程里面\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 每次手动操作，比较麻烦，效率低，容易出错\u003cbr/\u003e2. 涉及到跨端合作，每次要去前端团队主动拿JsBundle\u003cbr/\u003e3. Git不适合管理大文件和二进制文件\u003c/td\u003e\u003ctd align=\"left\"\u003e简单粗暴\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e使用submodule保存构建好的JsBundle\u003c/td\u003e\u003ctd align=\"left\"\u003e直接把JsBundle放在Native仓库的一个submodule里面，由前端团队主动更新，每次更新Native的时候，直接就拿到了最新的JsBundle\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 简单无开发成本\u003cbr/\u003e2. 不方便单独控制JsBundle的版本\u003cbr/\u003e3. Git不适合管理大文件和二进制文件\u003c/td\u003e\u003ctd align=\"left\"\u003e前端团队可以主动更新JsBundle\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e使用submodule管理JsBundle的源码\u003c/td\u003e\u003ctd align=\"left\"\u003e直接把JsBundle的源码放在Native仓库的一个submodule里面，由前端团队开发更新，每次构建Native的时候，先构构建JsBundle\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 不方便单独控制JsBundle的版本\u003cbr/\u003e2. 即使JsBundle无更新，也需要构建，构建速度慢，浪费资源\u003c/td\u003e\u003ctd align=\"left\"\u003e方便灵活\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e分开构建，产物存档\u003c/td\u003e\u003ctd align=\"left\"\u003eJsBundle和Native分开构建，构建完了的JsBundle分版本存档，Native构建的时候，直接去下载构建好了的JsBundle版本\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 通过配置管理JsBundle，解放Git\u003cbr/\u003e2. 方便Jenkins构建的时候，动态配置需要的JsBundle版本\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 需要花费时间建立流程\u003cbr/\u003e2. 需要开发Gradle的JsBundle下载插件\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e前端团队开发页面，构建后生成JsBundle，Android团队拿到前端构建的JsBundle，一起打包生成最终的产物。 在我们开发过程中，JsBundle修改以后，不一定需要修改Native，Native构建的时候，也不一定每次都需要重新构建JsBundle。并且这两个部分由两个团队负责，各自独立发版，构建的时候也应该独立构建，不应该融合到一起。\u003c/p\u003e\u003cp\u003e综合对比，我们选择了使用分开构建的方式来实现。\u003c/p\u003e\u003ch3 id=\"分开构建\"\u003e分开构建\u003c/h3\u003e\u003cp\u003e因为需要分开发布版本，所以JsBundle的构建和Native的构建要分开，使用两个不同的job来完成，这样也方便两个团队自行操作，避免相互影响。 JsBundle的构建，也可以参考上文提到的Pipeline的构建方式来做，这里不再赘述。\u003c/p\u003e\u003cp\u003e在独立构建以后，怎么才能组合到一起呢？我们是这样思考的：JsBundle构建以后，分版本的储存在一个地方，供Native在构建时下载需要版本的JsBundle，大致的流程如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/1211a071.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这个流程有两个核心，一个是构建的JsBundle归档存储，一个是在Native构建时去下载。\u003c/p\u003e\u003ch3 id=\"jsbundle归档存储\"\u003eJsBundle归档存储\u003c/h3\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003e方案\u003c/th\u003e\u003cth align=\"left\"\u003e缺点\u003c/th\u003e\u003cth align=\"left\"\u003e优点\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e直接存档在Jenkins上面\u003c/td\u003e\u003ctd align=\"left\"\u003e1. JsBundle不能汇总浏览\u003cbr/\u003e2. Jenkins很多人可能要下载，命名带有版本号，时间，分支等，命名不统一，不方便构建下载地址\u003cbr/\u003e3. 下载Jenkins上面的产物需要登陆授权，比较麻烦\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 实现简单，一句代码就搞定，成本低\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e自己构建一个存储服务\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 工程大，开发成本高\u003cbr/\u003e2. 维护起来麻烦\u003c/td\u003e\u003ctd align=\"left\"\u003e可扩展，灵活性高\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eMSS\u003cbr/\u003e(美团存储服务)\u003c/td\u003e\u003ctd align=\"left\"\u003e无\u003c/td\u003e\u003ctd align=\"left\"\u003e1. 储存空间大\u003cbr/\u003e2. 可靠性高，配合CDN下载速度快\u003cbr/\u003e3. 维护成本低， 价格便宜\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e这里我们选择了MSS。 上传文件到MSS，可以使用\u003ccode\u003es3cmd\u003c/code\u003e，但毕竟不是每个Slave上面都有安装，通用性不强。为了保证稳定可靠，这里基于\u003ca href=\"https://github.com/meituan/mssapi_java\"\u003eMSS的SDK\u003c/a\u003e写个小工具即可，比较简单，几行代码就可以搞定：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static String TenantId = \u0026#34;mss_TenantId==\u0026#34;;\nprivate static AmazonS3 s3Client;\n\npublic static void main(String[] args) throws IOException {\n\tif (args == null || args.length != 3) {\n\t\tSystem.out.println(\u0026#34;请依次输入：inputFile、bucketName、objectName\u0026#34;);\n\t\treturn;\n\t}\n\ts3Client = AmazonS3ClientProvider.CreateAmazonS3Conn();\n\tuploadObject(args[0], args[1], args[2]);\n}\n\npublic static void uploadObject(String inputFile, String bucketName, String objectName) {\n\ttry {\n\t\tFile file = new File(inputFile);\n\t\tif (!file.exists()) {\n\t\t\tSystem.out.println(\u0026#34;文件不存在：\u0026#34; + file.getPath());\n\t\t\treturn;\n\t\t}\n\t\ts3Client.putObject(new PutObjectRequest(bucketName, objectName, file));\n\t\tSystem.out.printf(\u0026#34;上传%s到MSS成功: %s/v1/%s/%s/%se\u0026#34;, inputFile, AmazonS3ClientProvider.url, TenantId, bucketName, objectName);\n\t} catch (AmazonServiceException ase) {\n\t\tSystem.out.println(\u0026#34;Caught an AmazonServiceException, which \u0026#34; +\n\t\t\t\t\u0026#34;means your request made it \u0026#34; +\n\t\t\t\t\u0026#34;to Amazon S3, but was rejected with an error response\u0026#34; +\n\t\t\t\t\u0026#34; for some reason.\u0026#34;);\n\t\tSystem.out.println(\u0026#34;Error Message:    \u0026#34; + ase.getMessage());\n\t\tSystem.out.println(\u0026#34;HTTP Status Code: \u0026#34; + ase.getStatusCode());\n\t\tSystem.out.println(\u0026#34;AWS Error Code:   \u0026#34; + ase.getErrorCode());\n\t\tSystem.out.println(\u0026#34;Error Type:       \u0026#34; + ase.getErrorType());\n\t\tSystem.out.println(\u0026#34;Request ID:       \u0026#34; + ase.getRequestId());\n\t} catch (AmazonClientException ace) {\n\t\tSystem.out.println(\u0026#34;Caught an AmazonClientException, which \u0026#34; +\n\t\t\t\t\u0026#34;means the client encountered \u0026#34; +\n\t\t\t\t\u0026#34;an internal error while trying to \u0026#34; +\n\t\t\t\t\u0026#34;communicate with S3, \u0026#34; +\n\t\t\t\t\u0026#34;such as not being able to access the network.\u0026#34;);\n\t\tSystem.out.println(\u0026#34;Error Message: \u0026#34; + ace.getMessage());\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们直接在Pipeline里构建完成后，调用这个工具就可以了。\n当然，JsBundle也分类型，在调试的时候可能随时需要更新，这些JsBundle不需要永久保存，一段时间后就可以删除了。在删除时，可以参考\u003ca href=\"https://www.mtyun.com/doc/sdk/mss-sdk/java/sheng-ming-zhu-qi-guan-li\"\u003eMSS生命周期管理\u003c/a\u003e。所以，我们在构建JsBundle的job里，添加一个参数来区分。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e//根据TYPE，上传到不同的bucket里面\ndef bucket = \u0026#34;rn-bundle-prod\u0026#34;\nif (\u0026#34;${TYPE}\u0026#34; == \u0026#34;dev\u0026#34;) {\n\tbucket = \u0026#34;rn-bundle-dev\u0026#34; //有生命周期管理，一段时间后自动删除\n}\necho \u0026#34;开始JsBundle上传到MSS\u0026#34;\n//jar地址需要替换成你自己的\nsh \u0026#34;curl -s -S -L  http://s3plus.sankuai.com/v1/mss_xxxxx==/rn-bundle-prod/rn.bundle.upload-0.0.1.jar -o upload.jar\u0026#34;\nsh \u0026#34;java -jar upload.jar ${archiveZip} ${bucket} ${PROJECT}/${targetZip}\u0026#34;\necho \u0026#34;上传JsBundle到MSS:${archiveZip}\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"native构建时jsbundle的下载\"\u003eNative构建时JsBundle的下载\u003c/h3\u003e\u003cp\u003e为了实现构建时能够自动下载，我们写了一个Gradle的插件。\u003c/p\u003e\u003cp\u003e首先要在build.gradle里面配置插件依赖：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eclasspath \u0026#39;com.zjiecode:rn-bundle-gradle-plugin:0.0.1\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在需要的Module应用插件：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eapply plugin: \u0026#39;mt-rn-bundle-download\u0026#39;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在build.gradle里面配置JsBundle的信息：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eRNDownloadConfig {\n    //远程文件目录,因为有多种类型，所以这里可以填多个。\n    paths = [\n            \u0026#39;http://msstest-corp.sankuai.com/v1/mss_xxxx==/rn-bundle-dev/xxx/\u0026#39;,\n            \u0026#39;http://msstest-corp.sankuai.com/v1/mss_xxxx==/rn-bundle-prod/xxx/\u0026#39;\n    ]\n    version  = \u0026#34;1\u0026#34;//版本号，这里使用的是打包JsBundle的BUILD_NUMBER\n    fileName = \u0026#39;xxxx.android.bundle-%s.zip\u0026#39; //远程文件的文件名,%s会用上面的version来填充\n    outFile  = \u0026#39;xxxx/src/main/assets/JsBundle/xxxx.android.bundle.zip\u0026#39; // 下载后的存储路径，相对于项目根目录\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e插件会在package的task前面，插入一个下载的task，task读取上面的配置信息，在打包阶段检查是否已经存在这个版本的JsBundle。如果不存在，就会去归档的JsBundle里，下载我们需要的JsBundle。 当然，这里的version可以使用上文介绍的\u003ccode\u003e注入构建信息\u003c/code\u003e的方式，通过job参数的方式进行注入。这样在Jenkins构建Native时，就可以动态地填写需要JsBundle的版本了。\u003c/p\u003e\u003cp\u003e这个Gradle插件，我们已经放到到了github仓库，你可以基于此修改，当然，也欢迎PR。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/zjiecode/rn-bundle-gradle-plugin\"\u003ehttps://github.com/zjiecode/rn-bundle-gradle-plugin\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"六-总结\"\u003e六、总结\u003c/h2\u003e\u003cp\u003e\u003cstrong\u003e我们把一个构建分成了好几个部分，带来的好处如下：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e核心构建过程，只需要维护一份，减轻维护工作；\u003c/li\u003e\u003cli\u003e方便多个人维护构建CI，避免Pipeline代码被覆盖；\u003c/li\u003e\u003cli\u003e方便构建job的版本管理，比如要修复某个已经发布的版本，可以很方便切换到发布版本时候用的Pipeline脚本版本；\u003c/li\u003e\u003cli\u003e每个项目，配置也比较灵活，如果项目配置不够灵活，可以尝试定义更多的变量；\u003c/li\u003e\u003cli\u003e构建过程可视化，方便针对性优化和错误定位等。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e当然，Pipeline也存在一些弊端，比如：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e语法不够友好，但好在Jenkins提供了一个比较强大的帮助工具（Pipeline Syntax）；\u003c/li\u003e\u003cli\u003e代码测试繁琐，没有本地运行环境，每次测试都需要提交运行一个job，等等。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e当项目集成了React Native时，配合Pipeline，我们可以把JsBundle的构建产物上传到MSS归档。在构建Native的时候 ，可以动态地下载。\u003c/p\u003e\u003ch2 id=\"七-作者\"\u003e七、作者\u003c/h2\u003e\u003cul\u003e\u003cli\u003e张杰，美团点评高级Android工程师，2017年加入餐饮平台成都研发中心，主要负责餐饮平台B端应用开发。\u003c/li\u003e\u003cli\u003e王浩，美团点评高级Android工程师，2017年加入餐饮平台成都研发中心，主要负责餐饮平台B端应用开发。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"八-招聘广告\"\u003e八、招聘广告\u003c/h2\u003e\u003cp\u003e本文作者来自美团成都研发中心（是的，我们在成都建研发中心啦！）。我们在成都有众多后端、前端和测试的岗位正在招人，欢迎大家投递简历：songyanwei#meituan.com。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-08-02T00:00:00Z",
  "Author": "soulteary@gmail.com"
}