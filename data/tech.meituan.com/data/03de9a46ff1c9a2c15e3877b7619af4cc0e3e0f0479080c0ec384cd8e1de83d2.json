{
  "Source": "tech.meituan.com",
  "Title": "Android OOM案例分析",
  "Link": "https://tech.meituan.com/2017/04/14/oom-analysis.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e在Android（Java）开发中，基本都会遇到\u003ccode\u003ejava.lang.OutOfMemoryError\u003c/code\u003e（本文简称OOM），这种错误解决起来相对于一般的Exception或者Error都要难一些，主要是由于错误产生的root cause不是很显而易见。由于没有办法能够直接拿到用户的内存dump文件，如果错误发生在线上的版本，分析起来就会更加困难。本文从一个具体的案例切入，介绍OOM分析的思路及相关工具的使用。\u003c/p\u003e\u003ch2 id=\"案例背景\"\u003e案例背景\u003c/h2\u003e\u003cp\u003e在美团App 7.4~7.7版本期间，美食业务的OOM数量居高不下，远高于历史水平，主要都是DECODE本地的资源出错。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/81d7a001.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e图中OOM数量为各版本发版后第一个月的统计量，包含新发版本及历史版本。对比了同时期其他业务的情况，也有类似OOM。由于美食业务的访问量占美团App的比重较大，因此，OOM的数量相对其他业务也多一些。\u003c/p\u003e\u003ch2 id=\"思路方案\"\u003e思路方案\u003c/h2\u003e\u003cp\u003e在问题较为严重的7.6~7.7版本期间，团队对OOM频现的原因有过各种猜测。笔者怀疑过是否是业务上某些修改引起的，例如头图尺寸变大，或者是由页面模块加载方式引起的等等。但这些与OOM问题出现的时间并不吻合。其次也怀疑过是否由某些ROM的Bug导致，但此推断缺乏有力的证据支撑。因此，要找到OOM的root cause，根本途径还是找到谁占的内存最多，然后再根据具体case具体分析，为什么占了这么多。\u003c/p\u003e\u003ch3 id=\"采集用户手机内存信息\"\u003e采集用户手机内存信息\u003c/h3\u003e\u003cp\u003e要分析内存的占用，需要内存的dump文件，但是dump文件一般都比较大，让用户配合上传dump文件不合适。所以希望能够运行时采集一些内存的特征然后随着crash日志上报上来。当用户发生OOM时，dump出用户的内存，然后基于\u003ccode\u003ecom.squareup.haha:haha:2.0.3\u003c/code\u003e分析，得到一些关键数据（内存占用最多的实例及所占比例等）。但这个方案很快就被证明是不可行的。主要基于下面几个原因：\n- 需要引入新的库。\n- dump和分析内存都很耗时，效率难以接受。\n- OOM时内存已经几乎耗尽，再加载内存dump文件并分析会导致二次OOM，得不偿失。\u003c/p\u003e\u003ch3 id=\"模拟复现oom\"\u003e模拟复现OOM\u003c/h3\u003e\u003cp\u003e采集用户手机内存信息的方案不可行，那么只能采取复现用户场景的方式。由于发生OOM时，用户操作路径的不确定性，无法精确复现线上的OOM，因此采取模拟复现的方式，最终发生OOM时的栈信息基本一致即可。为了能够尽量模拟用户发生OOM的场景，需要基本条件基本一致，即用户使用的手机的各种相关参数。\u003c/p\u003e\u003ch4 id=\"挖掘oom特征\"\u003e挖掘OOM特征\u003c/h4\u003e\u003cp\u003e分析7.4以来的OOM，列出发生OOM的机器的特征，主要是内存和分辨率，适当考虑其它因素例如系统版本。\u003c/p\u003e\u003cp\u003e| 机型 | 内存 | 分辨率 | OS | stack log |\n| – | – | – | – | – |\n| OPPO N1(T/W) | 2G | 1920*1080 | 4.2.2 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method)|\n| HM 2LTE-CMCC | 1G | 1280*720 | 4.4.4 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\n| Newman CM810 | 2G | 1920*1080 | 4.4.4 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\n| LGL22 | 2G | 1830*1080 | 4.2.2 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\n| OPPO X909 | 2G | 1920*1080 | 4.2.2 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\n| Lenovo K900 | 2G | 1920*1080 | 4.2.2 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\n| GiONEE E6 | 2G | 1920*1080 | 4.2.1 | java.lang.OutOfMemoryError\u003cbr/\u003eat android.graphics.BitmapFactory.nativeDecodeAsset(Native Method) |\u003c/p\u003e\u003cp\u003e这些特征可以总结为：内存一般，分辨率偏高，OOM的堆栈log基本一致。其中，OPPO N1(T/W)上所发生的OOM比重较高，约为65%，因此选定这款机器作为复现OOM的机器。\u003c/p\u003e\u003ch4 id=\"关键数据-内存dump文件\"\u003e关键数据（内存dump文件）\u003c/h4\u003e\u003cp\u003e需要复现OOM然后获取内存dump。思路是采取内存压力测试，让问题暴露的快速且充分。具体方案为：\n- 选取图片资源多且较为复杂的页面，比如美食的POI详情页。\n- 加载30次该页面，为了增加OOM的几率，30个POI页面的ID是不同的。\u003c/p\u003e\u003cp\u003eOOM发生后，使用Android Studio自带的Android Monitor dump出HPROF文件，然后使用SDK中的hprof-conv（位于sdk_root/platform-tools）工具转换为标准的Java堆转储文件格式，这样可以使用MAT（Eclipse Memory Analyzer）继续分析。\u003c/p\u003e\u003cp\u003e切到histogram视图，按shadow heap降序排列。\u003c/p\u003e\u003cp\u003e选取byte数组，右击-\u0026gt;list objects-\u0026gt;with incoming references，降序排列可以看到有很多大小一致的byte[]实例。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/7f5ca256.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e右击其中一个数组-\u0026gt;Path to GC Roots-\u0026gt; exclude xxx references\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/91fcd85c.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如上图所示，这些byte[]都是系统的EdgeEffect的drawable所持有，drawable对应的bitmap占用的空间为1566 * 406 * 4 = 2543184，与byte数组的大小一致。\u003c/p\u003e\u003cp\u003e再看另外一个：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/2b3655b6.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这些byte[]是被App的一个背景图所持有，如下图：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/c793ea40.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过ImageView的ID（如图）及build目录下的R.txt反查可知该ImageView的ID名称，即可知其设置的背景图的大小为720 * 200（xhdpi），加载到内存并考虑density，size刚好是1080 * 300 * 4 = 1296000，与byte数组大小一致。\u003c/p\u003e\u003ch4 id=\"数据分析\"\u003e数据分析\u003c/h4\u003e\u003cp\u003e为什么会出现这些大小一致的byte数组，或者说，为什么会创建多份EdgeEffect的drawable？查看EdgeEffect的源码（4.2.2）可知，其drawable成员也是通过\u003ccode\u003eResources.getDrawable\u003c/code\u003e系统调用获取的。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/**\n * Construct a new EdgeEffect with a theme appropriate for the provided context.\n * @param context Context used to provide theming and resource information for the EdgeEffect\n */\npublic EdgeEffect(Context context) {\n    final Resources res = context.getResources();\n    mEdge = res.getDrawable(R.drawable.overscroll_edge);\n    mGlow = res.getDrawable(R.drawable.overscroll_glow);\n\n        ******\n\n    mMinWidth = (int) (res.getDisplayMetrics().density * MIN_WIDTH + 0.5f);\n    mInterpolator = new DecelerateInterpolator();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eImageView(View)获取background对应的drawable的过程类似。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efor (int i = 0; i \u0026lt; N; i++) {\n    int attr = a.getIndex(i);\n    switch (attr) {\n        case com.android.internal.R.styleable.View_background:\n            background = a.getDrawable(attr); // TypedArray.getDrawable\n            break;\n        ******\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e不论是Resources.getDrawable还是TypedArray.getDrawable，最终都会调用Resources.loadDrawable。继续看\u003ccode\u003eResources.loadDrawable\u003c/code\u003e的源码，发现的确是使用了缓存。对于同一个drawable资源，系统只会加载一次，之后都会从缓存去取。\u003c/p\u003e\u003cp\u003e既然drawable的加载机制并没有问题，那么drawable所在的缓存实例或者获取drawable的Resources实例是否是同一个呢？通过下面的代码，打印出每个Activity的Resources实例及Resources实例的drawable cache。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//noinspection unchecked\nLongSparseArray\u0026lt;WeakReference\u0026lt;Drawable.ConstantState\u0026gt;\u0026gt; cache = (LongSparseArray\u0026lt;WeakReference\u0026lt;Drawable.ConstantState\u0026gt;\u0026gt;) Hack.into(Resources.class).field(\u0026#34;mDrawableCache\u0026#34;).get(getResources());\nObject appCache = Hack.into(Resources.class).field(\u0026#34;mDrawableCache\u0026#34;).get(getApplication().getResources());\nLog.e(\u0026#34;oom\u0026#34;, \u0026#34;Resources: {application=\u0026#34; + getApplication().getResources() + \u0026#34;, activity=\u0026#34; + getResources() + \u0026#34;}\u0026#34;);\nLog.e(\u0026#34;oom\u0026#34;, \u0026#34;Resources.mDrawableCache: {application=\u0026#34; + appCache + \u0026#34;, activity=\u0026#34; + cache + \u0026#34;}\u0026#34;); \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/d10a48d8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这也进一步解释了另外一个现象，即这些大小相同的数组的个数基本和启动Activity的数量成正比。\u003c/p\u003e\u003cp\u003e通过数据分析可知，这些drawable之所以存在多份，是因为其所在的Resources实例并不是同一个。进一步debug可知，Resources实例存在多个的原因是开启了标志位\u003ca href=\"https://developer.android.com/reference/android/support/v7/app/AppCompatDelegate.html#setCompatVectorFromResourcesEnabled(boolean)\"\u003esCompatVectorFromResourcesEnabled\u003c/a\u003e。\n虽然最终造成OOM突然增多的原因只是开启一个标志位，但是这也告诫大家阅读API文档的重要性，其实很多时候API的使用说明已经明确告知了使用的限制条件甚至风险。\u003c/p\u003e\u003cp\u003e7.8版本关闭了此标志，发版后第一个月的OOM数量（包含历史版本）为153，如下图。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a76bc884.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e其中新版本发生的OOM数量为22。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e对于线上出现的OOM，如何分析和解决可以大致分为三个步骤：\u003c/p\u003e\u003col\u003e\u003cli\u003e充分挖掘特征。在挖掘特征时，需要多方面考虑，此过程更多的是猜测怀疑，所以可能的方面都要考虑到，包括但不限于代码改动、机器特征、时间特征等，必要时还需要做一定的统计分析。\u003c/li\u003e\u003cli\u003e根据掌握的特征寻找稳定的复现的途径。一般需要做内存压力测试，这样比较容易达到OOM的临界值，只是简单的一些正常操作难以触发OOM。\u003c/li\u003e\u003cli\u003e获取可分析的数据（内存dump文件）。利用MAT分析dump文件，MAT可以方便的按照大小排序实例，可以查看某些实例到GC ROOT的路径。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cp\u003e军慧，美团点评Android高级工程师，2015年加入原美团，负责美团点评到店餐饮业务美团Android App的开发工作。\u003c/p\u003e\u003cp\u003e到店餐饮技术部交易与信息技术中心，负责美团点评美食用户端业务，服务于数以亿计用户，通过更好的榜单、真实的评价和完善的信息为用户提供更好的决策支持，致力于提升用户体验；同时承载所有餐饮商户端线上流量，为餐饮商户提供多种营销工具，提升餐饮商户营销效率，最终达到让国人“Eat Better、Live Better”的美好愿景！我们的团队包含且不限于Android、iOS、FE、Java、PHP等技术方向，已完备覆盖前后端技术栈。只要你来，就能点亮全栈开发技能树。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-04-14T00:00:00Z",
  "Author": "soulteary@gmail.com"
}