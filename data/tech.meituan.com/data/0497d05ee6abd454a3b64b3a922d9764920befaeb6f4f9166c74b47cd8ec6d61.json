{
  "Source": "tech.meituan.com",
  "Title": "Node.js Stream - 基础篇",
  "Link": "https://tech.meituan.com/2016/07/08/stream-basics.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e在构建较复杂的系统时，通常将其拆解为功能独立的若干部分。这些部分的接口遵循一定的规范，通过某种方式相连，以共同完成较复杂的任务。譬如，shell通过管道\u003ccode\u003e|\u003c/code\u003e连接各部分，其输入输出的规范是文本流。\u003c/p\u003e\u003cp\u003e在\u003ca href=\"https://nodejs.org/\"\u003eNode.js\u003c/a\u003e中，内置的\u003ca href=\"https://nodejs.org/api/stream.html\"\u003eStream\u003c/a\u003e模块也实现了类似功能，各部分通过\u003ccode\u003e.pipe()\u003c/code\u003e连接。\u003c/p\u003e\u003cp\u003e鉴于目前国内系统性介绍Stream的文章较少，而越来越多的开源工具都使用了Stream，本系列文章将从以下几方面来介绍相关内容：\n1. 流的基本类型，以及\u003ca href=\"https://nodejs.org/api/stream.html\"\u003eStream\u003c/a\u003e模块的基本使用方法\n2. 流式处理与\u003ca href=\"https://howtonode.org/streams-explained\"\u003eback pressure\u003c/a\u003e的工作原理\n3. 如何开发流式程序，包括对\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e与\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e的剖析，以及一个实战示例。\u003c/p\u003e\u003cp\u003e本文为系列文章的第一篇。\u003c/p\u003e\u003cp\u003eStream提供了以下四种类型的流：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar Stream = require(\u0026#39;stream\u0026#39;)\n\nvar Readable = Stream.Readable\nvar Writable = Stream.Writable\nvar Duplex = Stream.Duplex\nvar Transform = Stream.Transform\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e使用\u003ccode\u003eStream\u003c/code\u003e可实现数据的流式处理，如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar fs = require(\u0026#39;fs\u0026#39;)\n// `fs.createReadStream`创建一个`Readable`对象以读取`bigFile`的内容，并输出到标准输出\n// 如果使用`fs.readFile`则可能由于文件过大而失败\nfs.createReadStream(bigFile).pipe(process.stdout)\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"readable\"\u003eReadable\u003c/h2\u003e\u003cp\u003e创建可读流。\u003c/p\u003e\u003cp\u003e实例：流式消耗\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols\"\u003e迭代器\u003c/a\u003e中的数据。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u0026#39;use strict\u0026#39;\nconst Readable = require(\u0026#39;stream\u0026#39;).Readable\n\nclass ToReadable extends Readable {\n  constructor(iterator) {\n    super()\n    this.iterator = iterator\n  }\n\n  // 子类需要实现该方法\n  // 这是生产数据的逻辑\n  _read() {\n    const res = this.iterator.next()\n    if (res.done) {\n      // 数据源已枯竭，调用`push(null)`通知流\n      return this.push(null)\n    }\n    setTimeout(() =\u0026gt; {\n      // 通过`push`方法将数据添加到流中\n      this.push(res.value + \u0026#39;\\n\u0026#39;)\n    }, 0)\n  }\n}\n\nmodule.exports = ToReadable\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e实际使用时，\u003ccode\u003enew ToReadable(iterator)\u003c/code\u003e会返回一个可读流，下游可以流式的消耗迭代器中的数据。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst iterator = function (limit) {\n  return {\n    next: function () {\n      if (limit--) {\n        return { done: false, value: limit + Math.random() }\n      }\n      return { done: true }\n    }\n  }\n}(1e10)\n\nconst readable = new ToReadable(iterator)\n\n// 监听`data`事件，一次获取一个数据\nreadable.on(\u0026#39;data\u0026#39;, data =\u0026gt; process.stdout.write(data))\n\n// 所有数据均已读完\nreadable.on(\u0026#39;end\u0026#39;, () =\u0026gt; process.stdout.write(\u0026#39;DONE\u0026#39;))\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行上述代码，将会有100亿个随机数源源不断地写进标准输出流。\u003c/p\u003e\u003cp\u003e创建可读流时，需要继承\u003ccode\u003eReadable\u003c/code\u003e，并实现\u003ccode\u003e_read\u003c/code\u003e方法。\n* \u003ccode\u003e_read\u003c/code\u003e方法是从底层系统读取具体数据的逻辑，即生产数据的逻辑。\n* 在\u003ccode\u003e_read\u003c/code\u003e方法中，通过调用\u003ccode\u003epush(data)\u003c/code\u003e将数据放入可读流中供下游消耗。\n* 在\u003ccode\u003e_read\u003c/code\u003e方法中，可以同步调用\u003ccode\u003epush(data)\u003c/code\u003e，也可以异步调用。\n* 当全部数据都生产出来后，\u003cstrong\u003e必须\u003c/strong\u003e调用\u003ccode\u003epush(null)\u003c/code\u003e来结束可读流。\n* 流一旦结束，便不能再调用\u003ccode\u003epush(data)\u003c/code\u003e添加数据。\u003c/p\u003e\u003cp\u003e可以通过监听\u003ccode\u003edata\u003c/code\u003e事件的方式消耗可读流。\n* 在首次监听其\u003ccode\u003edata\u003c/code\u003e事件后，\u003ccode\u003ereadable\u003c/code\u003e便会持续不断地调用\u003ccode\u003e_read()\u003c/code\u003e，通过触发\u003ccode\u003edata\u003c/code\u003e事件将数据输出。\n* 第一次\u003ccode\u003edata\u003c/code\u003e事件会在下一个tick中触发，所以，可以安全地将数据输出前的逻辑放在事件监听后（同一个tick中）。\n* 当数据全部被消耗时，会触发\u003ccode\u003eend\u003c/code\u003e事件。\u003c/p\u003e\u003cp\u003e上面的例子中，\u003ccode\u003eprocess.stdout\u003c/code\u003e代表标准输出流，实际是一个可写流。下小节中介绍可写流的用法。\u003c/p\u003e\u003ch2 id=\"writable\"\u003eWritable\u003c/h2\u003e\u003cp\u003e创建可写流。\u003c/p\u003e\u003cp\u003e前面通过继承的方式去创建一类可读流，这种方法也适用于创建一类可写流，只是需要实现的是\u003ccode\u003e_write(data, enc, next)\u003c/code\u003e方法，而不是\u003ccode\u003e_read()\u003c/code\u003e方法。\u003c/p\u003e\u003cp\u003e有些简单的情况下不需要创建一类流，而只是一个流对象，可以用如下方式去做：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst Writable = require(\u0026#39;stream\u0026#39;).Writable\n\nconst writable = Writable()\n// 实现`_write`方法\n// 这是将数据写入底层的逻辑\nwritable._write = function (data, enc, next) {\n  // 将流中的数据写入底层\n  process.stdout.write(data.toString().toUpperCase())\n  // 写入完成时，调用`next()`方法通知流传入下一个数据\n  process.nextTick(next)\n}\n\n// 所有数据均已写入底层\nwritable.on(\u0026#39;finish\u0026#39;, () =\u0026gt; process.stdout.write(\u0026#39;DONE\u0026#39;))\n\n// 将一个数据写入流中\nwritable.write(\u0026#39;a\u0026#39; + \u0026#39;\\n\u0026#39;)\nwritable.write(\u0026#39;b\u0026#39; + \u0026#39;\\n\u0026#39;)\nwritable.write(\u0026#39;c\u0026#39; + \u0026#39;\\n\u0026#39;)\n\n// 再无数据写入流时，需要调用`end`方法\nwritable.end()\n\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e上游通过调用\u003ccode\u003ewritable.write(data)\u003c/code\u003e将数据写入可写流中。\u003ccode\u003ewrite()\u003c/code\u003e方法会调用\u003ccode\u003e_write()\u003c/code\u003e将\u003ccode\u003edata\u003c/code\u003e写入底层。\u003c/li\u003e\u003cli\u003e在\u003ccode\u003e_write\u003c/code\u003e中，当数据成功写入底层后，\u003cstrong\u003e必须\u003c/strong\u003e调用\u003ccode\u003enext(err)\u003c/code\u003e告诉流开始处理下一个数据。\u003c/li\u003e\u003cli\u003e\u003ccode\u003enext\u003c/code\u003e的调用既可以是同步的，也可以是异步的。\u003c/li\u003e\u003cli\u003e上游\u003cstrong\u003e必须\u003c/strong\u003e调用\u003ccode\u003ewritable.end(data)\u003c/code\u003e来结束可写流，\u003ccode\u003edata\u003c/code\u003e是可选的。此后，不能再调用\u003ccode\u003ewrite\u003c/code\u003e新增数据。\u003c/li\u003e\u003cli\u003e在\u003ccode\u003eend\u003c/code\u003e方法调用后，当所有底层的写操作均完成时，会触发\u003ccode\u003efinish\u003c/code\u003e事件。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"duplex\"\u003eDuplex\u003c/h2\u003e\u003cp\u003e创建可读可写流。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eDuplex\u003c/code\u003e实际上就是继承了\u003ccode\u003eReadable\u003c/code\u003e和\u003ccode\u003eWritable\u003c/code\u003e的一类流。\n所以，一个\u003ccode\u003eDuplex\u003c/code\u003e对象既可当成可读流来使用（需要实现\u003ccode\u003e_read\u003c/code\u003e方法），也可当成可写流来使用（需要实现\u003ccode\u003e_write\u003c/code\u003e方法）。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar Duplex = require(\u0026#39;stream\u0026#39;).Duplex\n\nvar duplex = Duplex()\n\n// 可读端底层读取逻辑\nduplex._read = function () {\n  this._readNum = this._readNum || 0\n  if (this._readNum \u0026gt; 1) {\n    this.push(null)\n  } else {\n    this.push(\u0026#39;\u0026#39; + (this._readNum++))\n  }\n}\n\n// 可写端底层写逻辑\nduplex._write = function (buf, enc, next) {\n  // a, b\n  process.stdout.write(\u0026#39;_write \u0026#39; + buf.toString() + \u0026#39;\\n\u0026#39;)\n  next()\n}\n\n// 0, 1\nduplex.on(\u0026#39;data\u0026#39;, data =\u0026gt; console.log(\u0026#39;ondata\u0026#39;, data.toString()))\n\nduplex.write(\u0026#39;a\u0026#39;)\nduplex.write(\u0026#39;b\u0026#39;)\n\nduplex.end()\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面的代码中实现了\u003ccode\u003e_read\u003c/code\u003e方法，所以可以监听\u003ccode\u003edata\u003c/code\u003e事件来消耗\u003ccode\u003eDuplex\u003c/code\u003e产生的数据。\n同时，又实现了\u003ccode\u003e_write\u003c/code\u003e方法，可作为下游去消耗数据。\u003c/p\u003e\u003cp\u003e因为它既可读又可写，所以称它有两端：可写端和可读端。\n可写端的接口与\u003ccode\u003eWritable\u003c/code\u003e一致，作为下游来使用；可读端的接口与\u003ccode\u003eReadable\u003c/code\u003e一致，作为上游来使用。\u003c/p\u003e\u003ch2 id=\"transform\"\u003eTransform\u003c/h2\u003e\u003cp\u003e在上面的例子中，可读流中的数据（0, 1）与可写流中的数据（’a’, ‘b’）是隔离开的，但在\u003ccode\u003eTransform\u003c/code\u003e中可写端写入的数据经变换后会自动添加到可读端。\n\u003ccode\u003eTranform\u003c/code\u003e继承自\u003ccode\u003eDuplex\u003c/code\u003e，并已经实现了\u003ccode\u003e_read\u003c/code\u003e和\u003ccode\u003e_write\u003c/code\u003e方法，同时要求用户实现一个\u003ccode\u003e_transform\u003c/code\u003e方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e\u0026#39;use strict\u0026#39;\n\nconst Transform = require(\u0026#39;stream\u0026#39;).Transform\n\nclass Rotate extends Transform {\n  constructor(n) {\n    super()\n    // 将字母旋转`n`个位置\n    this.offset = (n || 13) % 26\n  }\n\n  // 将可写端写入的数据变换后添加到可读端\n  _transform(buf, enc, next) {\n    var res = buf.toString().split(\u0026#39;\u0026#39;).map(c =\u0026gt; {\n      var code = c.charCodeAt(0)\n      if (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) {\n        code += this.offset\n        if (code \u0026gt; \u0026#39;z\u0026#39;.charCodeAt(0)) {\n          code -= 26\n        }\n      } else if (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;) {\n        code += this.offset\n        if (code \u0026gt; \u0026#39;Z\u0026#39;.charCodeAt(0)) {\n          code -= 26\n        }\n      }\n      return String.fromCharCode(code)\n    }).join(\u0026#39;\u0026#39;)\n\n    // 调用push方法将变换后的数据添加到可读端\n    this.push(res)\n    // 调用next方法准备处理下一个\n    next()\n  }\n\n}\n\nvar transform = new Rotate(3)\ntransform.on(\u0026#39;data\u0026#39;, data =\u0026gt; process.stdout.write(data))\ntransform.write(\u0026#39;hello, \u0026#39;)\ntransform.write(\u0026#39;world!\u0026#39;)\ntransform.end()\n\n// khoor, zruog!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e前面几节的例子中，经常看到调用\u003ccode\u003edata.toString()\u003c/code\u003e。这个\u003ccode\u003etoString()\u003c/code\u003e的调用是必需的吗？\n本节介绍完如何控制流中的数据类型后，自然就有了答案。\u003c/p\u003e\u003cp\u003e在shell中，用管道（\u003ccode\u003e|\u003c/code\u003e）连接上下游。上游输出的是文本流（标准输出流），下游输入的也是文本流（标准输入流）。在本文介绍的流中，默认也是如此。\u003c/p\u003e\u003cp\u003e对于可读流来说，\u003ccode\u003epush(data)\u003c/code\u003e时，\u003ccode\u003edata\u003c/code\u003e只能是\u003ccode\u003eString\u003c/code\u003e或\u003ccode\u003eBuffer\u003c/code\u003e类型，而消耗时\u003ccode\u003edata\u003c/code\u003e事件输出的数据都是\u003ccode\u003eBuffer\u003c/code\u003e类型。对于可写流来说，\u003ccode\u003ewrite(data)\u003c/code\u003e时，\u003ccode\u003edata\u003c/code\u003e只能是\u003ccode\u003eString\u003c/code\u003e或\u003ccode\u003eBuffer\u003c/code\u003e类型，\u003ccode\u003e_write(data)\u003c/code\u003e调用时传进来的\u003ccode\u003edata\u003c/code\u003e都是\u003ccode\u003eBuffer\u003c/code\u003e类型。\u003c/p\u003e\u003cp\u003e也就是说，流中的数据默认情况下都是\u003ccode\u003eBuffer\u003c/code\u003e类型。产生的数据一放入流中，便转成\u003ccode\u003eBuffer\u003c/code\u003e被消耗；写入的数据在传给底层写逻辑时，也被转成\u003ccode\u003eBuffer\u003c/code\u003e类型。\u003c/p\u003e\u003cp\u003e但每个构造函数都接收一个配置对象，有一个\u003ccode\u003eobjectMode\u003c/code\u003e的选项，一旦设置为\u003ccode\u003etrue\u003c/code\u003e，就能出现“种瓜得瓜，种豆得豆”的效果。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eReadable\u003c/code\u003e未设置\u003ccode\u003eobjectMode\u003c/code\u003e时：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst Readable = require(\u0026#39;stream\u0026#39;).Readable\n\nconst readable = Readable()\n\nreadable.push(\u0026#39;a\u0026#39;)\nreadable.push(\u0026#39;b\u0026#39;)\nreadable.push(null)\n\nreadable.on(\u0026#39;data\u0026#39;, data =\u0026gt; console.log(data))\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e输出：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;Buffer 61\u0026gt;\n\u0026lt;Buffer 62\u0026gt;\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eReadable\u003c/code\u003e设置\u003ccode\u003eobjectMode\u003c/code\u003e后：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst Readable = require(\u0026#39;stream\u0026#39;).Readable\n\nconst readable = Readable({ objectMode: true })\n\nreadable.push(\u0026#39;a\u0026#39;)\nreadable.push(\u0026#39;b\u0026#39;)\nreadable.push({})\nreadable.push(null)\n\nreadable.on(\u0026#39;data\u0026#39;, data =\u0026gt; console.log(data))\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e输出：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ea\nb\n{}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可见，设置\u003ccode\u003eobjectMode\u003c/code\u003e后，\u003ccode\u003epush(data)\u003c/code\u003e的数据被原样地输出了。此时，可以生产任意类型的数据。\u003c/p\u003e\u003cp\u003eStream系列共三篇文章：\n* 第一部分：基础篇，介绍\u003ca href=\"https://nodejs.org/api/stream.html\"\u003eStream\u003c/a\u003e接口的基本使用。\n* 第二部分：进阶篇，重点剖析Stream底层如何支持流式数据处理，及其\u003ca href=\"https://howtonode.org/streams-explained\"\u003eback pressure\u003c/a\u003e机制。\n* 第三部分：实战篇。介绍如何使用Stream进行程序设计。从\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e和\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e总结出两种设计模式，并基于Stream构建一个为\u003ca href=\"https://git-scm.com/\"\u003eGit\u003c/a\u003e仓库自动生成changelog的应用作为示例。\u003c/p\u003e\u003cul\u003e\u003cli\u003eGitHub，\u003ca href=\"https://github.com/substack/browserify-handbook\"\u003esubstack/browserify-handbook\u003c/a\u003e\u003c/li\u003e\u003cli\u003eGitHub，\u003ca href=\"https://github.com/zoubin/streamify-your-node-program\"\u003ezoubin/streamify-your-node-program\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-07-08T00:00:00Z",
  "Author": "soulteary@gmail.com"
}