{
  "Source": "tech.meituan.com",
  "Title": "WebView性能、体验分析与优化",
  "Link": "https://tech.meituan.com/2017/06/09/webviewperf.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e在App开发中，内嵌WebView始终占有着一席之地。它能以较低的成本实现Android、iOS和Web的复用，也可以冠冕堂皇的突破苹果对热更新的封锁。\u003c/p\u003e\u003cp\u003e然而便利性的同时，WebView的性能体验却备受质疑，导致很多客户端中需要动态更新等页面时不得不采用其他方案。\u003c/p\u003e\u003cp\u003e以发展的眼光来看，功能的动态加载以及三端的融合将会是大趋势。那么如何克服WebView固有的问题呢？我们将从性能、内存消耗、体验、安全几个维度，来系统的分析客户端默认WebView的问题，以及对应的优化方案。\u003c/p\u003e\u003cp\u003e对于WebView的性能，给人最直观的莫过于：打开速度比native慢。\u003c/p\u003e\u003cp\u003e是的，当我们打开一个WebView页面，页面往往会慢吞吞的loading很久，若干秒后才出现你所需要看到的页面。\u003c/p\u003e\u003cp\u003e这是为什么呢？\u003c/p\u003e\u003cp\u003e对于一个普通用户来讲，打开一个WebView通常会经历以下几个阶段：\u003c/p\u003e\u003col\u003e\u003cli\u003e交互无反馈\u003c/li\u003e\u003cli\u003e到达新的页面，页面白屏\u003c/li\u003e\u003cli\u003e页面基本框架出现，但是没有数据；页面处于loading状态\u003c/li\u003e\u003cli\u003e出现所需的数据\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e如果从程序上观察，WebView启动过程大概分为以下几个阶段：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/9a2f8beb.png\" alt=\"WebView启动时间\"/\u003e\u003c/p\u003e\u003cp\u003e如何缩短这些过程的时间，就成了优化WebView性能的关键。\u003c/p\u003e\u003cp\u003e接下来我们逐一分析各个阶段的耗时情况，以及需要注意的优化点。\u003c/p\u003e\u003ch2 id=\"webview初始化\"\u003eWebView初始化\u003c/h2\u003e\u003cp\u003e当App首次打开时，默认是并不初始化浏览器内核的；只有当创建WebView实例的时候，才会创建WebView的基础框架。\u003c/p\u003e\u003cp\u003e所以与浏览器不同，\u003cstrong\u003eApp中打开WebView的第一步并不是建立连接，而是启动浏览器内核\u003c/strong\u003e。\u003c/p\u003e\u003cp\u003e我们来分析一下这段耗时到底需要多久。\u003c/p\u003e\u003ch3 id=\"分析\"\u003e分析\u003c/h3\u003e\u003cp\u003e针对WebView的初始化时间，我们可以定义两个指标：\u003c/p\u003e\u003cul\u003e\u003cli\u003e首次初始化时间：客户端冷启动后，第一次打开WebView，从开始创建WebView到开始建立网络连接之间的时间。\u003c/li\u003e\u003cli\u003e二次初始化时间：在打开过WebView后，退出WebView，再重新打开WebView，从开始创建WebView到开始建立网络连接之间的时间。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e测试数据：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e测试系统1： iOS模拟器，Titans 10.0.7\u003c/p\u003e\u003cp\u003e测试系统2： OPPO R829T Android 4.2.2\u003c/p\u003e\u003cp\u003e测试方式：测试10次取平均值\u003c/p\u003e\u003cp\u003e测试App：美团外卖\u003c/p\u003e\u003cp\u003e单位：ms\u003c/p\u003e\u003c/blockquote\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003e首次初始化时间\u003c/th\u003e\u003cth\u003e二次初始化时间\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eiOS（UIWebView）\u003c/td\u003e\u003ctd\u003e306.56\u003c/td\u003e\u003ctd\u003e76.43\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eiOS（WKWebView）\u003c/td\u003e\u003ctd\u003e763.26\u003c/td\u003e\u003ctd\u003e457.25\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAndroid\u003c/td\u003e\u003ctd\u003e192.79 *\u003c/td\u003e\u003ctd\u003e142.53\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cblockquote\u003e\u003cp\u003e*Android外卖客户端启动后会在后台开启WebView进程，故并不是完全新建WebView时间。\u003c/p\u003e\u003c/blockquote\u003e\u003ch3 id=\"这意味着什么呢\"\u003e这意味着什么呢？\u003c/h3\u003e\u003cp\u003e作为前端工程师，统计了无数次的页面打开时间，都是以网络连接开始作为起点的。\u003c/p\u003e\u003cp\u003e很遗憾的通知您：WebView中用户体验到的打开时间需要再增加70~700ms。\u003c/p\u003e\u003cp\u003e于是我们找到了“为什么WebView总是很慢”的原因之一：\u003c/p\u003e\u003cul\u003e\u003cli\u003e在浏览器中，我们输入地址时（甚至在之前），浏览器就可以开始加载页面。\u003c/li\u003e\u003cli\u003e而在客户端中，客户端需要先花费时间初始化WebView完成后，才开始加载。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e而这段时间，由于WebView还不存在，所有后续的过程是完全阻塞的。可以这样形容WebView初始化过程：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/0b91f76e.png\" alt=\"WebView启动过程\"/\u003e\u003c/p\u003e\u003cp\u003e那么有哪些解决办法呢？\u003c/p\u003e\u003ch3 id=\"怎么优化\"\u003e怎么优化\u003c/h3\u003e\u003cp\u003e由于这段过程发生在native的代码中，单纯靠前端代码是无法优化的；大部分的方案都是前端和客户端协作完成，以下是几个业界采用过的方案。\u003c/p\u003e\u003ch4 id=\"全局webview\"\u003e全局WebView\u003c/h4\u003e\u003cp\u003e方法：\u003c/p\u003e\u003cul\u003e\u003cli\u003e在客户端刚启动时，就初始化一个全局的WebView待用，并隐藏；\u003c/li\u003e\u003cli\u003e当用户访问了WebView时，直接使用这个WebView加载对应网页，并展示。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这种方法可以比较有效的减少WebView在App中的首次打开时间。当用户访问页面时，不需要初始化WebView的时间。\u003c/p\u003e\u003cp\u003e当然这也带来了一些问题，包括：\u003c/p\u003e\u003cul\u003e\u003cli\u003e额外的内存消耗。\u003c/li\u003e\u003cli\u003e页面间跳转需要清空上一个页面的痕迹，更容易内存泄露。\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp\u003e【参考东软专利 - 加载网页的方法及装置 \u003ca href=\"https://www.google.com/patents/CN106250434A?cl=zh\"\u003eCN106250434A\u003c/a\u003e】\u003c/p\u003e\u003c/blockquote\u003e\u003ch4 id=\"客户端代理数据请求\"\u003e客户端代理数据请求\u003c/h4\u003e\u003cp\u003e方法：\u003c/p\u003e\u003cul\u003e\u003cli\u003e在客户端初始化WebView的同时，直接由native开始网络请求数据；\u003c/li\u003e\u003cli\u003e当页面初始化完成后，向native获取其代理请求的数据。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e此方法虽然不能减小WebView初始化时间，但数据请求和WebView初始化可以并行进行，总体的页面加载时间就缩短了；缩短总体的页面加载时间：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e【参考腾讯分享：\u003ca href=\"http://mp.weixin.qq.com/s/evzDnTsHrAr2b9jcevwBzA\"\u003e70%以上业务由H5开发，手机QQ Hybrid 的架构如何优化演进？\u003c/a\u003e】\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e还有其他各种优化的方式，不再一一列举，总结起来都是围绕两点：\u003c/p\u003e\u003col\u003e\u003cli\u003e在使用前预先初始化好WebView，从而减小耗时。\u003c/li\u003e\u003cli\u003e在初始化的同时，通过Native来完成一些网络请求等过程，使得WebView初始化不是完全的阻塞后续过程。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"建立连接-服务器处理\"\u003e建立连接/服务器处理\u003c/h2\u003e\u003cp\u003e在页面请求的数据返回之前，主要有以下过程耗费时间。\u003c/p\u003e\u003cul\u003e\u003cli\u003eDNS\u003c/li\u003e\u003cli\u003econnection\u003c/li\u003e\u003cli\u003e服务器处理\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"分析-1\"\u003e分析\u003c/h3\u003e\u003cp\u003e以下为美团中活动页面的链接时间统计：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e统计： 美团的活动页面\u003c/p\u003e\u003cp\u003e内容值： n%分位值（ms）\u003c/p\u003e\u003c/blockquote\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003eDNS\u003c/th\u003e\u003cth\u003econnection\u003c/th\u003e\u003cth\u003e获取首字节\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e50%\u003c/td\u003e\u003ctd\u003e1.3\u003c/td\u003e\u003ctd\u003e71\u003c/td\u003e\u003ctd\u003e172\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e90%\u003c/td\u003e\u003ctd\u003e60\u003c/td\u003e\u003ctd\u003e360\u003c/td\u003e\u003ctd\u003e541\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch3 id=\"优化\"\u003e优化\u003c/h3\u003e\u003cp\u003e这些时间都是发生在网页加载之前，但这并不意味着无法优化，有以下几种方法。\u003c/p\u003e\u003ch4 id=\"dns采用和客户端api相同的域名\"\u003eDNS采用和客户端API相同的域名\u003c/h4\u003e\u003cp\u003eDNS会在系统级别进行缓存，对于WebView的地址，如果使用的域名与native的API相同，则可以直接使用缓存的DNS而不用再发起请求图片。\u003c/p\u003e\u003cp\u003e以美团为例，美团的客户端请求域名主要位于api.meituan.com，然而内嵌的WebView主要位于 i.meituan.com。\u003c/p\u003e\u003cp\u003e当我们初次打开App时：\u003c/p\u003e\u003cul\u003e\u003cli\u003e客户端首次打开都会请求api.meituan.com，其DNS将会被系统缓存。\u003c/li\u003e\u003cli\u003e然而当打开WebView的时候，由于请求了不同的域名，需要重新获取i.meituan.com的IP。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e根据上面的统计，至少10%的用户打开WebView时耗费了60ms在DNS上面，如果WebView的域名与App的API域名统一，则\u003cstrong\u003e可以让WebView的DNS时间全部达到1.3ms的量级\u003c/strong\u003e。\u003c/p\u003e\u003cp\u003e静态资源同理，最好与客户端的资源域名保持一致。\u003c/p\u003e\u003ch4 id=\"同步渲染采用chunk编码\"\u003e同步渲染采用chunk编码\u003c/h4\u003e\u003cp\u003e同步渲染时如果后端请求时间过长，可以考虑采用chunk编码，将数据放在最后，并优先将静态内容flush。对于传统的后端渲染页面，往往都是使用的【浏览器】–\u0026gt; 【Web API】 –\u0026gt; 【业务 API】的加载模式，其中后端时间就指的是Web API的处理时间了。在这里Web API一般有两个作用：\u003c/p\u003e\u003col\u003e\u003cli\u003e确定静态资源的版本。\u003c/li\u003e\u003cli\u003e根据用户的请求，去业务API获取数据。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e而一般确定静态资源的版本往往是直接读取代码版本，基本无耗时；而主要的后端时间都花费在了业务API请求上面。\u003c/p\u003e\u003cp\u003e那么怎么优化利用这段时间呢？\u003c/p\u003e\u003cp\u003e在HTTP协议中，我们可以在header中设置 \u003ccode\u003etransfer-encoding:chunked\u003c/code\u003e 使得页面可以分块输出。如果合理设计页面，让head部分都是确定的静态资源版本相关内容，而body部分是业务数据相关内容，那么我们可以在用户请求的时候，首先将Web API可以确定的部分先输出给浏览器，然后等API完全获取后，再将API数据传输给浏览器。\u003c/p\u003e\u003cp\u003e下图可以直观的看出分chunk输出和一起输出的区别：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/4c33eae7.png\" alt=\"分chunk加载\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e如果采用普通方式输出页面，则页面会在服务器请求完所有API并处理完成后开始传输。浏览器要在后端所有API都加载完成后才能开始解析。\u003c/li\u003e\u003cli\u003e如果采用chunk-encoding: chunked，并优先将页面的静态部分输出；然后处理API请求，并最终返回页面，可以让后端的API请求和前端的资源加载同时进行。\u003c/li\u003e\u003cli\u003e两者的总共后端时间并没有区别，但是可以提升首字节速度，从而让前端加载资源和后端加载API不互相阻塞。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"页面框架渲染\"\u003e页面框架渲染\u003c/h2\u003e\u003cp\u003e页面在解析到足够多的节点，且所有CSS都加载完成后进行首屏渲染。在此之前，页面保持白屏；在页面完全下载并解析完成之前，页面处于不完整展示状态。\u003c/p\u003e\u003ch3 id=\"分析-2\"\u003e分析\u003c/h3\u003e\u003cp\u003e我们以一个美团的活动页面作为样例：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e测试页面：\u003ca href=\"http://i.meituan.com/firework/meituanxianshifengqiang\"\u003ehttp://i.meituan.com/firework/meituanxianshifengqiang\u003c/a\u003e\u003c/p\u003e\u003cp\u003e在Mac上面，模拟4G情况\u003c/p\u003e\u003cp\u003e页面样式：\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/322057fe.png\" alt=\"页面\"/\u003e\u003c/p\u003e\u003cp\u003e测试得到的时间耗费如下：\u003c/p\u003e\u003cp\u003e表1\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e阶段\u003c/th\u003e\u003cth\u003e时间\u003c/th\u003e\u003cth\u003e大小\u003c/th\u003e\u003cth\u003e备注\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eDOM下载\u003c/td\u003e\u003ctd\u003e58ms\u003c/td\u003e\u003ctd\u003e29.5 KB\u003c/td\u003e\u003ctd\u003e4G网络\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eDOM解析\u003c/td\u003e\u003ctd\u003e12.5ms\u003c/td\u003e\u003ctd\u003e198 KB\u003c/td\u003e\u003ctd\u003e根据估算，在手机上慢2~5倍不等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCSS请求+下载\u003c/td\u003e\u003ctd\u003e58ms\u003c/td\u003e\u003ctd\u003e11.7 KB\u003c/td\u003e\u003ctd\u003e4G网络（包含链接时间，CDN）\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCSS解析\u003c/td\u003e\u003ctd\u003e2.89ms\u003c/td\u003e\u003ctd\u003e54.1 KB\u003c/td\u003e\u003ctd\u003e根据估算，在手机上慢2~5倍不等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e渲染\u003c/td\u003e\u003ctd\u003e23ms\u003c/td\u003e\u003ctd\u003e1361节点\u003c/td\u003e\u003ctd\u003e根据估算，在手机上慢2~5倍不等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e绘制\u003c/td\u003e\u003ctd\u003e4.1ms\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003e根据估算，在手机上慢2~5倍不等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e合成\u003c/td\u003e\u003ctd\u003e0.23ms\u003c/td\u003e\u003ctd\u003e\u003c/td\u003e\u003ctd\u003eGPU处理\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e同时，对HTML的加载时间进行分析，可以得到如下时间点。\u003c/p\u003e\u003cp\u003e表2\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e指标\u003c/th\u003e\u003cth\u003e时间\u003c/th\u003e\u003cth\u003e计算方法\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eHTML加载完成时间\u003c/td\u003e\u003ctd\u003e218\u003c/td\u003e\u003ctd\u003eperformance.timing.responseEnd - performance.timing.fetchStart\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eHTML解析完成时间\u003c/td\u003e\u003ctd\u003e330\u003c/td\u003e\u003ctd\u003eperformance.timing.domInteractive - performance.timing.fetchStart\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch3 id=\"这意味着什么呢-1\"\u003e这意味着什么呢？\u003c/h3\u003e\u003ch4 id=\"对于表1\"\u003e对于表1\u003c/h4\u003e\u003cp\u003e可以看到，随着在网络优良的情况下，Dom的解析所占耗时比例还是不算低的，对于低端机器更甚。Layout时间也是首屏前耗时的大头，据猜测这与页面使用了rem作为单位有关（待进一步分析）。\u003c/p\u003e\u003ch4 id=\"对于表2-我们可以发现一个问题\"\u003e对于表2，我们可以发现一个问题\u003c/h4\u003e\u003cp\u003e一般来说HTML在开始接收到返回数据的时候就开始解析HTML并构建DOM树。如果没有JS（JavaScript）阻塞的话一般会相继完成。然而，在这里时间相差了90ms……也就是说，解析被阻塞了。\u003c/p\u003e\u003cp\u003e进一步分析可以发现，页面的header部分有这样的代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e.....\n\u0026lt;link href=\u0026#34;//ms0.meituan.net/css/eve.9d9eee71.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; onload=\u0026#34;MT.pageData.eveTime=Date.now()\u0026#34;/\u0026gt;\n\u0026lt;script\u0026gt;\nwindow.fk = function (callback) {\nrequire([\u0026#39;util/native/risk.js\u0026#39;], function (risk) {\n    risk.getFk(callback);\n});\n}\n\u0026lt;/script\u0026gt;\n\u0026lt;/head\u0026gt;\n....\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通常情况下，上面代码的link部分和script部分如果单独出现，都不会阻塞页面的解析：\u003c/p\u003e\u003cul\u003e\u003cli\u003eCSS不会阻止页面继续向下继续。\u003c/li\u003e\u003cli\u003e内联的JS很快执行完成，然后继续解析文档。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e然而，当这两部分同时出现的时候，问题就来了。\u003c/p\u003e\u003cul\u003e\u003cli\u003eCSS加载阻塞了下面的一段内联JS的执行，而被阻塞的内联JS则阻塞了HTML的解析。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e通常情况下，CSS不会阻塞HTML的解析，但如果CSS后面有JS，则会阻塞JS的执行直到CSS加载完成（即便JS是内联的脚本），从而间接阻塞HTML的解析。\u003c/p\u003e\u003ch3 id=\"优化-1\"\u003e优化\u003c/h3\u003e\u003cp\u003e在页面框架加载这一部分，能够优化的点参照\u003ca href=\"https://stevesouders.com/hpws/rules.php\"\u003e雅虎14条\u003c/a\u003e就够了；但注意不要犯错，一个小小的内联JS放错位置也会让性能下降很多。\u003c/p\u003e\u003col\u003e\u003cli\u003eCSS的加载会在HTML解析到CSS的标签时开始，所以CSS的标签要尽量靠前。\u003c/li\u003e\u003cli\u003e但是，CSS链接下面不能有任何的JS标签（包括很简单的内联JS），否则会阻塞HTML的解析。\u003c/li\u003e\u003cli\u003e如果必须要在头部增加内联脚本，一定要放在CSS标签之前。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/fef19af0.png\" alt=\"CSS带来的阻塞解析\"/\u003e\u003c/p\u003e\u003ch2 id=\"js加载\"\u003eJS加载\u003c/h2\u003e\u003cp\u003e对于大型的网站来说，在此我们先提出几个问题：\u003c/p\u003e\u003cul\u003e\u003cli\u003e将全部JS代码打成一个包，造成首次执行代码过大怎么办？\u003c/li\u003e\u003cli\u003e将JS以细粒度打包，造成请求过多怎么办？\u003c/li\u003e\u003cli\u003e将JS按 “基础库” + “页面代码” 分别打包，要怎么界定什么是基础代码，什么是页面代码；不同页面用的基础代码不一致怎么办？\u003c/li\u003e\u003cli\u003e单一文件的少量代码改的是否会导致缓存失效？\u003c/li\u003e\u003cli\u003e代码模块间有动态依赖，怎样合并请求。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e关于这些问题的解决方案数量可能会比问题还多，而它们也各有优劣。\u003c/p\u003e\u003cp\u003e具体分析太过复杂，鉴于篇幅原因在这里不做具体分析了。您可以期待我们的后续计划：BPM（浏览器包管理）。\u003c/p\u003e\u003ch2 id=\"js解析-编译-执行\"\u003eJS解析、编译、执行\u003c/h2\u003e\u003cp\u003e在PC互联网时代，人们似乎都快忘记了JS的解析和执行还需要消耗时间。确实，在几年前网速还在用kb衡量的时代里，JS的解析时间在整个页面的打开时间里只能算是九牛一毛。\u003c/p\u003e\u003cp\u003e然而，随着网速越来越快，而CPU的速度反而没有提升（从PC到手机），JS的时间开销就成为问题了。那么JS的编译和解析，在当今的页面上要消耗多少时间呢？\u003c/p\u003e\u003ch3 id=\"分析-3\"\u003e分析\u003c/h3\u003e\u003cp\u003e我们用以下方式来检验JS代码的解析/编译和执行时间：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;script\u0026gt;\n    window.t1 = performance.now()\n\u0026lt;/script\u0026gt;\n\u0026lt;script\u0026gt;\n    window.test = function () {\n        // test code\n    }\n\u0026lt;/script\u0026gt;\n\u0026lt;script\u0026gt;\n    window.t2 = performance.now()\n    test();\n    window.t3 = performance.now();\n     \n    alert(\u0026#34;编译耗时：\u0026#34; + (t2 - t1));\n    alert(\u0026#34;执行耗时：\u0026#34; + (t3 - t2));\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将测试代码放入 【test code】 位置，然后在手机中执行；\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e在t1~t2期间，JS代码仅仅声明了一个函数，主要时间会集中在解析和编译过程；\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e在t2~t3时间段内，执行test时时间主要为代码的执行时间\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在首次启动客户端后，打开WebView的测试页面，我们可以得到如下的结果：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e测试系统： iPhone6 iOS 10.2.1\u003c/p\u003e\u003cp\u003e测试系统： OPPO R829T Android 4.2.2\u003c/p\u003e\u003cp\u003e内容值： 编译时间（ms）/执行时间（ms）\u003c/p\u003e\u003c/blockquote\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e系统\u003c/th\u003e\u003cth\u003eZepto.js\u003c/th\u003e\u003cth\u003eVue.js\u003c/th\u003e\u003cth\u003eReact.js + ReactDOM.js\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eiOS\u003c/td\u003e\u003ctd\u003e5.2 / 8\u003c/td\u003e\u003ctd\u003e12.8 / 16.1\u003c/td\u003e\u003ctd\u003e13.7 / 43.3\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAndroid\u003c/td\u003e\u003ctd\u003e13 / 40\u003c/td\u003e\u003ctd\u003e43 / 127\u003c/td\u003e\u003ctd\u003e26 / 353\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e当保持客户端进行不关闭情况下，关闭WebView并重新访问测试页面，再次测试得到如下结果：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e系统\u003c/th\u003e\u003cth\u003eZepto.js\u003c/th\u003e\u003cth\u003eVue.js\u003c/th\u003e\u003cth\u003eReact.js + ReactDom.js\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eiOS\u003c/td\u003e\u003ctd\u003e0.9 / 1.9\u003c/td\u003e\u003ctd\u003e5 / 7.4\u003c/td\u003e\u003ctd\u003e3.5 / 23\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAndroid\u003c/td\u003e\u003ctd\u003e5 / 9\u003c/td\u003e\u003ctd\u003e17 / 12\u003c/td\u003e\u003ctd\u003e25 / 60\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e执行时间指的是框架代码加载的页面的初始化时间，没有任何业务的调用。\u003c/p\u003e\u003ch3 id=\"这意味着什么\"\u003e这意味着什么\u003c/h3\u003e\u003cp\u003e经过测试可以得出以下结论：\n* 偏重的框架，例如React，仅仅初始化的时间就会达到50ms ~ 350ms，这在对性能敏感的业务中时比较不利的。\n* 在App的启动周期内，统一域名下的代码会被缓存编辑和初始化结果，重复调用性能较好。\u003c/p\u003e\u003cp\u003e所以，在移动浏览器上，JS的解析和执行时间并不是不可忽略的。\u003c/p\u003e\u003cp\u003e在低端安卓机上，（框架的初始化+异步数据请求+业务代码执行）会远高于几KB网络请求时间；高性能的Web网站需要仔细斟酌前端渲染带来的性能问题。\u003c/p\u003e\u003ch3 id=\"优化-2\"\u003e优化\u003c/h3\u003e\u003cul\u003e\u003cli\u003e高性能要求页面还是需要后端渲染。\u003c/li\u003e\u003cli\u003eReact还是太重了，面向用户写系统需要谨慎考虑。\u003c/li\u003e\u003cli\u003eJS代码的编译和执行会有缓存，同App中网页尽量统一框架。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"webview性能优化总结\"\u003eWebView性能优化总结\u003c/h2\u003e\u003cp\u003e一个加载网页的过程中，native、网络、后端处理、CPU都会参与，各自都有必要的工作和依赖关系；让他们相互并行处理而不是相互阻塞才可以让网页加载更快：\u003c/p\u003e\u003cul\u003e\u003cli\u003eWebView初始化慢，可以在初始化同时先请求数据，让后端和网络不要闲着。\u003c/li\u003e\u003cli\u003e后端处理慢，可以让服务器分trunk输出，在后端计算的同时前端也加载网络静态资源。\u003c/li\u003e\u003cli\u003e脚本执行慢，就让脚本在最后运行，不阻塞页面解析。\u003c/li\u003e\u003cli\u003e同时，合理的预加载、预缓存可以让加载速度的瓶颈更小。\u003c/li\u003e\u003cli\u003eWebView初始化慢，就随时初始化好一个WebView待用。\u003c/li\u003e\u003cli\u003eDNS和链接慢，想办法复用客户端使用的域名和链接。\u003c/li\u003e\u003cli\u003e脚本执行慢，可以把框架代码拆分出来，在请求页面之前就执行好。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"分析-4\"\u003e分析\u003c/h3\u003e\u003cp\u003e为了测试WebView会消耗多少内存，我们设计了如下的测试方案：\u003c/p\u003e\u003col\u003e\u003cli\u003e客户端启动后，记录消耗的内存。\u003c/li\u003e\u003cli\u003e打开空页面，记录内存的上涨。\u003c/li\u003e\u003cli\u003e退出。\u003c/li\u003e\u003cli\u003e打开空页面，记录内存上涨。\u003c/li\u003e\u003cli\u003e退出。\u003c/li\u003e\u003cli\u003e打开加载了代码的页面，记录内存的额外增加。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e得到如下测试结果：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e测试系统： iOS模拟器，Titans 10.0.7\u003c/p\u003e\u003cp\u003e测试系统： OPPO R829T Android 4.2.2\u003c/p\u003e\u003cp\u003e测试方式：测试10次取平均值\u003c/p\u003e\u003c/blockquote\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003e首次打开增加内存\u003c/th\u003e\u003cth\u003e二次打开增加内存\u003c/th\u003e\u003cth\u003e加载KNB+VUE+灵犀\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eiOS UIWebView\u003c/td\u003e\u003ctd\u003e31.1M\u003c/td\u003e\u003ctd\u003e5.52M\u003c/td\u003e\u003ctd\u003e2M\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eiOS WKWebView\u003c/td\u003e\u003ctd\u003e1.95M\u003c/td\u003e\u003ctd\u003e1.6M\u003c/td\u003e\u003ctd\u003e2M\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAndroid\u003c/td\u003e\u003ctd\u003e32.2M\u003c/td\u003e\u003ctd\u003e6.62M\u003c/td\u003e\u003ctd\u003e1.7M\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eWKWebView的内存消耗相比其他低了一个数量级，在此方面相当占优。\u003c/p\u003e\u003cp\u003eUIWebView和Android的WebView在首次初始化时都要消耗大量内存，之后每次新建WebView会额外增加一些。\u003c/p\u003e\u003cp\u003eUIWebView的内存占用不会在关闭WebView时主动回收，每次新开WebView都会消耗额外内存。\u003c/p\u003e\u003cp\u003e相比于性能，对于内存的优化可以做的还是比较有限的。\u003c/p\u003e\u003cul\u003e\u003cli\u003eWKWebView的内存占用优势比较大（代价是初始化比较慢）。\u003c/li\u003e\u003cli\u003e页面内代码消耗的内存相比与WebView系统的内存消耗相比可以说是很低。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e除了打开的速度，WebView通常体验也没有native的实现更好，我们可以找到以下几个例子：\u003c/p\u003e\u003ch3 id=\"长按选择\"\u003e长按选择\u003c/h3\u003e\u003cp\u003e在WebView中，长按文字会使得WebView默认开始选择文字；长按链接会弹出提示是否在新页面打开。\u003c/p\u003e\u003cp\u003e解决方法：可以通过给body增加CSS来禁止这些默认规则。\u003c/p\u003e\u003ch3 id=\"点击延迟\"\u003e点击延迟\u003c/h3\u003e\u003cp\u003e在WebView中，click通常会有大约300ms的延迟（同时包括链接的点击，表单的提交，控件的交互等任何用户点击行为）。\u003c/p\u003e\u003cp\u003e唯一的例外是设置的meta：viewpoint为禁止缩放的Chrome（然而并不是Android默认的浏览器）。\u003c/p\u003e\u003cp\u003e解决方法：使用fastclick一般可以解决这个问题。\u003c/p\u003e\u003ch3 id=\"页面滑动期间不渲染-执行\"\u003e页面滑动期间不渲染/执行\u003c/h3\u003e\u003cp\u003e在很多需求中会有一些吸顶的元素，例如导航条，购买按钮等；当页面滚动超出元素高度后，元素吸附在屏幕顶部。\u003c/p\u003e\u003cp\u003e这个功能在PC和native中都能够实现，然而在WebView中却成了难题：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e 在页面滚动期间，Scroll Event不触发\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e不仅如此，WebView在滚动期间还有各种限定：\u003c/p\u003e\u003cul\u003e\u003cli\u003esetTimeout和setInterval不触发。\u003c/li\u003e\u003cli\u003eGIF动画不播放。\u003c/li\u003e\u003cli\u003e很多回调会延迟到页面停止滚动之后。\u003c/li\u003e\u003cli\u003ebackground-position: fixed不支持。\u003c/li\u003e\u003cli\u003e这些限制让WebView在滚动期间很难有较好的体验。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这些限制大部分是不可突破的，但至少对于吸顶功能还是可以做一些支持：\u003c/p\u003e\u003cp\u003e解决方法：\u003c/p\u003e\u003cul\u003e\u003cli\u003e在iOS上，使用position: sticky可以做到元素吸顶。\u003c/li\u003e\u003cli\u003e在Android上，监听touchmove事件可以在滑动期间做元素的position切换（惯性运动期间就无效了）。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"crash\"\u003ecrash\u003c/h3\u003e\u003cp\u003e通常WebView并不能直接接触到底层的API，因此比较稳定；但仍然有使用不当造成整个App崩溃的情况。\u003c/p\u003e\u003cp\u003e目前发现的案例包括：\u003c/p\u003e\u003cul\u003e\u003cli\u003e使用过大的图片（2M）\u003c/li\u003e\u003cli\u003e不正常使用WebGL\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"webview被运营商劫持-注入问题\"\u003eWebView被运营商劫持、注入问题\u003c/h2\u003e\u003cp\u003e由于WebView加载的页面代码是从服务器动态获取的，这些代码将会很容易被中间环节所窃取或者修改，其中最主要的问题出自地方运营商（浙江尤其明显）和一些WiFi。\u003c/p\u003e\u003cp\u003e我们监测到的问题包括：\u003c/p\u003e\u003cul\u003e\u003cli\u003e无视通信规则强制缓存页面。\u003c/li\u003e\u003cli\u003eheader被篡改。\u003c/li\u003e\u003cli\u003e页面被注入广告。\u003c/li\u003e\u003cli\u003e页面被重定向。\u003c/li\u003e\u003cli\u003e页面被重定向并重新iframe到新页面，框架嵌入广告。\u003c/li\u003e\u003cli\u003eHTTPS请求被拦截。\u003c/li\u003e\u003cli\u003eDNS劫持。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这些问题轻则影响用户体验，重则泄露数据，或影响公司信誉。\u003c/p\u003e\u003cp\u003e针对页面注入的行为，有一些解决方案：\u003c/p\u003e\u003ch5 id=\"使用csp-content-security-policy\"\u003e使用CSP（Content Security Policy）\u003c/h5\u003e\u003cp\u003eCSP可以有效的拦截页面中的非白名单资源，而且兼容性较好。在美团移动版的使用中，能够阻止大部分的页面内容注入。\u003c/p\u003e\u003cp\u003e但在使用中还是存在以下问题：\u003c/p\u003e\u003cul\u003e\u003cli\u003e由于业务的需要，通常inline脚本还是在白名单中，会导致完全依赖内联的页面代码注入可以通过检测。\u003c/li\u003e\u003cli\u003e如果注入的内容是纯HTML+CSS的内容，则CSP无能为力。\u003c/li\u003e\u003cli\u003e无法解决页面被劫持的问题。\u003c/li\u003e\u003cli\u003e会带来额外的一些维护成本。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e总体来说CSP是一个行之有效的防注入方案，但是如果对于安全要求更高的网站，这些还不够。\u003c/p\u003e\u003ch4 id=\"https\"\u003eHTTPS\u003c/h4\u003e\u003cp\u003eHTTPS可以防止页面被劫持或者注入，然而其副作用也是明显的，网络传输的性能和成功率都会下降，而且HTTPS的页面会要求页面内所有引用的资源也是HTTPS的，对于大型网站其迁移成本并不算低。\u003c/p\u003e\u003cp\u003eHTTPS的一个问题在于：一旦底层想要篡改或者劫持，会导致整个链接失效，页面无法展示。这会带来一个问题：本来页面只是会被注入广告，而且广告会被CSP拦截，而采用了HTTPS后，整个网页由于受到劫持完全无法展示。\u003c/p\u003e\u003cp\u003e对于安全要求不高的静态页面，就需要权衡HTTPS带来的利与弊了。\u003c/p\u003e\u003ch4 id=\"app使用socket代理请求\"\u003eApp使用Socket代理请求\u003c/h4\u003e\u003cp\u003e如果HTTP请求容易被拦截，那么让App将其转换为一个Socket请求，并代理WebView的访问也是一个办法。\u003c/p\u003e\u003cp\u003e通常不法运营商或者WiFi都只能拦截HTTP（S）请求，对于自定义的包内容则无法拦截，因此可以基本解决注入和劫持的问题。\u003c/p\u003e\u003cp\u003eSocket代理请求也存在问题。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e首先，使用客户端代理的页面HTML请求将丧失边下载边解析的能力；根据前面所述，浏览器在HTML收到部分内容后就立刻开始解析，并加载解析出来的外链、图片等，执行内联的脚本……而目前WebView对外并没有暴露这种流式的HTML接口，只能由客户端完全下载好HTML后，注入到WebView中。因此其性能将会受到影响。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e其次，其技术问题也是较多的，例如对跳转的处理，对缓存的处理，对CDN的处理等等……稍不留神就会埋下若干大坑。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e此外还有一些其他的办法，例如页面的MD5检测，页面静态页打包下载等等方式，具体如何选择还要根据具体的场景抉择。\u003c/p\u003e\u003ch2 id=\"客户端内打开第三方webview\"\u003e客户端内打开第三方WebView\u003c/h2\u003e\u003cp\u003e一般来说，客户端内的WebView都是可以通过客户端的某个schema打开的，而要打开页面的URL很多都并不写在客户端内，而是可以由URL中的参数传递过去的。\u003c/p\u003e\u003cp\u003e那么，一旦此URL可以通过外界输入自定义，那么就有可能在客户端内部打开一个外部的网页。\u003c/p\u003e\u003cp\u003e例：作案过程\u003c/p\u003e\u003cul\u003e\u003cli\u003e某个App有个WebView，打开的schema为 appxx://web?url={weburl}。\u003c/li\u003e\u003cli\u003eApp中有个扫码的功能，可以扫描某个二维码并打开对应的schema链接。\u003c/li\u003e\u003cli\u003e某个坏人制作了一个二维码并张贴到街上，内容符合 ： appxx://web?url={some_hack_weburl}。\u003c/li\u003e\u003cli\u003e用户扫码打开了some_hack_weburl。\u003c/li\u003e\u003cli\u003e如果some_hack_weburl是一个高仿的登录页面，那么用户将会很可能将用户名密码提交到其他网站。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e解决方法：在内嵌的WebView中应该限制允许打开的WebView的域名，并设置运行访问的白名单。或者当用户打开外部链接前给用户强烈而明显的提示。\u003c/p\u003e\u003cp\u003e在一个客户端内，native目前主要功能是提供高效而基础的功能；内部的WebView则添加一些性能体验要求不高但动态化要求高的能力。\u003c/p\u003e\u003cp\u003e提高客户端的动态能力，或者提高WebView的性能，都是提升App功能覆盖的方式。\u003c/p\u003e\u003cp\u003e而目前的各种框架，ReactNative、Week包括微信小程序，都是这个趋势的尝试。\u003c/p\u003e\u003cp\u003e随着技术的发展，WebView的性能、体验和安全问题也将会逐渐的改善，在App中占有越来越多比重的同时，也将会为App开拓新的能力，为用户带来更优质的体验。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/fef78e6d.png\" alt=\"dest\"/\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-06-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}