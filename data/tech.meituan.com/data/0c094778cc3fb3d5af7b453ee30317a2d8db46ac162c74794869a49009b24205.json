{
  "Source": "tech.meituan.com",
  "Title": "ReactiveCocoa中潜在的内存泄漏及解决方案",
  "Link": "https://tech.meituan.com/2016/08/19/potential-memory-leak-in-reactivecocoa.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e\u003ca href=\"http://www.github.com/ReactiveCocoa/ReactiveCocoa\"\u003eReactiveCocoa\u003c/a\u003e是\u003ca href=\"https://github.com/\"\u003eGitHub\u003c/a\u003e开源的一个函数响应式编程框架，目前在美团App中大量使用。用过它的人都知道很好用，也确实为我们的生活带来了很多便利，特别是跟MVVM模式结合使用，更是如鱼得水。不过刚开始使用的时候，可能容易疏忽掉一些隐藏的细节，从而导致内存泄漏等问题。本文就带大家深入了解下ReactiveCocoa中隐藏的一些细节，帮助大家以更加正确的姿势使用ReactiveCocoa。\u003c/p\u003e\u003cp\u003e以下代码和示例基于\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/releases/tag/v2.5\"\u003eReactiveCocoa v2.5\u003c/a\u003e。\u003c/p\u003e\u003ch2 id=\"racobserve引发的血案\"\u003eRACObserve引发的血案\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/NSObject%2BRACPropertySubscribing.h\"\u003eRACObserve\u003c/a\u003e是ReactiveCocoa中一个相当常用也相当好用的宏，它可以用来监听属性值的改变，然后传递给订阅者。不过在使用的时候有一点需要稍微注意一下，为了直观说明，先上一个小Demo。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) { //1\n        MTModel *model = [[MTModel alloc] init]; // MTModel有一个名为的title的属性\n        [subscriber sendNext:model];\n        [subscriber sendCompleted];\n        return nil;\n    }];\n    self.flattenMapSignal = [signal flattenMap:^RACStream *(MTModel *model) { //2\n        return RACObserve(model, title);\n    }];\n    [self.flattenMapSignal subscribeNext:^(id x) { //3\n        NSLog(@\u0026#34;subscribeNext - %@\u0026#34;, x);\n    }];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\u003cli\u003e创建一个signal，该signal被订阅后会发送一个MTModel的实例；\u003c/li\u003e\u003cli\u003e对第一步创建的signal进行flattenMap操作，并将返回的信号保留（之所以要保留，是因为可能希望在其它地方订阅，不过这里为了简单，就直接在第三步进行订阅）；\u003c/li\u003e\u003cli\u003e对第二步产生的信号（self.flattenMapSignal）进行订阅。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e这段代码看起来很正常，工作也相当良好，但是当从添加了这段代码的控制器返回时，控制器并没有被释放。这又是为啥呢？看下RACObserve的定义：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#define RACObserve(TARGET, KEYPATH) \\\n\t({ \\\n\t\t_Pragma(\u0026#34;clang diagnostic push\u0026#34;) \\\n\t\t_Pragma(\u0026#34;clang diagnostic ignored \\\u0026#34;-Wreceiver-is-weak\\\u0026#34;\u0026#34;) \\\n\t\t__weak id target_ = (TARGET); \\\n\t\t[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n\t\t_Pragma(\u0026#34;clang diagnostic pop\u0026#34;) \\\n\t})\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意这一句：\u003ccode\u003e[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self];\u003c/code\u003e\n如果将宏简单展开就变成了下面这样：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id \u0026lt; RACSubscriber \u0026gt; subscriber) { //1\n        GJModel *model = [[GJModel alloc] init];\n        [subscriber sendNext:model];\n        [subscriber sendCompleted];\n        return nil;\n    }]; \n    self.flattenMapSignal = [signal flattenMap:^RACStream *(GJModel *model) {//2\n        __weak GJModel *target_ = model;\n        return [target_ rac_valuesForKeyPath:@keypath(target_, title) observer:self];\n    }];\n    [self.flattenMapSignal subscribeNext:^(id x) {//3\n        NSLog(@\u0026#34;subscribeNext - %@\u0026#34;, x);\n    }];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看到这里，应该发现哪里不对了吧？没错，flattenMap操作接收的block里面出现了self，对self进行了持有，而flattenMap操作返回的信号又由self的属性flattenMapSignal进行了持有，这就造成了循环引用。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/9992a927.png\" alt=\"Alt text\"/\u003e\u003c/p\u003e\u003cp\u003e注意：2是间接持有，从逻辑上来讲，flattenMapSignal会有一个didSubscribeBlock，为了让传递给flattenMap操作的block有意义，didSubscribeBlock会对该block进行持有，从而也就间接持有了self，感兴趣的读者可以去看下相关源码。\u003c/p\u003e\u003cp\u003eOK，找到了问题所在，解决起来也就简单了，使用@weakify和@strongify即可：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id \u0026lt; RACSubscriber \u0026gt; subscriber) {\n        GJModel *model = [[GJModel alloc] init];\n        [subscriber sendNext:model];\n        [subscriber sendCompleted];\n        return nil;\n    }];\n    @weakify(self); //\n    self.signal = [signal flattenMap:^RACStream *(GJModel *model) {\n        @strongify(self); //\n        return RACObserve(model, title);\n    }];\n    [self.signal subscribeNext:^(id x) {\n        NSLog(@\u0026#34;subscribeNext - %@\u0026#34;, x);\n    }];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里之所以容易疏忽，是因为在block里没有很直观的看到self，但是RACObserve的定义里面却用到了self。\n其实RACObserve的解释中已经很明确地说明了这个问题。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/// Creates a signal which observes `KEYPATH` on `TARGET` for changes.\n///\n/// In either case, the observation continues until `TARGET` _or self_ is\n/// deallocated. If any intermediate object is deallocated instead, it will be\n/// assumed to have been set to nil.\n///\n/// Make sure to `@strongify(self)` when using this macro within a block! The\n/// macro will _always_ reference `self`, which can silently introduce a retain\n/// cycle within a block. As a result, you should make sure that `self` is a weak\n/// reference (e.g., created by `@weakify` and `@strongify`) before the\n/// expression that uses `RACObserve`.\n///\n/// Examples\n///\n///    // Observes self, and doesn\u0026#39;t stop until self is deallocated.\n///    RACSignal *selfSignal = RACObserve(self, arrayController.items);\n///\n///    // Observes the array controller, and stops when self _or_ the array\n///    // controller is deallocated.\n///    RACSignal *arrayControllerSignal = RACObserve(self.arrayController, items);\n///\n///    // Observes obj.arrayController, and stops when self _or_ the array\n///    // controller is deallocated.\n///    RACSignal *signal2 = RACObserve(obj.arrayController, items);\n///\n///    @weakify(self);\n///    RACSignal *signal3 = [anotherSignal flattenMap:^(NSArrayController *arrayController) {\n///        // Avoids a retain cycle because of RACObserve implicitly referencing\n///        // self.\n///        @strongify(self);\n///        return RACObserve(arrayController, items);\n///    }];\n///\n/// Returns a signal which sends the current value of the key path on\n/// subscription, then sends the new value every time it changes, and sends\n/// completed if self or observer is deallocated.\n#define RACObserve(TARGET, KEYPATH) \\\n\t({ \\\n\t\t_Pragma(\u0026#34;clang diagnostic push\u0026#34;) \\\n\t\t_Pragma(\u0026#34;clang diagnostic ignored \\\u0026#34;-Wreceiver-is-weak\\\u0026#34;\u0026#34;) \\\n\t\t__weak id target_ = (TARGET); \\\n\t\t[target_ rac_valuesForKeyPath:@keypath(TARGET, KEYPATH) observer:self]; \\\n\t\t_Pragma(\u0026#34;clang diagnostic pop\u0026#34;) \\\n\t})\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过这个例子，相信你已经知道了RACObserve的正确使用姿势，也意识到了阅读文档的重要性。\n如果说RACObserve潜在的内存泄漏只要稍加留意，使用的时候查看下文档就能避免；那么下面的情况，就相当隐蔽了，就算是看了文档也不一定能看出来。\n不信？接着往下看。\u003c/p\u003e\u003ch2 id=\"racsubject带来的悲剧\"\u003eRACSubject带来的悲剧\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/RACSubject.h\"\u003eRACSubject\u003c/a\u003e是非RAC到RAC的一个桥梁，使用起来也很简单方便，基本的用法如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad {\n    [super viewDidLoad];\n    RACSubject *subject = [RACSubject subject]; //1\n\t[subject.rac_willDeallocSignal subscribeCompleted:^{ //2\n        NSLog(@\u0026#34;subject dealloc\u0026#34;);\n    }];\n    [subject subscribeNext:^(id x) { //3\n        NSLog(@\u0026#34;next = %@\u0026#34;, x);\n    }];\n    [subject sendNext:@1]; //4\n}\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\u003cli\u003e创建一个RACSubject的实例；\u003c/li\u003e\u003cli\u003e订阅subject的dealloc信号，在subject被释放的时候会发送完成信号；\u003c/li\u003e\u003cli\u003e订阅subject；\u003c/li\u003e\u003cli\u003e使用subject发送一个值。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e接下来看一下输出的结果：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e2016-06-13 09:15:25.426 RAC[5366:245360] next = 1\n2016-06-13 09:15:25.428 RAC[5366:245360] subject dealloc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e工作相当良好，接下来改造下程序，要求对subject发送的所有值进行乘3，这用map很容易就实现了。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad {\n    [super viewDidLoad];\n    RACSubject *subject = [RACSubject subject]; \n    [subject.rac_willDeallocSignal subscribeCompleted:^{ \n        NSLog(@\u0026#34;subject dealloc\u0026#34;);\n    }];\n    \n    [[subject map:^id(NSNumber *value) { \n        return @([value integerValue] * 3);\n    }] subscribeNext:^(id x) { \n        NSLog(@\u0026#34;next = %@\u0026#34;, x);\n    }];\n    [subject sendNext:@1]; \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e跟之前大体不变，只是对subject进行了map操作然后再订阅，看下输出结果：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e2016-06-13 09:21:42.450 RAC[5404:248584] next = 3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e的确是进行了乘3操作，符合预期，但是这里有一个很严重的问题，subject dealloc没有输出，也就是说subject没有释放。\n这不科学啊！subject看上去没有被任何对象持有。\n那究竟是什么情况？下面我们将RACSubject换成\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/RACSignal.h\"\u003eRACSignal\u003c/a\u003e试试：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad {\n    [super viewDidLoad];\n    RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) {\n        [subscriber sendNext:@1];\n        return nil;\n    }];\n    [signal.rac_willDeallocSignal subscribeCompleted:^{\n        NSLog(@\u0026#34;signal dealloc\u0026#34;);\n    }];\n    [[signal map:^id(NSNumber *value) {\n        return @([value integerValue] * 3);\n    }] subscribeNext:^(id x) {\n        NSLog(@\u0026#34;next = %@\u0026#34;, x);\n    }];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e逻辑跟之前一样，看一下输出结果：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e2016-06-12 23:32:31.669 RACDemo[5085:217082] next = 3\n2016-06-12 23:32:31.674 RACDemo[5085:217082] signal dealloc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e很明显，signal被释放了。同样的逻辑，signal能正常释放，subject却不能正常释放，太神奇了！\n细心的读者看到这里，应该会发现一个问题：上面的几次试验，不管是RACSubject还是RACSignal都没有调用sendCompleted。\n难道跟这个有关系？带着这个疑问，再进行如下试验，给RACSubject发送一个完成信号：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (void)viewDidLoad {\n    [super viewDidLoad];\n    RACSubject *subject = [RACSubject subject]; \n    [subject.rac_willDeallocSignal subscribeCompleted:^{ \n        NSLog(@\u0026#34;subject dealloc\u0026#34;);\n    }];\n    \n    [[subject map:^id(NSNumber *value) { \n        return @([value integerValue] * 3);\n    }] subscribeNext:^(id x) { \n        NSLog(@\u0026#34;next = %@\u0026#34;, x);\n    }];\n    [subject sendNext:@1]; \n    [subject sendCompleted];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e输出结果：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e2016-06-12 23:40:19.148 RAC_bindSample[5168:221902] next = 3\n2016-06-12 23:40:19.153 RAC_bindSample[5168:221902] subject dealloc\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003esubject被释放了，确实修正了内存泄漏问题。到这里，我们可以得出结论：\n使用RACSubject，如果进行了map操作，那么一定要发送完成信号，不然会内存泄漏。\u003c/p\u003e\u003cp\u003e虽然得出了结论，但是留下的疑问也是不少，如果你希望知道这其中的缘由，请继续往下看。\n简单来说，留下的疑问有：\u003c/p\u003e\u003col\u003e\u003cli\u003e为什么对RACSubject的实例进行map操作之后会产生内存泄漏？\u003c/li\u003e\u003cli\u003e为什么RACSignal不管是否有map操作，都不会产生内存泄漏？\u003c/li\u003e\u003cli\u003e针对第一个问题，为什么发送完成可以修复内存泄漏？\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e带着疑问，咱们继续一探究竟。\n讲道理，\u003ccode\u003eRACSignal\u003c/code\u003e和\u003ccode\u003eRACSubject\u003c/code\u003e虽然都是信号，但是它们有一个本质的区别：\n\u003cstrong\u003eRACSubject会持有订阅者（因为RACSubject是热信号，为了保证未来有事件发送的时候，订阅者可以收到信息，所以需要对订阅者保持状态，做法就是持有订阅者），而RACSignal不会持有订阅者。\u003c/strong\u003e\n关于这一点，更详细的说明请看\u003ca href=\"http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html\"\u003e《细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号》\u003c/a\u003e。\n那么持不持有订阅者，跟内存无法释放又有啥关系呢？不急，先记着有这样一个特性，咱们看看实现。\u003c/p\u003e\u003cp\u003e从上面提出第一个问题可以发现，关键点在于map操作，那么map操作究竟干了什么事情，看下map的实现：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- (instancetype)map:(id (^)(id value))block {\n\tNSCParameterAssert(block != nil);\n\tClass class = self.class;\n\t\n\treturn [[self flattenMap:^(id value) {\n\t\treturn [class return:block(value)];\n\t}] setNameWithFormat:@\u0026#34;[%@] -map:\u0026#34;, self.name];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e很简单，只是调用了一下flattenMap，再看下flattenMap怎么实现的：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e - (instancetype)flattenMap:(RACStream * (^)(id value))block {\n\tClass class = self.class;\n\treturn [[self bind:^{\n\t\treturn ^(id value, BOOL *stop) {\n\t\t\tid stream = block(value) ?: [class empty];\n\t\t\tNSCAssert([stream isKindOfClass:RACStream.class], @\u0026#34;Value returned from -flattenMap: is not a stream: %@\u0026#34;, stream);\n\t\t\treturn stream;\n\t\t};\n\t}] setNameWithFormat:@\u0026#34;[%@] -flattenMap:\u0026#34;, self.name];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e也很简单，只是调用了一下bind，再看看bind的实现，bind的实现位于RACSignal.m的92行左右。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e - (RACSignal *)bind:(RACStreamBindBlock (^)(void))block {\n\tNSCParameterAssert(block != NULL);\n\t/*\n\t * -bind: should:\n\t * \n\t * 1. Subscribe to the original signal of values.\n\t * 2. Any time the original signal sends a value, transform it using the binding block.\n\t * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they\u0026#39;re received.\n\t * 4. If the binding block asks the bind to terminate, complete the _original_ signal.\n\t * 5. When _all_ signals complete, send completed to the subscriber.\n\t * \n\t * If any signal sends an error at any point, send that to the subscriber.\n\t */\n\treturn [[RACSignal createSignal:^(id\u0026lt;RACSubscriber\u0026gt; subscriber) {\n\t\tRACStreamBindBlock bindingBlock = block();\n\t\tNSMutableArray *signals = [NSMutableArray arrayWithObject:self];\n\t\t// 此处省略了80行代码\n\t\t// ...\n\t}] setNameWithFormat:@\u0026#34;[%@] -bind:\u0026#34;, self.name];\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果你下载了源代码（不想下源码的话，也可以\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/RACSignal.m\"\u003e在线查看\u003c/a\u003e），并且看到了这里，相信你的感觉一定是一脸懵逼的，不要激动，虽然这个方法很长，看上去也不那么好懂，但是关键点就那么几个地方，掌握了关键点就基本能get了。\nReactiveCocoa的作者更是罕见地在实现文件了写了一大段注释来说明bind方法的用途，根据作者的注释再去理解这个方法会轻松很多。\n这里贴一个图，方便大家理解：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/287d7a18.png\" alt=\"Alt text\"/\u003e\u003c/p\u003e\u003cp\u003eOK，了解了bind操作的用途，也是时候回归主题了——内存是怎么泄露的。\n首先我们看到，在didSubscribe的开头，就创建了一个数组signals，并且持有了self，也就是源信号：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eNSMutableArray *signals = [NSMutableArray arrayWithObject:self];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e(p.s. 如果你不知道didSubscribe是什么，也不了解ReactiveCocoa中信号的订阅过程，可以先看下\u003ca href=\"http://tech.meituan.com/RACSignalSubscription.html\"\u003e《RACSignal的Subscription深入分析》\u003c/a\u003e)\u003c/p\u003e\u003cp\u003e接下来会对源信号进行订阅：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eRACDisposable *bindingDisposable = [self subscribeNext:^(id x) {\n    // Manually check disposal to handle synchronous errors.\n    if (compoundDisposable.disposed) return;\n    BOOL stop = NO;\n    id signal = bindingBlock(x, \u0026amp;stop);\n    @autoreleasepool {\n        if (signal != nil) addSignal(signal);\n        if (signal == nil || stop) {\n            [selfDisposable dispose];\n            completeSignal(self, selfDisposable);\n        }\n    }\n} error:^(NSError *error) {\n    //...\n} completed:^{\n    //...\n}];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e订阅者会持有nextBlock、errorBlock、completedBlock三个block，为了简单，我们只讨论nextBlock。\n从nextBlock中的\u003ccode\u003ecompleteSignal(self, selfDisposable);\u003c/code\u003e这一行代码可以看出，nextBlock对self，也就是源信号进行了持有，再看到\u003ccode\u003eif (signal != nil) addSignal(signal);\u003c/code\u003e这一行，nextBlock对addSignal进行了持有，addSignal是在订阅self之前定义的一个block。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evoid (^addSignal)(RACSignal *) = ^(RACSignal *signal) {\n    @synchronized (signals) {\n        [signals addObject:signal];\n    }\n    //...\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eaddSignal这个block里面对一开始创建的数组signals进行了持有，用一幅图来描述下刚才所说的关系：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/134838d9.png\" alt=\"Alt text\"/\u003e\u003c/p\u003e\u003cp\u003e如果这个signal是一个RACSignal，那么是没有任何问题的；如果是signal是一个RACSubject，那问题就来了。还记得前面说过的RACSignal和RACSubject的区别吗？RACSubject会持有订阅者，而RACSignal不会持有订阅者，如果signal是一个RACSubject，那么图应该是这样的：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/3628032d.png\" alt=\"Alt text\"/\u003e\u003c/p\u003e\u003cp\u003e很明显，产生了循环引用！！！到这里，也就解答了前面提出的三个问题的前两个：\n对一个信号进行了map操作，那么最终会调用到bind。\n如果源信号是RACSubject，由于RACSubject会持有订阅者，所以产生了循环引用(内存泄漏)；\n如果源信号是RACSignal，由于RACSignal不会持有订阅者，那么也就不存在循环引用。\u003c/p\u003e\u003cp\u003e还剩下最后一个问题：如果源信号是RACSubject，为什么发送完成可以修复内存泄漏？\n来看下订阅者收到完成信号之后干了些什么：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eRACDisposable *bindingDisposable = [self subscribeNext:^(id x) {\n    //...\n} error:^(NSError *error) {\n    //...\n} completed:^{\n    @autoreleasepool {\n        completeSignal(self, selfDisposable);\n    }\n}];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e很简单，只是调用了一下completeSignal这个block。再看下这个block内部在干嘛：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\nvoid (^completeSignal)(RACSignal *, RACDisposable *) = ^(RACSignal *signal, RACDisposable *finishedDisposable) {\n    BOOL removeDisposable = NO;\n    @synchronized (signals) {\n        [signals removeObject:signal]; //1\n        if (signals.count == 0) {\n            [subscriber sendCompleted]; //2\n            [compoundDisposable dispose]; //3\n        } else {\n            removeDisposable = YES;\n        }\n    }\n    if (removeDisposable) [compoundDisposable removeDisposable:finishedDisposable]; //4\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e//1这里从signals这个数组中移除传入的signal，也就断掉了signals持有subject这条线。\n//2、//3、//4其实干的事情差不多，都是拿到对应的disposable调用dispose，这样资源就得到了回收，subject就不会再持有subscriber，subscriber也会对自己的nextBlock、errorBlock、completedBlock三个block置为nil，就不会存在引用关系，所有的对象都得到了释放。\n有兴趣的同学可以去了解下\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/blob/v2.5/ReactiveCocoa/RACDisposable.h\"\u003eRACDisposable\u003c/a\u003e，它也是ReactiveCocoa中的重要一员，对理解源码有很大的帮助。\nmap只是一个很典型的操作，其实在ReactiveCocoa的实现中，几乎所有的操作底层都会调用到bind这样一个方法，包括但不限于：\n\u003ccode\u003emap、filter、merge、combineLatest、flattenMap ……\u003c/code\u003e\u003c/p\u003e\u003cp\u003e所以在使用ReactiveCocoa的时候也一定要仔细，对信号操作完成之后，记得发送完成信号，不然可能在不经意间就导致了内存泄漏。\u003c/p\u003e\u003cp\u003eRACSubject就是一个比较典型直接的例子。除此之外，如果在对一个信号进行类似replay这样的操作之后，也一定要保证源信号发送完成；不然，也是会有内存泄漏的。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eRACSignal *signal = [RACSignal createSignal:^RACDisposable *(id\u0026lt;RACSubscriber\u0026gt; subscriber) {\n    [subscriber sendNext:@1];\n    [subscriber sendCompleted]; // 保证源信号发送完成\n    return nil;\n}];\n\nRACSignal *replaySignal = [signal replay]; // 这里返回的其实是一个RACReplaySubject\n\n[[replaySignal map:^id(NSNumber *value) {\n    return @([value integerValue] * 3);\n}] subscribeNext:^(id x) {\n    NSLog(@\u0026#34;subscribeNext - %@\u0026#34;, x);\n}];\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e总之，一句话：使用ReactiveCocoa必须要保证信号发送完成或者发送错误。\u003c/p\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003cul\u003e\u003cli\u003e美团点评技术博客，\u003ca href=\"http://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html\"\u003e《细说ReactiveCocoa的冷信号与热信号系列文章》\u003c/a\u003e。\u003c/li\u003e\u003cli\u003e美团点评技术博客，\u003ca href=\"http://tech.meituan.com/RACSignalSubscription.html\"\u003e《RACSignal的Subscription深入分析》\u003c/a\u003e。\u003c/li\u003e\u003cli\u003eGitHub，\u003ca href=\"https://github.com/ReactiveCocoa/ReactiveCocoa/tree/v2.5/Documentation\"\u003eReactiveCocoa官方文档\u003c/a\u003e。\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-08-19T00:00:00Z",
  "Author": "soulteary@gmail.com"
}