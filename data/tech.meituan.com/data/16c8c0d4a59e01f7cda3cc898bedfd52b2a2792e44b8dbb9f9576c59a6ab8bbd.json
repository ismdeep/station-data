{
  "Source": "tech.meituan.com",
  "Title": "美团点评SQL优化工具SQLAdvisor开源",
  "Link": "https://tech.meituan.com/2017/03/09/sqladvisor-pr.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e在数据库运维过程中，优化 SQL 是 DBA 团队的日常任务。例行 SQL 优化，不仅可以提升程序性能，还能够降低线上故障的概率。\u003c/p\u003e\u003cp\u003e目前常用的 SQL 优化方式包括但不限于：业务层优化、SQL逻辑优化、索引优化等。其中索引优化通常通过调整索引或新增索引从而达到 SQL 优化的目的。索引优化往往可以在短时间内产生非常巨大的效果。如果能够将索引优化转化成工具化、标准化的流程，减少人工介入的工作量，无疑会大大提高DBA的工作效率。\u003c/p\u003e\u003cp\u003eSQLAdvisor 是由美团点评公司北京DBA团队开发维护的 SQL 优化工具：\u003cstrong\u003e输入SQL，输出索引优化建议\u003c/strong\u003e。 它基于 MySQL 原生词法解析，再结合 SQL 中的 where 条件以及字段选择度、聚合条件、多表 Join 关系等最终输出最优的索引优化建议。\u003cstrong\u003e目前 SQLAdvisor 在公司内部大量使用，较为成熟、稳定。\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e现在，我们非常高兴地将 SQLAdvisor 开源，项目 GitHub 地址：\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor\"\u003ehttps://github.com/Meituan-Dianping/SQLAdvisor\u003c/a\u003e 。我们已经把相关开发工作全面转到 GitHub 上，开源版本和内部使用版本保持完全一致。希望与业内有类似需求的团队，一起打造一款优秀的 SQL 优化产品。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSQLAdvisor架构流程图\u003c/strong\u003e：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/2b8b7d7a.jpg\" alt=\"SQLAdvisor处理流程\"/\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003esql: SELECT id FROM crm_loan WHERE id_card = \u0026#39;1234567\u0026#39;\ncmd: ./sqladvisor -h xx -P xx -u xx -pxx -d xx -q \u0026#34;SELECT id FROM crm_loan WHERE id_card = \u0026#39;1234567\u0026#39;\u0026#34;\nSQLAdvisor输出: alter table crm_loan add index idx_id_card(id_card)   \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/QUICK_START.md\"\u003eSQLAdvisor快速入门教程\u003c/a\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e基于 MySQL 原生词法解析，充分保证词法解析的性能、准确定以及稳定性；\u003c/li\u003e\u003cli\u003e支持常见的 SQL(Insert/Delete/Update/Select)；\u003c/li\u003e\u003cli\u003e支持多表 Join 并自动逻辑选定驱动表；\u003c/li\u003e\u003cli\u003e支持聚合条件 Order by 和 Group by；\u003c/li\u003e\u003cli\u003e过滤表中已存在的索引。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"join-处理\"\u003eJoin 处理\u003c/h2\u003e\u003col\u003e\u003cli\u003eJoin语法分为两种：Join on 和 Join using，并且 Join on 有时会存在 where 条件中。\u003c/li\u003e\u003cli\u003e分析 Join 条件首先会得到一个 nested_join 的 table list，通过判断它的 join_using_fields 字段是否为空来区分 Join on 与 Join using。\u003c/li\u003e\u003cli\u003e生成的 table list 以二叉树的形式进行存储，以后序遍历的方式对二叉树进行遍历。\u003c/li\u003e\u003cli\u003e生成内部解析树时，right Join 会转换成 left Join。\u003c/li\u003e\u003cli\u003eJoin 条件会存在当层的叶子节点上，如果左右节点都是叶子节点，会存在右叶子节点。\u003c/li\u003e\u003cli\u003e每一个非叶子节点代表一次 Join 的结果。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e上述实现时，涉及的函数为：mysql_sql_parse_join(TABLE_LIST *join_table) mysql_sql_parse_join(Item *join_condition) ，主要流程图如下：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/319147a5.jpg\" alt=\"join流程\"/\u003e\u003c/p\u003e\u003ch2 id=\"where-处理\"\u003ewhere 处理\u003c/h2\u003e\u003col\u003e\u003cli\u003e主要是提取 SQL 语句的 where 条件。where 条件中一般由 AND 和 OR 连接符进行连接，因为 OR 比较难以处理，所以忽略，只处理 AND 连接符。\u003c/li\u003e\u003cli\u003e由于 where 条件中可以存在 Join 条件，因此需要进行区分。\u003c/li\u003e\u003cli\u003e依次获取 where 条件，当条件中的操作符是 like，如果不是前缀匹配则丢弃这个条件。\u003c/li\u003e\u003cli\u003e根据条件计算字段的区分度按照高低进行倒序排，如果小于30则丢弃。同时使用最左原则将 where 条件进行有序排列。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"计算区分度\"\u003e计算区分度\u003c/h2\u003e\u003col\u003e\u003cli\u003e通过 “show table status like” 获得表的总行数 table_count。\u003c/li\u003e\u003cli\u003e通过计算选择表中已存在的区分度最高的索引 best_index，同时Primary key \u0026gt; Unique key \u0026gt; 一般索引。\u003c/li\u003e\u003cli\u003e通过计算获取数据采样的起始值offset与采样范围rand_rows：\n\u0026gt; * offset = (table_count / 2) \u0026gt; 10W ? 10W : (table_count / 2)\n\u0026gt; * rand_rows =(table_count / 2) \u0026gt; 1W ? 1W : (table_count / 2)\n\u0026gt; * 使用select count(1) from (select field from table force index(best_index) order by cl.. desc limit rand_rows) where field_print 得到满足条件的rows。\n\u0026gt; * cardinality = rows == 0 ? rand_rows : rand_rows / rows;\n\u0026gt; * 计算完成选择度后，会根据选择度大小，将该条件添加到该表中的备选索引中。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e主要涉及的函数为：mysql_sql_parse_field_cardinality_new() 计算选择度。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/d13f6ddb.jpg\" alt=\"计算区分度流程\"/\u003e\u003c/p\u003e\u003ch2 id=\"添加备选索引\"\u003e添加备选索引\u003c/h2\u003e\u003col\u003e\u003cli\u003emysql_sql_parse_index()将条件按照选择度添加到备选索引链表中。\u003c/li\u003e\u003cli\u003e上述两函数的流程图如下所示：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/86b62991.png\" alt=\"添加备选索引\"/\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"group-与-order-处理\"\u003eGroup 与 Order 处理\u003c/h2\u003e\u003col\u003e\u003cli\u003eGroup 字段与 Order 字段能否用上索引，需要满足如下条件：\n\u0026gt; * 涉及到的字段必须来自于同一张表，并且这张表必须是确定下来的驱动表。\n\u0026gt; * Group by 优于 Order by， 两者只能同时存在一个。\n\u0026gt; * Order by 字段的排序方向必须完全一致，否则丢弃整个 Order by 字段列。\n\u0026gt; * 当 Order by 条件中包含主键时，如果主键字段为 Order by。 字段列末尾，忽略该主键，否则丢弃整个 Order by 字段列。\u003c/li\u003e\u003cli\u003e整个索引列排序优先级：等值\u0026gt;(group by | order by )\u0026gt; 非等值。\u003c/li\u003e\u003cli\u003e该过程中设计的函数主要有：\n\u0026gt; * mysql_sql_parse_group() 判断 Group 后的字段是否均来自于同一张表。\n\u0026gt; * mysql_sql_parse_order() 判断 Order 后的条件是否可以使用。\n\u0026gt; * mysql_sql_parse_group_order_add() 将字段依次按照规则添加到备选索引链表中。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/4af6de41.jpg\" alt=\"添加group\"/\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/50ece4c9.jpg\" alt=\"处理group\"/\u003e\u003c/p\u003e\u003ch2 id=\"驱动表选择\"\u003e驱动表选择\u003c/h2\u003e\u003col\u003e\u003cli\u003e经过前期的 where 解析、Join 解析，已经将 SQL 中表关联关系存储起来，并且按照一定逻辑将候选驱动表确定下来。\u003c/li\u003e\u003cli\u003e在侯选驱动表中，按照每一张表的侯选索引字段中第一个字段进行计算表中结果集大小。\u003c/li\u003e\u003cli\u003e使用 explain select * from table where field 来计算表中结果集。\u003c/li\u003e\u003cli\u003e结果集小最小的被确为驱动表。\u003c/li\u003e\u003cli\u003e步骤中涉及的函数为：final_table_drived()，在该函数中，调用了函数 get_join_table_result_set() 来获取每张驱动候选表的行数。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"添加被驱动表备选索引\"\u003e添加被驱动表备选索引\u003c/h2\u003e\u003col\u003e\u003cli\u003e通过上述过程，已经选择了驱动表，也通过解析保存了语句中的条件。\u003c/li\u003e\u003cli\u003e由于选定了驱动表，因此需要对被驱动表的索引，根据 Join 条件进行添加。\u003c/li\u003e\u003cli\u003e该过程涉及的函数主要是：mysql_index_add_condition_field()，流程如下：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/e0479804.png\" alt=\"驱动表选择\"/\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"输出建议\"\u003e输出建议\u003c/h2\u003e\u003col\u003e\u003cli\u003e通过上述步骤，已经将每张表的备选索引键全部保存。此时，只要判断每张表中的候选索引键是否在实际表中已存在。没有索引，则给出建议增加对应的索引。\u003c/li\u003e\u003cli\u003e该步骤涉及的函数是：print_index() ，主要的流程图为：\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/78a776ae.png\" alt=\"驱动表选择\"/\u003e\u003c/li\u003e\u003c/ol\u003e\u003cul\u003e\u003cli\u003eFunctionality Added or Changed\u003cul\u003e\u003cli\u003e调整架构将 SQLParser 与 SQLAdvisor 模块隔离，方便调试。\u003c/li\u003e\u003cli\u003e重新架构多表 Join 关系的 find_join_elements() 函数，思路更加清晰。\u003c/li\u003e\u003cli\u003e修改选定驱动表的策略，确保驱动表为小结果集。\u003c/li\u003e\u003cli\u003e添加 where 条件中的 like 处理。\u003c/li\u003e\u003cli\u003e优化 Order by 逻辑，忽略 Order by primary key 场景。\u003c/li\u003e\u003cli\u003e输出索引建议前，增加判断索引是否已存在。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eBugs Fixed\u003cul\u003e\u003cli\u003e修复 SQL 无法处理中文问题。\u003c/li\u003e\u003cli\u003e修复字段多次出现在 where 条件中从而导致多次出现在索引列中问题。\u003c/li\u003e\u003cli\u003e修复在 find_best_index() 函数中，对 MySQL API 中的 result 对象提前 free，导致指针失效问题。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e和各位同行共同打造一款企业级优秀的 SQL 优化产品，希望大家能够积极参与。\n欢迎大家将需求或发现的 Bug 在 Github 上提交 issue，帮助 SQLAdvisor 逐渐壮大；也欢迎大家在 SQLAdvisor 用户交流群（QQ: 231434335）相互交流，共同学习。\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/QUICK_START.md\"\u003eSQLAdvisor快速入门教程\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/THEORY_PRACTICES.md\"\u003eSQLAdvisor原理和架构\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/RELEASE_NOTES.md\"\u003eSQLAdvisor release notes\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/DEVELOPMENT_NORM.md\"\u003eSQLAdvisor开发规范\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor/blob/master/doc/FAQ.md\"\u003eFAQ\u003c/a\u003e.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-03-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}