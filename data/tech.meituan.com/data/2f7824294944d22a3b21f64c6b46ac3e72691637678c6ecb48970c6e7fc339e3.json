{
  "Source": "tech.meituan.com",
  "Title": "构建时预渲染：网页首帧优化实践",
  "Link": "https://tech.meituan.com/2018/11/15/first-contentful-paint-practice.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003e自JavaScript诞生以来，前端技术发展非常迅速。移动端白屏优化是前端界面体验的一个重要优化方向，Web 前端诞生了 SSR 、CSR、预渲染等技术。在美团支付的前端技术体系里，通过预渲染提升网页首帧优化，从而优化了白屏问题，提升用户体验，并形成了最佳实践。\u003c/p\u003e\u003cp\u003e在前端渲染领域，主要有以下几种方式可供选择：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"center\"\u003e\u003c/th\u003e\u003cth align=\"left\"\u003eCSR\u003c/th\u003e\u003cth align=\"left\"\u003e预渲染\u003c/th\u003e\u003cth align=\"left\"\u003eSSR\u003c/th\u003e\u003cth align=\"left\"\u003e同构\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"center\"\u003e优点\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e不依赖数据\u003c/li\u003e\u003cli\u003eFP 时间最快\u003c/li\u003e\u003cli\u003e客户端用户体验好\u003c/li\u003e\u003cli\u003e内存数据共享\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e不依赖数据\u003c/li\u003e\u003cli\u003eFCP 时间比 CSR 快\u003c/li\u003e\u003cli\u003e客户端用户体验好\u003c/li\u003e\u003cli\u003e内存数据共享\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003eSEO 友好\u003c/li\u003e\u003cli\u003e首屏性能高，FMP 比 CSR 和预渲染快\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003eSEO 友好\u003c/li\u003e\u003cli\u003e首屏性能高，FMP 比 CSR 和预渲染快\u003c/li\u003e\u003cli\u003e客户端用户体验好\u003c/li\u003e\u003cli\u003e内存数据共享\u003c/li\u003e\u003cli\u003e客户端与服务端代码公用，开发效率高\u003c/li\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"center\"\u003e缺点\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003eSEO 不友好\u003c/li\u003e\u003cli\u003eFCP 、FMP 慢\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003eSEO 不友好\u003c/li\u003e\u003cli\u003eFMP 慢\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e客户端数据共享成本高\u003c/li\u003e\u003cli\u003e模板维护成本高\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003eNode 容易形成性能瓶颈\u003c/li\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e通过对比，同构方案集合 CSR 与 SSR 的优点，可以适用于大部分业务场景。但由于在同构的系统架构中，连接前后端的 Node 中间层处于核心链路，系统可用性的瓶颈就依赖于 Node ，一旦作为短板的 Node 挂了，整个服务都不可用。\u003c/p\u003e\u003cp\u003e结合到我们团队负责的支付业务场景里，由于支付业务追求极致的系统稳定性，服务不可用直接影响到客诉和资损，因此我们采用浏览器端渲染的架构。在保证系统稳定性的前提下，还需要保障用户体验，所以采用了预渲染的方式。\u003c/p\u003e\u003cp\u003e那么究竟什么是预渲染呢？什么是 FCP/FMP 呢？我们先从最常见的 CSR 开始说起。\u003c/p\u003e\u003cp\u003e以 Vue 举例，常见的 CSR 形式如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6edb9a61.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e一切看似很美好。然而，作为以用户体验为首要目标的我们发现了一个体验问题：\u003cstrong\u003e首屏白屏问题\u003c/strong\u003e。\u003c/p\u003e\u003ch2 id=\"为什么会首屏白屏\"\u003e为什么会首屏白屏\u003c/h2\u003e\u003cp\u003e浏览器渲染包含 HTML 解析、DOM 树构建、CSSOM 构建、JavaScript 解析、布局、绘制等等，大致如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/f8d5d24b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e要搞清楚为什么会有白屏，就需要利用这个理论基础来对实际项目进行具体分析。通过 DevTools 进行分析：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/f42e655e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e等待 HTML 文档返回，此时处于白屏状态。\u003c/li\u003e\u003cli\u003e对 HTML 文档解析完成后进行首屏渲染，因为项目中对\u003cdiv id=\"app\"\u003e\u003c/div\u003e加了灰色的背景色，因此呈现出灰屏。\u003c/li\u003e\u003cli\u003e进行文件加载、JS 解析等过程，导致界面长时间出于灰屏中。\u003c/li\u003e\u003cli\u003e当 Vue 实例触发了 mounted 后，界面显示出大体框架。\u003c/li\u003e\u003cli\u003e调用 API 获取到时机业务数据后才能展示出最终的页面内容。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e由此得出结论，因为要等待文件加载、CSSOM 构建、JS 解析等过程，而这些过程比较耗时，导致用户会长时间出于不可交互的首屏灰白屏状态，从而给用户一种网页很“慢”的感觉。那么一个网页太“慢”，会造成什么影响呢？\u003c/p\u003e\u003ch2 id=\"慢-的影响\"\u003e“慢”的影响\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://www.cdnetworks.com/resources/whitepapers/us/Global%20Web%20Performance%20Matters.pdf\"\u003eGlobal Web Performance Matters for ecommerce\u003c/a\u003e的报告中指出：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/267c29f0.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e57%的用户更在乎网页在3秒内是否完成加载。\u003c/li\u003e\u003cli\u003e52%的在线用户认为网页打开速度影响到他们对网站的忠实度。\u003c/li\u003e\u003cli\u003e每慢1秒造成页面 PV 降低11%，用户满意度也随之降低降低16%。\u003c/li\u003e\u003cli\u003e近半数移动用户因为在10秒内仍未打开页面从而放弃。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e我们团队主要负责美团支付相关的业务，如果网站太慢会影响用户的支付体验，会造成客诉或资损。既然网站太“慢”会造成如此重要的影响，那要如何优化呢？\u003c/p\u003e\u003ch2 id=\"优化思路\"\u003e优化思路\u003c/h2\u003e\u003cp\u003e在\u003ca href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics\"\u003eUser-centric Performance Metrics\u003c/a\u003e一文中，共提到了4个页面渲染的关键指标：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ad2aa1a2.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e基于这个理论基础，再回过头来看看之前项目的实际表现：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/78ef764e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可见在 FP 的灰白屏界面停留了很长时间，用户不清楚网站是否有在正常加载，用户体验很差。\u003c/p\u003e\u003cp\u003e试想：如果我们可以将 FCP 或 FMP 完整的 HTML 文档提前到 FP 时机预渲染，用户看到页面框架，能感受到页面正在加载而不是冷冰冰的灰白屏，那么用户更愿意等待页面加载完成，从而降低了流失率。并且这种改观在弱网环境下更明显。\u003c/p\u003e\u003cp\u003e通过对比 FP、FCP、FMP 这三个时期 DOM 的差异，发现区别在于：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/431ac789.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/aef51a44.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/81cde23f.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eFP：仅有一个 div 根节点。\u003c/li\u003e\u003cli\u003eFCP：包含页面的基本框架，但没有数据内容。\u003c/li\u003e\u003cli\u003eFMP：包含页面所有元素及数据。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e仍然以 Vue 为例， 在其生命周期中，mounted 对应的是 FCP，updated 对应的是 FMP。那么具体应该使用哪个生命周期的 HTML 结构呢？\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"center\"\u003e\u003c/th\u003e\u003cth align=\"left\"\u003emounted (FCP)\u003c/th\u003e\u003cth align=\"left\"\u003eupdated (FMP)\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"center\"\u003e缺点\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e只是视觉体验将 FCP 提前，实际的 TTI 时间变化不大\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e构建时需要获取数据，编译速度慢\u003c/li\u003e\u003cli\u003e构建时与运行时的数据存在差异性\u003c/li\u003e\u003cli\u003e有复杂交互的页面，仍需等待，实际的 TTI 时间变化不大\u003c/li\u003e\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"center\"\u003e优点\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e不受数据影响，编译速度快\u003c/li\u003e\u003c/td\u003e\u003ctd align=\"left\"\u003e\u003cli\u003e首屏体验好\u003c/li\u003e\u003cli\u003e对于纯展示类型的页面，FP 与 TTI 时间近乎一致\u003c/li\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e通过以上的对比，最终选择在 mounted 时触发构建时预渲染。由于我们采用的是 CSR 的架构，没有 Node 作为中间层，因此要实现 DOM 内容的预渲染，就需要在项目构建编译时完成对原始模板的更新替换。\u003c/p\u003e\u003cp\u003e至此，我们明确了构建时预渲染的大体方案。\u003c/p\u003e\u003ch2 id=\"构建时预渲染方案\"\u003e构建时预渲染方案\u003c/h2\u003e\u003cp\u003e构建时预渲染流程：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8adc18c7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"配置读取\"\u003e配置读取\u003c/h3\u003e\u003cp\u003e由于 SPA 可以由多个路由构成，需要根据业务场景决定哪些路由需要用到预渲染。因此这里的配置文件主要是用于告知编译器需要进行预渲染的路由。\u003c/p\u003e\u003cp\u003e在我们的系统架构里，脚手架是基于 Webpack 自研的，在此基础上可以自定义自动化构建任务和配置。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/f44e3e64.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"触发构建\"\u003e触发构建\u003c/h3\u003e\u003cp\u003e项目中主要是使用 TypeScript，利用 TS 的\u003ca href=\"https://www.typescriptlang.org/docs/handbook/decorators.html\"\u003e装饰器\u003c/a\u003e，我们封装了统一的预渲染构建的钩子方法，从而只用一行代码即可完成构建时预渲染的触发。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e装饰器：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7213a6c7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e使用：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/cb713a1b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"构建编译\"\u003e构建编译\u003c/h3\u003e\u003cp\u003e从流程图上，需要在发布机上启动模拟的浏览器环境，并通过预渲染的事件钩子获取当前的页面内容，生成最终的 HTML 文件。\u003c/p\u003e\u003cp\u003e由于我们在预渲染上的尝试比较早，当时还没有 \u003ca href=\"https://developers.google.com/web/updates/2017/04/headless-chrome\"\u003eHeadless Chrome\u003c/a\u003e 、 \u003ca href=\"https://github.com/GoogleChrome/puppeteer\"\u003ePuppeteer\u003c/a\u003e、\u003ca href=\"https://www.npmjs.com/package/prerender-spa-plugin\"\u003ePrerender SPA Plugin\u003c/a\u003e等，因此在选型上使用的是 \u003ca href=\"https://www.npmjs.com/package/phantomjs-prebuilt\"\u003ephantomjs-prebuilt\u003c/a\u003e（Prerender SPA Plugin 早期版本也是基于 phantomjs-prebuilt 实现的）。\u003c/p\u003e\u003cp\u003e通过 phantom 提供的 API 可获得当前 HTML，示例如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/202684fb.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e为了提高构建效率，并行对配置的多个页面或路由进行预渲染构建，保证在 5S 内即可完成构建，流程图如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/e46f186e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"方案优化\"\u003e方案优化\u003c/h2\u003e\u003cp\u003e理想很丰满，现实很骨感。在实际投产中，构建时预渲染方案遇到了一个问题。\u003c/p\u003e\u003cp\u003e我们梳理一下简化后的项目上线过程：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e开发 -\u0026gt; 编译 -\u0026gt; 上线\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e假设本次修改了静态文件中的一个 JS 文件，这个文件会通过 CDN 方式在 HTML 里引用，那么最终在 HTML 文档中的引用方式是 \u003ccode\u003e\u0026lt;script src=\u0026#34;http://cdn.com/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e。然而由于项目还没有上线，所以其实通过完整 URL 的方式是获取不到这个文件的；而预渲染的构建又是在上线动作之前，所以问题就产生了：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e构建时预渲染无法正常获取文件，导致编译报错\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e怎么办？\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e请求劫持\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e因为在做预渲染时，我们使用启动了一个模拟的浏览器环境，根据 phantom 提供的 API，可以对发出的请求加以劫持，将获取 CDN 文件的请求劫持到本地，从而在根本上解决了这个问题。示例代码如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/9992b84f.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"构建时预渲染研发流程及效果\"\u003e构建时预渲染研发流程及效果\u003c/h2\u003e\u003cp\u003e最终，构建时预渲染研发流程如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/af202144.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e开发阶段：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e通过 TypeScript 的装饰器单行引入预渲染构建触发的方法。\u003c/li\u003e\u003cli\u003e发布前修改编译构建的配置文件。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e发布阶段：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e先进行常规的项目构建。\u003c/li\u003e\u003cli\u003e若有预渲染相关配置，则触发预渲染构建。\u003c/li\u003e\u003cli\u003e通过预渲染得到最终的文件，并完成发布上线动作。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e完整的用户请求路径如下：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/999c7f32.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过构建时预渲染在项目中的使用，FCP 的时间相比之前减少了 75%。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/53771784.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"作者简介\"\u003e作者简介\u003c/h3\u003e\u003cul\u003e\u003cli\u003e寒阳，美团资深研发工程师，多年前端研发经历，负责美团支付钱包团队和美团支付前端基础技术。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"招聘信息\"\u003e招聘信息\u003c/h3\u003e\u003cp\u003e我们美团金融服务平台大前端研发组在高速成长中，我们欢迎更多优秀的 Web 前端研发工程师加入，感兴趣的朋友可以将简历发送到邮箱：shanghanyang@meituan.com。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-11-15T00:00:00Z",
  "Author": "soulteary@gmail.com"
}