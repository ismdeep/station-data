{
  "Source": "tech.meituan.com",
  "Title": "【基本功】深入剖析Swift性能优化",
  "Link": "https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"简介\"\u003e简介\u003c/h2\u003e\u003cp\u003e2014年，苹果公司在WWDC上发布Swift这一新的编程语言。经过几年的发展，Swift已经成为iOS开发语言的“中流砥柱”，Swift提供了非常灵活的高级别特性，例如协议、闭包、泛型等，并且Swift还进一步开发了强大的SIL（Swift Intermediate Language）用于对编译器进行优化，使得Swift相比Objective-C运行更快性能更优，Swift内部如何实现性能的优化，我们本文就进行一下解读，希望能对大家有所启发和帮助。\u003c/p\u003e\u003cp\u003e针对Swift性能提升这一问题，我们可以从概念上拆分为两个部分：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e编译器\u003c/strong\u003e：Swift编译器进行的性能优化，从阶段分为编译期和运行期，内容分为时间优化和空间优化。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e开发者\u003c/strong\u003e：通过使用合适的数据结构和关键字，帮助编译器获取更多信息，进行优化。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e下面我们将从这两个角度切入，对Swift性能优化进行分析。通过了解编译器对不同数据结构处理的内部实现，来选择最合适的算法机制，并利用编译器的优化特性，编写高性能的程序。\u003c/p\u003e\u003ch2 id=\"理解swift的性能\"\u003e理解Swift的性能\u003c/h2\u003e\u003cp\u003e理解Swift的性能，首先要清楚Swift的数据结构，组件关系和编译运行方式。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e数据结构\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eSwift的数据结构可以大体拆分为：\u003ccode\u003eClass\u003c/code\u003e，\u003ccode\u003eStruct\u003c/code\u003e，\u003ccode\u003eEnum\u003c/code\u003e。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e组件关系\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e组件关系可以分为：\u003ccode\u003einheritance\u003c/code\u003e，\u003ccode\u003eprotocols\u003c/code\u003e，\u003ccode\u003egenerics\u003c/code\u003e。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e方法分派方式\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e方法分派方式可以分为\u003ccode\u003eStatic dispatch\u003c/code\u003e和\u003ccode\u003eDynamic dispatch\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e要在开发中提高Swift性能，需要开发者去了解这几种数据结构和组件关系以及它们的内部实现，从而通过选择最合适的抽象机制来提升性能。\u003c/p\u003e\u003cp\u003e首先我们对于性能标准进行一个概念陈述，性能标准涵盖三个标准：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/9543d745.png\" alt=\"性能指标\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eAllocation\u003c/li\u003e\u003cli\u003eReference counting\u003c/li\u003e\u003cli\u003eMethod dispatch\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e接下来，我们会分别对这几个指标进行说明。\u003c/p\u003e\u003ch3 id=\"allocation\"\u003eAllocation\u003c/h3\u003e\u003cp\u003e内存分配可以分为堆区栈区，在栈的内存分配速度要高于堆，结构体和类在堆栈分配是不同的。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eStack\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e基本数据类型和结构体默认在栈区，栈区内存是连续的，通过出栈入栈进行分配和销毁，速度很快，高于堆区。\u003c/p\u003e\u003cp\u003e我们通过一些例子进行说明：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//示例 1\n// Allocation\n// Struct\nstruct Point {\n var x, y:Double\n func draw() { … }\n}\nlet point1 = Point(x:0, y:0) //进行point1初始化，开辟栈内存\nvar point2 = point1 //初始化point2，拷贝point1内容，开辟新内存\npoint2.x = 5 //对point2的操作不会影响point1\n// use `point1`\n// use `point2`\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/cb771a53.png\" alt=\"结构体的内存分配\"/\u003e\u003c/p\u003e\u003cp\u003e以上结构体的内存是在栈区分配的，内部的变量也是内联在栈区。将\u003ccode\u003epoint1\u003c/code\u003e赋值给\u003ccode\u003epoint2\u003c/code\u003e实际操作是在栈区进行了一份拷贝，产生了新的内存消耗\u003ccode\u003epoint2\u003c/code\u003e，这使得\u003ccode\u003epoint1\u003c/code\u003e和\u003ccode\u003epoint2\u003c/code\u003e是完全独立的两个实例，它们之间的操作互不影响。在使用\u003ccode\u003epoint1\u003c/code\u003e和\u003ccode\u003epoint2\u003c/code\u003e之后，会进行销毁。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eHeap\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e高级的数据结构，比如类，分配在堆区。初始化时查找没有使用的内存块，销毁时再从内存块中清除。因为堆区可能存在多线程的操作问题，为了保证线程安全，需要进行加锁操作，因此也是一种性能消耗。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Allocation\n// Class\nclass Point {\n var x, y:Double\n func draw() { … }\n}\nlet point1 = Point(x:0, y:0) //在堆区分配内存，栈区只是存储地址指针\nlet point2 = point1 //不产生新的实例，而是对point2增加对堆区内存引用的指针\npoint2.x = 5 //因为point1和point2是一个实例，所以point1的值也会被修改\n// use `point1`\n// use `point2`\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/3101e25f.png\" alt=\"Class 实例内存分配\"/\u003e\u003c/p\u003e\u003cp\u003e以上我们初始化了一个\u003ccode\u003eClass\u003c/code\u003e类型，在栈区分配一块内存，但是和结构体直接在栈内存储数值不同，我们只在栈区存储了对象的指针，指针指向的对象的内存是分配在堆区的。需要注意的是，为了管理对象内存，在堆区初始化时，除了分配属性内存（这里是Double类型的x，y），还会有额外的两个字段，分别是\u003ccode\u003etype\u003c/code\u003e和\u003ccode\u003erefCount\u003c/code\u003e，这个包含了\u003ccode\u003etype\u003c/code\u003e，\u003ccode\u003erefCount\u003c/code\u003e和实际属性的结构被称为\u003ccode\u003eblue box\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e内存分配总结\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e从初始化角度，\u003ccode\u003eClass\u003c/code\u003e相比\u003ccode\u003eStruct\u003c/code\u003e需要在堆区分配内存，进行内存管理，使用了指针，有更强大的特性，但是性能较低。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e优化方式：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e对于频繁操作（比如通信软件的内容气泡展示），尽量使用\u003ccode\u003eStruct\u003c/code\u003e替代\u003ccode\u003eClass\u003c/code\u003e，因为栈内存分配更快，更安全，操作更快。\u003c/p\u003e\u003ch3 id=\"reference-counting\"\u003eReference counting\u003c/h3\u003e\u003cp\u003eSwift通过引用计数管理堆对象内存，当引用计数为0时，Swift确认没有对象再引用该内存，所以将内存释放。对于引用计数的管理是一个非常高频的间接操作，并且需要考虑线程安全，使得引用计数的操作需要较高的性能消耗。\u003c/p\u003e\u003cp\u003e对于基本数据类型的\u003ccode\u003eStruct\u003c/code\u003e来说，没有堆内存分配和引用计数的管理，性能更高更安全，但是对于复杂的结构体，如：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Reference Counting\n// Struct containing references\nstruct Label {\n var text:String\n var font:UIFont\n func draw() { … }\n}\nlet label1 = Label(text:\u0026#34;Hi\u0026#34;, font:font)  //栈区包含了存储在堆区的指针\nlet label2 = label1 //label2产生新的指针，和label1一样指向同样的string和font地址\n// use `label1`\n// use `label2`\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/80057f9c.png\" alt=\"结构体包含引用类型\"/\u003e\u003c/p\u003e\u003cp\u003e这里看到，包含了引用的结构体相比\u003ccode\u003eClass\u003c/code\u003e，需要管理双倍的引用计数。每次将结构体作为参数传递给方法或者进行直接拷贝时，都会出现多份引用计数。下图可以比较直观的理解：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/d2438687.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e备注：包含引用类型的结构体出现Copy的处理方式\u003c/p\u003e\u003cp\u003eClass在拷贝时的处理方式：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/20750021.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e引用计数总结\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eClass\u003c/code\u003e在堆区分配内存，需要使用引用计数器进行内存管理。\u003c/li\u003e\u003cli\u003e基本类型的\u003ccode\u003eStruct\u003c/code\u003e在栈区分配内存，无引用计数管理。\u003c/li\u003e\u003cli\u003e包含强类型的\u003ccode\u003eStruct\u003c/code\u003e通过指针管理在堆区的属性，对结构体的拷贝会创建新的栈内存，创建多份引用的指针，\u003ccode\u003eClass\u003c/code\u003e只会有一份。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e优化方式\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e在使用结构体时：\u003c/p\u003e\u003col\u003e\u003cli\u003e通过使用精确类型，例如UUID替代String（UUID字节长度固定128字节，而不是String任意长度），这样就可以进行内存内联，在栈内存储UUID，我们知道，栈内存管理更快更安全，并且不需要引用计数。\u003c/li\u003e\u003cli\u003eEnum替代String，在栈内管理内存，无引用计数，并且从语法上对于开发者更友好。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"method-dispatch\"\u003eMethod Dispatch\u003c/h3\u003e\u003cp\u003e我们之前在\u003ca href=\"https://www.jianshu.com/p/e0659093eaac\"\u003eStatic dispatch VS Dynamic dispatch\u003c/a\u003e中提到过，能够在编译期确定执行方法的方式叫做静态分派Static dispatch，无法在编译期确定，只能在运行时去确定执行方法的分派方式叫做动态分派Dynamic dispatch。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eStatic dispatch\u003c/code\u003e更快，而且静态分派可以进行\u003cstrong\u003e内联\u003c/strong\u003e等进一步的优化，使得执行更快速，性能更高。\u003c/p\u003e\u003cp\u003e但是对于多态的情况，我们不能在编译期确定最终的类型，这里就用到了\u003ccode\u003eDynamic dispatch\u003c/code\u003e动态分派。动态分派的实现是，每种类型都会创建一张表，表内是一个包含了方法指针的数组。动态分派更灵活，但是因为有查表和跳转的操作，并且因为很多特点对于编译器来说并不明确，所以相当于block了编译器的一些后期优化。所以速度慢于\u003ccode\u003eStatic dispatch\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e下面看一段多态代码，以及分析实现方式：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//引用语义实现的多态\nclass Drawable { func draw() {} }\nclass Point :Drawable {\n var x, y:Double\n override func draw() { … }\n}\nclass Line :Drawable {\n var x1, y1, x2, y2:Double\n override func draw() { … }\n}\nvar drawables:[Drawable]\nfor d in drawables {\n d.draw（）\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/dc4e1465.png\" alt=\"引用语义多态的方法分派流程\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMethod Dispatch总结\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eClass\u003c/code\u003e默认使用\u003ccode\u003eDynamic dispatch\u003c/code\u003e，因为在编译期几乎每个环节的信息都无法确定，所以阻碍了编译器的优化，比如\u003ccode\u003einline\u003c/code\u003e和\u003ccode\u003ewhole module inline\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e使用Static dispatch代替Dynamic dispatch提升性能\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们知道\u003ccode\u003eStatic dispatch\u003c/code\u003e快于\u003ccode\u003eDynamic dispatch\u003c/code\u003e，如何在开发中去尽可能使用\u003ccode\u003eStatic dispatch\u003c/code\u003e。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003einheritance constraints\u003c/code\u003e继承约束\n我们可以使用\u003ccode\u003efinal\u003c/code\u003e关键字去修饰\u003ccode\u003eClass\u003c/code\u003e，以此生成的\u003ccode\u003eFinal class\u003c/code\u003e，使用\u003ccode\u003eStatic dispatch\u003c/code\u003e。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003eaccess control\u003c/code\u003e访问控制\n\u003ccode\u003eprivate\u003c/code\u003e关键字修饰，使得方法或属性只对当前类可见。编译器会对方法进行\u003ccode\u003eStatic dispatch\u003c/code\u003e。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e编译器可以通过\u003ccode\u003ewhole module optimization\u003c/code\u003e检查继承关系，对某些没有标记\u003ccode\u003efinal\u003c/code\u003e的类通过计算，如果能在编译期确定执行的方法，则使用\u003ccode\u003eStatic dispatch\u003c/code\u003e。\n\u003ccode\u003eStruct\u003c/code\u003e默认使用\u003ccode\u003eStatic dispatch\u003c/code\u003e。\u003c/p\u003e\u003cp\u003eSwift快于OC的一个关键是可以消解动态分派。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e总结\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSwift提供了更灵活的\u003ccode\u003eStruct\u003c/code\u003e，用以在内存、引用计数、方法分派等角度去进行性能的优化，在正确的时机选择正确的数据结构，可以使我们的代码性能更快更安全。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e延伸\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e你可能会问\u003ccode\u003eStruct\u003c/code\u003e如何实现多态呢?答案是\u003ccode\u003eprotocol oriented programming\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e以上分析了影响性能的几个标准，那么不同的算法机制\u003ccode\u003eClass\u003c/code\u003e，\u003ccode\u003eProtocol Types\u003c/code\u003e和\u003ccode\u003eGeneric code\u003c/code\u003e，它们在这三方面的表现如何，\u003ccode\u003eProtocol Type\u003c/code\u003e和\u003ccode\u003eGeneric code\u003c/code\u003e分别是怎么实现的呢？我们带着这个问题看下去。\u003c/p\u003e\u003ch2 id=\"protocol-type\"\u003eProtocol Type\u003c/h2\u003e\u003cp\u003e这里我们会讨论Protocol Type如何存储和拷贝变量，以及方法分派是如何实现的。不通过继承或者引用语义的多态：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprotocol Drawable { func draw() }\nstruct Point :Drawable {\n var x, y:Double\n func draw() { … }\n}\nstruct Line :Drawable {\n var x1, y1, x2, y2:Double\n func draw() { … }\n}\n\nvar drawables:[Drawable] //遵守了Drawable协议的类型集合，可能是point或者line\nfor d in drawables {\n d.draw（）\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上通过\u003ccode\u003eProtocol Type\u003c/code\u003e实现多态，几个类之间没有继承关系，故不能按照惯例借助\u003ccode\u003eV-Table\u003c/code\u003e实现动态分派。\u003c/p\u003e\u003cp\u003e如果想了解\u003ca href=\"https://www.jianshu.com/p/c93d7a7d6771\"\u003eVtable和Witness table实现\u003c/a\u003e，可以进行点击查看，这里不做细节说明。\u003c/p\u003e\u003cp\u003e因为Point和Line的尺寸不同，数组存储数据实现一致性存储，使用了\u003ccode\u003eExistential Container\u003c/code\u003e。查找正确的执行方法则使用了 \u003ccode\u003eProtoloc Witness Table\u003c/code\u003e 。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/aa9e8eab.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"existential-container\"\u003eExistential Container\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eExistential Container\u003c/code\u003e是一种特殊的内存布局方式，用于管理遵守了相同协议的数据类型\u003ccode\u003eProtocol Type\u003c/code\u003e，这些数据类型因为不共享同一继承关系（这是\u003ccode\u003eV-Table\u003c/code\u003e实现的前提），并且内存空间尺寸不同，使用\u003ccode\u003eExistential Container\u003c/code\u003e进行管理，使其具有存储的一致性。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/b2b3807e.png\" alt=\"Existential Container的构成\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e结构如下：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e三个词大小的valueBuffer\n这里介绍一下valueBuffer结构，valueBuffer有三个词，每个词包含8个字节，存储的可能是值，也可能是对象的指针。对于small value（空间小于valueBuffer），直接存储在valueBuffer的地址内， inline valueBuffer，无额外堆内存初始化。当值的数量大于3个属性即large value，或者总尺寸超过valueBuffer的占位，就会在堆区开辟内存，将其存储在堆区，valueBuffer存储内存指针。\u003c/li\u003e\u003cli\u003evalue witness table的引用\n因为\u003ccode\u003eProtocol Type\u003c/code\u003e的类型不同，内存空间，初始化方法等都不相同，为了对\u003ccode\u003eProtocol Type\u003c/code\u003e生命周期进行专项管理，用到了\u003ccode\u003eValue Witness Table\u003c/code\u003e。\u003c/li\u003e\u003cli\u003eprotocol witness table的引用\n管理\u003ccode\u003eProtocol Type\u003c/code\u003e的方法分派。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e内存分布如下：\u003c/strong\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e1. payload_data_0 = 0x0000000000000004,\n2. payload_data_1 = 0x0000000000000000,\n3. payload_data_2 = 0x0000000000000000,\n4. instance_type = 0x000000010d6dc408 ExistentialContainers`type    \n       metadata for ExistentialContainers.Car,\n5. protocol_witness_0 = 0x000000010d6dc1c0 \n       ExistentialContainers protocol witness table for \n       ExistentialContainers.Car:ExistentialContainers.Drivable \n       in ExistentialContainers\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"protocol-witness-table-pwt\"\u003eProtocol Witness Table（PWT）\u003c/h3\u003e\u003cp\u003e为了实现\u003ccode\u003eClass\u003c/code\u003e多态也就是引用语义多态，需要\u003ccode\u003eV-Table\u003c/code\u003e来实现，但是\u003ccode\u003eV-Table\u003c/code\u003e的前提是具有同一个父类即共享相同的继承关系，但是对于\u003ccode\u003eProtocol Type\u003c/code\u003e来说，并不具备此特征，故为了支持\u003ccode\u003eStruct\u003c/code\u003e的多态，需要用到\u003ccode\u003eprotocol oriented programming\u003c/code\u003e机制，也就是借助\u003ccode\u003eProtocol Witness Table\u003c/code\u003e来实现（细节可以点击\u003ca href=\"https://www.jianshu.com/p/c93d7a7d6771\"\u003eVtable和witness table实现\u003c/a\u003e，每个结构体会创造\u003ccode\u003ePWT\u003c/code\u003e表，内部包含指针，指向方法具体实现）。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ced90c8e.png\" alt=\"Point and Line PWT\"/\u003e\u003c/p\u003e\u003ch3 id=\"value-witness-table-vwt\"\u003eValue Witness Table（VWT）\u003c/h3\u003e\u003cp\u003e用于管理任意值的初始化、拷贝、销毁。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ce2a6d93.png\" alt=\"VWT use existential container\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003eValue Witness Table\u003c/code\u003e的结构如上，是用于管理遵守了协议的\u003ccode\u003eProtocol Type\u003c/code\u003e实例的初始化，拷贝，内存消减和销毁的。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003eValue Witness Table\u003c/code\u003e在\u003ccode\u003eSIL\u003c/code\u003e中还可以拆分为\u003ccode\u003e%relative_vwtable\u003c/code\u003e和\u003ccode\u003e%absolute_vwtable\u003c/code\u003e，我们这里先不做展开。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ccode\u003eValue Witness Table\u003c/code\u003e和\u003ccode\u003eProtocol Witness Table\u003c/code\u003e通过分工，去管理\u003ccode\u003eProtocol Type\u003c/code\u003e实例的内存管理（初始化，拷贝，销毁）和方法调用。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e我们来借助具体的示例进行进一步了解：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Protocol Types\n// The Existential Container in action\nfunc drawACopy(local ：Drawable) {\n local.draw()\n}\nlet val :Drawable = Point()\ndrawACopy(val)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在Swift编译器中，通过\u003ccode\u003eExistential Container\u003c/code\u003e实现的伪代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Protocol Types\n// The Existential Container in action\nfunc drawACopy(local :Drawable) {\n local.draw()\n}\nlet val :Drawable = Point()\ndrawACopy(val)\n\n//existential container的伪代码结构\nstruct ExistContDrawable {\n var valueBuffer:(Int, Int, Int)\n var vwt:ValueWitnessTable\n var pwt:DrawableProtocolWitnessTable\n}\n\n// drawACopy方法生成的伪代码\nfunc drawACopy(val:ExistContDrawable) { //将existential container传入\n var local = ExistContDrawable()  //初始化container\n let vwt = val.vwt //获取value witness table，用于管理生命周期\n let pwt = val.pwt //获取protocol witness table，用于进行方法分派\n local.type = type \n local.pwt = pwt\n vwt.allocateBufferAndCopyValue(\u0026amp;local, val)  //vwt进行生命周期管理，初始化或者拷贝\n pwt.draw(vwt.projectBuffer(\u0026amp;local)) //pwt查找方法，这里说一下projectBuffer，因为不同类型在内存中是不同的（small value内联在栈内，large value初始化在堆内，栈持有指针），所以方法的确定也是和类型相关的，我们知道，查找方法时是通过当前对象的地址，通过一定的位移去查找方法地址。\n vwt.destructAndDeallocateBuffer(temp) //vwt进行生命周期管理，销毁内存\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"protocol-type-存储属性\"\u003eProtocol Type 存储属性\u003c/h3\u003e\u003cp\u003e我们知道，Swift中\u003ccode\u003eClass\u003c/code\u003e的实例和属性都存储在堆区，\u003ccode\u003eStruct\u003c/code\u003e实例在栈区，如果包含指针属性则存储在堆区，\u003ccode\u003eProtocol Type\u003c/code\u003e如何存储属性？Small Number通过\u003ccode\u003eExistential Container\u003c/code\u003e内联实现，大数存在堆区。如何处理Copy呢？\u003c/p\u003e\u003ch4 id=\"protocol大数的copy优化\"\u003eProtocol大数的Copy优化\u003c/h4\u003e\u003cp\u003e在出现Copy情况时：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003elet aLine = Line(1.0, 1.0, 1.0, 3.0)\nlet pair = Pair(aLine, aLine)\nlet copy = pair\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/ffef3229.png\" alt=\"Protocol Type Copy Large Number\"/\u003e\u003c/p\u003e\u003cp\u003e会将新的\u003ccode\u003eExsitential Container\u003c/code\u003e的valueBuffer指向同一个value即创建指针引用，但是如果要改变值怎么办?我们知道\u003ccode\u003eStruct\u003c/code\u003e值的修改和\u003ccode\u003eClass\u003c/code\u003e不同，Copy是不应该影响原实例的值的。\u003c/p\u003e\u003cp\u003e这里用到了一个技术叫做\u003ccode\u003eIndirect Storage With Copy-On-Write\u003c/code\u003e，即优先使用内存指针。通过提高内存指针的使用，来降低堆区内存的初始化。降低内存消耗。在需要修改值的时候，会先检测引用计数检测，如果有大于1的引用计数，则开辟新内存，创建新的实例。在对内容进行变更的时候，会开启一块新的内存，伪代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass LineStorage { var x1, y1, x2, y2:Double }\nstruct Line :Drawable {\n var storage :LineStorage\n init() { storage = LineStorage(Point(), Point()) }\n func draw() { … }\n mutating func move() {\n   if !isUniquelyReferencedNonObjc(\u0026amp;storage) { //如何存在多份引用，则开启新内存，否则直接修改\n     storage = LineStorage(storage)\n   }\n   storage。start = ...\n   }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样实现的目的：通过多份指针去引用同一份地址的成本远远低于开辟多份堆内存。以下对比图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/06227fbe.png\" alt=\"堆拷贝\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/6689b674.png\" alt=\"Indirect Storage\"/\u003e\u003c/p\u003e\u003ch4 id=\"protocol-type多态总结\"\u003eProtocol Type多态总结\u003c/h4\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e支持\u003ccode\u003eProtocol Type\u003c/code\u003e的动态多态（\u003ccode\u003eDynamic Polymorphism\u003c/code\u003e）行为。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e通过使用\u003ccode\u003eWitness Table\u003c/code\u003e和\u003ccode\u003eExistential Container\u003c/code\u003e来实现。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e对于大数的拷贝可以通过\u003ccode\u003eIndirect Storage\u003c/code\u003e间接存储来进行优化。\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e说到动态多态\u003ccode\u003eDynamic Polymorphism\u003c/code\u003e，我们就要问了，什么是静态多态\u003ccode\u003eStatic Polymorphism\u003c/code\u003e，看看下面示例：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Drawing a copy\nprotocol Drawable {\n func draw()\n}\nfunc drawACopy(local :Drawable) {\n local.draw()\n}\n\nlet line = Line()\ndrawACopy(line)\n// ...\nlet point = Point()\ndrawACopy(point)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这种情况我们就可以用到\u003cstrong\u003e泛型\u003c/strong\u003e\u003ccode\u003eGeneric code\u003c/code\u003e来实现，进行进一步优化。\u003c/p\u003e\u003ch2 id=\"泛型\"\u003e泛型\u003c/h2\u003e\u003cp\u003e我们接下来会讨论泛型属性的存储方式和泛型方法是如何分派的。泛型和\u003ccode\u003eProtocol Type\u003c/code\u003e的区别在于：\u003c/p\u003e\u003cul\u003e\u003cli\u003e泛型支持的是静态多态。\u003c/li\u003e\u003cli\u003e每个调用上下文只有一种类型。\n查看下面的示例，\u003ccode\u003efoo\u003c/code\u003e和\u003ccode\u003ebar\u003c/code\u003e方法是同一种类型。\u003c/li\u003e\u003cli\u003e在调用链中会通过类型降级进行类型取代。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e对于以下示例：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc foo\u0026lt;T:Drawable\u0026gt;(local :T) {\n bar(local)\n}\nfunc bar\u0026lt;T:Drawable\u0026gt;(local:T) { … }\nlet point = Point()\nfoo(point)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e分析方法\u003ccode\u003efoo\u003c/code\u003e和\u003ccode\u003ebar\u003c/code\u003e的调用过程：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//调用过程\nfoo(point)--\u0026gt;foo\u0026lt;T = Point\u0026gt;(point)   //在方法执行时，Swift将泛型T绑定为调用方使用的具体类型，这里为Point\n bar(local) --\u0026gt;bar\u0026lt;T = Point\u0026gt;(local) //在调用内部bar方法时，会使用foo已经绑定的变量类型Point，可以看到，泛型T在这里已经被降级，通过类型Point进行取代\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e泛型方法调用的具体实现为：\u003c/p\u003e\u003cul\u003e\u003cli\u003e同一种类型的任何实例，都共享同样的实现，即使用同一个Protocol Witness Table。\u003c/li\u003e\u003cli\u003e使用Protocol/Value Witness Table。\u003c/li\u003e\u003cli\u003e每个调用上下文只有一种类型：这里没有使用\u003ccode\u003eExistential Container\u003c/code\u003e， 而是将\u003ccode\u003eProtocol/Value Witness Table\u003c/code\u003e作为调用方的额外参数进行传递。\u003c/li\u003e\u003cli\u003e变量初始化和方法调用，都使用传入的\u003ccode\u003eVWT\u003c/code\u003e和\u003ccode\u003ePWT\u003c/code\u003e来执行。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e看到这里，我们并不觉得泛型比\u003ccode\u003eProtocol Type\u003c/code\u003e有什么更快的特性，泛型如何更快呢?静态多态前提下可以进行进一步的优化，称为\u003cstrong\u003e特定泛型\u003c/strong\u003e优化。\u003c/p\u003e\u003ch3 id=\"泛型特化\"\u003e泛型特化\u003c/h3\u003e\u003cul\u003e\u003cli\u003e静态多态：在调用栈中只有一种类型。\nSwift使用只有一种类型的特点，来进行类型降级取代。\u003c/li\u003e\u003cli\u003e类型降级后，产生特定类型的方法。\u003c/li\u003e\u003cli\u003e为泛型的每个类型创造对应的方法。这时候你可能会问，那每一种类型都产生一个新的方法，代码空间岂不爆炸?\u003c/li\u003e\u003cli\u003e静态多态下进行\u003cstrong\u003e特定优化\u003c/strong\u003e \u003ccode\u003especialization\u003c/code\u003e 。\n因为是静态多态。所以可以进行很强大的优化，比如进行内联实现，并且通过获取上下文来进行更进一步的优化。从而降低方法数量。优化后可以更精确和具体。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc min\u0026lt;T:Comparable\u0026gt;(x:T, y:T) -\u0026gt; T {\n  return y \u0026lt; x ? y : x\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从普通的泛型展开如下，因为要支持所有类型的\u003ccode\u003emin\u003c/code\u003e方法，所以需要对泛型类型进行计算，包括初始化地址、内存分配、生命周期管理等。除了对value的操作，还要对方法进行操作。这是一个非常复杂庞大的工程。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc min\u0026lt;T:Comparable\u0026gt;(x:T, y:T, FTable:FunctionTable) -\u0026gt; T {\n  let xCopy = FTable.copy(x)\n  let yCopy = FTable.copy(y)\n  let m = FTable.lessThan(yCopy， xCopy) ? y :x\n  FTable.release(x)\n  FTable.release(y)\n  return m\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在确定入参类型时，比如Int，编译器可以通过泛型特化，进行类型取代（Type Substitute），优化为：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003efunc min\u0026lt;Int\u0026gt;(x:Int, y:Int) -\u0026gt; Int {\n  return y \u0026lt; x ? y :x\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e泛型特化\u003c/strong\u003e\u003ccode\u003especilization\u003c/code\u003e是何时发生的?\u003c/p\u003e\u003cp\u003e在使用特定优化时，调用方需要进行类型推断，这里需要知晓类型的上下文，例如类型的定义和内部方法实现。如果调用方和类型是单独编译的，就无法在调用方推断类型的内部实行，就无法使用特定优化，保证这些代码一起进行编译，这里就用到了\u003ccode\u003ewhole module optimization\u003c/code\u003e。而\u003ccode\u003ewhole module optimization\u003c/code\u003e是对于调用方和被调用方的方法在不同文件时，对其进行泛型特化优化的前提。\u003c/p\u003e\u003ch3 id=\"泛型进一步优化\"\u003e泛型进一步优化\u003c/h3\u003e\u003cp\u003e特定泛型的进一步优化：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Pairs in our program using generic types\nstruct Pair\u0026lt;T :Drawable\u0026gt; {\n init(_ f:T， _ s:T) {\n first = f ; second = s\n }\n var first:T\n var second:T\n}\nlet pairOfLines = Pair(Line(), Line())\n// ...\n\nlet pairOfPoint = Pair(Point(), Point())\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在用到多种泛型，且确定\u003cstrong\u003e泛型类型不会在运行时修改\u003c/strong\u003e时，就可以对成对泛型的使用进行进一步优化。\u003c/p\u003e\u003cp\u003e优化的方式是将泛型的内存分配由指针指定，变为内存内联，不再有额外的堆初始化消耗。请注意，因为进行了存储内联，已经确定了泛型特定类型的内存分布，泛型的内存内联不能存储不同类型。所以再次强调\u003cstrong\u003e此种优化只适用于在运行时不会修改泛型类型\u003c/strong\u003e，即不能同时支持一个方法中包含\u003ccode\u003eline\u003c/code\u003e和\u003ccode\u003epoint\u003c/code\u003e两种类型。\u003c/p\u003e\u003ch3 id=\"whole-module-optimization\"\u003ewhole module optimization\u003c/h3\u003e\u003cp\u003e\u003ccode\u003ewhole module optimization\u003c/code\u003e是用于Swift编译器的优化机制。可以通过\u003ccode\u003e-whole-module-optimization\u003c/code\u003e （或 \u003ccode\u003e-wmo\u003c/code\u003e）进行打开。在XCode 8之后默认打开。 \u003ccode\u003eSwift Package Manager\u003c/code\u003e在release模式默认使用\u003ccode\u003ewhole module optimization\u003c/code\u003e。module是多个文件集合。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/36e45899.png\" alt=\"没有进行全模块优化\"/\u003e\u003c/p\u003e\u003cp\u003e编译器在对源文件进行语法分析之后，会对其进行优化，生成机器码并输出目标文件，之后链接器联合所有的目标文件生成共享库或可执行文件。\u003c/p\u003e\u003cp\u003e\u003ccode\u003ewhole module optimization\u003c/code\u003e通过跨函数优化，可以进行内联等优化操作，对于泛型，可以通过获取类型的具体实现来进行推断优化，进行类型降级方法内联，删除多余方法等操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/2a5e41a0.png\" alt=\"whole module optimizaiton\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e全模块优化的优势\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e编译器掌握所有方法的实现，可以进行\u003cstrong\u003e内联\u003c/strong\u003e和\u003cstrong\u003e泛型特化\u003c/strong\u003e等优化，通过计算所有方法的引用，移除多余的引用计数操作。\u003c/li\u003e\u003cli\u003e通过知晓所有的非公共方法，如果这写方法没有被使用，就可以对其进行消除。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e如何降低编译时间\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e和全模块优化相反的是文件优化，即对单个文件进行编译。这样的好处在于可以并行执行，并且对于没有修改的文件不会再次编译。缺点在于编译器无法获知全貌，无法进行深度优化。下面我们分析下全模块优化如何避免没修改的文件再次编译。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/0a9908b5.png\" alt=\"避免recompile\"/\u003e\u003c/p\u003e\u003cp\u003e编译器内部运行过程分为：语法分析，类型检查，\u003ccode\u003eSIL\u003c/code\u003e优化，\u003ccode\u003eLLVM\u003c/code\u003e后端处理。\u003c/p\u003e\u003cp\u003e语法分析和类型检查一般很快，\u003ccode\u003eSIL\u003c/code\u003e优化执行了重要的Swift特定优化，例如泛型特化和方法内联等，该过程大概占用整个编译时间的三分之一。\u003ccode\u003eLLVM\u003c/code\u003e后端执行占用了大部分的编译时间，用于运行降级优化和生成代码。\u003c/p\u003e\u003cp\u003e进行全模块优化后，\u003ccode\u003eSIL\u003c/code\u003e优化会将模块再次拆分为多个部分，\u003ccode\u003eLLVM\u003c/code\u003e后端通过多线程对这些拆分模块进行处理，对于没有修改的部分，不会进行再处理。这样就避免了修改一小部分，整个大模块进行\u003ccode\u003eLLVM\u003c/code\u003e后端的再次执行，除此外，使用多线程并行操作也会缩短处理时间。\u003c/p\u003e\u003ch2 id=\"扩展-swift的隐藏-bug\"\u003e扩展：Swift的隐藏“Bug”\u003c/h2\u003e\u003cp\u003eSwift因为方法分派机制问题，所以在设计和优化后，会产生和我们常规理解不太一致的结果，这当然不能算Bug。但是还是要单独进行说明，避免在开发过程中，因为对机制的掌握不足，造成预期和执行出入导致的问题。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMessage dispatch\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们通过上面说明结合\u003ca href=\"https://www.jianshu.com/p/e0659093eaac\"\u003eStatic dispatch VS Dynamic dispatch\u003c/a\u003e对方法分派方式有了了解。这里需要对\u003ccode\u003eObjective-C\u003c/code\u003e的方法分派方式进行说明。\u003c/p\u003e\u003cp\u003e熟悉OC的人都知道，OC采用了运行时机制使用\u003ccode\u003eobj_msgSend\u003c/code\u003e发送消息，runtime非常的灵活，我们不仅可以对方法调用采用\u003ccode\u003eswizzling\u003c/code\u003e，对于对象也可以通过\u003ccode\u003eisa-swizzling\u003c/code\u003e来扩展功能，应用场景有我们常用的hook和大家熟知的\u003ccode\u003eKVO\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e大家在使用Swift进行开发时都会问，Swift是否可以使用OC的运行时和消息转发机制呢？答案是可以。\u003c/p\u003e\u003cp\u003eSwift可以通过关键字\u003ccode\u003edynamic\u003c/code\u003e对方法进行标记，这样就会告诉编译器，此方法使用的是OC的运行时机制。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e注意：我们常见的关键字\u003ccode\u003e@ObjC\u003c/code\u003e并不会改变Swift原有的方法分派机制，关键字\u003ccode\u003e@ObjC\u003c/code\u003e的作用只是告诉编译器，该段代码对于OC可见。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e总结来说，Swift通过\u003ccode\u003edynamic\u003c/code\u003e关键字的扩展后，一共包含三种方法分派方式：\u003ccode\u003eStatic dispatch\u003c/code\u003e，\u003ccode\u003eTable dispatch\u003c/code\u003e和\u003ccode\u003eMessage dispatch\u003c/code\u003e。下表为不同的数据结构在不同情况下采取的分派方式：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/fd34ea0b.png\" alt=\"Swift Dispatch Method\"/\u003e\u003c/p\u003e\u003cp\u003e如果在开发过程中，错误的混合了这几种分派方式，就可能出现Bug，以下我们对这些Bug进行分析：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://bugs.Swift.org/browse/SR-584\"\u003eSR-584\u003c/a\u003e\u003c/strong\u003e\n此情况是在子类的extension中重载父类方法时，出现和预期不同的行为。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass Base:NSObject {\n    var directProperty:String { return \u0026#34;This is Base\u0026#34; }\n    var indirectProperty:String { return directProperty }\n}\n\nclass Sub:Base { }\n\nextension Sub {\n    override var directProperty:String { return \u0026#34;This is Sub\u0026#34; }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行以下代码，直接调用没有问题：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eBase().directProperty // “This is Base”\nSub().directProperty // “This is Sub”\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e间接调用结果和预期不同：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eBase（）。indirectProperty // “This is Base”\nSub（）。indirectProperty // expected \u0026#34;this is Sub\u0026#34;，but is “This is Base” \u0026lt;- Unexpected!\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在\u003ccode\u003eBase.directProperty\u003c/code\u003e前添加\u003ccode\u003edynamic\u003c/code\u003e关键字就可以获得”this is Sub”的结果。Swift在\u003ca href=\"https://docs.Swift.org/Swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151\"\u003eextension 文档\u003c/a\u003e中说明，不能在extension中重载已经存在的方法。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e“Extensions can add new functionality to a type, but they cannot override existing functionality.”\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e会出现警告：\u003ccode\u003eCannot override a non-dynamic class declaration from an extension\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/b89bb030.png\" alt=\"Extension Override Warning\"/\u003e\u003c/p\u003e\u003cp\u003e出现这个问题的原因是，NSObject的extension是使用的\u003ccode\u003eMessage dispatch\u003c/code\u003e，而\u003ccode\u003eInitial Declaration\u003c/code\u003e使用的是\u003ccode\u003eTable dispath\u003c/code\u003e（查看上图 Swift Dispatch Method）。extension重载的方法添加在了\u003ccode\u003eMessage dispatch\u003c/code\u003e内，没有修改虚函数表，虚函数表内还是父类的方法，故会执行父类方法。想在extension重载方法，需要标明\u003ccode\u003edynamic\u003c/code\u003e来使用\u003ccode\u003eMessage dispatch\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://bugs.Swift.org/browse/SR-103\"\u003eSR-103\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e协议的扩展内实现的方法，无法被遵守类的子类重载：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprotocol Greetable {\n    func sayHi()\n}\nextension Greetable {\n    func sayHi() {\n        print(\u0026#34;Hello\u0026#34;）\n    }\n}\nfunc greetings(greeter：Greetable) {\n    greeter.sayHi()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在定义一个遵守了协议的类\u003ccode\u003ePerson\u003c/code\u003e。遵守协议类的子类\u003ccode\u003eLoudPerson\u003c/code\u003e：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass Person:Greetable {\n}\nclass LoudPerson:Person {\n    func sayHi() {\n        print(\u0026#34;sub\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行下面代码结果为：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evar sub:LoudPerson = LoudPerson()\nsub.sayHi()  //sub\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e不符合预期的代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evar sub:Person = LoudPerson()\nsub.sayHi()  //HellO  \u0026lt;-使用了protocol的默认实现\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注意，在子类\u003ccode\u003eLoudPerson\u003c/code\u003e中没有出现\u003ccode\u003eoverride\u003c/code\u003e关键字。可以理解为\u003ccode\u003eLoudPerson\u003c/code\u003e并没有成功注册\u003ccode\u003eGreetable\u003c/code\u003e在\u003ccode\u003eWitness table\u003c/code\u003e的方法。所以对于声明为\u003ccode\u003ePerson\u003c/code\u003e实际为\u003ccode\u003eLoudPerson\u003c/code\u003e的实例，会在编译器通过\u003ccode\u003ePerson\u003c/code\u003e去查找，\u003ccode\u003ePerson\u003c/code\u003e没有实现协议方法，则不产生\u003ccode\u003eWitness table\u003c/code\u003e，\u003ccode\u003esayHi\u003c/code\u003e方法是直接调用的。解决办法是在base类内实现协议方法，无需实现也要提供默认方法。或者将基类标记为\u003ccode\u003efinal\u003c/code\u003e来避免继承。\u003c/p\u003e\u003cp\u003e进一步通过示例去理解：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// Defined protocol。\nprotocol A {\n    func a() -\u0026gt; Int\n}\nextension A {\n    func a() -\u0026gt; Int {\n        return 0\n    }\n}\n\n// A class doesn\u0026#39;t have implement of the function。\nclass B：A {}\n\nclass C：B {\n    func a() -\u0026gt; Int {\n        return 1\n    }\n}\n\n// A class has implement of the function。\nclass D：A {\n    func a() -\u0026gt; Int {\n        return 1\n    }\n}\n\nclass E：D {\n    override func a() -\u0026gt; Int {\n        return 2\n    }\n}\n\n// Failure cases。\nB().a() // 0\nC().a() // 1\n(C() as A).a() // 0 # We thought return 1。 \n\n// Success cases。\nD().a() // 1\n(D() as A).a() // 1\nE().a() // 2\n(E() as A).a() // 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e其他\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们知道Class extension使用的是Static Dispatch：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass MyClass {\n}\nextension MyClass {\n    func extensionMethod() {}\n}\n \nclass SubClass：MyClass {\n    override func extensionMethod() {}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上代码会出现错误，提示\u003ccode\u003eDeclarations in extensions can not be overridden yet\u003c/code\u003e。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cul\u003e\u003cli\u003e影响程序的性能标准有三种：\u003cstrong\u003e初始化方式\u003c/strong\u003e， \u003cstrong\u003e引用指针\u003c/strong\u003e和\u003cstrong\u003e方法分派\u003c/strong\u003e。\u003c/li\u003e\u003cli\u003e文中对比了两种数据结构：\u003ccode\u003eStruct\u003c/code\u003e和\u003ccode\u003eClass\u003c/code\u003e的在不同标准下的性能表现。Swift相比OC和其它语言强化了结构体的能力，所以在了解以上性能表现的前提下，通过利用结构体可以有效提升性能。\u003c/li\u003e\u003cli\u003e在此基础上，我们还介绍了功能强大的结构体的类：\u003ccode\u003eProtocol Type\u003c/code\u003e和\u003ccode\u003eGeneric\u003c/code\u003e。并且介绍了它们如何支持多态以及通过使用有条件限制的泛型如何让程序更快。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://developer.apple.com/documentation/swift/memorylayout\"\u003eswift memorylayout\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2016/416/\"\u003ewitness table video\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://devstreaming-cdn.apple.com/videos/wwdc/2016/416k7f0xkmz28rvlvwb/416/416_understanding_swift_performance.pdf?dl=1\"\u003eprotocol types pdf\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2016/419\"\u003eprotocol and value oriented programming in UIKit apps video\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.apple.com/videos/play/wwdc2015/409/\"\u003eoptimizing swift performance\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://swift.org/blog/whole-module-optimizations/\"\u003ewhole module optimizaiton\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.apple.com/swift/blog/?id=27\"\u003eincreasing performance by reducing dynamic dispatch\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://medium.com/@vhart/protocols-generics-and-existential-containers-wait-what-e2e698262ab1\"\u003eprotocols generics existential container\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://airspeedvelocity.net/2015/03/26/protocols-and-generics-2/\"\u003eprotocols and generics\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.skilled.io/u/purpleyay/why-swift-is-swift\"\u003ewhy swift is swift\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://raizlabs.wpengine.com/dev/2016/12/swift-method-dispatch/\"\u003eswift method dispatch\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://docs.swift.org/swift-book/LanguageGuide/Extensions.html#//apple_ref/doc/uid/TP40014097-CH24-ID151\"\u003eswift extension\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html\"\u003euniversal dynamic dispatch for method calls\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/apple/swift/blob/master/docs/CompilerPerformance.md\"\u003ecompiler performance.md\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html\"\u003estructures and classes\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e亚男，美团点评iOS工程师。2017年加入美团点评，负责专业版餐饮管家开发，研究编译器原理。目前正积极推动Swift组件化建设。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e我们餐饮生态技术部是一个技术氛围活跃，大牛聚集的地方。新到店紧握真正的大规模SaaS实战机会，多租户、数据、安全、开放平台等全方位的挑战。业务领域复杂技术挑战多，技术和业务能力迅速提升，最重要的是，加入我们，你将实现真正通过代码来改变行业的梦想。我们欢迎各端人才加入，Java优先。感兴趣的同学赶紧发送简历至 zhaoyanan02@meituan.com，我们期待你的到来。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-11-01T00:00:00Z",
  "Author": "soulteary@gmail.com"
}