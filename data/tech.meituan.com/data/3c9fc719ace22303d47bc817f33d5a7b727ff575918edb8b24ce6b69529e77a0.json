{
  "Source": "tech.meituan.com",
  "Title": "Android App包瘦身优化实践",
  "Link": "https://tech.meituan.com/2017/04/07/android-shrink-overall-solution.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e随着业务的快速迭代增长，美团App里不断引入新的业务逻辑代码、图片资源和第三方SDK，直接导致APK体积不断增长。包体积增长带来的问题越来越多，如CDN流量费用增加、用户安装成功率降低，甚至可能会影响用户的留存率。APK的瘦身已经是不得不考虑的事情。在尝试瘦身的过程中，我们借鉴了很多业界其他公司提供的方案，同时也针对自身特点，发现了一些新的技巧。本文将对其中的一些做详细介绍。\u003c/p\u003e\u003cp\u003e在开始讲瘦身技巧之前，先来讲一下APK的构成。\u003c/p\u003e\u003ch2 id=\"apk的构成\"\u003eAPK的构成\u003c/h2\u003e\u003cp\u003e可以用Zip工具打开APK查看。比如，美团App 7.8.6的线上版本的格式是这样的：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/fa192e15.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可以看到APK由以下主要部分组成：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e文件/目录\u003c/th\u003e\u003cth align=\"left\"\u003e描述\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003elib/\u003c/td\u003e\u003ctd align=\"left\"\u003e存放so文件，可能会有armeabi、armeabi-v7a、arm64-v8a、x86、x86_64、mips，大多数情况下只需要支持armabi与x86的架构即可，如果非必需，可以考虑拿掉x86的部分\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eres/\u003c/td\u003e\u003ctd align=\"left\"\u003e存放编译后的资源文件，例如：drawable、layout等等\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eassets/\u003c/td\u003e\u003ctd align=\"left\"\u003e应用程序的资源，应用程序可以使用AssetManager来检索该资源\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eMETA-INF/\u003c/td\u003e\u003ctd align=\"left\"\u003e该文件夹一般存放于已经签名的APK中，它包含了APK中所有文件的签名摘要等信息\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eclasses(n).dex\u003c/td\u003e\u003ctd align=\"left\"\u003eclasses文件是Java Class，被DEX编译后可供Dalvik/ART虚拟机所理解的文件格式\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eresources.arsc\u003c/td\u003e\u003ctd align=\"left\"\u003e编译后的二进制资源文件\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAndroidManifest.xml\u003c/td\u003e\u003ctd align=\"left\"\u003eAndroid的清单文件，格式为AXML，用于描述应用程序的名称、版本、所需权限、注册的四大组件\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e当然还会有一些其它的文件，例如上图中的\u003ccode\u003eorg/\u003c/code\u003e、\u003ccode\u003esrc/\u003c/code\u003e、\u003ccode\u003epush_version\u003c/code\u003e等文件或文件夹。这些资源是Java Resources，感兴趣的可以结合编译工作流中的\u003ca href=\"http://tools.android.com/tech-docs/new-build-system/build-workflow\"\u003e流程图\u003c/a\u003e以及\u003ca href=\"https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/build-system/gradle-core/src/main/groovy/com/android/build/gradle/internal/transforms/MergeJavaResourcesTransform.java\"\u003eMergeJavaResourcesTransform的源码\u003c/a\u003e看看被打入APK包中的资源都有哪些，这里不做过多介绍。\u003c/p\u003e\u003cp\u003e在充分了解了APK各个组成部分以及它们的作用后，我们针对自身特点进行了分析和优化。下面将从Zip文件格式、classes.dex、资源文件、resources.arsc等方面来介绍下我们发现的部分优化技巧。\u003c/p\u003e\u003ch2 id=\"zip格式优化\"\u003eZip格式优化\u003c/h2\u003e\u003cp\u003e前面介绍了APK的文件格式以及主要组成部分，通过\u003ccode\u003eaapt l -v xxx.apk\u003c/code\u003e或\u003ccode\u003eunzip -l xxx.apk\u003c/code\u003e来查看APK文件时会得到以下信息，见下面截图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/030c5dd8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过上图可以看到APK中很多资源是以\u003ccode\u003eStored\u003c/code\u003e来存储的，根据Zip的文件格式中对压缩方式的描述\u003ca href=\"https://en.wikipedia.org/wiki/Zip_(file_format)#Compression_methods\"\u003eCompression_methods\u003c/a\u003e可以看出这些文件是没有压缩的，那为什么它们没有被压缩呢？从AAPT的源码中找到以下描述：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-C++\"\u003e/* these formats are already compressed, or don\u0026#39;t compress well */\nstatic const char* kNoCompressExt[] = {\n    \u0026#34;.jpg\u0026#34;, \u0026#34;.jpeg\u0026#34;, \u0026#34;.png\u0026#34;, \u0026#34;.gif\u0026#34;,\n    \u0026#34;.wav\u0026#34;, \u0026#34;.mp2\u0026#34;, \u0026#34;.mp3\u0026#34;, \u0026#34;.ogg\u0026#34;, \u0026#34;.aac\u0026#34;,\n    \u0026#34;.mpg\u0026#34;, \u0026#34;.mpeg\u0026#34;, \u0026#34;.mid\u0026#34;, \u0026#34;.midi\u0026#34;, \u0026#34;.smf\u0026#34;, \u0026#34;.jet\u0026#34;,\n    \u0026#34;.rtttl\u0026#34;, \u0026#34;.imy\u0026#34;, \u0026#34;.xmf\u0026#34;, \u0026#34;.mp4\u0026#34;, \u0026#34;.m4a\u0026#34;,\n    \u0026#34;.m4v\u0026#34;, \u0026#34;.3gp\u0026#34;, \u0026#34;.3gpp\u0026#34;, \u0026#34;.3g2\u0026#34;, \u0026#34;.3gpp2\u0026#34;,\n    \u0026#34;.amr\u0026#34;, \u0026#34;.awb\u0026#34;, \u0026#34;.wma\u0026#34;, \u0026#34;.wmv\u0026#34;, \u0026#34;.webm\u0026#34;, \u0026#34;.mkv\u0026#34;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看出AAPT在资源处理时对这些文件后缀类型的资源是不做压缩的，那是不是可以修改它们的压缩方式从而达到瘦身的效果呢？\u003c/p\u003e\u003cp\u003e在介绍怎么做之前，先来大概介绍一下App的资源是怎么被打进APK包里的。Android构建工具链使用AAPT工具来对资源进行处理，来看下图（图片来源于\u003ca href=\"http://tools.android.com/tech-docs/new-build-system/build-workflow\"\u003eBuild Workflow\u003c/a\u003e）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"http://tools.android.com/tech-docs/new-build-system/build-workflow/Android%20Build%20Process.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/70ffd20a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过上图可以看到\u003ccode\u003eManifest\u003c/code\u003e、\u003ccode\u003eResources\u003c/code\u003e、\u003ccode\u003eAssets\u003c/code\u003e的资源经过\u003ccode\u003eAAPT\u003c/code\u003e处理后生成\u003ccode\u003eR.java\u003c/code\u003e、\u003ccode\u003eProguard Configuration\u003c/code\u003e、\u003ccode\u003eCompiled Resources\u003c/code\u003e。其中\u003ccode\u003eR.java\u003c/code\u003e大家都比较熟悉，这里就不过多介绍了。我们来重点看看\u003ccode\u003eProguard Configuration\u003c/code\u003e、\u003ccode\u003eCompiled Resources\u003c/code\u003e都是做什么的呢？\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eProguard Configuration\u003c/code\u003e是AAPT工具为\u003ccode\u003eManifest\u003c/code\u003e中声明的四大组件以及布局文件中（\u003ccode\u003eXML layouts\u003c/code\u003e）使用的各种Views所生成的ProGuard配置，该文件通常存放在\u003ccode\u003e${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/proguard-rules/${flavorName}/${buildType}/aapt_rules.txt\u003c/code\u003e，下面是项目中该文件的截图，红框标记出来的就是对\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e、\u003ccode\u003eXML Layouts\u003c/code\u003e中相关Class的ProGuard配置。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6a26ecac.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eCompiled Resources\u003c/code\u003e是一个Zip格式的文件，这个文件的路径通常为\u003ccode\u003e${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/res/resources-${flavorName}-${buildType}-stripped.ap_\u003c/code\u003e。 通过下面经过Zip解压后的截图，可以看出这个文件包含了\u003ccode\u003eres\u003c/code\u003e、\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e和\u003ccode\u003eresources.arsc\u003c/code\u003e的文件或文件夹。结合\u003ca href=\"http://tools.android.com/tech-docs/new-build-system/build-workflow\"\u003eBuild Workflow\u003c/a\u003e中的描述，可以看出这个文件（\u003ccode\u003eresources-${flavorName}-${buildType}-stripped.ap_\u003c/code\u003e）会被\u003ccode\u003eapkbuilder\u003c/code\u003e打包到APK包中，它其实就是APK的“资源包”（\u003ccode\u003eres\u003c/code\u003e、\u003ccode\u003eAndroidManifest.xml\u003c/code\u003e和\u003ccode\u003eresources.arsc\u003c/code\u003e）。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a83096e7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e我们就是通过这个文件来修改不同后缀文件资源的压缩方式来达到瘦身效果的，而在后面“resources.arsc的优化”一节中也是操作的这个文件。\u003c/p\u003e\u003cp\u003e笔者在自己的项目中是通过在\u003ccode\u003epackage${flavorName}\u003c/code\u003e Task（感兴趣的同学可以查看\u003ca href=\"https://android.googlesource.com/platform/tools/build/+/master/gradle/src/main/groovy/com/android/build/gradle/tasks/PackageApplication.groovy\"\u003e源码\u003c/a\u003e）之前进行这个操作的。\u003c/p\u003e\u003cp\u003e下面是部分代码片段：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eappPlugin.variantManager.variantDataList.each { variantData -\u0026gt;\n    variantData.outputs.each {\n        def sourceApFile = it.packageAndroidArtifactTask.getResourceFile();\n        def destApFile = new File(\u0026#34;${sourceApFile.name}.temp\u0026#34;, sourceApFile.parentFile);\n        it.packageAndroidArtifactTask.doFirst {\n            byte[] buf = new byte[1024 * 8];\n\n            ZipInputStream zin = new ZipInputStream(new FileInputStream(sourceApFile));\n            ZipOutputStream out = new ZipOutputStream(new FileOutputStream(destApFile));\n\n            ZipEntry entry = zin.getNextEntry();\n            while (entry != null) {\n                String name = entry.getName();\n\n                // Add ZIP entry to output stream.\n                ZipEntry zipEntry = new ZipEntry(name);\n\n                if (ZipEntry.STORED == entry.getMethod() \u0026amp;\u0026amp; !okayToCompress(entry.getName())) {\n                    zipEntry.setMethod(ZipEntry.STORED)\n                    zipEntry.setSize(entry.getSize())\n                    zipEntry.setCompressedSize(entry.getCompressedSize())\n                    zipEntry.setCrc(entry.getCrc())\n                } else {\n                    zipEntry.setMethod(ZipEntry.DEFLATED)\n                    ...\n                }\n                ...\n\n                out.putNextEntry(zipEntry);\n                out.closeEntry();\n                entry = zin.getNextEntry();\n            }\n            // Close the streams\n            zin.close();\n            out.close();\n\n            sourceApFile.delete();\n            destApFile.renameTo(sourceApFile);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当然也可以在其它构建步骤中采用更高压缩率的方式来达到瘦身效果，例如\u003ca href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==\u0026amp;mid=208135658\u0026amp;idx=1\u0026amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\"\u003e采用7Zip压缩\u003c/a\u003e等等。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e本技巧的使用需要注意以下问题：\n* 如果音视频资源被压缩存放在APK中的话，在使用一些音频、视频API时尤其要注意，需要做好充分的测试。\n* resources.arsc文件最好不要压缩存储，如果压缩会影响一定的性能（尤其是冷启动时间）。\n* 如果想在\u003ccode\u003eAndroid 6.0\u003c/code\u003e上开启\u003ccode\u003eandroid:extractNativeLibs=”false”\u003c/code\u003e的话，.so 文件也不能被压缩，\u003ccode\u003eandroid:extractNativeLibs\u003c/code\u003e的使用姿势看这里：\u003ca href=\"https://developer.android.com/guide/topics/manifest/application-element.html#extractNativeLibs\"\u003eApp Manifest — application\u003c/a\u003e。\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"classes-dex的优化\"\u003eclasses.dex的优化\u003c/h2\u003e\u003cp\u003e如何优化classes.dex的大小呢？大体有如下套路：\u003c/p\u003e\u003cul\u003e\u003cli\u003e时刻保持良好的编程习惯和对包体积敏锐的嗅觉，去除重复或者不用的代码，慎用第三方库，选用体积小的第三方SDK等等。\u003c/li\u003e\u003cli\u003e开启ProGuard来进行代码压缩，通过使用ProGuard来对代码进行混淆、优化、压缩等工作。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e针对第一种套路，因各个公司的项目的差异，共性的东西较少，需要case by case的分析，这里不做过多的介绍。\u003c/p\u003e\u003ch3 id=\"压缩代码\"\u003e压缩代码\u003c/h3\u003e\u003cp\u003e可以通过开启ProGuard来实现代码压缩，可以在build.gradle文件相应的构建类型中添加\u003ccode\u003eminifyEnabled true\u003c/code\u003e。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e请注意，代码压缩会拖慢构建速度，因此应该尽可能避免在调试构建中使用。不过一定要为用于测试的最终APK启用代码压缩，如果不能充分地自定义要保留的代码，可能会引入错误。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e例如，下面这段来自build.gradle文件的代码用于为发布构建启用代码压缩：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eandroid {\n    buildTypes {\n        release {\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile(‘proguard-android.txt\u0026#39;),\n                    \u0026#39;proguard-rules.pro\u0026#39;\n        }\n    }\n    ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e除了\u003ccode\u003eminifyEnabled\u003c/code\u003e属性外，还有用于定义ProGuard规则的proguardFiles属性：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003egetDefaultProguardFile(‘proguard-android.txt\u0026#39;)\u003c/code\u003e是从Android SDK\u003ccode\u003etools/proguard/\u003c/code\u003e文件夹获取默认ProGuard设置。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eproguard-rules.pro\u003c/code\u003e文件用于添加自定义ProGuard规则。默认情况下，该文件位于模块根目录（build.gradle文件旁）。\u003c/li\u003e\u003c/ul\u003e\u003cblockquote\u003e\u003cp\u003e提示：要想做进一步的代码压缩，可尝试使用位于同一位置的\u003ccode\u003eproguard-android-optimize.txt\u003c/code\u003e文件。它包括相同的ProGuard规则，但还包括其他在字节码一级（方法内和方法间）执行分析的优化，以进一步减小APK大小和帮助提高其运行速度。\u003c/p\u003e\u003cp\u003e在Gradle Plugin 2.2.0及以上版本ProGuard的配置文件会自动解压缩到\u003ccode\u003e${rootProject.buildDir}/${AndroidProject.FD_INTERMEDIATES}/proguard-files/\u003c/code\u003e目录下，\u003ccode\u003eproguardFiles\u003c/code\u003e会从这个目录来获取ProGuard配置。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e每次执行完ProGuard之后，ProGuard都会在\u003ccode\u003e${project.buildDir}/outputs/mapping/${flavorDir}/\u003c/code\u003e生成以下文件：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e文件名\u003c/th\u003e\u003cth align=\"left\"\u003e描述\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003edump.txt\u003c/td\u003e\u003ctd align=\"left\"\u003eAPK中所有类文件的内部结构\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003emapping.txt\u003c/td\u003e\u003ctd align=\"left\"\u003e提供原始与混淆过的类、方法和字段名称之间的转换，可以通过\u003ccode\u003eproguard.obfuscate.MappingReader\u003c/code\u003e来解析\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eseeds.txt\u003c/td\u003e\u003ctd align=\"left\"\u003e列出未进行混淆的类和成员\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eusage.txt\u003c/td\u003e\u003ctd align=\"left\"\u003e列出从APK移除的代码\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e可以通过在\u003ccode\u003eusage.txt\u003c/code\u003e文件中看到哪些代码被删除了，如下图中所示\u003ccode\u003eandroid.support.multidex.MultiDex\u003c/code\u003e已经被删除了：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/e43a0df4.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"r-field的优化\"\u003eR Field的优化\u003c/h3\u003e\u003cp\u003e除了对项目代码优化和开启代码压缩之外，笔者在\u003ca href=\"http://tech.meituan.com/mt-android-auto-split-dex.html\"\u003e《美团Android DEX自动拆包及动态加载简介》\u003c/a\u003e这篇文章中提到了通过内联R Field来解决R Field过多导致MultiDex 65536的问题，而这一步骤对代码瘦身能够起到明显的效果。下面是笔者通过字节码工具在构建流程中内联R Field的代码片段（字节码的修改可以使用\u003ca href=\"http://jboss-javassist.github.io/javassist/\"\u003eJavassist\u003c/a\u003e或者\u003ca href=\"http://asm.ow2.org/\"\u003eASM\u003c/a\u003e，该步骤笔者采用的是Javassist）。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003ectBehaviors.each { CtBehavior ctBehavior -\u0026gt;\n    if (!ctBehavior.isEmpty()) {\n        try {\n            ctBehavior.instrument(new ExprEditor() {\n                @Override\n                public void edit(FieldAccess f) {\n                    try {\n                        def fieldClassName = JavassistUtils.getClassNameFromCtClass(f.getCtClass())\n                        if (shouldInlineRField(className, fieldClassName) \u0026amp;\u0026amp; f.isReader()) {\n                            def temp = fieldClassName.substring(fieldClassName.indexOf(ANDROID_RESOURCE_R_FLAG) + ANDROID_RESOURCE_R_FLAG.length())\n                            def fieldName = f.fieldName\n                            def key = \u0026#34;${temp}.${fieldName}\u0026#34;\n\n                            if (resourceSymbols.containsKey(key)) {\n                                Object obj = resourceSymbols.get(key)\n                                try {\n                                    if (obj instanceof Integer) {\n                                        int value = ((Integer) obj).intValue()\n                                        f.replace(\u0026#34;\\$_=${value};\u0026#34;)\n                                    } else if (obj instanceof Integer[]) {\n                                        def obj2 = ((Integer[]) obj)\n                                        StringBuilder stringBuilder = new StringBuilder()\n                                        for (int index = 0; index \u0026lt; obj2.length; ++index) {\n                                            stringBuilder.append(obj2[index].intValue())\n                                            if (index != obj2.length - 1) {\n                                                stringBuilder.append(\u0026#34;,\u0026#34;)\n                                            }\n                                        }\n                                        f.replace(\u0026#34;\\$_ = new int[]{${stringBuilder.toString()}};\u0026#34;)\n                                    } else {\n                                        throw new GradleException(\u0026#34;Unknown ResourceSymbols Type!\u0026#34;)\n                                    }\n                                } catch (NotFoundException e) {\n                                    throw new GradleException(e.message)\n                                } catch (CannotCompileException e) {\n                                    throw new GradleException(e.message)\n                                }\n                            } else {\n                                throw new GradleException(\u0026#34;******** InlineRFieldTask unprocessed ${className}, ${fieldClassName}, ${f.fieldName}, ${key}\u0026#34;)\n                            }\n                        }\n                    } catch (NotFoundException e) {\n                    }\n                }\n            })\n        } catch (CannotCompileException e) {\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"其它优化手段\"\u003e其它优化手段\u003c/h3\u003e\u003cp\u003e针对代码的瘦身还有很多优化的技巧，例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e减少ENUM的使用（详情可以参考：\u003ca href=\"https://developer.android.com/topic/performance/reduce-apk-size.html#reduce-code\"\u003eRemove Enumerations\u003c/a\u003e），每减少一个ENUM可以减少大约1.0到1.4 KB的大小；\u003c/li\u003e\u003cli\u003e通过\u003ca href=\"https://pmd.github.io/pmd-5.4.1/usage/cpd-usage.html\"\u003epmd cpd\u003c/a\u003e来检查重复的代码从而进行代码优化；\u003c/li\u003e\u003cli\u003e移除掉所有无用或者功能重复的依赖库。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这些优化技巧就不展开介绍了。\u003c/p\u003e\u003ch2 id=\"资源的优化\"\u003e资源的优化\u003c/h2\u003e\u003ch3 id=\"图片优化\"\u003e图片优化\u003c/h3\u003e\u003cp\u003e为了支持Android设备DPI的多样化（[l|m|tv|h|x|xx|xxx]dpi）以及用户对高质量UI的期待，美团App中使用了大量的图片，在Android下支持很多格式的图片，例如：\u003ca href=\"https://en.wikipedia.org/wiki/Portable_Network_Graphics\"\u003ePNG\u003c/a\u003e、\u003ca href=\"https://en.wikipedia.org/wiki/JPEG\"\u003eJPG\u003c/a\u003e 、\u003ca href=\"https://en.wikipedia.org/wiki/WebP\"\u003eWebP\u003c/a\u003e，那我们该怎么选择不同类型的图片格式呢？ 在\u003ccode\u003eGoogle I/O 2016\u003c/code\u003e中提到了针对图片格式的选择，来看下图（图片来源于\u003ca href=\"https://events.google.com/io2016/schedule?sid=8c2d2aeb-0bef-e511-a517-00155d5066d7\"\u003eImage compression for Android developers\u003c/a\u003e）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/25cf827c.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过上图可以看出一个大概图片格式选择的方法。如果能用\u003ccode\u003eVectorDrawable\u003c/code\u003e来表示的话优先使用VectorDrawable，如果支持\u003ccode\u003eWebP\u003c/code\u003e则优先用WebP，而\u003ccode\u003ePNG\u003c/code\u003e主要用在展示透明或者简单的图片，而其它场景可以使用\u003ccode\u003eJPG\u003c/code\u003e格式。针对每种图片格式也有各类的优化手段和优化工具。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e使用矢量图片\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e可以使用\u003ca href=\"https://developer.android.com/guide/topics/graphics/vector-drawable-resources.html\"\u003e矢量图形\u003c/a\u003e来创建独立于分辨率的图标和其他可伸缩图片。使用矢量图片能够有效的减少App中图片所占用的大小，矢量图形在Android中表示为\u003ca href=\"https://developer.android.com/guide/topics/graphics/vector-drawable-resources.html\"\u003eVectorDrawable\u003c/a\u003e对象。 使用\u003ca href=\"https://developer.android.com/guide/topics/graphics/vector-drawable-resources.html\"\u003eVectorDrawable\u003c/a\u003e对象，100字节的文件可以生成屏幕大小的清晰图像，但系统渲染每个VectorDrawable对象需要大量的时间，较大的图像需要更长的时间才能出现在屏幕上。 因此只有在显示小图像时才考虑使用矢量图形。有关使用\u003ca href=\"https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html\"\u003eVectorDrawable\u003c/a\u003e的更多信息，请参阅 \u003ca href=\"https://developer.android.com/training/material/drawables.html\"\u003eWorking with Drawables\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e使用WebP\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如果App的\u003ccode\u003eminSdkVersion\u003c/code\u003e高于14（\u003ccode\u003eAndroid 4.0+\u003c/code\u003e）的话，可以选用WebP格式，因为WebP在同画质下体积更小（WebP支持透明度，压缩比比JPEG更高但显示效果却不输于JPEG，官方评测quality参数等于75均衡最佳）， 可以通过\u003ca href=\"https://developers.google.com/speed/webp/docs/precompiled\"\u003ePNG到WebP转换工具\u003c/a\u003e来进行转换。当然Android从4.0才开始WebP的原生支持，但是不支持包含透明度，直到\u003ccode\u003eAndroid 4.2.1+\u003c/code\u003e才支持显示含透明度的WebP，在笔者使用中是判断当前App的\u003ccode\u003eminSdkVersion\u003c/code\u003e以及图片文件的类型（是否为透明）来选用是否适用WebP。见下面的代码片段：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eboolean isPNGWebpConvertSupported() {\n    if (!isWebpConvertEnable()) {\n        return false\n    }\n\n    // Android 4.0+\n    return GradleUtils.getAndroidExtension(project).defaultConfig.minSdkVersion.apiLevel \u0026gt;= 14\n    // 4.0\n}\n\nboolean isTransparencyPNGWebpConvertSupported() {\n    if (!isWebpConvertEnable()) {\n        return false\n    }\n\n    // Lossless, Transparency, Android 4.2.1+\n    return GradleUtils.getAndroidExtension(project).defaultConfig.minSdkVersion.apiLevel \u0026gt;= 18\n    // 4.3\n}\n\ndef convert() {\n    String resPath = \u0026#34;${project.buildDir}/${AndroidProject.FD_INTERMEDIATES}/res/merged/${variant.dirName}\u0026#34;\n    def resDir = new File(\u0026#34;${resPath}\u0026#34;)\n    resDir.eachDirMatch(~/drawable[a-z0-9-]*/) { dir -\u0026gt;\n        FileTree tree = project.fileTree(dir: dir)\n        tree.filter { File file -\u0026gt;\n            return (isJPGWebpConvertSupported() \u0026amp;\u0026amp; (file.name.endsWith(SdkConstants.DOT_JPG) || file.name.endsWith(SdkConstants.DOT_JPEG))) || (isPNGWebpConvertSupported() \u0026amp;\u0026amp; file.name.endsWith(SdkConstants.DOT_PNG) \u0026amp;\u0026amp; !file.name.endsWith(SdkConstants.DOT_9PNG))\n        }.each { File file -\u0026gt;\n            def shouldConvert = true\n            if (file.name.endsWith(SdkConstants.DOT_PNG)) {\n                if (!isTransparencyPNGWebpConvertSupported()) {\n                    shouldConvert = !Imaging.getImageInfo(file).isTransparent()\n                }\n            }\n            if (shouldConvert) {\n                WebpUtils.encode(project, webpFactorQuality, file.absolutePath, webp)\n            }\n        }\n    }\n}   \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e选择更优的压缩工具\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e可以使用\u003ca href=\"http://pmt.sourceforge.net/pngcrush/\"\u003epngcrush\u003c/a\u003e、\u003ca href=\"https://pngquant.org/\"\u003epngquant\u003c/a\u003e或\u003ca href=\"https://github.com/google/zopfli\"\u003ezopflipng\u003c/a\u003e等压缩工具来减少PNG文件大小，而不会丢失图像质量。所有这些工具都可以减少PNG文件大小，同时保持图像质量。\u003c/p\u003e\u003cp\u003e\u003ca href=\"http://pmt.sourceforge.net/pngcrush/\"\u003epngcrush\u003c/a\u003e工具特别有效：此工具在PNG过滤器和zlib（Deflate）参数上迭代，使用过滤器和参数的每个组合来压缩图像。然后选择产生最小压缩输出的配置。\u003c/p\u003e\u003cp\u003e对于JPEG文件，你可以使用\u003ca href=\"http://www.elektronik.htw-aalen.de/packjpg/\"\u003epackJPG\u003c/a\u003e或\u003ca href=\"https://github.com/google/guetzli/\"\u003eguetzli\u003c/a\u003e等工具将JPEG文件压缩的更小，这些工具能够在保持图片质量不变的情况下，把图片文件压缩的更小。\u003ca href=\"https://github.com/google/guetzli/\"\u003eguetzli\u003c/a\u003e工具更是能够在图片质量不变的情况下，将文件大小降低35%。\u003c/p\u003e\u003cp\u003e在Android构建流程中AAPT会使用内置的压缩算法来优化\u003ccode\u003eres/drawable/\u003c/code\u003e目录下的PNG图片，但也可能会导致本来已经优化过的图片体积变大，可以通过在\u003ccode\u003ebuild.gradle\u003c/code\u003e中设置\u003ccode\u003ecruncherEnabled\u003c/code\u003e来禁止AAPT来优化PNG图片。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eaaptOptions {\n    cruncherEnabled = false\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"开启资源压缩\"\u003e开启资源压缩\u003c/h3\u003e\u003cp\u003eAndroid的编译工具链中提供了一款资源压缩的工具，可以通过该工具来压缩资源，如果要启用资源压缩，可以在build.gradle文件中将\u003ccode\u003eshrinkResources true\u003c/code\u003e。例如：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eandroid {\n    ...\n    buildTypes {\n        release {\n            shrinkResources true\n            minifyEnabled true\n            proguardFiles getDefaultProguardFile(\u0026#39;proguard-android.txt\u0026#39;),\n                    \u0026#39;proguard-rules.pro\u0026#39;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003e需要注意的是目前资源压缩器目前不会移除values/文件夹中定义的资源（例如字符串、尺寸、样式和颜色），有关详情，请参阅\u003ca href=\"https://code.google.com/p/android/issues/detail?id=70869\u0026amp;hl=zh-cn\"\u003e问题 70869\u003c/a\u003e。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eAndroid构建工具是通过\u003ca href=\"https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/build-system/gradle-core/src/main/groovy/com/android/build/gradle/tasks/ResourceUsageAnalyzer.java\"\u003eResourceUsageAnalyzer\u003c/a\u003e来检查哪些资源是无用的，当检查到无用的资源时会把该资源替换成预定义的版本。详看下面代码片段（摘自\u003ccode\u003ecom.android.build.gradle.tasks.ResourceUsageAnalyzer\u003c/code\u003e）：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ResourceUsageAnalyzer {\n\t...\n\n    /**\n     * Whether we should create small/empty dummy files instead of actually\n     * removing file resources. This is to work around crashes on some devices\n     * where the device is traversing resources. See http://b.android.com/79325 for more.\n     */\n    public static final boolean REPLACE_DELETED_WITH_EMPTY = true;\n\n  \t// A 1x1 pixel PNG of type BufferedImage.TYPE_BYTE_GRAY\n    public static final byte[] TINY_PNG = new byte[] {\n            (byte)-119, (byte)  80, (byte)  78, (byte)  71, (byte)  13, (byte)  10,\n            (byte)  26, (byte)  10, (byte)   0, (byte)   0, (byte)   0, (byte)  13,\n            (byte)  73, (byte)  72, (byte)  68, (byte)  82, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   1, (byte)   0, (byte)   0, (byte)   0, (byte)   1,\n            (byte)   8, (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)  58,\n            (byte) 126, (byte)-101, (byte)  85, (byte)   0, (byte)   0, (byte)   0,\n            (byte)  10, (byte)  73, (byte)  68, (byte)  65, (byte)  84, (byte) 120,\n            (byte) -38, (byte)  99, (byte)  96, (byte)   0, (byte)   0, (byte)   0,\n            (byte)   2, (byte)   0, (byte)   1, (byte) -27, (byte)  39, (byte) -34,\n            (byte)  -4, (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)  73,\n            (byte)  69, (byte)  78, (byte)  68, (byte) -82, (byte)  66, (byte)  96,\n            (byte)-126\n    };\n\n    public static final long TINY_PNG_CRC = 0x88b2a3b0L;\n\n    // A 3x3 pixel PNG of type BufferedImage.TYPE_INT_ARGB with 9-patch markers\n    public static final byte[] TINY_9PNG = new byte[] {\n            (byte)-119, (byte)  80, (byte)  78, (byte)  71, (byte)  13, (byte)  10,\n            (byte)  26, (byte)  10, (byte)   0, (byte)   0, (byte)   0, (byte)  13,\n            (byte)  73, (byte)  72, (byte)  68, (byte)  82, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   3, (byte)   0, (byte)   0, (byte)   0, (byte)   3,\n            (byte)   8, (byte)   6, (byte)   0, (byte)   0, (byte)   0, (byte)  86,\n            (byte)  40, (byte) -75, (byte) -65, (byte)   0, (byte)   0, (byte)   0,\n            (byte)  20, (byte)  73, (byte)  68, (byte)  65, (byte)  84, (byte) 120,\n            (byte) -38, (byte)  99, (byte)  96, (byte)-128, (byte)-128, (byte)  -1,\n            (byte)  12, (byte)  48, (byte)   6, (byte)   8, (byte) -96, (byte)   8,\n            (byte)-128, (byte)   8, (byte)   0, (byte)-107, (byte)-111, (byte)   7,\n            (byte)  -7, (byte) -64, (byte) -82, (byte)   8, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   0, (byte)  73, (byte)  69, (byte)  78,\n            (byte)  68, (byte) -82, (byte)  66, (byte)  96, (byte)-126\n    };\n\n    public static final long TINY_9PNG_CRC = 0x1148f987L;\n\n    // The XML document \u0026lt;x/\u0026gt; as binary-packed with AAPT\n    public static final byte[] TINY_XML = new byte[] {\n            (byte)   3, (byte)   0, (byte)   8, (byte)   0, (byte) 104, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   1, (byte)   0, (byte)  28, (byte)   0,\n            (byte)  36, (byte)   0, (byte)   0, (byte)   0, (byte)   1, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   1, (byte)   0, (byte)   0, (byte)  32, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   1, (byte)   1,\n            (byte) 120, (byte)   0, (byte)   2, (byte)   1, (byte)  16, (byte)   0,\n            (byte)  36, (byte)   0, (byte)   0, (byte)   0, (byte)   1, (byte)   0,\n            (byte)   0, (byte)   0, (byte)  -1, (byte)  -1, (byte)  -1, (byte)  -1,\n            (byte)  -1, (byte)  -1, (byte)  -1, (byte)  -1, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   0, (byte)  20, (byte)   0, (byte)  20, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   0, (byte)   3, (byte)   1, (byte)  16, (byte)   0,\n            (byte)  24, (byte)   0, (byte)   0, (byte)   0, (byte)   1, (byte)   0,\n            (byte)   0, (byte)   0, (byte)  -1, (byte)  -1, (byte)  -1, (byte)  -1,\n            (byte)  -1, (byte)  -1, (byte)  -1, (byte)  -1, (byte)   0, (byte)   0,\n            (byte)   0, (byte)   0\n    };\n\n    public static final long TINY_XML_CRC = 0xd7e65643L;\n\n    ...\n}    \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面截图中3个byte数组的定义就是资源压缩工具为无用资源提供的预定义版本，可以看出对\u003ccode\u003e.png\u003c/code\u003e提供了\u003ccode\u003eTINY_PNG\u003c/code\u003e， 对\u003ccode\u003e.9.png\u003c/code\u003e提供了\u003ccode\u003eTINY_9PNG\u003c/code\u003e以及对\u003ccode\u003e.xml\u003c/code\u003e提供了\u003ccode\u003eTINY_XML\u003c/code\u003e的预定义版本。\u003c/p\u003e\u003cp\u003e资源压缩工具的详细使用可以参考\u003ca href=\"https://developer.android.com/studio/build/shrink-code.html\"\u003eShrink Your Code and Resources\u003c/a\u003e。资源压缩工具默认是采用安全压缩模式来运行，可以通过\u003ca href=\"https://developer.android.com/studio/build/shrink-code.html#strict-reference-checks\"\u003e开启严格压缩模式\u003c/a\u003e来达到更好的瘦身效果。\u003c/p\u003e\u003cp\u003e如果想知道哪些资源是无用的，可以通过资源压缩工具的输出日志文件\u003ccode\u003e${project.buildDir}/outputs/mapping/release/resources.txt\u003c/code\u003e来查看。如下图所示\u003ccode\u003eres/layout/abc_activity_chooser_viewer.xml\u003c/code\u003e就是无用的，然后被预定义的版本\u003ccode\u003eTINY_XML\u003c/code\u003e所替换：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/9ae476f2.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e资源压缩工具只是把无用资源替换成预定义较小的版本，那我们如何删除这些无用资源呢？通常的做法是结合资源压缩工具的输出日志，找到这些资源并把它们进行删除。但在笔者的项目中很多无用资源是被其它组件或第三方SDK所引入的，如果采用这种优化方式会带来这些SDK后期维护成本的增加，针对这种情况笔者是通过采用在resources.arsc中做优化来解决的，详情看下面“resources.arsc的优化”一节的介绍。\u003c/p\u003e\u003ch3 id=\"语言资源优化\"\u003e语言资源优化\u003c/h3\u003e\u003cp\u003e根据App自身支持的语言版本选用合适的语言资源，例如使用了AppCompat，如果不做任何配置的话，最终APK包中会包含AppCompat中消息的所有已翻译语言字符串，无论应用的其余部分是否翻译为同一语言，可以通过\u003ccode\u003eresConfig\u003c/code\u003e来配置使用哪些语言，从而让构建工具移除指定语言之外的所有资源。下图是具体的配置示例：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003eandroid {\n\t...\n    defaultConfig {\n    \t...\n        resConfigs \u0026#34;zh\u0026#34;, \u0026#34;zh-rCN\u0026#34;\n    }\n    ...\n}    \n\u003c/code\u003e\u003c/pre\u003e\u003cblockquote\u003e\u003cp\u003e针对为不同DPI所提供的图片也可以采用相同的策略，需要针对自身的目标用户和目标设备做一定的选择，可以参考\u003ca href=\"https://developer.android.com/topic/performance/reduce-apk-size.html?#reduce-resources\"\u003eSupport Only Specific Densities\u003c/a\u003e来操作。有关屏幕密度的详细信息，请参阅\u003ca href=\"https://developer.android.com/about/dashboards/index.html#Screens\"\u003eScreen Sizes and Densities\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e对\u003ccode\u003e.so\u003c/code\u003e文件也可以采用类似的策略，比如笔者的项目中只保留了\u003ccode\u003earmeabi\u003c/code\u003e版本的\u003ccode\u003e.so\u003c/code\u003e文件。\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"resources-arsc的优化\"\u003eresources.arsc的优化\u003c/h2\u003e\u003cp\u003e针对\u003ccode\u003eresources.arsc\u003c/code\u003e，笔者尝试过的优化手段如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e开启资源混淆；\u003c/li\u003e\u003cli\u003e对重复的资源进行优化；\u003c/li\u003e\u003cli\u003e对被\u003ccode\u003eshrinkResources\u003c/code\u003e优化掉的资源进行处理。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e下面将分别对这些优化手段进行展开介绍。\u003c/p\u003e\u003ch3 id=\"资源混淆\"\u003e资源混淆\u003c/h3\u003e\u003cp\u003e在笔者另一篇\u003ca href=\"http://tech.meituan.com/mt-android-resource-obfuscation.html\"\u003e《美团Android资源混淆保护实践》\u003c/a\u003e文章中介绍了采用对资源混淆的方式来保护资源的安全，同时也提到了这种方式有显著的瘦身效果。笔者当时是采用修改AAPT的相关源码的方式，这种方式的痛点是每次升级\u003ccode\u003eBuild Tools\u003c/code\u003e都要修改一次AAPT源码，维护性较差。目前笔者采用了微信开源的资源混淆库\u003ca href=\"https://github.com/shwenzhang/AndResGuard\"\u003eAndResGuard\u003c/a\u003e，具体的原理和使用帮助可以参考\u003ca href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==\u0026amp;mid=208135658\u0026amp;idx=1\u0026amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\"\u003e安装包立减1M–微信Android资源混淆打包工具\u003c/a\u003e。\u003c/p\u003e\u003ch3 id=\"无用资源优化\"\u003e无用资源优化\u003c/h3\u003e\u003cp\u003e在上一节中介绍了可以通过\u003ccode\u003eshrinkResources true\u003c/code\u003e来开启资源压缩，资源压缩工具会把无用的资源替换成预定义的版本而不是移除，如果采用人工移除的方式会带来后期的维护成本，这里笔者采用了一种比较取巧的方式，在Android构建工具执行\u003ccode\u003epackage${flavorName}\u003c/code\u003eTask之前通过修改\u003ccode\u003eCompiled Resources\u003c/code\u003e来实现自动去除无用资源。\u003c/p\u003e\u003cp\u003e具体流程如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e收集资源包（\u003ccode\u003eCompiled Resources\u003c/code\u003e的简称）中被替换的预定义版本的资源名称，通过查看资源包（Zip格式）中每个\u003ccode\u003eZipEntry\u003c/code\u003e的\u003ccode\u003eCRC-32 checksum\u003c/code\u003e来寻找被替换的预定义资源，预定义资源的\u003ccode\u003eCRC-32\u003c/code\u003e定义在\u003ca href=\"https://android.googlesource.com/platform/tools/base/+/gradle_2.0.0/build-system/gradle-core/src/main/groovy/com/android/build/gradle/tasks/ResourceUsageAnalyzer.java\"\u003eResourceUsageAnalyzer\u003c/a\u003e，下面是它们的定义。\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e  \t// A 1x1 pixel PNG of type BufferedImage.TYPE_BYTE_GRAY\n    public static final long TINY_PNG_CRC = 0x88b2a3b0L;\n\n    // A 3x3 pixel PNG of type BufferedImage.TYPE_INT_ARGB with 9-patch markers\n    public static final long TINY_9PNG_CRC = 0x1148f987L;\n\n    // The XML document \u0026lt;x/\u0026gt; as binary-packed with AAPT\n    public static final long TINY_XML_CRC = 0xd7e65643L;\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e通过\u003ca href=\"https://github.com/madisp/android-chunk-utils\"\u003eandroid-chunk-utils\u003c/a\u003e把\u003ccode\u003eresources.arsc\u003c/code\u003e中对应的定义移除；\u003c/li\u003e\u003cli\u003e删除资源包中对应的资源文件。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"重复资源优化\"\u003e重复资源优化\u003c/h3\u003e\u003cp\u003e目前美团App是由各个业务团队共同开发完成，为了方便各业务团队的独立开发，美团App进行了平台化改造。改造时存在很多资源文件（如：drawable、layout等）被不同的业务团队都拷贝到自己的Library下，同时为了避免引发资源覆盖的问题，每个业务团队都会为自己的资源文件名添加前缀。这样就导致了这些资源文件虽然内容相同，但因为名称的不同而不能被覆盖，最终都会被集成到APK包中，针对这种问题笔者采用了和前面“无用资源优化”一节中描述类似的策略。\u003c/p\u003e\u003cp\u003e具体步骤如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e通过资源包中的每个\u003ccode\u003eZipEntry\u003c/code\u003e的\u003ccode\u003eCRC-32 checksum\u003c/code\u003e来筛选出重复的资源；\u003c/li\u003e\u003cli\u003e通过\u003ca href=\"https://github.com/madisp/android-chunk-utils\"\u003eandroid-chunk-utils\u003c/a\u003e修改\u003ccode\u003eresources.arsc\u003c/code\u003e，把这些重复的资源都\u003ccode\u003e重定向\u003c/code\u003e到同一个文件上；\u003c/li\u003e\u003cli\u003e把其它重复的资源文件从资源包中删除。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e代码片段：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003evariantData.outputs.each {\n    def apFile = it.packageAndroidArtifactTask.getResourceFile();\n\n    it.packageAndroidArtifactTask.doFirst {\n        def arscFile = new File(apFile.parentFile, \u0026#34;resources.arsc\u0026#34;);\n        JarUtil.extractZipEntry(apFile, \u0026#34;resources.arsc\u0026#34;, arscFile);\n\n        def HashMap\u0026lt;String, ArrayList\u0026lt;DuplicatedEntry\u0026gt;\u0026gt; duplicatedResources = findDuplicatedResources(apFile);\n\n        removeZipEntry(apFile, \u0026#34;resources.arsc\u0026#34;);\n\n        if (arscFile.exists()) {\n            FileInputStream arscStream = null;\n            ResourceFile resourceFile = null;\n            try {\n                arscStream = new FileInputStream(arscFile);\n\n                resourceFile = ResourceFile.fromInputStream(arscStream);\n                List\u0026lt;Chunk\u0026gt; chunks = resourceFile.getChunks();\n\n                HashMap\u0026lt;String, String\u0026gt; toBeReplacedResourceMap = new HashMap\u0026lt;String, String\u0026gt;(1024);\n\n                // 处理arsc并删除重复资源\n                Iterator\u0026lt;Map.Entry\u0026lt;String, ArrayList\u0026lt;DuplicatedEntry\u0026gt;\u0026gt;\u0026gt; iterator = duplicatedResources.entrySet().iterator();\n                while (iterator.hasNext()) {\n                    Map.Entry\u0026lt;String, ArrayList\u0026lt;DuplicatedEntry\u0026gt;\u0026gt; duplicatedEntry = iterator.next();\n\n                    // 保留第一个资源，其他资源删除掉\n                    for (def index = 1; index \u0026lt; duplicatedEntry.value.size(); ++index) {\n                        removeZipEntry(apFile, duplicatedEntry.value.get(index).name);\n\n                        toBeReplacedResourceMap.put(duplicatedEntry.value.get(index).name, duplicatedEntry.value.get(0).name);\n                    }\n                }\n\n                for (def index = 0; index \u0026lt; chunks.size(); ++index) {\n                    Chunk chunk = chunks.get(index);\n                    if (chunk instanceof ResourceTableChunk) {\n                        ResourceTableChunk resourceTableChunk = (ResourceTableChunk) chunk;\n                        StringPoolChunk stringPoolChunk = resourceTableChunk.getStringPool();\n                        for (def i = 0; i \u0026lt; stringPoolChunk.stringCount; ++i) {\n                            def key = stringPoolChunk.getString(i);\n                            if (toBeReplacedResourceMap.containsKey(key)) {\n                                stringPoolChunk.setString(i, toBeReplacedResourceMap.get(key));\n                            }\n                        }\n                    }\n                }\n\n            } catch (IOException ignore) {\n            } catch (FileNotFoundException ignore) {\n            } finally {\n                if (arscStream != null) {\n                    IOUtils.closeQuietly(arscStream);\n                }\n\n                arscFile.delete();\n                arscFile \u0026lt;\u0026lt; resourceFile.toByteArray();\n\n                addZipEntry(apFile, arscFile);\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过这种方式可以有效减少重复资源对包体大小的影响，同时这种操作方式对各业务团队透明，也不会增加协调相同资源如何被不同业务团队复用的成本。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e上述就是我们目前在APK瘦身方面的做的一些尝试和积累，可以根据自身情况取舍使用。当然我们还可以采取一些按需加载的策略来减少安装包的体积。最后提一点，砍掉不必要的功能才是安装包瘦身的超级大招。一个好的App的标准有很多方面，但提供尽可能小的安装包是其中一个重要的方面，这也是对我们Android开发者人员自身的提出的基本要求，要时刻保持良好的编程习惯和对包体积敏锐的嗅觉。\u003c/p\u003e\u003ch2 id=\"参考文献\"\u003e参考文献\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Android_application_package\"\u003eAndroid application package (APK)\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://en.wikipedia.org/wiki/Zip_(file_format)\"\u003eZip (file format)\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://tools.android.com/tech-docs/new-build-system/build-workflow\"\u003eBuild Workflow\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://android.googlesource.com/platform/frameworks/base.git/+/master/tools/aapt\"\u003eAndroid AAPT Source Code\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.android.com/topic/performance/reduce-apk-size.html\"\u003eReduce APK Size\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.android.com/studio/build/shrink-code.html\"\u003eShrink Your Code and Resources\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.android.com/topic/performance/memory.html\"\u003eManage Your App’s Memory\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://developer.android.com/guide/topics/graphics/vector-drawable-resources.html\"\u003eVector Drawable\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://jboss-javassist.github.io/javassist/\"\u003eJavassist\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://asm.ow2.org/\"\u003eASM\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://pmt.sourceforge.net/pngcrush/\"\u003epngcrush\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://pngquant.org/\"\u003epngquant\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/google/zopfli\"\u003ezopflipng\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/madisp/android-chunk-utils\"\u003eandroid-chunk-utils\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==\u0026amp;mid=208135658\u0026amp;idx=1\u0026amp;sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd\"\u003e安装包立减1M–微信Android资源混淆打包工具\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://gold.xitu.io/entry/5824447ca0bb9f0058d9d281\"\u003e减少 APK 的大小，Android 官方这样说\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/21543787\"\u003eGoogle I/O 2016 笔记：APK 瘦身的正确姿势\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cp\u003e建帅，Android技术专家，2015年3月加入美团，目前就职于到店餐饮技术部信息与交易技术中心。\u003c/p\u003e\u003cp\u003e到店餐饮技术部交易与信息技术中心，负责美团美食用户端业务，服务于数以亿计用户，通过更好的榜单、真实的评价和完善的信息为用户提供更好的决策支持，致力于提升用户体验；同时承载所有餐饮商户端线上流量，为餐饮商户提供多种营销工具，提升餐饮商户营销效率，最终达到让国人“Eat Better、Live Better”的美好愿景！我们的团队包含且不限于Android、iOS、FE、Java、PHP等技术方向，已完备覆盖前后端技术栈。只要你来，就能点亮全栈开发技能树。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-04-07T00:00:00Z",
  "Author": "soulteary@gmail.com"
}