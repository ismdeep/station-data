{
  "Source": "tech.meituan.com",
  "Title": "Android漏洞扫描工具Code Arbiter",
  "Link": "https://tech.meituan.com/2017/08/17/android-code-arbiter.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e目前Android应用代码漏洞扫描工具种类繁多，效果良莠不齐，这些工具有一个共同的特点，都是在应用打包完成后对应用进行解包扫描。这种扫描有非常明显的缺点，扫描周期较长，不能向开发者实时反馈代码中存在的安全问题，并且对于问题代码的定位需要手动搜索匹配源码，这样就更不利于开发者对问题代码进行及时的修改。Code Arbiter正是为解决上述两个问题而开发的，专门对Android Studio中的源码进行安全扫描。\u003c/p\u003e\u003cp\u003e为实现对Android Studio中的源码进行扫描，最方便的方式便是将扫描工具以IDE插件的形式进行工作。此时一个很自然的想法便是从头构建一个Android Studio插件，但是进行仔细的评估后会发现，这样做难度并不小：\n1. 工作量大，许多知识需要学习，如IDE开放API接口、插件UI构建等，同时许多底层模块需要从头构建；\n2. 插件的稳定性、检测问题的准确性上都不一定能够达到已有开源工具的效果。\u003c/p\u003e\u003cp\u003e因此我们转而考虑在已有漏洞检测插件的基础上进行扩展，以满足需求。经过调研，最终入围的两款检测插件是PMD和FindBugs，其中PMD是对Java源码进行扫描，而FindBugs则是对Java源码编译后的class文件进行扫描。考虑到可扩展性及检测的准确性，最终选定了FindBugs。FindBugs是一个静态分析工具，它检查类或者JAR文件，将字节码与一组缺陷模式进行对比来发现可能的问题，可以以独立的JAR包形式运行，也可以作为集成开发工具的插件形式存在。\u003c/p\u003e\u003ch3 id=\"扩展优化\"\u003e扩展优化\u003c/h3\u003e\u003cp\u003e那么，怎么扩展FindBugs呢？调研发现FindBugs插件具有着极强的可扩展性，只需要将扩展的JAR包导入FindBugs插件，重启，即可完成相关功能的扩展。安装JAR包示意图如下所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/31b8d136.png\" alt=\"安装jar包\"/\u003e\u003c/p\u003e\u003cp\u003e下面的问题是如何构建可安装的JAR包。继续调研，发现FindBugs有一款专门对安全问题进行检测的扩展插件Find Security Bugs，该插件主要用于对Web安全问题进行检测，也有极少对Android相关安全问题的检测规则。考虑以下几个原因，需要对该插件的源码进行重构。\n1. 对Android安全问题的检测太少，只包含外部文件使用、Webview、Broadcast使用等寥寥几项；\n2. 检测的细粒度上考虑不够完全，会造成大量的误报，无法满足检测精度的要求；\n3. 检测问题的上报只支持英文模式，且问题展示的逻辑性不够严谨，不便于开发者进行问题排查。\u003c/p\u003e\u003cp\u003e基于以上三个原因，我们需要对Find Security Bugs的源码进行重写、优化，通过增加检测项来检测尽可能多的安全问题，通过优化检测规则来减少检测的误报，问题展示使用中文进行描述，同时优化问题描述的逻辑性，使得开发者能够更易理解并修改相关问题，至此插件实现及优化的方案确定。\u003c/p\u003e\u003cp\u003eFindBugs检测的是class文件，因此当待检测的源码未生成编译文件时，FindBugs会先将源码编译生成.class文件，然后对这个class文件进行分析。FindBugs会完成对class文件的自动建模，在此模型的基础上对代码进行分析。按照在实际编写检测代码过程中的总结，把检测的实现方式分成四种方式，下面分别进行介绍。\u003c/p\u003e\u003ch2 id=\"2-1-逐行检查\"\u003e2.1 逐行检查\u003c/h2\u003e\u003cp\u003e逐行检查主要是针对代码中使用的一些不安全方法或参数进行检测，其实现方式是重写sawOpcode()方法，下面以Android中使用外部存储问题作为示例进行讲解。\u003c/p\u003e\u003cp\u003eAndroid中获取外部存储文件夹地址的方法主要包括下面这些方法：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003egetExternalCacheDir()\ngetExternalCacheDirs()\ngetExternalFilesDir()\ngetExternalFilesDirs()\ngetExternalMediaDirs()\nEnvironment.getExternalStorageDirectory()\nEnvironment.getExternalStoragePublicDirectory()\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e检测的方式便是，如果发现存在该方法的调用，则作为一个问题进行上报，实现完整代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ExternalFileAccessDetector extends OpcodeStackDetector {\n\n    private static final String ANDROID_EXTERNAL_FILE_ACCESS_TYPE = \u0026#34;ANDROID_EXTERNAL_FILE_ACCESS\u0026#34;;\n    private BugReporter bugReporter;\n    public ExternalFileAccessDetector(BugReporter bugReporter) {\n        this.bugReporter = bugReporter;\n    }\n\n    @Override\n public void sawOpcode(int seen) {\n        //printOpCode(seen);\n if (seen == Constants.INVOKEVIRTUAL \u0026amp;\u0026amp; (\n        getNameConstantOperand().equals(\u0026#34;getExternalCacheDir\u0026#34;) ||\n        getNameConstantOperand().equals(\u0026#34;getExternalCacheDirs\u0026#34;) ||\n        getNameConstantOperand().equals(\u0026#34;getExternalFilesDir\u0026#34;) ||\n        getNameConstantOperand().equals(\u0026#34;getExternalFilesDirs\u0026#34;) ||\n        getNameConstantOperand().equals(\u0026#34;getExternalMediaDirs\u0026#34;)\n            )) {\n// System.out.println(getSigConstantOperand());\n bugReporter.reportBug(new BugInstance(this, ANDROID_EXTERNAL_FILE_ACCESS_TYPE, Priorities.NORMAL_PRIORITY).addClass(this).addMethod(this).addSourceLine(this));\n        }\n        else if(seen == Constants.INVOKESTATIC \u0026amp;\u0026amp; getClassConstantOperand().equals(\u0026#34;android/os/Environment\u0026#34;) \u0026amp;\u0026amp; (getNameConstantOperand().equals(\u0026#34;getExternalStorageDirectory\u0026#34;) || getNameConstantOperand().equals(\u0026#34;getExternalStoragePublicDirectory\u0026#34;))) {\n            bugReporter.reportBug(new BugInstance(this, ANDROID_EXTERNAL_FILE_ACCESS_TYPE, Priorities.NORMAL_PRIORITY).addClass(this).addMethod(this).addSourceLine(this));\n        }\n    }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该类的实现是继承OpcodeStackDetector类，是FindBugs中的一个抽象类，封装了对于获取代码特定参数的方法调用。sawOpcode方法参数可以理解为待检测代码行的行号，通过printOpCode(seen)可以打印该代码行的具体内容。Constants.INVOKEVIRTUAL表示该行调用类的实例方法，Constants.INVOKESTATIC表示调用类的静态方法。getNameConstantOperand方法表示获取被调用方法的名称，getClassConstantOperand方法表示获取调用类的名称，getSigConstantOperand方法表示获取方法的所有参数。bugReporter.reportBug用于上报检测到的漏洞信息，其中BugInstance的三个参数分别表示：检测器、漏洞类型、漏洞等级，其中漏洞等级分为五个级别，如下表所示：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003e名称\u003c/th\u003e\u003cth align=\"left\"\u003e参数\u003c/th\u003e\u003cth align=\"left\"\u003e含义\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eHIGH_PRIORITY\u003c/td\u003e\u003ctd align=\"left\"\u003e1\u003c/td\u003e\u003ctd align=\"left\"\u003e高危风险\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eNORMAL_PRIORITY\u003c/td\u003e\u003ctd align=\"left\"\u003e2\u003c/td\u003e\u003ctd align=\"left\"\u003e中危风险\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eLOW_PRIORITY\u003c/td\u003e\u003ctd align=\"left\"\u003e3\u003c/td\u003e\u003ctd align=\"left\"\u003e低危风险\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eEXP_PRIORITY\u003c/td\u003e\u003ctd align=\"left\"\u003e4\u003c/td\u003e\u003ctd align=\"left\"\u003e安全提醒\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eIGNORE_PRIORITY\u003c/td\u003e\u003ctd align=\"left\"\u003e5\u003c/td\u003e\u003ctd align=\"left\"\u003e可忽略风险\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eaddClass、addMethod、addSourceLine用于指定该漏洞所在的类、方法、行，方便报告漏洞时定位关键代码。\u003c/p\u003e\u003ch2 id=\"2-2-逐方法检查\"\u003e2.2 逐方法检查\u003c/h2\u003e\u003cp\u003e逐方法检查首先获取待检测类的所有内容，然后对类中的方法进行逐个检查，多用于对方法体进行检测，其实现的方法主要是通过重写visitClassContext方法，下面以对Android TrustManager的空实现的检测为例进行说明。\nTrustManager的空实现，主要是指对于检测Server端证书是否可信的方法checkServerTrusted，是否是空实现。下面展示问题代码，如果是空实现那么将导致客户端接收任意证书，从而造成加密后的HTTPS消息被中间人解密。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException {\n\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e检测的方式是通过遍历类中的所有方法，找到checkServerTrusted方法，对方法整体进行检测，确定其是否为空实现，部分代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class WeakTrustManagerDetector implements Detector {\n...\npublic WeakTrustManagerDetector(BugReporter bugReporter) {\n        this.bugReporter = bugReporter;\n    }\n\n    @Override\n public void visitClassContext(ClassContext classContext) {\n        JavaClass javaClass = classContext.getJavaClass();\n\n        //The class extends X509TrustManager\n  boolean isTrustManager = InterfaceUtils.isSubtype(javaClass,\u0026#34;javax.net.ssl.X509TrustManager\u0026#34;);\n        boolean isHostnameVerifier = InterfaceUtils.isSubtype(javaClass,\u0026#34;javax.net.ssl.HostnameVerifier\u0026#34;);\n\n// if (!isTrustManager \u0026amp;\u0026amp; !isHostnameVerifier) return;\n if (!isTrustManager \u0026amp;\u0026amp; !isHostnameVerifier){\n            for (Method m : javaClass.getMethods()) {\n                allow_All_Hostname_Verify(classContext, javaClass, m);\n            }\n        }\n\n        Method[] methodList = javaClass.getMethods();\n\n        for (Method m : methodList) {\n            MethodGen methodGen = classContext.getMethodGen(m);\n\n            if (DEBUG) System.out.println(\u0026#34;\u0026gt;\u0026gt;\u0026gt; Method: \u0026#34; + m.getName());\n\n            if (isTrustManager \u0026amp;\u0026amp;\n                    (m.getName().equals(\u0026#34;checkClientTrusted\u0026#34;) ||\n                     m.getName().equals(\u0026#34;checkServerTrusted\u0026#34;) ||\n                     m.getName().equals(\u0026#34;getAcceptedIssuers\u0026#34;))) {\n                if(isEmptyImplementation(methodGen)) {\n                    bugReporter.reportBug(new BugInstance(this, WEAK_TRUST_MANAGER_TYPE, Priorities.NORMAL_PRIORITY).addClassAndMethod(javaClass, m));\n                }\n......\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eclassContext.getJavaClass用于获取整个类的所有内容；javaClass.getMethods用于获取该类中的所有方法，以一个方法列表的形式返回；classContext.getMethodGen用于获取该方法的内容；isEmptyImplementation将方法的内容导入该函数进行检测，用于确定方法是否是空实现，该方法的代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate boolean isEmptyImplementation(MethodGen methodGen){\n    boolean invokeInst = false;\n    boolean loadField = false;\n\n    for (Iterator itIns = methodGen.getInstructionList().iterator();itIns.hasNext();) {\n        Instruction inst = ((InstructionHandle) itIns.next()).getInstruction();\n        if (DEBUG)\n            System.out.println(inst.toString(true));\n\n        if (inst instanceof InvokeInstruction) {\n            invokeInst = true;\n        }\n        if (inst instanceof GETFIELD) {\n            loadField = true;\n        }\n    }\n    return !invokeInst \u0026amp;\u0026amp; !loadField;\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该方法主要用于检测方法中是否包含方法调用、域操作，如果没有包含则认为是一个空实现的方法。因此该方法对于只包含 return true/false 语句的方法体同样认为是一个空实现。\u003c/p\u003e\u003ch2 id=\"2-3-污点分析\"\u003e2.3 污点分析\u003c/h2\u003e\u003cp\u003e数据流分析主要用于分析特定方法加载的参数是否能够被用户控制，即进行污点分析。做污点分析首先需要定义污染源（source点），污染源可以理解为能够被用户控制的输入数据，这里定义的Android污染源主要包括用户的输入、Intent传入的数据，下面展示定义的部分污染源（source点）：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e- EditText\nandroid/widget/EditText.getText()Landroid/text/Editable;:TAINTED\n- Intent\nandroid/content/Intent.getAction()Ljava/lang/String;:TAINTED\nandroid/content/Intent.getStringExtra(Ljava/lang/String;)Ljava/lang/String;:TAINTED\n......\n- Bundle\nandroid/os/Bundle.get(Ljava/lang/String;)Ljava/lang/Object;:TAINTED\nandroid/os/Bundle.getString(Ljava/lang/String;)Ljava/lang/String;:TAINTED\n......\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e定义好污染源后就需要确定污染的触发点（sink点），可以理解为会触发危险操作的函数。定义sink点的方式有两种，一种是直接从文件中导入，以命令注入为示例，代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class CommandInjectionDetector extends BasicInjectionDetector {\n\n    public CommandInjectionDetector(BugReporter bugReporter) {\n        super(bugReporter);\n        loadConfiguredSinks(\u0026#34;command.txt\u0026#34;, \u0026#34;COMMAND_INJECTION\u0026#34;);\n }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从代码中可以清楚的看到其导入方式是继承BasicInjectionDetector类，然后再该类的构造方法中通过loadConfiguredSinks方法，导入包含sink点的文件，下面展示该示例文件中的内容：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ejava/lang/Runtime.exec(Ljava/lang/String;)Ljava/lang/Process;:0\njava/lang/Runtime.exec([Ljava/lang/String;)Ljava/lang/Process;:0\njava/lang/Runtime.exec(Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process;:0,1\njava/lang/Runtime.exec([Ljava/lang/String;[Ljava/lang/String;)Ljava/lang/Process;:0,1\njava/lang/Runtime.exec(Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process;:1,2\njava/lang/Runtime.exec([Ljava/lang/String;[Ljava/lang/String;Ljava/io/File;)Ljava/lang/Process;:1,2\njava/lang/ProcessBuilder.\u0026lt;init\u0026gt;([Ljava/lang/String;)V:0\njava/lang/ProcessBuilder.\u0026lt;init\u0026gt;(Ljava/util/List;)V:0\njava/lang/ProcessBuilder.command([Ljava/lang/String;)Ljava/lang/ProcessBuilder;:0\njava/lang/ProcessBuilder.command(Ljava/util/List;)Ljava/lang/ProcessBuilder;:0\ndalvik/system/DexClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;:0\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e另一种是自定义导入，其实现是通过覆盖BasicInjectionDetector类中的getInjectionPoint方法，以WebView.loadurl方法为例，示例代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\n protected InjectionPoint getInjectionPoint(InvokeInstruction invoke, ConstantPoolGen cpg, InstructionHandle handle) {\n        assert invoke != null \u0026amp;\u0026amp; cpg != null;\n        String method = invoke.getMethodName(cpg);\n        String sig    = invoke.getSignature(cpg);\n// System.out.println(invoke.getClassName(cpg));\n if(sig.contains(\u0026#34;Ljava/lang/String;\u0026#34;)) {\n            if(\u0026#34;loadUrl\u0026#34;.equals(method)){\n                if(sig.contains(\u0026#34;Ljava/util/Map;\u0026#34;)){\n                    return new InjectionPoint(new int[]{1}, WEBVIEW_LOAD_DATA_URL_TYPE);\n                }else{\n                    return new InjectionPoint(new int[]{0}, WEBVIEW_LOAD_DATA_URL_TYPE);\n                }\n            }else if(\u0026#34;loadData\u0026#34;.equals(method)){\n                return new InjectionPoint(new int[]{2}, WEBVIEW_LOAD_DATA_URL_TYPE);\n            }else if(\u0026#34;loadDataWithBaseURL\u0026#34;.equals(method)){\n                //BUG\n return new InjectionPoint(new int[]{4}, WEBVIEW_LOAD_DATA_URL_TYPE);\n            }\n        }\n        return InjectionPoint.NONE;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过实例化InjectionPoint类构造新的sink点，其构造方法中的第一个参数表示该方法接收污染数据参数的位置，如方法为webView.loadUrl(url)，其第一个参数就是new int[]{0}，其它的以此类推。\u003c/p\u003e\u003cp\u003e上报发现漏洞的情况，则通过覆盖getPriorityFromTaintFrame方法的实现，示例代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\n protected int getPriorityFromTaintFrame(TaintFrame fact, int offset)\n            throws DataflowAnalysisException {\n        Taint stringValue = fact.getStackValue(offset);\n// System.out.println(stringValue.getConstantValue());\n if (stringValue.isTainted() || stringValue.isUnknown()) {\n            return Priorities.NORMAL_PRIORITY;\n        } else {\n            return Priorities.IGNORE_PRIORITY;\n        }\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过fact.getStackValue获取检测的函数变量，如果该变量被污染（isTainted）或 变量是否被污染未知（但是是可控制变量），那么作为一个中危风险（Priorities.NORMAL_PRIORITY）进行上报，其它的情况则上报为可忽略风险（Priorities.IGNORE_PRIORITY）。\u003c/p\u003e\u003ch2 id=\"2-4-自定义代码检测\"\u003e2.4 自定义代码检测\u003c/h2\u003e\u003cp\u003e自定义代码检测实现的前半部分同2.2的逐方法检测类似，均是获取类的内容，然后遍历所有的方法，对方法的内容进行检测，但是在具体代码检测实现上是通过自定义分析进行。目前自定义检测只应用到Android中本地拒绝服务的检测。本地拒绝服务的被触发的重要原因在于对通过Intent获取的参数未进行异常捕获，因此检测实现的方式便是检测获取参数的代码行是否被try catch包裹（这个存在误差，待改进）。对于其代码分析，不能使用FindBugs模型进行分析，而是使用最原始的class代码进行分析，原始class代码的形式通过javap命令进行查看，下图展示示例代码。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/c9faf35b.png\" alt=\"class示例代码\"/\u003e\u003c/p\u003e\u003cp\u003e对原始class文件进行分析存在的缺陷是无法定位具体的代码行，那么在进行问题上报时无法将问题定位到代码行，因此第一步需要在原有模型的基础上对所有包含Intent获取参数的方法的位置存储到一个Map结构中，方便后面对方法的定位，代码实现如下所示，获取方法所在的行，然后以方法名作为Key值，以代码行相关信息作为Value值，存储到Map中。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Map\u0026lt;String, List\u0026lt;Location\u0026gt;\u0026gt; get_line_location(Method m, ClassContext classContext){\n        HashMap\u0026lt;String, List\u0026lt;Location\u0026gt;\u0026gt; all_line_location = new HashMap\u0026lt;\u0026gt;();\n        ConstantPoolGen cpg = classContext.getConstantPoolGen();\n        CFG cfg = null;\n        try {\n            cfg = classContext.getCFG(m);\n        } catch (CFGBuilderException e) {\n            e.printStackTrace();\n            return all_line_location;\n        }\n        for (Iterator\u0026lt;Location\u0026gt; i = cfg.locationIterator(); i.hasNext(); ) {\n            Location loc = i.next();\n            Instruction inst = loc.getHandle().getInstruction();\n            if(inst instanceof INVOKEVIRTUAL) {\n                INVOKEVIRTUAL invoke = (INVOKEVIRTUAL) inst;\n if(all_line_location.containsKey(invoke.getMethodName(cpg))){\n                        all_line_location.get(invoke.getMethodName(cpg)).add(loc);\n                    }else {\n                        LinkedList\u0026lt;Location\u0026gt; loc_list = new LinkedList\u0026lt;\u0026gt;();\n                        loc_list.add(loc);\n                        all_line_location.put(invoke.getMethodName(cpg), loc_list);\n                    }\n// }\n }\n        }\n        return all_line_location;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e之后获取Exception包裹的范围，FindBugs中包含对Exception的建模，因此能够通过其模型能够直接获取其范围并存储到一个列表中，代码如下所示，其中exceptionTable[i].getStartPC用于获取try catch 的起始代码行，exceptionTable[i].getEndPC用于获取try catch 的结束代码行。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int[] getExceptionScope(){\n        try {\n            CodeException[] exceptionTable = this.code.getExceptionTable();\n            int[] exception_scop = new int[exceptionTable.length * 2];\n            for (int i = 0; i \u0026lt; exceptionTable.length; i++) {\n                exception_scop[i * 2] = exceptionTable[i].getStartPC();\n                exception_scop[i * 2 + 1] = exceptionTable[i].getEndPC();\n            }\n            return exception_scop;\n        }catch (Exception e){\n }\n        return new int[0];\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在对代码进行逐行检查时，因为使用的是最原始class文件形式，因此需要限定其遍历的范围，限定的方式是通过代码的行号，即上图中每行代码的第一个数值。首先需要获取代码总行数的大小，获取的方式便是解析FindBugs建模后的第一行代码，找到关键词code-length后面的数值，即为代码的行数，解析代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic int get_Code_Length(String firstLineCode){\n        try{\n            String[] split1 = firstLineCode.split(\u0026#34;code_length\u0026#34;);\n// System.out.println(split1[split1.length-1]);\n byte[] code_length_bytes = split1[split1.length-1].getBytes();\n            byte[] new_code_bytes = new byte[code_length_bytes.length];\n            for(int i=0; i\u0026lt;code_length_bytes.length; i++){\n// System.out.println();\n if(code_length_bytes[i]\u0026lt;48 || code_length_bytes[i]\u0026gt;57){\n                    new_code_bytes[i] = 32;\n                }else{\n                    new_code_bytes[i] = code_length_bytes[i];\n                }\n            }\n            return Integer.parseInt(new String(new_code_bytes).trim());\n        }catch(Exception e){\n            e.printStackTrace();\n        }\n        return 0;\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后对代码进行逐行遍历，遍历中为防止try catch块被遍历到，使用行号来限制遍历的范围。检测代码行是否包含通过Intent获取参数，及该行是否被try catch 包裹，如果上述两个条件均被触发，那么就作为一个问题进行上报。示例代码如下，其中get_code_line_index方法用于获取代码的行号，获取的方式是截取代码行的首字符的数值，以确定是否在代码包裹的范围内。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void analyzeMethod(JavaClass javaClass, Method m, ClassContext classContext) throws CFGBuilderException {\n        HashMap\u0026lt;String, List\u0026lt;Location\u0026gt;\u0026gt; all_line_location = (HashMap\u0026lt;String, List\u0026lt;Location\u0026gt;\u0026gt;) get_line_location(m, classContext);\n        Code code = m.getCode();\n        StringCodeAnalysis sca = new StringCodeAnalysis(code);\n        String[] codes = sca.codes_String_Array();\n        int code_length = sca.get_Code_Length(sca.get_First_Code(codes));\n        int[] exception_scop = sca.getExceptionScope();\n        for(int i=1; i\u0026lt;codes.length; i++){\n            int line_index = sca.get_code_line_index(codes[i]);\n            if (line_index \u0026lt; code_length){\n                if(codes[i].toLowerCase().contains(\u0026#34;invokevirtual\u0026#34;) \u0026amp;\u0026amp;\n                        (codes[i].contains(\u0026#34;android.content.Intent.get\u0026#34;)  || codes[i].contains(\u0026#34;android.os.Bundle.get\u0026#34;))){\n                    if(exception_scop.length == 0){\n                        ......\n                    }else{\n                        boolean is_scope = false;\n                        for(int j=0; j\u0026lt;exception_scop.length; j+=2){\n                            int start = exception_scop[j];\n                            int end = exception_scop[j+1];\n                            if(line_index \u0026gt;= start \u0026amp;\u0026amp; line_index \u0026lt;= end){\n                                is_scope = true;\n                            }\n                            if(is_scope){\n                                break;\n                            }\n                        }\n                        if(!is_scope){\n                            String method_name = get_method_name(codes[i]);\n                            if(all_line_location.containsKey(method_name)){\n                                for(Location loc : all_line_location.get(method_name)){\n                                    bugReporter.reportBug(new BugInstance(this, LOCAL_DENIAL_SERVICE_TYPE, Priorities.NORMAL_PRIORITY).addClass(javaClass).addMethod(javaClass, m).addSourceLine(classContext, m, loc));\n                                }\n                            }else {\n                                bugReporter.reportBug(new BugInstance(this, LOCAL_DENIAL_SERVICE_TYPE, Priorities.NORMAL_PRIORITY).addClass(javaClass).addMethod(javaClass, m));\n }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面详细叙述了如何构造自己的问题检测代码，完成检测方法的书写后，下一步就是在配置文件中对检测方法进行注册，才能使检测代码运转起来。\u003c/p\u003e\u003cp\u003e需要在两个文件中进行注册，第一个是findbugs.xml，注册示例如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;Detector class=\u0026#34;com.h3xstream.findsecbugs.android.LocalDenialOfServiceDetector\u0026#34; reports=\u0026#34;LOCAL_DENIAL_SERVICE\u0026#34;/\u0026gt;\n\u0026lt;BugPattern type=\u0026#34;LOCAL_DENIAL_SERVICE\u0026#34; abbrev=\u0026#34;SECLDOS\u0026#34; category=\u0026#34;Android安全问题\u0026#34; cweid=\u0026#34;276\u0026#34;/\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其中Detector用于注册该检测方法的位置及其唯一标识，BugPattern用于对检测出的问题进行归类，方便展示，如此处归类到”Android安全问题”中，那么在生成报告的时候问题也将被归类到”Android安全问题”中。\u003c/p\u003e\u003cp\u003e第二个是messages.xml注册，注册示例如下，该注册主要是对该问题进行说明，包括问题的危害及修复方法。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e\u0026lt;Detector class=\u0026#34;com.h3xstream.findsecbugs.android.LocalDenialOfServiceDetector\u0026#34;\u0026gt;\u2028\u0026lt;Details\u0026gt;Local Denial of Service.\u0026lt;/Details\u0026gt;\u2028\u0026lt;/Detector\u0026gt;\u2028\u0026lt;BugPattern type=\u0026#34;LOCAL_DENIAL_SERVICE\u0026#34;\u0026gt;\u2028\u0026lt;ShortDescription\u0026gt;本地拒绝服务\u0026lt;/ShortDescription\u0026gt;\u2028\u0026lt;LongDescription\u0026gt;通过Intent接收的参数未进行异常捕获，导致出现异常使得应用崩溃\u0026lt;/LongDescription\u0026gt;\u2028\u0026lt;Details\u0026gt;\u2028\u0026lt;![CDATA[\u2028    \u0026lt;p\u0026gt;\u2028        \u0026lt;b\u0026gt;危害:\u0026lt;/b\u0026gt;\u0026lt;br/\u0026gt;\u2028        \u0026lt;pre\u0026gt;\u2028            应用崩溃无法使用，影响用户体验；\u2028            被竞争对手利用，进行点对点攻击。\u2028        \u0026lt;/pre\u0026gt;\u2028    \u0026lt;/p\u0026gt;\u2028    \u0026lt;p\u0026gt;\u2028        \u0026lt;b\u0026gt;错误代码:\u0026lt;/b\u0026gt;\u0026lt;br/\u0026gt;\u2028        \u0026lt;pre\u0026gt;\u2028            bundle.getString(\u0026#34;\u0026#34;); //未try/catch\u2028            intent.getStringExtra(\u0026#34;\u0026#34;); //未try/catch\u2028        \u0026lt;/pre\u0026gt;\u2028    \u0026lt;/p\u0026gt;\u2028    \u0026lt;p\u0026gt;\u2028        \u0026lt;b\u0026gt;解决方案:\u0026lt;/b\u0026gt;\u0026lt;br/\u0026gt;\u2028        \u0026lt;pre\u0026gt;\u2028            对通过Intent接收的参数处理时，进行严格的异常捕获。\u2028            try {\u2028                bundle.getString(\u0026#34;\u0026#34;);\u2028                intent.getStringExtra(\u0026#34;\u0026#34;); \u2028            }catch (Exception e){}\u2028        \u0026lt;/pre\u0026gt;\u2028    \u0026lt;/p\u0026gt;\u2028]]\u0026gt;\u2028\u0026lt;/Details\u0026gt;\u2028\u0026lt;/BugPattern\u0026gt;\u2028\u0026lt;BugCode abbrev=\u0026#34;SECLDOS\u0026#34;\u0026gt;本地拒绝服务\u0026lt;/BugCode\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e一切完成就绪后使用Maven进行打包，就生产了供FindBugs集成开发工具插件使用的JAR包，完成安装并重启，即可使用自定义插件对特定问题进行检测。\n最终分析的效果图如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/3d7465d4.png\" alt=\"分析效果图\"/\u003e\u003c/p\u003e\u003cp\u003e本文介绍了Android集成开发环境Android Studio的代码实时检测工具Code Arbiter的产生原因及代码实现，最后展示了分析的效果。通过Code Arbiter在生产环境中的应用，其检测效果还是相当不错，能够发现很多编码过程中存在的问题。但是Code Arbiter仍然存在许多不足，需要优化。后续将在以下两个方面对工具进行改进：\n1. 扩大漏洞检测范围，使Code Arbiter能够囊括Android编码常见安全问题；\n2. 优化漏洞检测规则，提高检测的准确性，减少误报。\u003c/p\u003e\u003cp\u003e建弋，2016年加入美团，目前主要负责金融部门相关的安全工作。对于代码审计/漏洞扫描感兴趣的同学，可以阅读本人Freebuf上发表的\u003ca href=\"http://www.freebuf.com/author/nightmarelee\"\u003e相关文章\u003c/a\u003e，期待与大家共同学习共同提高。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e美团金融服务平台-安全与合规中心致力于维护美团金融平台的安全工作，努力构建行业顶级安全架构，打造行业领先安全产品。欢迎各位行业同仁加入我们，共同建设美团金融安全。\n联系邮箱：isec#meituan.com\u003c/strong\u003e\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e【思考题】\u003c/p\u003e\u003cp\u003e文中描述了Android IDE漏洞扫描工具产生的前因后果，对实现的代码也进行了概括总结。不管是在IDE集成开发环境下的源码扫描，还是对APK文件的解包扫描，其最终的目的还是为了保证应用的安全性，那么大家在日常的工作中对于移动安全建设，以及互联网快速迭代环境下业务安全问题的排查有何独到的见地呢？希望不吝赐教。\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-08-17T00:00:00Z",
  "Author": "soulteary@gmail.com"
}