{
  "Source": "tech.meituan.com",
  "Title": "Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus",
  "Link": "https://tech.meituan.com/2018/07/26/android-livedatabus.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e对于Android系统来说，消息传递是最基本的组件，每一个App内的不同页面，不同组件都在进行消息传递。消息传递既可以用于Android四大组件之间的通信，也可用于异步线程和主线程之间的通信。对于Android开发者来说，经常使用的消息传递方式有很多种，从最早使用的Handler、BroadcastReceiver、接口回调，到近几年流行的通信总线类框架EventBus、RxBus。Android消息传递框架，总在不断的演进之中。\u003c/p\u003e\u003ch2 id=\"从eventbus说起\"\u003e从EventBus说起\u003c/h2\u003e\u003cp\u003eEventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递。EventBus可以代替Android传统的Intent、Handler、Broadcast或接口回调，在Fragment、Activity、Service线程之间传递数据，执行方法。\u003c/p\u003e\u003cp\u003eEventBus最大的特点就是：简洁、解耦。在没有EventBus之前我们通常用广播来实现监听，或者自定义接口函数回调，有的场景我们也可以直接用Intent携带简单数据，或者在线程之间通过Handler处理消息传递。但无论是广播还是Handler机制远远不能满足我们高效的开发。EventBus简化了应用程序内各组件间、组件与后台线程间的通信。EventBus一经推出，便受到广大开发者的推崇。\u003c/p\u003e\u003cp\u003e现在看来，EventBus给Android开发者世界带来了一种新的框架和思想，就是消息的发布和订阅。这种思想在其后很多框架中都得到了应用。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/87d7f0f7e01b188aa312c91b2be45fe828898.png\" alt=\"图片摘自EventBus GitHub主页\"/\u003e\u003c/p\u003e\u003ch3 id=\"发布-订阅模式\"\u003e发布/订阅模式\u003c/h3\u003e\u003cp\u003e订阅发布模式定义了一种“一对多”的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a2e14f7c.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"rxbus的出现\"\u003eRxBus的出现\u003c/h2\u003e\u003cp\u003eRxBus不是一个库，而是一个文件，实现只有短短30行代码。RxBus本身不需要过多分析，它的强大完全来自于它基于的RxJava技术。响应式编程（Reactive Programming）技术这几年特别火，RxJava是它在Java上的实作。RxJava天生就是发布/订阅模式，而且很容易处理线程切换。所以，RxBus凭借区区30行代码，就敢挑战EventBus江湖老大的地位。\u003c/p\u003e\u003ch3 id=\"rxbus原理\"\u003eRxBus原理\u003c/h3\u003e\u003cp\u003e在RxJava中有个Subject类，它继承Observable类，同时实现了Observer接口，因此Subject可以同时担当订阅者和被订阅者的角色，我们使用Subject的子类PublishSubject来创建一个Subject对象（PublishSubject只有被订阅后才会把接收到的事件立刻发送给订阅者），在需要接收事件的地方，订阅该Subject对象，之后如果Subject对象接收到事件，则会发射给该订阅者，此时Subject对象充当被订阅者的角色。\u003c/p\u003e\u003cp\u003e完成了订阅，在需要发送事件的地方将事件发送给之前被订阅的Subject对象，则此时Subject对象作为订阅者接收事件，然后会立刻将事件转发给订阅该Subject对象的订阅者，以便订阅者处理相应事件，到这里就完成了事件的发送与处理。\u003c/p\u003e\u003cp\u003e最后就是取消订阅的操作了，RxJava中，订阅操作会返回一个Subscription对象，以便在合适的时机取消订阅，防止内存泄漏，如果一个类产生多个Subscription对象，我们可以用一个CompositeSubscription存储起来，以进行批量的取消订阅。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRxBus有很多实现，如：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eAndroidKnife/RxBus（\u003ca href=\"https://github.com/AndroidKnife/RxBus）\"\u003ehttps://github.com/AndroidKnife/RxBus）\u003c/a\u003e\nBlankj/RxBus（\u003ca href=\"https://github.com/Blankj/RxBus）\"\u003ehttps://github.com/Blankj/RxBus）\u003c/a\u003e\u003c/p\u003e\u003cp\u003e其实正如前面所说的，RxBus的原理是如此简单，我们自己都可以写出一个RxBus的实现：\u003c/p\u003e\u003ch3 id=\"基于rxjava1的rxbus实现\"\u003e基于RxJava1的RxBus实现：\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final class RxBus {\n\n    private final Subject\u0026lt;Object, Object\u0026gt; bus;\n\n    private RxBus() {\n        bus = new SerializedSubject\u0026lt;\u0026gt;(PublishSubject.create());\n    }\n\n    private static class SingletonHolder {\n        private static final RxBus defaultRxBus = new RxBus();\n    }\n\n    public static RxBus getInstance() {\n        return SingletonHolder.defaultRxBus;\n    }\n\n    /*\n     * 发送\n     */\n    public void post(Object o) {\n        bus.onNext(o);\n    }\n\n    /*\n     * 是否有Observable订阅\n     */\n    public boolean hasObservable() {\n        return bus.hasObservers();\n    }\n\n    /*\n     * 转换为特定类型的Obserbale\n     */\n    public \u0026lt;T\u0026gt; Observable\u0026lt;T\u0026gt; toObservable(Class\u0026lt;T\u0026gt; type) {\n        return bus.ofType(type);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"基于rxjava2的rxbus实现\"\u003e基于RxJava2的RxBus实现：\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final class RxBus2 {\n\n    private final Subject\u0026lt;Object\u0026gt; bus;\n\n    private RxBus2() {\n        // toSerialized method made bus thread safe\n        bus = PublishSubject.create().toSerialized();\n    }\n\n    public static RxBus2 getInstance() {\n        return Holder.BUS;\n    }\n\n    private static class Holder {\n        private static final RxBus2 BUS = new RxBus2();\n    }\n\n    public void post(Object obj) {\n        bus.onNext(obj);\n    }\n\n    public \u0026lt;T\u0026gt; Observable\u0026lt;T\u0026gt; toObservable(Class\u0026lt;T\u0026gt; tClass) {\n        return bus.ofType(tClass);\n    }\n\n    public Observable\u0026lt;Object\u0026gt; toObservable() {\n        return bus;\n    }\n\n    public boolean hasObservers() {\n        return bus.hasObservers();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"引入livedatabus的想法\"\u003e引入LiveDataBus的想法\u003c/h2\u003e\u003ch3 id=\"从livedata谈起\"\u003e从LiveData谈起\u003c/h3\u003e\u003cp\u003eLiveData是Android Architecture Components提出的框架。LiveData是一个可以被观察的数据持有类，它可以感知并遵循Activity、Fragment或Service等组件的生命周期。正是由于LiveData对组件生命周期可感知特点，因此可以做到仅在组件处于生命周期的激活状态时才更新UI数据。\u003c/p\u003e\u003cp\u003eLiveData需要一个观察者对象，一般是Observer类的具体实现。当观察者的生命周期处于STARTED或RESUMED状态时，LiveData会通知观察者数据变化；在观察者处于其他状态时，即使LiveData的数据变化了，也不会通知。\u003c/p\u003e\u003ch4 id=\"livedata的优点\"\u003eLiveData的优点\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eUI和实时数据保持一致\u003c/strong\u003e 因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e避免内存泄漏\u003c/strong\u003e 观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e不会再产生由于Activity处于stop状态而引起的崩溃\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e不需要再解决生命周期带来的问题\u003c/strong\u003e LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e实时数据刷新\u003c/strong\u003e 当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e解决Configuration Change问题\u003c/strong\u003e 在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"谈一谈android-architecture-components\"\u003e谈一谈Android Architecture Components\u003c/h3\u003e\u003cp\u003eAndroid Architecture Components的核心是Lifecycle、LiveData、ViewModel 以及 Room，通过它可以非常优雅的让数据与界面进行交互，并做一些持久化的操作，高度解耦，自动管理生命周期，而且不用担心内存泄漏的问题。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eRoom\u003c/strong\u003e\n一个强大的SQLite对象映射库。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eViewModel\u003c/strong\u003e\n一类对象，它用于为UI组件提供数据，在设备配置发生变更时依旧可以存活。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLiveData\u003c/strong\u003e 一个可感知生命周期、可被观察的数据容器，它可以存储数据，还会在数据发生改变时进行提醒。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLifecycle\u003c/strong\u003e\n包含LifeCycleOwer和LifecycleObserver，分别是生命周期所有者和生命周期感知者。\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"android-architecture-components的特点\"\u003eAndroid Architecture Components的特点\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e数据驱动型编程\u003c/strong\u003e\n变化的永远是数据，界面无需更改。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e感知生命周期，防止内存泄漏。\u003c/strong\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e高度解耦\u003c/strong\u003e\n数据，界面高度分离。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e数据持久化\u003c/strong\u003e\n数据、ViewModel不与UI的生命周期挂钩，不会因为界面的重建而销毁。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"重点-为什么使用livedata构建数据通信总线livedatabus\"\u003e重点：为什么使用LiveData构建数据通信总线LiveDataBus\u003c/h2\u003e\u003ch3 id=\"使用livedata的理由\"\u003e使用LiveData的理由\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eLiveData具有的这种可观察性和生命周期感知的能力，使其非常适合作为Android通信总线的基础构件。\u003c/strong\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e使用者不用显示调用反注册方法。\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e由于LiveData具有生命周期感知能力，所以LiveDataBus只需要调用注册回调方法，而不需要显示的调用反注册方法。这样带来的好处不仅可以编写更少的代码，而且可以完全杜绝其他通信总线类框架（如EventBus、RxBus）忘记调用反注册所带来的内存泄漏的风险。\u003c/p\u003e\u003ch3 id=\"为什么要用livedatabus替代eventbus和rxbus\"\u003e为什么要用LiveDataBus替代EventBus和RxBus\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eLiveDataBus的实现及其简单\u003c/strong\u003e 相对EventBus复杂的实现，LiveDataBus只需要一个类就可以实现。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLiveDataBus可以减小APK包的大小\u003c/strong\u003e 由于LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，没有其他依赖，本身实现只有一个类。作为比较，EventBus JAR包大小为57kb，RxBus依赖RxJava和RxAndroid，其中RxJava2包大小2.2MB，RxJava1包大小1.1MB，RxAndroid包大小9kb。使用LiveDataBus可以大大减小APK包的大小。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLiveDataBus依赖方支持更好\u003c/strong\u003e LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，相比RxBus依赖的RxJava和RxAndroid，依赖方支持更好。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLiveDataBus具有生命周期感知\u003c/strong\u003e LiveDataBus具有生命周期感知，在Android系统中使用调用者不需要调用反注册，相比EventBus和RxBus使用更为方便，并且没有内存泄漏风险。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"livedatabus的设计和架构\"\u003eLiveDataBus的设计和架构\u003c/h2\u003e\u003ch3 id=\"livedatabus的组成\"\u003eLiveDataBus的组成\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e消息\u003c/strong\u003e\n消息可以是任何的Object，可以定义不同类型的消息，如Boolean、String。也可以定义自定义类型的消息。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e消息通道\u003c/strong\u003e\nLiveData扮演了消息通道的角色，不同的消息通道用不同的名字区分，名字是String类型的，可以通过名字获取到一个LiveData消息通道。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e消息总线\u003c/strong\u003e\n消息总线通过单例实现，不同的消息通道存放在一个HashMap中。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e订阅\u003c/strong\u003e\n订阅者通过getChannel获取消息通道，然后调用observe订阅这个通道的消息。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e发布\u003c/strong\u003e\n发布者通过getChannel获取消息通道，然后调用setValue或者postValue发布消息。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"livedatabus原理图\"\u003eLiveDataBus原理图\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/10af315f.png\" alt=\"LiveDataBus原理图\"/\u003e\u003c/p\u003e\u003ch2 id=\"livedatabus的实现\"\u003eLiveDataBus的实现\u003c/h2\u003e\u003ch4 id=\"第一个实现\"\u003e第一个实现：\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final class LiveDataBus {\n\n    private final Map\u0026lt;String, MutableLiveData\u0026lt;Object\u0026gt;\u0026gt; bus;\n\n    private LiveDataBus() {\n        bus = new HashMap\u0026lt;\u0026gt;();\n    }\n\n    private static class SingletonHolder {\n        private static final LiveDataBus DATA_BUS = new LiveDataBus();\n    }\n\n    public static LiveDataBus get() {\n        return SingletonHolder.DATA_BUS;\n    }\n\n    public \u0026lt;T\u0026gt; MutableLiveData\u0026lt;T\u0026gt; getChannel(String target, Class\u0026lt;T\u0026gt; type) {\n        if (!bus.containsKey(target)) {\n            bus.put(target, new MutableLiveData\u0026lt;\u0026gt;());\n        }\n        return (MutableLiveData\u0026lt;T\u0026gt;) bus.get(target);\n    }\n\n    public MutableLiveData\u0026lt;Object\u0026gt; getChannel(String target) {\n        return getChannel(target, Object.class);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e短短二十行代码，就实现了一个通信总线的全部功能，并且还具有生命周期感知功能，并且使用起来也及其简单：\u003c/p\u003e\u003cp\u003e注册订阅：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eLiveDataBus.get().getChannel(\u0026#34;key_test\u0026#34;, Boolean.class)\n        .observe(this, new Observer\u0026lt;Boolean\u0026gt;() {\n            @Override\n            public void onChanged(@Nullable Boolean aBoolean) {\n            }\n        });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e发送消息：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eLiveDataBus.get().getChannel(\u0026#34;key_test\u0026#34;).setValue(true);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们发送了一个名为”key_test”，值为true的事件。\u003c/p\u003e\u003cp\u003e这个时候订阅者就会收到消息，并作相应的处理，非常简单。\u003c/p\u003e\u003ch4 id=\"问题出现\"\u003e问题出现\u003c/h4\u003e\u003cp\u003e对于LiveDataBus的第一版实现，我们发现，在使用这个LiveDataBus的过程中，订阅者会收到订阅之前发布的消息。对于一个消息总线来说，这是不可接受的。无论EventBus或者RxBus，订阅方都不会收到订阅之前发出的消息。对于一个消息总线，LiveDataBus必须要解决这个问题。\u003c/p\u003e\u003ch4 id=\"问题分析\"\u003e问题分析\u003c/h4\u003e\u003cp\u003e怎么解决这个问题呢？先分析下原因：\u003c/p\u003e\u003cp\u003e当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/df9d4bb1.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在LiveData的dispatchingValue中，又会调用LiveData的considerNotify方法。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b219e01a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在LiveData的considerNotify方法中，红框中的逻辑是关键，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/3a5de647.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"问题原因总结\"\u003e问题原因总结\u003c/h4\u003e\u003cp\u003e对于这个问题，总结一下发生的核心原因。对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue，其vesion会+1；对于每一个观察者的封装ObserverWrapper，其初始version也为-1，也就是说，每一个新注册的观察者，其version为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的version，LiveData就会强制把当前value推送给Observer。\u003c/p\u003e\u003ch4 id=\"如何解决这个问题\"\u003e如何解决这个问题\u003c/h4\u003e\u003cp\u003e明白了问题产生的原因之后，我们来看看怎么才能解决这个问题。很显然，根据之前的分析，只需要在注册一个新的订阅者的时候把Wrapper的version设置成跟LiveData的version一致即可。\u003c/p\u003e\u003cp\u003e那么怎么实现呢，看看LiveData的observe方法，他会在步骤1创建一个LifecycleBoundObserver，LifecycleBoundObserver是ObserverWrapper的派生类。然后会在步骤2把这个LifecycleBoundObserver放入一个私有Map容器mObservers中。无论ObserverWrapper还是LifecycleBoundObserver都是私有的或者包可见的，所以无法通过继承的方式更改LifecycleBoundObserver的version。\u003c/p\u003e\u003cp\u003e那么能不能从Map容器mObservers中取到LifecycleBoundObserver，然后再更改version呢？答案是肯定的，通过查看SafeIterableMap的源码我们发现有一个protected的get方法。因此，在调用observe的时候，我们可以通过反射拿到LifecycleBoundObserver，再把LifecycleBoundObserver的version设置成和LiveData一致即可。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/bdc42c56.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e对于非生命周期感知的observeForever方法来说，实现的思路是一致的，但是具体的实现略有不同。observeForever的时候，生成的wrapper不是LifecycleBoundObserver，而是AlwaysActiveObserver（步骤1），而且我们也没有机会在observeForever调用完成之后再去更改AlwaysActiveObserver的version，因为在observeForever方法体内，步骤3的语句，回调就发生了。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5adbe3b7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e那么对于observeForever，如何解决这个问题呢？既然是在调用内回调的，那么我们可以写一个ObserverWrapper，把真正的回调给包装起来。把ObserverWrapper传给observeForever，那么在回调的时候我们去检查调用栈，如果回调是observeForever方法引起的，那么就不回调真正的订阅者。\u003c/p\u003e\u003ch3 id=\"livedatabus最终实现\"\u003eLiveDataBus最终实现\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final class LiveDataBus {\n\n    private final Map\u0026lt;String, BusMutableLiveData\u0026lt;Object\u0026gt;\u0026gt; bus;\n\n    private LiveDataBus() {\n        bus = new HashMap\u0026lt;\u0026gt;();\n    }\n\n    private static class SingletonHolder {\n        private static final LiveDataBus DEFAULT_BUS = new LiveDataBus();\n    }\n\n    public static LiveDataBus get() {\n        return SingletonHolder.DEFAULT_BUS;\n    }\n\n    public \u0026lt;T\u0026gt; MutableLiveData\u0026lt;T\u0026gt; with(String key, Class\u0026lt;T\u0026gt; type) {\n        if (!bus.containsKey(key)) {\n            bus.put(key, new BusMutableLiveData\u0026lt;\u0026gt;());\n        }\n        return (MutableLiveData\u0026lt;T\u0026gt;) bus.get(key);\n    }\n\n    public MutableLiveData\u0026lt;Object\u0026gt; with(String key) {\n        return with(key, Object.class);\n    }\n\n    private static class ObserverWrapper\u0026lt;T\u0026gt; implements Observer\u0026lt;T\u0026gt; {\n\n        private Observer\u0026lt;T\u0026gt; observer;\n\n        public ObserverWrapper(Observer\u0026lt;T\u0026gt; observer) {\n            this.observer = observer;\n        }\n\n        @Override\n        public void onChanged(@Nullable T t) {\n            if (observer != null) {\n                if (isCallOnObserve()) {\n                    return;\n                }\n                observer.onChanged(t);\n            }\n        }\n\n        private boolean isCallOnObserve() {\n            StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n            if (stackTrace != null \u0026amp;\u0026amp; stackTrace.length \u0026gt; 0) {\n                for (StackTraceElement element : stackTrace) {\n                    if (\u0026#34;android.arch.lifecycle.LiveData\u0026#34;.equals(element.getClassName()) \u0026amp;\u0026amp;\n                            \u0026#34;observeForever\u0026#34;.equals(element.getMethodName())) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    private static class BusMutableLiveData\u0026lt;T\u0026gt; extends MutableLiveData\u0026lt;T\u0026gt; {\n\n        private Map\u0026lt;Observer, Observer\u0026gt; observerMap = new HashMap\u0026lt;\u0026gt;();\n\n        @Override\n        public void observe(@NonNull LifecycleOwner owner, @NonNull Observer\u0026lt;T\u0026gt; observer) {\n            super.observe(owner, observer);\n            try {\n                hook(observer);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        @Override\n        public void observeForever(@NonNull Observer\u0026lt;T\u0026gt; observer) {\n            if (!observerMap.containsKey(observer)) {\n                observerMap.put(observer, new ObserverWrapper(observer));\n            }\n            super.observeForever(observerMap.get(observer));\n        }\n\n        @Override\n        public void removeObserver(@NonNull Observer\u0026lt;T\u0026gt; observer) {\n            Observer realObserver = null;\n            if (observerMap.containsKey(observer)) {\n                realObserver = observerMap.remove(observer);\n            } else {\n                realObserver = observer;\n            }\n            super.removeObserver(realObserver);\n        }\n\n        private void hook(@NonNull Observer\u0026lt;T\u0026gt; observer) throws Exception {\n            //get wrapper\u0026#39;s version\n            Class\u0026lt;LiveData\u0026gt; classLiveData = LiveData.class;\n            Field fieldObservers = classLiveData.getDeclaredField(\u0026#34;mObservers\u0026#34;);\n            fieldObservers.setAccessible(true);\n            Object objectObservers = fieldObservers.get(this);\n            Class\u0026lt;?\u0026gt; classObservers = objectObservers.getClass();\n            Method methodGet = classObservers.getDeclaredMethod(\u0026#34;get\u0026#34;, Object.class);\n            methodGet.setAccessible(true);\n            Object objectWrapperEntry = methodGet.invoke(objectObservers, observer);\n            Object objectWrapper = null;\n            if (objectWrapperEntry instanceof Map.Entry) {\n                objectWrapper = ((Map.Entry) objectWrapperEntry).getValue();\n            }\n            if (objectWrapper == null) {\n                throw new NullPointerException(\u0026#34;Wrapper can not be bull!\u0026#34;);\n            }\n            Class\u0026lt;?\u0026gt; classObserverWrapper = objectWrapper.getClass().getSuperclass();\n            Field fieldLastVersion = classObserverWrapper.getDeclaredField(\u0026#34;mLastVersion\u0026#34;);\n            fieldLastVersion.setAccessible(true);\n            //get livedata\u0026#39;s version\n            Field fieldVersion = classLiveData.getDeclaredField(\u0026#34;mVersion\u0026#34;);\n            fieldVersion.setAccessible(true);\n            Object objectVersion = fieldVersion.get(this);\n            //set wrapper\u0026#39;s version\n            fieldLastVersion.set(objectWrapper, objectVersion);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"注册订阅\"\u003e注册订阅\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eLiveDataBus.get()\n        .with(\u0026#34;key_test\u0026#34;, String.class)\n        .observe(this, new Observer\u0026lt;String\u0026gt;() {\n            @Override\n            public void onChanged(@Nullable String s) {\n            }\n        });\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"发送消息\"\u003e发送消息：\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eLiveDataBus.get().with(\u0026#34;key_test\u0026#34;).setValue(s);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"源码说明\"\u003e源码说明\u003c/h3\u003e\u003cp\u003eLiveDataBus的源码可以直接拷贝使用，也可以前往作者的GitHub仓库查看下载：\n\u003ca href=\"https://github.com/JeremyLiao/LiveDataBus\"\u003ehttps://github.com/JeremyLiao/LiveDataBus\u003c/a\u003e 。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e本文提供了一个新的消息总线框架——LiveDataBus。订阅者可以订阅某个消息通道的消息，发布者可以把消息发布到消息通道上。利用LiveDataBus，不仅可以实现消息总线功能，而且对于订阅者，他们不需要关心何时取消订阅，极大减少了因为忘记取消订阅造成的内存泄漏风险。\u003c/p\u003e\u003ch2 id=\"作者介绍\"\u003e作者介绍\u003c/h2\u003e\u003cul\u003e\u003cli\u003e海亮，美团高级工程师，2017年加入美团，目前主要负责美团轻收银、美团收银零售版等App的相关业务及模块开发工作。\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-07-26T00:00:00Z",
  "Author": "soulteary@gmail.com"
}