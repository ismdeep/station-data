{
  "Source": "tech.meituan.com",
  "Title": "美团App页面视图可测性改造实践",
  "Link": "https://tech.meituan.com/2021/07/28/app-xraysdk.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"美团app的页面特点\"\u003e美团App的页面特点\u003c/h2\u003e\u003cp\u003e对于不同的用户，美团App页面的呈现方式其实多种多样，这就是所谓的“千人千面”。以美团首页的“猜你喜欢”模块为例，针对与不同的用户有单列、Tab、双列等多种不同形式。这么多不同的页面样式需求，如果要在1天内时间内完成开发、测试、上线流程，研发团队也面临着很大的挑战。所以测试工程师就需要重度依赖自动化测试来形成快速的验收机制。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b3fb502a4c01b1f3bcef9d6bdee1b5a8487412.png\" alt=\"图1美团App首页多种页面布局样式\"/\u003e\u003c/p\u003e\u003ch2 id=\"自动化测试实施中的技术挑战\"\u003e自动化测试实施中的技术挑战\u003c/h2\u003e\u003cp\u003e接下来，本文将会从页面元素无法定位、Appium元素定位的原理、AccessibilityNodeInfo和Drawable等三个维度进行阐述。\u003c/p\u003e\u003ch3 id=\"页面元素无法定位\"\u003e页面元素无法定位\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/e9828cf0a3dfa7090dbf8634b0c80ddb40788.png\" alt=\"图2 页面元素审查情况\"/\u003e\u003c/p\u003e\u003cp\u003e目前，美团App客户端自动化主要依托于Appium（一个开源、跨平台的测试框架，可以用来测试原生及混合的移动端应用）来实现页面元素的定位和操作，当我们通过Appium Inspector进行页面元素审查时，能通过元素审查找到的信息只有外面的边框和下方的两个按钮，其他信息均无法识别(如上图2所示)。中央位置的图片、左上角的文本信息都无法通过现有的UI自动化方案进行定位和解析。不能定位元素，也就无法进行页面的操作和断言，这就严重影响了自动化的实施工作。\u003c/p\u003e\u003cp\u003e经过进一步的调研，我们发现这些页面卡片中大量使用Drawable对象来绘制页面的信息，从而导致元素无法进行定位。为什么Drawable对象无法定位呢？下面我们一起研究一下UI自动化元素定位的原理。\u003c/p\u003e\u003ch3 id=\"appium元素定位的原理\"\u003eAppium元素定位的原理\u003c/h3\u003e\u003cp\u003e目前的UI自动化测试，使用Appium进行页面元素的定位和操作。如下图所示，AppiumServer和UiAutomator2的手机端进行通信后完成元素的操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/94c2fdd1a91576a70d67e61dae724b5e84069.png\" alt=\"图3 Appium的通信原理\"/\u003e\u003c/p\u003e\u003cp\u003e通过阅读Appium源码发现完成一次定位的流程如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/29f6cbb2eab601df480f5d27b182300050750.png\" alt=\"图4 Appium定位元素的实现流程\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e首先，Appium通过调用\u003ccode\u003efindElement\u003c/code\u003e的方式进行元素定位。\u003c/li\u003e\u003cli\u003e然后，调用Android提供\u003ccode\u003eUIDevice\u003c/code\u003e对象的\u003ccode\u003efindObject\u003c/code\u003e方法。\u003c/li\u003e\u003cli\u003e最终，通过\u003ccode\u003ePartialMatch.accept\u003c/code\u003e完成元素的查找。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e接下来我们看一下，这个\u003ccode\u003ePartialMatch.accept\u003c/code\u003e到底是如何完成元素定位的。通过对于\u003ca href=\"https://android.googlesource.com/platform/frameworks/uiautomator/+/android-support-test/src/main/java/android/support/test/uiautomator/ByMatcher.java\"\u003e源码\u003c/a\u003e的研究，我们发现元素的信息都是存储在一个叫做\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e的对象里面。源码中使用大量\u003ccode\u003enode.getXXX\u003c/code\u003e方法中的信息，大家是否眼熟呢？这些信息其实就是我们日常自动化测试中可以获取UI元素的属性。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/27d287ee42436a920901bc184cfd69d725211.png\" alt=\"图5 AppiumInspector审查元素获取信息示意\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eDrawable\u003c/code\u003e无法获取元素信息，是否和\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e相关？我们进一步探究\u003ccode\u003eDrawable\u003c/code\u003e和\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e的关系。\u003c/p\u003e\u003ch3 id=\"accessibilitynodeinfo和drawable\"\u003eAccessibilityNodeInfo和Drawable\u003c/h3\u003e\u003cp\u003e通过对于源码的研究，我们绘制了如下类图来解释\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e和\u003ccode\u003eDrawable\u003c/code\u003e之间的关系。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/44e4855dc8de4abe17465e2136bed6d692365.png\" alt=\"图6 类关系示意图\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eView\u003c/code\u003e实现了\u003ccode\u003eAccessibilityEventSource\u003c/code\u003e接口并实现了一个叫做\u003ccode\u003eonInitializeAccessibilityNodeInfo\u003c/code\u003e的方法来填充信息。我们也在\u003ca href=\"https://developer.android.com/guide/topics/ui/accessibility/custom-views?hl=zh-cn\"\u003eAndroid官方文档\u003c/a\u003e中找到了对于此信息的说明：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eonInitializeAccessibilityNodeInfo() ：此方法为无障碍服务提供有关视图状态的信息。默认的\u003ccode\u003eView\u003c/code\u003e实现具有一组标准的视图属性，但如果您的自定义视图提供除了简单的 \u003ccode\u003eTextView\u003c/code\u003e或\u003ccode\u003eButton\u003c/code\u003e之外的其他互动控件，则您应替换此方法并将有关视图的其他信息设置到由此方法处理的\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e对象中。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e而\u003ccode\u003eDrawable\u003c/code\u003e并没有实现对应的方法，所以也就无法被自动化测试找到。探究了元素查找原理之后，我们就要开始着手解决问题了。\u003c/p\u003e\u003ch2 id=\"页面视图可测性改造-xraysdk\"\u003e页面视图可测性改造-XraySDK\u003c/h2\u003e\u003ch3 id=\"定位方案对比\"\u003e定位方案对比\u003c/h3\u003e\u003cp\u003e既然知道了\u003ccode\u003eDrawable\u003c/code\u003e没有填充\u003ccode\u003eAccessibilityNodeInfo\u003c/code\u003e，也就说明我无法接入目前的自动化测试方案来完成页面内容的获取。那我们可以想到如下三种方案来解决问题：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e实现方案\u003c/th\u003e\u003cth\u003e影响范围\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e改造Appium定位方式，让Drawable可以被识别\u003c/td\u003e\u003ctd\u003e需要改动底层的AccessibilityNodeInfo obtain(View,int)方法和为Drawable添加AccessibilityNodeInfo这样就需要对于所有的Android系统做兼容，影响范围过大\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e使用View替代Drawable\u003c/td\u003e\u003ctd\u003e动态布局卡片使用Drawable进行绘制就是因为Drawable比View使用资源更少，绘制性能更好，放弃使用Drawable就等于放弃了性能的改进\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e使用图像识别进行定位\u003c/td\u003e\u003ctd\u003e动态卡片中有很多图像中包含文字，还有多行文本都会对图像识别的准确性带来很大的影响\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e上面的三种方案，目前看来都无法有效地解决动态卡片元素定位的问题。如何在影响范围较小的前提下，达成获取视图信息的目标呢？接下来，我们将进一步研究动态布局的实现方案。\u003c/p\u003e\u003ch3 id=\"视图信息的获取和存储-xraydumper\"\u003e视图信息的获取和存储-XrayDumper\u003c/h3\u003e\u003cp\u003e我们的应用场景非常明确，自动化测试通过集成Client来获得和客户端交互能力，通过Client向App发送指令来页面信息的获取。那我们可以考虑内嵌一个SDK（XraySDK）来完成视图的获取，然后再向自动化提供一个客户端（XrayClient）来完成这部分功能。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/be15715976df10ef128432891f7488bd18021.png\" alt=\"图7 XraySDK的工作流程示意图\"/\u003e\u003c/p\u003e\u003cp\u003e对于XraySDK的功能划分，如下表所示：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e模块名\u003c/th\u003e\u003cth\u003e功能划分\u003c/th\u003e\u003cth\u003e运行环境\u003c/th\u003e\u003cth\u003e产品形态\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eXray-Client\u003c/td\u003e\u003ctd\u003e1.和Xray-Server进行交互进行指令发送和数据的接收\u003cbr/\u003e2.暴露对外的Api给自动化或者其他系统\u003c/td\u003e\u003ctd\u003e自动化内部或者三方系统内部\u003c/td\u003e\u003ctd\u003eJAR包或基于其他语言的依赖包\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eXray-SDK\u003c/td\u003e\u003ctd\u003e1.进行页面信息的获取以及结构化(Xray-Dumper)\u003cbr/\u003e2.接收用户指令来进行结构化数据输出(Xray-Server)\u003c/td\u003e\u003ctd\u003eApp内部\u003c/td\u003e\u003ctd\u003e客户端SDK（AAR和Pod-Library）\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003eXraySDK如何才能获取到我们需要的Drawable信息呢？我们先来研究一下动态布局的实现方案。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/c1398d7af80f42d0302e25ad8babdab832893.png\" alt=\"图8 动态卡片的页面绘制流程\"/\u003e\u003c/p\u003e\u003cp\u003e动态布局的视图呈现过程分为：解析模板-\u0026gt;绑定数据-\u0026gt;计算布局-\u0026gt;页面绘制，计算布局结束后，元素在页面上的位置就已经确定了，那么只要拦截这个阶段信息就可以实现视图信息的获取。\u003c/p\u003e\u003cp\u003e通过对于代码的研究，我们发现在\u003ccode\u003ecom.sankuai.litho.recycler.AdapterCompat\u003c/code\u003e这个类中控制着视图布局行为，在\u003ccode\u003ebindViewHolder\u003c/code\u003e中完成视图的最终的布局和计算。首先，我们通过在此处插入一个自定义的监听器来拦截布局信息。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic final void bindViewHolder(BaseViewHolder\u0026lt;Data\u0026gt; viewHolder, int position) {\n        if (viewHolder != null) {\n            viewHolder.bindView(context, getData(position), position);\n\n            //自动化测试回调\n            if (componentTreeCreateListeners != null) {\n                if (viewHolder instanceof LithoViewHolder) {\n                    DataHolder holder = getData(position);\n                    //获取视图布局信息\n                    LithoView view = ((LithoViewHolder\u0026lt;Data\u0026gt;) viewHolder).lithoView;\n                    LayoutController layoutController = ((LithoDynamicDataHolder) holder).getLayoutController(null);\n                    VirtualNodeBase node = layoutController.viewNodeRoot;\n                    //通过监听器将视图信息向外传递给可测性SDK\n                    componentTreeCreateListeners.onComponentTreeCreated(node, view.getRootView(), view.getComponentTree());\n                }\n            }\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后，通过暴露一个静态方法给可测性SDK，完成监听器的初始化。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic static void setComponentTreeCreateListener(ComponentTreeCreateListener l) {\n        AdapterCompat.componentTreeCreateListeners = l;\n        try {\n            // 兼容mbc的动态布局自动化测试，为避免循环依赖，采用反射调用\n            Class\u0026lt;?\u0026gt; mbcDynamicClass = Class.forName(\u0026#34;com.sankuai.meituan.mbc.business.item.dynamic.DynamicLithoItem\u0026#34;);\n            Method setComponentTreeCreateListener = mbcDynamicClass.getMethod(\u0026#34;setComponentTreeCreateListener\u0026#34;, ComponentTreeCreateListener.class);\n            setComponentTreeCreateListener.invoke(null, l);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        try {\n            // 搜索新框架动态布局自动化测试\n            Class\u0026lt;?\u0026gt; searchDynamicClass = Class.forName(\u0026#34;com.sankuai.meituan.search.result2.model.DynamicItem\u0026#34;);\n            Method setSearchComponentTreeCreateListener = searchDynamicClass.getMethod(\u0026#34;setComponentTreeCreateListener\u0026#34;, ComponentTreeCreateListener.class);\n            setSearchComponentTreeCreateListener.invoke(null, l);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，自动化通过设置自定义的监听器来完成视图信息的获取和存储。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//通过静态方法设置一个ComponentTreeCreateListener来监听布局事件\nAdapterCompat.setComponentTreeCreateListener(new AdapterCompat.ComponentTreeCreateListener() {\n            @Override\n            public void onComponentTreeCreated(VirtualNodeBase node, View rootView, ComponentTree tree) {\n                //将信息存储到一个自定义的ViewInfoObserver对象中\n                ViewInfoObserver vif = new ViewInfoObserver();\n                vif.update(node, rootView, tree);\n            }\n        });\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们将视图信息存储在ViewInfoObserver这样一个对象中。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class ViewInfoObserver implements AutoTestObserver{\n    public static HashMap\u0026lt;String, View\u0026gt; VIEW_MAP = new HashMap\u0026lt;\u0026gt;();\n    public static HashMap\u0026lt;VirtualNodeBase, View\u0026gt; VIEW = new HashMap\u0026lt;\u0026gt;();\n    public static HashMap\u0026lt;String, ComponentTree\u0026gt; COMPTREE_MAP = new HashMap\u0026lt;\u0026gt;();\n    public static String uri = \u0026#34;http://dashboard.ep.dev.sankuai.com/outter/dynamicTemplateKeyFromJson\u0026#34;;\n\n    @Override\n    public void update(VirtualNodeBase vn, View view,ComponentTree tree) {\n        if (null != vn \u0026amp;\u0026amp; null != vn.jsonObject) {\n            try {\n                String string = vn.jsonObject.toString();\n                Gson g = new GsonBuilder().setPrettyPrinting().create();\n                JsonParser p = new JsonParser();\n                JsonElement e = p.parse(string);\n\n                String templateName = null;\n                String name1 = getObject(e,\u0026#34;templateName\u0026#34;);\n                String name2 = getObject(e,\u0026#34;template_name\u0026#34;);\n                String name3 = getObject(e,\u0026#34;template\u0026#34;);\n                templateName = null != name1 ? name1 : (null != name2 ? name2 : (null != name3 ? name3 : null));\n\n                if (null != templateName) {\n                //如果已经存储则更新视图信息\n                    if (VIEW_MAP.containsKey(templateName)) {\n                        VIEW_MAP.remove(templateName);\n                    }\n                    //存储视图编号\n                    VIEW_MAP.put(templateName, view);\n                    if (VIEW.containsKey(templateName)) {\n                        VIEW.remove(templateName);\n                    }\n                    //存储视图信息\n                    VIEW.put(vn, view);\n                    if (COMPTREE_MAP.containsKey(templateName)) {\n                        COMPTREE_MAP.remove(templateName);\n                    }\n                    COMPTREE_MAP.put(templateName, tree);\n                    System.out.println(\u0026#34;autotestDyn：update success\u0026#34;);\n\n                }\n\n            } catch (Exception e) {\n                System.out.println(e.toString());\n                System.out.println(\u0026#34;autotestDyn：templateName not exist!\u0026#34;);\n            }\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当需要查询这些信息的时候，就可以通过XrayDumper来完成信息的输出。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class SubViewInfo {\n    public JSONObject getOutData(String template) throws JSONException {\n        JSONObject outData = new JSONObject();\n        JSONObject componentTouchables = new JSONObject();\n\n        if (!COMPTREE_MAP.isEmpty() \u0026amp;\u0026amp; COMPTREE_MAP.containsKey(template) \u0026amp;\u0026amp; null != COMPTREE_MAP.get(template)) {\n            ComponentTree cpt = COMPTREE_MAP.get(template);\n            JSONArray componentArray = new JSONArray();\n\n            ArrayList\u0026lt;View\u0026gt; touchables = cpt.getLithoView().getTouchables();\n            LithoView lithoView = cpt.getLithoView();\n            int[] ls = new int[2];\n            lithoView.getLocationOnScreen(ls);\n            int pointX = ls[0];\n            int pointY = ls[1];\n\n            for (int i = 0; i \u0026lt; touchables.size(); i++) {\n                JSONObject temp = new JSONObject();\n                int height = touchables.get(i).getHeight();\n                int width = touchables.get(i).getWidth();\n                int[] tl = new int[2];\n                touchables.get(i).getLocationOnScreen(tl);\n                temp.put(\u0026#34;height\u0026#34;,height);\n                temp.put(\u0026#34;width\u0026#34;,width);\n                temp.put(\u0026#34;pointX\u0026#34;,tl[0]);\n                temp.put(\u0026#34;pointY\u0026#34;,tl[1]);\n\n                String url = \u0026#34;\u0026#34;;\n                try {\n                    EventHandler eh = (EventHandler) getValue(getValue(touchables.get(i), \u0026#34;mOnClickListener\u0026#34;), \u0026#34;mEventHandler\u0026#34;);\n                    DynamicClickListener listener = (DynamicClickListener) getValue(getValue(eh, \u0026#34;mHasEventDispatcher\u0026#34;), \u0026#34;listener\u0026#34;);\n                    Uri clickUri = (Uri) getValue(listener, \u0026#34;uri\u0026#34;);\n                    if (null != clickUri) {\n                        url = clickUri.toString();\n                    }\n                } catch (Exception e) {\n                    Log.d(\u0026#34;autotest\u0026#34;, \u0026#34;get click url error!\u0026#34;);\n                }\n\n                temp.put(\u0026#34;url\u0026#34;,url);\n                componentArray.put(temp);\n            }\n            componentTouchables.put(\u0026#34;componentTouchables\u0026#34;,componentArray);\n            componentTouchables.put(\u0026#34;componentTouchablesCount\u0026#34;, cpt.getLithoView().getTouchables().size());\n\n            View[] root = (View[])getValue(cpt.getLithoView(),\u0026#34;mChildren\u0026#34;);\n            JSONArray allComponentArray = new JSONArray();\n            if (root.length \u0026gt; 0) {\n                for (int i = 0; i \u0026lt; root.length; i++) {\n                    try {\n                        if (null != root[i]) {\n                            Object items[] = (Object[]) getValue(getValue(root[i], \u0026#34;mMountItems\u0026#34;), \u0026#34;mValues\u0026#34;);\n                            componentTouchables.put(\u0026#34;componentCount\u0026#34;, items.length);\n                            for (int itemIndex = 0; itemIndex \u0026lt; items.length; itemIndex++) {\n                                getMountItems(allComponentArray, items[itemIndex], pointX, pointY);\n                            }\n                        }\n                    } catch (Exception e) {\n\n                    }\n                }\n            }\n            componentTouchables.put(\u0026#34;componentUntouchables\u0026#34;,allComponentArray);\n        } else {\n            Log.d(\u0026#34;autotest\u0026#34;,\u0026#34;COMPTREE_MAP is null!\u0026#34;);\n        }\n        outData.put(template,componentTouchables);\n        System.out.println(outData);\n        return outData;\n    }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"视图信息的输出-xrayserver\"\u003e视图信息的输出-XrayServer\u003c/h3\u003e\u003cp\u003e我们获取到了信息，接下来就要考虑如何将视图信息传递给自动化测试脚本，我们参考了Appium的设计。\u003c/p\u003e\u003cp\u003eAppium通过在手机上安装的InstrumentsClient启动了一个SocketServer通过HTTP协议来完成自动化和底层测试框架的数据通信。我们也可以借鉴上述思路，在美团App中启动一个WebServer来完成信息的输出。\u003c/p\u003e\u003cp\u003e第一步，我们实现了一个继承了Service组件，这样就可以方便的通过命令行的方式的启动和停止可测性的功能。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class AutoTestServer extends Service  {\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n    ....\n        return super.onStartCommand(intent, flags, startId);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第二步，通过HttpServer的方式对外暴露通信的接口。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class AutoTestServer extends Service  {\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n        // 创建对象，端口通过参数传入\n        if (intent != null) {\n            int randNum = intent.getIntExtra(\u0026#34;autoTestPort\u0026#34;,8999);\n            HttpServer myServer = new HttpServer(randNum);\n            try {\n                // 开启HTTP服务\n                myServer.start();\n                System.out.println(\u0026#34;AutoTestPort:\u0026#34; + randNum);\n            } catch (IOException e) {\n                System.err.println(\u0026#34;AutoTestPort:\u0026#34; + e.getMessage());\n                myServer = new HttpServer(8999);\n                try {\n                    myServer.start();\n                    System.out.println(\u0026#34;AutoTestPort:8999\u0026#34;);\n                } catch (IOException e1) {\n                    System.err.println(\u0026#34;Default:\u0026#34; + e.getMessage());\n                }\n            }\n        }\n        return super.onStartCommand(intent, flags, startId);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第三步，将之前设置好的监听器进行注册。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class AutoTestServer extends Service  {\n    @Override\n    public IBinder onBind(Intent intent) {\n        return null;\n    }\n\n    @Override\n    public int onStartCommand(Intent intent, int flags, int startId) {\n    //注册监听器\n        AdapterCompat.setComponentTreeCreateListener(new AdapterCompat.ComponentTreeCreateListener() {\n            @Override\n            public void onComponentTreeCreated(VirtualNodeBase node, View rootView, ComponentTree tree) {\n                ViewInfoObserver vif = new ViewInfoObserver();\n                vif.update(node, rootView, tree);\n            }\n        });\n\n        // 创建对象，端口通过参数传入\n        .....\n        return super.onStartCommand(intent, flags, startId);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后，在HttpServer中通过不同的路径来实现接收不同的指令。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eprivate JSONObject getResponseByUri(@Nonnull IHTTPSession session) throws JSONException {\n        String uri = session.getUri();\n        if (isFindCommand(uri)) {\n            return getResponseByFindUri(uri);\n        }\n}\n\n@Nonnull\nprivate JSONObject getResponseByFindUri(@Nonnull String uri) throws JSONException {\n    String template = uri.split(\u0026#34;/\u0026#34;)[2];\n    String protocol = uri.split(\u0026#34;/\u0026#34;)[3];\n    switch (protocol) {\n        case \u0026#34;frame\u0026#34;:\n            TemplateLayoutFrame tlf = new TemplateLayoutFrame();\n            return tlf.getOutData(template);\n        case \u0026#34;subview\u0026#34;:\n            SubViewInfo svi = new SubViewInfo();\n            return svi.getOutData(template);\n        //省略了部分的代码处理逻辑    \n        ....\n        default:\n            JSONObject errorJson = new JSONObject();\n            errorJson.put(\u0026#34;success\u0026#34;, false);\n            errorJson.put(\u0026#34;message\u0026#34;, \u0026#34;输入find链接地址有误\u0026#34;);\n            return errorJson;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"sdk整体功能结构\"\u003eSDK整体功能结构\u003c/h3\u003e\u003cp\u003e自动化脚本通过访问设备的特定端口（例如：\u003ca href=\"http://localhost:8899/find/subview），经由XrayServer，通过访问路径将请求转发至XrayDumper进行信息的提取和输出。然后布局解析器将布局信息序列化成JSON数据，再经由XrayServer，通过网络以HTTP响应的方式传到给自动化测试脚本。\"\u003ehttp://localhost:8899/find/subview），经由XrayServer，通过访问路径将请求转发至XrayDumper进行信息的提取和输出。然后布局解析器将布局信息序列化成JSON数据，再经由XrayServer，通过网络以HTTP响应的方式传到给自动化测试脚本。\u003c/a\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/0686b4d2a1bd6d9dc1855634c470c5bd203337.png\" alt=\"图9-XraySDK功能结构示意图\"/\u003e\u003c/p\u003e\u003ch3 id=\"视图信息的增强\"\u003e视图信息的增强\u003c/h3\u003e\u003cp\u003e除了常规的位置、内容、类型等信息，我们还通过检查时间监听器的方式，进一步判断视图元素是否可以进行交互，进一步增强了页面视图结构的有效信息。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// setGestures\nArrayList\u0026lt;String\u0026gt; gestures = new ArrayList\u0026lt;\u0026gt;();\nif (view.isClickable()){\n   gestures.add(\u0026#34;isClickable\u0026#34;);\n}\nif (view.isLongClickable()){\n   gestures.add(\u0026#34;isLongClickable\u0026#34;);\n}\n//省略部分代码\n.....\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"动态布局自动化的收益\"\u003e动态布局自动化的收益\u003c/h3\u003e\u003cp\u003e基于视图可测性的提升，美团动态化卡片的自动化测试覆盖度有了大幅的提升，从原来无法做自动化测试，到目前80%以上的动态化卡片都实现了自动化测试，而且效率也得到了明显的提升。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/55ba8423378be711bf7ad73b6d589cc668434.png\" alt=\"图10 自动化效率提升收益\"/\u003e\u003c/p\u003e\u003ch2 id=\"未来展望\"\u003e未来展望\u003c/h2\u003e\u003cp\u003e页面视图信息作为客户端测试最基础且重要的属性之一，是对用户视觉信息的一种代码级的表示。它对于机器识别页面元素信息有着非常重要的作用，对于它的可测性改造将会给技术团队带来很大的收益。我们会列举了几个视图可测性改造的探索方向，仅供大家参考。\u003c/p\u003e\u003ch3 id=\"使用视图解析原理解决webview元素定位\"\u003e使用视图解析原理解决WebView元素定位\u003c/h3\u003e\u003cp\u003e应用同样的思想，我们还可以用来解决WebView元素定位的问题。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/144bffaa8553a3d65f6a8c7e4913f868257457.png\" alt=\"图11 WebView页面示例\"/\u003e\u003c/p\u003e\u003cp\u003e通过运行在App内部的SDK，可以获取到对应的WebView实例。通过获取到根节点，从根节点开始进行循环遍历，同时把每个节点的信息存储下来就可以得到所有的视图信息了。\u003c/p\u003e\u003cp\u003e在WebView是否也有同样合适的根节点呢？基于对于HTML的理解我们可以想到HTML中所有的标签都是挂在BODY标签下面的，BODY标签就是我们需要选取的根节点。我们可以通过WebElement[“attrName”]的方式来进行属性的获取。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/9c59bc97c2dc90071b6c0812edc2b548141543.png\" alt=\"图12 遍历WebView节点的代码示例\"/\u003e\u003c/p\u003e\u003ch3 id=\"视图可测性改造的更多应用场景\"\u003e视图可测性改造的更多应用场景\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e提升功能测试可靠性\u003c/strong\u003e：在功能测试自动化中，通过内部更加稳定和迅速的视图信息输出，可以有效提升自动化测试的稳定性。避免由于元素无法获取或者元素获取缓慢导致的自动化测试失败。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e提升可靠性测试效率\u003c/strong\u003e：对于依靠随机或者按照视图信息进行页面随机操作的可靠性测试，依赖对于视图信息的过滤，也可以只操作可以交互的元素（通过过滤元素事件监听器是否为空）。这样就可以有效提升可靠性测试的效率，在单位时间内可以完成更多页面的检测。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e增加兼容性测试检测手段\u003c/strong\u003e：在页面兼容性方面，通过对页面组件位置信息和属性来扫描页面内是否存在不合理的堆叠、空白区域、形状异常等UI呈现异常。也可以获取内容信息，例如图片、文本，来检查是否存在不适宜内容呈现。可以作为图像对比方案的有效补充。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团平台质量技术中心，负责美团 App 业务和大前端（移动客户端和Web前端）基础技术质量工作，沉淀流程规范和配套工具、提升研发效率。团队技术一流、氛围良好，感兴趣的同学简历可以发送至: zhangjie63@meituan.com\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2021-07-28T00:00:00Z",
  "Author": "soulteary@gmail.com"
}