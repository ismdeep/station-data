{
  "Source": "tech.meituan.com",
  "Title": "CompletableFuture原理与实践-外卖商家端API的异步化",
  "Link": "https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"0-背景\"\u003e0 背景\u003c/h2\u003e\u003cp\u003e随着订单量的持续上升，美团外卖各系统服务面临的压力也越来越大。作为外卖链路的核心环节，商家端提供了商家接单、配送等一系列核心功能，业务对系统吞吐量的要求也越来越高。而商家端API服务是流量入口，所有商家端流量都会由其调度、聚合，对外面向商家提供功能接口，对内调度各个下游服务获取数据进行聚合，具有鲜明的I/O密集型（I/O Bound）特点。在当前日订单规模已达千万级的情况下，使用同步加载方式的弊端逐渐显现，因此我们开始考虑将同步加载改为并行加载的可行性。\u003c/p\u003e\u003ch2 id=\"1-为何需要并行加载\"\u003e1 为何需要并行加载\u003c/h2\u003e\u003cp\u003e外卖商家端API服务是典型的I/O密集型（I/O Bound）服务。除此之外，美团外卖商家端交易业务还有两个比较大的特点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e服务端必须一次返回订单卡片所有内容\u003c/strong\u003e：根据商家端和服务端的“增量同步协议\u003csup\u003e注1\u003c/sup\u003e”，服务端必须一次性返回订单的所有信息，包含订单主信息、商品、结算、配送、用户信息、骑手信息、餐损、退款、客服赔付（参照下面订单卡片截图）等，需要从下游三十多个服务中获取数据。在特定条件下，如第一次登录和长时间没登录的情况下，客户端会分页拉取多个订单，这样发起的远程调用会更多。\u003c/li\u003e\u003cli\u003e商家端和服务端\u003cstrong\u003e交互频繁\u003c/strong\u003e：商家对订单状态变化敏感，多种推拉机制保证每次变更能够触达商家，导致App和服务端的交互频繁，每次变更需要拉取订单最新的全部内容。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在外卖交易链路如此大的流量下，为了保证商家的用户体验，保证接口的高性能，并行从下游获取数据就成为必然。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/624090f482fe471e74f6e4e135803de3501878.png\" alt=\"图1 订单卡片\"/\u003e\u003c/p\u003e\u003ch2 id=\"2-并行加载的实现方式\"\u003e2 并行加载的实现方式\u003c/h2\u003e\u003cp\u003e并行从下游获取数据，从IO模型上来讲分为\u003cstrong\u003e同步模型\u003c/strong\u003e和\u003cstrong\u003e异步模型\u003c/strong\u003e。\u003c/p\u003e\u003ch3 id=\"2-1-同步模型\"\u003e2.1 同步模型\u003c/h3\u003e\u003cp\u003e从各个服务获取数据最常见的是同步调用，如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/ad46bb8baa4e79e727ee5bd7af0b175c38212.png\" alt=\"图2 同步调用\"/\u003e\u003c/p\u003e\u003cp\u003e在同步调用的场景下，接口耗时长、性能差，接口响应时长T \u0026gt; T1+T2+T3+……+Tn，这时为了缩短接口的响应时间，一般会使用线程池的方式并行获取数据，商家端订单卡片的组装正是使用了这种方式。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/873b403c8542460c44bd6d631f7f813644155.png\" alt=\"图3 并行之线程池\"/\u003e\u003c/p\u003e\u003cp\u003e这种方式由于以下两个原因，导致资源利用率比较低：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eCPU资源大量浪费在阻塞等待上\u003c/strong\u003e，导致CPU资源利用率低。在Java 8之前，一般会通过回调的方式来减少阻塞，但是大量使用回调，又引发臭名昭著的\u003cstrong\u003e回调地狱\u003c/strong\u003e问题，导致代码可读性和可维护性大大降低。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了增加并发度，会引入更多额外的线程池\u003c/strong\u003e，随着CPU调度线程数的增加，会导致更严重的资源争用，宝贵的CPU资源被损耗在上下文切换上，而且线程本身也会占用系统资源，且不能无限增加。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e同步模型下，会导致\u003cstrong\u003e硬件资源无法充分利用\u003c/strong\u003e，系统吞吐量容易达到瓶颈。\u003c/p\u003e\u003ch3 id=\"2-2-nio异步模型\"\u003e2.2 NIO异步模型\u003c/h3\u003e\u003cp\u003e我们主要通过以下两种方式来减少线程池的调度开销和阻塞时间：\u003c/p\u003e\u003cul\u003e\u003cli\u003e通过RPC NIO异步调用的方式可以降低线程数，从而降低调度（上下文切换）开销，如Dubbo的异步调用可以参考\u003ca href=\"https://dubbo.apache.org/zh/docs/v3.0/references/features/async-call/\"\u003e《dubbo调用端异步》\u003c/a\u003e一文。\u003c/li\u003e\u003cli\u003e通过引入CompletableFuture（下文简称CF）对业务流程进行编排，降低依赖之间的阻塞。本文主要讲述CompletableFuture的使用和原理。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"2-3-为什么会选择completablefuture\"\u003e2.3 为什么会选择CompletableFuture？\u003c/h3\u003e\u003cp\u003e我们首先对业界广泛流行的解决方案做了横向调研，主要包括Future、CompletableFuture\u003csup\u003e注2\u003c/sup\u003e、RxJava、Reactor。它们的特性对比如下：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e\u003c/th\u003e\u003cth\u003eFuture\u003c/th\u003e\u003cth\u003eCompletableFuture\u003c/th\u003e\u003cth\u003eRxJava\u003c/th\u003e\u003cth\u003eReactor\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eComposable（可组合）\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eAsynchronous（异步）\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eOperator fusion（操作融合）\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eLazy（延迟执行）\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eBackpressure（回压）\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e❌\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003ctd\u003e✔️\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e可组合\u003c/strong\u003e：可以将多个依赖操作通过不同的方式进行编排，例如CompletableFuture提供thenCompose、thenCombine等各种then开头的方法，这些方法就是对“可组合”特性的支持。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e操作融合\u003c/strong\u003e：将数据流中使用的多个操作符以某种方式结合起来，进而降低开销（时间、内存）。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e延迟执行\u003c/strong\u003e：操作不会立即执行，当收到明确指示时操作才会触发。例如Reactor只有当有订阅者订阅时，才会触发操作。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e回压\u003c/strong\u003e：某些异步阶段的处理速度跟不上，直接失败会导致大量数据的丢失，对业务来说是不能接受的，这时需要反馈上游生产者降低调用量。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eRxJava与Reactor显然更加强大，它们提供了更多的函数调用方式，支持更多特性，但同时也带来了更大的学习成本。而我们本次整合最需要的特性就是“异步”、“可组合”，综合考虑后，我们选择了学习成本相对较低的CompletableFuture。\u003c/p\u003e\u003ch2 id=\"3-completablefuture使用与原理\"\u003e3 CompletableFuture使用与原理\u003c/h2\u003e\u003ch3 id=\"3-1-completablefuture的背景和定义\"\u003e3.1 CompletableFuture的背景和定义\u003c/h3\u003e\u003ch4 id=\"3-1-1-completablefuture解决的问题\"\u003e3.1.1 CompletableFuture解决的问题\u003c/h4\u003e\u003cp\u003eCompletableFuture是由Java 8引入的，在Java8之前我们一般通过Future实现异步。\u003c/p\u003e\u003cul\u003e\u003cli\u003eFuture用于表示异步计算的结果，只能通过阻塞或者轮询的方式获取结果，而且不支持设置回调方法，Java 8之前若要设置回调一般会使用guava的ListenableFuture，回调的引入又会导致臭名昭著的回调地狱（下面的例子会通过ListenableFuture的使用来具体进行展示）。\u003c/li\u003e\u003cli\u003eCompletableFuture对Future进行了扩展，可以通过设置回调的方式处理计算结果，同时也支持组合操作，支持进一步的编排，同时一定程度解决了回调地狱的问题。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e下面将举例来说明，我们通过ListenableFuture、CompletableFuture来实现异步的差异。假设有三个操作step1、step2、step3存在依赖关系，其中step3的执行依赖step1和step2的结果。\u003c/p\u003e\u003cp\u003eFuture(ListenableFuture)的实现（回调地狱）如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eExecutorService executor = Executors.newFixedThreadPool(5);\nListeningExecutorService guavaExecutor = MoreExecutors.listeningDecorator(executor);\nListenableFuture\u0026lt;String\u0026gt; future1 = guavaExecutor.submit(() -\u0026gt; {\n    //step 1\n    System.out.println(\u0026#34;执行step 1\u0026#34;);\n    return \u0026#34;step1 result\u0026#34;;\n});\nListenableFuture\u0026lt;String\u0026gt; future2 = guavaExecutor.submit(() -\u0026gt; {\n    //step 2\n    System.out.println(\u0026#34;执行step 2\u0026#34;);\n    return \u0026#34;step2 result\u0026#34;;\n});\nListenableFuture\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; future1And2 = Futures.allAsList(future1, future2);\nFutures.addCallback(future1And2, new FutureCallback\u0026lt;List\u0026lt;String\u0026gt;\u0026gt;() {\n    @Override\n    public void onSuccess(List\u0026lt;String\u0026gt; result) {\n        System.out.println(result);\n        ListenableFuture\u0026lt;String\u0026gt; future3 = guavaExecutor.submit(() -\u0026gt; {\n            System.out.println(\u0026#34;执行step 3\u0026#34;);\n            return \u0026#34;step3 result\u0026#34;;\n        });\n        Futures.addCallback(future3, new FutureCallback\u0026lt;String\u0026gt;() {\n            @Override\n            public void onSuccess(String result) {\n                System.out.println(result);\n            }        \n            @Override\n            public void onFailure(Throwable t) {\n            }\n        }, guavaExecutor);\n    }\n\n    @Override\n    public void onFailure(Throwable t) {\n    }}, guavaExecutor);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eCompletableFuture的实现如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eExecutorService executor = Executors.newFixedThreadPool(5);\nCompletableFuture\u0026lt;String\u0026gt; cf1 = CompletableFuture.supplyAsync(() -\u0026gt; {\n    System.out.println(\u0026#34;执行step 1\u0026#34;);\n    return \u0026#34;step1 result\u0026#34;;\n}, executor);\nCompletableFuture\u0026lt;String\u0026gt; cf2 = CompletableFuture.supplyAsync(() -\u0026gt; {\n    System.out.println(\u0026#34;执行step 2\u0026#34;);\n    return \u0026#34;step2 result\u0026#34;;\n});\ncf1.thenCombine(cf2, (result1, result2) -\u0026gt; {\n    System.out.println(result1 + \u0026#34; , \u0026#34; + result2);\n    System.out.println(\u0026#34;执行step 3\u0026#34;);\n    return \u0026#34;step3 result\u0026#34;;\n}).thenAccept(result3 -\u0026gt; System.out.println(result3));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e显然，CompletableFuture的实现更为简洁，可读性更好。\u003c/p\u003e\u003ch4 id=\"3-1-2-completablefuture的定义\"\u003e3.1.2 CompletableFuture的定义\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/75a9710d2053b2fa0654c67cd7f35a0c18774.png\" alt=\"图4 CompletableFuture的定义\"/\u003e\u003c/p\u003e\u003cp\u003eCompletableFuture实现了两个接口（如上图所示）：Future、CompletionStage。Future表示异步计算的结果，CompletionStage用于表示异步执行过程中的一个步骤（Stage），这个步骤可能是由另外一个CompletionStage触发的，随着当前步骤的完成，也可能会触发其他一系列CompletionStage的执行。从而我们可以根据实际业务对这些步骤进行多样化的编排组合，CompletionStage接口正是定义了这样的能力，我们可以通过其提供的thenAppy、thenCompose等函数式编程方法来组合编排这些步骤。\u003c/p\u003e\u003ch3 id=\"3-2-completablefuture的使用\"\u003e3.2 CompletableFuture的使用\u003c/h3\u003e\u003cp\u003e下面我们通过一个例子来讲解CompletableFuture如何使用，使用CompletableFuture也是构建依赖树的过程。一个CompletableFuture的完成会触发另外一系列依赖它的CompletableFuture的执行：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b14b861db9411b2373b80100fee0b92f15076.png\" alt=\"图5 请求执行流程\"/\u003e\u003c/p\u003e\u003cp\u003e如上图所示，这里描绘的是一个业务接口的流程，其中包括CF1\\CF2\\CF3\\CF4\\CF5共5个步骤，并描绘了这些步骤之间的依赖关系，每个步骤可以是一次RPC调用、一次数据库操作或者是一次本地方法调用等，在使用CompletableFuture进行异步化编程时，图中的每个步骤都会产生一个CompletableFuture对象，最终结果也会用一个CompletableFuture来进行表示。\u003c/p\u003e\u003cp\u003e根据CompletableFuture依赖数量，可以分为以下几类：零依赖、一元依赖、二元依赖和多元依赖。\u003c/p\u003e\u003ch4 id=\"3-2-1-零依赖-completablefuture的创建\"\u003e3.2.1 零依赖：CompletableFuture的创建\u003c/h4\u003e\u003cp\u003e我们先看下如何不依赖其他CompletableFuture来创建新的CompletableFuture：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/ff663f95c86e22928c0bb94fc6bd8b8715722.png\" alt=\"图6 零依赖\"/\u003e\u003c/p\u003e\u003cp\u003e如上图红色链路所示，接口接收到请求后，首先发起两个异步调用CF1、CF2，主要有三种方式：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eExecutorService executor = Executors.newFixedThreadPool(5);\n//1、使用runAsync或supplyAsync发起异步调用\nCompletableFuture\u0026lt;String\u0026gt; cf1 = CompletableFuture.supplyAsync(() -\u0026gt; {\n  return \u0026#34;result1\u0026#34;;\n}, executor);\n//2、CompletableFuture.completedFuture()直接创建一个已完成状态的CompletableFuture\nCompletableFuture\u0026lt;String\u0026gt; cf2 = CompletableFuture.completedFuture(\u0026#34;result2\u0026#34;);\n//3、先初始化一个未完成的CompletableFuture，然后通过complete()、completeExceptionally()，完成该CompletableFuture\nCompletableFuture\u0026lt;String\u0026gt; cf = new CompletableFuture\u0026lt;\u0026gt;();\ncf.complete(\u0026#34;success\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第三种方式的一个典型使用场景，就是将回调方法转为CompletableFuture，然后再依赖CompletableFure的能力进行调用编排，示例如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@FunctionalInterface\npublic interface ThriftAsyncCall {\n    void invoke() throws TException;\n}\n /**\n  * 该方法为美团内部rpc注册监听的封装，可以作为其他实现的参照\n  * OctoThriftCallback 为thrift回调方法\n  * ThriftAsyncCall 为自定义函数，用来表示一次thrift调用（定义如上）\n  */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;T\u0026gt; toCompletableFuture(final OctoThriftCallback\u0026lt;?,T\u0026gt; callback , ThriftAsyncCall thriftCall) {\n   //新建一个未完成的CompletableFuture\n   CompletableFuture\u0026lt;T\u0026gt; resultFuture = new CompletableFuture\u0026lt;\u0026gt;();\n   //监听回调的完成，并且与CompletableFuture同步状态\n   callback.addObserver(new OctoObserver\u0026lt;T\u0026gt;() {\n       @Override\n       public void onSuccess(T t) {\n           resultFuture.complete(t);\n       }\n       @Override\n       public void onFailure(Throwable throwable) {\n           resultFuture.completeExceptionally(throwable);\n       }\n   });\n   if (thriftCall != null) {\n       try {\n           thriftCall.invoke();\n       } catch (TException e) {\n           resultFuture.completeExceptionally(e);\n       }\n   }\n   return resultFuture;\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"3-2-2-一元依赖-依赖一个cf\"\u003e3.2.2 一元依赖：依赖一个CF\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/373a334e7e7e7d359e8f042c7c9075e215479.png\" alt=\"图7 一元依赖\"/\u003e\u003c/p\u003e\u003cp\u003e如上图红色链路所示，CF3，CF5分别依赖于CF1和CF2，这种对于单个CompletableFuture的依赖可以通过thenApply、thenAccept、thenCompose等方法来实现，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCompletableFuture\u0026lt;String\u0026gt; cf3 = cf1.thenApply(result1 -\u0026gt; {\n  //result1为CF1的结果\n  //......\n  return \u0026#34;result3\u0026#34;;\n});\nCompletableFuture\u0026lt;String\u0026gt; cf5 = cf2.thenApply(result2 -\u0026gt; {\n  //result2为CF2的结果\n  //......\n  return \u0026#34;result5\u0026#34;;\n});\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"3-2-3-二元依赖-依赖两个cf\"\u003e3.2.3 二元依赖：依赖两个CF\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/fa4c8669b4cf63b7a89cfab0bcb693b216006.png\" alt=\"图8 二元依赖\"/\u003e\u003c/p\u003e\u003cp\u003e如上图红色链路所示，CF4同时依赖于两个CF1和CF2，这种二元依赖可以通过thenCombine等回调来实现，如下代码所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCompletableFuture\u0026lt;String\u0026gt; cf4 = cf1.thenCombine(cf2, (result1, result2) -\u0026gt; {\n  //result1和result2分别为cf1和cf2的结果\n  return \u0026#34;result4\u0026#34;;\n});\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"3-2-4-多元依赖-依赖多个cf\"\u003e3.2.4 多元依赖：依赖多个CF\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/92248abd0a5b11dd36f9ccb1f1233d4e16045.png\" alt=\"图9 多元依赖\"/\u003e\u003c/p\u003e\u003cp\u003e如上图红色链路所示，整个流程的结束依赖于三个步骤CF3、CF4、CF5，这种多元依赖可以通过\u003ccode\u003eallOf\u003c/code\u003e或\u003ccode\u003eanyOf\u003c/code\u003e方法来实现，区别是当需要多个依赖全部完成时使用\u003ccode\u003eallOf\u003c/code\u003e，当多个依赖中的任意一个完成即可时使用\u003ccode\u003eanyOf\u003c/code\u003e，如下代码所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCompletableFuture\u0026lt;Void\u0026gt; cf6 = CompletableFuture.allOf(cf3, cf4, cf5);\nCompletableFuture\u0026lt;String\u0026gt; result = cf6.thenApply(v -\u0026gt; {\n  //这里的join并不会阻塞，因为传给thenApply的函数是在CF3、CF4、CF5全部完成时，才会执行 。\n  result3 = cf3.join();\n  result4 = cf4.join();\n  result5 = cf5.join();\n  //根据result3、result4、result5组装最终result;\n  return \u0026#34;result\u0026#34;;\n});\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"3-3-completablefuture原理\"\u003e3.3 CompletableFuture原理\u003c/h3\u003e\u003cp\u003eCompletableFuture中包含两个字段：\u003cstrong\u003eresult\u003c/strong\u003e和\u003cstrong\u003estack\u003c/strong\u003e。result用于存储当前CF的结果，stack（Completion）表示当前CF完成后需要触发的依赖动作（Dependency Actions），去触发依赖它的CF的计算，依赖动作可以有多个（表示有多个依赖它的CF），以栈（\u003ca href=\"https://en.wikipedia.org/wiki/Treiber_stack\"\u003eTreiber stack\u003c/a\u003e）的形式存储，stack表示栈顶元素。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/82aa288ea62d74c03afcd2308d302b6910425.png\" alt=\"图10 CF基本结构\"/\u003e\u003c/p\u003e\u003cp\u003e这种方式类似“观察者模式”，依赖动作（Dependency Action）都封装在一个单独Completion子类中。下面是Completion类关系结构图。CompletableFuture中的每个方法都对应了图中的一个Completion的子类，Completion本身是\u003cstrong\u003e观察者\u003c/strong\u003e的基类。\u003c/p\u003e\u003cul\u003e\u003cli\u003eUniCompletion继承了Completion，是一元依赖的基类，例如thenApply的实现类UniApply就继承自UniCompletion。\u003c/li\u003e\u003cli\u003eBiCompletion继承了UniCompletion，是二元依赖的基类，同时也是多元依赖的基类。例如thenCombine的实现类BiRelay就继承自BiCompletion。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/5a889b90d0f2c2a0f6a4f294b9094194112106.png\" alt=\"图11 CF类图\"/\u003e\u003c/p\u003e\u003ch4 id=\"3-3-1-completablefuture的设计思想\"\u003e3.3.1 CompletableFuture的设计思想\u003c/h4\u003e\u003cp\u003e按照类似“观察者模式”的设计思想，原理分析可以从“观察者”和“被观察者”两个方面着手。由于回调种类多，但结构差异不大，所以这里单以一元依赖中的thenApply为例，不再枚举全部回调类型。如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/f45b271b656f3ae243875fcb2af36a1141224.png\" alt=\"图12 thenApply简图\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3.3.1.1 被观察者\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e每个CompletableFuture都可以被看作一个被观察者，其内部有一个Completion类型的链表成员变量stack，用来存储注册到其中的所有观察者。当被观察者执行完成后会弹栈stack属性，依次通知注册到其中的观察者。上面例子中步骤fn2就是作为观察者被封装在UniApply中。\u003c/li\u003e\u003cli\u003e被观察者CF中的result属性，用来存储返回结果数据。这里可能是一次RPC调用的返回值，也可能是任意对象，在上面的例子中对应步骤fn1的执行结果。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cstrong\u003e3.3.1.2 观察者\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eCompletableFuture支持很多回调方法，例如thenAccept、thenApply、exceptionally等，这些方法接收一个函数类型的参数f，生成一个Completion类型的对象（即观察者），并将入参函数f赋值给Completion的成员变量fn，然后检查当前CF是否已处于完成状态（即result != null），如果已完成直接触发fn，否则将观察者Completion加入到CF的观察者链stack中，再次尝试触发，如果被观察者未执行完则其执行完毕之后通知触发。\u003c/p\u003e\u003col\u003e\u003cli\u003e观察者中的dep属性：指向其对应的CompletableFuture，在上面的例子中dep指向CF2。\u003c/li\u003e\u003cli\u003e观察者中的src属性：指向其依赖的CompletableFuture，在上面的例子中src指向CF1。\u003c/li\u003e\u003cli\u003e观察者Completion中的fn属性：用来存储具体的等待被回调的函数。这里需要注意的是不同的回调方法（thenAccept、thenApply、exceptionally等）接收的函数类型也不同，即fn的类型有很多种，在上面的例子中fn指向fn2。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"3-3-2-整体流程\"\u003e3.3.2 整体流程\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e3.3.2.1 一元依赖\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e这里仍然以thenApply为例来说明一元依赖的流程：\u003c/p\u003e\u003col\u003e\u003cli\u003e将观察者Completion注册到CF1，此时CF1将Completion压栈。\u003c/li\u003e\u003cli\u003e当CF1的操作运行完成时，会将结果赋值给CF1中的result属性。\u003c/li\u003e\u003cli\u003e依次弹栈，通知观察者尝试运行。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/f449bbc62d4a1f8e9e4998929196513d165269.gif\" alt=\"图13 执行流程简要说明\"/\u003e\u003c/p\u003e\u003cp\u003e初步流程设计如上图所示，这里有几个关于注册与通知的并发问题，大家可以思考下：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQ1\u003c/strong\u003e：在观察者注册之前，如果CF已经执行完成，并且已经发出通知，那么这时观察者由于错过了通知是不是将永远不会被触发呢 ？\n\u003cstrong\u003eA1\u003c/strong\u003e：不会。在注册时检查依赖的CF是否已经完成。如果未完成（即result == null）则将观察者入栈，如果已完成（result != null）则直接触发观察者操作。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQ2\u003c/strong\u003e：在”入栈“前会有”result == null“的判断，这两个操作为非原子操作，CompletableFufure的实现也没有对两个操作进行加锁，完成时间在这两个操作之间，观察者仍然得不到通知，是不是仍然无法触发？\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/6b4aeae7085f7d77d9f33799734f3b926723.png\" alt=\"图14 入栈校验\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA2\u003c/strong\u003e：不会。入栈之后再次检查CF是否完成，如果完成则触发。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQ3\u003c/strong\u003e：当依赖多个CF时，观察者会被压入所有依赖的CF的栈中，每个CF完成的时候都会进行，那么会不会导致一个操作被多次执行呢 ？如下图所示，即当CF1、CF2同时完成时，如何避免CF3被多次触发。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/316ff338f8dab2826a5d32dfb75ffede4158.png\" alt=\"图15 多次触发\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA3\u003c/strong\u003e：CompletableFuture的实现是这样解决该问题的：观察者在执行之前会先通过CAS操作设置一个状态位，将status由0改为1。如果观察者已经执行过了，那么CAS操作将会失败，取消执行。\u003c/p\u003e\u003cp\u003e通过对以上3个问题的分析可以看出，CompletableFuture在处理并行问题时，全程无加锁操作，极大地提高了程序的执行效率。我们将并行问题考虑纳入之后，可以得到完善的整体流程图如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/606323a07fb7e31cb91f46c879d99b8d735272.gif\" alt=\"图16 完整流程\"/\u003e\u003c/p\u003e\u003cp\u003eCompletableFuture支持的回调方法十分丰富，但是正如上一章节的整体流程图所述，他们的整体流程是一致的。所有回调复用同一套流程架构，不同的回调监听通过\u003cstrong\u003e策略模式\u003c/strong\u003e实现差异化。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3.3.2.2 二元依赖\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们以thenCombine为例来说明二元依赖：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b969e49a7eedbd52b014f86e86dcd3fc49634.png\" alt=\"图17 二元依赖数据结构\"/\u003e\u003c/p\u003e\u003cp\u003ethenCombine操作表示依赖两个CompletableFuture。其观察者实现类为BiApply，如上图所示，BiApply通过src和snd两个属性关联被依赖的两个CF，fn属性的类型为BiFunction。与单个依赖不同的是，在依赖的CF未完成的情况下，thenCombine会尝试将BiApply压入这两个被依赖的CF的栈中，每个被依赖的CF完成时都会尝试触发观察者BiApply，BiApply会检查两个依赖是否都完成，如果完成则开始执行。这里为了解决重复触发的问题，同样用的是上一章节提到的CAS操作，执行时会先通过CAS设置状态位，避免重复触发。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3.3.2.3 多元依赖\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e依赖多个CompletableFuture的回调方法包括\u003ccode\u003eallOf\u003c/code\u003e、\u003ccode\u003eanyOf\u003c/code\u003e，区别在于\u003ccode\u003eallOf\u003c/code\u003e观察者实现类为BiRelay，需要所有被依赖的CF完成后才会执行回调；而\u003ccode\u003eanyOf\u003c/code\u003e观察者实现类为OrRelay，任意一个被依赖的CF完成后就会触发。二者的实现方式都是将多个被依赖的CF构建成一棵平衡二叉树，执行结果层层通知，直到根节点，触发回调监听。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/cef5469b5ec2e67ecca1b99a07260e4e22003.png\" alt=\"图18 多元依赖结构树\"/\u003e\u003c/p\u003e\u003ch4 id=\"3-3-3-小结\"\u003e3.3.3 小结\u003c/h4\u003e\u003cp\u003e本章节为CompletableFuture实现原理的科普，旨在尝试不粘贴源码，而通过结构图、流程图以及搭配文字描述把CompletableFuture的实现原理讲述清楚。把晦涩的源码翻译为“整体流程”章节的流程图，并且将并发处理的逻辑融入，便于大家理解。\u003c/p\u003e\u003ch2 id=\"4-实践总结\"\u003e4 实践总结\u003c/h2\u003e\u003cp\u003e在商家端API异步化的过程中，我们遇到了一些问题，这些问题有的会比较隐蔽，下面把这些问题的处理经验整理出来。希望能帮助到更多的同学，大家可以少踩一些坑。\u003c/p\u003e\u003ch3 id=\"4-1-线程阻塞问题\"\u003e4.1 线程阻塞问题\u003c/h3\u003e\u003ch4 id=\"4-1-1-代码执行在哪个线程上\"\u003e4.1.1 代码执行在哪个线程上？\u003c/h4\u003e\u003cp\u003e要合理治理线程资源，最基本的前提条件就是要在写代码时，清楚地知道每一行代码都将执行在哪个线程上。下面我们看一下CompletableFuture的执行线程情况。\u003c/p\u003e\u003cp\u003eCompletableFuture实现了CompletionStage接口，通过丰富的回调方法，支持各种组合操作，每种组合场景都有同步和异步两种方法。\u003c/p\u003e\u003cp\u003e同步方法（即不带Async后缀的方法）有两种情况。\u003c/p\u003e\u003cul\u003e\u003cli\u003e如果注册时被依赖的操作已经执行完成，则直接由当前线程执行。\u003c/li\u003e\u003cli\u003e如果注册时被依赖的操作还未执行完，则由回调线程执行。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e异步方法（即带Async后缀的方法）：可以选择是否传递线程池参数Executor运行在指定线程池中；当不传递Executor时，会使用ForkJoinPool中的共用线程池CommonPool（CommonPool的大小是CPU核数-1，如果是IO密集的应用，线程数可能成为瓶颈）。\u003c/p\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eExecutorService threadPool1 = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue\u0026lt;\u0026gt;(100));\nCompletableFuture\u0026lt;String\u0026gt; future1 = CompletableFuture.supplyAsync(() -\u0026gt; {\n    System.out.println(\u0026#34;supplyAsync 执行线程：\u0026#34; + Thread.currentThread().getName());\n    //业务操作\n    return \u0026#34;\u0026#34;;\n}, threadPool1);\n//此时，如果future1中的业务操作已经执行完毕并返回，则该thenApply直接由当前main线程执行；否则，将会由执行以上业务操作的threadPool1中的线程执行。\nfuture1.thenApply(value -\u0026gt; {\n    System.out.println(\u0026#34;thenApply 执行线程：\u0026#34; + Thread.currentThread().getName());\n    return value + \u0026#34;1\u0026#34;;\n});\n//使用ForkJoinPool中的共用线程池CommonPool\nfuture1.thenApplyAsync(value -\u0026gt; {\n//do something\n  return value + \u0026#34;1\u0026#34;;\n});\n//使用指定线程池\nfuture1.thenApplyAsync(value -\u0026gt; {\n//do something\n  return value + \u0026#34;1\u0026#34;;\n}, threadPool1);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"4-2-线程池须知\"\u003e4.2 线程池须知\u003c/h3\u003e\u003ch4 id=\"4-2-1-异步回调要传线程池\"\u003e4.2.1 异步回调要传线程池\u003c/h4\u003e\u003cp\u003e前面提到，异步回调方法可以选择是否传递线程池参数Executor，这里我们建议\u003cstrong\u003e强制传线程池，且根据实际情况做线程池隔离\u003c/strong\u003e。\u003c/p\u003e\u003cp\u003e当不传递线程池时，会使用ForkJoinPool中的公共线程池CommonPool，这里所有调用将共用该线程池，核心线程数=处理器数量-1（单核核心线程数为1），所有异步回调都会共用该CommonPool，核心与非核心业务都竞争同一个池中的线程，很容易成为系统瓶颈。手动传递线程池参数可以更方便的调节参数，并且可以给不同的业务分配不同的线程池，以求资源隔离，减少不同业务之间的相互干扰。\u003c/p\u003e\u003ch4 id=\"4-2-2-线程池循环引用会导致死锁\"\u003e4.2.2 线程池循环引用会导致死锁\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Object doGet() {\n  ExecutorService threadPool1 = new ThreadPoolExecutor(10, 10, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue\u0026lt;\u0026gt;(100));\n  CompletableFuture cf1 = CompletableFuture.supplyAsync(() -\u0026gt; {\n  //do sth\n    return CompletableFuture.supplyAsync(() -\u0026gt; {\n        System.out.println(\u0026#34;child\u0026#34;);\n        return \u0026#34;child\u0026#34;;\n      }, threadPool1).join();//子任务\n    }, threadPool1);\n  return cf1.join();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如上代码块所示，doGet方法第三行通过supplyAsync向threadPool1请求线程，并且内部子任务又向threadPool1请求线程。threadPool1大小为10，当同一时刻有10个请求到达，则threadPool1被打满，子任务请求线程时进入阻塞队列排队，但是父任务的完成又依赖于子任务，这时由于子任务得不到线程，父任务无法完成。主线程执行cf1.join()进入阻塞状态，并且永远无法恢复。\u003c/p\u003e\u003cp\u003e为了修复该问题，需要将父任务与子任务做线程池隔离，两个任务请求不同的线程池，避免循环依赖导致的阻塞。\u003c/p\u003e\u003ch4 id=\"4-2-3-异步rpc调用注意不要阻塞io线程池\"\u003e4.2.3 异步RPC调用注意不要阻塞IO线程池\u003c/h4\u003e\u003cp\u003e服务异步化后很多步骤都会依赖于异步RPC调用的结果，这时需要特别注意一点，如果是使用基于NIO（比如Netty）的异步RPC，则返回结果是由IO线程负责设置的，即回调方法由IO线程触发，CompletableFuture同步回调（如thenApply、thenAccept等无Async后缀的方法）如果依赖的异步RPC调用的返回结果，那么这些同步回调将运行在IO线程上，而整个服务只有一个IO线程池，这时需要保证同步回调中不能有阻塞等耗时过长的逻辑，否则在这些逻辑执行完成前，IO线程将一直被占用，影响整个服务的响应。\u003c/p\u003e\u003ch3 id=\"4-3-其他\"\u003e4.3 其他\u003c/h3\u003e\u003ch4 id=\"4-3-1-异常处理\"\u003e4.3.1 异常处理\u003c/h4\u003e\u003cp\u003e由于异步执行的任务在其他线程上执行，而异常信息存储在线程栈中，因此当前线程除非阻塞等待返回结果，否则无法通过try\\catch捕获异常。CompletableFuture提供了异常捕获回调exceptionally，相当于同步调用中的try\\catch。使用方法如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Autowired\nprivate WmOrderAdditionInfoThriftService wmOrderAdditionInfoThriftService;//内部接口\npublic CompletableFuture\u0026lt;Integer\u0026gt; getCancelTypeAsync(long orderId) {\n    CompletableFuture\u0026lt;WmOrderOpRemarkResult\u0026gt; remarkResultFuture = wmOrderAdditionInfoThriftService.findOrderCancelledRemarkByOrderIdAsync(orderId);//业务方法，内部会发起异步rpc调用\n    return remarkResultFuture\n      .exceptionally(err -\u0026gt; {//通过exceptionally 捕获异常，打印日志并返回默认值\n         log.error(\u0026#34;WmOrderRemarkService.getCancelTypeAsync Exception orderId={}\u0026#34;, orderId, err);\n         return 0;\n      });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e有一点需要注意，CompletableFuture在回调方法中对异常进行了包装。大部分异常会封装成CompletionException后抛出，真正的异常存储在cause属性中，因此如果调用链中经过了回调方法处理那么就需要用Throwable.getCause()方法提取真正的异常。但是，有些情况下会直接返回真正的异常（\u003ca href=\"https://stackoverflow.com/questions/49230980/does-completionstage-always-wrap-exceptions-in-completionexception\"\u003eStack Overflow的讨论\u003c/a\u003e），最好使用工具类提取异常，如下代码所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Autowired\nprivate WmOrderAdditionInfoThriftService wmOrderAdditionInfoThriftService;//内部接口\npublic CompletableFuture\u0026lt;Integer\u0026gt; getCancelTypeAsync(long orderId) {\n    CompletableFuture\u0026lt;WmOrderOpRemarkResult\u0026gt; remarkResultFuture = wmOrderAdditionInfoThriftService.findOrderCancelledRemarkByOrderIdAsync(orderId);//业务方法，内部会发起异步rpc调用\n    return remarkResultFuture\n          .thenApply(result -\u0026gt; {//这里增加了一个回调方法thenApply，如果发生异常thenApply内部会通过new CompletionException(throwable) 对异常进行包装\n      //这里是一些业务操作\n        })\n      .exceptionally(err -\u0026gt; {//通过exceptionally 捕获异常，这里的err已经被thenApply包装过，因此需要通过Throwable.getCause()提取异常\n         log.error(\u0026#34;WmOrderRemarkService.getCancelTypeAsync Exception orderId={}\u0026#34;, orderId, ExceptionUtils.extractRealException(err));\n         return 0;\n      });\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面代码中用到了一个自定义的工具类ExceptionUtils，用于CompletableFuture的异常提取，在使用CompletableFuture做异步编程时，可以直接使用该工具类处理异常。实现代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class ExceptionUtils {\n    public static Throwable extractRealException(Throwable throwable) {\n          //这里判断异常类型是否为CompletionException、ExecutionException，如果是则进行提取，否则直接返回。\n        if (throwable instanceof CompletionException || throwable instanceof ExecutionException) {\n            if (throwable.getCause() != null) {\n                return throwable.getCause();\n            }\n        }\n        return throwable;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"4-3-2-沉淀的工具方法介绍\"\u003e4.3.2 沉淀的工具方法介绍\u003c/h4\u003e\u003cp\u003e在实践过程中我们沉淀了一些通用的工具方法，在使用CompletableFuture开发时可以直接拿来使用，详情参见“附录”。\u003c/p\u003e\u003ch2 id=\"5-异步化收益\"\u003e5 异步化收益\u003c/h2\u003e\u003cp\u003e通过异步化改造，美团商家端API系统的性能得到明显提升，与改造前对比的收益如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e核心接口吞吐量大幅提升，其中订单轮询接口改造前TP99为754ms，改造后降为408ms。\u003c/li\u003e\u003cli\u003e服务器数量减少1/3。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"6-参考文献\"\u003e6 参考文献\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html\"\u003eCompletableFuture (Java Platform SE 8 )\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/49230980/does-completionstage-always-wrap-exceptions-in-completionexception\"\u003ejava - Does CompletionStage always wrap exceptions in CompletionException? - Stack Overflow\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://stackoverflow.com/questions/27430255/surprising-behavior-of-java-8-completablefuture-exceptionally-method\"\u003eexception - Surprising behavior of Java 8 CompletableFuture exceptionally method - Stack Overflow\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://dubbo.apache.org/zh/docs/\"\u003e文档 | Apache Dubbo\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"7-名词解释及备注\"\u003e7 名词解释及备注\u003c/h2\u003e\u003cp\u003e注1：“增量同步”是指商家客户端与服务端之间的订单增量数据同步协议，客户端使用该协议获取新增订单以及状态发生变化的订单。\u003c/p\u003e\u003cp\u003e注2：本文涉及到的所有技术点依赖的Java版本为JDK 8，CompletableFuture支持的特性分析也是基于该版本。\u003c/p\u003e\u003ch2 id=\"附录\"\u003e附录\u003c/h2\u003e\u003ch3 id=\"自定义函数\"\u003e自定义函数\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@FunctionalInterface\npublic interface ThriftAsyncCall {\n    void invoke() throws TException ;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"completablefuture处理工具类\"\u003eCompletableFuture处理工具类\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n * CompletableFuture封装工具类\n */\n@Slf4j\npublic class FutureUtils {\n/**\n * 该方法为美团内部rpc注册监听的封装，可以作为其他实现的参照\n * OctoThriftCallback 为thrift回调方法\n * ThriftAsyncCall 为自定义函数，用来表示一次thrift调用（定义如上）\n */\npublic static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;T\u0026gt; toCompletableFuture(final OctoThriftCallback\u0026lt;?,T\u0026gt; callback , ThriftAsyncCall thriftCall) {\n    CompletableFuture\u0026lt;T\u0026gt; thriftResultFuture = new CompletableFuture\u0026lt;\u0026gt;();\n    callback.addObserver(new OctoObserver\u0026lt;T\u0026gt;() {\n        @Override\n        public void onSuccess(T t) {\n            thriftResultFuture.complete(t);\n        }\n        @Override\n        public void onFailure(Throwable throwable) {\n            thriftResultFuture.completeExceptionally(throwable);\n        }\n    });\n    if (thriftCall != null) {\n        try {\n            thriftCall.invoke();\n        } catch (TException e) {\n            thriftResultFuture.completeExceptionally(e);\n        }\n    }\n    return thriftResultFuture;\n}\n  /**\n   * 设置CF状态为失败\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;T\u0026gt; failed(Throwable ex) {\n   CompletableFuture\u0026lt;T\u0026gt; completableFuture = new CompletableFuture\u0026lt;\u0026gt;();\n   completableFuture.completeExceptionally(ex);\n   return completableFuture;\n  }\n  /**\n   * 设置CF状态为成功\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;T\u0026gt; success(T result) {\n   CompletableFuture\u0026lt;T\u0026gt; completableFuture = new CompletableFuture\u0026lt;\u0026gt;();\n   completableFuture.complete(result);\n   return completableFuture;\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;T\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequence(Collection\u0026lt;CompletableFuture\u0026lt;T\u0026gt;\u0026gt; completableFutures) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .map(CompletableFuture::join)\n                   .collect(Collectors.toList())\n           );\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\n   * 多用于分页查询的场景\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequenceList(Collection\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; completableFutures) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .flatMap( listFuture -\u0026gt; listFuture.join().stream())\n                   .collect(Collectors.toList())\n           );\n  }\n  /*\n   * 将List\u0026lt;CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\n   * @Param mergeFunction 自定义key冲突时的merge策略\n   */\n  public static \u0026lt;K, V\u0026gt; CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt; sequenceMap(\n       Collection\u0026lt;CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\u0026gt; completableFutures, BinaryOperator\u0026lt;V\u0026gt; mergeFunction) {\n   return CompletableFuture\n           .allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream().map(CompletableFuture::join)\n                   .flatMap(map -\u0026gt; map.entrySet().stream())\n                   .collect(Collectors.toMap(Entry::getKey, Entry::getValue, mergeFunction)));\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;T\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;，并过滤调null值\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequenceNonNull(Collection\u0026lt;CompletableFuture\u0026lt;T\u0026gt;\u0026gt; completableFutures) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .map(CompletableFuture::join)\n                   .filter(e -\u0026gt; e != null)\n                   .collect(Collectors.toList())\n           );\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;，并过滤调null值\n   * 多用于分页查询的场景\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequenceListNonNull(Collection\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; completableFutures) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .flatMap( listFuture -\u0026gt; listFuture.join().stream().filter(e -\u0026gt; e != null))\n                   .collect(Collectors.toList())\n           );\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\n   * @Param filterFunction 自定义过滤策略\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequence(Collection\u0026lt;CompletableFuture\u0026lt;T\u0026gt;\u0026gt; completableFutures,\n                                                     Predicate\u0026lt;? super T\u0026gt; filterFunction) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .map(CompletableFuture::join)\n                   .filter(filterFunction)\n                   .collect(Collectors.toList())\n           );\n  }\n  /**\n   * 将List\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; 转为 CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\n   * @Param filterFunction 自定义过滤策略\n   */\n  public static \u0026lt;T\u0026gt; CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt; sequenceList(Collection\u0026lt;CompletableFuture\u0026lt;List\u0026lt;T\u0026gt;\u0026gt;\u0026gt; completableFutures,\n                                                         Predicate\u0026lt;? super T\u0026gt; filterFunction) {\n   return CompletableFuture.allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream()\n                   .flatMap( listFuture -\u0026gt; listFuture.join().stream().filter(filterFunction))\n                   .collect(Collectors.toList())\n           );\n  }\n/**\n * 将CompletableFuture\u0026lt;Map\u0026lt;K,V\u0026gt;\u0026gt;的list转为 CompletableFuture\u0026lt;Map\u0026lt;K,V\u0026gt;\u0026gt;。 多个map合并为一个map。 如果key冲突，采用新的value覆盖。\n */\n  public static \u0026lt;K, V\u0026gt; CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt; sequenceMap(\n       Collection\u0026lt;CompletableFuture\u0026lt;Map\u0026lt;K, V\u0026gt;\u0026gt;\u0026gt; completableFutures) {\n   return CompletableFuture\n           .allOf(completableFutures.toArray(new CompletableFuture\u0026lt;?\u0026gt;[0]))\n           .thenApply(v -\u0026gt; completableFutures.stream().map(CompletableFuture::join)\n                   .flatMap(map -\u0026gt; map.entrySet().stream())\n                   .collect(Collectors.toMap(Entry::getKey, Entry::getValue, (a, b) -\u0026gt; b)));\n  }}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"异常提取工具类\"\u003e异常提取工具类\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  public class ExceptionUtils {\n   /**\n    * 提取真正的异常\n    */\n   public static Throwable extractRealException(Throwable throwable) {\n       if (throwable instanceof CompletionException || throwable instanceof ExecutionException) {\n           if (throwable.getCause() != null) {\n               return throwable.getCause();\n           }\n       }\n       return throwable;\n   }\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"打印日志\"\u003e打印日志\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  @Slf4j\n  public abstract class AbstractLogAction\u0026lt;R\u0026gt; {\n  protected final String methodName;\n  protected final Object[] args;\npublic AbstractLogAction(String methodName, Object... args) {\n    this.methodName = methodName;\n    this.args = args;\n}\nprotected void logResult(R result, Throwable throwable) {\n    if (throwable != null) {\n        boolean isBusinessError = throwable instanceof TBase || (throwable.getCause() != null \u0026amp;\u0026amp; throwable\n                .getCause() instanceof TBase);\n        if (isBusinessError) {\n            logBusinessError(throwable);\n        } else if (throwable instanceof DegradeException || throwable instanceof DegradeRuntimeException) {//这里为内部rpc框架抛出的异常，使用时可以酌情修改\n            if (RhinoSwitch.getBoolean(\u0026#34;isPrintDegradeLog\u0026#34;, false)) {\n                log.error(\u0026#34;{} degrade exception, param:{} , error:{}\u0026#34;, methodName, args, throwable);\n            }\n        } else {\n            log.error(\u0026#34;{} unknown error, param:{} , error:{}\u0026#34;, methodName, args, ExceptionUtils.extractRealException(throwable));\n        }\n    } else {\n        if (isLogResult()) {\n            log.info(\u0026#34;{} param:{} , result:{}\u0026#34;, methodName, args, result);\n        } else {\n            log.info(\u0026#34;{} param:{}\u0026#34;, methodName, args);\n        }\n    }\n}\nprivate void logBusinessError(Throwable throwable) {\n    log.error(\u0026#34;{} business error, param:{} , error:{}\u0026#34;, methodName, args, throwable.toString(), ExceptionUtils.extractRealException(throwable));\n}\nprivate boolean isLogResult() {\n      //这里是动态配置开关，用于动态控制日志打印，开源动态配置中心可以使用nacos、apollo等，如果项目没有使用配置中心则可以删除\n    return RhinoSwitch.getBoolean(methodName + \u0026#34;_isLogResult\u0026#34;, false);\n}}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"日志处理实现类\"\u003e日志处理实现类\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n * 发生异常时，根据是否为业务异常打印日志。\n * 跟CompletableFuture.whenComplete配合使用，不改变completableFuture的结果（正常OR异常）\n */\n@Slf4j\npublic class LogErrorAction\u0026lt;R\u0026gt; extends AbstractLogAction\u0026lt;R\u0026gt; implements BiConsumer\u0026lt;R, Throwable\u0026gt; {\npublic LogErrorAction(String methodName, Object... args) {\n    super(methodName, args);\n}\n@Override\npublic void accept(R result, Throwable throwable) {\n    logResult(result, throwable);\n}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"打印日志方式\"\u003e打印日志方式\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003ecompletableFuture\n.whenComplete(\n  new LogErrorAction\u0026lt;\u0026gt;(\u0026#34;orderService.getOrder\u0026#34;, params));\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"异常情况返回默认值\"\u003e异常情况返回默认值\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n * 当发生异常时返回自定义的值\n */\npublic class DefaultValueHandle\u0026lt;R\u0026gt; extends AbstractLogAction\u0026lt;R\u0026gt; implements BiFunction\u0026lt;R, Throwable, R\u0026gt; {\n    private final R defaultValue;\n/**\n * 当返回值为空的时候是否替换为默认值\n */\nprivate final boolean isNullToDefault;\n/**\n * @param methodName      方法名称\n * @param defaultValue 当异常发生时自定义返回的默认值\n * @param args            方法入参\n */\n  public DefaultValueHandle(String methodName, R defaultValue, Object... args) {\n   super(methodName, args);\n   this.defaultValue = defaultValue;\n   this.isNullToDefault = false;\n  }\n/**\n * @param isNullToDefault\n * @param defaultValue 当异常发生时自定义返回的默认值\n * @param methodName      方法名称\n * @param args            方法入参\n */\n  public DefaultValueHandle(boolean isNullToDefault, R defaultValue, String methodName, Object... args) {\n   super(methodName, args);\n   this.defaultValue = defaultValue;\n   this.isNullToDefault = isNullToDefault;\n  }\n@Override\npublic R apply(R result, Throwable throwable) {\n    logResult(result, throwable);\n    if (throwable != null) {\n        return defaultValue;\n    }\n    if (result == null \u0026amp;\u0026amp; isNullToDefault) {\n        return defaultValue;\n    }\n    return result;\n}\npublic static \u0026lt;R\u0026gt; DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;R\u0026gt; builder() {\n    return new DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;\u0026gt;();\n}\npublic static class DefaultValueHandleBuilder\u0026lt;R\u0026gt; {\n    private boolean isNullToDefault;\n    private R defaultValue;\n    private String methodName;\n    private Object[] args;\n    DefaultValueHandleBuilder() {\n    }\n    public DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;R\u0026gt; isNullToDefault(final boolean isNullToDefault) {\n        this.isNullToDefault = isNullToDefault;\n        return this;\n    }\n    public DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;R\u0026gt; defaultValue(final R defaultValue) {\n        this.defaultValue = defaultValue;\n        return this;\n    }\n    public DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;R\u0026gt; methodName(final String methodName) {\n        this.methodName = methodName;\n        return this;\n    }\n    public DefaultValueHandle.DefaultValueHandleBuilder\u0026lt;R\u0026gt; args(final Object... args) {\n        this.args = args;\n        return this;\n    }\n    public DefaultValueHandle\u0026lt;R\u0026gt; build() {\n        return new DefaultValueHandle\u0026lt;R\u0026gt;(this.isNullToDefault, this.defaultValue, this.methodName, this.args);\n    }\n    public String toString() {\n        return \u0026#34;DefaultValueHandle.DefaultValueHandleBuilder(isNullToDefault=\u0026#34; + this.isNullToDefault + \u0026#34;, defaultValue=\u0026#34; + this.defaultValue + \u0026#34;, methodName=\u0026#34; + this.methodName + \u0026#34;, args=\u0026#34; + Arrays.deepToString(this.args) + \u0026#34;)\u0026#34;;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"默认返回值应用示例\"\u003e默认返回值应用示例\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003ecompletableFuture.handle(new DefaultValueHandle\u0026lt;\u0026gt;(\u0026#34;orderService.getOrder\u0026#34;, Collections.emptyMap(), params));\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"本文作者\"\u003e本文作者\u003c/h2\u003e\u003cp\u003e长发、旭孟、向鹏，均来自美团外卖商家组技术团队。\u003c/p\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团外卖商家组技术团队，通过技术手段服务于百万商家，涵盖客户、合同、商品、交易、成长等多个业务方向构建商家端系统，同时提升餐饮外卖商家的数字化经营水平，帮助美团建立丰富的供给，为用户提供更加丰富、多样的可选择性。\u003c/p\u003e\u003cp\u003e美团外卖商家系统，既有日千万量级订单下的稳定性挑战，又具有B端特有的业务复杂性，同时也在商家生态、商家运营、智能硬件等方向创新与探索。通过在高可用、领域驱动设计、微服务等技术方向持续实践，积累了丰富的技术经验。\u003c/p\u003e\u003cp\u003e欢迎加入美团外卖商家组技术团队，感兴趣的同学可以将简历发送至pingxumeng@\u003ca href=\"http://meituan.com/\"\u003emeituan.com\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2022-05-12T00:00:00Z",
  "Author": "soulteary@gmail.com"
}