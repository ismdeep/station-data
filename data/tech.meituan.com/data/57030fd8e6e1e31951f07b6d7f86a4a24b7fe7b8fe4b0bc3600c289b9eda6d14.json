{
  "Source": "tech.meituan.com",
  "Title": "Lego-美团接口自动化测试实践",
  "Link": "https://tech.meituan.com/2018/01/09/lego-api-test.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"一-概述\"\u003e一、概述\u003c/h2\u003e\u003ch3 id=\"1-1-接口自动化概述\"\u003e1.1 接口自动化概述\u003c/h3\u003e\u003cp\u003e众所周知，接口自动化测试有着如下特点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e低投入，高产出。\u003c/li\u003e\u003cli\u003e比较容易实现自动化。\u003c/li\u003e\u003cli\u003e和UI自动化测试相比更加稳定。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e如何做好一个接口自动化测试项目呢？\u003c/p\u003e\u003cp\u003e我认为，一个“好的”自动化测试项目，需要从\u003cstrong\u003e“时间”\u003c/strong\u003e、\u003cstrong\u003e“人力”\u003c/strong\u003e、\u003cstrong\u003e“收益”\u003c/strong\u003e这三个方面出发，做好“取舍”。\u003c/p\u003e\u003cp\u003e不能由于被测系统发生一些变更，就导致花费了几个小时的自动化脚本无法执行。同时，我们需要看到“收益”，不能为了总想看到100%的成功，而少做或者不做校验，但是校验多了维护成本一定会增多，可能每天都需要进行大量的维护。\u003c/p\u003e\u003cp\u003e所以做好这三个方面的平衡并不容易，经常能看到做自动化的同学，做到最后就本末倒置了。\u003c/p\u003e\u003ch3 id=\"1-2-提高roi\"\u003e1.2 提高ROI\u003c/h3\u003e\u003cp\u003e想要提高ROI（Return On Investment，投资回报率），我们必须从两方面入手：\u003c/p\u003e\u003col\u003e\u003cli\u003e减少投入成本。\u003c/li\u003e\u003cli\u003e增加使用率。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"针对-减少投入成本\"\u003e针对“减少投入成本”\u003c/h4\u003e\u003cp\u003e我们需要做到：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e减少工具开发的成本。\u003c/strong\u003e尽可能的减少开发工具的时间、工具维护的时间，尽可能使用公司已有的，或是业界成熟的工具或组件。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e减少用例录入成本。\u003c/strong\u003e简化测试用例录入的成本，尽可能多的提示，如果可以，开发一些批量生成测试用例的工具。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e减少用例维护成本。\u003c/strong\u003e减少用例维护成本，尽量只用在页面上做简单的输入即可完成维护动作，而不是进行大量的代码操作。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e减少用例优化成本。\u003c/strong\u003e当团队做用例优化时，可以通过一些统计数据，进行有针对性、有目的性的用例优化。\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"针对-增加使用率\"\u003e针对“增加使用率”\u003c/h4\u003e\u003cp\u003e我们需要做到：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e手工也能用。\u003c/strong\u003e不只是进行接口自动化测试，也可以完全用在手工测试上。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e人人能用。\u003c/strong\u003e每一个需要使用测试的人，包括一些非技术人员都可以使用。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e当工具用。\u003c/strong\u003e将一些接口用例当成工具使用，比如“生成订单”工具，“查找表单数据”工具。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e每天测试。\u003c/strong\u003e进行每日构建测试。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e开发的在构建之后也能触发测试。\u003c/strong\u003e开发将被测系统构建后，能自动触发接口自动化测试脚本，进行测试。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e所以，我这边开发了Lego接口测试平台，来实现我对自动测试想法的一些实践。先简单浏览一下网站，了解一下大概是个什么样的工具。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6fa46b09.png\" alt=\"首页\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b2e77799.png\" alt=\"用例维护页面\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7e0947bc.png\" alt=\"自动化用例列表\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/fd35b2df.png\" alt=\"在线执行结果\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/db08da1a.png\" alt=\"用例数量统计\"/\u003e\u003c/p\u003e\u003ch3 id=\"1-3-lego的组成\"\u003e1.3 Lego的组成\u003c/h3\u003e\u003cp\u003eLego接口测试解决方案是由两部分组成的，一个就是刚刚看到的“网站”，另一个部分就是“脚本”。\u003c/p\u003e\u003cp\u003e下面就开始进行“脚本设计”部分的介绍。\u003c/p\u003e\u003ch2 id=\"二-脚本设计\"\u003e二、脚本设计\u003c/h2\u003e\u003ch3 id=\"2-1-lego的做法\"\u003e2.1 Lego的做法\u003c/h3\u003e\u003cp\u003eLego接口自动化测试脚本部分，使用很常见的Jenkins+TestNG的结构。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/3f2a543b.jpg\" alt=\"Jenkins+TestNG的结构\"/\u003e\u003c/p\u003e\u003cp\u003e相信看到这样的模型并不陌生，因为很多的测试都是这样的组成方式。\u003c/p\u003e\u003cp\u003e将自动化测试用例存储至MySQL数据库中，做成比较常见的\u003cstrong\u003e“数据驱动”\u003c/strong\u003e做法。\u003c/p\u003e\u003cp\u003e很多团队也是使用这样的结构来进行接口自动化，沿用的话，那在以后的“推广”中，学习和迁移成本低都会比较低。\u003c/p\u003e\u003ch3 id=\"2-2-测试脚本\"\u003e2.2 测试脚本\u003c/h3\u003e\u003cp\u003e首先来简单看一下目前的脚本代码：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TestPigeon {\n    String sql;\n    int team_id = -1;\n\n    @Parameters({\u0026#34;sql\u0026#34;, \u0026#34;team_id\u0026#34;})\n    @BeforeClass()\n    public void beforeClass(String sql, int team_id) {\n        this.sql = sql;\n        this.team_id = team_id;\n        ResultRecorder.cleanInfo();\n    }\n\n    /**\n     * XML中的SQL决定了执行什么用例, 执行多少条用例, SQL的搜索结果为需要测试的测试用例\n     */\n    @DataProvider(name = \u0026#34;testData\u0026#34;)\n    private Iterator\u0026lt;Object[]\u0026gt; getData() throws SQLException, ClassNotFoundException {\n        return new DataProvider_forDB(TestConfig.DB_IP, TestConfig.DB_PORT, \n            TestConfig.DB_BASE_NAME,TestConfig.DB_USERNAME, TestConfig.DB_PASSWORD, sql);\n    }\n\n    @Test(dataProvider = \u0026#34;testData\u0026#34;)\n    public void test(Map\u0026lt;String, String\u0026gt; data) {\n        new ExecPigeonTest().execTestCase(data, false);\n    }\n\n    @AfterMethod\n    public void afterMethod(ITestResult result, Object[] objs) {...}\n\n    @AfterClass\n    public void consoleLog() {...}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6f4ea5da.jpg\" alt=\"测试脚本结构\"/\u003e\u003c/p\u003e\u003cp\u003e有一种做法我一直不提倡，就是把测试用例直接写在Java文件中。这样做会带来很多问题：修改测试用例需要改动大量的代码；代码也不便于交接给其他同学，因为每个人都有自己的编码风格和用例设计风格，这样交接，最后都会变成由下一个同学全部推翻重写一遍；如果测试平台更换，无法做用例数据的迁移，只能手动的一条条重新输入。\u003c/p\u003e\u003cp\u003e所以“测试数据”与“脚本”分离是非常有必要的。\u003c/p\u003e\u003cp\u003e网上很多的范例是使用的Excel进行的数据驱动，我这里为什么改用MySQL而不使用Excel了呢？\u003c/p\u003e\u003cp\u003e在公司，我们的脚本和代码都是提交至公司的Git代码仓库，如果使用Excel……很显然不方便日常经常修改测试用例的情况。使用MySQL数据库就没有这样的烦恼了，由于数据与脚本的分离，只需对数据进行修改即可，脚本每次会在数据库中读取最新的用例数据进行测试。同时，还可以防止一些操作代码时的误操作。\u003c/p\u003e\u003cp\u003e这里再附上一段我自己写的\u003ccode\u003eDataProvider_forDB\u003c/code\u003e方法，方便其他同学使用在自己的脚本上：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eimport java.sql.*;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * 数据源 数据库\n *\n * @author yongda.chen\n */\npublic class DataProvider_forDB implements Iterator\u0026lt;Object[]\u0026gt; {\n\n    ResultSet rs;\n    ResultSetMetaData rd;\n\n    public DataProvider_forDB(String ip, String port, String baseName, \n        String userName, String password, String sql) throws ClassNotFoundException, SQLException {\n        \n        Class.forName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;);\n        String url = String.format(\u0026#34;jdbc:mysql://%s:%s/%s\u0026#34;, ip, port, baseName);\n        Connection conn = DriverManager.getConnection(url, userName, password);\n        Statement createStatement = conn.createStatement();\n\n        rs = createStatement.executeQuery(sql);\n        rd = rs.getMetaData();\n    }\n\n    @Override\n    public boolean hasNext() {\n        boolean flag = false;\n        try {\n            flag = rs.next();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return flag;\n    }\n\n    @Override\n    public Object[] next() {\n        Map\u0026lt;String, String\u0026gt; data = new HashMap\u0026lt;String, String\u0026gt;();\n        try {\n            for (int i = 1; i \u0026lt;= rd.getColumnCount(); i++) {\n                data.put(rd.getColumnName(i), rs.getString(i));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        Object r[] = new Object[1];\n        r[0] = data;\n        return r;\n    }\n\n    @Override\n    public void remove() {\n        try {\n            rs.close();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"2-3-配置文件\"\u003e2.3 配置文件\u003c/h3\u003e\u003cp\u003e上面图中提到了“配置文件”，下面就来简单看一下这个XML配置文件的脚本：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt;\n\u0026lt;!DOCTYPE suite SYSTEM \u0026#34;http://testng.org/testng-1.0.dtd\u0026#34;\u0026gt;\n\u0026lt;suite name=\u0026#34;Pigeon Api测试\u0026#34; parallel=\u0026#34;false\u0026#34;\u0026gt;\n\n    \u0026lt;test name=\u0026#34;xxx-xxx-service\u0026#34;\u0026gt;\n        \u0026lt;parameter name=\u0026#34;sql\u0026#34;\n                   value=\u0026#34;SELECT * FROM API_PigeonCases \n                   WHERE team_id=2\n                   AND isRun=1\n                   AND service=\u0026#39;xxx-xxx-service\u0026#39;\n                   AND env=\u0026#39;beta\u0026#39;;\u0026#34;/\u0026gt;\n        \u0026lt;classes\u0026gt;\n            \u0026lt;class name=\u0026#34;com.dp.lego.test.TestPigeon\u0026#34;/\u0026gt;\n        \u0026lt;/classes\u0026gt;\n    \u0026lt;/test\u0026gt;\n\n    \u0026lt;listeners\u0026gt;\n        \u0026lt;listener class-name=\u0026#34;org.uncommons.reportng.HTMLReporter\u0026#34;/\u0026gt;\n        \u0026lt;listener class-name=\u0026#34;org.uncommons.reportng.JUnitXMLReporter\u0026#34;/\u0026gt;\n    \u0026lt;/listeners\u0026gt;\n\u0026lt;/suite\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/83fa07a9.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e对照上图来解释一下配置文件：\u003c/p\u003e\u003cul\u003e\u003cli\u003eSQL的话，这里的SQL主要决定了选取哪些测试用例进行测试。\u003c/li\u003e\u003cli\u003e一个\u003ctest\u003e标签，就代表一组测试，可以写多个\u003ctest\u003e标签。\u003c/test\u003e\u003c/test\u003e\u003c/li\u003e\u003cli\u003e“listener”是为了最后能够生成一个ReportNG的报告。\u003c/li\u003e\u003cli\u003eJenkins来实现每日构建，可以使用Maven插件，通过命令来选择需要执行的XML配置。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这样做有什么好处呢？\u003c/p\u003e\u003ch4 id=\"使用sql最大的好处就是灵活\"\u003e使用SQL最大的好处就是灵活\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f98de593.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如上面的这个例子，在数据库中会查询出下面这56条测试用例，那么这个\u003ctest\u003e标签就会对这56条用例进行逐一测试。\u003c/test\u003e\u003c/p\u003e\u003ch4 id=\"多-test-标签时-可以分组展示\"\u003e多\u003ccode\u003e\u0026lt;test\u0026gt;\u003c/code\u003e标签时，可以分组展示\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/df6b6862.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e使用多个\u003ccode\u003e\u0026lt;test\u0026gt;\u003c/code\u003e标签来区分用例，最大的好处就是也能在最后的报告上，达到一个分组展示的效果。\u003c/p\u003e\u003ch4 id=\"报告更美观丰富\"\u003e报告更美观丰富\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/78f931d4.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e由于使用了\u003ccode\u003eReportNG\u003c/code\u003e进行报告的打印，所以报告的展示要比TestNG自带的报告要更加美观、并且能自定义展示样式，点开能看到详细的执行过程。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/e682d094.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如果有执行失败的用例，通常报错的用例会在最上方优先展示。\u003c/p\u003e\u003ch4 id=\"支持多团队\"\u003e支持多团队\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/74d65c31.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当两个团队开始使用时，为了方便维护，将基础部分抽出，各个团队的脚本都依赖这个Base包，并且将Base包版本置为“SNAPSHOT版本”。使用“SNAPSHOT版本”的好处是，之后我对Lego更新，各个业务组并不需要对脚本做任何改动就能及时更新。\u003c/p\u003e\u003cp\u003e当更多的团队开始使用后，比较直观的看的话是这个样子的：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d2114989.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e每个团队的脚本都依赖于我的这个Base包，所以最后，各个业务团队的脚本就变成了下面的这个样子：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0477b30e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可以看到，使用了Lego之后：\u003c/p\u003e\u003cul\u003e\u003cli\u003e没有了Java文件，只有XML文件\u003c/li\u003e\u003cli\u003exml中只需要配置SQL。\u003c/li\u003e\u003cli\u003e执行和调试也很方便。\u003c/li\u003e\u003cli\u003e可以右键直接执行想要执行的测试配置。\u003c/li\u003e\u003cli\u003e可以使用maven命令执行测试：\u003cul\u003e\u003cli\u003e\u003ccode\u003emvn clean test -U -Dxml=xmlFileName\u003c/code\u003e 。\u003c/li\u003e\u003cli\u003e通过参数来选择需要执行的xml文件。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e也可以使用Jenkins来实现定时构建测试。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e由于，所有测试用例都在数据库所以这段脚本基本不需要改动了，减少了大量的脚本代码量。\u003c/p\u003e\u003cp\u003e有些同学要问，有时候编写一条接口测试用例不只是请求一下接口就行，可能还需要写一些数据库操作啊，一些参数可能还得自己写一些方法才能获取到啊之类的，那不code怎么处理呢？\u003c/p\u003e\u003cp\u003e下面就进入“用例设计”，我将介绍我如何通过统一的用例模板来解决这些问题。\u003c/p\u003e\u003ch2 id=\"三-用例设计\"\u003e三、用例设计\u003c/h2\u003e\u003ch3 id=\"3-1-一些思考\"\u003e3.1 一些思考\u003c/h3\u003e\u003cp\u003e我在做接口自动化设计的时候，会思考通用、校验、健壮、易用这几点。\u003c/p\u003e\u003ch4 id=\"通用\"\u003e通用\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e简单、方便\u003c/strong\u003e\u003cul\u003e\u003cli\u003e用例数据与脚本分离，简单、方便。\u003c/li\u003e\u003cli\u003e免去上传脚本的动作，能避免很多不必要的错误和维护时间。\u003c/li\u003e\u003cli\u003e便于维护。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e模板化\u003c/strong\u003e\u003cul\u003e\u003cli\u003e抽象出通用的模板，可快速拓展。\u003c/li\u003e\u003cli\u003e数据结构一致，便于批量操作。\u003c/li\u003e\u003cli\u003e专人维护、减少多团队间的重复开发工作。\u003c/li\u003e\u003cli\u003e由于使用了统一的模板，那各组之间便可交流、学习、做有效的对比分析。\u003c/li\u003e\u003cli\u003e如果以后这个平台不再使用，或者有更好的平台，可快速迁移。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e可统计、可拓展\u003c/strong\u003e\u003cul\u003e\u003cli\u003e可统计、可开发工具；如：用例数统计，某服务下有多少条用例等。\u003c/li\u003e\u003cli\u003e可开发用例维护工具。\u003c/li\u003e\u003cli\u003e可开发批量生成工具。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"校验\"\u003e校验\u003c/h4\u003e\u003cp\u003e在写自动化脚本的时候，都会想“细致”，然后“写很多”的检查点；但当“校验点”多的时候，又会因为很多原因造成执行失败。所以我们的设计，需要在保证充足的检查点的情况下，还要尽可能减少误报。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e充足的检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e可以检查出被测服务更多的缺陷。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e尽量少的误报\u003c/strong\u003e\u003cul\u003e\u003cli\u003e可以减少很多的人工检查和维护的时间人力成本。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e还要\u003c/strong\u003e\u003cul\u003e\u003cli\u003e简单、易读。\u003c/li\u003e\u003cli\u003e最好使用一些公式就能实现自己想要的验证。\u003c/li\u003e\u003cli\u003e通用、灵活、多样。\u003c/li\u003e\u003cli\u003e甚至可以用在其他项目的检查上，减少学习成本。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"健壮\"\u003e健壮\u003c/h4\u003e\u003cp\u003e执行测试的过程中，难免会报失败，执行失败可能的原因有很多，简单分为4类：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/c2e2a7e1.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e被测系统出错\u003c/strong\u003e，这部分其实是我们希望看到的，因为这说明我们的自动化测试真正地发现了一个Bug，用例发挥了它的价值，所以，这是我们希望看到的。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e测试工具出错\u003c/strong\u003e，这部分其实是我们不希望看到的，因为很大可能我们今天的自动化相当于白跑了。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e测试数据错误\u003c/strong\u003e，这是我们要避免的，既然数据容易失效，那我在设计测试平台的时候，就需要考虑如果将所有的数据跑“活”，而不是只写“死”。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e不可抗力\u003c/strong\u003e，这部分是我们也很无奈的，但是这样的情况很少发生。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e那针对上面的情况：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e参数数据失效\u003c/strong\u003e\u003cul\u003e\u003cli\u003e支持实时去数据库查询。\u003c/li\u003e\u003cli\u003e支持批量查。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eIP进场发生变更\u003c/strong\u003e\u003cul\u003e\u003cli\u003e自动更新IP。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e灵活、可复用\u003c/strong\u003e\u003cul\u003e\u003cli\u003e支持批量维护。\u003c/li\u003e\u003cli\u003e接口测试执行前生成一些数据。\u003c/li\u003e\u003cli\u003e接口执行完成后销毁一些数据。\u003c/li\u003e\u003cli\u003e支持参数使用另一条测试用例的返回结果。\u003c/li\u003e\u003cli\u003e支持一些请求参数实时生成，如token等数据，从而减少数据失效的问题。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e通过这些手段，提高测试用例的健壮性，让每一条自动化测试用例都能很好的完成测试任务，真正发挥出一条测试用例的价值。\u003c/p\u003e\u003ch4 id=\"易用\"\u003e易用\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e简单\u003c/strong\u003e\u003cul\u003e\u003cli\u003e功能强大，但要人人会用。\u003c/li\u003e\u003cli\u003e非技术人员也要会用。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e减少代码操作\u003c/strong\u003e\u003cul\u003e\u003cli\u003e让自动化开发人员注意力能更多的放在用例本身，而不是浪费在无关紧要的开发工作上面。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e还要\u003c/strong\u003e\u003cul\u003e\u003cli\u003e配置能复用。\u003c/li\u003e\u003cli\u003e通用、易学。\u003c/li\u003e\u003cli\u003e一些数据能自动生成。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"3-2-lego接口自动化测试用例\"\u003e3.2 Lego接口自动化测试用例\u003c/h3\u003e\u003cp\u003e说了这么多，那我们来看一下一条Lego接口测试用例的样子。\u003c/p\u003e\u003cp\u003e一条Lego自动用例执行顺序大概是如下图这样：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/51112400.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e简单区分一下各个部分，可以看到：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d759e33b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e那上面图中提到了两个名词：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e“参数化”\u003c/strong\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e“前后置动作”\u003c/strong\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e下面会先对这两个名词做一个简单的介绍。\u003c/p\u003e\u003ch3 id=\"3-3-参数化\"\u003e3.3 参数化\u003c/h3\u003e\u003cp\u003e比如一个请求需要用到的参数。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n\t\u0026#34;sync\u0026#34;: false,\n\t\u0026#34;cityId\u0026#34;: 1,\n\t\u0026#34;source\u0026#34;: 0,\n\t\u0026#34;userId\u0026#34;: 1234,\n\t\u0026#34;productId\u0026#34;: 00004321\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这个例子中有个参数\u003ccode\u003e\u0026#34;productId\u0026#34;: 00004321\u003c/code\u003e，而由于测试的环境中，表单00004321很可能一些状态已经发生了改变，甚至表单已经删除，导致接口请求的失败，那么这时候，就很适合对\u003ccode\u003e\u0026#34;productId\u0026#34;: 00004321\u003c/code\u003e进行参数化，比如写成这样：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n\t\u0026#34;sync\u0026#34;: false,\n\t\u0026#34;cityId\u0026#34;: 1,\n\t\u0026#34;source\u0026#34;: 0,\n\t\u0026#34;userId\u0026#34;: 1234,\n\t\u0026#34;productId\u0026#34;: ${myProductId}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e所以对\u003cstrong\u003e“参数化”\u003c/strong\u003e简单的理解就是：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e通过一些操作，将一个“值”替换掉测试用例里的一个“替代字符”\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003ccode\u003e${myProductId}\u003c/code\u003e 的值可以通过配置获取到：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eKey-Value\u003c/strong\u003e\u003cul\u003e\u003cli\u003e配置 Value=00004321。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSQL获取\u003c/strong\u003e\u003cul\u003e\u003cli\u003e执行一个select语句来实时查询得到可用ID。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e已有测试用例\u003c/strong\u003e\u003cul\u003e\u003cli\u003e某个接口接口测试用例的返回结果。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"参数化-实例\"\u003e“参数化”实例\u003c/h4\u003e\u003cp\u003e下面我们来看一个“参数化”的实例：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（1） 首先我们在参数化维护页面中新建一个参数化，\u003ccode\u003eshopdealid\u003c/code\u003e。\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/14806572.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过配置我们可以看到这个参数的值，是执行了一条SQL后，取用执行结果中\u003ccode\u003eDealID\u003c/code\u003e字段的值。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（2） 在用例中，将需要这个表单号的地方用${shopdealid}替代。\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/fbc1a615.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e那在编写测试用例的时候，大家可以看一下这个放大的图片，在这里的ProductID的值并不是硬代码一个固定的表单号，而是选择了刚才配置的参数化数据。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（3） 执行结果中，${shopdealid} 变为实时查询数据库的来的一个真实的表单号。\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ecbc7408.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从结果中可以看到，我们的这个参数被替换成了一个有效的值，而这个值就是我们刚刚配置的那个SQL实时查询而来的。\u003c/p\u003e\u003ch4 id=\"参数化-的场景\"\u003e“参数化”的场景\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e多个测试用例使用同一个参数进行测试\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如50条测试用例都使用同一个id作为参数进行测试，这时候我们需要变更这个id。\u003c/p\u003e\u003cp\u003e无参数化时：\u003c/p\u003e\u003cul\u003e\u003cli\u003e需要修改50次，即每条测试用例中的id都得进行修改。\u003c/li\u003e\u003cli\u003e可能会有遗漏。\n有参数化时：\u003c/li\u003e\u003cli\u003eID部分用 ${myID} 替代。\u003c/li\u003e\u003cli\u003e需要修改的话，在“参数化维护”页面中维护 ${myID}这条数据就可以。修改一次，所有使用${myID}的用例都配置完成。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e测试数据过期导致测试用例执行失败\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如一条用例参数需要传入Token，但是Token会因为时间问题而导致过期，这时候用例就失败了。\u003c/p\u003e\u003cp\u003e无参数化时：\u003c/p\u003e\u003cul\u003e\u003cli\u003e经常修改Token，或是写一段ID转Token的代码。\u003c/li\u003e\u003cli\u003e方法可能会重复编写。\u003c/li\u003e\u003cli\u003e多个团队之间可能实现方式也不同。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e有参数化时：\u003c/p\u003e\u003cul\u003e\u003cli\u003e使用参数化工具，Lego统一管理。\u003c/li\u003e\u003cli\u003e维护一个参数化 如：\u003ccode\u003e${测试用Token} = id:123\u003c/code\u003e。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e数据库获取有效测试数据\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e参数中需要传入DealId作为参数，写死参数的话，如果这个DealId被修改引起失效，那这条测试用例就会执行失败。\u003c/p\u003e\u003cp\u003e不使用Lego时：\u003c/p\u003e\u003cul\u003e\u003cli\u003e测试环境中，一个订单时常会因为测试需要被修改数据，导致单号失效，最后导致自动化失败。\u003c/li\u003e\u003cli\u003e编写相关代码来做好数据准备工作。\u003c/li\u003e\u003cli\u003e在代码中编写读取数据库的方法获取某些内容。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在Lego上的方案：\n- 使用参数化，实时获取sql结果，查询出一条符合条件的dealId来实现。\n- 使用参数化，调用写好的“生成订单”接口用例实现，拿单号来实现。\n- 前后置动作，插入一条满足条件的数据。\u003c/p\u003e\u003ch3 id=\"3-4-前后置动作\"\u003e3.4 前后置动作\u003c/h3\u003e\u003cp\u003e“前后置动作”的概念就比较好理解了：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e在接口请求之前（或之后），执行一些操作\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e目前前后置动作支持6种类型：\u003c/p\u003e\u003cul\u003e\u003cli\u003e数据库SQL执行\u003cul\u003e\u003cli\u003e有时候在执行接口请求前，为了保证数据可用，可能需要在数据库中插入或删除一条信息，这时候就可以使用前后置动作里的“执行SQL语句”类型，来编写在接口请求前（后）的 Insert 和 Delete 语句。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e已有测试用例执行\u003cul\u003e\u003cli\u003e比如当前测试用例的请求参数，需要使用另一条测试用例的返回结果，这时候就可以使用“执行测试用例”类型，写上Lego上某条测试用例的ID编号，就可以在当前用例接口请求前（后）执行这条测试用例。\u003c/li\u003e\u003cli\u003e前后置动作中测试用例的返回结果可以用于当前用例的参数，对测试用例返回结果内容的获取上，也支持JsonPath和正则表达式两种方式。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eMQ消息发送\u003cul\u003e\u003cli\u003e在接口请求前（后）发送MQ消息。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003eHTTP请求\u003c/li\u003e\u003cli\u003e等待时间\u003c/li\u003e\u003cli\u003e自定义的Java方法\u003cul\u003e\u003cli\u003e如果上面的方法还满足不了需求，还可以根据自己的需要，编写自己的Java方法。\u003c/li\u003e\u003cli\u003e可以在Lego-Kit项目中，编写自己需要的Java方法，选择“执行Java方法”，通过反射实现自定义Java方法的执行。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这里的SQL同时支持Select操作，这里其实也是做了一些小的设计，会将查询出来的全部的结果，放入到这个全局Map中。\u003c/p\u003e\u003cp\u003e比如查询一条SQL得到下表中的结果：\u003c/p\u003e\u003cp\u003eid | 　　　name　　　 | 　　　age　　　 | 　　　number　　　\n:–: | :–: | :–: | :–: | :–:\n0 | 张三 | 18 | 1122\n1 | 李四 | 30 | 3344\u003c/p\u003e\u003cp\u003e那我们可以使用下面左边的表达式，得到对应的结果：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e${pre.name}\u003c/code\u003e —- 得到 “张三”å\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.age}\u003c/code\u003e —- 得到 18\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.number}\u003c/code\u003e —- 得到 1122\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e也可以用：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e${pre.name[0]}\u003c/code\u003e —- 得到 “张三”\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.age[0]}\u003c/code\u003e —- 得到 18\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.number[0]}\u003c/code\u003e —- 得到 1122\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.name[1]}\u003c/code\u003e —- 得到 “李四”\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.age[1]}\u003c/code\u003e —- 得到 30\u003c/li\u003e\u003cli\u003e\u003ccode\u003e${pre.number[1]}\u003c/code\u003e —- 得到 3344\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这样的设计，更加帮助在用例设计时，提供数据准备的操作。\u003c/p\u003e\u003ch4 id=\"前后置动作-实例\"\u003e“前后置动作”实例\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e（1） 首先我们在前后置维护页面中新建一个动作，\u003ccode\u003e获取库存上限未卖光团单\u003c/code\u003e\u003c/strong\u003e 。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/e73ef128.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这个配置也是可以支持在线调试的，在调试中，可以看到可以使用的参数化：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/387a25d3.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（2） 在测试用例中的前置动作，添加\u003ccode\u003e获取库存上限未卖光团单\u003c/code\u003e\u003c/strong\u003e 。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/9978e340.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这样就可以在整个测试用例中，使用\u003ccode\u003e${pre.ProductID}\u003c/code\u003e，来替换掉原有的数据信息。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e（3） 最后请求接口，返回了执行成功\u003c/strong\u003e 。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d4f55351.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"q-a\"\u003eQ \u0026amp; A\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003eQ：那如果同样是获取三个参数，使用3个“参数化的Select操作”和使用1个“前置动作的Select操作”又有什么不同呢？\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA：\u003c/strong\u003e 不同在于执行时间上。\n比如，我们查询最新的有效团单的“单号”“下单人”和“手机号”三个字段。\n使用3个“参数化的Select操作”：可能当执行${单号}的时候得到的订单号是“10001”，但是当执行到${下单人}的时候，可能有谁又下了一单，可能取到的下单人变成了“10002”的“李四”而不是“10001”的“张三”了，最后可能“单号”“下单人”和“手机号”三个字段去的数据并非同一行的数据。\n而使用“前置动作的Select操作”：就可以避免上面的问题，因为所有字段的数据是一次性查询出来的，就不会出现错位的情况。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eQ : 那“参数化的Select操作”和“前置动作的Select操作”这样不同的取值时机又有什么好用之处呢？\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eA :\u003c/strong\u003e 由于“前置动作”一定是接口请求前执行，“参数化”一定是用到的时候才执行这样的特性。\n所以在检查点中，如果要验证一个数据库字段在经过接口调用后发生了变更，那使用“前置动作”和“参数化”同时去查询这个字段，然后进行比较，不一致就说明发生了变化。\n所以根据使用场景，选择合适的参数化方式，很重要，选择对了，能大大提升测试用例的测试数据健壮性。\u003c/p\u003e\u003ch3 id=\"3-5-执行各部分\"\u003e3.5 执行各部分\u003c/h3\u003e\u003cp\u003e回到一开始的流程图，可以按照一类一类来看执行过程。\u003c/p\u003e\u003ch4 id=\"测试发起\"\u003e测试发起\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/10efa223.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e测试发起基本还是使用的Jenkins，稳定、成熟、简单、公司工具组支持，也支持从Lego的Web页面进行执行操作。\u003c/p\u003e\u003ch4 id=\"数据-环境准备\"\u003e数据 / 环境准备\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5964f928.png\" alt=\"\"/\u003e\n使用 @DataProvider 的方式，从DB数据库中读取测试用例，逐一执行进行测试。\u003c/p\u003e\u003ch4 id=\"测试执行\"\u003e测试执行\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/e4e7c7b9.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在正式执行测试用例之前，会先进行一波参数替换的动作，在调用接口之后，还会执行一次参数替换动作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/500b15af.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e参数替换后会进行前置动作的执行，然后在调用接口之后还会执行测试后动作，最后执行后置动作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/61db10b8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e接口请求这部分就没什么好说的了，就是通过接口请求的参数，请求对应的接口，拿到返回结果。\u003c/p\u003e\u003cp\u003e这里的话是为了方便通用，所以要求返回的结果都是使用的String类型。这样做最大的好处就是。比如说我现在有一种新的接口类型需要接入。那只需要写一个方法能够请求到这个接口，并且拿到String类型的返回结果，就可以很快将新的接口类型接入Lego测试平台进行接口测试。\u003c/p\u003e\u003ch4 id=\"检查点校验\"\u003e检查点校验\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b739dbeb.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e检查点部分是一条自动化测试用例的精髓，一条自动化测试用例是否能真正的发挥它的测试功能，就是看QA对这条测试用例的检查点编写是否做了良好设计。在Lego平台上，目前我拥有的检查点有6种不同的类型。\u003c/p\u003e\u003cblockquote\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e异常检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e当返回结果为异常时，则会报错。\u003c/li\u003e\u003cli\u003e但是有时候为了做异常测试，可以将这个检查点关掉。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e不为空检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e顾名思义，当出现”“、”[]“、”{}“、null 这样的的结果，都会报错。也可以根据自己用例的实际情况关闭。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e包含检查点\u003c/strong\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e不包含检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e“包含”和“不包含”检查点是将接口的返回结果作为一个String类型来看，检查所有返回内容中是否“包含”或“不包含”指定的内容。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e数据库参数检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e顾名思义，不做过多的解释了。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eJsonPath检查点\u003c/strong\u003e\u003cul\u003e\u003cli\u003e这是我在Lego上设计的最具有特色的一种检查点类型。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003eJsonPath的基本写法是\u003c/strong\u003e：\u003cstrong\u003e\u003cem\u003e{JsonPath语法}==value\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eJsonPath的语法和XPath的语法差不多，都是根据路径的方法找值。这里也是主要是针对返回结果为JSON数据的结果，进行检查。\u003c/p\u003e\u003cp\u003e具体的JsonPath语法可以参考：\u003ca href=\"https://github.com/json-path/JsonPath\"\u003ehttps://github.com/json-path/JsonPath\u003c/a\u003e\u003c/p\u003e\u003cp\u003e说完了\u003cstrong\u003e“JsonPath的语法”\u003c/strong\u003e，现在说一下\u003cstrong\u003e“JsonPath检查点的语法”\u003c/strong\u003e，\u003cstrong\u003e“JsonPath检查点的语法”\u003c/strong\u003e是我自己想的，主要针对以下几种数据类型进行校验：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e(1) 字符串类型结果检验\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e等于：\u003ccode\u003e==\u003c/code\u003e\u003c/li\u003e\u003cli\u003e不等于：\u003ccode\u003e!==\u003c/code\u003e\u003c/li\u003e\u003cli\u003e包含：\u003ccode\u003e=\u003c/code\u003e\u003c/li\u003e\u003cli\u003e不包含：\u003ccode\u003e!=\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e{$.[1].name}==aa\u003c/code\u003e：检查返回的JSON中第2个JSON的name字段是否等于aa。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$..type}==\u0026#39;14\u0026#39;\u003c/code\u003e：检查返回的JSON中每一个JSON的name字段是否等于aa。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[1].type}==14 \u0026amp;\u0026amp; {$.[1].orderId}==106712\u003c/code\u003e：一条用例中多个检查用\u0026amp;\u0026amp;连接。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$..orderId}!==12\u003c/code\u003e：检查返回的JSON中每个JSON的orderId字段是否不等于12。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$..type}=1\u003c/code\u003e：检查返回的JSON中每个JSON的type字段是否包含1。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[1].type}!=chenyongda\u003c/code\u003e：检查返回的JSON中第2个JSON的type字段是否不包含chenyongda。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e(2) 数值校验\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e等于：\u003ccode\u003e=\u003c/code\u003e\u003c/li\u003e\u003cli\u003e大于：\u003ccode\u003e\u0026gt;\u003c/code\u003e\u003c/li\u003e\u003cli\u003e大于等于：\u003ccode\u003e\u0026gt;=\u003c/code\u003e\u003c/li\u003e\u003cli\u003e小于：\u003ccode\u003e\u0026lt;\u003c/code\u003e\u003c/li\u003e\u003cli\u003e小于等于：\u003ccode\u003e\u0026lt;=\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e{$.[0].value}\u0026lt;5：检查返回的JSON中第1个JSON的value字段的列表是否小于3。\u003c/li\u003e\u003cli\u003e{$.[1].value}\u0026gt;4：检查返回的JSON中第2个JSON的value字段的列表是否大于4。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e(3) List结果检验\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003elist长度：\u003ccode\u003e.length\u003c/code\u003e\u003c/li\u003e\u003cli\u003elist包含：\u003ccode\u003e.contains(param)\u003c/code\u003e\u003c/li\u003e\u003cli\u003elist成员：\u003ccode\u003e.get(index)\u003c/code\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e{$..value}.length=3\u003c/code\u003e：检查返回的JSON中每个JSON的value字段的列表是否等于3。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[0].value}.length\u0026lt;5\u003c/code\u003e：检查返回的JSON中第1个JSON的value字段的列表是否小于3。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[1].value}.length\u0026gt;4\u003c/code\u003e：检查返回的JSON中第2个JSON的value字段的列表是否大于4。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$..value}.contains(\u0026#39;222\u0026#39;)\u003c/code\u003e：检查返回的JSON中每个JSON的value字段的列表是否包含222字符串。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[0].value}.contains(1426867200000)\u003c/code\u003e：检查返回的JSON中第1个JSON的value字段的列表是否包含1426867200000。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$.[0].value}.get(0)==\u0026#39;222\u0026#39;\u003c/code\u003e：检查返回的JSON中第1个JSON的value字段的列表中第1个内容是否等于222。\u003c/li\u003e\u003cli\u003e\u003ccode\u003e{$..value}.get(2)=\u0026#39;22\u0026#39;\u003c/code\u003e：检查返回的JSON中每个JSON的value字段的列表中第3个内容是否包含22。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e(4) 时间类型处理\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e时间戳转日期时间字符串：\u003ccode\u003e.todate\u003c/code\u003e\u003c/p\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003e{$..beginDate}.todate==2015-12-31 23:59:59\u003c/code\u003e：检查返回的JSON中beginDate这个时间戳转换成日期后是否等于2015-12-31 23:59:59。\u003c/li\u003e\u003c/ul\u003e\u003ch5 id=\"当jsonpath返回的结果是列表的形式时\"\u003e当JsonPath返回的结果是列表的形式时\u003c/h5\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003e检查点\u003c/th\u003e\u003cth align=\"center\"\u003e检查点等号左边\u003c/th\u003e\u003cth align=\"center\"\u003e期望值\u003c/th\u003e\u003cth align=\"left\"\u003e验证效果\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e{$.value}==“good”\u003c/td\u003e\u003ctd align=\"center\"\u003e[‘good’, ‘good’, ‘bad’, ‘good’]\u003c/td\u003e\u003ctd align=\"center\"\u003e“good”\u003c/td\u003e\u003ctd align=\"left\"\u003e作为4个检查点，会拿列表里的每个对象逐一和“期望值”进行检验，每一次对比都是一个独立的检查点。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e{$.value}==[“good”]\u003c/td\u003e\u003ctd align=\"center\"\u003e[‘good’, ‘good’, ‘bad’, ‘good’]\u003c/td\u003e\u003ctd align=\"center\"\u003e[“good”]\u003c/td\u003e\u003ctd align=\"left\"\u003e作为1个检查点，作为一个整体做全量比对。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003e{$.value}==[‘a’, ‘b’]\u003c/td\u003e\u003ctd align=\"center\"\u003e[[‘a’, ‘b’],[‘a’, ‘b’],[‘a’, ‘b’, ‘c’]]\u003c/td\u003e\u003ctd align=\"center\"\u003e[‘a’, ‘b’]\u003c/td\u003e\u003ctd align=\"left\"\u003e作为3个检查点，道理和1一样，列表中的数据分别和期望值做比较。\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch5 id=\"除此之外-还有非常多的花样玩法\"\u003e除此之外，还有非常多的花样玩法\u003c/h5\u003e\u003cp\u003eJsonPath中的检查支持“参数化”和“前后置动作”，所以会看到很多如：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e\u003cem\u003e{$.param}=‘${param}’ \u0026amp;\u0026amp; {$.param}==${pre.param}\u003c/em\u003e\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e这样的检查点：\u003c/p\u003e\u003cp\u003e“参数化”和“前后置动作”也支持递归配置，这些都是为了能够让接口自动化测试用例写的更加灵活好用。\u003c/p\u003e\u003ch4 id=\"测试结果\"\u003e测试结果\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b9922ecb.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e使用ReportNG可以打印出很漂亮的报告。\u003c/p\u003e\u003cp\u003e报告会自定义一些高亮等展示方式，只需要在ReportNG使用前加上下面的语句，就可以支持“输出逃逸”，可使用HTML标签自定义输出样式。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eSystem.setProperty(\u0026#34;org.uncommons.reportng.escape-output\u0026#34;, \u0026#34;false\u0026#34;);\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"后期优化\"\u003e后期优化\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/74a02a58.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当使用Jenkins执行后，通过Jenkins API 、和Base包中的一些方法，定时获取测试结果，落数据库，提供生成统计图表用。\u003c/p\u003e\u003ch2 id=\"四-网站功能\"\u003e四、网站功能\u003c/h2\u003e\u003ch3 id=\"4-1-站点开发\"\u003e4.1 站点开发\u003c/h3\u003e\u003cp\u003e既然打算做工具平台了，就得设计方方面面，可惜人手和时间上的不足，只能我一人利用下班时间进行开发。也算是担任了Lego平台的产品、后端开发、前端开发、运维和测试等各种角色。\u003c/p\u003e\u003cp\u003eJenkins+TestNG+ReportNG+我自己开发的基本接口自动化测试Base jar包，基本上没什么太大难度。但是站点这块，在来美团之前，还真没开发过这样的工具平台，这个算是我的第一个带Web界面的工具。边Google边做，没想到不久还真的架起来了一个简易版本。\u003c/p\u003e\u003cp\u003e使用 Servlet + Jsp 进行开发，前端框架使用Bootstrap，前端数据使用jstl，数据库使用MySQL，服务器使用的公司的一台Beta环境Docker虚拟机，域名是申请的公司内网域名，并开通北京上海两侧内网访问权限。\u003c/p\u003e\u003cp\u003e功能上基本都是要满足的，界面上，虽然做不到惊艳吧，但是绝对不能丑，功能满足，但是长得一副80年代的界面，我自己都会嫌弃去使用它，所以界面上我还是花了一些时间去调整和设计。熟练以后就快多了。\u003c/p\u003e\u003ch3 id=\"4-2-整体组成\"\u003e4.2 整体组成\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7749a457.jpeg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e目前Lego由五个不同的项目组成，分别是“测试脚本”、“Lego-web页面项目”、“用于执行接口测试的base包”、“小工具集合Lego-kit”和“lego-job”，通过上图可以看出各项目间的依赖关系。\u003c/p\u003e\u003cp\u003e细化各个项目的功能，就是下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0c70d00a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e简单来说，网站部分和脚本是分离的，中间的纽带是数据库。所以，没有网站，脚本执行一点问题也没有；同样的，网站的操作，和脚本也没有关系。\u003c/p\u003e\u003ch3 id=\"4-3-使用-日常维护\"\u003e4.3 使用-日常维护\u003c/h3\u003e\u003ch4 id=\"step-1\"\u003eStep 1\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0eb1279b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e每天上班来会收到这样的测试邮件，通过邮件能知道昨晚执行的情况。如果有报错，可以点击“详细报告链接”，跳转到在线报告。\u003c/p\u003e\u003ch4 id=\"step-2\"\u003eStep 2\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/edcccc42.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在现报告可以直接看到执行报错的信息，然后点击“LEGO维护传送门”，可以跳转到Lego站点上，进行用例维护。\u003c/p\u003e\u003ch4 id=\"step-3\"\u003eStep 3\u003c/h4\u003e\u003cp\u003e跳转到站点上以后，可以直接展示出该条测试用例的所有信息。定位，维护、保存，维护用例，可以点击“执行”查看维护后的执行结果，维护好后“保存”即可。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e仅仅3步，1~2分钟即可完成对一条执行失败的用例进行定位、调试和维护动作。\u003c/strong\u003e\u003c/p\u003e\u003ch3 id=\"4-4-用例编辑\"\u003e4.4 用例编辑\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d83f6afb.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过页面，我们就可以对一条测试用例进行：\u003c/p\u003e\u003cul\u003e\u003cli\u003e新建\u003c/li\u003e\u003cli\u003e复制\u003c/li\u003e\u003cli\u003e编辑\u003c/li\u003e\u003cli\u003e删除\u003c/li\u003e\u003cli\u003e是否放入每日构建中进行测试\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"4-5-在线调试\"\u003e4.5 在线调试\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/657ac5e6.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003elego-web项目同样的使用base进行的用例执行，所以执行结果和打印都与脚本执行的一致的。\u003c/p\u003e\u003ch3 id=\"4-6-用例生成工具\"\u003e4.6 用例生成工具\u003c/h3\u003e\u003cp\u003e为了更方便的写用例，针对部分接口开发了一键批量生成用例的小工具。\u003c/p\u003e\u003ch3 id=\"4-7-执行结果分析\"\u003e4.7 执行结果分析\u003c/h3\u003e\u003cp\u003e通过Jenkins接口、Base包中基础Test方法，将结果收集到数据库，便于各组对测试结果进行分析。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6e6a50fb.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这是每天执行后成功率走势图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cfb46622.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e也可以按月进行统计，生成统计的图表，帮助各个团队进行月报数据收集和统计。\u003c/p\u003e\u003ch3 id=\"4-8-失败原因跟踪\"\u003e4.8 失败原因跟踪\u003c/h3\u003e\u003cp\u003e有了能直观看到测试结果的图表，就会想要跟踪失败原因。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/8c45cda8.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e所以在成功率数据的右边，会有这样的跟踪失败原因的入口，也可以很直观地看到哪一些失败的原因还没有被跟踪。点开后可以对失败原因进行记录。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/2b795136.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e最后会有生成图表，可以很清晰地看到失败原因以及失败类型的占比。\u003c/p\u003e\u003ch3 id=\"4-9-代码覆盖率分析\"\u003e4.9 代码覆盖率分析\u003c/h3\u003e\u003cp\u003e结合Jacoco，我们可以对接口自动化的代码覆盖率进行分析。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/2b36b8c6.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在多台Slave机器上配置Jacoco还是比较复杂的，所以可以开发覆盖率配置辅助工具来帮助测试同学，提高效率。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cbb1f404.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"4-10-用例优化方向\"\u003e4.10 用例优化方向\u003c/h3\u003e\u003cp\u003e除了上面的图表，还会给用例优化提供方向。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/949fdb05.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过用例数量统计的图表，我们可以知道哪些服务用例还比较少，哪些环境的用例还比较少，可以比较有针对性的进行测试用例的补充。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/1895ab49.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过失败原因的图表，我们可以改善自己用例中的“参数化”和“前后置动作”的使用，增加测试用例的健壮性。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/bbe85d4a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过线上接口调用量排序的图表。我们可以有效的知道优先维护哪些服务的测试用例，通过表格中，我们可以看到，哪些服务已经覆盖了测试用例，哪些没有被覆盖， 给各组的QA制定用例开发计划，提供参考。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a8ed42f6.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e同时在维护接口自动化测试的时候，都会看到用例评分的情况，来协助QA提高用例编写的质量。\u003c/p\u003e\u003ch3 id=\"4-11-收集反馈-学习\"\u003e4.11 收集反馈/学习\u003c/h3\u003e\u003cp\u003e还做了“需求白板”，用来收集使用者的需求和Bug。除此之外，Lego平台已经不只是一个接口测试的平台，还可以让想学习开发的QA领任务，学习一些开发技巧，提高自己的代码能力。\u003c/p\u003e\u003ch2 id=\"五-总结\"\u003e五、总结\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e为了减少开发成本\u003c/strong\u003e，使用比较常见的Jenkins+TestNG的脚本形式。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了简化code操作\u003c/strong\u003e，使用DB进行测试用例存储，并抽象出用例摸版。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了减低新建用例成本\u003c/strong\u003e，开发“用例维护页面”和“一键生成”等工具。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了减低维护成本\u003c/strong\u003e，加跳转链接，维护一条用例成本在几分钟内。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了增加用例健壮性\u003c/strong\u003e，设计了“参数化”、“前后置动作”等灵活的参数替换。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了易用和兼容\u003c/strong\u003e，统一“返回结果”类型，统一“检查点”的使用。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了接口自动化用例设计提供方向\u003c/strong\u003e，结合Jacoco做代码覆盖率统计，并开发相关配置工具\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了便于分析数据\u003c/strong\u003e，从DOM、CAT、Jenkins上爬各种数据，在页面上用图表展示。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e为了优化用例\u003c/strong\u003e，提供“用例打分”、“线上调用量排行”等数据进行辅助。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/432c0f0f.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e本文介绍了我们的接口自动化测试平台Lego，欢迎感兴趣的同学扫描“美团技术团队”微信二维码，通过后台交流讨论。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-01-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}