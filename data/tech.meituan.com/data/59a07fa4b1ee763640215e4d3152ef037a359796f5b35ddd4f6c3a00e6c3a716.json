{
  "Source": "tech.meituan.com",
  "Title": "红黑树深入剖析及Java实现",
  "Link": "https://tech.meituan.com/2016/12/02/redblack-tree.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e红黑树是平衡二叉查找树的一种。为了深入理解红黑树，我们需要从二叉查找树开始讲起。\u003c/p\u003e\u003ch2 id=\"bst\"\u003eBST\u003c/h2\u003e\u003cp\u003e二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。\u003c/p\u003e\u003cp\u003e在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/af3502319d2a56536b54a02f973a7534112150.png@1078w_600h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"bst的查找操作\"\u003eBST的查找操作\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003eT  key = a search key\nNode root = point to the root of a BST\n\nwhile(true){\n    if(root==null){\n    \tbreak;\n    }\n    if(root.value.equals(key)){\n    \treturn root;\n    }\n    else if(key.compareTo(root.value)\u0026lt;0){\n    \troot = root.left;\n    }\n    else{\n    \troot = root.right;\n    }\n}\nreturn null;\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从程序中可以看出，当BST查找的时候，先与当前节点进行比较：\u003c/p\u003e\u003cul\u003e\u003cli\u003e如果相等的话就返回当前节点。\u003c/li\u003e\u003cli\u003e如果少于当前节点则继续查找当前节点的左节点。\u003c/li\u003e\u003cli\u003e如果大于当前节点则继续查找当前节点的右节点。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e直到当前节点指针为空或者查找到对应的节点，程序查找结束。\u003c/p\u003e\u003ch3 id=\"bst的插入操作\"\u003eBST的插入操作\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003eNode node = create a new node with specify value\nNode root = point the root node of a BST\nNode parent = null;\n\n//find the parent node to append the new node\nwhile(true){\n   if(root==null)break;\n   parent = root;\n   if(node.value.compareTo(root.value)\u0026lt;=0){\n      root = root.left;  \n   }else{\n      root = root.right;\n   } \n}\nif(parent!=null){\n   if(node.value.compareTo(parent.value)\u0026lt;=0){//append to left\n      parent.left = node;\n   }else{//append to right\n\t  parent.right = node;\n   }\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e插入操作先通过循环查找到待插入的节点的父节点，和查找父节点的逻辑一样，都是比大小，小的往左，大的往右。找到父节点后，对比父节点，小的就插入到父节点的左节点，大就插入到父节点的右节点上。\u003c/p\u003e\u003ch3 id=\"bst的删除操作\"\u003eBST的删除操作\u003c/h3\u003e\u003cp\u003e删除操作的步骤如下：\u003c/p\u003e\u003col\u003e\u003cli\u003e查找到要删除的节点。\u003c/li\u003e\u003cli\u003e如果待删除的节点是叶子节点，则直接删除。\u003c/li\u003e\u003cli\u003e如果待删除的节点不是叶子节点，则先找到待删除节点的中序遍历的后继节点，用该后继节点的值替换待删除的节点的值，然后删除后继节点。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/adf35d4ba9207ade1ddd80d0f2ab11b598210.png@676w_322h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"bst存在的问题\"\u003eBST存在的问题\u003c/h3\u003e\u003cp\u003eBST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。\u003c/p\u003e\u003ch2 id=\"rbtree\"\u003eRBTree\u003c/h2\u003e\u003cp\u003e基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。\u003c/p\u003e\u003cp\u003e红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。\u003c/p\u003e\u003cp\u003eRBTree也是函数式语言中最常用的持久数据结构之一，在计算几何中也有重要作用。值得一提的是，Java 8中HashMap的实现也因为用RBTree取代链表，性能有所提升。\u003c/p\u003e\u003ch3 id=\"rbtree的定义\"\u003eRBTree的定义\u003c/h3\u003e\u003cp\u003eRBTree的定义如下:\u003c/p\u003e\u003col\u003e\u003cli\u003e任何一个节点都有颜色，黑色或者红色。\u003c/li\u003e\u003cli\u003e根节点是黑色的。\u003c/li\u003e\u003cli\u003e父子节点之间不能出现两个连续的红节点。\u003c/li\u003e\u003cli\u003e任何一个节点向下遍历到其子孙的叶子节点，所经过的黑节点个数必须相等。\u003c/li\u003e\u003cli\u003e空节点被认为是黑色的。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e数据结构表示如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass  Node\u0026lt;T\u0026gt;{\n   public  T value;\n   public   Node\u0026lt;T\u0026gt; parent;\n   public   boolean isRed;\n   public   Node\u0026lt;T\u0026gt; left;\n   public   Node\u0026lt;T\u0026gt; right;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRBTree在理论上还是一棵BST树，但是它在对BST的插入和删除操作时会维持树的平衡，即保证树的高度在[logN,logN+1]（理论上，极端的情况下可以出现RBTree的高度达到2*logN，但实际上很难遇到）。这样RBTree的查找时间复杂度始终保持在O(logN)从而接近于理想的BST。RBTree的删除和插入操作的时间复杂度也是O(logN)。RBTree的查找操作就是BST的查找操作。\u003c/p\u003e\u003ch3 id=\"rbtree的旋转操作\"\u003eRBTree的旋转操作\u003c/h3\u003e\u003cp\u003e旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到平衡。\nRotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/45dbcbcdfd1a99f1d01b3ae7b013cf7978526.png@697w_242h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"rbtree的查找操作\"\u003eRBTree的查找操作\u003c/h3\u003e\u003cp\u003eRBTree的查找操作和BST的查找操作是一样的。请参考BST的查找操作代码。\u003c/p\u003e\u003ch3 id=\"rbtree的插入操作\"\u003eRBTree的插入操作\u003c/h3\u003e\u003cp\u003eRBTree的插入与BST的插入方式是一致的，只不过是在插入过后，可能会导致树的不平衡，这时就需要对树进行旋转操作和颜色修复（在这里简称插入修复），使得它符合RBTree的定义。\u003c/p\u003e\u003cp\u003e新插入的节点是红色的，插入修复操作如果遇到父节点的颜色为黑则修复操作结束。也就是说，只有在父节点为红色节点的时候是需要插入修复操作的。\u003c/p\u003e\u003cp\u003e插入修复操作分为以下的三种情况，而且新插入的节点的父节点都是红色的：\u003c/p\u003e\u003col\u003e\u003cli\u003e叔叔节点也为红色。\u003c/li\u003e\u003cli\u003e叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上。\u003c/li\u003e\u003cli\u003e叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"插入操作-case-1\"\u003e插入操作-Case 1\u003c/h4\u003e\u003cp\u003ecase 1的操作是将父节点和叔叔节点与祖父节点的颜色互换，这样就符合了RBTRee的定义。即维持了高度的平衡，修复后颜色也符合RBTree定义的第三条和第四条。下图中，操作完成后A节点变成了新的节点。如果A节点的父节点不是黑色的话，则继续做修复操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/451fe5109f421fc6bd912e26fc584d0c83808.png@694w_298h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"插入操作-case-2\"\u003e插入操作-Case 2\u003c/h4\u003e\u003cp\u003ecase 2的操作是将B节点进行右旋操作，并且和父节点A互换颜色。通过该修复操作RBTRee的高度和颜色都符合红黑树的定义。如果B和C节点都是右节点的话，只要将操作变成左旋就可以了。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/d2004602c4b11c5207eae1ddcc013b2e43177.png@576w_237h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"插入操作-case-3\"\u003e插入操作-Case 3\u003c/h4\u003e\u003cp\u003ecase 3的操作是将C节点进行左旋，这样就从case 3转换成case 2了，然后针对case 2进行操作处理就行了。case 2操作做了一个右旋操作和颜色互换来达到目的。如果树的结构是下图的镜像结构，则只需要将对应的左旋变成右旋，右旋变成左旋即可。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/977048855e80f64b4bd72ed77a216dd643825.png@609w_261h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"插入操作的总结\"\u003e插入操作的总结\u003c/h4\u003e\u003cp\u003e插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。之所以会向上回溯是由于case 1操作会将父节点，叔叔节点和祖父节点进行换颜色，有可能会导致祖父节点不平衡(红黑树定义3)。这个时候需要对祖父节点为起点进行调节（向上回溯）。\u003c/p\u003e\u003cp\u003e祖父节点调节后如果还是遇到它的祖父颜色问题，操作就会继续向上回溯，直到root节点为止，根据定义root节点永远是黑色的。在向上的追溯的过程中，针对插入的3中情况进行调节。直到符合红黑树的定义为止。直到牵涉的节点都符合了红黑树的定义，修复操作结束。\u003c/p\u003e\u003cp\u003e如果上面的3中情况如果对应的操作是在右子树上，做对应的镜像操作就是了。\u003c/p\u003e\u003ch3 id=\"rbtree的删除操作\"\u003eRBTree的删除操作\u003c/h3\u003e\u003cp\u003e删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使的树符合红黑树的定义，符合定义的红黑树高度是平衡的。\u003c/p\u003e\u003cp\u003e删除修复操作在遇到被删除的节点是红色节点或者到达root节点时，修复操作完毕。\u003c/p\u003e\u003cp\u003e删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点上借调黑色的节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点数减去一个，使得整棵树符合红黑树的定义。\u003c/p\u003e\u003cp\u003e删除操作的总体思想是从兄弟节点借调黑色节点使树保持局部的平衡，如果局部的平衡达到了，就看整体的树是否是平衡的，如果不平衡就接着向上追溯调整。\u003c/p\u003e\u003cp\u003e删除修复操作分为四种情况(删除黑节点后)：\u003c/p\u003e\u003col\u003e\u003cli\u003e待删除的节点的兄弟节点是红色的节点。\u003c/li\u003e\u003cli\u003e待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。\u003c/li\u003e\u003cli\u003e待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。\u003c/li\u003e\u003cli\u003e待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"删除操作-case-1\"\u003e删除操作-Case 1\u003c/h4\u003e\u003cp\u003e由于兄弟节点是红色节点的时候，无法借调黑节点，所以需要将兄弟节点提升到父节点，由于兄弟节点是红色的，根据RBTree的定义，兄弟节点的子节点是黑色的，就可以从它的子节点借调了。\u003c/p\u003e\u003cp\u003ecase 1这样转换之后就会变成后面的case 2，case 3，或者case 4进行处理了。上升操作需要对C做一个左旋操作，如果是镜像结构的树只需要做对应的右旋操作即可。\u003c/p\u003e\u003cp\u003e之所以要做case 1操作是因为兄弟节点是红色的，无法借到一个黑节点来填补删除的黑节点。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/e32688e1ea6037abc1bd8afd645e3445115445.png@678w_310h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"删除操作-case-2\"\u003e删除操作-Case 2\u003c/h4\u003e\u003cp\u003ecase 2的删除操作是由于兄弟节点可以消除一个黑色节点，因为兄弟节点和兄弟节点的子节点都是黑色的，所以可以将兄弟节点变红，这样就可以保证树的局部的颜色符合定义了。这个时候需要将父节点A变成新的节点，继续向上调整，直到整颗树的颜色符合RBTree的定义为止。\u003c/p\u003e\u003cp\u003ecase 2这种情况下之所以要将兄弟节点变红，是因为如果把兄弟节点借调过来，会导致兄弟的结构不符合RBTree的定义，这样的情况下只能是将兄弟节点也变成红色来达到颜色的平衡。当将兄弟节点也变红之后，达到了局部的平衡了，但是对于祖父节点来说是不符合定义4的。这样就需要回溯到父节点，接着进行修复操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/fb9253d7058ce873fbd1b3d763890a0461392.png@603w_264h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"删除操作-case-3\"\u003e删除操作-Case 3\u003c/h4\u003e\u003cp\u003ecase 3的删除操作是一个中间步骤，它的目的是将左边的红色节点借调过来，这样就可以转换成case 4状态了，在case 4状态下可以将D，E节点都阶段过来，通过将两个节点变成黑色来保证红黑树的整体平衡。\u003c/p\u003e\u003cp\u003e之所以说case-3是一个中间状态，是因为根据红黑树的定义来说，下图并不是平衡的，他是通过case 2操作完后向上回溯出现的状态。之所以会出现case 3和后面的case 4的情况，是因为可以通过借用侄子节点的红色，变成黑色来符合红黑树定义4。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/da32679182d266aa49dffbfcc80a0ca581532.png@660w_327h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"删除操作-case-4\"\u003e删除操作-Case 4\u003c/h4\u003e\u003cp\u003eCase 4的操作是真正的节点借调操作，通过将兄弟节点以及兄弟节点的右节点借调过来，并将兄弟节点的右子节点变成红色来达到借调两个黑节点的目的，这样的话，整棵树还是符合RBTree的定义的。\u003c/p\u003e\u003cp\u003eCase 4这种情况的发生只有在待删除的节点的兄弟节点为黑，且子节点不全部为黑，才有可能借调到两个节点来做黑节点使用，从而保持整棵树都符合红黑树的定义。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/784a3e4fbec3858066d898d3c9839508104293.png@695w_364h_80q\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"删除操作的总结\"\u003e删除操作的总结\u003c/h4\u003e\u003cp\u003e红黑树的删除操作是最复杂的操作，复杂的地方就在于当删除了黑色节点的时候，如何从兄弟节点去借调节点，以保证树的颜色符合定义。由于红色的兄弟节点是没法借调出黑节点的，这样只能通过选择操作让他上升到父节点，而由于它是红节点，所以它的子节点就是黑的，可以借调。\u003c/p\u003e\u003cp\u003e对于兄弟节点是黑色节点的可以分成3种情况来处理，当所以的兄弟节点的子节点都是黑色节点时，可以直接将兄弟节点变红，这样局部的红黑树颜色是符合定义的。但是整颗树不一定是符合红黑树定义的，需要往上追溯继续调整。\u003c/p\u003e\u003cp\u003e对于兄弟节点的子节点为左红右黑或者 (全部为红，右红左黑)这两种情况，可以先将前面的情况通过选择转换为后一种情况，在后一种情况下，因为兄弟节点为黑，兄弟节点的右节点为红，可以借调出两个节点出来做黑节点，这样就可以保证删除了黑节点，整棵树还是符合红黑树的定义的，因为黑色节点的个数没有改变。\u003c/p\u003e\u003cp\u003e红黑树的删除操作是遇到删除的节点为红色，或者追溯调整到了root节点，这时删除的修复操作完毕。\u003c/p\u003e\u003ch3 id=\"rbtree的java实现\"\u003eRBTree的Java实现\u003c/h3\u003e\u003cpre\u003e\u003ccode\u003epublic class RBTreeNode\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; {\n\tprivate T value;//node value\n\tprivate RBTreeNode\u0026lt;T\u0026gt; left;//left child pointer\n\tprivate RBTreeNode\u0026lt;T\u0026gt; right;//right child pointer\n\tprivate RBTreeNode\u0026lt;T\u0026gt; parent;//parent pointer\n\tprivate boolean red;//color is red or not red\n\t\n\tpublic RBTreeNode(){}\n\tpublic RBTreeNode(T value){this.value=value;}\n\tpublic RBTreeNode(T value,boolean isRed){this.value=value;this.red = isRed;}\n\t\n\tpublic T getValue() {\n\t\treturn value;\n\t}\n\tvoid setValue(T value) {\n\t\tthis.value = value;\n\t}\n\tRBTreeNode\u0026lt;T\u0026gt; getLeft() {\n\t\treturn left;\n\t}\n\tvoid setLeft(RBTreeNode\u0026lt;T\u0026gt; left) {\n\t\tthis.left = left;\n\t}\n\tRBTreeNode\u0026lt;T\u0026gt; getRight() {\n\t\treturn right;\n\t}\n\tvoid setRight(RBTreeNode\u0026lt;T\u0026gt; right) {\n\t\tthis.right = right;\n\t}\n\tRBTreeNode\u0026lt;T\u0026gt; getParent() {\n\t\treturn parent;\n\t}\n\tvoid setParent(RBTreeNode\u0026lt;T\u0026gt; parent) {\n\t\tthis.parent = parent;\n\t}\n\tboolean isRed() {\n\t\treturn red;\n\t}\n\tboolean isBlack(){\n\t\treturn !red;\n\t}\n\t/**\n\t* is leaf node\n\t**/\n\tboolean isLeaf(){\n\t\treturn left==null \u0026amp;\u0026amp; right==null;\n\t}\n\t\n\tvoid setRed(boolean red) {\n\t\tthis.red = red;\n\t}\n\t\n\tvoid makeRed(){\n\t\tred=true;\n\t}\n\tvoid makeBlack(){\n\t\tred=false;\n\t}\n\t@Override\n\tpublic String toString(){\n\t\treturn value.toString();\n\t}\n}\n\n\n\n\npublic class RBTree\u0026lt;T extends Comparable\u0026lt;T\u0026gt;\u0026gt; {\n\tprivate final RBTreeNode\u0026lt;T\u0026gt; root;\n\t//node number\n\tprivate java.util.concurrent.atomic.AtomicLong size = \n\t\t\t\t\tnew java.util.concurrent.atomic.AtomicLong(0);\n\t\n\t//in overwrite mode,all node\u0026#39;s value can not  has same\tvalue\n\t//in non-overwrite mode,node can have same value, suggest don\u0026#39;t use non-overwrite mode.\n\tprivate volatile boolean overrideMode=true;\n\t\n\tpublic RBTree(){\n\t\tthis.root = new RBTreeNode\u0026lt;T\u0026gt;();\n\t}\n\t\n\tpublic RBTree(boolean overrideMode){\n\t\tthis();\n\t\tthis.overrideMode=overrideMode;\n\t}\n\t\n\t\n\tpublic boolean isOverrideMode() {\n\t\treturn overrideMode;\n\t}\n\n\tpublic void setOverrideMode(boolean overrideMode) {\n\t\tthis.overrideMode = overrideMode;\n\t}\n\n\t/**\n\t * number of tree number\n\t * @return\n\t */\n\tpublic long getSize() {\n\t\treturn size.get();\n\t}\n\t/**\n\t * get the root node\n\t * @return\n\t */\n\tprivate RBTreeNode\u0026lt;T\u0026gt; getRoot(){\n\t\treturn root.getLeft();\n\t}\n\t\n\t/**\n\t * add value to a new node,if this value exist in this tree,\n\t * if value exist,it will return the exist value.otherwise return null\n\t * if override mode is true,if value exist in the tree,\n\t * it will override the old value in the tree\n\t * \n\t * @param value\n\t * @return\n\t */\n\tpublic T addNode(T value){\n\t\tRBTreeNode\u0026lt;T\u0026gt; t = new RBTreeNode\u0026lt;T\u0026gt;(value);\n\t\treturn addNode(t);\n\t}\n\t/**\n\t * find the value by give value(include key,key used for search,\n\t * other field is not used,@see compare method).if this value not exist return null\n\t * @param value\n\t * @return\n\t */\n\tpublic T find(T value){\n\t\tRBTreeNode\u0026lt;T\u0026gt; dataRoot = getRoot();\n\t\twhile(dataRoot!=null){\n\t\t\tint cmp = dataRoot.getValue().compareTo(value);\n\t\t\tif(cmp\u0026lt;0){\n\t\t\t\tdataRoot = dataRoot.getRight();\n\t\t\t}else if(cmp\u0026gt;0){\n\t\t\t\tdataRoot = dataRoot.getLeft();\n\t\t\t}else{\n\t\t\t\treturn dataRoot.getValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * remove the node by give value,if this value not exists in tree return null\n\t * @param value include search key\n\t * @return the value contain in the removed node\n\t */\n\tpublic T remove(T value){\n\t\tRBTreeNode\u0026lt;T\u0026gt; dataRoot = getRoot();\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = root;\n\t\t\n\t\twhile(dataRoot!=null){\n\t\t\tint cmp = dataRoot.getValue().compareTo(value);\n\t\t\tif(cmp\u0026lt;0){\n\t\t\t\tparent = dataRoot;\n\t\t\t\tdataRoot = dataRoot.getRight();\n\t\t\t}else if(cmp\u0026gt;0){\n\t\t\t\tparent = dataRoot;\n\t\t\t\tdataRoot = dataRoot.getLeft();\n\t\t\t}else{\n\t\t\t\tif(dataRoot.getRight()!=null){\n\t\t\t\t\tRBTreeNode\u0026lt;T\u0026gt; min = removeMin(dataRoot.getRight());\n\t\t\t\t\t//x used for fix color balance\n\t\t\t\t\tRBTreeNode\u0026lt;T\u0026gt; x = min.getRight()==null ? min.getParent() : min.getRight();\n\t\t\t\t\tboolean isParent = min.getRight()==null;\n\t\t\t\t\t\t\t\n\t\t\t\t\tmin.setLeft(dataRoot.getLeft());\n\t\t\t\t\tsetParent(dataRoot.getLeft(),min);\n\t\t\t\t\tif(parent.getLeft()==dataRoot){\n\t\t\t\t\t\tparent.setLeft(min);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent.setRight(min);\n\t\t\t\t\t}\n\t\t\t\t\tsetParent(min,parent);\n\t\t\t\t\t\n\t\t\t\t\tboolean curMinIsBlack = min.isBlack();\n\t\t\t\t\t//inherit dataRoot\u0026#39;s color\n\t\t\t\t\tmin.setRed(dataRoot.isRed());\n\t\t\t\t\t\n\t\t\t\t\tif(min!=dataRoot.getRight()){\n\t\t\t\t\t\tmin.setRight(dataRoot.getRight());\n\t\t\t\t\t\tsetParent(dataRoot.getRight(),min);\n\t\t\t\t\t}\n\t\t\t\t\t//remove a black node,need fix color\n\t\t\t\t\tif(curMinIsBlack){\n\t\t\t\t\t\tif(min!=dataRoot.getRight()){\n\t\t\t\t\t\t\tfixRemove(x,isParent);\n\t\t\t\t\t\t}else if(min.getRight()!=null){\n\t\t\t\t\t\t\tfixRemove(min.getRight(),false);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tfixRemove(min,true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tsetParent(dataRoot.getLeft(),parent);\n\t\t\t\t\tif(parent.getLeft()==dataRoot){\n\t\t\t\t\t\tparent.setLeft(dataRoot.getLeft());\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent.setRight(dataRoot.getLeft());\n\t\t\t\t\t}\n\t\t\t\t\t//current node is black and tree is not empty\n\t\t\t\t\tif(dataRoot.isBlack() \u0026amp;\u0026amp; !(root.getLeft()==null)){\n\t\t\t\t\t\tRBTreeNode\u0026lt;T\u0026gt; x = dataRoot.getLeft()==null \n\t\t\t\t\t\t\t\t\t\t\t? parent :dataRoot.getLeft();\n\t\t\t\t\t\tboolean isParent = dataRoot.getLeft()==null;\n\t\t\t\t\t\tfixRemove(x,isParent);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsetParent(dataRoot,null);\n\t\t\t\tdataRoot.setLeft(null);\n\t\t\t\tdataRoot.setRight(null);\n\t\t\t\tif(getRoot()!=null){\n\t\t\t\t\tgetRoot().setRed(false);\n\t\t\t\t\tgetRoot().setParent(null);\n\t\t\t\t}\n\t\t\t\tsize.decrementAndGet();\n\t\t\t\treturn dataRoot.getValue();\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * fix remove action\n\t * @param node\n\t * @param isParent\n\t */\n\tprivate void fixRemove(RBTreeNode\u0026lt;T\u0026gt; node,boolean isParent){\n\t\tRBTreeNode\u0026lt;T\u0026gt; cur = isParent ? null : node;\n\t\tboolean isRed = isParent ? false : node.isRed();\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = isParent ? node : node.getParent();\n\t\t\n\t\twhile(!isRed \u0026amp;\u0026amp; !isRoot(cur)){\n\t\t\tRBTreeNode\u0026lt;T\u0026gt; sibling = getSibling(cur,parent);\n\t\t\t//sibling is not null,due to before remove tree color is balance\n\t\t\t\n\t\t\t//if cur is a left node\n\t\t\tboolean isLeft = parent.getRight()==sibling;\n\t\t\tif(sibling.isRed() \u0026amp;\u0026amp; !isLeft){//case 1\n\t\t\t\t//cur in right\n\t\t\t\tparent.makeRed();\n\t\t\t\tsibling.makeBlack();\n\t\t\t\trotateRight(parent);\n\t\t\t}else if(sibling.isRed() \u0026amp;\u0026amp; isLeft){\n\t\t\t\t//cur in left\n\t\t\t\tparent.makeRed();\n\t\t\t\tsibling.makeBlack();\n\t\t\t\trotateLeft(parent);\n\t\t\t}else if(isBlack(sibling.getLeft()) \u0026amp;\u0026amp; isBlack(sibling.getRight())){//case 2\n\t\t\t\tsibling.makeRed();\n\t\t\t\tcur = parent;\n\t\t\t\tisRed = cur.isRed();\n\t\t\t\tparent=parent.getParent();\n\t\t\t}else if(isLeft \u0026amp;\u0026amp; !isBlack(sibling.getLeft()) \n\t\t\t\t\t\t\t\t\t\u0026amp;\u0026amp; isBlack(sibling.getRight())){//case 3\n\t\t\t\tsibling.makeRed();\n\t\t\t\tsibling.getLeft().makeBlack();\n\t\t\t\trotateRight(sibling);\n\t\t\t}else if(!isLeft \u0026amp;\u0026amp; !isBlack(sibling.getRight()) \n\t\t\t\t\t\t\t\t\t\t\t\u0026amp;\u0026amp; isBlack(sibling.getLeft()) ){\n\t\t\t\tsibling.makeRed();\n\t\t\t\tsibling.getRight().makeBlack();\n\t\t\t\trotateLeft(sibling);\n\t\t\t}else if(isLeft \u0026amp;\u0026amp; !isBlack(sibling.getRight())){//case 4\n\t\t\t\tsibling.setRed(parent.isRed());\n\t\t\t\tparent.makeBlack();\n\t\t\t\tsibling.getRight().makeBlack();\n\t\t\t\trotateLeft(parent);\n\t\t\t\tcur=getRoot();\n\t\t\t}else if(!isLeft \u0026amp;\u0026amp; !isBlack(sibling.getLeft())){\n\t\t\t\tsibling.setRed(parent.isRed());\n\t\t\t\tparent.makeBlack();\n\t\t\t\tsibling.getLeft().makeBlack();\n\t\t\t\trotateRight(parent);\n\t\t\t\tcur=getRoot();\n\t\t\t}\n\t\t}\n\t\tif(isRed){\n\t\t\tcur.makeBlack();\n\t\t}\n\t\tif(getRoot()!=null){\n\t\t\tgetRoot().setRed(false);\n\t\t\tgetRoot().setParent(null);\n\t\t}\n\t\t\n\t}\n\t//get sibling node\n\tprivate RBTreeNode\u0026lt;T\u0026gt; getSibling(RBTreeNode\u0026lt;T\u0026gt; node,RBTreeNode\u0026lt;T\u0026gt; parent){\n\t\tparent = node==null ? parent : node.getParent();\n\t\tif(node==null){\n\t\t\treturn parent.getLeft()==null ? parent.getRight() : parent.getLeft();\n\t\t}\n\t\tif(node==parent.getLeft()){\n\t\t\treturn parent.getRight();\n\t\t}else{\n\t\t\treturn parent.getLeft();\n\t\t}\n\t}\n\t\n\tprivate boolean isBlack(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\treturn node==null || node.isBlack();\n\t}\n\tprivate boolean isRoot(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\treturn root.getLeft() == node \u0026amp;\u0026amp; node.getParent()==null;\n\t}\n\t/**\n\t * find the successor node\n\t * @param node current node\u0026#39;s right node\n\t * @return\n\t */\n\tprivate RBTreeNode\u0026lt;T\u0026gt; removeMin(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\t//find the min node\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = node;\n\t\twhile(node!=null \u0026amp;\u0026amp; node.getLeft()!=null){\n\t\t\tparent = node;\n\t\t\tnode = node.getLeft();\n\t\t}\n\t\t//remove min node\n\t\tif(parent==node){\n\t\t\treturn node;\n\t\t}\n\t\t\n\t\tparent.setLeft(node.getRight());\n\t\tsetParent(node.getRight(),parent);\n\t\t\n\t\t//don\u0026#39;t remove right pointer,it is used for fixed color balance\n\t\t//node.setRight(null);\n\t\treturn node;\n\t}\n\t\n\t\n\t\n\tprivate T addNode(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\tnode.setLeft(null);\n\t\tnode.setRight(null);\n\t\tnode.setRed(true);\n\t\tsetParent(node,null);\n\t\tif(root.getLeft()==null){\n\t\t\troot.setLeft(node);\n\t\t\t//root node is black\n\t\t\tnode.setRed(false);\n\t\t\tsize.incrementAndGet();\n\t\t}else{\n\t\t\tRBTreeNode\u0026lt;T\u0026gt; x = findParentNode(node);\n\t\t\tint cmp = x.getValue().compareTo(node.getValue());\n\t\t\t\n\t\t\tif(this.overrideMode \u0026amp;\u0026amp; cmp==0){\n\t\t\t\tT v = x.getValue();\n\t\t\t\tx.setValue(node.getValue());\n\t\t\t\treturn v;\n\t\t\t}else if(cmp==0){\n\t\t\t\t//value exists,ignore this node\n\t\t\t\treturn x.getValue();\n\t\t\t}\n\t\t\t\n\t\t\tsetParent(node,x);\n\t\t\t\n\t\t\tif(cmp\u0026gt;0){\n\t\t\t\tx.setLeft(node);\n\t\t\t}else{\n\t\t\t\tx.setRight(node);\n\t\t\t}\n\t\t\t\n\t\t\tfixInsert(node);\n\t\t\tsize.incrementAndGet();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * find the parent node to hold node x,if parent value equals x.value return parent.\n\t * @param x\n\t * @return\n\t */\n\tprivate RBTreeNode\u0026lt;T\u0026gt; findParentNode(RBTreeNode\u0026lt;T\u0026gt; x){\n\t\tRBTreeNode\u0026lt;T\u0026gt; dataRoot = getRoot();\n\t\tRBTreeNode\u0026lt;T\u0026gt; child = dataRoot;\n\t\t\n\t\twhile(child!=null){\n\t\t\tint cmp = child.getValue().compareTo(x.getValue());\n\t\t\tif(cmp==0){\n\t\t\t\treturn child;\n\t\t\t}\n\t\t\tif(cmp\u0026gt;0){\n\t\t\t\tdataRoot = child;\n\t\t\t\tchild = child.getLeft();\n\t\t\t}else if(cmp\u0026lt;0){\n\t\t\t\tdataRoot = child;\n\t\t\t\tchild = child.getRight();\n\t\t\t}\n\t\t}\n\t\treturn dataRoot;\n\t}\n\t\n\t/**\n\t * red black tree insert fix.\n\t * @param x\n\t */\n\tprivate void fixInsert(RBTreeNode\u0026lt;T\u0026gt; x){\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = x.getParent();\n\t\t\n\t\twhile(parent!=null \u0026amp;\u0026amp; parent.isRed()){\n\t\t\tRBTreeNode\u0026lt;T\u0026gt; uncle = getUncle(x);\n\t\t\tif(uncle==null){//need to rotate\n\t\t\t\tRBTreeNode\u0026lt;T\u0026gt; ancestor = parent.getParent();\n\t\t\t\t//ancestor is not null due to before before add,tree color is balance\n\t\t\t\tif(parent == ancestor.getLeft()){\n\t\t\t\t\tboolean isRight = x == parent.getRight();\n\t\t\t\t\tif(isRight){\n\t\t\t\t\t\trotateLeft(parent);\n\t\t\t\t\t}\n\t\t\t\t\trotateRight(ancestor);\n\t\t\t\t\t\n\t\t\t\t\tif(isRight){\n\t\t\t\t\t\tx.setRed(false);\n\t\t\t\t\t\tparent=null;//end loop\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent.setRed(false);\n\t\t\t\t\t}\n\t\t\t\t\tancestor.setRed(true);\n\t\t\t\t}else{\n\t\t\t\t\tboolean isLeft = x == parent.getLeft();\n\t\t\t\t\tif(isLeft){\n\t\t\t\t\t\trotateRight(parent);\n\t\t\t\t\t}\n\t\t\t\t\trotateLeft(ancestor);\n\t\t\t\t\t\n\t\t\t\t\tif(isLeft){\n\t\t\t\t\t\tx.setRed(false);\n\t\t\t\t\t\tparent=null;//end loop\n\t\t\t\t\t}else{\n\t\t\t\t\t\tparent.setRed(false);\n\t\t\t\t\t}\n\t\t\t\t\tancestor.setRed(true);\n\t\t\t\t}\n\t\t\t}else{//uncle is red\n\t\t\t\tparent.setRed(false);\n\t\t\t\tuncle.setRed(false);\n\t\t\t\tparent.getParent().setRed(true);\n\t\t\t\tx=parent.getParent();\n\t\t\t\tparent = x.getParent();\n\t\t\t}\n\t\t}\n\t\tgetRoot().makeBlack();\n\t\tgetRoot().setParent(null);\n\t}\n\t/**\n\t * get uncle node\n\t * @param node\n\t * @return\n\t */\n\tprivate RBTreeNode\u0026lt;T\u0026gt; getUncle(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = node.getParent();\n\t\tRBTreeNode\u0026lt;T\u0026gt; ancestor = parent.getParent();\n\t\tif(ancestor==null){\n\t\t\treturn null;\n\t\t}\n\t\tif(parent == ancestor.getLeft()){\n\t\t\treturn ancestor.getRight();\n\t\t}else{\n\t\t\treturn ancestor.getLeft();\n\t\t}\n\t}\n\t\n\tprivate void rotateLeft(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\tRBTreeNode\u0026lt;T\u0026gt; right = node.getRight();\n\t\tif(right==null){\n\t\t\tthrow new java.lang.IllegalStateException(\u0026#34;right node is null\u0026#34;);\n\t\t}\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = node.getParent();\n\t\tnode.setRight(right.getLeft());\n\t\tsetParent(right.getLeft(),node);\n\t\t\n\t\tright.setLeft(node);\n\t\tsetParent(node,right);\n\t\t\n\t\tif(parent==null){//node pointer to root\n\t\t\t//right  raise to root node\n\t\t\troot.setLeft(right);\n\t\t\tsetParent(right,null);\n\t\t}else{\n\t\t\tif(parent.getLeft()==node){\n\t\t\t\tparent.setLeft(right);\n\t\t\t}else{\n\t\t\t\tparent.setRight(right);\n\t\t\t}\n\t\t\t//right.setParent(parent);\n\t\t\tsetParent(right,parent);\n\t\t}\n\t}\n\t\n\tprivate void rotateRight(RBTreeNode\u0026lt;T\u0026gt; node){\n\t\tRBTreeNode\u0026lt;T\u0026gt; left = node.getLeft();\n\t\tif(left==null){\n\t\t\tthrow new java.lang.IllegalStateException(\u0026#34;left node is null\u0026#34;);\n\t\t}\n\t\tRBTreeNode\u0026lt;T\u0026gt; parent = node.getParent();\n\t\tnode.setLeft(left.getRight());\n\t\tsetParent(left.getRight(),node);\n\t\t\n\t\tleft.setRight(node);\n\t\tsetParent(node,left);\n\t\t\n\t\tif(parent==null){\n\t\t\troot.setLeft(left);\n\t\t\tsetParent(left,null);\n\t\t}else{\n\t\t\tif(parent.getLeft()==node){\n\t\t\t\tparent.setLeft(left);\n\t\t\t}else{\n\t\t\t\tparent.setRight(left);\n\t\t\t}\n\t\t\tsetParent(left,parent);\n\t\t}\n\t}\n\t\n\t\n\tprivate void setParent(RBTreeNode\u0026lt;T\u0026gt; node,RBTreeNode\u0026lt;T\u0026gt; parent){\n\t\tif(node!=null){\n\t\t\tnode.setParent(parent);\n\t\t\tif(parent==root){\n\t\t\t\tnode.setParent(null);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * debug method,it used print the given node and its children nodes,\n\t * every layer output in one line\n\t * @param root\n\t */\n\tpublic void printTree(RBTreeNode\u0026lt;T\u0026gt; root){\n\t\tjava.util.LinkedList\u0026lt;RBTreeNode\u0026lt;T\u0026gt;\u0026gt; queue =new java.util.LinkedList\u0026lt;RBTreeNode\u0026lt;T\u0026gt;\u0026gt;();\n\t\tjava.util.LinkedList\u0026lt;RBTreeNode\u0026lt;T\u0026gt;\u0026gt; queue2 =new java.util.LinkedList\u0026lt;RBTreeNode\u0026lt;T\u0026gt;\u0026gt;();\n\t\tif(root==null){\n\t\t\treturn ;\n\t\t}\n\t\tqueue.add(root);\n\t\tboolean firstQueue = true;\n\t\t\n\t\twhile(!queue.isEmpty() || !queue2.isEmpty()){\n\t\t\tjava.util.LinkedList\u0026lt;RBTreeNode\u0026lt;T\u0026gt;\u0026gt; q = firstQueue ? queue : queue2;\n\t\t\tRBTreeNode\u0026lt;T\u0026gt; n = q.poll();\n\t\t\t\n\t\t\tif(n!=null){\n\t\t\t\tString pos = n.getParent()==null ? \u0026#34;\u0026#34; : ( n == n.getParent().getLeft() \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \u0026#34; LE\u0026#34; : \u0026#34; RI\u0026#34;);\n\t\t\t\tString pstr = n.getParent()==null ? \u0026#34;\u0026#34; : n.getParent().toString();\n\t\t\t\tString cstr = n.isRed()?\u0026#34;R\u0026#34;:\u0026#34;B\u0026#34;;\n\t\t\t\tcstr = n.getParent()==null ? cstr : cstr+\u0026#34; \u0026#34;;\n\t\t\t\tSystem.out.print(n+\u0026#34;(\u0026#34;+(cstr)+pstr+(pos)+\u0026#34;)\u0026#34;+\u0026#34;\\t\u0026#34;);\n\t\t\t\tif(n.getLeft()!=null){\n\t\t\t\t\t(firstQueue ? queue2 : queue).add(n.getLeft());\n\t\t\t\t}\n\t\t\t\tif(n.getRight()!=null){\n\t\t\t\t\t(firstQueue ? queue2 : queue).add(n.getRight());\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tSystem.out.println();\n\t\t\t\tfirstQueue = !firstQueue;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tRBTree\u0026lt;String\u0026gt; bst = new RBTree\u0026lt;String\u0026gt;();\n\t\tbst.addNode(\u0026#34;d\u0026#34;);\n\t\tbst.addNode(\u0026#34;d\u0026#34;);\n\t\tbst.addNode(\u0026#34;c\u0026#34;);\n\t\tbst.addNode(\u0026#34;c\u0026#34;);\n\t\tbst.addNode(\u0026#34;b\u0026#34;);\n\t\tbst.addNode(\u0026#34;f\u0026#34;);\n\t\t\n\t\tbst.addNode(\u0026#34;a\u0026#34;);\n\t\tbst.addNode(\u0026#34;e\u0026#34;);\n\t\t\n\t\tbst.addNode(\u0026#34;g\u0026#34;);\n\t\tbst.addNode(\u0026#34;h\u0026#34;);\n\n\t\t\n\t\tbst.remove(\u0026#34;c\u0026#34;);\n\n\t\tbst.printTree(bst.getRoot());\n\t}\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e代码调试的时候，printTree输出格式如下：\u003c/p\u003e\u003cp\u003ed(B)\u003cbr/\u003eb(B d LE) g(R d RI)\u003cbr/\u003ea(R b LE) e(B g LE) h(B g RI)\u003cbr/\u003ef(R e RI)\u003c/p\u003e\u003cp\u003e括号左边表示元素的内容。括号内的第一个元素表示颜色，B表示black，R表示red；第二个元素表示父元素的值；第三个元素表示左右，LE表示在父元素的左边。RI表示在父元素的右边。\u003c/p\u003e\u003cp\u003e第一个元素d是root节点，由于它没有父节点，所以括号内只有一个元素。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e作为平衡二叉查找树里面众多的实现之一，红黑树无疑是最简洁、实现最为简单的。红黑树通过引入颜色的概念，通过颜色这个约束条件的使用来保持树的高度平衡。作为平衡二叉查找树，旋转是一个必不可少的操作。通过旋转可以降低树的高度，在红黑树里面还可以转换颜色。\u003c/p\u003e\u003cp\u003e红黑树里面的插入和删除的操作比较难理解，这时要注意记住一点：操作之前红黑树是平衡的，颜色是符合定义的。在操作的时候就需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡（局部符合红黑树的定义），但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。在整个修复的过程中，插入具体的分为3种情况，删除分为4种情况。\u003c/p\u003e\u003cp\u003e整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN，查找从根到叶，走过的路径是树的高度，删除和插入操作是从叶到根的，所以经过的路径都是logN。\u003c/p\u003e\u003ch2 id=\"参考文献\"\u003e参考文献\u003c/h2\u003e\u003col\u003e\u003cli\u003eCormen T H, Leiserson C E, Rivest R L, 等. 算法导论（第3版）. 殷建平, 等. 机械工业出版社, 2012.\u003c/li\u003e\u003cli\u003eSedgewick R, Wayne K. 算法（第4版）. 谢路云 译. 人民邮电出版社, 2012.\u003cbr/\u003e\u003c/li\u003e\u003cli\u003eWeiss M A. 数据结构与算法分析（第2版）. 冯舜玺 译. 机械工业出版社, 2004.\u003cbr/\u003e\u003c/li\u003e\u003cli\u003eKnuth D E. 计算机程序设计艺术 卷3：排序与查找（英文版 第2版）. 人民邮电出版社, 2010.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-12-02T00:00:00Z",
  "Author": "soulteary@gmail.com"
}