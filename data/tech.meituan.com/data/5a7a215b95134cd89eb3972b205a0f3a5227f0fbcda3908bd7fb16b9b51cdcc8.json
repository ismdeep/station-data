{
  "Source": "tech.meituan.com",
  "Title": "Java魔法类：Unsafe应用解析",
  "Link": "https://tech.meituan.com/2019/02/14/talk-about-java-magic-class-unsafe.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003eUnsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用Unsafe类会使得程序出错的概率变大，使得Java这种安全的语言变得不再“安全”，因此对Unsafe的使用一定要慎重。\u003c/p\u003e\u003cp\u003e注：本文对sun.misc.Unsafe公共API功能及相关应用场景进行介绍。\u003c/p\u003e\u003ch2 id=\"基本介绍\"\u003e基本介绍\u003c/h2\u003e\u003cp\u003e如下Unsafe源码所示，Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic final class Unsafe {\n  // 单例对象\n  private static final Unsafe theUnsafe;\n\n  private Unsafe() {\n  }\n  @CallerSensitive\n  public static Unsafe getUnsafe() {\n    Class var0 = Reflection.getCallerClass();\n    // 仅在引导类加载器`BootstrapClassLoader`加载时才合法\n    if(!VM.isSystemDomainLoader(var0.getClassLoader())) {    \n      throw new SecurityException(\u0026#34;Unsafe\u0026#34;);\n    } else {\n      return theUnsafe;\n    }\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e那如若想使用这个类，该如何获取其实例？有如下两个可行方案。\u003c/p\u003e\u003cp\u003e其一，从\u003ccode\u003egetUnsafe\u003c/code\u003e方法的使用限制条件出发，通过Java命令行命令\u003ccode\u003e-Xbootclasspath/a\u003c/code\u003e把调用Unsafe相关方法的类A所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载，从而通过\u003ccode\u003eUnsafe.getUnsafe\u003c/code\u003e方法安全的获取Unsafe实例。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-bash\"\u003ejava -Xbootclasspath/a: ${path}   // 其中path为调用Unsafe相关方法的类所在jar包路径 \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其二，通过反射获取单例对象theUnsafe。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static Unsafe reflectGetUnsafe() {\n    try {\n      Field field = Unsafe.class.getDeclaredField(\u0026#34;theUnsafe\u0026#34;);\n      field.setAccessible(true);\n      return (Unsafe) field.get(null);\n    } catch (Exception e) {\n      log.error(e.getMessage(), e);\n      return null;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"功能介绍\"\u003e功能介绍\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/f182555953e29cec76497ebaec526fd1297846.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如上图所示，Unsafe提供的API大致可分为内存操作、CAS、Class相关、对象操作、线程调度、系统信息获取、内存屏障、数组操作等几类，下面将对其相关方法和应用场景进行详细介绍。\u003c/p\u003e\u003ch3 id=\"内存操作\"\u003e内存操作\u003c/h3\u003e\u003cp\u003e这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//分配内存, 相当于C++的malloc函数\npublic native long allocateMemory(long bytes);\n//扩充内存\npublic native long reallocateMemory(long address, long bytes);\n//释放内存\npublic native void freeMemory(long address);\n//在给定的内存块中设置值\npublic native void setMemory(Object o, long offset, long bytes, byte value);\n//内存拷贝\npublic native void copyMemory(Object srcBase, long srcOffset, Object destBase, long destOffset, long bytes);\n//获取给定地址值，忽略修饰限定符的访问限制。与此类似操作还有: getInt，getDouble，getLong，getChar等\npublic native Object getObject(Object o, long offset);\n//为给定地址设置值，忽略修饰限定符的访问限制，与此类似操作还有: putInt,putDouble，putLong，putChar等\npublic native void putObject(Object o, long offset, Object x);\n//获取给定地址的byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果为确定的）\npublic native byte getByte(long address);\n//为给定地址设置byte类型的值（当且仅当该内存地址为allocateMemory分配时，此方法结果才是确定的）\npublic native void putByte(long address, byte x);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通常，我们在Java中创建的对象都处于堆内内存（heap）中，堆内内存是由JVM所管控的Java进程内存，并且它们遵循JVM的内存管理机制，JVM会采用垃圾回收机制统一管理堆内存。与之相对的是堆外内存，存在于JVM管控之外的内存区域，Java中对堆外内存的操作，依赖于Unsafe提供的操作堆外内存的native方法。\u003c/p\u003e\u003ch4 id=\"使用堆外内存的原因\"\u003e使用堆外内存的原因\u003c/h4\u003e\u003cul\u003e\u003cli\u003e对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。\u003c/li\u003e\u003cli\u003e提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"典型应用\"\u003e典型应用\u003c/h4\u003e\u003cp\u003eDirectByteBuffer是Java用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在Netty、MINA等NIO框架中应用广泛。DirectByteBuffer对于堆外内存的创建、使用、销毁等逻辑均由Unsafe提供的堆外内存API来实现。\u003c/p\u003e\u003cp\u003e下图为DirectByteBuffer构造函数，创建DirectByteBuffer的时候，通过Unsafe.allocateMemory分配内存、Unsafe.setMemory进行内存初始化，而后构建Cleaner对象用于跟踪DirectByteBuffer对象的垃圾回收，以实现当DirectByteBuffer被垃圾回收时，分配的堆外内存一起被释放。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/5eb082d2e4baf2d993ce75747fc35de6486751.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e那么如何通过构建垃圾回收追踪对象Cleaner实现堆外内存释放呢？\u003c/p\u003e\u003cp\u003eCleaner继承自Java四大引用类型之一的虚引用PhantomReference（众所周知，无法通过虚引用获取与之关联的对象实例，且当对象仅被虚引用引用时，在任何发生GC的时候，其均可被回收），通常PhantomReference与引用队列ReferenceQueue结合使用，可以实现虚引用关联对象被垃圾回收时能够进行系统通知、资源清理等功能。如下图所示，当某个被Cleaner引用的对象将被回收时，JVM垃圾收集器会将此对象的引用放入到对象引用中的pending链表中，等待Reference-Handler进行相关处理。其中，Reference-Handler为一个拥有最高优先级的守护线程，会循环不断的处理pending链表中的对象引用，执行Cleaner的clean方法进行相关清理工作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/9efac865a875c32cf570489332be5d0f131298.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e所以当DirectByteBuffer仅被Cleaner引用（即为虚引用）时，其可以在任意GC时段被回收。当DirectByteBuffer实例对象被回收时，在Reference-Handler线程操作中，会调用Cleaner的clean方法根据创建Cleaner时传入的Deallocator来进行堆外内存的释放。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/66e616c6db18202578c561649facac8d387390.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"cas相关\"\u003eCAS相关\u003c/h3\u003e\u003cp\u003e如下源代码释义所示，这部分主要为CAS相关操作的方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e/**\n\t*  CAS\n  * @param o         包含要修改field的对象\n  * @param offset    对象中某field的偏移量\n  * @param expected  期望值\n  * @param update    更新值\n  * @return          true | false\n  */\npublic final native boolean compareAndSwapObject(Object o, long offset,  Object expected, Object update);\n\npublic final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);\n  \npublic final native boolean compareAndSwapLong(Object o, long offset, long expected, long update);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e什么是CAS? 即比较并替换，实现并发算法时常用到的一种技术。CAS操作包含三个操作数——内存位置、预期原值及新值。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。\u003c/p\u003e\u003ch4 id=\"典型应用-1\"\u003e典型应用\u003c/h4\u003e\u003cp\u003eCAS在java.util.concurrent.atomic相关类、Java AQS、CurrentHashMap等实现上有非常广泛的应用。如下图所示，AtomicInteger的实现中，静态字段valueOffset即为字段value的内存偏移地址，valueOffset的值在AtomicInteger初始化时，在静态代码块中通过Unsafe的objectFieldOffset方法获取。在AtomicInteger中提供的线程安全方法中，通过字段valueOffset的值可以定位到AtomicInteger对象中value的内存地址，从而可以根据CAS实现对value字段的原子操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/3bacb938ca6e63d6c79c2bb48d3f608f189412.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e下图为某个AtomicInteger对象自增操作前后的内存示意图，对象的基地址baseAddress=“0x110000”，通过baseAddress+valueOffset得到value的内存地址valueAddress=“0x11000c”；然后通过CAS进行原子性的更新操作，成功则返回，否则继续重试，直到更新成功为止。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/6e8b1fe5d5993d17a4c5b69bb72ac51d89826.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"线程调度\"\u003e线程调度\u003c/h3\u003e\u003cp\u003e这部分，包括线程挂起、恢复、锁机制等方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e\n//取消阻塞线程\npublic native void unpark(Object thread);\n//阻塞线程\npublic native void park(boolean isAbsolute, long time);\n//获得对象锁（可重入锁）\n@Deprecated\npublic native void monitorEnter(Object o);\n//释放对象锁\n@Deprecated\npublic native void monitorExit(Object o);\n//尝试获取对象锁\n@Deprecated\npublic native boolean tryMonitorEnter(Object o);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如上源码说明中，方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark可以终止一个挂起的线程，使其恢复正常。\u003c/p\u003e\u003ch4 id=\"典型应用-2\"\u003e典型应用\u003c/h4\u003e\u003cp\u003eJava锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用\u003ccode\u003eLockSupport.park()\u003c/code\u003e和\u003ccode\u003eLockSupport.unpark()\u003c/code\u003e实现线程的阻塞和唤醒的，而LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。\u003c/p\u003e\u003ch3 id=\"class相关\"\u003eClass相关\u003c/h3\u003e\u003cp\u003e此部分主要提供Class和它的静态字段的操作相关方法，包含静态字段内存定位、定义类、定义匿名类、检验\u0026amp;确保初始化等。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//获取给定静态字段的内存地址偏移量，这个值对于给定的字段是唯一且固定不变的\npublic native long staticFieldOffset(Field f);\n//获取一个静态类中给定字段的对象指针\npublic native Object staticFieldBase(Field f);\n//判断是否需要初始化一个类，通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。 当且仅当ensureClassInitialized方法不生效时返回false。\npublic native boolean shouldBeInitialized(Class\u0026lt;?\u0026gt; c);\n//检测给定的类是否已经初始化。通常在获取一个类的静态属性的时候（因为一个类如果没初始化，它的静态属性也不会初始化）使用。\npublic native void ensureClassInitialized(Class\u0026lt;?\u0026gt; c);\n//定义一个类，此方法会跳过JVM的所有安全检查，默认情况下，ClassLoader（类加载器）和ProtectionDomain（保护域）实例来源于调用者\npublic native Class\u0026lt;?\u0026gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader, ProtectionDomain protectionDomain);\n//定义一个匿名类\npublic native Class\u0026lt;?\u0026gt; defineAnonymousClass(Class\u0026lt;?\u0026gt; hostClass, byte[] data, Object[] cpPatches);\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"典型应用-3\"\u003e典型应用\u003c/h4\u003e\u003cp\u003e从Java 8开始，JDK使用invokedynamic及VM Anonymous Class结合来实现Java语言层面上的Lambda表达式。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003einvokedynamic\u003c/strong\u003e： invokedynamic是Java 7为了实现在JVM上运行动态语言而引入的一条新的虚拟机指令，它可以实现在运行期动态解析出调用点限定符所引用的方法，然后再执行该方法，invokedynamic指令的分派逻辑是由用户设定的引导方法决定。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eVM Anonymous Class\u003c/strong\u003e：可以看做是一种模板机制，针对于程序动态生成很多结构相同、仅若干常量不同的类时，可以先创建包含常量占位符的模板类，而后通过Unsafe.defineAnonymousClass方法定义具体类时填充模板的占位符生成具体的匿名类。生成的匿名类不显式挂在任何ClassLoader下面，只要当该类没有存在的实例对象、且没有强引用来引用该类的Class对象时，该类就会被GC回收。故而VM Anonymous Class相比于Java语言层面的匿名内部类无需通过ClassClassLoader进行类加载且更易回收。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在Lambda表达式实现中，通过invokedynamic指令调用引导方法生成调用点，在此过程中，会通过ASM动态生成字节码，而后利用Unsafe的defineAnonymousClass方法定义实现相应的函数式接口的匿名类，然后再实例化此匿名类，并返回与此匿名类中函数式方法的方法句柄关联的调用点；而后可以通过此调用点实现调用相应Lambda表达式定义逻辑的功能。下面以如下图所示的Test类来举例说明。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/7707d035eb5f04314b3684ff91dddb1663516.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eTest类编译后的class文件反编译后的结果如下图一所示（删除了对本文说明无意义的部分），我们可以从中看到main方法的指令实现、invokedynamic指令调用的引导方法BootstrapMethods、及静态方法\u003ccode\u003elambda$main$0\u003c/code\u003e（实现了Lambda表达式中字符串打印逻辑）等。在引导方法执行过程中，会通过Unsafe.defineAnonymousClass生成如下图二所示的实现Consumer接口的匿名类。其中，accept方法通过调用Test类中的静态方法\u003ccode\u003elambda$main$0\u003c/code\u003e来实现Lambda表达式中定义的逻辑。而后执行语句\u003ccode\u003econsumer.accept（\u0026#34;lambda\u0026#34;）\u003c/code\u003e其实就是调用下图二所示的匿名类的accept方法。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/1038d53959701093db6c655e4a342e30456249.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"对象操作\"\u003e对象操作\u003c/h3\u003e\u003cp\u003e此部分主要包含对象成员属性相关操作及非常规的对象实例化方式等相关方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//返回对象成员属性在内存地址相对于此对象的内存地址的偏移量\npublic native long objectFieldOffset(Field f);\n//获得给定对象的指定地址偏移量的值，与此类似操作还有：getInt，getDouble，getLong，getChar等\npublic native Object getObject(Object o, long offset);\n//给定对象的指定地址偏移量设值，与此类似操作还有：putInt，putDouble，putLong，putChar等\npublic native void putObject(Object o, long offset, Object x);\n//从对象的指定偏移量处获取变量的引用，使用volatile的加载语义\npublic native Object getObjectVolatile(Object o, long offset);\n//存储变量的引用到对象的指定的偏移量处，使用volatile的存储语义\npublic native void putObjectVolatile(Object o, long offset, Object x);\n//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。只有在field被volatile修饰符修饰时有效\npublic native void putOrderedObject(Object o, long offset, Object x);\n//绕过构造方法、初始化代码来创建对象\npublic native Object allocateInstance(Class\u0026lt;?\u0026gt; cls) throws InstantiationException;\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"典型应用-4\"\u003e典型应用\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e常规对象实例化方式\u003c/strong\u003e：我们通常所用到的创建对象的方式，从本质上来讲，都是通过new机制来实现对象的创建。但是，new机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e非常规的实例化方式\u003c/strong\u003e：而Unsafe中提供allocateInstance方法，仅通过Class对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM安全检查等。它抑制修饰符检测，也就是即使构造器是private修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance在java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e如下图所示，在Gson反序列化时，如果类有默认构造函数，则通过反射调用默认构造函数创建实例，否则通过UnsafeAllocator来实现对象实例的构造，UnsafeAllocator通过调用Unsafe的allocateInstance实现对象的实例化，保证在目标类无默认构造函数时，反序列化不够影响。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/b9fe6ab772d03f30cd48009920d56948514676.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"数组相关\"\u003e数组相关\u003c/h3\u003e\u003cp\u003e这部分主要介绍与数据操作相关的arrayBaseOffset与arrayIndexScale这两个方法，两者配合起来使用，即可定位数组中每个元素在内存中的位置。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//返回数组中第一个元素的偏移地址\npublic native int arrayBaseOffset(Class\u0026lt;?\u0026gt; arrayClass);\n//返回数组中一个元素占用的大小\npublic native int arrayIndexScale(Class\u0026lt;?\u0026gt; arrayClass);\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"典型应用-5\"\u003e典型应用\u003c/h4\u003e\u003cp\u003e这两个与数据操作相关的方法，在java.util.concurrent.atomic 包下的AtomicIntegerArray（可以实现对Integer数组中每个元素的原子性操作）中有典型的应用，如下图AtomicIntegerArray源码所示，通过Unsafe的arrayBaseOffset、arrayIndexScale分别获取数组首元素的偏移地址base及单个元素大小因子scale。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的getAndAdd方法即通过checkedByteOffset方法获取某数组元素的偏移地址，而后通过CAS实现原子性操作。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/160366b0fb2079ad897f6d6b1cb349cd426237.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"内存屏障\"\u003e内存屏障\u003c/h3\u003e\u003cp\u003e在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前\npublic native void loadFence();\n//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前\npublic native void storeFence();\n//内存屏障，禁止load、store操作重排序\npublic native void fullFence();\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"典型应用-6\"\u003e典型应用\u003c/h4\u003e\u003cp\u003e在Java 8中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于StampedLock提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用StampedLock的乐观读锁时，需要遵从如下图用例中使用的模式来确保数据的一致性。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/839ad79686d06583296f3abf1bec27e3320222.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如上图用例所示计算坐标点Point对象，包含点移动方法move及计算此点到原点的距离的方法distanceFromOrigin。在方法distanceFromOrigin中，首先，通过tryOptimisticRead方法获取乐观读标记；然后从主内存中加载点的坐标值 (x,y)；而后通过StampedLock的validate方法校验锁状态，判断坐标点(x,y)从主内存加载到线程工作内存过程中，主内存的值是否已被其他线程通过move方法修改，如果validate返回值为true，证明(x, y)的值未被修改，可参与后续计算；否则，需加悲观读锁，再次从主内存加载(x,y)的最新值，然后再进行距离计算。其中，校验锁状态这步操作至关重要，需要判断锁状态是否发生改变，从而判断之前copy到线程工作内存中的值是否与主内存的值存在不一致。\u003c/p\u003e\u003cp\u003e下图为StampedLock.validate方法的源码实现，通过锁标记与相关常量进行位运算、比较来校验锁状态，在校验逻辑之前，会通过Unsafe的loadFence方法加入一个load内存屏障，目的是避免上图用例中步骤②和StampedLock.validate中锁状态校验运算发生重排序导致锁状态校验不准确的问题。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/256f54b037d07df53408b5eea9436b34135955.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"系统相关\"\u003e系统相关\u003c/h3\u003e\u003cp\u003e这部分包含两个获取系统相关信息的方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。\npublic native int addressSize();  \n//内存页的大小，此值为2的幂次方。\npublic native int pageSize();\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"典型应用-7\"\u003e典型应用\u003c/h4\u003e\u003cp\u003e如下图所示的代码片段，为java.nio下的工具类Bits中计算待申请内存所需内存页数量的静态方法，其依赖于Unsafe中pageSize方法获取系统内存页大小实现后续计算逻辑。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/262470b0c3e79b8f4f7b0c0280b1cc5362454.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"结语\"\u003e结语\u003c/h2\u003e\u003cp\u003e本文对Java中的sun.misc.Unsafe的用法及应用场景进行了基本介绍，我们可以看到Unsafe提供了很多便捷、有趣的API方法。即便如此，由于Unsafe中包含大量自主操作内存的方法，如若使用不当，会对程序带来许多不可控的灾难。因此对它的使用我们需要慎之又慎。\u003c/p\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/sun/misc/Unsafe.java\"\u003eOpenJDK Unsafe source\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe\"\u003eJava Magic. Part 4: sun.misc.Unsafe\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/51132462\"\u003eJVM crashes at libjvm.so\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/throwable/p/9139947.html\"\u003eJava中神奇的双刃剑–Unsafe\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://lovestblog.cn/blog/2015/05/12/direct-buffer/\"\u003eJVM源码分析之堆外内存完全解读\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.jianshu.com/p/007052ee3773\"\u003e堆外内存 之 DirectByteBuffer 详解\u003c/a\u003e\u003c/li\u003e\u003cli\u003e《深入理解Java虚拟机（第2版）》\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e璐璐，美团点评Java开发工程师。2017年加入美团点评，负责美团点评境内度假的后端开发。\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-02-14T00:00:00Z",
  "Author": "soulteary@gmail.com"
}