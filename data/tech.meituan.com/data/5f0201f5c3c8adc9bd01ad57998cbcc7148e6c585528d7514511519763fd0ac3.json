{
  "Source": "tech.meituan.com",
  "Title": "前端渲染引擎doT.js解析",
  "Link": "https://tech.meituan.com/2017/03/24/dot.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e前端渲染有很多框架，而且形式和内容在不断发生变化。这些演变的背后是设计模式的变化，而归根到底是功能划分逻辑的演变：MVC—\u0026gt;MVP—\u0026gt;MVVM（忽略最早混在一起的写法，那不称为模式）。近几年兴起的React、Vue、Angular等框架都属于MVVM模式，能帮我们实现界面渲染、事件绑定、路由分发等复杂功能。但在一些只需完成数据和模板简单渲染的场合，它们就显得笨重而且学习成本较高了。\u003c/p\u003e\u003cp\u003e例如，在美团外卖的开发实践中，前端经常从后端接口取得长串的数据，这些数据拥有相同的样式模板，前端需要将这些数据在同一个样式模板上做重复渲染操作。\u003c/p\u003e\u003cp\u003e解决这个问题的模板引擎有很多，doT.js（出自女程序员Laura Doktorova之手）是其中非常优秀的一个。下表将doT.js与其他同类引擎做了对比：\u003c/p\u003e\u003cp\u003e| 框架 | 大小 | 压缩版本大小 | 迭代 | 条件表达式 | 自定义语法 |\n| ———— | ————- | ———— | ———— |\n| doT.js | 6KB | 4KB | ✓ | ✓ | ✓ |\n| mustache | 18.9 KB | 9.3 KB | ✓ | ✗ | ✓ |\n| Handlebars | 512KB | 62.3KB | ✓ | ✓ | ✓ |\n| artTemplate(腾讯) | - | 5.2KB | ✓ | ✓| ✓ |\n| BaiduTemplate(百度) | 9.45KB | 6KB | ✓ | ✓ | ✓ |\n| jQuery-tmpl | 18.6KB | 5.98KB | ✓ | ✓ | ✓ |\u003c/p\u003e\u003cp\u003e可以看出，doT.js表现突出。而且，它的性能也很优秀，本人在Mac Pro上的用Chrome浏览器（版本为：56.0.2924.87）上做100条数据10000次渲染性能测试，结果如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/4d44efd0.png\" alt=\"性能测试\"/\u003e\u003c/p\u003e\u003cp\u003e从上可以看出doT.js更值得推荐，它的主要优势在于：\n1. 小巧精简，源代码不超过两百行，6KB的大小，压缩版只有4KB；\n2. 支持表达式丰富，涵盖几乎所有应用场景的表达式语句；\n3. 性能优秀；\n4. 不依赖第三方库。\u003c/p\u003e\u003cp\u003e本文主要对doT.js的源码进行分析，探究一下这类模板引擎的实现原理。\u003c/p\u003e\u003ch2 id=\"如何使用\"\u003e如何使用\u003c/h2\u003e\u003cp\u003e如果之前用过doT.js，可以跳过此小节，doT.js使用示例如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-html\"\u003e\u0026lt;script type=\u0026#34;text/html\u0026#34; id=\u0026#34;tpl\u0026#34;\u0026gt;\n    \u0026lt;div\u0026gt;\n        \u0026lt;a\u0026gt;name:{{= it.name}}\u0026lt;/a\u0026gt;\n        \u0026lt;p\u0026gt;age:{{= it.age}}\u0026lt;/p\u0026gt;\n        \u0026lt;p\u0026gt;hello:{{= it.sayHello() }}\u0026lt;/p\u0026gt;\n        \u0026lt;select\u0026gt;\n            {{~ it.arr:item}}\n                \u0026lt;option {{?item.id == it.stringParams2}}selected{{?}} value=\u0026#34;{{=item.id}}\u0026#34;\u0026gt;\n                    {{=item.text}}\n                \u0026lt;/option\u0026gt;\n            {{~}}\n        \u0026lt;/select\u0026gt;\n    \u0026lt;/div\u0026gt;\n\u0026lt;/script\u0026gt;\n\u0026lt;script\u0026gt;\n    $(\u0026#34;#app\u0026#34;).html(doT.template($(\u0026#34;#tpl\u0026#34;).html())({\n        name:\u0026#39;stringParams1\u0026#39;,\n        stringParams1:\u0026#39;stringParams1_value\u0026#39;,\n        stringParams2:1,\n        arr:[{id:0,text:\u0026#39;val1\u0026#39;},{id:1,text:\u0026#39;val2\u0026#39;}],\n        sayHello:function () {\n            return this[this.name]\n        }\n    }));\n\u0026lt;/script\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看出doT.js的设计思路：将数据注入到预置的视图模板中渲染，返回HTML代码段，从而得到最终视图。\u003c/p\u003e\u003cp\u003e下面是一些常用语法表达式对照表：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e项目\u003c/th\u003e\u003cth\u003eJavaScript语法\u003c/th\u003e\u003cth\u003e对应语法\u003c/th\u003e\u003cth\u003e案例\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e输出变量\u003c/td\u003e\u003ctd\u003e=\u003c/td\u003e\u003ctd\u003e{{= 变量名}}\u003c/td\u003e\u003ctd\u003e{{=it.name }}\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e条件判断\u003c/td\u003e\u003ctd\u003eif\u003c/td\u003e\u003ctd\u003e{{? 条件表达式}}\u003c/td\u003e\u003ctd\u003e{{? i \u0026gt; 3}}\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e条件转折\u003c/td\u003e\u003ctd\u003eelse/else if\u003c/td\u003e\u003ctd\u003e{{??}}/{{?? 表达式}}\u003c/td\u003e\u003ctd\u003e{{?? i ==2}}\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e循环遍历\u003c/td\u003e\u003ctd\u003efor\u003c/td\u003e\u003ctd\u003e{{~ 循环变量}}\u003c/td\u003e\u003ctd\u003e{{~ it.arr:item}}…{{~}}\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e执行方法\u003c/td\u003e\u003ctd\u003efuncName()\u003c/td\u003e\u003ctd\u003e{{= funcName() }}\u003c/td\u003e\u003ctd\u003e{{= it.sayHello() }}\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch2 id=\"源码分析及实现原理\"\u003e源码分析及实现原理\u003c/h2\u003e\u003cp\u003e和后端渲染不同，doT.js的渲染完全交由前端来进行，这样做主要有以下好处：\u003c/p\u003e\u003col\u003e\u003cli\u003e脱离后端渲染语言，不需要依赖后端项目的启动，从而降低了开发耦合度、提升开发效率；\u003c/li\u003e\u003cli\u003eView层渲染逻辑全在JavaScript层实现，容易维护和修改；\u003c/li\u003e\u003cli\u003e数据通过接口得到，无需考虑后端数据模型变化，只需关心数据格式。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003edoT.js源码核心：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e...\n// 去掉所有制表符、空格、换行\nstr = (\u0026#34;var out=\u0026#39;\u0026#34; + (c.strip ? str.replace(/(^|\\r|\\n)\\t* +| +\\t*(\\r|\\n|$)/g,\u0026#34; \u0026#34;)\n         .replace(/\\r|\\n|\\t|\\/\\*[\\s\\S]*?\\*\\//g,\u0026#34;\u0026#34;): str)\n   .replace(/\u0026#39;|\\\\/g, \u0026#34;\\\\$\u0026amp;\u0026#34;)\n   .replace(c.interpolate || skip, function(m, code) {\n      return cse.start + unescape(code,c.canReturnNull) + cse.end;\n   })\n   .replace(c.encode || skip, function(m, code) {\n      needhtmlencode = true;\n      return cse.startencode + unescape(code,c.canReturnNull) + cse.end;\n   })\n   // 条件判断正则匹配，包括if和else判断\n   .replace(c.conditional || skip, function(m, elsecase, code) {\n      return elsecase ?\n         (code ? \u0026#34;\u0026#39;;}else if(\u0026#34; + unescape(code,c.canReturnNull) + \u0026#34;){out+=\u0026#39;\u0026#34; : \u0026#34;\u0026#39;;}else{out+=\u0026#39;\u0026#34;) :\n         (code ? \u0026#34;\u0026#39;;if(\u0026#34; + unescape(code,c.canReturnNull) + \u0026#34;){out+=\u0026#39;\u0026#34; : \u0026#34;\u0026#39;;}out+=\u0026#39;\u0026#34;);\n   })\n   // 循环遍历正则匹配\n   .replace(c.iterate || skip, function(m, iterate, vname, iname) {\n      if (!iterate) return \u0026#34;\u0026#39;;} } out+=\u0026#39;\u0026#34;;\n      sid+=1; indv=iname || \u0026#34;i\u0026#34;+sid; iterate=unescape(iterate);\n      return \u0026#34;\u0026#39;;var arr\u0026#34;+sid+\u0026#34;=\u0026#34;+iterate+\u0026#34;;if(arr\u0026#34;+sid+\u0026#34;){var \u0026#34;+vname+\u0026#34;,\u0026#34;+indv+\u0026#34;=-1,l\u0026#34;+sid+\u0026#34;=arr\u0026#34;+sid+\u0026#34;.length-1;while(\u0026#34;+indv+\u0026#34;\u0026lt;l\u0026#34;+sid+\u0026#34;){\u0026#34;\n         +vname+\u0026#34;=arr\u0026#34;+sid+\u0026#34;[\u0026#34;+indv+\u0026#34;+=1];out+=\u0026#39;\u0026#34;;\n   })\n   // 可执行代码匹配\n   .replace(c.evaluate || skip, function(m, code) {\n      return \u0026#34;\u0026#39;;\u0026#34; + unescape(code,c.canReturnNull) + \u0026#34;out+=\u0026#39;\u0026#34;;\n   })\n   + \u0026#34;\u0026#39;;return out;\u0026#34;)\n ...\n\ntry {\n    return new Function(c.varname, str);//c.varname 定义的是new Function（）返回的函数的参数名\n  } catch (e) {\n    /* istanbul ignore else */\n     if (typeof console !== \u0026#34;undefined\u0026#34;) console.log(\u0026#34;Could not create a template function: \u0026#34; + str);\n     throw e;\n  }\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这段代码总结起来就是一句话：用正则表达式匹配预置模板中的语法规则，将其转换、拼接为可执行HTML代码，作为可执行语句，通过new Function()创建的新方法返回。\u003c/p\u003e\u003ch3 id=\"代码解析重点1-正则替换\"\u003e代码解析重点1：正则替换\u003c/h3\u003e\u003cp\u003e正则替换是doT.js的核心设计思路，本文不对正则表达式做扩充讲解，仅分析doT.js的设计思路。先来看一下doT.js中用到的正则：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003etemplateSettings: {\n   evaluate:    /\\{\\{([\\s\\S]+?(\\}?)+)\\}\\}/g, //表达式\n   interpolate: /\\{\\{=([\\s\\S]+?)\\}\\}/g, // 插入的变量\n   encode:      /\\{\\{!([\\s\\S]+?)\\}\\}/g, // 在这里{{！不是用来做判断，而是对里面的代码做编码\n   use:         /\\{\\{#([\\s\\S]+?)\\}\\}/g,\n   useParams:   /(^|[^\\w$])def(?:\\.|\\[[\\\u0026#39;\\\u0026#34;])([\\w$\\.]+)(?:[\\\u0026#39;\\\u0026#34;]\\])?\\s*\\:\\s*([\\w$\\.]+|\\\u0026#34;[^\\\u0026#34;]+\\\u0026#34;|\\\u0026#39;[^\\\u0026#39;]+\\\u0026#39;|\\{[^\\}]+\\})/g,\n   define:      /\\{\\{##\\s*([\\w\\.$]+)\\s*(\\:|=)([\\s\\S]+?)#\\}\\}/g,// 自定义模式\n   defineParams:/^\\s*([\\w$]+):([\\s\\S]+)/, // 自定义参数\n   conditional: /\\{\\{\\?(\\?)?\\s*([\\s\\S]*?)\\s*\\}\\}/g, // 条件判断\n   iterate:     /\\{\\{~\\s*(?:\\}\\}|([\\s\\S]+?)\\s*\\:\\s*([\\w$]+)\\s*(?:\\:\\s*([\\w$]+))?\\s*\\}\\})/g, // 遍历\n   varname:   \u0026#34;it\u0026#34;, // 默认变量名\n   strip:    true,\n   append:       true,\n   selfcontained: false,\n   doNotSkipEncoded: false // 是否跳过一些特殊字符\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e源码中将正则定义写到一起，这样方便了维护和管理。在早期版本的doT.js中，处理条件表达式的方式和tmpl一样，采用直接替换成可执行语句的形式，在最新版本的doT.js中，修改成仅一条正则就可以实现替换，变得更加简洁。\u003c/p\u003e\u003cp\u003edoT.js源码中对模板中语法正则替换的流程如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/52d4e600.png\" alt=\"渲染流程\"/\u003e\u003c/p\u003e\u003ch3 id=\"代码解析重点2-new-function-运用\"\u003e代码解析重点2：new Function()运用\u003c/h3\u003e\u003cp\u003e函数定义时，一般通过Function关键字，并指定一个函数名，用以调用。在JavaScript中，函数也是对象，可以通过函数对象（Function Object）来创建。正如数组对象对应的类型是Array，日期对象对应的类型是Date一样，如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar funcName = new Function(p1,p2,...,pn,body);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e参数的数据类型都是字符串，p1到pn表示所创建函数的参数名称列表，body表示所创建函数的函数体语句，funcName就是所创建函数的名称（可以不指定任何参数创建一个匿名函数）。\u003c/p\u003e\u003cp\u003e下面的定义是等价的。\u003c/p\u003e\u003cp\u003e例如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e// 一般函数定义方式\nfunction func1(a,b){\n    return a+b;\n}\n// 参数是一个字符串通过逗号分隔\nvar func2 = new Function(\u0026#39;a,b\u0026#39;,\u0026#39;return a+b\u0026#39;);\n// 参数是多个字符串\nvar func3 = new Function(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;return a+b\u0026#39;);\n// 一样的调用方式\nconsole.log(func1(1,2));\nconsole.log(func2(2,3));\nconsole.log(func3(1,3));\n// 输出\n3 // func1\n5 // func2\n4 // func3\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从上面的代码中可以看出，Function的最后一个参数，被转换为可执行代码，类似eval的功能。eval执行时存在浏览器性能下降、调试困难以及可能引发XSS（跨站）攻击等问题，因此不推荐使用eval执行字符串代码，new Function()恰好解决了这个问题。回过头来看doT代码中的”new Function(c.varname, str)“，就不难理解varname是传入可执行字符串str的变量。\u003c/p\u003e\u003cp\u003e具体关于new Fcuntion的定义和用法，详细请阅读\u003ca href=\"http://www.cnblogs.com/yuzhongwusan/archive/2012/04/09/2438569.html\"\u003eFunction详细介绍\u003c/a\u003e。\u003c/p\u003e\u003ch2 id=\"性能之因\"\u003e性能之因\u003c/h2\u003e\u003cp\u003e读到这里可能会产生一个疑问：doT.js的性能为什么在众多引擎如此突出？通过阅读其他引擎源代码，发现了它们核心代码段中都存在这样那样的问题。\u003c/p\u003e\u003ch4 id=\"jquery-tmpl\"\u003ejQuery-tmpl\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction buildTmplFn( markup ) {\n        return new Function(\u0026#34;jQuery\u0026#34;,\u0026#34;$item\u0026#34;,\n            // Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).\n            \u0026#34;var $=jQuery,call,__=[],$data=$item.data;\u0026#34; +\n\n            // Introduce the data as local variables using with(){}\n            \u0026#34;with($data){__.push(\u0026#39;\u0026#34; +\n\n            // Convert the template into pure JavaScript\n            jQuery.trim(markup)\n                .replace( /([\\\\\u0026#39;])/g, \u0026#34;\\\\$1\u0026#34; )\n                .replace( /[\\r\\t\\n]/g, \u0026#34; \u0026#34; )\n                .replace( /\\$\\{([^\\}]*)\\}/g, \u0026#34;{{= $1}}\u0026#34; )\n                .replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n                function( all, slash, type, fnargs, target, parens, args ) {\n                    //省略部分模板替换语句,若要阅读全部代码请访问:https://github.com/BorisMoore/jquery-tmpl\n                }) +\n            \u0026#34;\u0026#39;);}return __;\u0026#34;\n        );\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在上面的代码中看到，jQuery-teml同样使用了new Function()的方式编译模板，但是在性能对比中jQuery-teml性能相比doT.js相差甚远，出现性能瓶颈的关键在于with语句的使用。\u003c/p\u003e\u003cp\u003ewith语句为什么对性能有这么大的影响？我们来看下面的代码：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003evar datas = {persons:[\u0026#39;李明\u0026#39;,\u0026#39;小红\u0026#39;,\u0026#39;赵四\u0026#39;,\u0026#39;王五\u0026#39;,\u0026#39;张三\u0026#39;,\u0026#39;孙行者\u0026#39;,\u0026#39;马婆子\u0026#39;],gifts:[\u0026#39;平民\u0026#39;,\u0026#39;巫师\u0026#39;,\u0026#39;狼\u0026#39;,\u0026#39;猎人\u0026#39;,\u0026#39;先知\u0026#39;]};\nfunction go(){\n    with(datas){\n        var personIndex = 0,giftIndex = 0,i=100000;\n        while(i){\n            personIndex = Math.floor(Math.random()*persons.length);\n            giftIndex = Math.floor(Math.random()*gifts.length)\n            console.log(persons[personIndex] +\u0026#39;得到了新的身份:\u0026#39;+ gifts[giftIndex]);\n            i--;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面代码中使用了一个with表达式，为了避免多次从datas中取变量而使用了with语句。这看起来似乎提升了效率，但却产生了一个性能问题：在JavaScript中执行方法时会产生一个执行上下文，这个执行上下文持有该方法作用域链，主要用于标识符解析。当代码流执行到一个with表达式时，运行期上下文的作用域链被临时改变了，一个新的可变对象将被创建，它包含指定对象的所有属性。此对象被插入到作用域链的最前端，意味着现在函数的所有局部变量都被推入第二个作用域链对象中，这样访问datas的属性非常快，但是访问局部变量的速度却变慢了，所以访问代价更高了，如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/1f7a0ca9.png\" alt=\"with\"/\u003e\u003c/p\u003e\u003cp\u003e这个插件在GitHub上面介绍时，作者Boris Moore着重强调两点设计思路：\u003c/p\u003e\u003col\u003e\u003cli\u003e模板缓存，在模板重复使用时，直接使用内存中缓存的模板。在本文作者看来，这是一个鸡肋的功能，在实际使用中，无论是直接写在String中的模板还是从Dom获取的模板都会以变量的形式存放在内存中，变量使用得当，在页面整个生命周期内都能取到这个模板。通过源码分析之后发现jQuery-tmpl的模板缓存并不是对模板编译结果进行缓存，并且会造成多次执行渲染时产生多次编译，再加上代码with性能消耗，严重拖慢整个渲染过程。\u003c/li\u003e\u003cli\u003e模板标记，可以从缓存模板中取出对应子节点。这是一个不错的设计思路，可以实现数据改变只重新渲染局部界面的功能。但是我觉得：模板将渲染结果交给开发者，并渲染到界面指定位置之后，模板引擎的工作就应该结束了，剩下的对节点操作应该灵活的掌握在开发者手上。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e不改变原来设计思路基础之上，尝试对源代码进行性能提升。\u003c/p\u003e\u003cp\u003e先保留提升前性能作为对比：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/0a9a91d7.png\" alt=\"性能提升\"/\u003e\u003c/p\u003e\u003cp\u003e首先来我们做第一次性能提升，移除源码中with语句。\u003c/p\u003e\u003cp\u003e第一次提升后：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/ee9ef7c4.png\" alt=\"性能提升2\"/\u003e\u003c/p\u003e\u003cp\u003e接下来第二部提升，落实Boris Moore设计理念中的模板缓存：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/78546109.png\" alt=\"性能提升3\"/\u003e\u003c/p\u003e\u003cp\u003e优化后的这一部分代码段被我们修改成了：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003efunction buildTmplFn( markup ) {\n\n    if(!compledStr){\n        // Convert the template into pure JavaScript\n        compledStr = jQuery.trim(markup)\n            .replace( /([\\\\\u0026#39;])/g, \u0026#34;\\\\$1\u0026#34; )\n            .replace( /[\\r\\t\\n]/g, \u0026#34; \u0026#34; )\n            .replace( /\\$\\{([^\\}]*)\\}/g, \u0026#34;{{= $1}}\u0026#34; )\n            .replace( /\\{\\{(\\/?)(\\w+|.)(?:\\(((?:[^\\}]|\\}(?!\\}))*?)?\\))?(?:\\s+(.*?)?)?(\\(((?:[^\\}]|\\}(?!\\}))*?)\\))?\\s*\\}\\}/g,\n                //省略部分模板替换语句\n    }\n\n    return new Function(\u0026#34;jQuery\u0026#34;,\u0026#34;$item\u0026#34;,\n        // Use the variable __ to hold a string array while building the compiled template. (See https://github.com/jquery/jquery-tmpl/issues#issue/10).\n        \u0026#34;var $=jQuery,call,__=[],$data=$item.data;\u0026#34; +\n\n        // Introduce the data as local variables using with(){}\n        \u0026#34;__.push(\u0026#39;\u0026#34; + compledStr +\n        \u0026#34;\u0026#39;);return __;\u0026#34;\n    )\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在doT.js源码中没有用到with这类消耗性能的语句，与此同时doT.js选择先将模板编译结果返回给开发者，这样如要重复多次使用同一模板进行渲染便不会反复编译。\u003c/p\u003e\u003ch4 id=\"仅25行的模板-tmpl\"\u003e仅25行的模板：tmpl\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003e(function(){\n  var cache = {};\n\n  this.tmpl =  function (str, data){\n    var fn = !/\\W/.test(str) ?\n      cache[str] = cache[str] ||\n        tmpl(document.getElementById(str).innerHTML) :\n\n      new Function(\u0026#34;obj\u0026#34;,\n        \u0026#34;var p=[],print=function(){p.push.apply(p,arguments);};\u0026#34; +\n        \u0026#34;with(obj){p.push(\u0026#39;\u0026#34; +\n\n        str\n          .replace(/[\\r\\t\\n]/g, \u0026#34; \u0026#34;)\n          .split(\u0026#34;\u0026lt;%\u0026#34;).join(\u0026#34;\\t\u0026#34;)\n          .replace(/((^|%\u0026gt;)[^\\t]*)\u0026#39;/g, \u0026#34;$1\\r\u0026#34;)\n          .replace(/\\t=(.*?)%\u0026gt;/g, \u0026#34;\u0026#39;,$1,\u0026#39;\u0026#34;)\n          .split(\u0026#34;\\t\u0026#34;).join(\u0026#34;\u0026#39;);\u0026#34;)\n          .split(\u0026#34;%\u0026gt;\u0026#34;).join(\u0026#34;p.push(\u0026#39;\u0026#34;)\n          .split(\u0026#34;\\r\u0026#34;).join(\u0026#34;\\\\\u0026#39;\u0026#34;)\n      + \u0026#34;\u0026#39;);}return p.join(\u0026#39;\u0026#39;);\u0026#34;);\n\n    return data ? fn( data ) : fn;\n  };\n})();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e阅读这段代码会惊奇的发现，它更像是baiduTemplate精简版。相比baiduTemplate而言，它移除了baiduTemplate的自定义语法标签的功能，使得代码更加精简，也避开了替换用户语法标签而带来的性能消耗。对于doT.js来说，性能问题的关键是with语句。\u003c/p\u003e\u003cp\u003e综合上述我对tmpl的源码进行移除with语句改造：\u003c/p\u003e\u003cp\u003e改造之前性能：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/63be2494.png\" alt=\"tmpl性能提升\"/\u003e\u003c/p\u003e\u003cp\u003e改造之后性能：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/371738e9.png\" alt=\"tmpl性能提升2\"/\u003e\u003c/p\u003e\u003cp\u003e如果读者对性能对比源码比较感兴趣可以访问 \u003ca href=\"https://github.com/chen2009277025/TemplateTest\"\u003ehttps://github.com/chen2009277025/TemplateTest\u003c/a\u003e 。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e通过对doT.js源码的解读，我们发现：\u003c/p\u003e\u003col\u003e\u003cli\u003edoT.js的条件判断语法标签不直观。当开发者在使用过程中条件判断嵌套过多时，很难找到对应的结束语法符号，开发者需要自己严格规范代码书写，否则会给开发和维护带来困难。\u003c/li\u003e\u003cli\u003edoT.js限制开发者自定义语法标签，相比较之下baiduTemplate提供可自定义标签的功能，而baiduTemplate的性能瓶颈恰好是提供自定义语法标签的功能。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e很多解决我们问题的插件的代码往往简单明了，那些庞大的插件反而存在负面影响或无用功能。技术领域有一个软件设计范式：“约定大于配置”，旨在减少软件开发人员需要做决定的数量，做到简单而又不失灵活。在插件编写过程中开发者应多注意使用场景和性能的有机结合，使用恰当的语法，尽可能减少开发者的配置，不求迎合各个场景。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e建辉，美团外卖高级前端研发工程师，2015年加入美团外卖事业部。目前在前端业务增长组，主要负责运营平台搭建，主导运营活动业务。\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-03-24T00:00:00Z",
  "Author": "soulteary@gmail.com"
}