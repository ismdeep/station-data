{
  "Source": "tech.meituan.com",
  "Title": "Jupyter在美团民宿的应用实践",
  "Link": "https://tech.meituan.com/2019/11/21/application-practice-jupyter.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003e做算法的同学对于Kaggle应该都不陌生，除了举办算法挑战赛以外，它还提供了一个学习、练习数据分析和算法开发的平台。Kaggle提供了Kaggle Kernels，方便用户进行数据分析以及经验分享。在Kaggle Kernels中，你可以Fork别人分享的结果进行复现或者进一步分析，也可以新建一个Kernel进行数据分析和算法开发。Kaggle Kernels还提供了一个配置好的环境，以及比赛的数据集，帮你从配置本地环境中解放出来。Kaggle Kernels提供给你的是一个运行在浏览器中的Jupyter，你可以在上面进行交互式的执行代码、探索数据、训练模型等等。更多关于Kaggle Kernels的使用方法可以参考 \u003ca href=\"https://towardsdatascience.com/introduction-to-kaggle-kernels-2ad754ebf77\"\u003eIntroduction to Kaggle Kernels\u003c/a\u003e，这里不再多做阐述。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/c2e501fbf8aecd821e27ab3f3f4ab2203636169.gif\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e对于比赛类的任务，使用Kaggle Kernels非常方便，但我们平时的主要任务还是集中在分析、处理业务数据的层面，这些数据通常比较机密并且数量巨大，所以就不能在Kaggle Kernels上进行此类分析。因此，大型的互联网公司非常有必要开发并维护集团内部的一套「Kaggle Kernels」服务，从而有效地提升算法同学的日常开发效率。\u003c/p\u003e\u003cp\u003e本文我们将分享美团民宿团队是如何搭建自己的「Kaggle Kernels」—— 一个平台化的Jupyter，接入了大数据和分布式计算集群，用于业务数据分析和算法开发。希望能为有同样需求的读者带来一些启发。\u003c/p\u003e\u003ch2 id=\"美团内部数据系统现状\"\u003e美团内部数据系统现状\u003c/h2\u003e\u003ch3 id=\"现有系统与问题\"\u003e现有系统与问题\u003c/h3\u003e\u003cp\u003e算法同学在离线阶段主要包含三类任务：数据分析、数据生产、模型训练。为满足这些任务的要求，美团内部也开发了相应的系统：\u003c/p\u003e\u003cul\u003e\u003cli\u003e魔数平台：用于执行SQL查询，下载结果集的系统。通常在数据分析阶段使用。\u003c/li\u003e\u003cli\u003e协同平台：用于使用SQL开发ETL的平台。通常用于数据生产。\u003c/li\u003e\u003cli\u003e托管平台：用于管理和运行Spark任务，用户提供任务的代码仓库，系统管理和运行任务。通常用于逻辑较复杂的ETL、基于Spark的离线模型训练/预测任务等。\u003c/li\u003e\u003cli\u003e调度平台：用于管理任务的依赖关系，周期性按依赖执行调度任务。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这些系统对于确定的任务完成的比较好。例如：当取数任务确定时，适合在魔数平台执行查询；当Spark任务开发就绪后，适合在托管平台托管该任务。但对于探索性、分析性的任务没有比较好的工具支持。探索性的任务有程序开发时的调试和对陌生数据的探查，分析性的任务有特征分析、Bad Case分析等等。\u003c/p\u003e\u003cp\u003e以数据探索为例，我们经常需要对数据进行统计与可视化，现有的做法通常是：魔数执行SQL -\u0026gt; 下载Excel -\u0026gt; 可视化。这种方式存在的问题是：\u003c/p\u003e\u003cul\u003e\u003cli\u003e分析和取数工具割裂。\u003c/li\u003e\u003cli\u003e大数据分析可视化困难。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e以Bad Case分析为例，现有的做法通常是：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/8cc2f3ec3012f4daa4b74597cf76ec6942574.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这种方式存在的问题是：\u003c/p\u003e\u003cul\u003e\u003cli\u003e分析与取数割裂，整个过程需要较多的手工操作。\u003c/li\u003e\u003cli\u003e分析过程不容易复现，对于多人协作式的验证以及进一步分析不利。\u003c/li\u003e\u003cli\u003e本地Python环境可能与分析对象的依赖有冲突，需要付出额外精力管理Python环境。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e离线数据相关任务的模式通常是取数（小数据/大数据）–\u0026gt; Python处理（单机/分布式）–\u0026gt; 查看结果（表格/可视化）这样的循环。我们希望支持这一类任务的工具具有如下特质：\u003c/p\u003e\u003cul\u003e\u003cli\u003e体验流畅：数据任务可以在统一的工具中完成，或者在可组合的工具链中完成。\u003c/li\u003e\u003cli\u003e体验一致：数据任务所用工具应该是一致的，不需要根据任务切换不同工具。\u003c/li\u003e\u003cli\u003e使用便捷：工具应是开箱即用，不需要繁琐的前置配置。\u003c/li\u003e\u003cli\u003e结果可复现：分析过程能够作为可执行代码保存下来，需要复现时执行即可，也应支持修改。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e探索和分析类任务往往会带来可以沉淀的结果，如产生新的特征、模型、例行报告，希望可以建立起分析任务和调度任务的桥梁。\u003c/p\u003e\u003ch3 id=\"我们需要怎样的jupyter\"\u003e我们需要怎样的Jupyter\u003c/h3\u003e\u003cp\u003e参考Kaggle Kernels的体验和开源Jupyter的功能，Notebook方式进行探索分析具有良好的体验。我们计划定制Jupyter，使其成为完成数据任务的统一工具。\u003c/p\u003e\u003cp\u003e这个定制的Jupyter应具备以下功能：\u003c/p\u003e\u003cul\u003e\u003cli\u003e接入Spark：取数与分析均在Jupyter中完成，达到流畅、一致的体验。\u003c/li\u003e\u003cli\u003e接入调度系统：方便沉淀分析结果。\u003c/li\u003e\u003cli\u003e接入学城系统（内部WiKi）：方便分享和复现。\u003c/li\u003e\u003cli\u003e预配置环境：提供给用户开箱即用的环境。\u003c/li\u003e\u003cli\u003e用户隔离环境：避免用户间互相污染环境。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"如何搭建jupyter平台\"\u003e如何搭建Jupyter平台\u003c/h2\u003e\u003ch3 id=\"jupyter项目架构\"\u003eJupyter项目架构\u003c/h3\u003e\u003cp\u003eProject Jupyter由多个子项目组成，通过这些子项目可以自由组合出不同的应用。子项目的依赖关系如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/d7ca979c070dd5fd898c8f724a536ea1191926.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这个案例中，Jupyter应用是一个Web服务，我们可以从这个维度来看Jupyter架构：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/7189fdd91099e1a8ba7e792ce592da9529878.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"jupyter扩展方式\"\u003eJupyter扩展方式\u003c/h3\u003e\u003cp\u003e整个Jupyter项目的模块化和扩展性上都非常优秀。上图中的JupyterLab、Notebook Server、IPython、JupyterHub都是可扩展的。\u003c/p\u003e\u003ch4 id=\"jupyterlab扩展-labextension\"\u003eJupyterLab扩展（labextension）\u003c/h4\u003e\u003cp\u003eJupyterLab是Jupyter全新的前端项目，这个项目有非常明确的扩展规范以及丰富的扩展方式。通过开发JupyterLab扩展，可以为前端界面增加新功能，例如新的文件类型打开/编辑支持、Notebook工具栏增加新的按钮、菜单栏增加新的菜单项等等。JupyterLab上的前端模块具有非常清楚的定义和文档，每个模块都可以通过插件获取，进行方法调用，获取必要的信息以及执行必要的动作。我们在提供分享功能、调度功能时，均开发了JupyterLab扩展。JupyterLab扩展通常采用TypeScript开发，开发文档可参考：\u003ca href=\"https://jupyterlab.readthedocs.io/en/stable/developer/extension_dev.html\"\u003ehttps://jupyterlab.readthedocs.io/en/stable/developer/extension_dev.html\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/88ea8e2bc31b5906f8e44624f0ffb440275843.png\" alt=\"\"/\u003e\nJupyterLab核心组件依赖图\u003c/p\u003e\u003ch4 id=\"notebook-server扩展-serverextension\"\u003eNotebook Server扩展（serverextension）\u003c/h4\u003e\u003cp\u003eNotebook Server是用Python写的一个基于\u003ca href=\"https://www.tornadoweb.org/en/stable/\"\u003eTornado\u003c/a\u003e的Web服务。通过Notebook Server扩展，可以为这个Web服务增加新的Handler。增加新的Handler通常有两种用途：\u003c/p\u003e\u003col\u003e\u003cli\u003e为JupyterLab扩展提供对应的后端接口，用于响应一些需要由服务端处理的事件。例如调度任务的注册需要通过JupyterLab扩展发起请求，由Notebook Server扩展执行。\u003c/li\u003e\u003cli\u003e提供一个前端界面以及对应的后端处理服务。例如jupyter-rsession-proxy，用于在JupyterHub中使用RStudio。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eNotebook Server扩展开发文档可参考：\u003ca href=\"https://jupyter-notebook.readthedocs.io/en/stable/extending/handlers.html\"\u003ehttps://jupyter-notebook.readthedocs.io/en/stable/extending/handlers.html\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e##3# Jupyter Kernels\u003c/p\u003e\u003cp\u003eJupyter用于执行代码的模块叫Kernel，除了默认的ipykernel以外，还可以有其他的Kernel用于支持其他编程语言。例如支持Scala语言的\u003ca href=\"https://almond.sh/\"\u003ealmond\u003c/a\u003e、支持R语言的\u003ca href=\"https://irkernel.github.io/\"\u003eirkernel\u003c/a\u003e，更多详见\u003ca href=\"https://github.com/jupyter/jupyter/wiki/Jupyter-kernels\"\u003e语言支持列表\u003c/a\u003e。\u003c/p\u003e\u003ch4 id=\"ipython-magics\"\u003eIPython Magics\u003c/h4\u003e\u003cp\u003eIPython Magics就是那些%、%%开头的命令。常见的Magics有 %matplotlib inline，设置Notebook中调用matplotlib的绘图函数时，直接展示图表在Notebook中。执行Magics时，事实上是调用了该Magics定义的一个函数。对于Line Magics（一个%），传入函数的是当前行的代码；对于Cell Magics（两个%），传入的是整个Cell的内容。定义一个新的IPython Magics仅需定义一个函数，这个函数的入参有两个，一个是当前会话实例，可以用来遍历当前会话的所有变量，可以为当前会话增加新的变量；另一个是用户输入，对于Line Magics是当前行，对于Cell Magcis是当前Cell。\u003c/p\u003e\u003cp\u003eIPython Magics在简化代码方面非常有效，我们开发了%%spark、%%sql用于创建Spark会话以及SQL查询。另外很多第三方的Magics可以用来提高我们的开发效率，例如在开发Word2Vec变种时，使用%%cython来进行Cython和Python混合编程，省去编译加载模块的工作。\u003c/p\u003e\u003cp\u003eIPython Magics开发文档可参考：\u003ca href=\"https://ipython.readthedocs.io/en/stable/config/custommagics.html\"\u003ehttps://ipython.readthedocs.io/en/stable/config/custommagics.html\u003c/a\u003e。\u003c/p\u003e\u003ch4 id=\"ipython-widgets-ipywidgets\"\u003eIPython Widgets（ipywidgets）\u003c/h4\u003e\u003cp\u003eIPython Widgets是一种基于Jupyter Notebook和IPython的可交互控件。与普通可视化不同的是，在控件上的交互会触发和Python的通信并执行相应的代码，Python上相应的动作也会触发界面实时变化。\u003c/p\u003e\u003cp\u003eIPython Widgets在提供工具类型的功能增强上非常有用，基于它，我们实现了一个线上排序服务的调试和复现工具，用于展示排序结果以及指定房源在排序过程中的各种特征以及中间变量的值。IPython Widgets的开发可以通过组合现有的Widgets实现，也可以完全自定义一个，IPython Widgets开发文档可参考：\u003ca href=\"https://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Custom.html\"\u003ehttps://ipywidgets.readthedocs.io/en/stable/examples/Widget%20Custom.html\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/df55c0b8581a7a59fe9ab8f1c51cddc43874819.gif\" alt=\"\"/\u003e\nipyleaflet\u003c/p\u003e\u003ch4 id=\"扩展jupyterhub\"\u003e扩展JupyterHub\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003eAuthenticators\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eJupyterHub是一个多用户系统，登录模块可替换，通过实现新的Authenticator类并在配置文件中指定即可。通过这个扩展点，我们实现了使用内部SSO系统登录JupyterHub。Authenticator开发文档可参考：\u003ca href=\"https://jupyterhub.readthedocs.io/en/stable/reference/authenticators.html\"\u003ehttps://jupyterhub.readthedocs.io/en/stable/reference/authenticators.html\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSpawners\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e当用户登录时，JupyterHub需要为用户启动一个用户专用Notebook Server。启动这个Notebook Server有多种方式：本机新的Notebook Server进程、本机启动Docker实例、K8s系统中启动新的Pod、YARN中启动新的实例等等。每一种启动方式都对应一个Spawner，官方提供了多种Spawner的实现，这些实现本身是可配置的。如果不符合需求，也可以自己开发全新的Spawner。由于我们需要实现Spark接入，对K8s的Pod有新的要求，所以基于KubeSpawner定制了一个Spawner来解决Spark连接集群的网络问题。Spawner开发文档可参考：\u003ca href=\"https://jupyterhub.readthedocs.io/en/stable/reference/spawners.html\"\u003ehttps://jupyterhub.readthedocs.io/en/stable/reference/spawners.html\u003c/a\u003e。\u003c/p\u003e\u003ch3 id=\"我们的定制\"\u003e我们的定制\u003c/h3\u003e\u003cp\u003e回顾我们的需求，这个定制的Jupyter应具备以下功能：\u003c/p\u003e\u003cul\u003e\u003cli\u003e接入Spark：可以通过配置容器环境以及Spawner完成。\u003c/li\u003e\u003cli\u003e接入调度系统：需要开发JupyterLab扩展以及Notebook Server扩展。\u003c/li\u003e\u003cli\u003e接入学城系统：需要开发JupyterLab扩展以及Notebook Server扩展。\u003c/li\u003e\u003cli\u003e预配置环境：镜像配置。\u003c/li\u003e\u003cli\u003e用户隔离环境：通过定制Authenticators + K8s Spawner实现容器级别环境隔离。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e我们的方案是基于JupyterHub on K8s。下图是平台化Jupyter的架构图，从上到下可以看到三条主线：1. 分享复现、2. 探索执行、3. 调度执行。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/0bea9989a83ad72b12791e023234c79d303225.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e几个关键组件介绍：\u003c/p\u003e\u003cul\u003e\u003cli\u003eJupyterLab：交互式执行的前端，开源项目。\u003c/li\u003e\u003cli\u003eJupyter Server：交互式执行的后端，开源项目。\u003c/li\u003e\u003cli\u003eCommuter：浏览Notebook的工具，开源项目。\u003c/li\u003e\u003cli\u003eK8s：容器编排系统，开源项目。\u003c/li\u003e\u003cli\u003eCantor：美团调度系统，同类开源项目有AirFlow。\u003c/li\u003e\u003cli\u003e托管平台：美团离线任务托管平台，给定代码仓库和任务参数，为我们执行Spark-Submit的平台。\u003c/li\u003e\u003cli\u003e学城：美团文档系统。\u003c/li\u003e\u003cli\u003eMSS：美团对象存储。\u003c/li\u003e\u003cli\u003eNB-Runner：Notebook Runner，在nbconvert的基础上增加了参数化和Spark支持。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在定制Jupyter中，最为关键的两个是接入Spark以及接入调度系统，下文中将详细介绍这两部分的原理。\u003c/p\u003e\u003cp\u003eJupyterHub on K8s包括几个重要组成部分：Proxy、Hub、Kubernetes、用户容器（Jupyter Server Pod）、单点登录系统（SSO）。一个用户在登录后新建容器实例的过程中，这几个模块的交互如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/2e651544f4678b85db9763182c7c17a0142427.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可以看到，新建容器实例后，用户的交互都是经过Proxy后与Jupyter Server Pod进行通信。因此，扩展功能的工作主要是定制Jupyter Server Pod对应的容器镜像。\u003c/p\u003e\u003ch3 id=\"让jupyter支持spark\"\u003e让Jupyter支持Spark\u003c/h3\u003e\u003cp\u003eJupyter平台化后，我们得到一个接近Kaggle Kernel的环境，但是还不能够使用大数据集群。接下来，就是让Jupyter支持Spark，Jupyter支持Spark的方案有\u003ca href=\"https://toree.apache.org/\"\u003eToree\u003c/a\u003e，出于灵活性考虑，我们没有使用。我们希望让普通的Python Kernel能支持PySpark。\u003c/p\u003e\u003cp\u003e为了能让Jupyter支持Spark，我们需要了解两方面原理：Jupyter代码执行原理和PySpark原理。\u003c/p\u003e\u003cp\u003e#3## Jupyter代码执行原理\u003c/p\u003e\u003cp\u003e所用到的Jupyter分三部分：前端JupyterLab、服务端Jupyter Server、语言Kernel IPython。这三个模块的通信如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/3732db95117a0eb83c470cb4f299a0f147300.png\" alt=\"\"/\u003e\nJupyter执行代码时序图\u003c/p\u003e\u003cp\u003e这里，需要在IPython的exec阶段支持PySpark。\u003c/p\u003e\u003cp\u003e##3# PySpark原理\u003c/p\u003e\u003cp\u003e启动PySpark有两种方式：\u003c/p\u003e\u003cul\u003e\u003cli\u003e方案一：PySpark命令启动，内部执行了spark-submit命令。\u003c/li\u003e\u003cli\u003e方案二：任意Python shell（Python、IPython）中执行Spark会话创建语句。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e这两种启动方式有什么区别呢？\u003c/p\u003e\u003cp\u003e看一下PySpark架构图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/10515da505aa1b70b6d393b2586e5bb1552347.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003ePySpark架构图，来自\u003ca href=\"https://www.slideshare.net/blueplastic/spark-cassandra-at-datastax-meetup-on-jan-29-2015\"\u003eSlideShare\u003c/a\u003e\u003c/p\u003e\u003cp\u003e与Spark的区别是，多了一个Python进程，通过Py4J与Driver JVM进行通信。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003ePySpark方案启动流程\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/2a8b77cc091334569166caf5dbf1f8a5133078.png\" alt=\"\"/\u003e\nPySpark启动时序图\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eIPython方案启动流程\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/ec5671a7912a588f9b37532f45d2a361105237.png\" alt=\"\"/\u003e\n实际的IPython中启动Spark时序图\u003c/p\u003e\u003cp\u003eToree采用的是类似方案一的方式，脚本中调用spark-submit执行特殊版本的Shell，内置了Spark会话。我们不希望这么做，是因为如果这样做的话就会：\u003c/p\u003e\u003cul\u003e\u003cli\u003e多了一个PySpark专供的Kernel，我们希望Kernel应该是统一的IPython。\u003c/li\u003e\u003cli\u003ePySpark启动参数是固定的，配置在kernel.json里。希望PySpark任务是可以按需启动，可以灵活配置所需的参数，如Queue、Memory、Cores。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e因此我们采用方案二，只需要一些环境配置，就能顺利启动PySpark。另外为了简化Spark启动工作，我们还开发了IPython的Magics，%spark和%sql。\u003c/p\u003e\u003ch4 id=\"环境配置\"\u003e环境配置\u003c/h4\u003e\u003cp\u003e为了让IPython中能够顺利启动起Spark会话，需要正确配置如下环境变量：\u003c/p\u003e\u003cul\u003e\u003cli\u003eJAVA_HOME：Java安装路径，如/usr/local/jdk1.8.0_201。\u003c/li\u003e\u003cli\u003eHADOOP_HOME：Hadoop安装路径，如/opt/hadoop。\u003c/li\u003e\u003cli\u003eSPARK_HOME：Spark安装路径，如/opt/spark-2.2。\u003c/li\u003e\u003cli\u003ePYTHONPATH：额外的Python库路径，如$SPARK_HOME/python:$SPARK_HOME/python/lib/py4j-0.10.4-src.zip。\u003c/li\u003e\u003cli\u003ePYSPARK_PYTHON：集群中使用的Python路径，如./ARCHIVE/notebook/bin/python。集群中使用Python通常需要虚拟环境，通过spark.yarn.dist.archives带上去。\u003c/li\u003e\u003cli\u003ePYSPARK_DRIVER_PYTHON：Spark Driver所用的Python路径，如果你用Conda管理Python环境，那这个变量应为类似/opt/conda/envs/notebook/bin/python的路径。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e为了方便，建议设置各bin路径到PATH环境变量中：$SPARK_HOME/sbin:$SPARK_HOME/bin:$HADOOP_HOME/sbin:$HADOOP_HOME/bin:$JAVA_HOME/bin:$PATH。\u003c/p\u003e\u003cp\u003e完成这些之后，可以在IPython中执行创建Spark会话代码验证：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eimport pyspark\nspark = pyspark.sql.SparkSession.builder.appName(\u0026#34;MyApp\u0026#34;).getOrCreate()\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"在spark任务中执行notebook\"\u003e在Spark任务中执行Notebook\u003c/h3\u003e\u003cp\u003e执行Notebook的方案目前有nbconvert，Python API方式执行样例如下所示，暂时称这段代码为NB-Runner.py：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e# Import：首先我们import nbconvert和ExecutePreprocessor类：\nimport nbformat\nfrom nbconvert.preprocessors import ExecutePreprocessor\n\n# 加载：假设notebook_filename是notebook的路径，我们可以这样加载：\nwith open(notebook_filename) as f:\n    nb = nbformat.read(f, as_version=4)\n\n# 配置：接下来，我们配置notebook执行模式：\nep = ExecutePreprocessor(timeout=600, kernel_name=\u0026#39;python\u0026#39;)\n\n# 执行(preprocess)：真正执行notebook的地方是调用函数preprocess：\nep.preprocess(nb, {\u0026#39;metadata\u0026#39;: {\u0026#39;path\u0026#39;: \u0026#39;notebooks/\u0026#39;}})\n\n#保存：最后，我们保存notebook执行结果：\nwith open(\u0026#39;executed_notebook.ipynb\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f:\n    nbformat.write(nb, f)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e现在有两个问题需要确认：\u003c/p\u003e\u003cul\u003e\u003cli\u003e当Notebook中存在Spark相关代码时，Python NB-Runner.py能否正常执行？\u003c/li\u003e\u003cli\u003e当Notebook中存在Spark相关代码时，Spark-Submit NB-Runner.py能否正常执行？\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e之所以会出现问题2，是因为我们的调度系统只能调度Spark任务，所以必须使用Spark-Submit的方式来启动NB-Runner.py。\u003c/p\u003e\u003cp\u003e为了回答这两个问题，需要了解nbconvert是如何执行Notebook的。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/1d6cd609145de489ce6387eb0c90285681952.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003enbconvert执行时序图\u003c/p\u003e\u003cp\u003e问题1从原理上看，是可以正常执行的。实际测试也是如此。对于问题2，答案似乎并不明显。结合“PySpark启动时序图”、“实际的IPython中启动Spark时序图”与“nbconvert执行时序图”：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/9314b3f14ecfd22a4806d42d4f28eba2215702.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eSpark-Submit NB-Runner.py的方式存在问题的点可能在于，IPython中执行Spark.builder.getOrCreate时，Driver JVM已经启动并且Py4J Gateway Server已经实例化完成。如何让Spark.builder.getOrCreate执行时跳过上图“实际的IPython中启动Spark时序图”的Popen(spark-submit)以及后续的启动Py4J Gateway Server部分，直接与Py4J Gateway Server建立连接？\u003c/p\u003e\u003cp\u003e在PySpark代码中，看到如下这段代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edef launch_gateway(conf=None):\n    \u0026#34;\u0026#34;\u0026#34;\n    launch jvm gateway\n    :param conf: spark configuration passed to spark-submit\n    :return:\n    \u0026#34;\u0026#34;\u0026#34;\n    if \u0026#34;PYSPARK_GATEWAY_PORT\u0026#34; in os.environ:\n        gateway_port = int(os.environ[\u0026#34;PYSPARK_GATEWAY_PORT\u0026#34;])\n    else:\n        SPARK_HOME = _find_spark_home()\n        # Launch the Py4j gateway using Spark\u0026#39;s run command so that we pick up the\n        # proper classpath and settings from spark-env.sh\n        on_windows = platform.system() == \u0026#34;Windows\u0026#34;\n        script = \u0026#34;./bin/spark-submit.cmd\u0026#34; if on_windows else \u0026#34;./bin/spark-submit\u0026#34;\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果我们能在IPython进程中设置环境变量PYSPARK_GATEWAY_PORT为真实的Py4J Gateway Server监听的端口，就会跳过Spark-Submit以及启动Py4J Gateway Server部分。那么PYSPARK_GATEWAY_PORT从哪来呢？我们发现在Python进程中存在这个环境变量，只需要通过ExecutorPreprocessor将它传递给IPython进程即可。\u003c/p\u003e\u003ch2 id=\"使用案例\"\u003e使用案例\u003c/h2\u003e\u003ch3 id=\"数据分析与可视化\"\u003e数据分析与可视化\u003c/h3\u003e\u003cp\u003e数据探查和数据分析在这里都是同样的流程。用户要分析的数据通常存储在MySQL和Hive中。为了方便用户在Notebook中交互式的执行SQL，我们开发了IPython Magics %%sql用来执行SQL。\u003c/p\u003e\u003cp\u003eSQL Magics的用法如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e%%sql \u0026lt;var\u0026gt; [--preview] [--cache] [--quiet]\nSELECT field1, field2\n  FROM table1\n WHERE field3 == field4\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eSQL查询的结果暂存在指定的变量名\u003cvar\u003e中，对于MySQL数据源\u003cvar\u003e的类型是Pandas DataFrame，对于Hive数据源\u003cvar\u003e的类型是Spark DataFrame。\u003cvar\u003e可用于需要对结果集进行操作的场合，如多维分析、数据可视化。目前，我们支持几乎所有的Python数据可视化库。\u003c/var\u003e\u003c/var\u003e\u003c/var\u003e\u003c/var\u003e\u003c/p\u003e\u003cp\u003e下图是一个数据分析和可视化的例子：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/3f9ab3c5d1ebb23a795b8bb66db4fc423054799.gif\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e数据分析与可视化\u003c/p\u003e\u003ch3 id=\"notebook分享\"\u003eNotebook分享\u003c/h3\u003e\u003cp\u003eNotebook不仅支持交互式的执行代码，对于文档编辑也有不错的支持。数据分析过程中的数据、表格、图表加上文字描述就是一个很好的报告。Jupyter服务还支持用户一键将Notebook分享到美团内部的学城中。\u003c/p\u003e\u003cp\u003e一键分享：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b379bd437e96b4360db85cadceb22d8315330.png\" alt=\"\"/\u003e\n一键分享\u003c/p\u003e\u003cp\u003e上述数据分析分享到内部学城的效果如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/fee6b263b67d54108e6f92481a6cbc0a3049030.gif\" alt=\"\"/\u003e\nNotebook分享效果\u003c/p\u003e\u003ch3 id=\"模型训练\"\u003e模型训练\u003c/h3\u003e\u003cp\u003e基于大数据的模型训练通常使用PySpark来完成。除了Spark内置的Spark ML可以使用以外，Jupyter服务上还支持使用第三方X-on-Spark的算法，如XGBoost-on-Spark、LightGBM-on-Spark。我们开发了IPython Magics %%spark来简化这个过程。\u003c/p\u003e\u003cp\u003eSpark Magics的用法如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e%%spark\n[--conf \u0026lt;property-name\u0026gt;=\u0026lt;property-value\u0026gt;]\n[--conf \u0026lt;property-name\u0026gt;=\u0026lt;property-value\u0026gt;]\n...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行%%spark后，会启动Spark会话，启动后Notebook会话中会新建两个变量spark和sc，分别对应当前Spark会话的SparkSession和SparkContext。\u003c/p\u003e\u003cp\u003e下图是一个使用LightGBM-on-Yarn训练模型的例子，基于Azure/mmlspark官方Notebook例子，仅需添加启动Spark语句以及修改数据集路径。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/4e73856a0ffd39115bc8824c5be4f2a54122329.gif\" alt=\"\"/\u003e\nLightGBM on Spark Demo\u003c/p\u003e\u003ch3 id=\"排序策略调试\"\u003e排序策略调试\u003c/h3\u003e\u003cp\u003e通过开发ipywidgets实现了一个线上排序策略的调试工具，可以用于查看排序结果以及排序原因（通过查看变量值）。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/d2b1d6c00a8fdf877cdb53dfc2e0aafe1582119.gif\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"总结与展望\"\u003e总结与展望\u003c/h2\u003e\u003cp\u003e通过平台化Jupyter的定制与部署，我们实现了数据分析、数据生产、模型训练的统一开发环境。在此基础上，还集成了内部公共服务和业务服务，从而实现了从数据分析到策略上线到结果分析的全链路支持。\u003c/p\u003e\u003cp\u003e我们对这个项目未来的定位是数据科学的云端集成开发环境，而Jupyter项目所具有的极强扩展性，也能够支持我们朝着这个方向不断进行演进。\u003c/p\u003e\u003ch2 id=\"作者\"\u003e作者\u003c/h2\u003e\u003cp\u003e文龙，美团民宿研发团队工程师。\u003c/p\u003e\u003cp\u003e颖艺，美团民宿研发团队工程师。\u003c/p\u003e\u003ch2 id=\"招聘\"\u003e招聘\u003c/h2\u003e\u003cp\u003e美团民宿研发团队诚招数据系统研发工程师，Base厦门，欢迎有兴趣的同学投递简历到 tech@meituan.com 。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-11-21T00:00:00Z",
  "Author": "soulteary@gmail.com"
}