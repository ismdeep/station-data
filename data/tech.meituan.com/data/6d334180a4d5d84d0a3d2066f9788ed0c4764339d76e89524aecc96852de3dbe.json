{
  "Source": "tech.meituan.com",
  "Title": "Intel PAUSE指令变化影响到MySQL的性能，该如何解决？",
  "Link": "https://tech.meituan.com/2020/04/16/intel-pause-mysql.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003eMySQL得益于其开源属性、成熟的商业运作、良好的社区运营以及功能的不断迭代与完善，已经成为互联网关系型数据库的标配。可以说，X86服务器、Linux作为基础设施，跟MySQL一起构建了互联网数据存储服务的基石，三者相辅相成。本文将分享一个工作中的实践案例：因Intel PAUSE指令周期的迭代，引发了MySQL的性能瓶颈，美团MySQL DBA团队如何基于这三者来一步步进行分析、定位和优化。希望这些思路能对大家有所启发。\u003c/p\u003e\u003ch2 id=\"1-背景\"\u003e1.背景\u003c/h2\u003e\u003cp\u003e在2017年，Intel发布了新一代的服务器平台Purley，并将Intel Xeon Scalable Processor（至强可扩展处理器）重新划分为：Platinum（铂金）、Gold（金）、Silver（银）、Broze（铜）等四个等级。产品定位和框架也变得更加清晰。\u003c/p\u003e\u003cp\u003e因美团线上海量数据交易和存储等后端服务依赖大量高性能服务器的支撑。随着线上部分Grantly平台E系列服务器生命周期的临近，以及产品本身的发展和迭代。从2019年开始，RDS（关系型数据库服务）后端存储（MySQL）开始大量上线Purley平台的Skylake CPU服务器，其中包含Silver 4110等。\u003c/p\u003e\u003cp\u003eSilver 4110相比上一代E5-2620 V4，支持更高的内存频率、更多的内存通道、更大的L2 Cache、更快的总线传输速率等。Intel官方数据显示Silver 4110的性能比上一代E5-2620 V4提升了10%。\u003c/p\u003e\u003cp\u003e然而，随着线上Skylake服务器数量的增加，以及越来越多的业务接入。美团MySQL DBA团队发现部分MySQL实例性能与预期并不相符，有时甚至出现较大程度的下降。经过持续的性能问题分析，我们定位到Skylake服务器存在性能瓶颈：\u003c/p\u003e\u003cul\u003e\u003cli\u003eCPU负载相对较高。\u003c/li\u003e\u003cli\u003eTPS等吞吐量下降。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e接下来，我们将从Intel CPU、ut_delay函数、PAUSE指令三方面入手，进行剖析定位，并探索相关优化方案。\u003c/p\u003e\u003ch2 id=\"2-性能问题分析\"\u003e2.性能问题分析\u003c/h2\u003e\u003ch3 id=\"2-1-grantly与purley-cpu性能差异\"\u003e2.1 Grantly与Purley CPU性能差异\u003c/h3\u003e\u003cp\u003e首先，基于上述两代平台的CPU（Grantly和Purley），通过基准测试，横向对比在不同OS下的性能表现。\u003c/p\u003e\u003cp\u003e通过基准测试数据，总结如下：\u003c/p\u003e\u003cp\u003e1.在oltp_write_only（只写）的场景下Purley 4110的性能下降较为明显。\n2.同为Purley 4110，CentOS 7比CentOS 6 oltp_write_only（只写）性能有提升。\u003c/p\u003e\u003cp\u003e我们通过二维折线图，来展示性能之间的差异：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/562761e2b0a5c158f1c4d5d4095986dc128332.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在上图中，同为Purley 4110，CentOS 7比CentOS 6性能有提升。具体提升原因，因不涉及本文重点内容，所以不在这里详细展开了。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eNew MCS-based Locking Mechanism\u003c/p\u003e\u003cp\u003eRed Hat Enterprise Linux 7.1 introduces a new locking mechanism, MCS locks. This new locking mechanism significantly reduces spinlock overhead in large systems, which makes spinlocks generally more efficient in Red Hat Enterprise Linux 7.1.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e红帽官网Release Notes显示，从内核3.10.0-229开始，引入了新的加锁机制，MCS锁。可以降低spinlock的开销，从而更高效地运行。普通spinlock在多CPU Core下，同时只能有一个CPU获取变量，并自旋，而缓存一致性协议为了保证数据的正确，会对所有CPU Cache Line状态、数据，同步、失效等操作，导致性能下降。而MSC锁实现每个CPU都有自己的“spinlock”本地变量，只在本地自旋。避免Cache Line同步等，从而提升了相关性能。不过，社区对于spinlock的优化争议还是比较大的，后续又有大牛基于MSC实现了qspinlock，并在4.x的版本上patch了。具体实现可以参看：\u003ca href=\"https://lwn.net/Articles/590243/\"\u003eMCS locks and qspinlocks\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e在大致了解CentOS 7性能的迭代后，接下来我们深入分析一下Skylake CPU 4110导致性能下降的缘由。\u003c/p\u003e\u003ch2 id=\"3-cpu性能跟踪\"\u003e3.CPU性能跟踪\u003c/h2\u003e\u003ch3 id=\"3-1-定位热点函数\"\u003e3.1 定位热点函数\u003c/h3\u003e\u003cp\u003e具体定位4110性能瓶颈，分如下几步:\u003c/p\u003e\u003col\u003e\u003cli\u003e首先，通过perf top来跟踪一下Linux CPU性能开销。\u003c/li\u003e\u003cli\u003e然后，通过perf record记录函数CPU周期的消耗占比。\u003c/li\u003e\u003cli\u003e最后，通过火焰图来验证定位热点函数。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/eff5580b651c8e86cdf4fd1e5fbe0e4f447942.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可以看到，其中占CPU消耗占比较大为：ut_delay函数。\u003c/p\u003e\u003cp\u003e我们继续深挖一下函数链调用关系：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-SQL\"\u003e# Children      Self  Command  Shared Object        Symbol                                                                                                                                                                            \n# ........  ........  .......  ...................  ..................................................................................................................................................................................\n#\n    93.54%     0.00%  mysqld   libpthread-2.17.so   [.] start_thread\n            |\n            ---start_thread\n               |          \n               |--77.07%--pfs_spawn_thread\n               |          |          \n               |           --77.05%--handle_connection\n               |                     |          \n               |                      --76.97%--do_command\n               |                                |          \n               |                                |--74.30%--dispatch_command\n               |                                |          |          \n               |                                |          |--71.16%--mysqld_stmt_execute\n               |                                |          |          |          \n               |                                |          |           --70.74%--Prepared_statement::execute_loop\n               |                                |          |                     |          \n               |                                |          |                     |--69.53%--Prepared_statement::execute\n               |                                |          |                     |          |          \n               |                                |          |                     |          |--67.90%--mysql_execute_command\n               |                                |          |                     |          |          |          \n               |                                |          |                     |          |          |--23.43%--trans_commit_stmt\n               |                                |          |                     |          |          |          |          \n               |                                |          |                     |          |          |           --23.30%--ha_commit_trans\n               |                                |          |                     |          |          |                     |          \n               |                                |          |                     |          |          |                     |--18.86%--MYSQL_BIN_LOG::commit\n               |                                |          |                     |          |          |                     |          |          \n               |                                |          |                     |          |          |                     |           --18.18%--MYSQL_BIN_LOG::ordered_commit\n               |                                |          |                     |          |          |                     |                     |          \n               |                                |          |                     |          |          |                     |                     |--8.02%--MYSQL_BIN_LOG::change_stage\n               |                                |          |                     |          |          |                     |                     |          |          \n               |                                |          |                     |          |          |                     |                     |          |--2.35%--__lll_unlock_wake\n               |                                |          |                     |          |          |                     |                     |          |          |          \n               |                                |          |                     |          |          |                     |                     |          |           --2.24%--system_call_fastpath\n               |                                |          |                     |          |          |                     |                     |          |                     |          \n               |                                |          |                     |          |          |                     |                     |          |                      --2.24%--sys_futex\n               |                                |          |                     |          |          |                     |                     |          |                                |          \n               |                                |          |                     |          |          |                     |                     |          |                                 --2.23%--do_futex\n               |                                |          |                     |          |          |                     |                     |          |                                           |          \n               |                                |          |                     |          |          |                     |                     |          |                                            --2.14%--futex_wake\n               |                                |          |                     |          |          |                     |                     |          |                                                      |          \n               |                                |          |                     |          |          |                     |                     |          |                                                       --1.38%--wake_up_q\n               |                                |          |                     |          |          |                     |                     |          |                                                                 |          \n               |                                |          |                     |          |          |                     |                     |          |                                                                  --1.33%--try_to_wake_up\n               ...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将上述调用通过火焰图进行直观展示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/2a7f90b72ee88163d67df0f71cf0d13b262576.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e现在基本可以确定，所有的函数调用，最后大部分的消耗都在ut_delay上。\u003c/p\u003e\u003ch3 id=\"3-2-ut-delay和pause之间的关联与性能影响\"\u003e3.2 ut_delay和PAUSE之间的关联与性能影响\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e3.2.1 MySQL ut_delay实现\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e接下来，我们继续看一下MySQL源码中ut_delay函数的功能：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-C\"\u003e/*************************************************************//**\nRuns an idle loop on CPU. The argument gives the desired delay\nin microseconds on 100 MHz Pentium + Visual C++.\n@return dummy value */\nulint\nut_delay(\n/*=====*/\n  ulint delay)  /*!\u0026lt; in: delay in microseconds on 100 MHz Pentium */\n{\n  ulint i, j;\n​\n  UT_LOW_PRIORITY_CPU();\n​\n  j = 0;\n​\n  for (i = 0; i \u0026lt; delay * 50; i++) {\n    j += i;\n    UT_RELAX_CPU();\n  }\n​\n  UT_RESUME_PRIORITY_CPU();\n​\n  return(j);\n}\n...\n​\n#   define UT_RELAX_CPU() asm (\u0026#34;pause\u0026#34; )\n#   define UT_RELAX_CPU() __asm__ __volatile__ (\u0026#34;pause\u0026#34;)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以了解到，MySQL自旋会调用PAUSE指令，从而提升spin-wait loop的性能。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3.2.2 PAUSE指令周期的演变\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们可以看下Intel官网，也描述了在新平台架构PAUSE的改动：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003ePause Latency in Skylake Microarchitecture\u003c/p\u003e\u003cp\u003eThe PAUSE instruction is typically used with software threads executing on two logical processors located in the same processor core, waiting for a lock to be released. Such short wait loops tend to last between tens and a few hundreds of cycles, so performance-wise it is better to wait while occupying the CPU than yielding to the OS. When the wait loop is expected to last for thousands of cycles or more, it is preferable to yield to the operating system by calling an OS synchronization API function, such as WaitForSingleObject on Windows* OS or futex on Linux.\u003c/p\u003e\u003cp\u003e…\u003c/p\u003e\u003cp\u003eThe latency of the PAUSE instruction in prior generation microarchitectures is about 10 cycles, whereas in Skylake microarchitecture it has been extended to as many as 140 cycles.\u003c/p\u003e\u003cp\u003eThe increased latency (allowing more effective utilization of competitively-shared microarchitectural resources to the logical processor ready to make forward progress) has a small positive performance impact of 1-2% on highly threaded applications. It is expected to have negligible impact on less threaded applications if forward progress is not blocked executing a fixed number of looped PAUSE instructions. There’s also a small power benefit in 2-core and 4-core systems.\u003c/p\u003e\u003cp\u003eAs the PAUSE latency has been increased significantly, workloads that are sensitive to PAUSE latency will suffer some performance loss.\u003c/p\u003e\u003cp\u003e…\u003c/p\u003e\u003c/blockquote\u003e\u003cul\u003e\u003cli\u003e上一代架构中（Grantly平台E系列）PAUSE的周期时长为10 cycles，新一代的Skylake架构中则为140 cycles。\u003c/li\u003e\u003cli\u003e如果程序中使用固定次数的PAUSE循环来实现一段时间的延迟，以此阻塞程序执行，可能引发非预期的延迟。\u003c/li\u003e\u003cli\u003e由于PAUSE周期增加，对于PAUSE敏感的应用会有一定的性能损失。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e衡量程序执行性能的简化公式：\u003c/p\u003e\u003cp\u003eExecutionTime(T)=InstructionCount∗TimePerCycle∗CPI\u003c/p\u003e\u003cp\u003e即：程序执行时间 = 程序总指令数 x 每CPU时钟周期时间 x 每指令执行所需平均时钟周期数。\u003c/p\u003e\u003cp\u003eMySQL内部自旋，就是通过固定次数的PAUSE循环实现。可知，PAUSE指令周期的增加，那么执行自旋的时间也会增加，即程序执行的时间也会相对增加，对系统整体的吞吐量就会有影响。\u003c/p\u003e\u003cp\u003e显然，Intel文档已说明不同平台、不同架构CPU PAUSE定义的周期是不一样的。\u003c/p\u003e\u003cp\u003e下面，我们通过一个测试用例来大致验证、对比一下新老架构CPU执行PAUSE的cycles：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-C\"\u003e #include \u0026lt;stdio.h\u0026gt;\n#define TIMES 5\n​\nstatic inline unsigned long long rdtsc(void)\n{\n    unsigned long low, high;\n    asm volatile(\u0026#34;rdtsc\u0026#34; : \u0026#34;=a\u0026#34; (low), \u0026#34;=d\u0026#34; (high) );\n    return ((low) | (high) \u0026lt;\u0026lt; 32);\n}\n​\nvoid pause_test()\n{\n    int i = 0;\n    for (i = 0; i \u0026lt; TIMES; i++) {\n        asm(\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\\\n                \u0026#34;pause\\n\u0026#34;\n                ::\n                :);\n    }\n}\n​\nunsigned long pause_cycle()\n{\n    unsigned long start, finish, elapsed;\n    start = rdtsc();\n    pause_test();\n    finish = rdtsc();\n    elapsed = finish - start;\n    printf(\u0026#34;Pause的cycles约为:%ld\\n\u0026#34;, elapsed / 100);\n    return 0;\n}\n​\nint main()\n{\n    pause_cycle();\n    return 0;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其运行结果统计如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/338a2e975a777a83d27ff7a6e349616551054.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e4110和5118 PAUSE周期较大，均为100多，它们属于Purley第一代架构：Skylake。\u003c/li\u003e\u003cli\u003e4210和5218 PAUSE相比前一代有提升，是因为它们同属Purley第二代架构：Cascadelake，该代CPU PAUSE指令有优化。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e3.2.3 Intel 提升PAUSE猜想\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eIntel提高PAUSE指令周期的原因，推测可能是减少自旋锁冲突的概率，以及降低功耗；但反而导致PAUSE执行时间变长，降低了整体的吞吐量。\u003c/p\u003e\u003cp\u003eThe increased latency (allowing more effective utilization of competitively-shared microarchitectural resources to the logical processor read to make forward progress) has a small positive performance impact of 1-2% on highly threaded applications. It is expected to have negligible impact on less threaded applications if forward progress is not blocked executing a fixed number of looped PAUSE instructions.\u003c/p\u003e\u003ch3 id=\"3-3-pause导致写瓶颈分析\"\u003e3.3 PAUSE导致写瓶颈分析\u003c/h3\u003e\u003cp\u003e接下来，我们深入分析一下PAUSE指令导致MySQL写瓶颈的原因。\u003c/p\u003e\u003cp\u003e首先，通过MySQL 内部统计信息，查看一下InnoDB信号量监控数据：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Shell\"\u003eSEMAPHORES\n----------\nOS WAIT ARRAY INFO: reservation count 153720\n--Thread 139868617205504 has waited at row0row.cc line 1075 for 0.00 seconds the semaphore:\nX-lock on RW-latch at 0x7f4298084250 created in file buf0buf.cc line 1425\na writer (thread id 139869284108032) has reserved it in mode  SX\nnumber of readers 0, waiters flag 1, lock_word: 10000000\nLast time read locked in file not yet reserved line 0\nLast time write locked in file /mnt/workspace/percona-server-5.7-redhat-binary-rocks-new/label_exp/min-centos-7-x64/test/rpmbuild/BUILD/percona-server-5.7.26-29/percona-server-5.7.26-29/storage/innobase/buf/buf0flu.cc line 1216\nOS WAIT ARRAY INFO: signal count 441329\nRW-shared spins 0, rounds 1498677, OS waits 111991\nRW-excl spins 0, rounds 717200, OS waits 9012\nRW-sx spins 47596, rounds 366136, OS waits 4100\nSpin rounds per wait: 1498677.00 RW-shared, 717200.00 RW-excl, 7.69 RW-sx\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可见写操作并阻塞在：storage/innobase/buf/buf0flu.cc第1216行调用上。\u003c/p\u003e\u003cp\u003e跟踪一下发生等待的源码：buf0flu.cc line 1216：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-C\"\u003e    if (flush_type == BUF_FLUSH_LIST\n        \u0026amp;\u0026amp; is_uncompressed\n        \u0026amp;\u0026amp; !rw_lock_sx_lock_nowait(rw_lock, BUF_IO_WRITE)) {    // 加锁前，判断锁冲突\n        \n        if (!fsp_is_system_temporary(bpage-\u0026gt;id.space())) {\n        /* avoiding deadlock possibility involves\n        doublewrite buffer, should flush it, because\n        it might hold the another block-\u0026gt;lock. */\n        buf_dblwr_flush_buffered_writes(\n          buf_parallel_dblwr_partition(bpage,\n                flush_type));\n      } else {\n        buf_dblwr_sync_datafiles();\n      }\n      rw_lock_sx_lock_gen(rw_lock, BUF_IO_WRITE);        //  加sx锁\n    }\n... \n #define rw_lock_sx_lock_nowait(M, P)       \\\n  rw_lock_sx_lock_low((M), (P), __FILE__, __LINE__)\n...\n​\nrw_lock_sx_lock_func(                                       // 加sx锁函数            \n/*=================*/\n  rw_lock_t*  lock, /*!\u0026lt; in: pointer to rw-lock */\n  ulint   pass, /*!\u0026lt; in: pass value; != 0, if the lock will\n        be passed to another thread to unlock */\n  const char* file_name,/*!\u0026lt; in: file name where lock requested */\n  ulint   line) /*!\u0026lt; in: line where requested */\n​\n{\n  ulint   i = 0;\n  sync_array_t* sync_arr;\n  ulint   spin_count = 0;\n  uint64_t  count_os_wait = 0;\n  ulint   spin_wait_count = 0;\n​\n  ut_ad(rw_lock_validate(lock));\n  ut_ad(!rw_lock_own(lock, RW_LOCK_S));\n​\nlock_loop:\n​\n  if (rw_lock_sx_lock_low(lock, pass, file_name, line)) {\n​\n    if (count_os_wait \u0026gt; 0) {\n      lock-\u0026gt;count_os_wait +=\n        static_cast\u0026lt;uint32_t\u0026gt;(count_os_wait);\n      rw_lock_stats.rw_sx_os_wait_count.add(count_os_wait);\n    }\n​\n    rw_lock_stats.rw_sx_spin_round_count.add(spin_count);\n    rw_lock_stats.rw_sx_spin_wait_count.add(spin_wait_count);\n​\n    /* Locking succeeded */\n    return;\n​\n  } else {\n​\n    ++spin_wait_count;\n​\n    /* Spin waiting for the lock_word to become free */\n    os_rmb;\n    while (i \u0026lt; srv_n_spin_wait_rounds\n           \u0026amp;\u0026amp; lock-\u0026gt;lock_word \u0026lt;= X_LOCK_HALF_DECR) {\n​\n      if (srv_spin_wait_delay) {\n        ut_delay(ut_rnd_interval(\n            0, srv_spin_wait_delay));                         // 加锁失败，调用ut_delay\n      }\n​\n      i++;\n    }                             \n​\n    spin_count += i;\n​\n    if (i \u0026gt;= srv_n_spin_wait_rounds) {\n​\n      os_thread_yield();\n​\n    } else {\n​\n      goto lock_loop;\n    }\n...\nulong srv_n_spin_wait_rounds  = 30;\nulong srv_spin_wait_delay = 6;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述源码可知，MySQL锁等待是通过调用ut_delay做空循环实现的。\u003c/p\u003e\u003cp\u003eInnoDB层有三种锁：S（共享锁）、X（排他锁）和SX（共享排他锁）。 SX与SX、X是互斥锁。加SX不会影响读，只会阻塞写。所以在大量写入操作时，会造成大量的锁等待，即大量的PAUSE指令。\u003c/p\u003e\u003cp\u003e分析到这里，我们总结一下影响吞吐量的两个因素：\u003c/p\u003e\u003cul\u003e\u003cli\u003e自旋的时长，在MySQL5.7以及之前版本的源码定位为：spin_wait_delay * 50。\u003c/li\u003e\u003cli\u003eIntel CPU PAUSE的指令周期。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e接下来，我们就从这两方面入手，评估优化空间以及效果。\u003c/p\u003e\u003ch2 id=\"4-针对pause指令和spin参数优化与探索\"\u003e4. 针对PAUSE指令和spin参数优化与探索\u003c/h2\u003e\u003ch3 id=\"4-1-mysql-spin参数优化\"\u003e4.1 MySQL spin参数优化\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e4.1.1 MySQL 5.7 spin参数优化\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e我们可以基于现有MySQL版本、硬件等方面，来寻找优化点。\u003c/p\u003e\u003cp\u003eMySQL针对spin控制这块有个参数可以调整，根据参数特点进行相关优化：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003einnodb_spin_wait_delay\u003c/strong\u003e\u003c/p\u003e\u003cp\u003einnodb_spin_wait_delay的单位，是100MHZ的奔腾处理器处理1毫秒的时间，默认innodb_spin_wait_delay配置成6，表示最多在100MHZ的奔腾处理器上自旋6毫秒。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003einnodb_sync_spin_loops\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e当 innodb 线程获取 mutex 资源而得不到满足时，会最多进行 innodb_sync_spin_loops次尝试获取mutex资源。\u003c/p\u003e\u003cp\u003e其中innodb_spin_wait_delay参数对PAUSE运行时长是有影响的。针对此参数，我们进行调优测试。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b44ff26bdae34db4709ca2f95233823332179.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e同样，针对上述参数优化，我们通过基准测试来对比性能和效果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/5073f4289eecd16a189bbb3745298551128912.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e可以总结为：\u003c/p\u003e\u003cul\u003e\u003cli\u003einnodb_spin_wait_delay的调整对TPS、QPS 一定影响，其值趋于小，则MySQL性能有提升。反之，下降。\u003c/li\u003e\u003cli\u003einnodb_spin_wait_delay参数调整性能优化效果有限，性能提升的幅度还是无法满足线上业务需求。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"4-2-mysql8-0-spin新特性移植\"\u003e4.2 MySQL8.0 spin新特性移植\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e4.2.1 spin_wait_pause_multiplier移植\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e针对Skylake CPU，PAUSE造成的吞吐量下降，我们对MySQL 5.7 spin控制参数innodb_spin_wait_delay的调优并未取得明显效果。\u003c/p\u003e\u003cp\u003e于是，我们将目光投向了MySQL 8.0的新特性：MySQL 8.0 针对PAUSE，源码中新增了spin_wait_pause_multiplier参数，来替换之前写死的循环次数。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e4.2.2 spin_wait_pause_multiplier实现\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eMySQL 8.0源码中，之前循环50次的逻辑修改成了可以调整循环次数的参数：spin_wait_pause_multiplier。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-C\"\u003eulint ut_delay(ulint delay) {\n  ulint i, j;\n  /* We don\u0026#39;t expect overflow here, as ut::spin_wait_pause_multiplier is limited\n  to 100, and values of delay are not larger than @@innodb_spin_wait_delay\n  which is limited by 1 000. Anyway, in case an overflow happened, the program\n  would still work (as iterations is unsigned). */\n  const ulint iterations = delay * ut::spin_wait_pause_multiplier;\n  UT_LOW_PRIORITY_CPU();\n​\n  j = 0;\n​\n  for (i = 0; i \u0026lt; iterations; i++) {\n    j += i;\n    UT_RELAX_CPU();\n  }\n​\n  UT_RESUME_PRIORITY_CPU();\n​\n  return (j);\n}\n...\nnamespace ut {\nulong spin_wait_pause_multiplier = 50;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e4.2.3 移植spin_wait_pause_multiplier patch优化\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e既然MySQL 8.0参数spin_wait_pause_multiplier可以控制PAUSE执行的时长，那么就可以减少该值，从而降低整体PAUSE影响。\u003c/p\u003e\u003cp\u003e了解MySQL 8.0相关代码后，我们将该patch移植到线上的稳定版本：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-SQL\"\u003eMySQ \u0026gt;select version();\n+------------------+\n| version()        |\n+------------------+\n| 5.7.26-29-mt-log |\n+------------------+\n1 row in set (0.00 sec)\n​\nMySQL\u0026gt;show global variables like \u0026#39;%spin%\u0026#39;;  \n+-----------------------------------+-------+\n| Variable_name                     | Value |\n+-----------------------------------+-------+\n| innodb_spin_wait_delay            | 6     |\n| innodb_spin_wait_pause_multiplier | 5     |\n| innodb_sync_spin_loops            | 30    |\n+-----------------------------------+-------+\n3 rows in set (0.00 sec)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e由上述可知，Silver 4110的PAUSE cycles是E5-2620 v4的14倍左右。基于此，将innodb_spin_wait_pause_multiplier值调整为默认值的1/14，取稍大值：5。即将该参数由原默认的50调整为5。\u003c/p\u003e\u003cp\u003e最后，还是通过二维折线图来对比该patch调优后的基准测试数据：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/2217adabff752f2e76921e08deb7aa4f148650.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eSilver 4110移植spin_wait_pause_multiplier patch，并调整优化后，4110（patch）性能有了较大的提升。\u003c/li\u003e\u003cli\u003eSilver 4110（patch） 相对调优innodb_spin_wait_delay性能上更优。\u003c/li\u003e\u003cli\u003eSilver 4110（patch）并发线程大于64的只写场景，性能略低于E5-2620 V4 ，其他均优。\u003c/li\u003e\u003cli\u003e按照真实的线上读写比例，4110（patch）可以将吞吐量恢复到原先的性能水平。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"4-3-pause指令周期优化\"\u003e4.3 PAUSE指令周期优化\u003c/h3\u003e\u003cp\u003e上述章节中，我们测出Cascadelake CPU PAUSE周期下降了。在跟Intel技术专家确认后得知：从Purley的第二代产品Cascadelake开始，Intel将PAUSE的指令周期降低到了44。（估计Intel也发现了第一代增加PAUSE周期后的性能瓶颈问题。）\u003c/p\u003e\u003cp\u003e我们针对第二代CPU产品\b继续做基准测试，来看一下性能表现：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/dbd637342ca3faced84a0bd07c0a138a133960.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e接着用perf diff来对比一下4110和4210在ut_delay上的开销：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/3be9e418726470d95a20325deb61e4d2228109.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e可以看到4210比4110占比下降了8%。\u003c/li\u003e\u003cli\u003e由于PAUSE指令周期还是数倍于E5系列CPU，4210在高负载下，PAUSE的开销对MySQL吞吐量还是有较大的影响。而在128并发线程以下，性能相比4110有了较大的提升。按理，可以满足线上业务需求（该测试结果跟移植spin_wait_pause_multiplier patch性能测试数据曲线一致）。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"5-总结\"\u003e5. 总结\u003c/h2\u003e\u003cp\u003e最后针对本篇内容，我们可以做个简单的总结：\u003c/p\u003e\u003cp\u003eIntel在新平台CPU产品调大了PAUSE指令周期，在高并发spinlock竞争激烈场景下，可能会造成程序性能较大损耗（特别是执行固定PAUSE次数的程序）。\n针对Skylake架构CPU（比如：4110等）PAUSE指令周期较长引起性能问题的优化方法如下：\u003c/p\u003e\u003cp\u003e将MySQL 8.0 innodb_spin_wait_pause_multiplier patch移植到线上稳定版本（或升级到MySQL 8.0），通过降低PAUSE执行时长，来提升吞吐量。\n如果是OS为CentOS 6，可以升级到CentOS 7，CentOS 7本身spinlock优化，对MySQL性能也有一定提升。\n最简单、直接的方法可以替换为Cascadelake架构CPU。\u003c/p\u003e\u003cp\u003e针对Cascadelake架构CPU，由于Intel本身在PAUSE周期已经优化，性能上已经做了修复。当然也可以采用上述优化方案，让性能提升一个台阶。\u003c/p\u003e\u003ch2 id=\"6-作者简介\"\u003e6. 作者简介\u003c/h2\u003e\u003cp\u003e春林，2017年加入美团，主要负责MySQL运维开发和优化工作。\u003c/p\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团DBA团队招聘各类人才，Base北京、上海均可。我们致力于为公司提供稳定、可靠、高效的在线存储服务，打造业界领先的数据库团队。这里有数万各类架构的MySQL实例，每天提供万亿级的OLTP访问请求。真正的海量、分布式、高并发环境。欢迎感兴趣的同学发送简历至：tech@meituan.com（邮件标题注明：美团DBA团队）\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2020-04-16T00:00:00Z",
  "Author": "soulteary@gmail.com"
}