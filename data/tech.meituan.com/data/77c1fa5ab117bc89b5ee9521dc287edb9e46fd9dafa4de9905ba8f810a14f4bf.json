{
  "Source": "tech.meituan.com",
  "Title": "Node.js Stream - 实战篇",
  "Link": "https://tech.meituan.com/2016/07/22/stream-in-action.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e前面两篇（\u003ca href=\"stream-basics.html\"\u003e基础篇\u003c/a\u003e和\u003ca href=\"stream-internals.html\"\u003e进阶篇\u003c/a\u003e）主要介绍流的基本用法和原理，本篇从应用的角度，介绍如何使用管道进行程序设计，主要内容包括：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"#pipeline\"\u003e管道的概念\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#browserify\"\u003eBrowserify的管道设计\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#gulp\"\u003eGulp的管道设计\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#两种模式比较\"\u003e两种管道设计模式比较\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"#实例\"\u003e实例\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e所谓“管道”，指的是通过\u003ccode\u003ea.pipe(b)\u003c/code\u003e的形式连接起来的多个Stream对象的组合。\u003c/p\u003e\u003cp\u003e假如现在有两个\u003ccode\u003eTransform\u003c/code\u003e：\u003ccode\u003ebold\u003c/code\u003e和\u003ccode\u003ered\u003c/code\u003e，分别可将文本流中某些关键字加粗和飘红。\n可以按下面的方式对文本同时加粗和飘红：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// source: 输入流\n// dest: 输出目的地\nsource.pipe(bold).pipe(red).pipe(dest)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003ebold.pipe(red)\u003c/code\u003e便可以看作一个管道，输入流先后经过\u003ccode\u003ebold\u003c/code\u003e和\u003ccode\u003ered\u003c/code\u003e的变换再输出。\u003c/p\u003e\u003cp\u003e但如果这种加粗且飘红的功能的应用场景很广，我们期望的使用方式是：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// source: 输入流\n// dest: 输出目的地\n// pipeline: 加粗且飘红\nsource.pipe(pipeline).pipe(dest)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e此时，\u003ccode\u003epipeline\u003c/code\u003e封装了\u003ccode\u003ebold.pipe(red)\u003c/code\u003e，从逻辑上来讲，也称其为管道。\n其实现可简化为：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar pipeline = new Duplex()\nvar streams = pipeline._streams = [bold, red]\n\n// 底层写逻辑：将数据写入管道的第一个Stream，即bold\npipeline._write = function (buf, enc, next) {\n  streams[0].write(buf, enc, next)\n}\n\n// 底层读逻辑：从管道的最后一个Stream（即red）中读取数据\npipeline._read = function () {\n  var buf\n  var reads = 0\n  var r = streams[streams.length - 1]\n  // 将缓存读空\n  while ((buf = r.read()) !== null) {\n    pipeline.push(buf)\n    reads++\n  }\n  if (reads === 0) {\n    // 缓存本来为空，则等待新数据的到来\n    r.once(\u0026#39;readable\u0026#39;, function () {\n      pipeline._read()\n    })\n  }\n}\n\n// 将各个Stream组合起来（此处等同于`bold.pipe(red)`）\nstreams.reduce(function (r, next) {\n  r.pipe(next)\n  return next\n})\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e往\u003ccode\u003epipeline\u003c/code\u003e写数据时，数据直接写入\u003ccode\u003ebold\u003c/code\u003e，再流向\u003ccode\u003ered\u003c/code\u003e，最后从\u003ccode\u003epipeline\u003c/code\u003e读数据时再从\u003ccode\u003ered\u003c/code\u003e中读出。\u003c/p\u003e\u003cp\u003e如果需要在中间新加一个\u003ccode\u003eunderline\u003c/code\u003e的Stream，可以：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003epipeline._streams.splice(1, 0, underline)\nbold.unpipe(red)\nbold.pipe(underline).pipe(red)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果要将\u003ccode\u003ered\u003c/code\u003e替换成\u003ccode\u003egreen\u003c/code\u003e，可以：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// 删除red\npipeline._streams.pop()\nbold.unpipe(red)\n\n// 添加green\npipeline._streams.push(green)\nbold.pipe(green)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可见，这种管道的各个环节是可以修改的。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/stream-splicer\"\u003estream-splicer\u003c/a\u003e对上述逻辑进行了进一步封装，提供\u003ccode\u003esplice\u003c/code\u003e、\u003ccode\u003epush\u003c/code\u003e、\u003ccode\u003epop\u003c/code\u003e等方法，使得\u003ccode\u003epipeline\u003c/code\u003e可以像数组那样被修改：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar splicer = require(\u0026#39;stream-splicer\u0026#39;)\nvar pipeline = splicer([bold, red])\n// 在中间添加underline\npipeline.splice(1, 0, underline)\n\n// 删除red\npipeline.pop()\n\n// 添加green\npipeline.push(green)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/labeled-stream-splicer\"\u003elabeled-stream-splicer\u003c/a\u003e在此基础上又添加了使用名字替代下标进行操作的功能：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar splicer = require(\u0026#39;labeled-stream-splicer\u0026#39;)\nvar pipeline = splicer([\n  \u0026#39;bold\u0026#39;, bold,\n  \u0026#39;red\u0026#39;, red,\n])\n\n// 在`red`前添加underline\npipeline.splice(\u0026#39;red\u0026#39;, 0, underline)\n\n// 删除`bold`\npipeline.splice(\u0026#39;bold\u0026#39;, 1)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e由于\u003ccode\u003epipeline\u003c/code\u003e本身与其各个环节一样，也是一个Stream对象，因此可以嵌套：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar splicer = require(\u0026#39;labeled-stream-splicer\u0026#39;)\nvar pipeline = splicer([\n  \u0026#39;style\u0026#39;, [ bold, red ],\n  \u0026#39;insert\u0026#39;, [ comma ],\n])\n\npipeline.get(\u0026#39;style\u0026#39;)     // 取得管道：[bold, red]\n  .splice(1, 0, underline) // 添加underline\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e的功能介绍可见\u003ca href=\"https://github.com/substack/browserify-handbook\"\u003esubstack/browserify-handbook\u003c/a\u003e，其核心逻辑的实现在于管道的设计：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar splicer = require(\u0026#39;labeled-stream-splicer\u0026#39;)\nvar pipeline = splicer.obj([\n    // 记录输入管道的数据，重建管道时直接将记录的数据写入。\n    // 用于像watch时需要多次打包的情况\n    \u0026#39;record\u0026#39;, [ this._recorder() ],\n    // 依赖解析，预处理\n    \u0026#39;deps\u0026#39;, [ this._mdeps ],\n    // 处理JSON文件\n    \u0026#39;json\u0026#39;, [ this._json() ],\n    // 删除文件前面的BOM\n    \u0026#39;unbom\u0026#39;, [ this._unbom() ],\n    // 删除文件前面的`#!`行\n    \u0026#39;unshebang\u0026#39;, [ this._unshebang() ],\n    // 语法检查\n    \u0026#39;syntax\u0026#39;, [ this._syntax() ],\n    // 排序，以确保打包结果的稳定性\n    \u0026#39;sort\u0026#39;, [ depsSort(dopts) ],\n    // 对拥有同样内容的模块去重\n    \u0026#39;dedupe\u0026#39;, [ this._dedupe() ],\n    // 将id从文件路径转换成数字，避免暴露系统路径信息\n    \u0026#39;label\u0026#39;, [ this._label(opts) ],\n    // 为每个模块触发一次dep事件\n    \u0026#39;emit-deps\u0026#39;, [ this._emitDeps() ],\n    \u0026#39;debug\u0026#39;, [ this._debug(opts) ],\n    // 将模块打包\n    \u0026#39;pack\u0026#39;, [ this._bpack ],\n    // 更多自定义的处理\n    \u0026#39;wrap\u0026#39;, [],\n])\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每个模块用\u003ccode\u003erow\u003c/code\u003e表示，定义如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e{\n  // 模块的唯一标识\n  id: id,\n  // 模块对应的文件路径\n  file: \u0026#39;/path/to/file\u0026#39;,\n  // 模块内容\n  source: \u0026#39;\u0026#39;,\n  // 模块的依赖\n  deps: {\n    // `require(expr)`\n    expr: id,\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在\u003ccode\u003ewrap\u003c/code\u003e阶段前，所有的阶段都处理这样的对象流，且除\u003ccode\u003epack\u003c/code\u003e外，都输出这样的流。\n有的补充\u003ccode\u003erow\u003c/code\u003e中的一些信息，有的则对这些信息做一些变换，有的只是读取和输出。\n一般\u003ccode\u003erow\u003c/code\u003e中的\u003ccode\u003esource\u003c/code\u003e、\u003ccode\u003edeps\u003c/code\u003e内容都是在\u003ccode\u003edeps\u003c/code\u003e阶段解析出来的。\u003c/p\u003e\u003cp\u003e下面提供一个修改\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e管道的函数。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar Transform = require(\u0026#39;stream\u0026#39;).Transform\n// 创建Transform对象\nfunction through(write, end) {\n  return Transform({\n    transform: write,\n    flush: end,\n  })\n}\n\n// `b`为Browserify实例\n// 该插件可打印出打包时间\nfunction log(b) {\n  // watch时需要重新打包，整个pipeline会被重建，所以也要重新修改\n  b.on(\u0026#39;reset\u0026#39;, reset)\n  // 修改当前pipeline\n  reset()\n\n  function reset () {\n    var time = null\n    var bytes = 0\n    b.pipeline.get(\u0026#39;record\u0026#39;).on(\u0026#39;end\u0026#39;, function () {\n      // 以record阶段结束为起始时刻\n      time = Date.now()\n    })\n\n    // `wrap`是最后一个阶段，在其后添加记录结束时刻的Transform\n    b.pipeline.get(\u0026#39;wrap\u0026#39;).push(through(write, end))\n    function write (buf, enc, next) {\n      // 累计大小\n      bytes += buf.length\n      this.push(buf)\n      next()\n    }\n    function end () {\n      // 打包时间\n      var delta = Date.now() - time\n      b.emit(\u0026#39;time\u0026#39;, delta)\n      b.emit(\u0026#39;bytes\u0026#39;, bytes)\n      b.emit(\u0026#39;log\u0026#39;, bytes + \u0026#39; bytes written (\u0026#39;\n        + (delta / 1000).toFixed(2) + \u0026#39; seconds)\u0026#39;\n      )\n      this.push(null)\n    }\n  }\n}\n\nvar fs = require(\u0026#39;fs\u0026#39;)\nvar browserify = require(\u0026#39;browserify\u0026#39;)\nvar b = browserify(opts)\n// 应用插件\nb.plugin(log)\nb.bundle().pipe(fs.createWriteStream(\u0026#39;bundle.js\u0026#39;))\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e事实上，这里的\u003ccode\u003eb.plugin(log)\u003c/code\u003e就是直接执行了\u003ccode\u003elog(b)\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e在插件中，可以修改\u003ccode\u003eb.pipeline\u003c/code\u003e中的任何一个环节。\n因此，\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e本身只保留了必要的功能，其它都由插件去实现，如\u003ca href=\"https://github.com/substack/watchify\"\u003ewatchify\u003c/a\u003e、\u003ca href=\"https://github.com/substack/factor-bundle\"\u003efactor-bundle\u003c/a\u003e等。\u003c/p\u003e\u003cp\u003e除了了上述的插件机制外，\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e还有一套Transform机制，即通过\u003ccode\u003eb.transform(transform)\u003c/code\u003e可以新增一些文件内容预处理的Transform。\n预处理是发生在\u003ccode\u003edeps\u003c/code\u003e阶段的，当模块文件内容被读出来时，会经过这些Transform处理，然后才做依赖解析，如\u003ca href=\"https://github.com/babel/babelify\"\u003ebabelify\u003c/a\u003e、\u003ca href=\"https://github.com/hughsk/envify\"\u003eenvify\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e的核心逻辑分成两块：任务调度与文件处理。\n任务调度是基于\u003ca href=\"https://github.com/robrich/orchestrator\"\u003eorchestrator\u003c/a\u003e，而文件处理则是基于\u003ca href=\"https://github.com/gulpjs/vinyl-fs\"\u003evinyl-fs\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e类似于\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e提供的模块定义（用\u003ccode\u003erow\u003c/code\u003e表示），\u003ca href=\"https://github.com/gulpjs/vinyl-fs\"\u003evinyl-fs\u003c/a\u003e也提供了文件定义（\u003ca href=\"https://github.com/gulpjs/vinyl\"\u003evinyl\u003c/a\u003e对象）。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e的管道处理的是\u003ccode\u003erow\u003c/code\u003e流，\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e管道处理\u003ca href=\"https://github.com/gulpjs/vinyl\"\u003evinyl\u003c/a\u003e流：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003egulp.task(\u0026#39;scripts\u0026#39;, [\u0026#39;clean\u0026#39;], function() {\n  // Minify and copy all JavaScript (except vendor scripts) \n  // with sourcemaps all the way down \n  return gulp.src(paths.scripts)\n    .pipe(sourcemaps.init())\n    .pipe(coffee())\n    .pipe(uglify())\n    .pipe(concat(\u0026#39;all.min.js\u0026#39;))\n    .pipe(sourcemaps.write())\n    .pipe(gulp.dest(\u0026#39;build/js\u0026#39;));\n});\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e任务中创建的管道起始于\u003ccode\u003egulp.src\u003c/code\u003e，终止于\u003ccode\u003egulp.dest\u003c/code\u003e，中间有若干其它的Transform（插件）。\u003c/p\u003e\u003cp\u003e如果与\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e的管道对比，可以发现\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e是确定了一条具有完整功能的管道，而\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e本身只提供了创建\u003ca href=\"https://github.com/gulpjs/vinyl\"\u003evinyl\u003c/a\u003e流和将\u003ca href=\"https://github.com/gulpjs/vinyl\"\u003evinyl\u003c/a\u003e流写入磁盘的工具，管道中间经历什么全由用户决定。\n这是因为任务中做什么，是没有任何限制的，文件处理也只是常见的情况，并非一定要用\u003ccode\u003egulp.src\u003c/code\u003e与\u003ccode\u003egulp.dest\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e与\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e都借助管道的概念来实现插件机制。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e定义了模块的数据结构，提供了默认的管道以处理这样的数据流，而插件可用来修改管道结构，以定制处理行为。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e虽也定义了文件的数据结构，但只提供产生、消耗这种数据流的接口，完全由用户通过插件去构造处理管道。\u003c/p\u003e\u003cp\u003e当明确具体的处理需求时，可以像\u003ca href=\"https://github.com/substack/node-browserify\"\u003eBrowserify\u003c/a\u003e那样，构造一个基本的处理管道，以提供插件机制。\n如果需要的是实现任意功能的管道，可以如\u003ca href=\"https://github.com/gulpjs/gulp\"\u003eGulp\u003c/a\u003e那样，只提供数据流的抽象。\u003c/p\u003e\u003cp\u003e本节中实现一个针对\u003ca href=\"https://git-scm.com/\"\u003eGit\u003c/a\u003e仓库自动生成changelog的工具，完整代码见\u003ca href=\"https://github.com/zoubin/ezchangelog\"\u003eezchangelog\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://github.com/zoubin/ezchangelog\"\u003eezchangelog\u003c/a\u003e的输入为\u003ccode\u003egit log\u003c/code\u003e生成的文本流，输出默认为markdown格式的文本流，但可以修改为任意的自定义格式。\u003c/p\u003e\u003cp\u003e输入示意：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ecommit 9c5829ce45567bedccda9beb7f5de17574ea9437\nAuthor: zoubin \u0026lt;zoubin04@gmail.com\u0026gt;\nDate:   Sat Nov 7 18:42:35 2015 +0800\n\n    CHANGELOG\n\ncommit 3bf9055b732cc23a9c14f295ff91f48aed5ef31a\nAuthor: zoubin \u0026lt;zoubin04@gmail.com\u0026gt;\nDate:   Sat Nov 7 18:41:37 2015 +0800\n\n    4.0.3\n\ncommit 87abe8e12374079f73fc85c432604642059806ae\nAuthor: zoubin \u0026lt;zoubin04@gmail.com\u0026gt;\nDate:   Sat Nov 7 18:41:32 2015 +0800\n\n    fix readme\n    add more tests\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e输出示意：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003e* [[`9c5829c`](https://github.com/zoubin/ezchangelog/commit/9c5829c)] CHANGELOG\n\n## [v4.0.3](https://github.com/zoubin/ezchangelog/commit/3bf9055) (2015-11-07)\n\n* [[`87abe8e`](https://github.com/zoubin/ezchangelog/commit/87abe8e)] fix readme\n\n    add more tests\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e其实需要的是这样一个\u003ccode\u003epipeline\u003c/code\u003e：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003esource.pipe(pipeline).pipe(dest)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以分为两个阶段：\n* parse：从输入文本流中解析出commit信息\n* format: 将commit流变换为文本流\u003c/p\u003e\u003cp\u003e默认的情况下，要想得到示例中的markdown，需要解析出每个commit的sha1、日期、消息、是否为tag。\n定义commit的格式如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e{\n  commit: {\n    // commit sha1\n    long: \u0026#39;3bf9055b732cc23a9c14f295ff91f48aed5ef31a\u0026#39;,\n    short: \u0026#39;3bf9055\u0026#39;,\n  },\n  committer: {\n    // commit date\n    date: new Date(\u0026#39;Sat Nov 7 18:41:37 2015 +0800\u0026#39;),\n  },\n  // raw message lines\n  messages: [\u0026#39;\u0026#39;, \u0026#39;    4.0.3\u0026#39;, \u0026#39;\u0026#39;],\n  // raw headers before the messages\n  headers: [\n    [\u0026#39;Author\u0026#39;, \u0026#39;zoubin \u0026lt;zoubin04@gmail.com\u0026gt;\u0026#39;],\n    [\u0026#39;Date\u0026#39;, \u0026#39;Sat Nov 7 18:41:37 2015 +0800\u0026#39;],\n  ],\n  // the first non-empty message line\n  subject: \u0026#39;4.0.3\u0026#39;,\n  // other message lines\n  body: \u0026#39;\u0026#39;,\n  // git tag\n  tag: \u0026#39;v4.0.3\u0026#39;,\n  // link to the commit. opts.baseUrl should be specified.\n  url: \u0026#39;https://github.com/zoubin/ezchangelog/commit/3bf9055\u0026#39;,\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e于是有：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar splicer = require(\u0026#39;labeled-stream-splicer\u0026#39;)\npipeline = splicer.obj([\n  \u0026#39;parse\u0026#39;, [\n    // 按行分隔\n    \u0026#39;split\u0026#39;, split(),\n    // 生成commit对象，解析出sha1和日期\n    \u0026#39;commit\u0026#39;, commit(),\n    // 解析出tag\n    \u0026#39;tag\u0026#39;, tag(),\n    // 解析出url\n    \u0026#39;url\u0026#39;, url({ baseUrl: opts.baseUrl }),\n  ],\n  \u0026#39;format\u0026#39;, [\n    // 将commit组合成markdown文本\n    \u0026#39;markdownify\u0026#39;, markdownify(),\n  ],\n])\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e至此，基本功能已经实现。\n现在将其封装并提供插件机制。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction Changelog(opts) {\n  opts = opts || {}\n  this._options = opts\n  // 创建pipeline\n  this.pipeline = splicer.obj([\n    \u0026#39;parse\u0026#39;, [\n      \u0026#39;split\u0026#39;, split(),\n      \u0026#39;commit\u0026#39;, commit(),\n      \u0026#39;tag\u0026#39;, tag(),\n      \u0026#39;url\u0026#39;, url({ baseUrl: opts.baseUrl }),\n    ],\n    \u0026#39;format\u0026#39;, [\n      \u0026#39;markdownify\u0026#39;, markdownify(),\n    ],\n  ])\n\n  // 应用插件\n  ;[].concat(opts.plugin).filter(Boolean).forEach(function (p) {\n    this.plugin(p)\n  }, this)\n}\n\nChangelog.prototype.plugin = function (p, opts) {\n  if (Array.isArray(p)) {\n    opts = p[1]\n    p = p[0]\n  }\n  // 执行插件函数，修改pipeline\n  p(this, opts)\n  return this\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面的实现提供了两种方式来应用插件。\n一种是通过配置传入，另一种是创建实例后再调用\u003ccode\u003eplugin\u003c/code\u003e方法，本质一样。\u003c/p\u003e\u003cp\u003e为了使用方便，还可以简单封装一下。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003efunction changelog(opts) {\n  return new Changelog(opts).pipeline\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样，就可以如下方式使用：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003esource.pipe(changelog()).pipe(dest)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这个已经非常接近我们的预期了。\u003c/p\u003e\u003cp\u003e现在来开发一个插件，修改默认的渲染方式。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003evar through = require(\u0026#39;through2\u0026#39;)\n\nfunction customFormatter(c) {\n  // c是`Changelog`实例\n\n  // 添加解析author的transform\n  c.pipeline.get(\u0026#39;parse\u0026#39;).push(through.obj(function (ci, enc, next) {\n    // parse the author name from: \u0026#39;zoubin \u0026lt;zoubin04@gmail.com\u0026gt;\u0026#39;\n    ci.committer.author = ci.headers[0][1].split(/\\s+/)[0]\n    next(null, ci)\n  }))\n\n  // 替换原有的渲染\n  c.pipeline.get(\u0026#39;format\u0026#39;).splice(\u0026#39;markdownify\u0026#39;, 1, through.obj(function (ci, enc, next) {\n    var sha1 = ci.commit.short\n    sha1 = \u0026#39;[`\u0026#39; + sha1 + \u0026#39;`](\u0026#39; + c._options.baseUrl + sha1 + \u0026#39;)\u0026#39;\n    var date = ci.committer.date.toISOString().slice(0, 10)\n    next(null, \u0026#39;* \u0026#39; + sha1 + \u0026#39; \u0026#39; + date + \u0026#39; @\u0026#39; + ci.committer.author + \u0026#39;\\n\u0026#39;)\n  }))\n}\n\nsource\n  .pipe(changelog({\n    baseUrl: \u0026#39;https://github.com/zoubin/ezchangelog/commit/\u0026#39;,\n    plugin: [customFormatter],\n  }))\n  .pipe(dest)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同样的输入，输出将会是：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-markdown\"\u003e* [`9c5829c`](https://github.com/zoubin/ezchangelog/commit/9c5829c) 2015-11-07 @zoubin\n* [`3bf9055`](https://github.com/zoubin/ezchangelog/commit/3bf9055) 2015-11-07 @zoubin\n* [`87abe8e`](https://github.com/zoubin/ezchangelog/commit/87abe8e) 2015-11-07 @zoubin\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看出，通过创建可修改的管道，\u003ca href=\"https://github.com/zoubin/ezchangelog\"\u003eezchangelog\u003c/a\u003e保持了本身逻辑的单一性，同时又提供了强大的自定义空间。\u003c/p\u003e\u003cul\u003e\u003cli\u003eGitHub，\u003ca href=\"https://github.com/substack/browserify-handbook\"\u003esubstack/browserify-handbook\u003c/a\u003e\u003c/li\u003e\u003cli\u003eGitHub，\u003ca href=\"https://github.com/zoubin/streamify-your-node-program\"\u003ezoubin/streamify-your-node-program\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-07-22T00:00:00Z",
  "Author": "soulteary@gmail.com"
}