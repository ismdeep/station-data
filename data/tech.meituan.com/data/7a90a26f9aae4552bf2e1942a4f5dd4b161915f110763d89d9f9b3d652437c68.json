{
  "Source": "tech.meituan.com",
  "Title": "Kotlin代码检查在美团的探索与实践",
  "Link": "https://tech.meituan.com/2018/07/05/kotlin-code-inspect.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003eKotlin有着诸多的特性，比如空指针安全、方法扩展、支持函数式编程、丰富的语法糖等。这些特性使得Kotlin的代码比Java简洁优雅许多，提高了代码的可读性和可维护性，节省了开发时间，提高了开发效率。这也是我们团队转向Kotlin的原因，但是在实际的使用过程中，我们发现看似写法简单的Kotlin代码，可能隐藏着不容忽视的额外开销。本文剖析了Kotlin的隐藏开销，并就如何避免开销进行了探索和实践。\u003c/p\u003e\u003ch2 id=\"kotlin的隐藏开销\"\u003eKotlin的隐藏开销\u003c/h2\u003e\u003ch3 id=\"伴生对象\"\u003e伴生对象\u003c/h3\u003e\u003cp\u003e伴生对象通过在类中使用\u003ccode\u003ecompanion object\u003c/code\u003e来创建，用来替代静态成员，类似于Java中的静态内部类。所以在伴生对象中声明常量是很常见的做法，但如果写法不对，可能就会产生额外开销。比如下面这段声明\u003ccode\u003eVersion\u003c/code\u003e常量的代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eclass Demo {\n\n    fun getVersion(): Int {\n        return Version\n    }\n\n    companion object {\n        private val Version = 1\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e表面上看还算简洁，但是将这段Kotlin代码转化成等同的Java代码后，却显得晦涩难懂：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class Demo {\n    private static final int Version = 1;\n    public static final Demo.Companion Companion = new Demo.Companion();\n\n    public final int getVersion() {\n        return Companion.access$getVersion$p(Companion);\n    }\n\n    public static int access$getVersion$cp() {\n        return Version;\n    }\n\n    public static final class Companion {\n        private static int access$getVersion$p(Companion companion) {\n            return companion.getVersion();\n        }\n\n        private int getVersion() {\n            return Demo.access$getVersion$cp();\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e与Java直接读取一个常量不同，Kotlin访问一个伴生对象的私有常量字段需要经过以下方法：\u003c/p\u003e\u003cul\u003e\u003cli\u003e调用伴生对象的静态方法\u003c/li\u003e\u003cli\u003e调用伴生对象的实例方法\u003c/li\u003e\u003cli\u003e调用主类的静态方法\u003c/li\u003e\u003cli\u003e读取主类中的静态字段\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e为了访问一个常量，而多花费调用4个方法的开销，这样的Kotlin代码无疑是低效的。\u003c/p\u003e\u003cp\u003e我们可以通过以下解决方法来减少生成的字节码：\u003c/p\u003e\u003col\u003e\u003cli\u003e对于基本类型和字符串，可以使用\u003ccode\u003econst\u003c/code\u003e关键字将常量声明为编译时常量。\u003c/li\u003e\u003cli\u003e对于公共字段，可以使用\u003ccode\u003e@JvmField\u003c/code\u003e注解。\u003c/li\u003e\u003cli\u003e对于其他类型的常量，最好在它们自己的主类对象而不是伴生对象中来存储公共的全局常量。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"lazy-委托属性\"\u003eLazy()委托属性\u003c/h3\u003e\u003cp\u003e\u003ccode\u003elazy()\u003c/code\u003e委托属性可以用于只读属性的惰性加载，但是在使用\u003ccode\u003elazy()\u003c/code\u003e时经常被忽视的地方就是有一个可选的model参数：\u003c/p\u003e\u003cul\u003e\u003cli\u003eLazyThreadSafetyMode.SYNCHRONIZED：初始化属性时会有双重锁检查，保证该值只在一个线程中计算，并且所有线程会得到相同的值。\u003c/li\u003e\u003cli\u003eLazyThreadSafetyMode.PUBLICATION：多个线程会同时执行，初始化属性的函数会被多次调用，但是只有第一个返回的值被当做委托属性的值。\u003c/li\u003e\u003cli\u003eLazyThreadSafetyMode.NONE：没有双重锁检查，不应该用在多线程下。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003elazy()\u003c/code\u003e默认情况下会指定\u003ccode\u003eLazyThreadSafetyMode.SYNCHRONIZED\u003c/code\u003e，这可能会造成不必要线程安全的开销，应该根据实际情况，指定合适的model来避免不需要的同步锁。\u003c/p\u003e\u003ch3 id=\"基本类型数组\"\u003e基本类型数组\u003c/h3\u003e\u003cp\u003e在Kotlin中有3种数组类型：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eIntArray\u003c/code\u003e，\u003ccode\u003eFloatArray\u003c/code\u003e，其他：基本类型数组，被编译成\u003ccode\u003eint[]\u003c/code\u003e，\u003ccode\u003efloat[]\u003c/code\u003e，其他\u003c/li\u003e\u003cli\u003e\u003ccode\u003eArray\u0026lt;T\u0026gt;\u003c/code\u003e：非空对象数组\u003c/li\u003e\u003cli\u003e\u003ccode\u003eArray\u0026lt;T?\u0026gt;\u003c/code\u003e：可空对象数组\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e使用这三种类型来声明数组，可以发现它们之间的区别：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/2a89569e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e等同的Java代码：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/efcdbd95.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e后面两种方法都对基本类型做了装箱处理，产生了额外的开销。\u003c/p\u003e\u003cp\u003e所以当需要声明非空的基本类型数组时，应该使用xxxArray，避免自动装箱。\u003c/p\u003e\u003ch3 id=\"for循环\"\u003eFor循环\u003c/h3\u003e\u003cp\u003eKotlin提供了\u003ccode\u003edownTo\u003c/code\u003e、\u003ccode\u003estep\u003c/code\u003e、\u003ccode\u003euntil\u003c/code\u003e、\u003ccode\u003ereversed\u003c/code\u003e等函数来帮助开发者更简单的使用For循环，如果单一的使用这些函数确实是方便简洁又高效，但要是将其中两个结合呢？比如下面这样：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/53c8f572.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e上面的For循环中结合使用了\u003ccode\u003edownTo\u003c/code\u003e和\u003ccode\u003estep\u003c/code\u003e，那么等同的Java代码又是怎么实现的呢？\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b9fb079d.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e重点看这行代码：\u003c/p\u003e\u003cp\u003e\u003ccode\u003eIntProgression var10000 = RangesKt.step(RangesKt.downTo(10, 1), 2);\u003c/code\u003e\u003c/p\u003e\u003cp\u003e这行代码就创建了两个\u003ccode\u003eIntProgression\u003c/code\u003e临时对象，增加了额外的开销。\u003c/p\u003e\u003ch2 id=\"kotlin检查工具的探索\"\u003eKotlin检查工具的探索\u003c/h2\u003e\u003cp\u003eKotlin的隐藏开销不止上面列举的几个，为了避免开销，我们需要实现这样一个工具，实现Kotlin语法的检查，列出不规范的代码并给出修改意见。同时为了保证开发同学的代码都是经过工具检查的，整个检查流程应该自动化。\u003c/p\u003e\u003cp\u003e再进一步考虑，Kotlin代码的检查规则应该具有扩展性，方便其他使用方定制自己的检查规则。\u003c/p\u003e\u003cp\u003e基于此，整个工具主要包含下面三个方面的内容：\u003c/p\u003e\u003col\u003e\u003cli\u003e解析Kotlin代码\u003c/li\u003e\u003cli\u003e编写可扩展的自定义代码检查规则\u003c/li\u003e\u003cli\u003e检查自动化\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e结合对工具的需求，在经过思考和查阅资料之后，确定了三种可供选择的方案：\u003c/p\u003e\u003ch4 id=\"ktlint\"\u003ektlint\u003c/h4\u003e\u003cp\u003e\u003ca href=\"https://github.com/shyiko/ktlint\"\u003ektlint\u003c/a\u003e 是一款用来检查Kotlin代码风格的工具，和我们的工具定位不同，需要经过大量的改造工作才行。\u003c/p\u003e\u003ch4 id=\"detekt\"\u003edetekt\u003c/h4\u003e\u003cp\u003e\u003ca href=\"https://github.com/arturbosch/detekt\"\u003edetekt\u003c/a\u003e 是一款用来静态分析Kotlin代码的工具，符合我们的需求，但是不太适合Android工程，比如无法指定variant（变种）检查。另外，在整个检查流程中，一份\u003ccode\u003ekt\u003c/code\u003e文件只能检查一次，检查结果（当时）只支持控制台输出，不便于阅读。\u003c/p\u003e\u003ch4 id=\"改造lint\"\u003e改造Lint\u003c/h4\u003e\u003cp\u003e改造Lint来增加Lint对Kotlin代码检查的支持，一方面Lint提供的功能完全可以满足我们的需求，同时还能支持资源文件和class文件的检查，另一方面改造后的Lint和Lint很相似，学习上手的成本低。\u003c/p\u003e\u003cp\u003e相对于前两种方案，方案3的成本收益比最高，所以我们决定改造Lint成Kotlin Lint(KLint)插件。\u003c/p\u003e\u003cp\u003e先来大致了解下Lint的工作流程，如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/3dcd9165.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e很显然，上图中的红框部分需要被改造以适配Kotlin，主要工作有以下3点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e创建KotlinParser对象，用来解析Kotlin代码\u003c/li\u003e\u003cli\u003e从aar中获取自定义KLint规则的jar包\u003c/li\u003e\u003cli\u003eDetector类需要定义一套新的接口方法来适配遍历Kotlin节点回调时的调用\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"kotlin代码解析\"\u003eKotlin代码解析\u003c/h3\u003e\u003cp\u003e和Java一样，Kotlin也有自己的抽象语法树。可惜的是目前还没有解析Kotlin语法树的单独库，只能通过Kotlin编译器这个库中的相关类来解析。KLint用的是\u003ccode\u003ekotlin-compiler-embeddable:1.1.2-5\u003c/code\u003e库。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic KtFile parseKotlinToPsi(@NonNull File file) {\n        try {\n        org.jetbrains.kotlin.com.intellij.openapi.project.Project ktProject = KotlinCoreEnvironment.Companion.createForProduction(() -\u0026gt; {\n        }, new CompilerConfiguration(), CollectionsKt.emptyList()).getProject();\n\t\tthis.psiFileFactory = PsiFileFactory.getInstance(ktProject);\n        return (KtFile) psiFileFactory.createFileFromText(file.getName(), KotlinLanguage.INSTANCE, readFileToString(file, \u0026#34;UTF-8\u0026#34;));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n     //可忽视，只是将文件转成字符流\n     public static String readFileToString(File file, String encoding) throws IOException {\n        FileInputStream stream = new FileInputStream(file);\n        String result = null;\n        try {\n            result = readInputStreamToString(stream, encoding);\n        } finally {\n            try {\n                stream.close();\n            } catch (IOException e) {\n                // ignore\n            }\n        }\n        return result;\n    }\n    \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e以上这段代码可以封装成\u003ccode\u003eKotlinParser\u003c/code\u003e类，主要作用是将\u003ccode\u003e.Kt\u003c/code\u003e文件转化成\u003ccode\u003eKtFile\u003c/code\u003e对象。\u003c/p\u003e\u003cp\u003e在检查Kotlin文件时调用\u003ccode\u003eKtFile.acceptChildren(KtVisitorVoid)\u003c/code\u003e后，\u003ccode\u003eKtVisitorVoid\u003c/code\u003e便会多次回调遍历到的各个节点(Node)的方法：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eKtVisitorVoid visitorVoid = new KtVisitorVoid(){\n\t@Override\n\tpublic void visitClass(@NotNull KtClass klass) {\n   \t\t\tsuper.visitClass(klass);\n    }\n\n    @Override\n    public void visitPrimaryConstructor(@NotNull KtPrimaryConstructor constructor) {\n           super.visitPrimaryConstructor(constructor);\n    }\n\n    @Override\n    public void visitProperty(@NotNull KtProperty property) {\n           super.visitProperty(property);\n    }\n    ...\n};\nktPsiFile.acceptChildren(visitorVoid);\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"自定义klint规则的实现\"\u003e自定义KLint规则的实现\u003c/h3\u003e\u003cp\u003e自定义KLint规则的实现参考了\u003ca href=\"https://tech.meituan.com/android_custom_lint.html\"\u003eAndroid自定义Lint实践\u003c/a\u003e这篇文章。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/033cf1aa.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e上图展示了aar中允许包含的文件，aar中可以包含lint.jar，这也是\u003ca href=\"https://tech.meituan.com/android_custom_lint.html\"\u003eAndroid自定义Lint实践\u003c/a\u003e这篇文章采用的实现方式。但是\u003ccode\u003eklint.jar\u003c/code\u003e不能直接放入aar中，当然更不应该将\u003ccode\u003eklint.jar\u003c/code\u003e重命名成\u003ccode\u003elint.jar\u003c/code\u003e来实现目的。\u003c/p\u003e\u003cp\u003e最后采用的方案是：\u003c/p\u003e\u003col\u003e\u003cli\u003e通过创建\u003ccode\u003eklintrules\u003c/code\u003e这个空的aar，将\u003ccode\u003eklint.jar\u003c/code\u003e放入assets中；\u003c/li\u003e\u003cli\u003e修改KLint代码实现从assets中读取\u003ccode\u003eklint.jar\u003c/code\u003e；\u003c/li\u003e\u003cli\u003e项目依赖\u003ccode\u003eklintrules\u003c/code\u003eaar时使用debugCompile来避免把\u003ccode\u003eklint.jar\u003c/code\u003e带到release包。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"detector类中接口方法的定义\"\u003eDetector类中接口方法的定义\u003c/h3\u003e\u003cp\u003e既然是对Kotlin代码的检查，自然Detector类要定义一套新的接口方法。先来看一下Java代码检查规则提供的方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/8dcd61dc.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e相信写过Lint规则的同学对上面的方法应该非常熟悉。为了尽量降低KLint检查规则编写的学习成本，我们参照JavaPsiScanner接口，定义了一套非常相似的接口方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/36079401.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"klint的实现\"\u003eKLint的实现\u003c/h3\u003e\u003cp\u003e通过对上述3个主要方面的改造，完成了KLint插件。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a395423a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e由于KLint和Lint的相似，KLint插件简单易上手：\u003c/p\u003e\u003col\u003e\u003cli\u003e和Lint相似的编写规范(参考最后一节的代码)；\u003c/li\u003e\u003cli\u003e支持\u003ccode\u003e@SuppressWarnings(\u0026#34;\u0026#34;)\u003c/code\u003e等Lint支持的注解；\u003c/li\u003e\u003cli\u003e具有和Lint的Options相同功能的klintOptions，如下：\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode\u003emtKlint {\n    klintOptions {\n        abortOnError false\n        htmlReport true\n        htmlOutput new File(project.getBuildDir(), \u0026#34;mtKLint.html\u0026#34;)\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"检查自动化\"\u003e检查自动化\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e关于自动检查有两个方案：\u003c/p\u003e\u003col\u003e\u003cli\u003e在开发同学commit/push代码时，触发\u003ccode\u003epre-commit/push-hook\u003c/code\u003e进行检查，检查不通过不允许commit/push；\u003c/li\u003e\u003cli\u003e在创建\u003ccode\u003epull request\u003c/code\u003e时，触发CI构建进行检查，检查不通过不允许merge。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e这里更偏向于方案2，因为\u003ccode\u003epre-commit/push-hook\u003c/code\u003e可以通过\u003ccode\u003e--no-verify\u003c/code\u003e命令绕过，我们希望所有的Kotlin代码都是通过检查的。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eKLint插件本身支持通过\u003ccode\u003e./gradlew mtKLint\u003c/code\u003e命令运行，但是考虑到几乎所有的项目在CI构建上都会执行Lint检查，把KLint和Lint绑定在一起可以省去CI构建脚本接入KLint插件的成本。\u003c/p\u003e\u003cp\u003e通过以下代码，将\u003ccode\u003elint task\u003c/code\u003e依赖\u003ccode\u003eklint task\u003c/code\u003e，实现在执行Lint之前先执行KLint检查：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e//创建KLint task，并设置被Lint task依赖\nKLint klintTask = project.getTasks().create(String.format(TASK_NAME, \u0026#34;\u0026#34;), KLint.class, new KLint.GlobalConfigAction(globalScope, null, KLintOptions.create(project)))\nSet\u0026lt;Task\u0026gt; lintTasks = project.tasks.findAll {\n    it.name.toLowerCase().equals(\u0026#34;lint\u0026#34;)\n}\nlintTasks.each { lint -\u0026gt;\n    klintTask.dependsOn lint.taskDependencies.getDependencies(lint)\n    lint.dependsOn klintTask\n}\n\n//创建Klint变种task，并设置被Lint变种task依赖\nfor (Variant variant : androidProject.variants) {\n     klintTask = project.getTasks().create(String.format(TASK_NAME, variant.name.capitalize()), KLint.class, new KLint.GlobalConfigAction(globalScope, variant, KLintOptions.create(project)))\n     lintTasks = project.tasks.findAll {\n         it.name.startsWith(\u0026#34;lint\u0026#34;) \u0026amp;\u0026amp; it.name.toLowerCase().endsWith(variant.name.toLowerCase())\n     }\n     lintTasks.each { lint -\u0026gt;\n         klintTask.dependsOn lint.taskDependencies.getDependencies(lint)\n              lint.dependsOn klintTask\n     }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"检查实时化\"\u003e检查实时化\u003c/h3\u003e\u003cp\u003e虽然实现了检查的自动化，但是可以发现执行自动检查的时机相对滞后，往往是开发同学准备合代码的时候，这时再去修改代码成本高并且存在风险。CI上的自动检查应该是作为是否有“漏网之鱼”的最后一道关卡，而问题应该暴露在代码编写的过程中。基于此，我们开发了Kotlin代码实时检查的IDE插件。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ecec6564.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过这款工具，实现在Android Studio的窗口实时报错，帮助开发同学第一时间发现问题及时解决。\u003c/p\u003e\u003ch2 id=\"kotlin代码检查实践\"\u003eKotlin代码检查实践\u003c/h2\u003e\u003cp\u003eKLint插件分为Gradle插件和IDE插件两部分，前者在\u003ccode\u003ebuild.gradle\u003c/code\u003e中引入，后者通过\u003ccode\u003eAndroid Studio\u003c/code\u003e安装使用。\u003c/p\u003e\u003ch3 id=\"klint规则的编写\"\u003eKLint规则的编写\u003c/h3\u003e\u003cp\u003e针对上面列举的\u003ccode\u003elazy()中未指定mode\u003c/code\u003e的case，KLint实现了对应的检查规则：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class LazyDetector extends Detector implements Detector.KtPsiScanner {\n    public static final Issue ISSUE = Issue.create(\n            \u0026#34;Lazy Warning\u0026#34;, \n            \u0026#34;Missing specify `lazy` mode \u0026#34;,\n\n            \u0026#34;see detail: https://wiki.sankuai.com/pages/viewpage.action?pageId=1322215247\u0026#34;,\n\n            Category.CORRECTNESS,\n            6,\n            Severity.ERROR,\n            new Implementation(\n                    LazyDetector.class,\n                    EnumSet.of(Scope.KOTLIN_FILE)));\n\n    @Override\n    public List\u0026lt;Class\u0026lt;? extends PsiElement\u0026gt;\u0026gt; getApplicableKtPsiTypes() {\n        return Arrays.asList(KtPropertyDelegate.class);\n    }\n\n    @Override\n    public KtVisitorVoid createKtPsiVisitor(KotlinContext context) {\n        return new KtVisitorVoid() {\n\n            @Override\n            public void visitPropertyDelegate(@NotNull KtPropertyDelegate delegate) {\n                boolean isLazy = false;\n                boolean isSpeifyMode = false;\n                KtExpression expression = delegate.getExpression();\n                if (expression != null) {\n                    PsiElement[] psiElements = expression.getChildren();\n                    for (PsiElement psiElement : psiElements) {\n                        if (psiElement instanceof KtNameReferenceExpression) {\n                            if (\u0026#34;lazy\u0026#34;.equals(((KtNameReferenceExpression) psiElement).getReferencedName())) {\n                                isLazy = true;\n                            }\n                        } else if (psiElement instanceof KtValueArgumentList) {\n                            List\u0026lt;KtValueArgument\u0026gt; valueArguments = ((KtValueArgumentList) psiElement).getArguments();\n                            for (KtValueArgument valueArgument : valueArguments) {\n                                KtExpression argumentValue = valueArgument.getArgumentExpression();\n                                if (argumentValue != null) {\n                                    if (argumentValue.getText().contains(\u0026#34;SYNCHRONIZED\u0026#34;) ||\n                                            argumentValue.getText().contains(\u0026#34;PUBLICATION\u0026#34;) ||\n                                            argumentValue.getText().contains(\u0026#34;NONE\u0026#34;)) {\n                                        isSpeifyMode = true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (isLazy \u0026amp;\u0026amp; !isSpeifyMode) {\n                        context.report(ISSUE, expression,context.getLocation(expression.getContext()), \u0026#34;Specify the appropriate thread safety mode to avoid locking when it’s not needed.\u0026#34;);\n                    }\n                }\n            }\n        };\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"检查结果\"\u003e检查结果\u003c/h3\u003e\u003cp\u003eGradle插件和IDE插件共用一套规则，所以上面的规则编写一次，就可以同时在两个插件中使用：\u003c/p\u003e\u003cul\u003e\u003cli\u003eCI上自动检查对应的检测结果的HTML页面：\u003cbr/\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/26fa6704.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eAndroid Studio上对应的实时报错信息：\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5b9f876d.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e借助KLint插件，编写检查规则来约束不规范的Kotlin代码，一方面避免了隐藏开销，提高了Kotlin代码的性能，另一方面也帮助开发同学更好的理解Kotlin。\u003c/p\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://medium.com/@BladeCoder/exploring-kotlins-hidden-costs-part-1-fbb9935d9b62\"\u003eExploring Kotlin’s hidden costs\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://tech.meituan.com/android_custom_lint.html\"\u003eAndroid自定义Lint实践\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者介绍\"\u003e作者介绍\u003c/h2\u003e\u003cul\u003e\u003cli\u003e周佳，美团前端Android开发工程师，2016年毕业于南京信息工程大学，同年加入美团到店餐饮事业群，参与大众点评美食频道的日常开发工作。\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-07-05T00:00:00Z",
  "Author": "soulteary@gmail.com"
}