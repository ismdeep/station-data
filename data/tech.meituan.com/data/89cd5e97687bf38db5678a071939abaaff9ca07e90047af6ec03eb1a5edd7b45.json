{
  "Source": "tech.meituan.com",
  "Title": "MSON，让JSON序列化更快",
  "Link": "https://tech.meituan.com/2018/01/09/mson.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\u003cp\u003e我们经常需要在主线程中读取一些配置文件或者缓存数据，最常用的结构化存储数据的方式就是将对象序列化为JSON字符串保存起来，这种方式特别简单而且可以和SharedPrefrence配合使用，因此应用广泛。但是目前用到的Gson在序列化JSON时很慢，在读取解析这些必要的配置文件时性能不佳，导致卡顿启动速度减慢等问题。\u003c/p\u003e\u003cp\u003eGson的问题在哪里呢？笔者用AndroidStudio的profile工具分析了\u003ccode\u003eactivity.onCreate\u003c/code\u003e方法的耗时情况。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b850a5c8.jpg\" alt=\"图 1\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/985c1c48.jpg\" alt=\"图 2\"/\u003e\u003c/p\u003e\u003cp\u003e如图1所示，可以发现Gson序列化占用了大部分的执行时间，从图2可以更直观地看到Gson.fromJson占用了61%的执行时间。分析Gson的源码可以发现，它在序列化时大量使用了反射，每一个field，每一个get、set都需要用反射，由此带来了性能问题。\u003c/p\u003e\u003ch2 id=\"如何优化\"\u003e如何优化\u003c/h2\u003e\u003cp\u003e知道了性能的瓶颈之后，我们如何去修改呢？我能想到的方法就是尽量减少反射。\u003c/p\u003e\u003cp\u003eAndroid框架中由JSONObject来提供轻量级的JSON序列化工具，所以我选择用Android框架中的JSONObject来做序列化，然后手动复制到bean就可以去掉所有的反射。\u003c/p\u003e\u003cp\u003e我做了个简单的测试，分别用Gson和JSONObject的方式去序列化一个bean，看下各自速度如何。\u003c/p\u003e\u003cp\u003e使用JSONObject的实现方式如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class Bean {\n\n    public String key;\n    public String title;\n    public String[] values;\n    public String defaultValue;\n\n    public static Bean fromJsonString(String json) {\n        try {\n            JSONObject jsonObject = new JSONObject(json);\n            Bean bean = new Bean();\n            bean.key = jsonObject.optString(\u0026#34;key\u0026#34;);\n            bean.title = jsonObject.optString(\u0026#34;title\u0026#34;);\n            JSONArray jsonArray = jsonObject.optJSONArray(\u0026#34;values\u0026#34;);\n            if (jsonArray != null \u0026amp;\u0026amp; jsonArray.length() \u0026gt; 0) {\n                int len = jsonArray.length();\n                bean.values = new String[len];\n                for (int i=0; i\u0026lt;len; ++i) {\n                    bean.values[i] = jsonArray.getString(i);\n                }\n            }\n            bean.defaultValue = jsonObject.optString(\u0026#34;defaultValue\u0026#34;);\n\n            return bean;\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n\n        return null;\n    }\n\n    public static String toJsonString(Bean bean) {\n        if (bean == null) {\n            return null;\n        }\n        JSONObject jsonObject = new JSONObject();\n        try {\n            jsonObject.put(\u0026#34;key\u0026#34;, bean.key);\n            jsonObject.put(\u0026#34;title\u0026#34;, bean.title);\n            if (bean.values != null) {\n                JSONArray array = new JSONArray();\n                for (String str:bean.values) {\n                    array.put(str);\n                }\n                jsonObject.put(\u0026#34;values\u0026#34;, array);\n            }\n            jsonObject.put(\u0026#34;defaultValue\u0026#34;, bean.defaultValue);\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n\n        return jsonObject.toString();\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e测试代码:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void test() {\n    String a = \u0026#34;{\\\u0026#34;key\\\u0026#34;:\\\u0026#34;123\\\u0026#34;, \\\u0026#34;title\\\u0026#34;:\\\u0026#34;asd\\\u0026#34;, \\\u0026#34;values\\\u0026#34;:[\\\u0026#34;a\\\u0026#34;, \\\u0026#34;b\\\u0026#34;, \\\u0026#34;c\\\u0026#34;, \\\u0026#34;d\\\u0026#34;], \\\u0026#34;defaultValue\\\u0026#34;:\\\u0026#34;a\\\u0026#34;}\u0026#34;;\n\n    Gson Gson = new Gson();\n    Bean testBean = Gson.fromJson(a, new TypeToken\u0026lt;Bean\u0026gt;(){}.getType());\n\n    long now = System.currentTimeMillis();\n    for (int i=0; i\u0026lt;1000; ++i) {\n        Gson.fromJson(a, new TypeToken\u0026lt;Bean\u0026gt;(){}.getType());\n    }\n    Log.d(\u0026#34;time\u0026#34;, \u0026#34;Gson parse use time=\u0026#34;+(System.currentTimeMillis() - now));\n\n    now = System.currentTimeMillis();\n    for (int i=0; i\u0026lt;1000; ++i) {\n        Bean.fromJsonString(a);\n    }\n    Log.d(\u0026#34;time\u0026#34;, \u0026#34;jsonobject parse use time=\u0026#34;+(System.currentTimeMillis() - now));\n\n    now = System.currentTimeMillis();\n    for (int i=0; i\u0026lt;1000; ++i) {\n        Gson.toJson(testBean);\n    }\n    Log.d(\u0026#34;time\u0026#34;, \u0026#34;Gson tojson use time=\u0026#34;+(System.currentTimeMillis() - now));\n\n    now = System.currentTimeMillis();\n    for (int i=0; i\u0026lt;1000; ++i) {\n        Bean.toJsonString(testBean);\n    }\n    Log.d(\u0026#34;time\u0026#34;, \u0026#34;jsonobject tojson use time=\u0026#34;+(System.currentTimeMillis() - now));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e测试结果\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e序列化方法\u003c/th\u003e\u003cth\u003eGson\u003c/th\u003e\u003cth\u003eJSONObject\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e序列化耗时（ms）\u003c/td\u003e\u003ctd\u003e56\u003c/td\u003e\u003ctd\u003e9\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e反序列化耗时（ms）\u003c/td\u003e\u003ctd\u003e97\u003c/td\u003e\u003ctd\u003e7\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e执行1000次JSONObject，花费的时间是Gson的几十分之一。\u003c/p\u003e\u003ch2 id=\"工具\"\u003e工具\u003c/h2\u003e\u003cp\u003e虽然JSONObject能够解决我们的问题，但在项目中有大量的存量代码都使用了Gson序列化，一处处去修改既耗费时间又容易出错，也不方便增加减少字段。\u003c/p\u003e\u003cp\u003e那么有没有一种方式在使用时和Gson一样简单且性能又特别好呢？\u003c/p\u003e\u003cp\u003e我们调研了Java的AnnotationProcessor（注解处理器），它能够在编译前对源码做处理。我们可以通过使用AnnotationProcessor为带有特定注解的bean自动生成相应的序列化和反序列化实现，用户只需要调用这些方法来完成序列化工作。\u003c/p\u003e\u003cp\u003e我们继承“AbstractProcessor”，在处理方法中找到有JsonType注解的bean来处理，代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic boolean process(Set\u0026lt;? extends TypeElement\u0026gt; set, RoundEnvironment roundEnvironment) {\n    Set\u0026lt;? extends Element\u0026gt; elements = roundEnvironment.getElementsAnnotatedWith(JsonType.class);\n    for (Element element : elements) {\n        if (element instanceof TypeElement) {\n            processTypeElement((TypeElement) element);\n        }\n    }\n    return false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后生成对应的序列化方法，关键代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eJavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(fullClassName);\nClassModel classModel = new ClassModel().setModifier(\u0026#34;public final\u0026#34;).setClassName(simpleClassName);\n......\nJavaFile javaFile = new JavaFile();\njavaFile.setPackageModel(new PackageModel().setPackageName(packageName))\n        .setImportModel(new ImportModel()\n                .addImport(elementClassName)\n                .addImport(\u0026#34;com.meituan.android.MSON.IJsonObject\u0026#34;)\n                .addImport(\u0026#34;com.meituan.android.MSON.IJsonArray\u0026#34;)\n                .addImport(\u0026#34;com.meituan.android.MSON.exceptions.JsonParseException\u0026#34;)\n                .addImports(extension.getImportList())\n        ).setClassModel(classModel);\n\nList\u0026lt;? extends Element\u0026gt; enclosedElements = element.getEnclosedElements();\nfor (Element e : enclosedElements) {\n    if (e.getKind() == ElementKind.FIELD) {\n        processFieldElement(e, extension, toJsonMethodBlock, fromJsonMethodBlock);\n    }\n}\ntry (Writer writer = sourceFile.openWriter()) {\n    writer.write(javaFile.toSourceString());\n    writer.flush();\n    writer.close();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为了今后接入别的字符串和JSONObject的转换工具，我们封装了IJSONObject和IJsonArray，这样可以接入更高效的JSON解析和格式化工具。\u003c/p\u003e\u003ch2 id=\"继续优化\"\u003e继续优化\u003c/h2\u003e\u003cp\u003e继续深入测试发现，当JSON数据量比较大时用JSONObject处理会比较慢，究其原因是JSONObject会一次性将字符串读进来解析成一个map，这样会有比较大的内存浪费和频繁内存创建。经过调研Gson内部的实现细节，发现Gson底层有流式的解析器而且可以按需解析，可以做到匹配上的字段才去解析。根据这个发现我们将我们IJSONObject和IJsonArray换成了Gson底层的流解析来进一步优化我们的速度。\u003c/p\u003e\u003cp\u003e代码如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eFriend object = new Friend();\nreader.beginObject();\nwhile (reader.hasNext()) {\n    String field = reader.nextName();\n\tif (\u0026#34;id\u0026#34;.equals(field)) {\n\t\tobject.id = reader.nextInt();\n\t} else if (\u0026#34;name\u0026#34;.equals(field)) {\n\t\tif (reader.peek() == JsonToken.NULL) {\n\t\t    reader.nextNull();\n\t\t    object.name = null;\n\t\t} else {\n\t\t    object.name = reader.nextString();\n\t\t}\n    } else {\n        reader.skipValue();\n    }\n}\nreader.endObject();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e代码中可以看到，Gson流解析过程中我们对于不认识的字段直接调用skipValue来节省不必要的时间浪费，而且是一个token接一个token读文本流这样内存中不会存一个大的JSON字符串。\u003c/p\u003e\u003ch2 id=\"兼容性\"\u003e兼容性\u003c/h2\u003e\u003cp\u003e兼容性主要体现在能支持的数据类型上，目前MSON支持了基础数据类型，包装类型、枚举、数组、List、Set、Map、SparseArray以及各种嵌套类型（比如：Map\u0026lt;String, Map\u0026lt;String, List\u0026lt;String[]\u0026gt;\u0026gt;\u0026gt;）。\u003c/p\u003e\u003ch2 id=\"性能及兼容性对比\"\u003e性能及兼容性对比\u003c/h2\u003e\u003cp\u003e我们使用一个比较复杂的bean（包含了各种数据类型、嵌套类型）分别测试了Gson、fastjson和MSON的兼容性和性能。\u003c/p\u003e\u003cp\u003e测试用例如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@JsonType\npublic class Bean {\n    public Day day;\n    public List\u0026lt;Day\u0026gt; days;\n    public Day[] days1;\n    @JsonField(\u0026#34;filed_a\u0026#34;)\n    public byte a;\n    public char b;\n    public short c;\n    public int d;\n    public long e;\n    public float f;\n    public double g;\n    public boolean h;\n\n    @JsonField(\u0026#34;filed_a1\u0026#34;)\n    public byte[] a1;\n    public char[] b1;\n    public short[] c1;\n    public int[] d1;\n    public long[] e1;\n    public float[] f1;\n    public double[] g1;\n    public boolean[] h1;\n\n    public Byte a2;\n    public Character b2;\n    public Short c2;\n    public Integer d2;\n    public Long e2;\n    public Float f2;\n    public Double g2;\n    public Boolean h2;\n    @JsonField(\u0026#34;name\u0026#34;)\n    public String i2;\n\n    public Byte[] a3;\n    public Character[] b3;\n    public Short[] c3;\n    public Integer[] d3;\n    public Long[] e3;\n    public Float[] f3;\n    public Double[] g3;\n    public Boolean[] h3;\n    public String[] i3;\n\n    @JsonIgnore\n    public String i4;\n    public transient String i5;\n    public static String i6;\n\n    public List\u0026lt;String\u0026gt; k;\n    public List\u0026lt;Integer\u0026gt; k1;\n    public Collection\u0026lt;Integer\u0026gt; k2;\n    public ArrayList\u0026lt;Integer\u0026gt; k3;\n    public Set\u0026lt;Integer\u0026gt; k4;\n    public HashSet\u0026lt;Integer\u0026gt; k5;\n    // fastjson 序列化会崩溃所以忽略掉了，下同\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public List\u0026lt;int[]\u0026gt; k6;\n    public List\u0026lt;String[]\u0026gt; k7;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; k8;\n\n    @JsonIgnore\n    public List\u0026lt;Map\u0026lt;String, Integer\u0026gt;\u0026gt; k9;\n    @JsonIgnore\n    public Map\u0026lt;String, String\u0026gt; l;\n    public Map\u0026lt;String, List\u0026lt;Integer\u0026gt;\u0026gt; l1;\n    public Map\u0026lt;Long, List\u0026lt;Integer\u0026gt;\u0026gt; l2;\n    public Map\u0026lt;Map\u0026lt;String, String\u0026gt;, String\u0026gt; l3;\n    public Map\u0026lt;String, Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt;\u0026gt; l4;\n\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false) \n    public SparseArray\u0026lt;SimpleBean2\u0026gt; m1;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public SparseIntArray m2;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public SparseLongArray m3;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public SparseBooleanArray m4;\n\n    public SimpleBean2 bean;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public SimpleBean2[] bean1;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public List\u0026lt;SimpleBean2\u0026gt; bean2;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public Set\u0026lt;SimpleBean2\u0026gt; bean3;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public List\u0026lt;SimpleBean2[]\u0026gt; bean4;\n    @com.alibaba.fastjson.annotation.JSONField(serialize = false, deserialize = false)\n    public Map\u0026lt;String, SimpleBean2\u0026gt; bean5;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e测试发现：\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003eGson的兼容性最好，能兼容几乎所有的类型，MSON其次，fastjson对嵌套类型支持比较弱。\u003c/li\u003e\u003cli\u003e性能方面MSON最好，Gson和fastjson相当。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e测试结果如下：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e序列化方法\u003c/th\u003e\u003cth\u003eMSON\u003c/th\u003e\u003cth\u003eGson\u003c/th\u003e\u003cth\u003efastjson\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e序列化耗时（ms）\u003c/td\u003e\u003ctd\u003e20\u003c/td\u003e\u003ctd\u003e47\u003c/td\u003e\u003ctd\u003e55\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e反序列化耗时（ms）\u003c/td\u003e\u003ctd\u003e1\u003c/td\u003e\u003ctd\u003e20\u003c/td\u003e\u003ctd\u003e43\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch2 id=\"方法数\"\u003e方法数\u003c/h2\u003e\u003cp\u003eMSON本身方法数很少只有60个，在使用时会对每一个标注了JsonType的Bean生成2个方法，分别是:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String toJson(Bean bean) {...}              // 1\npublic Bean fromJson(String data) {...}            // 2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e另外MSON不需要对任何类做keep处理。\u003c/p\u003e\u003ch2 id=\"mson使用方法\"\u003eMSON使用方法\u003c/h2\u003e\u003cp\u003e下面介绍MSON的使用方法，流程特别简单：\u003c/p\u003e\u003ch3 id=\"1-在bean上加注解\"\u003e1. 在Bean上加注解\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@JsonType\npublic class Bean {\n    \n    public String name;\n    public int age;\n    @JsonField(\u0026#34;_desc\u0026#34;)\n    public String description;  //使用JsonField 标注字段在json中的key\n    public transient boolean state; //使用transient 不会被序列化\n    @JsonIgnore\n    public int state2; //使用JsonIgnore注解 不会被序列化\n    \n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"2-在需要序列化的地方\"\u003e2. 在需要序列化的地方\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eMSON.fromJson(json, clazz); // 反序列化\nMSON.toJson(bean); // 序列化\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e本文介绍了一种高性能的JSON序列化工具MSON，以及它的产生原因和实现原理。目前我们已经有好多性能要求比较高的地方在使用，可以大幅的降低JSON的序列化时间。\u003c/p\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团平台客户端技术团队长期招聘技术专家，有兴趣的同学可以发送简历到：fangjintao#meituan.com。\u003cbr/\u003e详情请点击：\u003ca href=\"https://zhaopin.meituan.com/job-detail?jobId=196856365334528077\"\u003e详细JD\u003c/a\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-01-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}