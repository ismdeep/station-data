{
  "Source": "tech.meituan.com",
  "Title": "Android组件化方案及组件消息总线modular-event实战",
  "Link": "https://tech.meituan.com/2018/12/20/modular-event.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e组件化作为Android客户端技术的一个重要分支，近年来一直是业界积极探索和实践的方向。美团内部各个Android开发团队也在尝试和实践不同的组件化方案，并且在组件化通信框架上也有很多高质量的产出。最近，我们团队对美团零售收银和美团轻收银两款Android App进行了组件化改造。本文主要介绍我们的组件化方案，希望对从事Android组件化开发的同学能有所启发。\u003c/p\u003e\u003ch3 id=\"为什么要组件化\"\u003e为什么要组件化\u003c/h3\u003e\u003cp\u003e近年来，为什么这么多团队要进行组件化实践呢？组件化究竟能给我们的工程、代码带来什么好处？我们认为组件化能够带来两个最大的好处。\u003c/p\u003e\u003ch4 id=\"提高组件复用性\"\u003e提高组件复用性\u003c/h4\u003e\u003cp\u003e可能有些人会觉得，提高复用性很简单，直接把需要复用的代码做成Android Module，打包AAR并上传代码仓库，那么这部分功能就能被方便地引入和使用。但是我们觉得仅仅这样是不够的，上传仓库的AAR库是否方便被复用，需要组件化的规则来约束，这样才能提高复用的便捷性。\u003c/p\u003e\u003ch4 id=\"降低组件间的耦合\"\u003e降低组件间的耦合\u003c/h4\u003e\u003cp\u003e我们需要通过组件化的规则把代码拆分成不同的模块，模块要做到高内聚、低耦合。模块间也不能直接调用，这需要组件化通信框架的支持。降低了组件间的耦合性可以带来两点直接的好处：第一，代码更便于维护；第二，降低了模块的Bug率。\u003c/p\u003e\u003ch3 id=\"组件化之前的状态\"\u003e组件化之前的状态\u003c/h3\u003e\u003cp\u003e我们的目标是要对团队的两款App（美团零售收银、美团轻收银）进行组件化重构，那么这里先简单地介绍一下这两款应用的架构。\u003c/p\u003e\u003cp\u003e总的来说，这两款应用的构架比较相似，主工程Module依赖Business Module，Business Module是各种业务功能的集合，Business Module依赖Service Module，Service Module依赖Platform Module，Service Module和Platform Module都对上层提供服务。\u003c/p\u003e\u003cp\u003e有所不同的是Platform Module提供的服务更为基础，主要包括一些工具Utils和界面Widget，而Service Module提供各种功能服务，如KNB、位置服务、网络接口调用等。这样的话，Business Module就变得非常臃肿和繁杂，各种业务模块相互调用，耦合性很强，改业务代码时容易“牵一发而动全身”，即使改一小块业务代码，可能要连带修改很多相关的地方，不仅在代码层面不利于进行维护，而且对一个业务的修改很容易造成其他业务产生Bug。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/a6c667b8.png\" alt=\"组件化之前的状态\"/\u003e\u003c/p\u003e\u003ch3 id=\"组件化方案调研\"\u003e组件化方案调研\u003c/h3\u003e\u003cp\u003e为了得到最适合我们业态和构架的组件化方案，我们调研了业界开源的一些组件化方案和公司内部其他团队的组件化方案，在此做个总结。\u003c/p\u003e\u003ch4 id=\"开源组件化方案调研\"\u003e开源组件化方案调研\u003c/h4\u003e\u003cp\u003e我们调研了业界一些主流的开源组件化方案。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/luckybilly/CC\"\u003eCC\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e号称业界首个支持渐进式组件化改造的Android组件化开源框架。无论页面跳转还是组件间调用，都采用CC统一的组件调用方式完成。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/luojilab/DDComponentForAndroid\"\u003eDDComponentForAndroid\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e得到的方案采用路由 + 接口下沉的方式，所有接口下沉到base中，组件中实现接口并在IApplicationLike中添加代码注册到Router中。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/SpinyTech/ModularizationArchitecture\"\u003eModularizationArchitecture\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e组件间调用需指定同步实现还是异步实现，调用组件时统一拿到RouterResponse作为返回值，同步调用的时候用RouterResponse.getData()来获取结果，异步调用获取时需要自己维护线程。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/alibaba/Arouter\"\u003eARouter\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e阿里推出的路由引擎，是一个路由框架，并不是完整的组件化方案，可作为组件化架构的通信引擎。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ca href=\"https://github.com/JumeiRdGroup/Router\"\u003e聚美Router\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e聚美的路由引擎，在此基础上也有\u003ca href=\"https://juejin.im/post/5a4b4425518825128654eef4\"\u003e聚美的组件化实践方案\u003c/a\u003e，基本思想是采用路由 + 接口下沉的方式实现组件化。\u003c/p\u003e\u003ch4 id=\"美团其他团队组件化方案调研\"\u003e美团其他团队组件化方案调研\u003c/h4\u003e\u003cp\u003e\u003cstrong\u003e美团收银ComponentCenter\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e美团收银的组件化方案支持接口调用和消息总线两种方式，接口调用的方式需要构建CCPData，然后调用ComponentCenter.call，最后在统一的Callback中进行处理。消息总线方式也需要构建CCPData，最后调用ComponentCenter.sendEvent发送。美团收银的业务组件都打包成AAR上传至仓库，组件间存在相互依赖，这样导致mainapp引用这些组件时需要小心地exclude一些重复依赖。在我们的组件化方案中，我们采用了一种巧妙的方法来解决这个问题。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e美团App ServiceLoader\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e美团App的组件化方案采用ServiceLoader的形式，这是一种典型的接口调用组件通信方式。用注解定义服务，获取服务时取得一个接口的List，判断这个List是否为空，如果不为空，则获取其中一个接口调用。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eWMRouter\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e美团外卖团队开发的一款Android路由框架，基于组件化的设计思路。主要提供路由、ServiceLoader两大功能。之前美团技术博客也发表过一篇WMRouter的介绍：\u003ca href=\"https://tech.meituan.com/meituan_waimai_android_open_source_routing_framework.html\"\u003e《WMRouter：美团外卖Android开源路由框架》\u003c/a\u003e。WMRouter提供了实现组件化的两大基础设施框架：路由和组件间接口调用。支持和文档也很充分，可以考虑作为我们团队实现组件化的基础设施。\u003c/p\u003e\u003ch2 id=\"组件化方案\"\u003e组件化方案\u003c/h2\u003e\u003ch3 id=\"组件化基础框架\"\u003e组件化基础框架\u003c/h3\u003e\u003cp\u003e在前期的调研工作中，我们发现外卖团队的WMRouter是一个不错的选择。首先，WMRouter提供了路由+ServiceLoader两大组件间通信功能，其次，WMRouter架构清晰，扩展性比较好，并且文档和支持也比较完备。所以我们决定了使用WMRouter作为组件化基础设施框架之一。然而，直接使用WMRouter有两个问题：\u003c/p\u003e\u003col\u003e\u003cli\u003e我们的项目已经在使用一个路由框架，如果使用WMRouter，需要把之前使用的路由框架改成WMRouter路由框架。\u003c/li\u003e\u003cli\u003eWMRouter没有消息总线框架，我们调研的其他项目也没有适合我们项目的消息总线框架，因此我们需要开发一个能够满足我们需求的消息总线框架，这部分会在后面详细描述。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"组件化分层结构\"\u003e组件化分层结构\u003c/h3\u003e\u003cp\u003e在参考了不同的组件化方案之后，我们采用了如下分层结构：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eApp壳工程\u003c/strong\u003e：负责管理各个业务组件和打包APK，没有具体的业务功能。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e业务组件层\u003c/strong\u003e：根据不同的业务构成独立的业务组件，其中每个业务组件包含一个Export Module和Implement Module。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e功能组件层\u003c/strong\u003e：对上层提供基础功能服务，如登录服务、打印服务、日志服务等。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e组件基础设施\u003c/strong\u003e：包括WMRouter，提供页面路由服务和ServiceLoader接口调用服务，以及后面会介绍的组件消息总线框架：modular-event。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e整体架构如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/0f0fe967.png\" alt=\"分层结构\"/\u003e\u003c/p\u003e\u003ch3 id=\"业务组件拆分\"\u003e业务组件拆分\u003c/h3\u003e\u003cp\u003e我们调研其他组件化方案的时候，发现很多组件方案都是把一个业务模块拆分成一个独立的业务组件，也就是拆分成一个独立的Module。而在我们的方案中，每个业务组件都拆分成了一个Export Module和Implement Module，为什么要这样做呢？\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. 避免循环依赖\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如果采用一个业务组件一个Module的方式，如果Module A需要调用Module B提供的接口，那么Module A就需要依赖Module。同时，如果Module B需要调用Module A的接口，那么Module B就需要依赖Module A。此时就会形成一个循环依赖，这是不允许的。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7a55e4cc.png\" alt=\"循环依赖\"/\u003e\u003c/p\u003e\u003cp\u003e也许有些读者会说，这个好解决：可以把Module A和Module B要依赖的接口放到另一个Module中去，然后让Module A和Module B都去依赖这个Module就可以了。这确实是一个解决办法，并且有些项目组在使用这种把接口下沉的方法。\u003c/p\u003e\u003cp\u003e但是我们希望一个组件的接口，是由这个组件自己提供，而不是放在一个更加下沉的接口里面，所以我们采用了把每个业务组件都拆分成了一个Export Module和Implement Module。这样的话，如果Module A需要调用Module B提供的接口，同时Module B需要调用Module A的接口，只需要Module A依赖Module B Export，Module B依赖Module A Export就可以了。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/b829442d.png\" alt=\"组件结构\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. 业务组件完全平等\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e在使用单Module方案的组件化方案中，这些业务组件其实不是完全平等，有些被依赖的组件在层级上要更下沉一些。但是采用Export Module+Implement Module的方案，所有业务组件在层级上完全平等。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3. 功能划分更加清晰\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e每个业务组件都划分成了Export Module+Implement Module的模式，这个时候每个Module的功能划分也更加清晰。Export Module主要定义组件需要对外暴露的部分，主要包含：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e对外暴露的接口\u003c/strong\u003e，这些接口用WMRouter的ServiceLoader进行调用。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e对外暴露的事件\u003c/strong\u003e，这些事件利用消息总线框架modular-event进行订阅和分发。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e组件的Router Path\u003c/strong\u003e，组件化之前的工程虽然也使用了Router框架，但是所有Router Path都是定义在了一个下沉Module的公有Class中。这样导致的问题是，无论哪个模块添加/删除页面，或是修改路由，都需要去修改这个公有的Class。设想如果组件化拆分之后，某个组件新增了页面，还要去一个外部的Java文件中新增路由，这显然难以接受，也不符合组件化内聚的目标。因此，我们把每个组件的Router Path放在组件的Export Module中，既可以暴露给其他组件，也可以做到每个组件管理自己的Router Path，不会出现所有组件去修改一个Java文件的窘境。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eImplement Module是组件实现的部分，主要包含：\u003c/p\u003e\u003cul\u003e\u003cli\u003e页面相关的Activity、Fragment，并且用WMRouter的注解定义路由。\u003c/li\u003e\u003cli\u003eExport Module中对外暴露的接口的实现。\u003c/li\u003e\u003cli\u003e其他的业务逻辑。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/7fc9ea52.png\" alt=\"组件功能划分\"/\u003e\u003c/p\u003e\u003ch2 id=\"组件化消息总线框架modular-event\"\u003e组件化消息总线框架modular-event\u003c/h2\u003e\u003cp\u003e前文提到的实现组件化基础设施框架中，我们用外卖团队的WMRouter实现页面路由和组件间接口调用，但是却没有消息总线的基础框架，因此，我们自己开发了一个组件化消息总线框架modular-event。\u003c/p\u003e\u003ch3 id=\"为什么需要消息总线框架\"\u003e为什么需要消息总线框架\u003c/h3\u003e\u003cp\u003e之前，我们开发过一个基于LiveData的消息总线框架：LiveDataBus，也在美团技术博客上发表过一篇文章来介绍这个框架：\u003ca href=\"https://tech.meituan.com/Android_LiveDataBus.html\"\u003e《Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus》\u003c/a\u003e。关于消息总线的使用，总是伴随着很多争论。有些人觉得消息总线很好用，有些人觉得消息总线容易被滥用。\u003c/p\u003e\u003cp\u003e既然已经有了ServiceLoader这种组件间接口调用的框架，为什么还需要消息总线这种方式呢？主要有两个理由。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. 更进一步的解耦\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e基于接口调用的ServiceLoader框架的确实现了解耦，但是消息总线能够实现更彻底的解耦。接口调用的方式调用方需要依赖这个接口并且知道哪个组件实现了这个接口。消息总线方式发送者只需要发送一个消息，根本不用关心是否有人订阅这个消息，这样发送者根本不需要了解其他组件的情况，和其他组件的耦合也就越少。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. 多对多的通信\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e基于接口的方式只能进行一对一的调用，基于消息总线的方式能够提供多对多的通信。\u003c/p\u003e\u003ch3 id=\"消息总线的优点和缺点\"\u003e消息总线的优点和缺点\u003c/h3\u003e\u003cp\u003e总的来说，消息总线最大的优点就是解耦，因此很适合组件化这种需要对组件间进行彻底解耦的场景。然而，消息总线被很多人诟病的重要原因，也确实是因为消息总线容易被滥用。消息总线容易被滥用一般体现在几个场景：\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e1. 消息难以溯源\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e有时候我们在阅读代码的过程中，找到一个订阅消息的地方，想要看看是谁发送了这个消息，这个时候往往只能通过查找消息的方式去“溯源”。导致我们在阅读代码，梳理逻辑的过程不太连贯，有种被割裂的感觉。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. 消息发送比较随意，没有强制的约束\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e消息总线在发送消息的时候一般没有强制的约束。无论是EventBus、RxBus或是LiveDataBus，在发送消息的时候既没有对消息进行检查，也没有对发送调用进行约束。这种不规范性在特定的时刻，甚至会带来灾难性的后果。比如订阅方订阅了一个名为login_success的消息，编写发送消息的是一个比较随意的程序员，没有把这个消息定义成全局变量，而是定义了一个临时变量String发送这个消息。不幸的是，他把消息名称login_success拼写成了login_seccess。这样的话，订阅方永远接收不到登录成功的消息，而且这个错误也很难被发现。\u003c/p\u003e\u003ch3 id=\"组件化消息总线的设计目标\"\u003e组件化消息总线的设计目标\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e1. 消息由组件自己定义\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e以前我们在使用消息总线时，喜欢把所有的消息都定义到一个公共的Java文件里面。但是组件化如果也采用这种方案的话，一旦某个组件的消息发生变动，都会去修改这个Java文件。所以我们希望由组件自己来定义和维护消息定义文件。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e2. 区分不同组件定义的同名消息\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如果消息由组件定义和维护，那么有可能不同组件定义了重名的消息，消息总线框架需要能够区分这种消息。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e3. 解决前文提到的消息总线的缺点\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e解决消息总线消息难以溯源和消息发送没有约束的问题。\u003c/p\u003e\u003ch4 id=\"基于livedata的消息总线\"\u003e基于LiveData的消息总线\u003c/h4\u003e\u003cp\u003e之前的博文\u003ca href=\"https://tech.meituan.com/Android_LiveDataBus.html\"\u003e《Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus》\u003c/a\u003e详细阐述了如何基于LiveData构建消息总线。组件化消息总线框架modular-event同样会基于LiveData构建。使用LiveData构建消息总线有很多优点：\u003c/p\u003e\u003col\u003e\u003cli\u003e使用LiveData构建消息总线具有生命周期感知能力，使用者不需要调用反注册，相比EventBus和RxBus使用更为方便，并且没有内存泄漏风险。\u003c/li\u003e\u003cli\u003e使用普通消息总线，如果回调的时候Activity处于Stop状态，这个时候进行弹Dialog一类的操作就会引起崩溃。使用LiveData构建消息总线完全没有这个风险。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"组件消息总线modular-event的实现\"\u003e组件消息总线modular-event的实现\u003c/h3\u003e\u003ch4 id=\"解决不同组件定义了重名消息的问题\"\u003e解决不同组件定义了重名消息的问题\u003c/h4\u003e\u003cp\u003e其实这个问题还是比较好解决的，实现的方式就是采用两级HashMap的方式解决。第一级HashMap的构建以ModuleName作为Key，第二级HashMap作为Value；第二级HashMap以消息名称EventName作为Key，LiveData作为Value。查找的时候先用组件名称ModuleName在第一级HashMap中查找，如果找到则用消息名EventName在第二级HashName中查找。整个结构如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/181c9d0e.png\" alt=\"消息总线结构\"/\u003e\u003c/p\u003e\u003ch3 id=\"对消息总线的约束\"\u003e对消息总线的约束\u003c/h3\u003e\u003cp\u003e我们希望消息总线框架有以下约束：\u003c/p\u003e\u003col\u003e\u003cli\u003e只能订阅和发送在组件中预定义的消息。换句话说，使用者不能发送和订阅临时消息。\u003c/li\u003e\u003cli\u003e消息的类型需要在定义的时候指定。\u003c/li\u003e\u003cli\u003e定义消息的时候需要指定属于哪个组件。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"如何实现这些约束\"\u003e如何实现这些约束\u003c/h3\u003e\u003col\u003e\u003cli\u003e在消息定义文件上使用注解，定义消息的类型和消息所属Module。\u003c/li\u003e\u003cli\u003e定义注解处理器，在编译期间收集消息的相关信息。\u003c/li\u003e\u003cli\u003e在编译器根据消息的信息生成调用时需要的interface，用接口约束消息发送和订阅。\u003c/li\u003e\u003cli\u003e运行时构建基于两级HashMap的LiveData存储结构。\u003c/li\u003e\u003cli\u003e运行时采用interface+动态代理的方式实现真正的消息订阅和发送。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e整个流程如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018b/8dbcd4dd.png\" alt=\"实现流程\"/\u003e\u003c/p\u003e\u003ch3 id=\"消息总线modular-event的结构\"\u003e消息总线modular-event的结构\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003emodular-event-base\u003c/strong\u003e：定义Anotation及其他基本类型\u003c/li\u003e\u003cli\u003e\u003cstrong\u003emodular-event-core\u003c/strong\u003e：modular-event核心实现\u003c/li\u003e\u003cli\u003e\u003cstrong\u003emodular-event-compiler\u003c/strong\u003e：注解处理器\u003c/li\u003e\u003cli\u003e\u003cstrong\u003emodular-event-plugin\u003c/strong\u003e：Gradle Plugin\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"anotation\"\u003eAnotation\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e@ModuleEvents\u003c/strong\u003e：消息定义\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Retention(RetentionPolicy.SOURCE)\n@Target(ElementType.TYPE)\npublic @interface ModuleEvents {\n    String module() default \u0026#34;\u0026#34;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e@EventType\u003c/strong\u003e：消息类型\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Retention(RetentionPolicy.SOURCE)\n@Target(ElementType.FIELD)\npublic @interface EventType {\n    Class value();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"消息定义\"\u003e消息定义\u003c/h4\u003e\u003cp\u003e通过@ModuleEvents注解一个定义消息的Java类，如果@ModuleEvents指定了属性module，那么这个module的值就是这个消息所属的Module，如果没有指定属性module，则会把定义消息的Java类所在的包的包名作为消息所属的Module。\u003c/p\u003e\u003cp\u003e在这个消息定义java类中定义的消息都是public static final String类型。可以通过@EventType指定消息的类型，@EventType支持java原生类型或自定义类型，如果没有用@EventType指定消息类型，那么消息的类型默认为Object，下面是一个消息定义的示例：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//可以指定module，若不指定，则使用包名作为module名\n@ModuleEvents()\npublic class DemoEvents {\n\n    //不指定消息类型，那么消息的类型默认为Object\n    public static final String EVENT1 = \u0026#34;event1\u0026#34;;\n\n    //指定消息类型为自定义Bean\n    @EventType(TestEventBean.class)\n    public static final String EVENT2 = \u0026#34;event2\u0026#34;;\n\n    //指定消息类型为java原生类型\n    @EventType(String.class)\n    public static final String EVENT3 = \u0026#34;event3\u0026#34;;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"interface自动生成\"\u003einterface自动生成\u003c/h4\u003e\u003cp\u003e我们会在modular-event-compiler中处理这些注解，一个定义消息的Java类会生成一个接口，这个接口的命名是EventsDefineOf+消息定义类名，例如消息定义类的类名为DemoEvents，自动生成的接口就是EventsDefineOfDemoEvents。消息定义类中定义的每一个消息，都会转化成接口中的一个方法。使用者只能通过这些自动生成的接口使用消息总线。我们用这种巧妙的方式实现了对消息总线的约束。前文提到的那个消息定义示例DemoEvents.java会生成一个如下的接口类：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epackage com.sankuai.erp.modularevent.generated.com.meituan.jeremy.module_b_export;\n\npublic interface EventsDefineOfDemoEvents extends com.sankuai.erp.modularevent.base.IEventsDefine {\n  com.sankuai.erp.modularevent.Observable\u0026lt;java.lang.Object\u0026gt; EVENT1();\n\n  com.sankuai.erp.modularevent.Observable\u0026lt;com.meituan.jeremy.module_b_export.TestEventBean\u0026gt; EVENT2(\n      );\n\n  com.sankuai.erp.modularevent.Observable\u0026lt;java.lang.String\u0026gt; EVENT3();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e关于接口类的自动生成，我们采用了\u003ca href=\"https://github.com/square/javapoet\"\u003esquare/javapoet\u003c/a\u003e来实现，网上介绍JavaPoet的文章很多，这里就不再累述。\u003c/p\u003e\u003ch4 id=\"使用动态代理实现运行时调用\"\u003e使用动态代理实现运行时调用\u003c/h4\u003e\u003cp\u003e有了自动生成的接口，就相当于有了一个壳，然而壳下面的所有逻辑，我们通过动态代理来实现，简单介绍一下代理模式和动态代理：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e代理模式\u003c/strong\u003e：\n给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e动态代理\u003c/strong\u003e：\n代理类是在运行时生成的。也就是说Java编译完之后并没有实际的class文件，而是在运行时动态生成的类字节码，并加载到JVM中。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e在动态代理的InvocationHandler中实现查找逻辑：\u003c/p\u003e\u003col\u003e\u003cli\u003e根据interface的typename得到ModuleName。\u003c/li\u003e\u003cli\u003e调用的方法的methodname即为消息名。\u003c/li\u003e\u003cli\u003e根据ModuleName和消息名找到相应的LiveData。\u003c/li\u003e\u003cli\u003e完成后续订阅消息或者发送消息的流程。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e消息的订阅和发送可以用链式调用的方式编码：\u003c/p\u003e\u003cul\u003e\u003cli\u003e订阅消息\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eModularEventBus\n        .get()\n        .of(EventsDefineOfModuleBEvents.class)\n        .EVENT1()\n        .observe(this, new Observer\u0026lt;TestEventBean\u0026gt;() {\n            @Override\n            public void onChanged(@Nullable TestEventBean testEventBean) {\n                Toast.makeText(MainActivity.this, \u0026#34;MainActivity收到自定义消息: \u0026#34; + testEventBean.getMsg(),\n                        Toast.LENGTH_SHORT).show();\n            }\n        });\n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e发送消息\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eModularEventBus\n        .get()\n        .of(EventsDefineOfModuleBEvents.class)\n        .EVENT1()\n        .setValue(new TestEventBean(\u0026#34;aa\u0026#34;));\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"订阅和发送的模式\"\u003e订阅和发送的模式\u003c/h4\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e订阅消息的模式\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eobserve\u003c/strong\u003e：生命周期感知，onDestroy的时候自动取消订阅。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eobserveSticky\u003c/strong\u003e：生命周期感知，onDestroy的时候自动取消订阅，Sticky模式。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eobserveForever\u003c/strong\u003e：需要手动取消订阅。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eobserveStickyForever\u003c/strong\u003e：需要手动取消订阅，Sticky模式。\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e发送消息的模式\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003esetValue\u003c/strong\u003e：主线程调用。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003epostValue\u003c/strong\u003e：后台线程调用。\u003c/li\u003e\u003c/ol\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e本文介绍了美团行业收银研发组Android团队的组件化实践，以及强约束组件消息总线modular-event的原理和使用。我们团队很早之前就在探索组件化改造，前期有些方案在落地的时候遇到很多困难。我们也研究了很多开源的组件化方案，以及公司内部其他团队（美团App、美团外卖、美团收银等）的组件化方案，学习和借鉴了很多优秀的设计思想，当然也踩过不少的坑。我们逐渐意识到：任何一种组件化方案都有其适用场景，我们的组件化架构选择，应该更加面向业务，而不仅仅是面向技术本身。\u003c/p\u003e\u003ch2 id=\"后期工作展望\"\u003e后期工作展望\u003c/h2\u003e\u003cp\u003e我们的组件化改造工作远远没有结束，未来可能会在以下几个方向继续进行深入的研究：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e组件管理\u003c/strong\u003e：组件化改造之后，每个组件是个独立的工程，组件也会迭代开发，如何对这些组件进行版本化管理。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e组件重用\u003c/strong\u003e：现在看起来对这些组件的重用是很方便的，只需要引入组件的库即可，但是如果一个新的项目到来，需求有些变化，我们应该怎样最大限度的重用这些组件。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eCI集成\u003c/strong\u003e：如何更好的与CI集成。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e集成到脚手架\u003c/strong\u003e：集成到脚手架，让新的项目从一开始就以组件化的模式进行开发。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://tech.meituan.com/Android_LiveDataBus.html\"\u003eAndroid消息总线的演进之路：用LiveDataBus替代RxBus、EventBus\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://tech.meituan.com/meituan_waimai_android_open_source_routing_framework.html\"\u003eWMRouter：美团外卖Android开源路由框架\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://tech.meituan.com/meituan_food_delivery_android_architecture_evolution.html\"\u003e美团外卖Android平台化架构演进实践\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e海亮，美团高级工程师，2017年加入美团，目前主要负责美团轻收银、美团收银零售版等App的相关业务及模块开发工作。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘\"\u003e招聘\u003c/h2\u003e\u003cp\u003e美团餐饮生态诚招Android高级/资深工程师和技术专家，Base北京、成都，欢迎有兴趣的同学投递简历到chenyuxiang@meituan.com。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-12-20T00:00:00Z",
  "Author": "soulteary@gmail.com"
}