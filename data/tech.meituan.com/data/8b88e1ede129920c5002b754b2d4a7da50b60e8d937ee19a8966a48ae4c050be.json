{
  "Source": "tech.meituan.com",
  "Title": "Android增量代码测试覆盖率工具",
  "Link": "https://tech.meituan.com/2017/06/16/android-jacoco-practace.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e美团业务快速发展，新项目新业务不断出现，在项目开发和测试人员不足、开发同学粗心的情况下，难免会出现少测漏测的情况，如何保证新增代码有足够的测试覆盖率是我们需要思考的问题。\u003c/p\u003e\u003cp\u003e先看一个bug：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a8d7c12b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e以上代码可能在onDestory时反注册一个没有注册的receiver而发生崩溃。如果开发同学经验不足、自测不够充分或者代码审查不够仔细，这个bug很容易被带到线上。\u003c/p\u003e\u003cp\u003e正常情况下，可以通过写单测来保证新增代码的覆盖率，在Android中可以参考\u003ca href=\"http://tech.meituan.com/Android_unit_test.html\"\u003e《Android单元测试研究与实践》\u003c/a\u003e 。但在实际开发中，由于单测部署成本高、项目排期比较紧张、需求变化频繁、团队成员能力不足等多种原因，单测在互联网行业普及程度并不理想。\u003c/p\u003e\u003cp\u003e所以我们实现了这样一个工具，不需要写单测的情况下，在代码提交之前自动检测新增代码的手工测试覆盖率，避免新开发的功能没有经过自测就直接进入代码审查环节。\u003c/p\u003e\u003cp\u003e整个工具主要包含下面三个方面的内容：\u003c/p\u003e\u003cul\u003e\u003cli\u003e如何获取新增代码。\u003c/li\u003e\u003cli\u003e如何只生成新增代码的覆盖率报告。\u003c/li\u003e\u003cli\u003e如何让整个流程自动化。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"定义新增代码\"\u003e定义新增代码\u003c/h2\u003e\u003cp\u003e美团一直使用Git做代码版本控制，开发完之后提交pull request到目标分支，审查通过后即可合并。所以对于单次提交，可将新增的代码定义为：\u003c/p\u003e\u003col\u003e\u003cli\u003e本地工作目录中还没提交到暂存区的代码。\u003c/li\u003e\u003cli\u003e已经提交到暂存区的代码。\u003c/li\u003e\u003cli\u003e上次merge以后到还没有merge的commit中的代码。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/93875cf7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e得到新增代码的定义以后，如何得到这些文件中真正新增的代码：\u003c/p\u003e\u003cul\u003e\u003cli\u003e把当前检测变化的Java文件放到一个临时目录A中。\u003c/li\u003e\u003cli\u003e分别查看第一步找到的文件在最近一个merge的commit中的文件，并放到临时目录B中。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e为了充分测试修改的代码，这里把方法作为最小测试单元（新增和修改的方法），即使是修改了方法中的某一行代码也认为这个方法发生了变化。如何准确定位到哪些方法发生了变化？我们通过抽象语法树来实现。\u003c/p\u003e\u003ch2 id=\"抽象语法树\"\u003e抽象语法树\u003c/h2\u003e\u003cp\u003e所谓抽象语法树，就是源代码的抽象语法结构的树状表现形式，树上的每一个节点代表源代码中的一种结构。\u003c/p\u003e\u003cp\u003e下面通过Android Studio的\u003ca href=\"http://www.eclipse.org/jdt/ui/astview/\"\u003eJDT-View\u003c/a\u003e插件来表示一个简单的抽象语法树结构，左边是源码，右边是解析完以后的抽象语法结构：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/e6169e76.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e后续语法树分析的实现通过Eclipse的\u003ca href=\"https://projects.eclipse.org/projects/eclipse.jdt\"\u003eJDT\u003c/a\u003e来完成。用JDT主要解决两个问题：\u003c/p\u003e\u003cul\u003e\u003cli\u003e定位哪些方法发生了变化。\u003c/li\u003e\u003cli\u003e把JDT分析出的结果转化为合适的数据结构，方便后面做增量注入。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e第一个问题比较容易解决，分别生成两组Java文件（上一部分结尾得到的两组文件A、B）的语法树，并对方法（去掉注释和空行）进行MD5，MD5不同的方法，便认为该方法在这次提交中发生了变化。\u003c/p\u003e\u003cp\u003e对于第二个问题，主要的难点在于通过JDT得到的方法定义和通过\u003ca href=\"http://asm.ow2.org/\"\u003eASM\u003c/a\u003e（后面字节码注入通过ASM来实现）得到的方法定义不同，这二者最大的区别是JDT无法直接得到内部类、匿名内部类、Lambda表达式的ClassName，所以需要在语法树分析时把方法对应的ClassName转化成字节码对应的ClassName。字节码生成内部类和\u003ca href=\"https://github.com/orfjackal/retrolambda\"\u003eRetroLambda\u003c/a\u003e ClassName的规则如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e匿名内部类：…$Index。\u003c/li\u003e\u003cli\u003e普通内部类、静态内部类：…$InnerClassName。\u003c/li\u003e\u003cli\u003eRetroLambda表达式：…$$Lambda$Index。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e具体如何处理呢？JDT在分析Java文件时有几个关键的函数：\u003c/p\u003e\u003cul\u003e\u003cli\u003evisit(MethodDeclaration method)：访问普通方法的定义。\u003c/li\u003e\u003cli\u003evisit(AnonymousDeclaration method)：访问匿名内部类的定义。\u003c/li\u003e\u003cli\u003eendVisit(AnonymousDeclaration method)：结束匿名内部类的定义。\u003c/li\u003e\u003cli\u003evisit(TypeDeclaration node)：访问普通类定义。\u003c/li\u003e\u003cli\u003eendVisit(TypeDeclaration node)：结束普通类的定义。\u003c/li\u003e\u003cli\u003evisit(LambdaExpress node)：访问Lambda表达式的定义。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e同时在解析源文件时会按照源码定义顺序来访问各个节点。对于以上情况，只需要按照入栈和出栈的顺序来管理ClassName，就能和后面字节码得到的方法所匹配。\u003c/p\u003e\u003cp\u003e通过以上步骤，把每个方法的信息封装到MethodInfo中（后面注入和生成覆盖率报告时会用到该数据）：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic String className;//hash package\npublic String md5;\npublic String methodName;\npublic List\u0026lt;String\u0026gt; paramList = new ArrayList\u0026lt;\u0026gt;();\npublic String methodBody;\npublic boolean isLambda;         //标识是否是Lambda表达式方法\npublic int lambdaNumInClass;     //同一个Class中此lambda表达式是第几个. 从1开始.\npublic int totalLambdaInClass;   //同一个Class中lambda表达式的总数\npublic String lambdaParent;      //lambda表达式的父节点\npublic boolean isLambdaInAnonymous; //标识lambda表达式是否位于内部类中\npublic boolean isAnonymousClass; //标识是否是内部类方法\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e生成代码的覆盖率报告，首先想到的就是\u003ca href=\"http://www.jacoco.org/jacoco/\"\u003eJaCoCo\u003c/a\u003e，下面分别介绍一下JaCoCo的原理和我们所做的改造。\u003c/p\u003e\u003ch2 id=\"jacoco概述\"\u003eJaCoCo概述\u003c/h2\u003e\u003cp\u003eJaCoCo包含了多种维度的\u003ca href=\"http://www.eclemma.org/jacoco/trunk/doc/counters.html\"\u003e覆盖率计数器\u003c/a\u003e：指令级计数器（C0 coverage）、分支级计数器（C1 coverage）、圈复杂度、行覆盖、方法覆盖、类覆盖。其覆盖率报告的示例如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/15b33f54.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e绿色：表示行覆盖充分。\u003c/li\u003e\u003cli\u003e红色：表示未覆盖的行。\u003c/li\u003e\u003cli\u003e黄色棱形：表示分支覆盖不全。\u003c/li\u003e\u003cli\u003e绿色棱形：表示分支覆盖完全。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"注入原理\"\u003e注入原理\u003c/h2\u003e\u003cp\u003eJaCoCo主要通过代码注入的方式来实现上面覆盖率的功能。JaCoCo支持的注入方式如下图（图片出自\u003ca href=\"http://www.jacoco.org/jacoco/trunk/doc/implementation.html\"\u003e这里\u003c/a\u003e）所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5bf4e3a6.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e包含了几种不同的收集覆盖率信息的方法，每个方法的实现都不太一样，这里主要关心字节码注入这种方式（Byte Code）。Byte Code包含Offline和On-The-Fly两种注入方式：\u003c/p\u003e\u003cul\u003e\u003cli\u003eOffline：在生成最终的目标文件之前，对Class文件进行插桩，生成最终的目标文件，执行目标文件以后得到覆盖执行结果，最终生成覆盖率报告。\u003c/li\u003e\u003cli\u003eOn-The-Fly：JVM通过-javaagent指定特定的Jar来启动Instrumentation代理程序，代理程序在ClassLoader装载一个class前先判断是否需要对class进行注入，对于需要注入的class进行注入。覆盖率结果可以在JVM执行代码的过程中完成。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e可以看到，On-The-Fly因为要修改JVM参数，所以对环境的要求比较高，为了屏蔽工具对虚拟机环境的依赖，我们的代码注入主要选择Offline这种方式。\u003c/p\u003e\u003cp\u003eOffline的工作流程：\u003c/p\u003e\u003col\u003e\u003cli\u003e在生成最终目标文件之前对字节码进行插桩。\u003c/li\u003e\u003cli\u003e运行测试代码，得到运行时数据。\u003c/li\u003e\u003cli\u003e根据运行时数据、生成的class文件、源码生成覆盖率报告。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e通过一张图来形象地表示一下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/7b9f269d.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如何实现代码注入呢？举个例子说明一下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/46bba9b0.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eJaCoCo通过ASM在字节码中插入Probe指针（探测指针），每个探测指针都是一个BOOL变量（true表示执行、false表示没有执行），程序运行时通过改变指针的结果来检测代码的执行情况（不会改变原代码的行为）。探测指针完整插入策略请参考\u003ca href=\"http://www.jacoco.org/jacoco/trunk/doc/flow.html\"\u003eProbe Insertion Strategy\u003c/a\u003e。\u003c/p\u003e\u003ch2 id=\"增量注入\"\u003e增量注入\u003c/h2\u003e\u003cp\u003e介绍完JaCoCo注入原理以后，我们来看看如何做到增量注入：\u003c/p\u003e\u003cp\u003eJaCoCo默认的注入方式为全量注入。通过阅读源码，发现注入的逻辑主要在ClassProbesAdapter中。ASM在遍历字节码时，每次访问一个方法定义，都会回调这个类的visitMethod方法\n，在visitMethod方法中再调用ClassProbeVisitor的visitMethod方法，并最终调用MethodInstrumenter完成注入。部分代码片段如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic final MethodVisitor visitMethod(final int access, final String name,\n      final String desc, final String signature, final String[] exceptions) {\n   final MethodProbesVisitor methodProbes;\n   final MethodProbesVisitor mv = cv.visitMethod(access, name, desc,\n         signature, exceptions);\n   if (mv == null) {\n      methodProbes = EMPTY_METHOD_PROBES_VISITOR;\n   } else {\n      methodProbes = mv;\n   }\n   return new MethodSanitizer(null, access, name, desc, signature,\n         exceptions) {\n      @Override\n      public void visitEnd() {\n         super.visitEnd();\n         LabelFlowAnalyzer.markLabels(this);\n         final MethodProbesAdapter probesAdapter = new MethodProbesAdapter(\n               methodProbes, ClassProbesAdapter.this);\n         if (trackFrames) {\n            final AnalyzerAdapter analyzer = new AnalyzerAdapter(\n                  ClassProbesAdapter.this.name, access, name, desc,\n                  probesAdapter);\n            probesAdapter.setAnalyzer(analyzer);\n            this.accept(analyzer);\n         } else {\n            this.accept(probesAdapter);\n         }\n      }\n   };\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看到这里基本上已经知道如何去修改JaCoCo的源码了。继承原有的ClassInstrumenter和ClassProbesAdapter，修改其中的visitMethod方法，只对变化了方法进行注入：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic final MethodVisitor visitMethod(final int access, final String name,\n                                       final String desc, final String signature, final String[] exceptions) {\n    if (Utils.shoudHackMethod(name,desc,signature,changedMethods,cv.getClassName())) {\n        ...\n    } else {\n        return  cv.getCv().visitMethod(access, name, desc, signature, exceptions);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"生成增量代码的覆盖率报告\"\u003e生成增量代码的覆盖率报告\u003c/h2\u003e\u003cp\u003e和增量注入的原理类似，通过阅读源码，分别需要修改Analyzer（只对变化的类做处理）：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void analyzeClass(final ClassReader reader) {\n  if (Utils.shoudHackMethod(reader.getClassName(),changedMethods)) {\n        ...\n    } \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e和ReportClassProbesAdapter（只对变化的方法做处理）：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic final MethodVisitor visitMethod(final int access, final String name,\n                                       final String desc, final String signature, final String[] exceptions) {\n    if (Utils.shoudHackMethod(name, desc, signature, changedMethods, this.className)) {\n        ...\n    } else {\n        return null;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样就能生成新增代码的覆盖率报告。如下图所示本次commit只修改了FoodPoiDetailActivity的onCreate和initCustomTitle这两个方法，那么覆盖率只涉及这些修改了的方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/05dc4503.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/e773ff1b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"jdt-vs-asm\"\u003eJDT vs ASM\u003c/h2\u003e\u003cp\u003e在上面增量注入和生成增量代码覆盖率报告时都会去判断当前方法是否应该被处理。这里分别对比JDT和ASM解析结果中的className、methodName、paramList来判断当前方法是否需要被注入，部分代码片段：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic static boolean shoudHackMethod(String methodName, String desc, String signature, HashSet\u0026lt;MethodInfo\u0026gt; changedMethods, String className) {\n    Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; changedLambdaMethods = getChangedLambdaMethods(changedMethods);\n    List\u0026lt;String\u0026gt; changedLambdaMethodNames = changedLambdaMethods.get(className.replace(\u0026#34;/\u0026#34;, \u0026#34;.\u0026#34;));\n    updateLambdaNum(methodName, className);\n    int indexMethods = 0;\n    outer:\n    for (; indexMethods \u0026lt; changedMethods.size(); indexMethods++) {\n        MethodInfo methodInfo = changedMethods[indexMethods]\n        if (methodInfo.className.replace(\u0026#34;.\u0026#34;, \u0026#34;/\u0026#34;).equals(className)) {\n            if (methodName.startsWith(\u0026#39;lambda$\u0026#39;) \u0026amp;\u0026amp; methodInfo.isLambda\n                    \u0026amp;\u0026amp; changedLambdaMethodNames != null \u0026amp;\u0026amp; changedLambdaMethodNames.size() \u0026gt; 0) {\n                //两者方法名相等\n                if (methodInfo.methodName.equals(methodName)) {\n                    changedLambdaMethodNames.remove(methodInfo.methodName)\n                    return true;\n\n                } else if (!changedLambdaMethodNames.contains(methodName)) {\n                    //两者方法名不等,且不包含在改变的lambda方法中,通过加载顺序来判断\n                    int lastIndex = methodInfo.methodName.lastIndexOf(\u0026#39;$\u0026#39;);\n                    if (lastIndex \u0026lt;= 0) {\n                        continue;\n                    }\n                    String tmpMethodName = methodInfo.methodName.substring(0, lastIndex);\n                    if (tmpMethodName.equals(sAsmMethodInfo.methodName)\n                            \u0026amp;\u0026amp; (methodInfo.lambdaNumInClass == (methodInfo.totalLambdaInClass - sAsmMethodInfo.lambdaNumInClass + 1) || judgeSoleLambda(changedMethods, methodInfo, methodName, className.replace(\u0026#34;/\u0026#34;, \u0026#34;.\u0026#34;)))) {\n                        changedLambdaMethodNames.remove(methodInfo.methodName)\n                        return true;\n                    }\n                }\n            } else {\n                if (methodInfo.methodName.equals(methodName) ||\n                        (!methodInfo.methodBody.trim().equals(\u0026#34;{}\u0026#34;) \u0026amp;\u0026amp; methodName.equals(\u0026#34;\u0026lt;init\u0026gt;\u0026#34;) \u0026amp;\u0026amp; methodInfo.methodName.equals(methodInfo.className.split(\u0026#34;\\\\.|\\\\\\$\u0026#34;)[methodInfo.className.split(\u0026#34;\\\\.|\\\\\\$\u0026#34;).length - 1]))) {\n                    if (signature == null) signature = desc;\n                    TraceSignatureVisitor v = new TraceSignatureVisitor(0);\n                    new SignatureReader(signature).accept(v);\n                    String declaration = v.getDeclaration();\n                    int rightBrace = declaration.indexOf(\u0026#34;(\u0026#34;);\n                    int leftBrace = declaration.lastIndexOf(\u0026#34;)\u0026#34;);\n                    if (rightBrace \u0026gt; 0 \u0026amp;\u0026amp; leftBrace \u0026gt; rightBrace) {\n                        //只取形参\n                        declaration = declaration.substring(rightBrace + 1, leftBrace);\n                    }\n                    //勿用\\\\[\\\\]作为分隔符, 否则数组形参不可区分\n                    String paraStr = declaration.replaceAll(\u0026#34;[(){}]\u0026#34;, \u0026#34;\u0026#34;);\n                    if (paraStr.length() \u0026gt; 0) {\n                        String[] parasArray = getAsmMethodParams(paraStr.split(\u0026#34;,\u0026#34;), className, methodInfo.paramList);\n                        List\u0026lt;String\u0026gt; paramListAst = getAstMethodParams(methodInfo.paramList);\n                        if (parasArray.length == paramListAst.size()) {\n                            for (int i = 0; i \u0026lt; paramListAst.size(); i++) {\n                                //将\u0026lt; \u0026gt; . 作为分隔符\n                                String[] methodInfoParamArray = paramListAst.get(i).split(\u0026#34;\u0026lt;|\u0026gt;|\\\\.\u0026#34;);\n                                for (String param : methodInfoParamArray) {\n                                    if (!parasArray[i].contains(param) ||\n                                            (parasArray[i].contains(param) \u0026amp;\u0026amp; parasArray[i].contains(\u0026#34;[]\u0026#34;) \u0026amp;\u0026amp; !param.endsWith(\u0026#34;[]\u0026#34;))) {\n                                        //同类名、同方法名、同参数长度, 参数类型不一致(或者 比较相等, 但class中是数组, 而源码中不是数组) 跳转到 outer循环开始处\n                                        continue outer;\n                                    }\n                                }\n                            }\n                        } else {\n                            continue;\n                        }\n                    }\n                    if (methodInfo.isLambda \u0026amp;\u0026amp; changedLambdaMethodNames != null) {\n                        changedLambdaMethodNames.remove(methodInfo.methodName)\n                    }\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"自动注入\"\u003e自动注入\u003c/h2\u003e\u003cp\u003e整个工具通过\u003ca href=\"https://docs.gradle.org/current/userguide/custom_plugins.html\"\u003eGradle插件\u003c/a\u003e的形式加入到项目中，只需要简单配置即可使用，在生成DEX之前完成增量代码的注入，同时为了不影响线上版本，该插件只在Debug模式下生效。\u003c/p\u003e\u003ch2 id=\"自动获取运行时数据\"\u003e自动获取运行时数据\u003c/h2\u003e\u003cp\u003e刚才讲JaCoCo原理的时候提到，需要运行时数据才能生成覆盖率报告。代码中通过反射执行下面的函数来获取运行时数据，并保存到当前执行代码的设备中：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eorg.jacoco.agent.rt.RT.getAgent().getExecutionData(false)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e由于生成报告时需要用到运行时数据，为了生成的覆盖率报告更准确、开发同学用起来更方便，分别在如下时机把运行时数据保存到当前设备中：\u003c/p\u003e\u003cul\u003e\u003cli\u003e每个页面执行onDestory时。\u003c/li\u003e\u003cli\u003e程序发生崩溃时。\u003c/li\u003e\u003cli\u003e收到特定广播（一个自定义的广播，在执行生成覆盖率报告的task前发送）时。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e并在生成覆盖率报告之前把设备中的运行时数据同步到本地开发环境中。\u003c/p\u003e\u003cp\u003e上面可以看到，因为获取时机比较多，可能会得到多份运行时数据，对于这些数据，可以通过JaCoCo的\u003ca href=\"http://www.eclemma.org/jacoco/trunk/doc/merge-mojo.html\"\u003emergeTask\u003c/a\u003e把\u003ca href=\"http://www.jacoco.org/jacoco/trunk/doc/classids.html\"\u003eClassId\u003c/a\u003e相同的运行时数据进行merge。如下图所示，JaCoCo会对ClassId相同的运行时数据进行merge，并对相同位置的probe指针取或：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/6aee02d7.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"自动部署pre-push脚本\"\u003e自动部署Pre-Push脚本\u003c/h2\u003e\u003cp\u003e为了开发者在提交代码之前能够自动生成覆盖率报告，我们在插件apply阶段动态下发一个\u003ca href=\"https://git-scm.com/book/gr/v2/Customizing-Git-Git-Hooks\"\u003ePre-Push\u003c/a\u003e脚本到本地项目的.git目录。在push之前生成覆盖率报告，同时对于覆盖率小于一定值（默认95%，可自定义）的提交提示并报警：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/cd785485.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e整个工具通过Gradle插件的形式部署到项目中，在项目编译阶段完成新增代码的查找和注入，在最终push代码之前获取当前设备的运行时数据，然后生成覆盖率报告，并把覆盖率低于一定值（默认是95%）的提交abort掉。\u003c/p\u003e\u003cp\u003e最后通过一张完整的图来看下这个工具的工作流程：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/c348d435.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e上述是我们在保障开发质量方面做的一些探索和积累。通过保障开发阶段增量代码的自测覆盖率，让开发者充分检验开发效果，提前发现逻辑缺陷，将风险前置。保障开发质量的道路任重而道远， 我们可以通过良好的测试覆盖率、持续完善单测、改善代码框架、规范开发流程等等多种维度相辅相成、共同推进。\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://github.com/jacoco/jacoco\"\u003eJaCoCo-Source-Code\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://mp.weixin.qq.com/s?__biz=MzIxNzEyMzIzOA==\u0026amp;mid=2652314564\u0026amp;idx=1\u0026amp;sn=a93e6154c92acaef9204b8440e66a852\u0026amp;scene=21#wechat_redirect\"\u003eJava代码覆盖率工具JaCoCo-原理篇\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e本文三位作者均来自美团的到店餐饮技术部信息与交易技术中心。\u003c/p\u003e\u003cp\u003e武智，Android高级开发工程师，2013年7月校招加入美团，目前负责维护大众点评App的美食频道。\u003c/p\u003e\u003cp\u003e莹莹，2015年校招加入美团，主要参与大众点评美食频道的日常开发工作，专注于通过工具自动化地提高开发效率和质量。\u003c/p\u003e\u003cp\u003e周佳，2016年校招加入美团，主要参与大众点评美食频道的日常开发工作。\u003c/p\u003e\u003cp\u003e到店餐饮技术部交易与信息技术中心，负责美团美食用户端业务，服务于数以亿计用户，通过更好的榜单、真实的评价和完善的信息为用户提供更好的决策支持，致力于提升用户体验；同时承载所有餐饮商户端线上流量，为餐饮商户提供多种营销工具，提升餐饮商户营销效率，最终达到让国人“Eat Better、Live Better”的美好愿景！我们的团队包含且不限于Android、iOS、FE、Java、PHP等技术方向，已完备覆盖前后端技术栈。只要你来，就能点亮全栈开发技能树。诚挚欢迎投递简历至chenhongbing#meituan.com。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e【思考题】\u003c/p\u003e\u003cp\u003e本文为大家介绍的工具基本上可以解决新增代码没有覆盖导致的问题。但开发过程中还会有一些因为数据、状态错误导致的问题，对于这类问题，通过什么工具可以及时的发现并解决？日常测试过程中用到测试数据是否被有效的利⽤和积累，是否能利用大数据相关的技术完善新时代的测试体系？\u003c/p\u003e\u003c/blockquote\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-06-16T00:00:00Z",
  "Author": "soulteary@gmail.com"
}