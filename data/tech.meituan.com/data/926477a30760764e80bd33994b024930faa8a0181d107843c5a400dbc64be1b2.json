{
  "Source": "tech.meituan.com",
  "Title": "新一代开源Android渠道包生成工具Walle",
  "Link": "https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e在Android 7.0（Nougat）推出了新的应用签名方案APK Signature Scheme v2后，之前快速生成渠道包的方式（\u003ca href=\"http://tech.meituan.com/mt-apk-packaging.html\"\u003e美团Android自动化之旅—生成渠道包\u003c/a\u003e）已经行不通了，在此应用签名方案下如何快速生成渠道包呢？\u003c/p\u003e\u003cp\u003e本文会对新的应用签名方案APK Signature Scheme v2以及新一代渠道生成工具进行详细深入的介绍。\u003c/p\u003e\u003ch2 id=\"新的应用签名方案apk-signature-scheme-v2\"\u003e新的应用签名方案APK Signature Scheme v2\u003c/h2\u003e\u003cp\u003eAndroid 7.0（Nougat）引入一项新的应用签名方案\u003ca href=\"https://source.android.com/security/apksigning/v2.html\"\u003eAPK Signature Scheme v2\u003c/a\u003e，它是一个对全文件进行签名的方案，能提供更快的应用安装时间、对未授权APK文件的更改提供更多保护，在默认情况下，Android Gradle 2.2.0插件会使用APK Signature Scheme v2和传统签名方案来签署你的应用。\u003c/p\u003e\u003cp\u003e下面以 \u003ccode\u003e新的应用签名方案\u003c/code\u003e 来指APK Signature Scheme v2。\u003c/p\u003e\u003cp\u003e目前该方案不是强制性的，在 \u003ccode\u003ebuild.gradle\u003c/code\u003e 添加 \u003ccode\u003ev2SigningEnabled false\u003c/code\u003e ，就能使用传统签名方案来签署我们的应用（见下面的代码片段）。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-groovy\"\u003e  android {\n    ...\n    defaultConfig { ... }\n    signingConfigs {\n      release {\n        storeFile file(\u0026#34;myreleasekey.keystore\u0026#34;)\n        storePassword \u0026#34;password\u0026#34;\n        keyAlias \u0026#34;MyReleaseKey\u0026#34;\n        keyPassword \u0026#34;password\u0026#34;\n        v2SigningEnabled false\n      }\n    }\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e但新的应用签名方案有着良好的向后兼容性，能完全兼容低于Android 7.0（Nougat）的版本。对比旧签名方案，它有更快的验证速度和更安全的保护，因此新的应用签名方案可能会被采纳成一个强制配置，笔者认为现在有必要对现有的渠道包生成方式进行检查、升级或改造来支持新的应用签名方案。\u003c/p\u003e\u003cp\u003e新的签名方案对已有的渠道生成方案有什么影响呢？下图是新的应用签名方案和旧的签名方案的一个对比：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/604a4dc5.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e新的签名方案会在ZIP文件格式的 \u003ccode\u003eCentral Directory\u003c/code\u003e 区块所在文件位置的前面添加一个APK Signing Block区块，下面按照ZIP文件的格式来分析新应用签名方案签名后的APK包。\u003c/p\u003e\u003cp\u003e整个APK（ZIP文件格式）会被分为以下四个区块：\n1. Contents of ZIP entries（from offset 0 until the start of APK Signing Block）\n2. APK Signing Block\n3. ZIP Central Directory\n4. ZIP End of Central Directory\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/b6ff18f5.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e新应用签名方案的签名信息会被保存在区块2（APK Signing Block）中， 而区块1（\u003ccode\u003eContents of ZIP entries\u003c/code\u003e）、区块3（\u003ccode\u003eZIP Central Directory\u003c/code\u003e）、区块4（\u003ccode\u003eZIP End of Central Directory\u003c/code\u003e）是受保护的，在签名后任何对区块1、3、4的修改都逃不过新的应用签名方案的检查。\u003c/p\u003e\u003cp\u003e之前的渠道包生成方案是通过在META-INF目录下添加空文件，用空文件的名称来作为渠道的唯一标识，之前在META-INF下添加文件是不需要重新签名应用的，这样会节省不少打包的时间，从而提高打渠道包的速度。但在新的应用签名方案下META-INF已经被列入了保护区了，向META-INF添加空文件的方案会对区块1、3、4都会有影响，新应用签名方案签署的应用经过我们旧的生成渠道包方案处理后，在安装时会报以下错误：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eFailure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: \nFailed to collect certificates from base.apk: META-INF/CERT.SF indicates base.apk is signed using APK Signature Scheme v2, \nbut no such signature was found. Signature stripped?]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e目前另外一种比较流行的\u003ca href=\"http://linghaolu.github.io/apk/2016/04/02/apk-comment.html\"\u003e渠道包快速生成方案\u003c/a\u003e（往APK中添加ZIP Comment）也因为上述原因，无法在新的应用签名方案下进行正常工作。\u003c/p\u003e\u003cp\u003e如果新的应用签名方案后续改成强制要求，那我们现有的生成渠道包的方式就会无法工作，那我们难道要退回到解放前，通过传统的方式（例如：使用APKTool逆向工具、采用Flavor ＋ BuildType等比较耗时的方案来进行渠道包打包）来生成支持新应用签名方案的渠道包吗？\u003c/p\u003e\u003cp\u003e如果只有少量渠道包的场景下，这种耗时时长还能够勉强接受。但是目前我们有将近900个渠道，如果采用传统方式打完所有的渠道包需要近3个小时，这是不能接受的。\u003c/p\u003e\u003cp\u003e那我们有没有其他更好的渠道包生成方式，既能支持新的应用签名方案，又能体验毫秒级的打包耗时呢？我们来分析一下新方案中的区块2——Block。\u003c/p\u003e\u003ch2 id=\"可扩展的apk-signature-scheme-v2-block\"\u003e可扩展的APK Signature Scheme v2 Block\u003c/h2\u003e\u003cp\u003e通过上面的描述，可以看出因为APK包的区块1、3、4都是受保护的，任何修改在签名后对它们的修改，都会在安装过程中被签名校验检测失败，而区块2（APK Signing Block）是不受签名校验规则保护的，那是否可以在这个不受签名保护的区块2（APK Signing Block）上做文章呢？我们先来看看对区块2格式的描述：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e偏移\u003c/th\u003e\u003cth align=\"center\"\u003e字节数\u003c/th\u003e\u003cth align=\"left\"\u003e描述\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e@+0\u003c/td\u003e\u003ctd align=\"center\"\u003e8\u003c/td\u003e\u003ctd align=\"left\"\u003e这个Block的长度（本字段的长度不计算在内）\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e@+8\u003c/td\u003e\u003ctd align=\"center\"\u003en\u003c/td\u003e\u003ctd align=\"left\"\u003e一组ID-value\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e@-24\u003c/td\u003e\u003ctd align=\"center\"\u003e8\u003c/td\u003e\u003ctd align=\"left\"\u003e这个Block的长度（和第一个字段一样值）\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003e@-16\u003c/td\u003e\u003ctd align=\"center\"\u003e16\u003c/td\u003e\u003ctd align=\"left\"\u003e魔数 “APK Sig Block 42”\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e区块2中APK Signing Block是由这几部分组成：2个用来标示这个区块长度的8字节 ＋ 这个区块的魔数（\u003ccode\u003eAPK Sig Block 42\u003c/code\u003e）+ 这个区块所承载的数据（ID-value）。\u003c/p\u003e\u003cp\u003e我们重点来看一下这个ID-value，它由一个8字节的长度标示＋4字节的ID＋它的负载组成。V2的签名信息是以ID（\u003ccode\u003e0x7109871a\u003c/code\u003e）的ID-value来保存在这个区块中，不知大家有没有注意这是一组ID-value，也就是说它是可以有若干个这样的ID-value来组成，那我们是不是可以在这里做一些文章呢？\u003c/p\u003e\u003cp\u003e为了验证我们的想法，先来看看新的应用签名方案是怎么验证签名信息的，见下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/18666479.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过上图可以看出新的应用签名方案的验证过程：\n1. 寻找APK Signing Block，如果能够找到，则进行验证，验证成功则继续进行安装，如果失败了则终止安装\n2. 如果未找到APK Signing Block，则执行原来的签名验证机制，也是验证成功则继续进行安装，如果失败了则终止安装\u003c/p\u003e\u003cp\u003e那Android应用在安装时新的应用签名方案是怎么进行校验的呢？笔者通过翻阅Android相关部分的源码，发现下面代码段是用来处理上面所说的ID-value的：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public static ByteBuffer findApkSignatureSchemeV2Block(\n            ByteBuffer apkSigningBlock,\n            Result result) throws SignatureNotFoundException {\n        checkByteOrderLittleEndian(apkSigningBlock);\n        // FORMAT:\n        // OFFSET       DATA TYPE  DESCRIPTION\n        // * @+0  bytes uint64:    size in bytes (excluding this field)\n        // * @+8  bytes pairs\n        // * @-24 bytes uint64:    size in bytes (same as the one above)\n        // * @-16 bytes uint128:   magic\n        ByteBuffer pairs = sliceFromTo(apkSigningBlock, 8, apkSigningBlock.capacity() - 24);\n\n        int entryCount = 0;\n        while (pairs.hasRemaining()) {\n            entryCount++;\n            if (pairs.remaining() \u0026lt; 8) {\n                throw new SignatureNotFoundException(\n                        \u0026#34;Insufficient data to read size of APK Signing Block entry #\u0026#34; + entryCount);\n            }\n            long lenLong = pairs.getLong();\n            if ((lenLong \u0026lt; 4) || (lenLong \u0026gt; Integer.MAX_VALUE)) {\n                throw new SignatureNotFoundException(\n                        \u0026#34;APK Signing Block entry #\u0026#34; + entryCount\n                                + \u0026#34; size out of range: \u0026#34; + lenLong);\n            }\n            int len = (int) lenLong;\n            int nextEntryPos = pairs.position() + len;\n            if (len \u0026gt; pairs.remaining()) {\n                throw new SignatureNotFoundException(\n                        \u0026#34;APK Signing Block entry #\u0026#34; + entryCount + \u0026#34; size out of range: \u0026#34; + len\n                                + \u0026#34;, available: \u0026#34; + pairs.remaining());\n            }\n            int id = pairs.getInt();\n            if (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {\n                return getByteBuffer(pairs, len - 4);\n            }\n            result.addWarning(Issue.APK_SIG_BLOCK_UNKNOWN_ENTRY_ID, id);\n            pairs.position(nextEntryPos);\n        }\n\n        throw new SignatureNotFoundException(\n                \u0026#34;No APK Signature Scheme v2 block in APK Signing Block\u0026#34;);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述代码中关键的一个位置是 \u003ccode\u003eif (id == APK_SIGNATURE_SCHEME_V2_BLOCK_ID) {return getByteBuffer(pairs, len - 4);}\u003c/code\u003e，通过源代码可以看出Android是通过查找ID为 \u003ccode\u003eAPK_SIGNATURE_SCHEME_V2_BLOCK_ID = 0x7109871a\u003c/code\u003e 的ID-value，来获取APK Signature Scheme v2 Block，对这个区块中其他的ID-value选择了忽略。\u003c/p\u003e\u003cp\u003e在\u003ca href=\"https://source.android.com/security/apksigning/v2.html\"\u003eAPK Signature Scheme v2\u003c/a\u003e中没有看到对无法识别的ID，有相关处理的介绍。\u003c/p\u003e\u003cp\u003e当看到这里时，我们可不可以设想一下，提供一个自定义的ID-value并写入该区域，从而为快速生成渠道包服务呢？\u003c/p\u003e\u003cp\u003e怎么向ID-value中添加信息呢？通过阅读ZIP的文件格式和APK Signing Block格式的描述，笔者通过编写下面的代码片段进行验证，发现通过在已经被新的应用签名方案签名后的APK中添加自定义的ID-value，是不需要再次经过签名就能安装的，下面是部分代码片段。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e  public void writeApkSigningBlock(DataOutput dataOutput) {\n        long length = 24;\n        for (int index = 0; index \u0026lt; payloads.size(); ++index) {\n            ApkSigningPayload payload = payloads.get(index);\n            byte[] bytes = payload.getByteBuffer();\n            length += 12 + bytes.length;\n        }\n\n        ByteBuffer byteBuffer = ByteBuffer.allocate(Long.BYTES);\n        byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n        byteBuffer.putLong(length);\n        dataOutput.write(byteBuffer.array());\n\n        for (int index = 0; index \u0026lt; payloads.size(); ++index) {\n            ApkSigningPayload payload = payloads.get(index);\n            byte[] bytes = payload.getByteBuffer();\n\n            byteBuffer = ByteBuffer.allocate(Integer.BYTES);\n            byteBuffer.order(ByteOrder.LITTLE_ENDIAN);\n            byteBuffer.putInt(payload.getId());\n            dataOutput.write(byteBuffer.array());\n\n            dataOutput.write(bytes);\n        }\n        ...\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"新一代渠道包生成工具\"\u003e新一代渠道包生成工具\u003c/h2\u003e\u003cp\u003e到这里为止一个新的渠道包生成方案逐步清晰了起来，下面是新一代渠道包生成工具的描述：\u003c/p\u003e\u003col\u003e\u003cli\u003e对新的应用签名方案生成的APK包中的ID-value进行扩展，提供自定义ID－value（渠道信息），并保存在APK中\u003c/li\u003e\u003cli\u003e而APK在安装过程中进行的签名校验，是忽略我们添加的这个ID-value的，这样就能正常安装了\u003c/li\u003e\u003cli\u003e在App运行阶段，可以通过ZIP的\u003ccode\u003eEOCD（End of central directory）\u003c/code\u003e、\u003ccode\u003eCentral directory\u003c/code\u003e等结构中的信息（会涉及ZIP格式的相关知识，这里不做展开描述）找到我们自己添加的ID-value，从而实现获取渠道信息的功能\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e新一代渠道包生成工具完全是基于ZIP文件格式和APK Signing Block存储格式而构建，基于文件的二进制流进行处理，有着良好的处理速度和兼容性，能够满足不同的语言编写的要求，目前笔者采用的是Java＋Groovy开发， 该工具主要有四部分组成：\n1. 用于写入ID-value信息的Java类库\n2. Gradle构建插件用来和Android的打包流程进行结合\n3. 用于读取ID-value信息的Java类库\n4. 用于供\u003ccode\u003ecom.android.application\u003c/code\u003e使用的读取渠道信息的AAR\u003c/p\u003e\u003cp\u003e这样，每打一个渠道包只需复制一个APK，然后在APK中添加一个ID-value即可，这种打包方式速度非常快，对一个30M大小的APK包只需要100多毫秒（包含文件复制时间）就能生成一个渠道包，而在运行时获取渠道信息只需要大约几毫秒的时间。\u003c/p\u003e\u003cp\u003e这个项目我们取名为Walle（瓦力），已经开源，项目的Github地址是： \u003ca href=\"https://github.com/Meituan-Dianping/walle\"\u003ehttps://github.com/Meituan-Dianping/walle\u003c/a\u003e （求Issue、PR、Star）。希望业内有类似需求的团队能够在APK Signature Scheme V2签名下愉快地生成渠道包，同时也期待大家一起对该项目进行完善和优化。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e以上就是我们对新的应用签名方案进行的分析，并根据它所带来的文件存储格式上的变化，找到了可以利用的ID-value，然后基于这个ID-value来构建我们新一代渠道包生成工具。\u003c/p\u003e\u003cp\u003e新一代渠道包生成工具能够满足新应用签名方案对安全性的要求，同时也能满足对渠道包打包时间的要求，至此大家生成渠道包的方式需要升级了！\u003c/p\u003e\u003cp\u003e文章中引用的图片来源于：\u003ca href=\"https://source.android.com/security/apksigning/v2.html\"\u003ehttps://source.android.com/security/apksigning/v2.html\u003c/a\u003e\u003c/p\u003e\u003ch2 id=\"参考文献\"\u003e参考文献\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://source.android.com/security/apksigning/v2.html\"\u003eAPK Signature Scheme v2\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://android.googlesource.com/platform/build/+/8740e9d\"\u003eApkSigner的源代码\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://android.googlesource.com/platform/tools/apksig/\"\u003eapksig的源代码\u003c/a\u003e\u003c/li\u003e\u003cli\u003e[ZIP Format](\u003ca href=\"https://en.wikipedia.org/wiki/Zip_(file_format\"\u003ehttps://en.wikipedia.org/wiki/Zip_(file_format\u003c/a\u003e)\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-01-13T00:00:00Z",
  "Author": "soulteary@gmail.com"
}