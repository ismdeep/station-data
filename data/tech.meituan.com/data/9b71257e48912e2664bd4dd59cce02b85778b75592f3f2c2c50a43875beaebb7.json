{
  "Source": "tech.meituan.com",
  "Title": "聊聊MyBatis缓存机制",
  "Link": "https://tech.meituan.com/2018/01/19/mybatis-cache.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003eMyBatis是常见的Java数据库访问层框架。在日常工作中，开发人员多数情况下是使用MyBatis的默认缓存配置，但是MyBatis缓存机制有一些不足之处，在使用中容易引起脏数据，形成一些潜在的隐患。个人在业务开发中也处理过一些由于MyBatis缓存引发的开发问题，带着个人的兴趣，希望从应用及源码的角度为读者梳理MyBatis缓存机制。\u003c/p\u003e\u003cp\u003e本次分析中涉及到的代码和数据库表均放在GitHub上，地址： \u003ca href=\"https://github.com/kailuncen/mybatis-cache-demo\"\u003emybatis-cache-demo\u003c/a\u003e 。\u003c/p\u003e\u003ch2 id=\"目录\"\u003e目录\u003c/h2\u003e\u003cp\u003e本文按照以下顺序展开。\u003c/p\u003e\u003cul\u003e\u003cli\u003e一级缓存介绍及相关配置。\u003c/li\u003e\u003cli\u003e一级缓存工作流程及源码分析。\u003c/li\u003e\u003cli\u003e一级缓存总结。\u003c/li\u003e\u003cli\u003e二级缓存介绍及相关配置。\u003c/li\u003e\u003cli\u003e二级缓存源码分析。\u003c/li\u003e\u003cli\u003e二级缓存总结。\u003c/li\u003e\u003cli\u003e全文总结。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"一级缓存\"\u003e一级缓存\u003c/h2\u003e\u003ch3 id=\"一级缓存介绍\"\u003e一级缓存介绍\u003c/h3\u003e\u003cp\u003e在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6e38df6a.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成\u003ccode\u003eMappedStatement\u003c/code\u003e，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入\u003ccode\u003eLocal Cache\u003c/code\u003e，最后返回结果给用户。具体实现类的类关系图如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d76ec5fe.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"一级缓存配置\"\u003e一级缓存配置\u003c/h3\u003e\u003cp\u003e我们来看看如何使用MyBatis一级缓存。开发者只需在MyBatis的配置文件中，添加如下语句，就可以使用一级缓存。共有两个选项，\u003ccode\u003eSESSION\u003c/code\u003e或者\u003ccode\u003eSTATEMENT\u003c/code\u003e，默认是\u003ccode\u003eSESSION\u003c/code\u003e级别，即在一个MyBatis会话中执行的所有语句，都会共享这一个缓存。一种是\u003ccode\u003eSTATEMENT\u003c/code\u003e级别，可以理解为缓存只对当前执行的这一个\u003ccode\u003eStatement\u003c/code\u003e有效。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;setting name=\u0026#34;localCacheScope\u0026#34; value=\u0026#34;SESSION\u0026#34;/\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"一级缓存实验\"\u003e一级缓存实验\u003c/h3\u003e\u003cp\u003e接下来通过实验，了解MyBatis一级缓存的效果，每个单元测试后都请恢复被修改的数据。\u003c/p\u003e\u003cp\u003e首先是创建示例表student，创建对应的POJO类和增改的方法，具体可以在entity包和mapper包中查看。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eCREATE TABLE `student` (\n  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n  `name` varchar(200) COLLATE utf8_bin DEFAULT NULL,\n  `age` tinyint(3) unsigned DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_bin;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在以下实验中，id为1的学生名称是凯伦。\u003c/p\u003e\u003ch4 id=\"实验1\"\u003e实验1\u003c/h4\u003e\u003cp\u003e开启一级缓存，范围为会话级别，调用三次\u003ccode\u003egetStudentById\u003c/code\u003e，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void getStudentById() throws Exception {\n        SqlSession sqlSession = factory.openSession(true); // 自动提交事务\n        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);\n        System.out.println(studentMapper.getStudentById(1));\n        System.out.println(studentMapper.getStudentById(1));\n        System.out.println(studentMapper.getStudentById(1));\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行结果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/9e996384.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e我们可以看到，只有第一次真正查询了数据库，后续的查询使用了一级缓存。\u003c/p\u003e\u003ch4 id=\"实验2\"\u003e实验2\u003c/h4\u003e\u003cp\u003e增加了对数据库的修改操作，验证在一次数据库会话中，如果对数据库发生了修改操作，一级缓存是否会失效。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void addStudent() throws Exception {\n        SqlSession sqlSession = factory.openSession(true); // 自动提交事务\n        StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);\n        System.out.println(studentMapper.getStudentById(1));\n        System.out.println(\u0026#34;增加了\u0026#34; + studentMapper.addStudent(buildStudent()) + \u0026#34;个学生\u0026#34;);\n        System.out.println(studentMapper.getStudentById(1));\n        sqlSession.close();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行结果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/fb6a78e0.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e我们可以看到，在修改操作后执行的相同查询，查询了数据库，\u003cstrong\u003e一级缓存失效\u003c/strong\u003e。\u003c/p\u003e\u003ch4 id=\"实验3\"\u003e实验3\u003c/h4\u003e\u003cp\u003e开启两个\u003ccode\u003eSqlSession\u003c/code\u003e，在\u003ccode\u003esqlSession1\u003c/code\u003e中查询数据，使一级缓存生效，在\u003ccode\u003esqlSession2\u003c/code\u003e中更新数据库，验证一级缓存只在数据库会话内部共享。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testLocalCacheScope() throws Exception {\n        SqlSession sqlSession1 = factory.openSession(true); \n        SqlSession sqlSession2 = factory.openSession(true); \n\n        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);\n        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);\n\n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        System.out.println(\u0026#34;studentMapper2更新了\u0026#34; + studentMapper2.updateStudentName(\u0026#34;小岑\u0026#34;,1) + \u0026#34;个学生的数据\u0026#34;);\n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentById(1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f480ac76.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003esqlSession2\u003c/code\u003e更新了id为1的学生的姓名，从凯伦改为了小岑，但session1之后的查询中，id为1的学生的名字还是凯伦，出现了脏数据，也证明了之前的设想，一级缓存只在数据库会话内部共享。\u003c/p\u003e\u003ch3 id=\"一级缓存工作流程-源码分析\"\u003e一级缓存工作流程\u0026amp;源码分析\u003c/h3\u003e\u003cp\u003e那么，一级缓存的工作流程是怎样的呢？我们从源码层面来学习一下。\u003c/p\u003e\u003ch4 id=\"工作流程\"\u003e工作流程\u003c/h4\u003e\u003cp\u003e一级缓存执行的时序图，如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/bb851700.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"源码分析\"\u003e源码分析\u003c/h4\u003e\u003cp\u003e接下来将对MyBatis查询相关的核心类和一级缓存的源码进行走读。这对后面学习二级缓存也有帮助。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eSqlSession\u003c/strong\u003e： 对外提供了用户和数据库之间交互需要的所有方法，隐藏了底层的细节。默认实现类是\u003ccode\u003eDefaultSqlSession\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ba96bc7f.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eExecutor\u003c/strong\u003e： \u003ccode\u003eSqlSession\u003c/code\u003e向用户提供操作数据库的方法，但和数据库操作有关的职责都会委托给Executor。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ef5e0eb3.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如下图所示，Executor有若干个实现类，为Executor赋予了不同的能力，大家可以根据类名，自行学习每个类的基本作用。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/83326eb3.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在一级缓存的源码分析中，主要学习\u003ccode\u003eBaseExecutor\u003c/code\u003e的内部实现。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eBaseExecutor\u003c/strong\u003e： \u003ccode\u003eBaseExecutor\u003c/code\u003e是一个实现了Executor接口的抽象类，定义若干抽象方法，在执行的时候，把具体的操作委托给子类进行执行。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprotected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;\nprotected abstract List\u0026lt;BatchResult\u0026gt; doFlushStatements(boolean isRollback) throws SQLException;\nprotected abstract \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;\nprotected abstract \u0026lt;E\u0026gt; Cursor\u0026lt;E\u0026gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在一级缓存的介绍中提到对\u003ccode\u003eLocal Cache\u003c/code\u003e的查询和写入是在\u003ccode\u003eExecutor\u003c/code\u003e内部完成的。在阅读\u003ccode\u003eBaseExecutor\u003c/code\u003e的代码后发现\u003ccode\u003eLocal Cache\u003c/code\u003e是\u003ccode\u003eBaseExecutor\u003c/code\u003e内部的一个成员变量，如下代码所示。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic abstract class BaseExecutor implements Executor {\nprotected ConcurrentLinkedQueue\u0026lt;DeferredLoad\u0026gt; deferredLoads;\nprotected PerpetualCache localCache;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003eCache\u003c/strong\u003e： MyBatis中的Cache接口，提供了和缓存相关的最基本的操作，如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/793031d0.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e有若干个实现类，使用装饰器模式互相组装，提供丰富的操控缓存的能力，部分实现类如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cdb21712.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eBaseExecutor\u003c/code\u003e成员变量之一的\u003ccode\u003ePerpetualCache\u003c/code\u003e，是对Cache接口最基本的实现，其实现非常简单，内部持有HashMap，对一级缓存的操作实则是对HashMap的操作。如下代码所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class PerpetualCache implements Cache {\n  private String id;\n  private Map\u0026lt;Object, Object\u0026gt; cache = new HashMap\u0026lt;Object, Object\u0026gt;();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在阅读相关核心类代码后，从源代码层面对一级缓存工作中涉及到的相关代码，出于篇幅的考虑，对源码做适当删减，读者朋友可以结合本文，后续进行更详细的学习。\u003c/p\u003e\u003cp\u003e为执行和数据库的交互，首先需要初始化\u003ccode\u003eSqlSession\u003c/code\u003e，通过\u003ccode\u003eDefaultSqlSessionFactory\u003c/code\u003e开启\u003ccode\u003eSqlSession\u003c/code\u003e：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {\n    ............\n    final Executor executor = configuration.newExecutor(tx, execType);     \n    return new DefaultSqlSession(configuration, executor, autoCommit);\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在初始化\u003ccode\u003eSqlSesion\u003c/code\u003e时，会使用\u003ccode\u003eConfiguration\u003c/code\u003e类创建一个全新的\u003ccode\u003eExecutor\u003c/code\u003e，作为\u003ccode\u003eDefaultSqlSession\u003c/code\u003e构造函数的参数，创建Executor代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic Executor newExecutor(Transaction transaction, ExecutorType executorType) {\n    executorType = executorType == null ? defaultExecutorType : executorType;\n    executorType = executorType == null ? ExecutorType.SIMPLE : executorType;\n    Executor executor;\n    if (ExecutorType.BATCH == executorType) {\n      executor = new BatchExecutor(this, transaction);\n    } else if (ExecutorType.REUSE == executorType) {\n      executor = new ReuseExecutor(this, transaction);\n    } else {\n      executor = new SimpleExecutor(this, transaction);\n    }\n    // 尤其可以注意这里，如果二级缓存开关开启的话，是使用CahingExecutor装饰BaseExecutor的子类\n    if (cacheEnabled) {\n      executor = new CachingExecutor(executor);                      \n    }\n    executor = (Executor) interceptorChain.pluginAll(executor);\n    return executor;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eSqlSession\u003c/code\u003e创建完毕后，根据Statment的不同类型，会进入\u003ccode\u003eSqlSession\u003c/code\u003e的不同方法中，如果是\u003ccode\u003eSelect\u003c/code\u003e语句的话，最后会执行到\u003ccode\u003eSqlSession\u003c/code\u003e的\u003ccode\u003eselectList\u003c/code\u003e，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; selectList(String statement, Object parameter, RowBounds rowBounds) {\n      MappedStatement ms = configuration.getMappedStatement(statement);\n      return executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eSqlSession\u003c/code\u003e把具体的查询职责委托给了Executor。如果只开启了一级缓存的话，首先会进入\u003ccode\u003eBaseExecutor\u003c/code\u003e的\u003ccode\u003equery\u003c/code\u003e方法。代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic \u0026lt;E\u0026gt; List\u0026lt;E\u0026gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {\n    BoundSql boundSql = ms.getBoundSql(parameter);\n    CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql);\n    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在上述代码中，会先根据传入的参数生成CacheKey，进入该方法查看CacheKey是如何生成的，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCacheKey cacheKey = new CacheKey();\ncacheKey.update(ms.getId());\ncacheKey.update(rowBounds.getOffset());\ncacheKey.update(rowBounds.getLimit());\ncacheKey.update(boundSql.getSql());\n//后面是update了sql中带的参数\ncacheKey.update(value);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在上述的代码中，将\u003ccode\u003eMappedStatement\u003c/code\u003e的Id、SQL的offset、SQL的limit、SQL本身以及SQL中的参数传入了CacheKey这个类，最终构成CacheKey。以下是这个类的内部结构：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate static final int DEFAULT_MULTIPLYER = 37;\nprivate static final int DEFAULT_HASHCODE = 17;\n\nprivate int multiplier;\nprivate int hashcode;\nprivate long checksum;\nprivate int count;\nprivate List\u0026lt;Object\u0026gt; updateList;\n\npublic CacheKey() {\n    this.hashcode = DEFAULT_HASHCODE;\n    this.multiplier = DEFAULT_MULTIPLYER;\n    this.count = 0;\n    this.updateList = new ArrayList\u0026lt;Object\u0026gt;();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e首先是成员变量和构造函数，有一个初始的\u003ccode\u003ehachcode\u003c/code\u003e和乘数，同时维护了一个内部的\u003ccode\u003eupdatelist\u003c/code\u003e。在\u003ccode\u003eCacheKey\u003c/code\u003e的\u003ccode\u003eupdate\u003c/code\u003e方法中，会进行一个\u003ccode\u003ehashcode\u003c/code\u003e和\u003ccode\u003echecksum\u003c/code\u003e的计算，同时把传入的参数添加进\u003ccode\u003eupdatelist\u003c/code\u003e中。如下代码所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void update(Object object) {\n    int baseHashCode = object == null ? 1 : ArrayUtil.hashCode(object); \n    count++;\n    checksum += baseHashCode;\n    baseHashCode *= count;\n    hashcode = multiplier * hashcode + baseHashCode;\n    \n    updateList.add(object);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同时重写了\u003ccode\u003eCacheKey\u003c/code\u003e的\u003ccode\u003eequals\u003c/code\u003e方法，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic boolean equals(Object object) {\n    .............\n    for (int i = 0; i \u0026lt; updateList.size(); i++) {\n      Object thisObject = updateList.get(i);\n      Object thatObject = cacheKey.updateList.get(i);\n      if (!ArrayUtil.equals(thisObject, thatObject)) {\n        return false;\n      }\n    }\n    return true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e除去hashcode、checksum和count的比较外，只要updatelist中的元素一一对应相等，那么就可以认为是CacheKey相等。只要两条SQL的下列五个值相同，即可以认为是相同的SQL。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eStatement Id + Offset + Limmit + Sql + Params\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003eBaseExecutor的query方法继续往下走，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003elist = resultHandler == null ? (List\u0026lt;E\u0026gt;) localCache.getObject(key) : null;\nif (list != null) {\n    // 这个主要是处理存储过程用的。\n    handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);\n    } else {\n    list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果查不到的话，就从数据库查，在\u003ccode\u003equeryFromDatabase\u003c/code\u003e中，会对\u003ccode\u003elocalcache\u003c/code\u003e进行写入。\u003c/p\u003e\u003cp\u003e在\u003ccode\u003equery\u003c/code\u003e方法执行的最后，会判断一级缓存级别是否是\u003ccode\u003eSTATEMENT\u003c/code\u003e级别，如果是的话，就清空缓存，这也就是\u003ccode\u003eSTATEMENT\u003c/code\u003e级别的一级缓存无法共享\u003ccode\u003elocalCache\u003c/code\u003e的原因。代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) {\n        clearLocalCache();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在源码分析的最后，我们确认一下，如果是\u003ccode\u003einsert/delete/update\u003c/code\u003e方法，缓存就会刷新的原因。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eSqlSession\u003c/code\u003e的\u003ccode\u003einsert\u003c/code\u003e方法和\u003ccode\u003edelete\u003c/code\u003e方法，都会统一走\u003ccode\u003eupdate\u003c/code\u003e的流程，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic int insert(String statement, Object parameter) {\n    return update(statement, parameter);\n  }\n   @Override\n  public int delete(String statement) {\n    return update(statement, null);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eupdate\u003c/code\u003e方法也是委托给了\u003ccode\u003eExecutor\u003c/code\u003e执行。\u003ccode\u003eBaseExecutor\u003c/code\u003e的执行方法如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic int update(MappedStatement ms, Object parameter) throws SQLException {\n    ErrorContext.instance().resource(ms.getResource()).activity(\u0026#34;executing an update\u0026#34;).object(ms.getId());\n    if (closed) {\n      throw new ExecutorException(\u0026#34;Executor was closed.\u0026#34;);\n    }\n    clearLocalCache();\n    return doUpdate(ms, parameter);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e每次执行\u003ccode\u003eupdate\u003c/code\u003e前都会清空\u003ccode\u003elocalCache\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e至此，一级缓存的工作流程讲解以及源码分析完毕。\u003c/p\u003e\u003ch3 id=\"总结\"\u003e总结\u003c/h3\u003e\u003col\u003e\u003cli\u003eMyBatis一级缓存的生命周期和SqlSession一致。\u003c/li\u003e\u003cli\u003eMyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。\u003c/li\u003e\u003cli\u003eMyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"二级缓存\"\u003e二级缓存\u003c/h2\u003e\u003ch3 id=\"二级缓存介绍\"\u003e二级缓存介绍\u003c/h3\u003e\u003cp\u003e在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/28399eba.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。\u003c/p\u003e\u003cp\u003e当开启缓存后，数据的查询执行的流程就是 二级缓存 -\u0026gt; 一级缓存 -\u0026gt; 数据库。\u003c/p\u003e\u003ch3 id=\"二级缓存配置\"\u003e二级缓存配置\u003c/h3\u003e\u003cp\u003e要正确的使用二级缓存，需完成如下配置的。\u003c/p\u003e\u003col\u003e\u003cli\u003e在MyBatis的配置文件中开启二级缓存。\u003cbr/\u003e\u003c/li\u003e\u003c/ol\u003e\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;setting name=\u0026#34;cacheEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003col\u003e\u003cli\u003e在MyBatis的映射XML中配置cache或者 cache-ref 。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003ecache标签用于声明这个namespace使用二级缓存，并且可以自定义配置。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;cache/\u0026gt;   \n\u003c/code\u003e\u003c/pre\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003etype\u003c/code\u003e：cache使用的类型，默认是\u003ccode\u003ePerpetualCache\u003c/code\u003e，这在一级缓存中提到过。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eeviction\u003c/code\u003e： 定义回收的策略，常见的有FIFO，LRU。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eflushInterval\u003c/code\u003e： 配置一定时间自动刷新缓存，单位是毫秒。\u003c/li\u003e\u003cli\u003e\u003ccode\u003esize\u003c/code\u003e： 最多缓存对象的个数。\u003c/li\u003e\u003cli\u003e\u003ccode\u003ereadOnly\u003c/code\u003e： 是否只读，若配置可读写，则需要对应的实体类能够序列化。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eblocking\u003c/code\u003e： 若缓存中找不到对应的key，是否会一直blocking，直到有对应的数据进入缓存。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003ccode\u003ecache-ref\u003c/code\u003e代表引用别的命名空间的Cache配置，两个命名空间的操作使用的是同一个Cache。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-xml\"\u003e\u0026lt;cache-ref namespace=\u0026#34;mapper.StudentMapper\u0026#34;/\u0026gt;\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"二级缓存实验\"\u003e二级缓存实验\u003c/h3\u003e\u003cp\u003e接下来我们通过实验，了解MyBatis二级缓存在使用上的一些特点。\u003c/p\u003e\u003cp\u003e在本实验中，id为1的学生名称初始化为点点。\u003c/p\u003e\u003ch4 id=\"实验1-1\"\u003e实验1\u003c/h4\u003e\u003cp\u003e测试二级缓存效果，不提交事务，\u003ccode\u003esqlSession1\u003c/code\u003e查询完数据后，\u003ccode\u003esqlSession2\u003c/code\u003e相同的查询是否会从缓存中获取数据。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testCacheWithoutCommitOrClose() throws Exception {\n        SqlSession sqlSession1 = factory.openSession(true); \n        SqlSession sqlSession2 = factory.openSession(true); \n        \n        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);\n        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);\n\n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentById(1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行结果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/71e2bfdc.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e我们可以看到，当\u003ccode\u003esqlsession\u003c/code\u003e没有调用\u003ccode\u003ecommit()\u003c/code\u003e方法时，二级缓存并没有起到作用。\u003c/p\u003e\u003ch4 id=\"实验2-1\"\u003e实验2\u003c/h4\u003e\u003cp\u003e测试二级缓存效果，当提交事务时，\u003ccode\u003esqlSession1\u003c/code\u003e查询完数据后，\u003ccode\u003esqlSession2\u003c/code\u003e相同的查询是否会从缓存中获取数据。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testCacheWithCommitOrClose() throws Exception {\n        SqlSession sqlSession1 = factory.openSession(true); \n        SqlSession sqlSession2 = factory.openSession(true); \n        \n        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);\n        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);\n\n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        sqlSession1.commit();\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentById(1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f366f34e.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从图上可知，\u003ccode\u003esqlsession2\u003c/code\u003e的查询，使用了缓存，缓存的命中率是0.5。\u003c/p\u003e\u003ch4 id=\"实验3-1\"\u003e实验3\u003c/h4\u003e\u003cp\u003e测试\u003ccode\u003eupdate\u003c/code\u003e操作是否会刷新该\u003ccode\u003enamespace\u003c/code\u003e下的二级缓存。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testCacheWithUpdate() throws Exception {\n        SqlSession sqlSession1 = factory.openSession(true); \n        SqlSession sqlSession2 = factory.openSession(true); \n        SqlSession sqlSession3 = factory.openSession(true); \n        \n        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);\n        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);\n        StudentMapper studentMapper3 = sqlSession3.getMapper(StudentMapper.class);\n        \n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentById(1));\n        sqlSession1.commit();\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentById(1));\n        \n        studentMapper3.updateStudentName(\u0026#34;方方\u0026#34;,1);\n        sqlSession3.commit();\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentById(1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/3ad93c3a.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e我们可以看到，在\u003ccode\u003esqlSession3\u003c/code\u003e更新数据库，并提交事务后，\u003ccode\u003esqlsession2\u003c/code\u003e的\u003ccode\u003eStudentMapper namespace\u003c/code\u003e下的查询走了数据库，没有走Cache。\u003c/p\u003e\u003ch4 id=\"实验4\"\u003e实验4\u003c/h4\u003e\u003cp\u003e验证MyBatis的二级缓存不适应用于映射文件中存在多表查询的情况。\u003c/p\u003e\u003cp\u003e通常我们会为每个单表创建单独的映射文件，由于MyBatis的二级缓存是基于\u003ccode\u003enamespace\u003c/code\u003e的，多表查询语句所在的\u003ccode\u003enamspace\u003c/code\u003e无法感应到其他\u003ccode\u003enamespace\u003c/code\u003e中的语句对多表查询中涉及的表进行的修改，引发脏数据问题。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Test\npublic void testCacheWithDiffererntNamespace() throws Exception {\n        SqlSession sqlSession1 = factory.openSession(true); \n        SqlSession sqlSession2 = factory.openSession(true); \n        SqlSession sqlSession3 = factory.openSession(true); \n    \n        StudentMapper studentMapper = sqlSession1.getMapper(StudentMapper.class);\n        StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);\n        ClassMapper classMapper = sqlSession3.getMapper(ClassMapper.class);\n        \n        System.out.println(\u0026#34;studentMapper读取数据: \u0026#34; + studentMapper.getStudentByIdWithClassInfo(1));\n        sqlSession1.close();\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentByIdWithClassInfo(1));\n\n        classMapper.updateClassName(\u0026#34;特色一班\u0026#34;,1);\n        sqlSession3.commit();\n        System.out.println(\u0026#34;studentMapper2读取数据: \u0026#34; + studentMapper2.getStudentByIdWithClassInfo(1));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e执行结果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/5265ed97.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在这个实验中，我们引入了两张新的表，一张class，一张classroom。class中保存了班级的id和班级名，classroom中保存了班级id和学生id。我们在\u003ccode\u003eStudentMapper\u003c/code\u003e中增加了一个查询方法\u003ccode\u003egetStudentByIdWithClassInfo\u003c/code\u003e，用于查询学生所在的班级，涉及到多表查询。在\u003ccode\u003eClassMapper\u003c/code\u003e中添加了\u003ccode\u003eupdateClassName\u003c/code\u003e，根据班级id更新班级名的操作。\u003c/p\u003e\u003cp\u003e当\u003ccode\u003esqlsession1\u003c/code\u003e的\u003ccode\u003estudentmapper\u003c/code\u003e查询数据后，二级缓存生效。保存在StudentMapper的namespace下的cache中。当\u003ccode\u003esqlSession3\u003c/code\u003e的\u003ccode\u003eclassMapper\u003c/code\u003e的\u003ccode\u003eupdateClassName\u003c/code\u003e方法对class表进行更新时，\u003ccode\u003eupdateClassName\u003c/code\u003e不属于\u003ccode\u003eStudentMapper\u003c/code\u003e的\u003ccode\u003enamespace\u003c/code\u003e，所以\u003ccode\u003eStudentMapper\u003c/code\u003e下的cache没有感应到变化，没有刷新缓存。当\u003ccode\u003eStudentMapper\u003c/code\u003e中同样的查询再次发起时，从缓存中读取了脏数据。\u003c/p\u003e\u003ch4 id=\"实验5\"\u003e实验5\u003c/h4\u003e\u003cp\u003e为了解决实验4的问题呢，可以使用Cache ref，让\u003ccode\u003eClassMapper\u003c/code\u003e引用\u003ccode\u003eStudenMapper\u003c/code\u003e命名空间，这样两个映射文件对应的SQL操作都使用的是同一块缓存了。\u003c/p\u003e\u003cp\u003e执行结果：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a2e4c2d8.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e不过这样做的后果是，缓存的粒度变粗了，多个\u003ccode\u003eMapper namespace\u003c/code\u003e下的所有操作都会对缓存使用造成影响。\u003c/p\u003e\u003ch3 id=\"二级缓存源码分析\"\u003e二级缓存源码分析\u003c/h3\u003e\u003cp\u003eMyBatis二级缓存的工作流程和前文提到的一级缓存类似，只是在一级缓存处理前，用\u003ccode\u003eCachingExecutor\u003c/code\u003e装饰了\u003ccode\u003eBaseExecutor\u003c/code\u003e的子类，在委托具体职责给\u003ccode\u003edelegate\u003c/code\u003e之前，实现了二级缓存的查询和写入功能，具体类关系图如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/090216b1.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003ch4 id=\"源码分析-1\"\u003e源码分析\u003c/h4\u003e\u003cp\u003e源码分析从\u003ccode\u003eCachingExecutor\u003c/code\u003e的\u003ccode\u003equery\u003c/code\u003e方法展开，源代码走读过程中涉及到的知识点较多，不能一一详细讲解，读者朋友可以自行查询相关资料来学习。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eCachingExecutor\u003c/code\u003e的\u003ccode\u003equery\u003c/code\u003e方法，首先会从\u003ccode\u003eMappedStatement\u003c/code\u003e中获得在配置初始化时赋予的Cache。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eCache cache = ms.getCache();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e本质上是装饰器模式的使用，具体的装饰链是：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eSynchronizedCache -\u0026gt; LoggingCache -\u0026gt; SerializedCache -\u0026gt; LruCache -\u0026gt; PerpetualCache。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/1f5233b2.jpg\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e以下是具体这些Cache实现类的介绍，他们的组合为Cache赋予了不同的能力。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eSynchronizedCache\u003c/code\u003e：同步Cache，实现比较简单，直接使用synchronized修饰方法。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eLoggingCache\u003c/code\u003e：日志功能，装饰类，用于记录缓存的命中率，如果开启了DEBUG模式，则会输出命中率日志。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eSerializedCache\u003c/code\u003e：序列化功能，将值序列化后存到缓存中。该功能用于缓存返回一份实例的Copy，用于保存线程安全。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eLruCache\u003c/code\u003e：采用了Lru算法的Cache实现，移除最近最少使用的Key/Value。\u003c/li\u003e\u003cli\u003e\u003ccode\u003ePerpetualCache\u003c/code\u003e： 作为为最基础的缓存类，底层实现比较简单，直接使用了HashMap。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e然后是判断是否需要刷新缓存，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eflushCacheIfRequired(ms);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在默认的设置中\u003ccode\u003eSELECT\u003c/code\u003e语句不会刷新缓存，\u003ccode\u003einsert/update/delte\u003c/code\u003e会刷新缓存。进入该方法。代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void flushCacheIfRequired(MappedStatement ms) {\n    Cache cache = ms.getCache();\n    if (cache != null \u0026amp;\u0026amp; ms.isFlushCacheRequired()) {      \n      tcm.clear(cache);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eMyBatis的\u003ccode\u003eCachingExecutor\u003c/code\u003e持有了\u003ccode\u003eTransactionalCacheManager\u003c/code\u003e，即上述代码中的tcm。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eTransactionalCacheManager\u003c/code\u003e中持有了一个Map，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate Map\u0026lt;Cache, TransactionalCache\u0026gt; transactionalCaches = new HashMap\u0026lt;Cache, TransactionalCache\u0026gt;();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这个Map保存了Cache和用\u003ccode\u003eTransactionalCache\u003c/code\u003e包装后的Cache的映射关系。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eTransactionalCache\u003c/code\u003e实现了Cache接口，\u003ccode\u003eCachingExecutor\u003c/code\u003e会默认使用他包装初始生成的Cache，作用是如果事务提交，对缓存的操作才会生效，如果事务回滚或者不提交事务，则不对缓存产生影响。\u003c/p\u003e\u003cp\u003e在\u003ccode\u003eTransactionalCache\u003c/code\u003e的clear，有以下两句。清空了需要在提交时加入缓存的列表，同时设定提交时清空缓存，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void clear() {\n\tclearOnCommit = true;\n\tentriesToAddOnCommit.clear();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eCachingExecutor\u003c/code\u003e继续往下走，\u003ccode\u003eensureNoOutParams\u003c/code\u003e主要是用来处理存储过程的，暂时不用考虑。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (ms.isUseCache() \u0026amp;\u0026amp; resultHandler == null) {\n\tensureNoOutParams(ms, parameterObject, boundSql);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e之后会尝试从tcm中获取缓存的列表。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eList\u0026lt;E\u0026gt; list = (List\u0026lt;E\u0026gt;) tcm.getObject(cache, key);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在\u003ccode\u003egetObject\u003c/code\u003e方法中，会把获取值的职责一路传递，最终到\u003ccode\u003ePerpetualCache\u003c/code\u003e。如果没有查到，会把key加入Miss集合，这个主要是为了统计命中率。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eObject object = delegate.getObject(key);\nif (object == null) {\n\tentriesMissedInCache.add(key);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003ccode\u003eCachingExecutor\u003c/code\u003e继续往下走，如果查询到数据，则调用\u003ccode\u003etcm.putObject\u003c/code\u003e方法，往缓存中放入值。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eif (list == null) {\n\tlist = delegate.\u0026lt;E\u0026gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);\n\ttcm.putObject(cache, key, list); // issue #578 and #116\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003etcm的\u003ccode\u003eput\u003c/code\u003e方法也不是直接操作缓存，只是在把这次的数据和key放入待提交的Map中。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void putObject(Object key, Object object) {\n    entriesToAddOnCommit.put(key, object);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从以上的代码分析中，我们可以明白，如果不调用\u003ccode\u003ecommit\u003c/code\u003e方法的话，由于\u003ccode\u003eTranscationalCache\u003c/code\u003e的作用，并不会对二级缓存造成直接的影响。因此我们看看\u003ccode\u003eSqlsession\u003c/code\u003e的\u003ccode\u003ecommit\u003c/code\u003e方法中做了什么。代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void commit(boolean force) {\n    try {\n      executor.commit(isCommitOrRollbackRequired(force));\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e因为我们使用了CachingExecutor，首先会进入CachingExecutor实现的commit方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e@Override\npublic void commit(boolean required) throws SQLException {\n    delegate.commit(required);\n    tcm.commit();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e会把具体commit的职责委托给包装的\u003ccode\u003eExecutor\u003c/code\u003e。主要是看下\u003ccode\u003etcm.commit()\u003c/code\u003e，tcm最终又会调用到\u003ccode\u003eTrancationalCache\u003c/code\u003e。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic void commit() {\n    if (clearOnCommit) {\n      delegate.clear();\n    }\n    flushPendingEntries();\n    reset();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看到这里的\u003ccode\u003eclearOnCommit\u003c/code\u003e就想起刚才\u003ccode\u003eTrancationalCache\u003c/code\u003e的\u003ccode\u003eclear\u003c/code\u003e方法设置的标志位，真正的清理Cache是放到这里来进行的。具体清理的职责委托给了包装的Cache类。之后进入\u003ccode\u003eflushPendingEntries\u003c/code\u003e方法。代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void flushPendingEntries() {\n    for (Map.Entry\u0026lt;Object, Object\u0026gt; entry : entriesToAddOnCommit.entrySet()) {\n      delegate.putObject(entry.getKey(), entry.getValue());\n    }\n    ................\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在\u003ccode\u003eflushPending\u003c/code\u003eEntries中，将待提交的Map进行循环处理，委托给包装的Cache类，进行\u003ccode\u003eputObject\u003c/code\u003e的操作。\u003c/p\u003e\u003cp\u003e后续的查询操作会重复执行这套流程。如果是\u003ccode\u003einsert|update|delete\u003c/code\u003e的话，会统一进入\u003ccode\u003eCachingExecutor\u003c/code\u003e的\u003ccode\u003eupdate\u003c/code\u003e方法，其中调用了这个函数，代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eprivate void flushCacheIfRequired(MappedStatement ms) \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在二级缓存执行流程后就会进入一级缓存的执行流程，因此不再赘述。\u003c/p\u003e\u003ch3 id=\"总结-1\"\u003e总结\u003c/h3\u003e\u003col\u003e\u003cli\u003eMyBatis的二级缓存相对于一级缓存来说，实现了\u003ccode\u003eSqlSession\u003c/code\u003e之间缓存数据的共享，同时粒度更加的细，能够到\u003ccode\u003enamespace\u003c/code\u003e级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。\u003c/li\u003e\u003cli\u003eMyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。\u003c/li\u003e\u003cli\u003e在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"全文总结\"\u003e全文总结\u003c/h2\u003e\u003cp\u003e本文对介绍了MyBatis一二级缓存的基本概念，并从应用及源码的角度对MyBatis的缓存机制进行了分析。最后对MyBatis缓存机制做了一定的总结，个人建议MyBatis缓存特性在生产环境中进行关闭，单纯作为一个ORM框架使用可能更为合适。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e凯伦，美团点评后端研发工程师，2016年毕业于上海海事大学，现从事美团点评餐饮平台相关的开发工作。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团点评点餐事业部期待你的加入，上海在招岗位：Java后台，数据开发，前端，QA，产品，产品运营，商业分析等。内推简历邮箱：weiyanping#meituan.com\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-01-19T00:00:00Z",
  "Author": "soulteary@gmail.com"
}