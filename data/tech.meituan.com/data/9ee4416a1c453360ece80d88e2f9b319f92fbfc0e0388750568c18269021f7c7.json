{
  "Source": "tech.meituan.com",
  "Title": "Android 兼容 Java 8 语法特性的原理分析",
  "Link": "https://tech.meituan.com/2019/10/17/android-java-8.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e本文主要阐述了Lambda表达式及其底层实现（invokedynamic指令）的原理、Android第三方插件RetroLambda对其的支持过程、Android官方最新的dex编译器D8对其的编译支持。通过对这三个方面的跟踪分析，以Java 8的代表性特性——Lambda表达式为着眼点，将Android如何兼容Java8的过程分享给大家。\u003c/p\u003e\u003ch2 id=\"java-8概述\"\u003eJava 8概述\u003c/h2\u003e\u003cp\u003eJava 8是Java开发语言非常重要的一个版本。Oracle从2014年3月18日发布Java 8，从该版本起，Java开始支持函数式编程。特别是吸收了运行在JVM上的Scala、Groovy等动态脚本语言的特性之后，Java 8在语言的表达力、简洁性两个方面有了很大的提高。\u003c/p\u003e\u003cp\u003eJava 8的主要语言特性改进概括起来包括以下几点：\u003c/p\u003e\u003cul\u003e\u003cli\u003eLambda表达 （函数闭包）\u003c/li\u003e\u003cli\u003e函数式接口 （@FunctionalInterface）\u003c/li\u003e\u003cli\u003eStream API （通过流式调用支持map、filter等高阶函数）\u003c/li\u003e\u003cli\u003e方法引用（使用::关键字将函数转化为对象）\u003c/li\u003e\u003cli\u003e默认方法（抽象接口中允许存在default修饰的非抽象方法）\u003c/li\u003e\u003cli\u003e类型注解和重复注解\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e其中Lambda表达、函数式接口、方法引用三个特性为Java带来了函数式编程的风格；而Stream实现了map、filter、reduce等常见的高阶函数，数据源囊括了数组、集合、IO通道等，这些又为Java带来了流式编程或者说链式编程的风格，以上这些风格让Java变得越来越现代化和易用。\u003c/p\u003e\u003ch2 id=\"android和java关系\"\u003eAndroid和Java关系\u003c/h2\u003e\u003cp\u003e其实Java在Android的快速发展过程中扮演着非常重要的角色，无论是作为开发语言（Java）、开发Framework（Android-SDK引用了80%的JDK-API），还是开发工具（Eclipse or Android Studio）。这些都和Java有着千丝万缕的关系。不过可能是受到与Oracle的法律诉讼的影响，Google在Android上针对Java的升级一直都不是很积极：\u003c/p\u003e\u003cul\u003e\u003cli\u003eAndroid 从1.0 一直升级到4.4，迭代了将近19个Android版本，才在4.4版本中支持了Java 7。\u003c/li\u003e\u003cli\u003e然后从Android 4.4版本开始算起，一直到Android N(7.0)共4个Android版本，才在Jack/Jill工具链勉强支持了Java 8。但由于Jack/Jill工具链在构建流程中舍弃了原有Java字节码的体系，导致大量既有的技术沉淀无法应用，致使许多App工程放弃了接入。\u003c/li\u003e\u003cli\u003e最后直到Android P(9.0)版本， Google 才在Android Studio 3.x中通过新增的D8 dex编译器正式支持了Java 8，但部分API并不能全版本支持。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e可谓”历经坎坷“。特别是Rx大行其道的今天，Rx配合Java 8特性Lambda带来简洁、高效的开发体验，更是让Android Developer望眼欲穿。\u003c/p\u003e\u003cp\u003e接下来，本文将从技术原理层面，来分析一下Android是如何支持Java 8的。\u003c/p\u003e\u003ch2 id=\"lambda-表达式\"\u003eLambda 表达式\u003c/h2\u003e\u003cp\u003e想要更好的理解Android对Java 8的支持过程，Lambda表达式这一代表性的”语法糖“是一个非常不错的切入点。所以，我们首先需要搞清楚Lambda表达式到底是什么？其底层的实现原理又是什么？\u003c/p\u003e\u003cp\u003eLambda表达式是Java支持函数式编程的基础，也可以称之为闭包。简单来说，就是在Java语法层面允许将函数当作方法的参数，函数可以当做对象。任一Lambda表达式都有且只有一个函数式接口与之对应，从这个角度来看，也可以说是该函数式接口的实例化。\u003c/p\u003e\u003ch3 id=\"lambda表达式\"\u003eLambda表达式\u003c/h3\u003e\u003cp\u003e通用格式：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/444980fd4037922bc13014b03b20f23634374.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e简单范例：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/e972a2c3d479d169cf8cf142d68c159062191.png\" alt=\"\"/\u003e\n\u003cimg src=\"https://p0.meituan.net/travelcube/6068641d4f4e27a1d73c0dbcbab2a93276779.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e说明：\u003c/p\u003e\u003cul\u003e\u003cli\u003eLambda表达式中 () 对应的是函数式接口-run方法的参数列表。\u003c/li\u003e\u003cli\u003eLambda表达式中 System.out.println(“xixi”) / System.out.println(“haha”)，在运行时会是具体的run方法实现。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"lambda表达式原理\"\u003eLambda表达式原理\u003c/h3\u003e\u003cp\u003e针对实例中的代码，我们来看下编译之后的字节码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ejavac J8Sample.java  -\u0026gt;  J8Sample.class\n\njavap -c -p J8Sample.class \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/d259250e3b32956a2e9fd4c39d924062258434.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从字节码中我们可以看到：\u003c/p\u003e\u003cul\u003e\u003cli\u003e实例中 Lambda表达式1变成了字节码代码块中 Line 11的 0: invokedynamic #2, 0 // InvokeDynamic #0:run:()Ljava/lang/Runnable。\u003c/li\u003e\u003cli\u003e实例中 Lambda表达式2变成了字节码代码块中 Line 20的 21: invokedynamic #6, 0 // InvokeDynamic #1:run:()Ljava/lang/Runnable。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e可见，Lambda表达式在虚拟机层面上，是通过一种名为invokedynamic字节码指令来实现的。那么invokedynamic又是何方神圣呢？\u003c/p\u003e\u003ch3 id=\"invokedynamic-指令解读\"\u003einvokedynamic 指令解读\u003c/h3\u003e\u003cp\u003einvokedynamic指令是Java 7中新增的字节码调用指令，作为Java支持动态类型语言的改进之一，跟invokevirtual、invokestatic、invokeinterface、invokespecial四大指令一起构成了虚拟机层面各种Java方法的分配调用指令集。区别在于：\u003c/p\u003e\u003cul\u003e\u003cli\u003e后四种指令，在编译期间生成的class文件中，通过常量池(Constant Pool)的MethodRef常量已经固定了目标方法的符号信息（方法所属者及其类型，方法名字、参数顺序和类型、返回值）。虚拟机使用符号信息能直接解释出具体的方法，直接调用。\u003c/li\u003e\u003cli\u003e而invokedynamic指令在编译期间生成的class文件中，对应常量池(Constant Pool)的Invokedynamic_Info常量存储的符号信息中并没有方法所属者及其类型 ，替代的是BootstapMethod信息。在运行时，通过引导方法BootstrapMethod机制动态确定方法的所属者和类型。这一特点也非常契合动态类型语言只有在运行期间才能确定类型的特征。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e那么，invokedynamic如何通过引导方法找到所属者及其类型？我们依然结合前面的J8Sample实例：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ejavap -v J8Sample.class \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/0531f7923e0d48fa12d05c3b8f98e7f4235846.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e结合J8Sample.class字节码，并对invokedynamic指令调用过程进行跟踪分析。总结如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/cc454c19e86cc0b805d6dd2498b461f2521802.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e依据上图invokedynamic调用步骤，我们一步一步做一个分析讲解。\u003c/p\u003e\u003cp\u003e步骤1 选取J8Sample.java源码中Lambda表达式1：\u003c/p\u003e\u003cp\u003e\u003ccode\u003eRunnable runnable = () -\u0026gt; System.out.println(\u0026#34;xixi\u0026#34;); // lambda表达式1\u003c/code\u003e\u003c/p\u003e\u003cp\u003e步骤2 通过\u003ccode\u003ejavac J8Sample.java\u003c/code\u003e编译得到\u003ccode\u003eJ8Sample.class\u003c/code\u003e之后，\u003c/p\u003e\u003cp\u003e\u003ccode\u003eLambda表达式1变成：0: invokedynamic #2, 0 // InvokeDynamic #0:run:()Ljava/lang/Runnable;\u003c/code\u003e\u003c/p\u003e\u003cp\u003e对应在\u003ccode\u003eJ8Sample.class\u003c/code\u003e中发现了新增的私有静态方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/5bab930ff959c035ebb5020e34d725f842361.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e步骤3 针对表达式1的字节码分析 #2 对应的是class文件中的常量池：\u003c/p\u003e\u003cp\u003e\u003ccode\u003e#2 = InvokeDynamic #0:#35 // #0:run:()Ljava/lang/Runnable;\u003c/code\u003e\u003c/p\u003e\u003cp\u003e注意，这里InvokeDynamic不是指令，代表的是\u003ccode\u003eConstant_InvokeDynamic_Info\u003c/code\u003e结构。\u003c/p\u003e\u003cp\u003e步骤4 结构后面紧跟的 #0 标识的是class文件中的BootstrapMethod区域中引导方法的索引：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/100147fdb283b0a6b8a204cdd8e2f84476626.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e步骤5 引导方法中的 java/lang/invoke/LambdaMetafactory.metafactory才是invokedynamic指令的关键：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/cddf77db35bc90c74b4fa9999e9f758c99777.png\" alt=\"\"/\u003e\n\u003cimg src=\"https://p0.meituan.net/travelcube/cd38418b02ac05c3d751c9f780af521d264186.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e该方法会在运行时，在内存中动态生成一个实现Lambda表达式对应函数式接口的实例类型，并在接口的实现方法中调用步骤2中新增的静态私有方法。\u003c/p\u003e\u003cp\u003e步骤6 使用\u003ccode\u003ejava -Djdk.internal.lambda.dumpProxyClasses J8Sample.class\u003c/code\u003e运行一下，可以内存中动态生成的类型输出到本地：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/cd38418b02ac05c3d751c9f780af521d264186.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e步骤7 通过\u003ccode\u003ejavap -p -c J8Sample\\$\\$Lambda\\$1.class\u003c/code\u003e反编译一下，可以看到生成类的实现：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/2af7a8bcd2f36a769a7e8b5d38a63fdd61308.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在run方法中使用了invokestatic指令，直接调用了\u003ccode\u003eJ8Sample.lambda$main$0\u003c/code\u003e这个在编译期间生成的静态私有方法。\u003c/p\u003e\u003cp\u003e至此，上面7个步骤就是Lambda表达式在Java的底层的实现原理。Android 针对这些实现会怎么处理呢？\u003c/p\u003e\u003ch2 id=\"android不能直接支持\"\u003eAndroid不能直接支持\u003c/h2\u003e\u003cp\u003e回到Android系统上，Java-Bytecode（JVM字节码）是不能直接运行在Android系统上的，需要转换成Android-Bytecode（Dalvik/ART 字节码）。\u003c/p\u003e\u003cp\u003e如图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/34c99604582febd014f3dd1d86d0a16f126414.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过Lambda这节，我们知道Java底层是通过invokedynamic指令来实现，由于Dalvik/ART并没有支持invokedynamic指令或者对应的替代功能。简单的来说，就是Android的dex编译器不支持invokedynamic指令，导致Android不能直接支持Java 8。\u003c/p\u003e\u003ch2 id=\"android间接支持\"\u003eAndroid间接支持\u003c/h2\u003e\u003cp\u003e既然不能直接支持，那就只能在Java-Bytecode转换到Android-Bytecode这一过程中想办法，间接支持。这个间接支持的过程我们统称为Desugar（脱糖）过程。\u003c/p\u003e\u003cp\u003e官方流程图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/057b1c5145970b5967ac5161cb9ce4f939852.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当前，无论是RetroLambda，还是Google的Jack \u0026amp; Jill 工具，还是最新的D8 dex编译器：\u003c/p\u003e\u003cul\u003e\u003cli\u003e流程方面：都是按照如上图所示的官方流程进行Desugar的。\u003c/li\u003e\u003cli\u003e原理方面：却是参照Lambda在Java底层的实现，并将这些实现移至到RetroLambda插件或者Jack、D8编译器工具中。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e下面我们逐个分析解读一下。\u003c/p\u003e\u003ch3 id=\"android-间接支持之retrolambda\"\u003eAndroid 间接支持之RetroLambda\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/3ebabdc018eb9a70bfdf78ebec61d2a9121317.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如图所示，RetroLambda 的Desugar过程发生在javac将源码编译完成之后，dx工具进行dex编译之前。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eRetroLambda Desugar\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e其实就是参照invokedynamic指令解读一节中的步骤5，根据\u003ccode\u003ejava/lang/invoke/LambdaMetafactory.metafactory\u003c/code\u003e方法，直接将原本在运行时生成在内存中的\u003ccode\u003eJ8Sample\\$\\$Lambda\\$1.class\u003c/code\u003e，在javac编译结束之后，dx编译dex之前，直接生成到本地，并使用生成的\u003ccode\u003eJ8Sample\\$\\$Lambda\\$1\u003c/code\u003e类修改\u003ccode\u003eJ8Sample.class\u003c/code\u003e字节码文件，将\u003ccode\u003eJ8Sample.class\u003c/code\u003e中的invokedynamic指令替换成invokestatic指令。\u003c/p\u003e\u003cp\u003e将实例中的J8Sample.java放到一个配置了Retrolambda的Android工程中：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/5191083f295b3c20e9ae5f337c4e94b9187853.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eAndroidStudio -\u0026gt; Build -\u0026gt; make project 编译之后：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/7952c9572b22947f558929239c49a00b76261.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eapp:transformClassesWithRetrolambdaForDebug\u003c/code\u003e任务发生在\u003ccode\u003eapp:compileDebugJavaWithJavac\u003c/code\u003e（对应javac）之后，和\u003ccode\u003eapp:transformDexArchiveWithDexMergerForDebug\u003c/code\u003e（对应dx）之前，同时在\u003ccode\u003ebuild/intermediates/transforms/retrolambda\u003c/code\u003e下面生产如图所示的class文件。\u003c/p\u003e\u003cp\u003eJ8Sample.class和J8Sample$$Lambda$1.class反编译之后的代码如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/9f744da7596f73db27134edb5afa261076463.png\" alt=\"\"/\u003e\n\u003cimg src=\"https://p0.meituan.net/travelcube/8d27fa3362ef1dd97935f490dbe88fa092418.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过反编译代码，可以看出J8Sample.class中Lambda表达式已经被我们熟悉的1.7or1.6的语句所替代。\u003c/p\u003e\u003cp\u003e注意：右图中\u003ccode\u003eJ8Sample.lambda$main$0()\u003c/code\u003e方法在左图中没有显示出来，但是J8Sample.class字节码确实是存在的。\u003c/p\u003e\u003ch3 id=\"android间接支持之jack-jill工具\"\u003eAndroid间接支持之Jack\u0026amp;Jill工具\u003c/h3\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/027e99f20eeef86e228656841541b59f86492.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eJack是基于Eclipse的ecj编译开发的， Jill是基于ASM4开发的。Jack\u0026amp;Jill工具链是Google在Android N(7.0)发布的，用于替换javac\u0026amp;dx的工具链，并且在jack过程内置了Desugar过程。\u003c/p\u003e\u003cp\u003e但是在Android P(9.0) 的时候将Jack\u0026amp;Jill工具链废弃了，被 javac\u0026amp;D8工具链替代了。这里就不做Desugar具体分析了。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/ab8a7b1decd1dd43e71243ec794588d3104965.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eD8是Android P(9.0)新增的dex编译器。并在Android Studio 3.1版本中默认使用D8作为dex的默认编译器。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eD8 Desugar\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如图所示，Desugar过程放在了D8的内部，由Android Studio这个IDE来实现这个转换，原理基本和RetroLambda是一样。\u003c/p\u003e\u003cp\u003e本质上也是参照\u003ccode\u003ejava/lang/invoke/LambdaMetafactory.metafactory\u003c/code\u003e方法直接将原本在运行时生成在内存中的\u003ccode\u003eJ8Sample\\$\\$Lambda\\$1.class\u003c/code\u003e，在D8的编译dex期间，直接生成并写入到dex文件中。\u003c/p\u003e\u003cp\u003e同样，将实例中的J8Sample.java放到支持D8的Android工程中：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/de2fa02da3aa66f070c99f9dbcf359d3182079.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e同样，AndroidStudio -\u0026gt; Build -\u0026gt; make project编译之后：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/55c814e78a7810d8d419b453f1499a96739353.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003ejavac编译之后的\u003ccode\u003eJ8Sample.class\u003c/code\u003e还是使用invokedynamic指令，即这一步并没有Desugar：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/c26ed5054060f57a85471f7f67476e9a319678.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e在\u003ccode\u003eapp:transformDexArchiveWithDexMergerForDebug\u003c/code\u003e（对应dx）任务之后，再对应\u003ccode\u003ebuild/intermediates/transforms/dexMerger\u003c/code\u003e目录找第0个classex.dex。\u003c/p\u003e\u003cp\u003e执行\u003ccode\u003e$ANDROID_HOME/build-tools/28.0.3/dexdump -d classes.dex \u0026gt;\u0026gt; dexInfo.txt\u003c/code\u003e拿到dex信息。\u003c/p\u003e\u003cp\u003e还是选取实例中Lambda表达式1 ：\u003ccode\u003eRunnable runnable = () -\u0026gt; System.out.println(\u0026#34;xixi\u0026#34;);\u003c/code\u003e来进行分析。\u003c/p\u003e\u003cp\u003e这个dexIno.txt文件非常大，有1.4M，我们通过\u003ccode\u003ecom.J8Smaple2.J8Sample\u003c/code\u003e找到我们J8Sample在dex中位置。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/7496c4af41f91bce520f6d705eb7b176142376.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e新增方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/907b8286ef5322fc0a9ff0f082e6ae3d63610.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eJ8Sample.main方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/003c74e67cf30caa0e8bd92bf056f26f420949.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e图中选中部分，对应就是Lambda表达式1 desugar之后的内容。\u003c/p\u003e\u003cp\u003e翻译成Java的话就变成了：\u003ccode\u003enew Lcom/j8sample2/-$$Lambda$J8Sample$jWmuYH0zEF070TKXrjBFgnnqOKc\u003c/code\u003e这个生成类的一个对象。\u003c/p\u003e\u003cp\u003e类\u003ccode\u003eLcom/j8sample2/-$$Lambda$J8Sample$jWmuYH0zEF070TKXrjBFgnnqOKc\u003c/code\u003e对应前面的生成的\u003ccode\u003eJ8Sample$$Lambda$1\u003c/code\u003e类型，只不过数字1变成了Hash值。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/231e9e4c7e2ad6ff30136857ea782cd959106.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e实现Interface Ljava/lang/Runnable。\n\u003ccode\u003eLcom/j8sample2/-$$Lambda$J8Sample$jWmuYH0zEF070TKXrjBFgnnqOKc.run\u003c/code\u003e方法：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/4793902b949092487cc91df178e57f1348256.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e到这里，是不是和前面RetroLambda就一样了。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e至此，Lambda及其invokedynamic指令、RetroLambda插件、D8编译器各自的原理分析都已经结束了。\u003c/p\u003e\u003cp\u003e相比较Lambda在Java8自己内部的实现：即运行时，在内存中动态生成关联的函数式接口的实例类型，通过BSM-引导方法找到该内存类（字节码层面的反射）。\u003c/p\u003e\u003cp\u003e在Android上的其他三种Desugar方式，原理都是一样的，区别在于时机不同：\u003c/p\u003e\u003col\u003e\u003cli\u003eRetroLambda将函数式接口对应的实例类型的生产过程，放在javac编译之后，dx编译之前，并动态修改了表达式所属的字节码文件。\u003c/li\u003e\u003cli\u003eJack\u0026amp;Jill是直接将接口对应的实例类型，直接jack过程中生成，并编译进了dex文件。\u003c/li\u003e\u003cli\u003eD8的过程是在dex编译过程中，直接在内存生成接口对应的实例类型，并将生成的类型直接写入生成的dex文件中。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"探讨\"\u003e探讨\u003c/h2\u003e\u003cp\u003e无论是RetroLambda，还是D8，对Java8的特性也不是全都支持。\u003c/p\u003e\u003cp\u003eJava8新增的许多API（例如：新的DataAPI），就D8编译器而言，只有在Android P(9.0)版本中能直接运行。低于9.0就不行了。如何能够全版本支持Java 8。D8还有很长的一段路要走。\u003c/p\u003e\u003cp\u003e如果我们在低版本需要使用新的API，目前可以采取将这些API打包进去的临时办法。\u003c/p\u003e\u003cp\u003e写到这里，肯定有人要提出，为什么不直接使用Kotlin呢？确实Kotlin对Lambda表达式、函数引用等特性都做了很好的支持，但是现实的情况中，Kotlin很难取代Android中的Java。新业务、新工程还相对容易，对老业务来说，尤其是经过多年沉淀，工程结构复杂，迁移改造带来的收益，往往远远小于迁移改造带来的成本和不可控之风险。Kotlin和Java同时存在的情况，长期来看是一个必然的结果。\u003c/p\u003e\u003cp\u003e至于Java 8的其他特性呢，D8是如何实现的，也可以按照上面类似的方式去分析，甚至可以结合Kotlin实现的方式，一探究竟。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-10-17T00:00:00Z",
  "Author": "soulteary@gmail.com"
}