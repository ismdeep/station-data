{
  "Source": "tech.meituan.com",
  "Title": "SQL解析在美团的应用",
  "Link": "https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e数据库作为核心的基础组件，是需要重点保护的对象。任何一个线上的不慎操作，都有可能给数据库带来严重的故障，从而给业务造成巨大的损失。为了避免这种损失，一般会在管理上下功夫。比如为研发人员制定数据库开发规范；新上线的SQL，需要DBA进行审核；维护操作需要经过领导审批等等。而且如果希望能够有效地管理这些措施，需要有效的数据库培训，还需要DBA细心的进行SQL审核。很多中小型创业公司，可以通过设定规范、进行培训、完善审核流程来管理数据库。\u003c/p\u003e\u003cp\u003e随着美团的业务不断发展和壮大，上述措施的实施成本越来越高。如何更多的依赖技术手段，来提高效率，越来越受到重视。业界已有不少基于MySQL源码开发的SQL审核、优化建议等工具，极大的减轻了DBA的SQL审核负担。那么我们能否继续扩展MySQL的源码，来辅助DBA和研发人员来进一步提高效率呢？比如，更全面的SQL优化功能；多维度的慢查询分析；辅助故障分析等。要实现上述功能，其中最核心的技术之一就是SQL解析。\u003c/p\u003e\u003ch2 id=\"现状与场景\"\u003e现状与场景\u003c/h2\u003e\u003cp\u003eSQL解析是一项复杂的技术，一般都是由数据库厂商来掌握，当然也有公司专门提供\u003ca href=\"http://sqlparser.com/\"\u003eSQL解析的API\u003c/a\u003e。由于这几年MySQL数据库中间件的兴起，需要支持读写分离、分库分表等功能，就必须从SQL中抽出表名、库名以及相关字段的值。因此像Java语言编写的Druid，C语言编写的MaxScale，Go语言编写的Kingshard等，都会对SQL进行部分解析。而真正把SQL解析技术用于数据库维护的产品较少，主要有如下几个:\u003c/p\u003e\u003cul\u003e\u003cli\u003e美团开源的\u003ca href=\"https://github.com/Meituan-Dianping/SQLAdvisor\"\u003eSQLAdvisor\u003c/a\u003e。它基于MySQL原生态词法解析，结合分析SQL中的where条件、聚合条件、多表Join关系给出索引优化建议。\u003c/li\u003e\u003cli\u003e去哪儿开源的\u003ca href=\"http://mysql-inception.github.io/inception-document/\"\u003eInception\u003c/a\u003e。侧重于根据内置的规则，对SQL进行审核。\u003c/li\u003e\u003cli\u003e阿里的\u003ca href=\"https://yq.aliyun.com/articles/218442\"\u003eCloud DBA\u003c/a\u003e。根据官方文档介绍，其也是提供SQL优化建议和改写。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e上述产品都有非常合适的应用场景，在业界也被广泛使用。但是SQL解析的应用场景远远没有被充分发掘，比如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e基于表粒度的慢查询报表。比如，一个Schema中包含了属于不同业务线的数据表，那么从业务线的角度来说，其希望提供表粒度的慢查询报表。\u003c/li\u003e\u003cli\u003e生成SQL特征。将SQL语句中的值替换成问号，方便SQL归类。虽然可以使用正则表达式实现相同的功能，但是其Bug较多，可以参考pt-query-digest。比如pt-query-digest中，会把遇到的数字都替换成“?”，导致无法区别不同数字后缀的表。\u003c/li\u003e\u003cli\u003e高危操作确认与规避。比如，DBA不小心Drop数据表，而此类操作，目前还无有效的工具进行回滚，尤其是大表，其后果将是灾难性的。\u003c/li\u003e\u003cli\u003eSQL合法性判断。为了安全、审计、控制等方面的原因，美团不会让研发人员直接操作数据库，而是提供RDS服务。尤其是对于数据变更，需要研发人员的上级主管进行业务上的审批。如果研发人员，写了一条语法错误的SQL，而RDS无法判断该SQL是否合法，就会造成不必要的沟通成本。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e因此为了让所有有需要的业务都能方便的使用SQL解析功能，我们认为应该具有如下特性。\u003c/p\u003e\u003cul\u003e\u003cli\u003e直接暴露SQL解析接口，使用尽量简单。比如，输入SQL，则输出表名、特征和优化建议。\u003c/li\u003e\u003cli\u003e接口的使用不依赖于特定的语言，否则维护和使用的代价太高。比如，以HTTP等方式提供服务。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e千里之行，始于足下。下面我先介绍下SQL的解析原理。\u003c/p\u003e\u003ch2 id=\"原理\"\u003e原理\u003c/h2\u003e\u003cp\u003eSQL解析与优化是属于编译器范畴，和C等其他语言的解析没有本质的区别。其中分为，词法分析、语法和语义分析、优化、执行代码生成。对应到MySQL的部分，如下图\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/beca77cf.png\" alt=\"图1 SQL解析原理\"/\u003e\u003c/p\u003e\u003ch3 id=\"词法分析\"\u003e词法分析\u003c/h3\u003e\u003cp\u003eSQL解析由词法分析和语法/语义分析两个部分组成。词法分析主要是把输入转化成一个个Token。其中Token中包含Keyword（也称symbol）和非Keyword。例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"center\"\u003e关键字\u003c/th\u003e\u003cth align=\"center\"\u003e非关键字\u003c/th\u003e\u003cth align=\"center\"\u003e关键字\u003c/th\u003e\u003cth align=\"center\"\u003e非关键字\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"center\"\u003eselect\u003c/td\u003e\u003ctd align=\"center\"\u003eusername\u003c/td\u003e\u003ctd align=\"center\"\u003efrom\u003c/td\u003e\u003ctd align=\"center\"\u003euserinfo\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e通常情况下，词法分析可以使用\u003ca href=\"https://www.gnu.org/software/flex/\"\u003eFlex\u003c/a\u003e来生成，但是MySQL并未使用该工具，而是手写了词法分析部分（据说是为了效率和灵活性，参考\u003ca href=\"https://yq.aliyun.com/articles/71979\"\u003e此文\u003c/a\u003e）。具体代码在sql/lex.h和sql/sql_lex.cc文件中。\u003c/p\u003e\u003cp\u003eMySQL中的Keyword定义在sql/lex.h中，如下为部分Keyword：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-c\"\u003e{ \u0026#34;\u0026amp;\u0026amp;\u0026#34;,               SYM(AND_AND_SYM)},\n{ \u0026#34;\u0026lt;\u0026#34;,                SYM(LT)},\n{ \u0026#34;\u0026lt;=\u0026#34;,               SYM(LE)},\n{ \u0026#34;\u0026lt;\u0026gt;\u0026#34;,               SYM(NE)},\n{ \u0026#34;!=\u0026#34;,               SYM(NE)},\n{ \u0026#34;=\u0026#34;,                SYM(EQ)},\n{ \u0026#34;\u0026gt;\u0026#34;,                SYM(GT_SYM)},\n{ \u0026#34;\u0026gt;=\u0026#34;,               SYM(GE)},\n{ \u0026#34;\u0026lt;\u0026lt;\u0026#34;,               SYM(SHIFT_LEFT)},\n{ \u0026#34;\u0026gt;\u0026gt;\u0026#34;,               SYM(SHIFT_RIGHT)},\n{ \u0026#34;\u0026lt;=\u0026gt;\u0026#34;,              SYM(EQUAL_SYM)},\n{ \u0026#34;ACCESSIBLE\u0026#34;,       SYM(ACCESSIBLE_SYM)},\n{ \u0026#34;ACTION\u0026#34;,           SYM(ACTION)},\n{ \u0026#34;ADD\u0026#34;,              SYM(ADD)},\n{ \u0026#34;AFTER\u0026#34;,            SYM(AFTER_SYM)},\n{ \u0026#34;AGAINST\u0026#34;,          SYM(AGAINST)},\n{ \u0026#34;AGGREGATE\u0026#34;,        SYM(AGGREGATE_SYM)},\n{ \u0026#34;ALL\u0026#34;,              SYM(ALL)},\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e词法分析的核心代码在sql/sql_lex.c文件中的，MySQLLex→lex_one_Token，有兴趣的同学可以下载源码研究。\u003c/p\u003e\u003ch3 id=\"语法分析\"\u003e语法分析\u003c/h3\u003e\u003cp\u003e语法分析就是生成语法树的过程。这是整个解析过程中最精华，最复杂的部分，不过这部分MySQL使用了Bison来完成。即使如此，如何设计合适的数据结构以及相关算法，去存储和遍历所有的信息，也是值得在这里研究的。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e语法分析树\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eSQL语句：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect username, ismale from userinfo where age \u0026gt; 20 and level \u0026gt; 5 and 1 = 1\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e会生成如下语法树。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a74c9e9c.png\" alt=\"图2 语法树\"/\u003e\u003c/p\u003e\u003cp\u003e对于未接触过编译器实现的同学，肯定会好奇如何才能生成这样的语法树。其背后的原理都是编译器的范畴，可以参考维基百科的一篇\u003ca href=\"https://en.wikipedia.org/wiki/LR_parser\"\u003e文章\u003c/a\u003e，以及该链接中的参考书籍。本人也是在学习MySQL源码过程中，阅读了部分内容。由于编译器涉及的内容过多，本人精力和时间有限，不做过多探究。从工程的角度来说，学会如何使用Bison去构建语法树，来解决实际问题，对我们的工作也许有更大帮助。下面我就以Bison为基础，探讨该过程。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eMySQL语法分析树生成过程\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e全部的源码在sql/sql_yacc.yy中，在MySQL5.6中有17K行左右代码。这里列出涉及到SQL：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect username, ismale from userinfo where age \u0026gt; 20 and level \u0026gt; 5 and 1 = 1 \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e解析过程的部分代码摘录出来。其实有了Bison之后，SQL解析的难度也没有想象的那么大。特别是这里给出了解析的脉络之后。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-c\"\u003eselect /*select语句入口*/:\n \n          select_init\n \n          {\n \n            LEX *lex= Lex;\n \n            lex-\u0026gt;sql_command= SQLCOM_SELECT;\n \n          }\n \n        ;\n \nselect_init:\n          SELECT_SYM /*select 关键字*/ select_init2\n \n        | \u0026#39;(\u0026#39; select_paren \u0026#39;)\u0026#39; union_opt\n \n        ;\n \nselect_init2:\n          select_part2\n          {\n            LEX *lex= Lex;\n            SELECT_LEX * sel= lex-\u0026gt;current_select;\n            if (lex-\u0026gt;current_select-\u0026gt;set_braces(0))\n            {\n              my_parse_error(ER(ER_SYNTAX_ERROR));\n              MYSQL_YYABORT;\n            }\n            if (sel-\u0026gt;linkage == UNION_TYPE \u0026amp;\u0026amp;\n                sel-\u0026gt;master_unit()-\u0026gt;first_select()-\u0026gt;braces)\n            {\n              my_parse_error(ER(ER_SYNTAX_ERROR));\n              MYSQL_YYABORT;\n            }\n          }\n          union_clause\n        ;\nselect_part2:\n          {\n            LEX *lex= Lex;\n            SELECT_LEX *sel= lex-\u0026gt;current_select;\n            if (sel-\u0026gt;linkage != UNION_TYPE)\n              mysql_init_select(lex);\n            lex-\u0026gt;current_select-\u0026gt;parsing_place= SELECT_LIST;\n          }\n  \n          select_options select_item_list /*解析列名*/\n          {\n            Select-\u0026gt;parsing_place= NO_MATTER;\n          }\n          select_into select_lock_type\n        ;\n \nselect_into:\n          opt_order_clause opt_limit_clause {}\n        | into\n        | select_from /*from 字句*/\n        | into select_from\n        | select_from into\n        ;\nselect_from:\n          FROM join_table_list /*解析表名*/ where_clause /*where字句*/ group_clause having_clause\n          opt_order_clause opt_limit_clause procedure_analyse_clause\n          {\n            Select-\u0026gt;context.table_list=\n              Select-\u0026gt;context.first_name_resolution_table=\n                Select-\u0026gt;table_list.first;\n          }\n        | FROM DUAL_SYM where_clause opt_limit_clause\n          /* oracle compatibility: oracle always requires FROM clause,\n             and DUAL is system table without fields.\n             Is \u0026#34;SELECT 1 FROM DUAL\u0026#34; any better than \u0026#34;SELECT 1\u0026#34; ?\n          Hmmm :) */\n        ;\n \nwhere_clause:\n          /* empty */  { Select-\u0026gt;where= 0; }\n        | WHERE\n          {\n            Select-\u0026gt;parsing_place= IN_WHERE;\n          }\n          expr /*各种表达式*/\n          {\n            SELECT_LEX *select= Select;\n            select-\u0026gt;where= $3;\n            select-\u0026gt;parsing_place= NO_MATTER;\n            if ($3)\n              $3-\u0026gt;top_level_item();\n          }\n        ;\n  \n/* all possible expressions */\nexpr:\n           | expr and expr %prec AND_SYM\n          {\n            /* See comments in rule expr: expr or expr */\n            Item_cond_and *item1;\n            Item_cond_and *item3;\n            if (is_cond_and($1))\n            {\n              item1= (Item_cond_and*) $1;\n              if (is_cond_and($3))\n              {\n                item3= (Item_cond_and*) $3;\n                /*\n                  (X1 AND X2) AND (Y1 AND Y2) ==\u0026gt; AND (X1, X2, Y1, Y2)\n                */\n                item3-\u0026gt;add_at_head(item1-\u0026gt;argument_list());\n                $$ = $3;\n              }\n              else\n              {\n                /*\n                  (X1 AND X2) AND Y ==\u0026gt; AND (X1, X2, Y)\n                */\n                item1-\u0026gt;add($3);\n                $$ = $1;\n              }\n            }\n            else if (is_cond_and($3))\n            {\n              item3= (Item_cond_and*) $3;\n              /*\n                X AND (Y1 AND Y2) ==\u0026gt; AND (X, Y1, Y2)\n              */\n              item3-\u0026gt;add_at_head($1);\n              $$ = $3;\n            }\n            else\n            {\n              /* X AND Y */\n              $$ = new (YYTHD-\u0026gt;mem_root) Item_cond_and($1, $3);\n              if ($$ == NULL)\n                MYSQL_YYABORT;\n            }\n          }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在大家浏览上述代码的过程，会发现Bison中嵌入了C++的代码。通过C++代码，把解析到的信息存储到相关对象中。例如表信息会存储到TABLE_LIST中，order_list存储order by子句里的信息，where字句存储在Item中。有了这些信息，再辅助以相应的算法就可以对SQL进行更进一步的处理了。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e核心数据结构及其关系\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e在SQL解析中，最核心的结构是SELECT_LEX，其定义在sql/sql_lex.h中。下面仅列出与上述例子相关的部分。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/8eafb088.png\" alt=\"图3 SQL解析树结构\"/\u003e\u003c/p\u003e\u003cp\u003e上面图示中，列名username、ismale存储在item_list中，表名存储在table_list中，条件存储在where中。其中以where条件中的Item层次结构最深，表达也较为复杂，如下图所示。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0adcdb23.png\" alt=\"图4 where条件\"/\u003e\u003c/p\u003e\u003ch2 id=\"sql解析的应用\"\u003eSQL解析的应用\u003c/h2\u003e\u003cp\u003e为了更深入的了解SQL解析器，这里给出2个应用SQL解析的例子。\u003c/p\u003e\u003ch3 id=\"无用条件去除\"\u003e无用条件去除\u003c/h3\u003e\u003cp\u003e无用条件去除属于优化器的逻辑优化范畴，可以仅仅根据SQL本身以及表结构即可完成，其优化的情况也是较多的，代码在sql/sql_optimizer.cc文件中的remove_eq_conds函数。为了避免过于繁琐的描述，以及大段代码的粘贴，这里通过图来分析以下四种情况。\u003c/p\u003e\u003cul\u003e\u003cli\u003ea）1=1 and (m \u0026gt; 3 and n \u0026gt; 4)\u003c/li\u003e\u003cli\u003eb）1=2 and (m \u0026gt; 3 and n \u0026gt; 4)\u003c/li\u003e\u003cli\u003ec）1=1 or (m \u0026gt; 3 and n \u0026gt; 4)\u003c/li\u003e\u003cli\u003ed）1=2 or (m \u0026gt; 3 and n \u0026gt; 4)\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7179d512.png\" alt=\"图5 无用条件去除a\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/288c2ec6.png\" alt=\"图6 无用条件去除b\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/9685c5d1.png\" alt=\"图7 无用条件去除c\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0f5d515d.png\" alt=\"图8 无用条件去除d\"/\u003e\u003c/p\u003e\u003cp\u003e如果对其代码实现有兴趣的同学，需要对MySQL中的一个重要数据结构Item类有所了解。因为其比较复杂，所以MySQL官方文档，专门介绍了\u003ca href=\"https://dev.mysql.com/doc/internals/en/item-class.html\"\u003eItem类\u003c/a\u003e。阿里的MySQL小组，也有类似的\u003ca href=\"http://www.orczhou.com/index.php/2012/11/mysql-innodb-source-code-optimization-1/\"\u003e文章\u003c/a\u003e。如需更详细的了解，就需要去查看源码中sql/item_*等文件。\u003c/p\u003e\u003ch3 id=\"sql特征生成\"\u003eSQL特征生成\u003c/h3\u003e\u003cp\u003e为了确保数据库，这一系统基础组件稳定、高效运行，业界有很多辅助系统。比如慢查询系统、中间件系统。这些系统采集、收到SQL之后，需要对SQL进行归类，以便统计信息或者应用相关策略。归类时，通常需要获取SQL特征。比如SQL:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sql\"\u003eselect username, ismale from userinfo where age \u0026gt; 20 and level \u0026gt; 5；```\nSQL特征为： \n```sql\nselect username, ismale from userinfo where age \u0026gt; ? and level \u0026gt; ? \n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e业界著名的慢查询分析工具pt-query-digest，通过正则表达式实现这个功能但是这类处理办法Bug较多。接下来就介绍如何使用SQL解析，完成SQL特征的生成。\u003c/p\u003e\u003cp\u003eSQL特征生成分两部分组成。\u003c/p\u003e\u003cul\u003e\u003cli\u003ea) 生成Token数组\u003c/li\u003e\u003cli\u003eb) 根据Token数组，生成SQL特征\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e首先回顾在词法解析章节，我们介绍了SQL中的关键字，并且每个关键字都有一个16位的整数对应，而非关键字统一用ident表示，其也对应了一个16位整数。如下表：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e标识\u003c/th\u003e\u003cth align=\"right\"\u003eselect\u003c/th\u003e\u003cth align=\"right\"\u003efrom\u003c/th\u003e\u003cth align=\"right\"\u003ewhere\u003c/th\u003e\u003cth align=\"right\"\u003e\u0026gt;\u003c/th\u003e\u003cth align=\"right\"\u003e?\u003c/th\u003e\u003cth align=\"right\"\u003eand\u003c/th\u003e\u003cth align=\"center\"\u003eident\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e整数\u003c/td\u003e\u003ctd align=\"right\"\u003e728\u003c/td\u003e\u003ctd align=\"right\"\u003e448\u003c/td\u003e\u003ctd align=\"right\"\u003e878\u003c/td\u003e\u003ctd align=\"right\"\u003e463\u003c/td\u003e\u003ctd align=\"right\"\u003e893\u003c/td\u003e\u003ctd align=\"right\"\u003e272\u003c/td\u003e\u003ctd align=\"center\"\u003e476\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e将一个SQL转换成特征的过程：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e原SQL\u003c/th\u003e\u003cth align=\"right\"\u003eselect\u003c/th\u003e\u003cth align=\"right\"\u003eusername\u003c/th\u003e\u003cth align=\"right\"\u003efrom\u003c/th\u003e\u003cth align=\"right\"\u003euserinfo\u003c/th\u003e\u003cth align=\"right\"\u003ewhere\u003c/th\u003e\u003cth align=\"right\"\u003eage\u003c/th\u003e\u003cth align=\"right\"\u003e\u0026gt;\u003c/th\u003e\u003cth align=\"center\"\u003e20\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eSQL特征\u003c/td\u003e\u003ctd align=\"right\"\u003eselect\u003c/td\u003e\u003ctd align=\"right\"\u003eident:length:value\u003c/td\u003e\u003ctd align=\"right\"\u003efrom\u003c/td\u003e\u003ctd align=\"right\"\u003eident:length:value\u003c/td\u003e\u003ctd align=\"right\"\u003ewhere\u003c/td\u003e\u003ctd align=\"right\"\u003eident:length:value\u003c/td\u003e\u003ctd align=\"right\"\u003e\u0026gt;\u003c/td\u003e\u003ctd align=\"center\"\u003e?\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e在SQL解析过程中，可以很方便的完成Token数组的生成。而一旦完成Token数组的生成，就可以很简单的完成SQL特征的生成。SQL特征被广泛用于各个系统中，比如pt-query-digest需要根据特征对SQL归类，然而其基于正则表达式的实现有诸多bug。下面列举几个已知Bug：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e原始SQL\u003c/th\u003e\u003cth align=\"right\"\u003ept-query-digest生成的特征\u003c/th\u003e\u003cth align=\"center\"\u003eSQL解析器生成的特征\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eselect * from email_template2 where id = 1\u003c/td\u003e\u003ctd align=\"right\"\u003eselect * from mail_template？ where id = ？\u003c/td\u003e\u003ctd align=\"center\"\u003eselect * from email_template2 where id = ？\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eREPLACE INTO a VALUES(‘INSERT INTO foo VALUES (1),(2)’)\u003c/td\u003e\u003ctd align=\"right\"\u003ereplace into a values(\\‘insert into foo values(?+)\u003c/td\u003e\u003ctd align=\"center\"\u003ereplace into a values （?）\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e因此可以看出SQL解析的优势是很明显的。\u003c/p\u003e\u003ch2 id=\"学习建议\"\u003e学习建议\u003c/h2\u003e\u003cp\u003e最近，在对SQL解析器和优化器探索的过程中，从一开始的茫然无措到有章可循，也总结了一些心得体会，在这里跟大家分享一下。\u003c/p\u003e\u003cul\u003e\u003cli\u003e首先，阅读相关图书书籍。图书能给我们系统认识解析器和优化器的角度。但是针对MySQL的此类图书市面上很少，目前中文作品可以看一看《数据库查询优化器的艺术：原理解析与SQL性能优化》。\u003c/li\u003e\u003cli\u003e其次，要阅读源码，但是最好以某个版本为基础，比如MySQL5.6.23，因为SQL解析、优化部分的代码在不断变化。尤其是在跨越大的版本时，改动力度大。\u003c/li\u003e\u003cli\u003e再次，多使用GDB调试，验证自己的猜测，检验阅读质量。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e最后，需要写相关代码验证，只有写出来了才能算真正的掌握。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e广友，美团到店综合事业群MySQL DBA专家，2012年毕业于中国科学技术大学，2017年加入美团，长期致力于MySQL及周边工具的研究。\u003c/li\u003e\u003cli\u003e金龙，2014年加入美团，主要从事相关的数据库运维、高可用和相关的运维平台建设。对运维高可用与架构相关感兴趣的同学可以关注个人微信公众号“自己的设计师”，定期推送运维相关原创内容。\u003c/li\u003e\u003cli\u003e邢帆，美团到店综合事业群MySQL DBA，2017年研究生毕业后加入美团，目前已经对MySQL运维有一定经验，并编写了一些自动化脚本。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团DBA团队招聘各类DBA人才，base北京上海均可。我们致力于为公司提供稳定、可靠、高效的在线存储服务，打造业界领先的数据库团队。这里有基于Redis Cluster构建的大规模分布式缓存系统Squirrel，也有基于Tair进行大刀阔斧改进的分布式KV存储系统Cellar，还有数千各类架构的MySQL实例，每天提供万亿级的OLTP访问请求。真正的海量、分布式、高并发环境。欢迎各位朋友推荐或自荐至jinlong.cai#dianping.com。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-05-20T00:00:00Z",
  "Author": "soulteary@gmail.com"
}