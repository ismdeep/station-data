{
  "Source": "tech.meituan.com",
  "Title": "外卖排序系统特征生产框架",
  "Link": "https://tech.meituan.com/2016/12/09/feature-pipeline.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/1340d0aa.png\" alt=\"图1 外卖排序系统框架\"/\u003e\u003c/p\u003e\u003cp\u003e外卖的排序策略是由机器学习模型驱动的，模型迭代效率制约着策略优化效果。如上图所示，在排序系统里，特征是最为基础的部分：有了特征之后，我们离线训练出模型，然后将特征和模型一起推送给线上排序服务使用。特征生产Pipeline对于策略迭代的效率起着至关重要的作用。经过实践中的积累和提炼，我们整理出一套通用的特征生产框架，大大节省开发量，提高策略迭代效率。\u003c/p\u003e\u003cp\u003e外卖排序系统使用GBDT（Gradient Boosting Decision Tree）树模型，比较复杂。受限于计算能力，除了上下文特征（如时间、地域、终端类型、距离等）之外，目前使用的主要是一些宽泛的统计特征，比如商家销量、商家单均价、用户的品类偏好等。这些特征的生产流程包括：离线的统计、离线到在线的同步、在线的加载等。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/d5824c88.png\" alt=\"图2 特征生产流程\"/\u003e\u003c/p\u003e\u003cp\u003e如上图，目前外卖排序的特征生产流程主要有：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003e特征统计\u003c/strong\u003e：基于基础数据表（如曝光表、点击表、订单表等），统计若干时段内特定维度的总量、分布等，如商家月均销量、用户不同品类下单占比。统计结果存储于Hive表。这部分工作，简单的可基于ETL，复杂的可基于Spark。产出的特征可供离线训练和线上预测，\u003cstrong\u003e本文主要围绕线上展开\u003c/strong\u003e。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e特征推送\u003c/strong\u003e：Hive表里的数据需要存入KV，以便线上实时使用。这一步，首先要将Hive表里的记录映射成POJO类（称为\u003cstrong\u003eDomain\u003c/strong\u003e类），然后将其序列化，最后将序列化串存入KV。这部分工作比较单一，基于MapReduce实现。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e特征获取\u003c/strong\u003e：在线服务根据需求，从KV中取出数据，并反序列化为Domain对象。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e特征加载\u003c/strong\u003e：针对模型所需特征列表，取得对应的Domain对象。这步通过调用特征获取实现。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e前两步为离线操作，后两步为在线操作。特征同步由离线推送和在线获取共同完成。离线生产流程是一个周期性的Pipeline，目前是以天为周期。\u003c/p\u003e\u003cp\u003e为此，我们设计了一套通用的框架，基于此框架，只需要简单的配置和少量代码开发，就可以新增一组特征。下文将详细介绍框架的各个部分。\u003c/p\u003e\u003ch2 id=\"特征统计\"\u003e特征统计\u003c/h2\u003e\u003cp\u003e排序模型用到的特征大部分是统计特征。有些特征比较简单，如商家的月均销量、商家单均价等，可用ETL统计(GROUP BY + SUM/AVG)；有些特征稍微复杂，如用户的品类偏好（在不同品类上的占比）、用户的下单额分布（不同金额区段的占比），用ETL就比较繁琐。针对后一种情况，我们开发了一套Spark程序来统计。我们发现，这种统计需求可以规约成一种范式：针对某些\u003cstrong\u003e统计对象\u003c/strong\u003e（用户、商家）的一些\u003cstrong\u003e维度\u003c/strong\u003e（品类、下单额），基于某些\u003cstrong\u003e度量值\u003c/strong\u003e（点击、下单）做\u003cstrong\u003e统计\u003c/strong\u003e（比例/总和）。\u003c/p\u003e\u003cp\u003e同一对象，可统计不同维度；同一维度，有不同的度量角度；同一度量角度，有不同的统计方式。如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/4cf5820e.png\" alt=\"图3 特征统计范式\"/\u003e\u003c/p\u003e\u003cp\u003e例如，对于用户点击品类偏好、用户下单品类偏好、用户下单额分布、用户下单总额等特征，可做范式分解：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e467990b.png\" alt=\"图4 特征统计范式示例\"/\u003e\u003c/p\u003e\u003cp\u003e其中，\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e统计对象、统计维度、度量值\u003c/strong\u003e对应于Hive表中的字段（维度一般来自维度表，度量值一般来自事实表，主要是曝光、点击、下单）。为了增加灵活性，我们还允许对原始Hive字段做加工，加工后的值作为统计维度、度量值（加工的接口我们分别称为维度算子和度量算子）。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e统计量\u003c/strong\u003e基于度量值做的一些聚合操作，如累加、求均值、拼接、求占比、算分位点（分布）。前两者输出一个数值，后三者输出形如”Key1:Value1,Key2:Value2”的KeyValue列表。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e另外，统计通常是在一定时间窗口内进行的，由于不同时期的数据价值不同（新数据比老数据更有价值），我们引入了\u003cstrong\u003e时间衰减\u003c/strong\u003e，对老数据降权。\u003c/p\u003e\u003cp\u003e基于以上考虑，整个统计流程可以分解为（基于Spark）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/75fab2d5.png\" alt=\"图5 特征统计流程\"/\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e按统计对象字段做聚合（GROUP BY）。统计对象字段由配置给定。对于外卖排序主要为uuid、poi_id。这一步可能会有数据倾斜，需要更多优化。\u003c/li\u003e\u003cli\u003e计算维度。支持维度算子，可以对原始维度字段做处理，如对金额字段做分段处理，以分段后的金额作为维度。\u003c/li\u003e\u003cli\u003e按统计维度聚合（GROUP BY）。这是在对象聚合的基础上做的二次聚合。维度字段由配置给定，可以有多个字段，表示交叉特征统计，如不同时段的品类偏好，维度字段为：时段、品类。\u003c/li\u003e\u003cli\u003e时间衰减并累加。衰减各个时间的度量值，并把所有时间的度量值累加，作为加权后的度量值。时间字段和度量字段由配置给定。时间字段主要为日期，度量字段主要为曝光、点击、下单。经过维度聚合后，度量值都在特定维度值对应的记录集上做累加，每个维度对应一个度量值，维度和度量值是一个KeyValue的映射关系。\u003c/li\u003e\u003cli\u003e计算度量值。度量字段也可以通过度量算子做进一步处理，算子得到的结果作为度量值。也可以有多个字段，如点击和曝光字段，配合除法算子，可以得到点击率作为度量值。\u003c/li\u003e\u003cli\u003e计算统计量。经过对象和维度聚合后，对象、维度、度量值建立了二级映射关系：对象维度度量值，相当于一个二维Map：Map\u0026lt;对象, Map\u0026lt;维度, 度量值\u0026gt;\u0026gt;。统计量是对Map\u0026lt;维度, 度量值\u0026gt;做一个聚合操作。每个统计量对应输出Hive表中的一个字段。现在主要支持如下几种算子：\u003cul\u003e\u003cli\u003e累加：对该维度的所有度量值求和；\u003c/li\u003e\u003cli\u003e求均值：该维度所有取值情况对应的度量值的均值；\u003c/li\u003e\u003cli\u003e拼接：把Map\u0026lt;维度, 度量值\u0026gt;序列化为”Key1:Value1, Key2:Value2”形式，以便以字符串的形式存储于一个输出字段内。为了防止序列化串太长，可通过配置设定只保留度量值最大的top N；\u003c/li\u003e\u003cli\u003e求占比：该维度所有取值情况对应的度量值占度量值总和的比重，即Map\u0026lt;维度, 度量值/Sum(度量值)\u0026gt;。然后再做拼接输出；\u003c/li\u003e\u003cli\u003e算分位点：有时候想直到某些维度的分布情况，比如用户下单金额的分布以考察用户的消费能力。分位点可以作为分布的一种简单而有效的表示方法。该算子输出每个分位点的维度值，形如”分位点1:维度值1, 分位点2:维度值2”。此时，度量值只是用来算比值。\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cstrong\u003e维度算子\u003c/strong\u003e、\u003cstrong\u003e度量算子\u003c/strong\u003e、\u003cstrong\u003e统计算子\u003c/strong\u003e都可以通过扩展接口的方式实现自定义。\u003c/p\u003e\u003cp\u003e如下是统计用户点击品类偏好、用户下单品类偏好、用户下单额分布的配置文件和Hive表示例([Toml]\u003csup\u003e[1]\u003c/sup\u003e格式)\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/1c17e1ec.png\" alt=\"图6 特征统计配置示例\"/\u003e\u003c/p\u003e\u003cp\u003e相对于ETL，这套Spark统计框架更为简单清晰，还可以同时统计多个相关的特征。通过简单的配置就可以实现特征的统计，开发量比较小。\u003c/p\u003e\u003ch2 id=\"特征同步\"\u003e特征同步\u003c/h2\u003e\u003cp\u003e离线统计得到的特征存储在Hive表中，出于性能的考虑，不能在线上直接访问。我们需要把特征从Hive中推送到更为高效的KV数据库中，线上服务再从KV中获取。整个同步过程可以分为如下步骤：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8be719f6.png\" alt=\"图7 特征推送流程\"/\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003eORM：将Hive表中的每行记录映射为Domain对象（类似于[Hibernate]\u003csup\u003e[2]\u003c/sup\u003e的功能）\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e序列化\u003c/strong\u003e：将Domain对象序列化，然后存储到KV中。一个Domain类包含一组相关的、可同时在一个任务中统计的特征数据。每个Domain对象都有一个key值来作为自己唯一的标志—实现key()接口。同时，由于不同类型的Domain都会存储在一起，我们还需要为每种类型的Domain设定一个Key值前缀prefix以示区别。因此，KV中的Key是Domain.prefix + Domain.key，Value是序列化串。我们支持json和protostuff两种序列化方式。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e反序列化\u003c/strong\u003e：在线服务根据key和Domain.prefix从KV中得到序列化串，并反序列化为Domain对象。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e前两步为离线操作，第三步为在线操作（在预测代码中被调用）。\u003c/p\u003e\u003cp\u003e我们针对Hive开发了一套ORM库（见图8），主要基于Java反射，除了支持基本类型(int/long/float/double/String等)，还支持POJO类型和集合类型(List/Map)。因为ETL不支持json拼接，为了兼容基于ETL统计的特征数据，我们的POJO以及集合类型是基于自定义的规范做编解码。针对Spark统计的特征数据，后续我们可以支持json格式的编解码。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/e2e2c338.png\" alt=\"图8 Hive ORM示意\"/\u003e\u003c/p\u003e\u003cp\u003e特征序列化和反序列我们统一封装为通用的\u003cstrong\u003eKvService\u003c/strong\u003e：负责序列化与反序列，以及读写KV。如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/386de561.png\" alt=\"图9 KvService\"/\u003e\u003c/p\u003e\u003cp\u003e对于新特征，只需要定义一个Domain类，并实现接口key()即可，KvService自动完成Key值的拼接（以Domain的类名作为Key的prefix），序列化和反序列化，读写KV。\u003c/p\u003e\u003cp\u003e我们通过周期性的离线MapReduce任务，读取Hive表的记录，并调用KvService的put接口，将特征数据推送到KV中。由于KvService能够统一处理各种Domain类型，MapReduce任务也是通用的，无需为每个特征单独开发。\u003c/p\u003e\u003cp\u003e对于特征同步，只需要开发Domain类，并做少量配置，开发量也很小。目前，我们为了代码的可读性，采用Domain这种强类型的方式来定义特征，如果可以弱化这种需求的话，还可以做更多的框架优化，省去Domain类开发这部分工作。\u003c/p\u003e\u003ch2 id=\"特征加载\"\u003e特征加载\u003c/h2\u003e\u003cp\u003e通过前面几步，我们已经准备好特征数据，并存储于KV中。线上有诸多模型在运行，不同模型需要不同的特征数据。特征加载这一步主要解决怎么高效便捷地为模型提供相应的特征数据。\u003c/p\u003e\u003cp\u003e离线得到的只是一些原始特征，在线还可能需要基于原始特征做更多的处理，得到高阶特征。比如离线得到了商家和用户的下单金额分布，在线我们可能需要基于这两个分布计算一个匹配度，以表征该商家是否在用户消费能力的承受范围之内。\u003c/p\u003e\u003cp\u003e我们把在线特征抽象为一个特征算子：\u003cstrong\u003eFeatureOperator\u003c/strong\u003e。类似的，一个特征算子包含了一组相关的在线特征，且可能依赖一组相关的离线特征。它除了封装了在线特征的计算过程，还通过两个Java Annotation声明该特征算子产出的特征清单(@\u003cstrong\u003eFeatures\u003c/strong\u003e)和所需要的数据清单(@\u003cstrong\u003eFetchers\u003c/strong\u003e)。所有的数据获取都是由\u003cstrong\u003eDataFetcher\u003c/strong\u003e调用\u003cstrong\u003eKvService\u003c/strong\u003e的get接口实现，拿到的\u003cstrong\u003eDomain\u003c/strong\u003e对象统一存储在\u003cstrong\u003eDataPortal\u003c/strong\u003e对象中以便后续使用。\u003c/p\u003e\u003cp\u003e服务启动时，会自动扫描所有的FeatureOperator的Annotation（@Features、@Fetchers），拿到对应的特征清单和数据清单，从而建立起映射关系：FeatureFeatureOperatorDataFetcher。而每个模型通过配置文件给定其所需要的特征清单，这样就建立起模型到特征的映射关系（如图9）：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003eModel → Feature → FeatureOperator → DataFetcher\u003c/strong\u003e\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e不同的在线特征可能会依赖相同的离线特征，也就是FeatureOperatorDataFetcher是多对多的关系。为了避免重复从KV读取相同的数据以造成性能浪费，离线特征的获取和在线特征的抽取被划分成两步：先汇总所有离线特征需求，统一获取离线特征；得到离线特征后，再进行在线特征的抽取。这样，我们也可以在离线特征加载阶段采用并发以减少网络IO延时。整个流程如图10所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/437d2b92.png\" alt=\"图10 模型和特征数据的映射关系\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/24e595ed.png\" alt=\"图11 特征加载流程\"/\u003e\u003c/p\u003e\u003cp\u003e对于新特征，我们需要实现对应的FeatureOperator、DataFetcher。DataFetcher主要封装了Domain和DataPortal的关系。类似的，如果我们不需要以强类型的方式来保证代码的业务可读性，也可以通过优化框架省去DataFetcher和DataPortal的定制开发。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e我们在合理抽象特征生产过程的各个环节后，设计了一套较为通用的框架，只需要少量的代码开发（主要是自定义一些算子）以及一些配置，就可以很方便地生产一组特征，有效地提高了策略迭代效率。\u003c/p\u003e\u003ch2 id=\"参考文献\"\u003e参考文献\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://github.com/toml-lang/toml\"\u003eTOML\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://hibernate.org/orm/\"\u003eHibernate ORM\u003c/a\u003e.\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-12-09T00:00:00Z",
  "Author": "soulteary@gmail.com"
}