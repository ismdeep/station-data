{
  "Source": "tech.meituan.com",
  "Title": "插件化、热补丁中绕不开的Proguard的坑",
  "Link": "https://tech.meituan.com/2018/04/27/mt-proguard.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cblockquote\u003e\u003cp\u003e文章主体部分已经发表于《程序员》杂志2018年2月期，内容略有改动。\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"proguard简介\"\u003eProGuard简介\u003c/h2\u003e\u003cp\u003e\u003ca href=\"https://www.guardsquare.com/en/proguard\"\u003eProGuard\u003c/a\u003e是2002年由比利时程序员Eric Lafortune发布的一款优秀的开源代码优化、混淆工具，适用于Java和Android应用，目标是让程序更小，运行更快，在Java界处于垄断地位。\u003c/p\u003e\u003cp\u003e主要分为三个模块：Shrinker（压缩器）、Optimizer（优化器）、Obfuscator（混淆器）、Retrace（堆栈反混淆）。\u003c/p\u003e\u003cul\u003e\u003cli\u003eShrinker 通过引用标记算法，将没用到的代码移除掉。\u003c/li\u003e\u003cli\u003eOptimizer 通过复杂的算法（Partial Evaluation \u0026amp;Peephole optimization，这部分算法我们不再展开介绍）对字节码进行优化，代码优化会使部分代码块的结构出现变动。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e举几个例子：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e某个非静态方法内部没有使用\u003ccode\u003ethis\u003c/code\u003e没有继承关系，这个方法就可以改为静态方法。\u003c/li\u003e\u003cli\u003e某个方法（代码不是很长）只被调用一次，这个方法就可以被内联。\u003c/li\u003e\u003cli\u003e方法中的参数没有使用到，这个参数可以被移除掉。\u003c/li\u003e\u003cli\u003e局部变量重分配，比如在if外面初始化了一个变量，但是这个变量只在if内部用到，这样就可以将变量移动的if内部去。\u003c/li\u003e\u003cli\u003eObfuscator 通过一个混淆名称发生器产生a、b、c的毫无意义名称来替换原来正常的名称，增加逆向的难度。\u003c/li\u003e\u003cli\u003eRetrace 经过ProGuard处理后的字节码运行的堆栈已经跟没有处理之前的不一样了，除了出现名称上的变化还伴随着逻辑上的变化，程序崩溃后，开发者需要借助Retrace将错误堆栈恢复为没有经过ProGuard处理的样子。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e在我们实施插件化、热补丁修复时，为了让插件、补丁和原来的宿主兼容，必须依赖ProGuard的applymapping功能的进行增量混淆，但在使用ProGuard的applymapping时会遇到部分方法混淆错乱的问题，同时在ProGuard的日志里有这些警告信息\u003ccode\u003eWarning: ... is not being kept as ..., but remapped to ...\u003c/code\u003e，针对这个问题我们进行了深入的研究，并找到了解决的方案，本文会对这个问题产生的缘由以及修复方案一一介绍。\u003c/p\u003e\u003ch2 id=\"现象\"\u003e现象\u003c/h2\u003e\u003cp\u003e下面是在使用\u003ccode\u003e-applymapping\u003c/code\u003e之后ProGuard输出的警告信息，同时我们发现在使用\u003ccode\u003e-applymapping\u003c/code\u003e得到的混淆结果中这些方法的名称都和原来宿主混淆结果的名称不一致的现象，导致使用\u003ccode\u003e-applymapping\u003c/code\u003e后的结果和宿主不兼容。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003ePrinting mapping to [.../mapping.txt]...\n...\nWarning: com.bumptech.glide.load.resource.gif.GifFrameLoader: method \u0026#39;void stop()\u0026#39; is not being kept as \u0026#39;b\u0026#39;, but remapped to \u0026#39;c\u0026#39;\nWarning: there were 6 kept classes and class members that were remapped anyway.\n         You should adapt your configuration or edit the mapping file.\n         (http://proguard.sourceforge.net/manual/troubleshooting.html#mappingconflict1)\n...\nWarning: com.bumptech.glide.load.resource.gif.GifFrameLoader: method \u0026#39;void stop()\u0026#39; can\u0026#39;t be mapped to \u0026#39;c\u0026#39; because it would conflict with method \u0026#39;clear\u0026#39;, which is already being mapped to \u0026#39;c\u0026#39;\nWarning: there were 2 conflicting class member name mappings.\n\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"applymaping前后的映射关系变化\"\u003eapplymaping前后的映射关系变化\u003c/h3\u003e\u003cpre\u003e\u003ccode class=\"language-diff\"\u003e@@ -1491,7 +1491,7 @@ BitmapRequestBuilder -\u0026gt; com..glide.a:\n-    264:265:BitmapRequestBuilder transform(cBitmapTransformation[]) -\u0026gt; a\n+    264:265:BitmapRequestBuilder transform(BitmapTransformation[]) -\u0026gt; b\n\n@@ -3532,7 +3532,7 @@ GifFrameLoader -\u0026gt; com.bumptech.glide.load.r\n-    77:78:void stop() -\u0026gt; b\n+    77:78:void stop() -\u0026gt; c_\n\n\u003c/code\u003e\u003c/pre\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e初次混淆\u003c/th\u003e\u003cth\u003e增量混淆\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003etransform-\u0026gt;a\u003c/td\u003e\u003ctd\u003etransform-\u0026gt;b\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003estop-\u0026gt;b\u003c/td\u003e\u003ctd\u003estop-\u0026gt;c_\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003estop方法作为一个公用方法存在的宿主中，而子模块依赖于宿主中的stop方法。子模块升级之后依然依赖宿主的接口、公共方法，这要确保stop方法在子模块升级前后是一致的。当使用\u003ccode\u003e-applymapping\u003c/code\u003e进行增量编译时stop由b映射为c_。升子模块依赖的stop方法不兼容，造成子模块无法升级。\u003c/p\u003e\u003ch3 id=\"了解一下mapping\"\u003e了解一下mapping\u003c/h3\u003e\u003cp\u003emapping.txt是代码混淆阶段输出产物。\u003c/p\u003e\u003ch4 id=\"mapping的用途\"\u003emapping的用途\u003c/h4\u003e\u003col\u003e\u003cli\u003eretrace使用mapping文件和stacktrace进行ProGuard前的堆栈还原。\u003c/li\u003e\u003cli\u003e使用\u003ccode\u003e-applymapping\u003c/code\u003e配合mapping文件进行增量混淆。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"mapping的组成\"\u003emapping的组成\u003c/h4\u003e\u003cp\u003e以\u003ccode\u003e-\u0026gt;\u003c/code\u003e为分界线，表示\u003ccode\u003e原始名称-\u0026gt;新名称\u003c/code\u003e。\u003c/p\u003e\u003col\u003e\u003cli\u003e类映射,特征：映射以\u003ccode\u003e:\u003c/code\u003e结束。\u003c/li\u003e\u003cli\u003e字段映射，特征：映射中没有\u003ccode\u003e()\u003c/code\u003e。\u003c/li\u003e\u003cli\u003e方法映射，特征：映射中有\u003ccode\u003e()\u003c/code\u003e，并且左侧的拥有两个数字，代表方法体的行号范围。\u003c/li\u003e\u003cli\u003e内联，特征：与方法映射相比，多了两个行号范围，右侧的行号表示原始代码行，左侧表示新的行号。\u003c/li\u003e\u003cli\u003e闭包，特征：只有三个行号，它与内联成对出现。\u003c/li\u003e\u003cli\u003e注释，特征：以\u003ccode\u003e#\u003c/code\u003e开头，通常不会出现在mapping中。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"一段与-applymapping-出错有关的mapping\"\u003e一段与\u003ccode\u003e-applymapping\u003c/code\u003e出错有关的mapping\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003eGifFrameLoader -\u0026gt; g:\n    com.bumptech.glide.load.resource.gif.GifFrameLoader$FrameCallback callback -\u0026gt; a\n    60:64:void setFrameTransformation(com.bumptech.glide.load.Transformation) -\u0026gt; a\n    67:74:void start() -\u0026gt; a\n    77:78:void stop() -\u0026gt; b\n    81:88:void clear() -\u0026gt; c\n    2077:2078:void stop():77:78 -\u0026gt; c\n    2077:2078:void clear():81 -\u0026gt; c\n    91:91:android.graphics.Bitmap getCurrentFrame() -\u0026gt; d\n    95:106:void loadNextFrame() -\u0026gt; e\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eGifFrameLoader映射为g。在代码里面，每个类、类成员只有一个新的映射名称，其中stop出现了两次不同的映射。为什么会出现两次不同的映射？这两次不同的映射对增量混淆有影响吗？\u003c/p\u003e\u003cp\u003e\u003ca href=\"https://www.guardsquare.com/en/proguard/manual/troubleshooting#mappingconflict1\"\u003eProGuard文档对于这个问题没有给出具体的原因和可靠的解决方案\u003c/a\u003e，在\u003ccode\u003e-applymapping\u003c/code\u003e一节提到如果代码发生结构性变化可能会输出上面的警告，建议使用\u003ccode\u003e-useuniqueclassmembernames\u003c/code\u003e参数来降低冲突的风险，这个参数并不能解决这个问题。\u003c/p\u003e\u003cp\u003e为了解决这个问题，我们决定探究一下ProGuard源码来看下为什么会出现这个问题，如何修复这个问题？\u003c/p\u003e\u003ch2 id=\"从源码中寻找答案\"\u003e从源码中寻找答案\u003c/h2\u003e\u003cp\u003e先看一下ProGuard怎么表示一个方法：\n\u003cimg src=\"https://p0.meituan.net/travelcube/7aed1df29555d1a4aeeaf390e6675b0621996.png\" alt=\"Class Detail\"/\u003e\u003c/p\u003e\u003cp\u003eProGuard对Class输入分为两类，一类是ProgramClass，另一类是LibraryClass。前者包含我们编写代码、第三方的SDK，而后者通常是系统库，不需要编译到程序中，比如引用的android.jar、rt.jar。\u003c/p\u003e\u003cp\u003eProgramMember是一个抽象类，拥有ProgramField和ProgramMethod两个子类，分别表示字段和方法，抽象类内部拥有一个Object visitorInfo的成员，这个字段存放的是混淆后的名称。\u003c/p\u003e\u003ch2 id=\"代码混淆\"\u003e代码混淆\u003c/h2\u003e\u003cp\u003e代码混淆可以认为是一个为类、方法、字段重命名的过程，可以使用\u003ccode\u003e-applymapping\u003c/code\u003e参数进行增量混淆。使用\u003ccode\u003e-applymapping\u003c/code\u003e参数时的过程可简略的分为mapping复用、名称混淆、混淆后名称冲突处理三部分。\u003c/p\u003e\u003cp\u003e流程简化后如下图（左右两个大虚线框代表了对单个类的两次处理，分别是名称混淆和冲突处理）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/dd84e555794a7a173cb0c90412433ec929559.png\" alt=\"混淆简略流程\"/\u003e\u003c/p\u003e\u003cp\u003e只有使用\u003ccode\u003e-applymapping\u003c/code\u003e参数时MappingKeeper才会执行，否则跳过该步骤。\u003c/p\u003e\u003ch3 id=\"1-mappingkeeper\"\u003e1. MappingKeeper\u003c/h3\u003e\u003cp\u003e它的作用就是复用上次的mapping映射，让ProgramMember的visitorInfo恢复到上次混淆的状态。\u003c/p\u003e\u003cul\u003e\u003cli\u003e如果是新加方法，visitorInfo为null。\u003c/li\u003e\u003cli\u003e如果一个方法存在多份映射，新出现的映射会覆盖旧的映射并输出警告\u003ccode\u003eWarning: ... is not being kept as ..., but remapped to\u003c/code\u003e。\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003epublic void processMethodMapping(String className,\n                                 int    firstLineNumber,\n                                 int    lastLineNumber,\n                                ...\n                                 int    newFirstLineNumber,\n                                 int    newLastLineNumber,\n                                 String newMethodName)\n{\n    if (clazz != null \u0026amp;\u0026amp; className.equals(newClassName))\n    {\n        String descriptor = ClassUtil.internalMethodDescriptor(methodReturnType,ListUtil.commaSeparatedList(methodArguments));\n        Method method = clazz.findMethod(methodName, descriptor);\n        if (method != null)\n        {\n            // Print out a warning if the mapping conflicts with a name that\n            // was set before.\n            // Make sure the mapping name will be kept.\n            MemberObfuscator.setFixedNewMemberName(method, newMethodName);\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"2-混淆处理\"\u003e2. 混淆处理\u003c/h3\u003e\u003cp\u003e混淆以类为单位，可以分为两部分，第一部分是收集映射关系，第二部分是名称混淆。判断是否存在映射关系，如果不存在的话分配一个新名称。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e第一部分：映射名称收集\u003c/strong\u003e\u003c/p\u003e\u003cp\u003eMemberNameCollector收集ProgramMember的visitorInfo，并把相同描述符的方法或字段放入同一个map\u003ccode\u003e\u0026lt;混淆后名称,原始名称\u0026gt;\u003c/code\u003e。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003e        String newName = MemberObfuscator.newMemberName(member);//获取visitorInfo\n        if (newName != null)\n        {\n            String descriptor = member.getDescriptor(clazz);\n            Map nameMap = MemberObfuscator.retrieveNameMap(descriptorMap, descriptor);\n            String otherName = (String)nameMap.get(newName);\n            if (otherName == null                              ||\n                MemberObfuscator.hasFixedNewMemberName(member) ||\n                name.compareTo(otherName) \u0026lt; 0)\n            {\n                nameMap.put(newName, name);\n            }\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果visitorInfo出现相同名称，map中的键值对会被后出现的方法（以在Class中的顺序为准）覆盖，可能会导致错误映射覆盖正确映射。\u003c/p\u003e\u003cp\u003e第二部分：名称混淆\u003c/p\u003e\u003cp\u003e如果visitorInfo为null的话为member分配新名称，第一部分收集的map来确保NameFactory产生的新名称不会跟现有的冲突，\u003ccode\u003enextName()\u003c/code\u003e这个里面有个计数器，每次产生新名称都自加，这就是出现a、b、c的原因。这一步只会保证map里面出现映射与新产生的映射不会出现冲突。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003e        Map nameMap = retrieveNameMap(descriptorMap, descriptor);\n        String newName = newMemberName(member);\n        if (newName == null)\n        {  nameFactory.reset();\n            do{newName = nameFactory.nextName();}\n            while (nameMap.containsKey(newName));\n            nameMap.put(newName, name);\n            setNewMemberName(member, newName);\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"3-混淆名称冲突的处理\"\u003e3. 混淆名称冲突的处理\u003c/h3\u003e\u003cp\u003e混淆冲突处理的第一步同混淆的第一步，先收集ProgramMember的visitorInfo，此时map跟\u003cstrong\u003e混淆处理过程\u003c/strong\u003e的状态一样。\u003c/p\u003e\u003cp\u003e冲突的判断代码：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003e        Map nameMap = MemberObfuscator.retrieveNameMap(descriptorMap, descriptor);\n        String newName = MemberObfuscator.newMemberName(member);\n        String previousName = (String)nameMap.get(newName);\n        if (previousName != null \u0026amp;\u0026amp;!name.equals(previousName))\n        {   MemberObfuscator.setNewMemberName(member, null);\n            member.accept(clazz, memberObfuscator);\n        }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e取出当前ProgramMethod中的visitorInfo，用这个visitorInfo作为key到map里面取value，如果value跟当前的ProgramMethod不相同话，说明value覆盖了ProgramMethod映射，认为当前ProgramMethod映射与map中的映射冲突，当前的映射关系失效，把visitorInfo设为null，然后再次调用MemberObfuscator为ProgramMethod产生一个新名称，NameFactory会为新名称加入一个\u003ccode\u003e_\u003c/code\u003e作为后缀，这样会出现某一些方法混淆出现下划线。\u003c/p\u003e\u003ch3 id=\"4-最终的代码输出\"\u003e4. 最终的代码输出\u003c/h3\u003e\u003cp\u003e代码优化之后不再对字节码进行修改，上面的主要是为类、类成员的名称进行映射关系分配以及映射冲突的处理，\u003c/p\u003e\u003cp\u003e当冲突解决完之后才会输出mapping.txt、修改字节码、引用修复、生成output.jar。\u003c/p\u003e\u003ch3 id=\"5-关于mapping的生成\"\u003e5. 关于mapping的生成\u003c/h3\u003e\u003cp\u003e在mapping生成过程中，除了生成类、方法、字段的映射关系，还记录了方法的内联的信息。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-Java\"\u003e    2077:2078:void stop():77:78 -\u0026gt; c\n    2077:2078:void clear():81 -\u0026gt; c\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e第一行表示：从右边的代码范围偏移到左侧的范围（方法c中的2077-2087行来自stop方法的），第二行表示偏移来的代码最终的位置（81行的方法调用修改为2077-2078行代码）。这两行并不是普通的映射。\u003c/p\u003e\u003ch2 id=\"代码优化\"\u003e代码优化\u003c/h2\u003e\u003cp\u003e刚才我们讲了，mapping里面有一段内联信息，现在看为什么mapping里面出现一段看起来跟混淆无关的内联。\u003c/p\u003e\u003cp\u003e上文讲到，mapping里面存在一段内联信息，之所以mapping里面出现一段看起来跟混淆无关的内联，这是因为javac在代码编译过程中并没有做太多的代码优化，只做了一些很简单的优化，比如字符串链接str1+str2+str3会优化为StringBuilder，减少了对象分配。\u003c/p\u003e\u003cp\u003e当引入的大量代码、库以及某些废弃的代码依然停留在仓库时，这些冗余的代码占用大量的磁盘、网络、内存。ProGuard代码优化可以解决这些问题，移除没有使用到的代码、优化指令、逻辑，以及方法内部的局部变量分配和内联，让程序运行的更快、占用磁盘、内存更低。\u003c/p\u003e\u003cp\u003e内联：在编译期间的调用内联的方法进行展开，减少方法调次数，消耗更少的CPU。但是Java中没有\u003ccode\u003einline\u003c/code\u003e这个关键字，ProGuard又是怎么对方法做的内联呢？\u003c/p\u003e\u003ch3 id=\"内联\"\u003e内联\u003c/h3\u003e\u003cp\u003e在代码优化过程中，对某一些方法进行内联（将被内联的方法体内容Copy到调用方调用被内联方法处，是一个代码展开的过程），修改了调用方的代码结构，所以被内联的方法Copy到调用方时需要考虑带来的副作用。当Copy来的代码发生崩溃时，Java stacktrace无法体现真实的崩溃堆栈和方法调用关系，它受调用方自身代码和内联Copy的代码相互影响。\u003c/p\u003e\u003cp\u003e内联主要分为两类：unique method 和short method，前者被调用并且只被调用一次，而后者被调用多次可能，但是这个方法\u003ca href=\"https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.3\"\u003ecode_length\u003c/a\u003e小于8（并非代码行数）。满足这两种的方法才可能被内联。\u003c/p\u003e\u003cp\u003e以clear调用stop为例，如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/3800193210236bab55585d3fa4fa64636608.png\" alt=\"内联\"/\u003e\u003c/p\u003e\u003cp\u003e在clear的81行调用stop，发生内联，stop的方法内容复制到81行处，很明显不可以使用之前的77-78行，在81行后的新代码从原来的77-78偏移为2077-2078。内联信息对retrace有用：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e    81:88:void clear() -\u0026gt; c\n    2077:2078:void stop():77:78 -\u0026gt; c//stop方法77-78行复制到c中偏移为2077-2078\n    2077:2078:void clear():81 -\u0026gt; c//2077-2078插入到c中的81行后，c为clear方法\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当内联处发生崩溃，根据2077-2078确定是stop方法发生崩溃，而stop实际clear的81行调用，根据2077-2078的偏移还原原始的堆栈应该是：clear方法81行调用stop方法（77-78行）发生崩溃。\u003c/p\u003e\u003cp\u003e行号的规则简化后如下：\u003c/p\u003e\u003cp\u003e（被内联方法的代码行数+1000后/1000）x1000x内联发生的次数+offset，offset为被内联的起始行号。\u003c/p\u003e\u003cp\u003eCopy的代码最低行号为1000+起始行号，如果行数大于1k的话取整之后+起始行号。\u003c/p\u003e\u003ch3 id=\"对于被内联的方法还存在吗\"\u003e对于被内联的方法还存在吗？\u003c/h3\u003e\u003cp\u003e这个是不一定，可能不存在，也可能存在，如果存在的话mapping就会出现对此方法映射。如果被内联之后不会有其他方法调用这个方法不存在，但是该方法如果是因为继承关系（子类继承父类），这种方法通常存在。\u003c/p\u003e\u003ch2 id=\"整个流程是这样的\"\u003e整个流程是这样的\u003c/h2\u003e\u003cp\u003e这几个模块并不是没关联的，接下来把整个流程串起来。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/8c1dcd02f591a0cc7e963341b8e2d34e26721.png\" alt=\"ProGuard流程图\"/\u003e\u003c/p\u003e\u003ch3 id=\"1-初始化\"\u003e1. 初始化\u003c/h3\u003e\u003cp\u003eProGuard初始化会读取我们配置的proguard-rule.txt和各种输入类以及依赖的类库，输入的类被ClassPool统一管理，我们的rule.txt配置了keep类的条件，ProGuard会根据keep规则和输入Classes确定最终需要被keep的类信息列表，这一份列表就是所谓的seeds.txt（种子），以后所有的操作（混淆、压缩、优化）都已seeds为基准，没有被seeds引用的代码都可以移除掉。\u003c/p\u003e\u003ch3 id=\"2-shrink\"\u003e2. shrink\u003c/h3\u003e\u003cp\u003e这部通过引用标记算法，如果没有被用到的类、类成员支持从ClassPool移除掉，只有第一次调用shrink才会产生usage.txt记录了移除掉的类、方法、字段。\u003c/p\u003e\u003ch3 id=\"3-optimize\"\u003e3. optimize\u003c/h3\u003e\u003cp\u003e代码优化做的事情比较复杂，这一部分对类进行优化，包括优化逻辑、变量分配、死代码移除，移除方法中没用的参数、优化指令、以及方法的内联，我们知道内联发生了代码Copy，被Copy的代码不会被当前方法调用。代码优化完之后会重新执行一次\u003cstrong\u003eshrink\u003c/strong\u003e，对于被内联的方法可能真的没有引用，这样就会被移除，但是如果被内联的方法继承关系，这种就要保留。\u003c/p\u003e\u003ch3 id=\"4-obfuscate\"\u003e4. obfuscate\u003c/h3\u003e\u003cp\u003e混淆以类为单位，为类、类成员分配名称，处理冲突名称，输出mapping文件，之后会输出一份经过优化、混淆后的jar。如果使用`-applymapping参数进行增量编译会从mapping里面获取映射关系，找不到映射关系才会为方法、字段分配新名称。mapping文件记录了两类信息：第一类是普通的映射关系，第二类就是内联关系（这部分源于optimize，跟混淆并没有直接关系），对于retrace这两类信息都需要，但是对于增量混淆只需要映射关系。\u003c/p\u003e\u003ch2 id=\"再次回到mapping文件\"\u003e再次回到mapping文件\u003c/h2\u003e\u003ch3 id=\"mappingkeeper读取mapping发生了什么错误\"\u003eMappingKeeper读取mapping发生了什么错误？\u003c/h3\u003e\u003cp\u003e在执行混淆时，MappingKeeper会把mapping中存在的映射关系为ProgramMethod的visitorInfo赋值，但是\u003cstrong\u003e没有区分普通映射还是内联\u003c/strong\u003e，虽然stop方法最初被正确的赋值为b，但是因为内联接下来被错误的赋值为c，此时clear的visitorInfo也是c。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/ef29c3daf8aee421d2bbd568b413119c25449.png\" alt=\"map状态\"/\u003e\u003c/p\u003e\u003cp\u003e当进入MemberNameCollector收集映射关系。stop和clear方法对应的visitorInfo都是c。因为stop方法排序位于clear之后。虽然stop方法的映射被搜集了，但收集到clear之后会把stop的映射覆盖掉，此时map里面已经没有了stop的映射，如左上图。如果stop方法visitorInfo并没有被覆盖此时状态如右上图。\u003c/p\u003e\u003ch3 id=\"进入解决冲突环节\"\u003e进入解决冲突环节\u003c/h3\u003e\u003cp\u003estop的visitorInfo为c，根据map里面的c取到为clear，认为stop跟map里面的映射存在冲突，把stop的visitorInfo设为null，然后重新为stop分为一个带有下划线的名称。\u003c/p\u003e\u003cp\u003e假设clear的描述符不是void类型并且被混淆为f那么map的状态如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/30879e68015e6af7420254467ec3150123830.png\" alt=\"map状态\"/\u003e\u003c/p\u003e\u003cp\u003e因为内联\u003ccode\u003estop()-\u0026gt;f\u003c/code\u003e的干扰，map中stop的visitorInfo由b变为f，但是名称为f的这个方法并不与其他返回值为void类型、参数为空的方法的visitorInfo存在冲突。这个情况就跟文章开头例子里提到的另一个方法transform一样虽然错乱了，但是并不会出现下划线。\u003c/p\u003e\u003ch2 id=\"sample\"\u003eSample\u003c/h2\u003e\u003cp\u003e这个Bug有些项目上很难复现，或者能复现该Bug的项目过于复杂，我们写了一个可以触发这个Bug的\u003ca href=\"https://github.com/rabbittrash/ProGuardSample\"\u003eSample\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e下载项目后首先\u003ccode\u003e./gradlew assembleDebug\u003c/code\u003e产生一个mapping文件，然后把mapping复制到app目录下，到Proguard rule打开\u003ccode\u003e-applymapping\u003c/code\u003e选项再次编译就会出现\u003ccode\u003eWarning: ... is not being kept as ..., but remapped to ...\u003c/code\u003e。\u003c/p\u003e\u003ch2 id=\"关于proguard一些常见问题\"\u003e关于ProGuard一些常见问题\u003c/h2\u003e\u003cp\u003e除了本文提到的增量混淆方法映射混乱，开发者也会遇到下面这些情况：\u003c/p\u003e\u003col\u003e\u003cli\u003e反射，例如\u003ccode\u003eClass clazz=Class.forName(\u0026#34;xxxx\u0026#34;);clazz.getMethod(\u0026#34;method_name\u0026#34;).invoke(...)\u003c/code\u003e与\u003ccode\u003exxxx.class.getMethod(\u0026#34;method_name\u0026#34;).invoke(...)\u003c/code\u003e这两种写法效果一不一样的，后者混淆的时候能正确处理，而前者method_name可能找不到，需要在rule中keep反射的方法。\u003c/li\u003e\u003cli\u003e规则混写会导致配置错误如\u003ccode\u003e-optimizations !code/** method/**\u003c/code\u003e，只允许使用肯定或者或者否定规则，！号为否定规则。\u003c/li\u003e\u003cli\u003e在6.0之前的版本大量单线程操作，整个处理过程比较耗时，如果时间可以将\u003ccode\u003e-optimizationpasses\u003c/code\u003e参数改为1，这样只进行一次代码优化，后面的代码优化带来的提升很少。\u003c/li\u003e\u003c/ol\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e本文主要介绍了Java优化\u0026amp;混淆工具ProGuard的基本原理、ProGuard的几个模块之间的相互关系与影响、以及增量混淆使用\u003ccode\u003e-applymapping\u003c/code\u003e遇到部分方法映射错乱的Bug，Bug出现的原因以及修复方案。代码优化涉及的编译器理论比较抽象，实现也比较复杂，鉴于篇幅限制我们只介绍了代码优化对整个过程带来的影响，对于代码优化有兴趣的读者可以查阅编译器相关的书籍。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e李挺，美团点评技术专家，2014年加入美团。先后负责过多个业务项目和技术项目，致力于推动AOP和字节码技术在美团的应用。曾独立负责美团App预装项目并推动预装实现自动化。主导了美团插件化框架的设计和开发工作，目前工作重心是美团插件化框架的布道和推广。\u003c/li\u003e\u003cli\u003e夏伟，美团点评资深工程师，2017年加入美团。目前从事美团插件化开发，美团平台的一些底层工具优化，如AAPT、ProGuard等，专注于Hook技术、逆向研究，习惯从源码中寻找解决方案。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003e美团平台客户端技术团队，负责美团平台的基础业务和移动基础设施的开发工作。基于海量用户的美团平台，支撑了美团点评多条业务线的快速发展。同时，我们也在移动开发技术方面做了一些积极的探索，在动态化、质量保障、开发模型等方面有一定积累。客户端技术团队积极采用开源技术的同时，也把我们的一些积累回馈给开源社区，希望跟业界一起推动移动开发效率、质量的提升。\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-04-27T00:00:00Z",
  "Author": "soulteary@gmail.com"
}