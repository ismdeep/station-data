{
  "Source": "tech.meituan.com",
  "Title": "函数式编程在Redux/React中的应用",
  "Link": "https://tech.meituan.com/2017/10/12/functional-programming-in-redux.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cp\u003e本文简述了软件复杂度问题及应对策略：抽象和组合；展示了抽象和组合在函数式编程中的应用；并展示了Redux/React在解决前端状态管理的复杂度方面对上述理论的实践。这其中包括了一段有趣的Redux推导。\u003c/p\u003e\u003ch2 id=\"软件复杂度\"\u003e软件复杂度\u003c/h2\u003e\u003cblockquote\u003e\u003cp\u003e软件的首要技术使命是管理复杂度。——代码大全\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e在软件开发过程中，随着需求的变化和系统规模的增大，我们的项目不可避免地会趋于复杂。如何对软件复杂度及其增长速率进行有效控制，便成为一个日益突出的问题。下面介绍两种控制复杂度的有效策略。\u003c/p\u003e\u003ch2 id=\"对应策略\"\u003e对应策略\u003c/h2\u003e\u003ch3 id=\"抽象\"\u003e抽象\u003c/h3\u003e\u003cp\u003e世界的复杂、多变和人脑处理问题能力的有限性，要求我们在认识世界时对其做简化，提取出一般化和共性的概念，形成理论和模型，然后反过来指导我们改造世界。而一般化的过程即抽象的过程，抽象思维使我们忽略不同事物的细节差异，抓住它们的本质，并提出解决本质问题的普适策略。\u003c/p\u003e\u003cp\u003e例如，范畴论将世界抽象为对象和对象之间的联系，Linux 将所有I/O接口都抽象为文件，Redux将所有事件抽象为action。\u003c/p\u003e\u003ch3 id=\"组合\"\u003e组合\u003c/h3\u003e\u003cp\u003e组合是另一种处理复杂事物的有效策略。通过简单概念的组合可以构造出复杂的概念；通过将复杂任务拆分为多个低耦合度的简单的子任务，我们可以对各子任务分而治之；各子任务解决后，将它们重新组合起来，整个任务便得以解决。\u003c/p\u003e\u003cp\u003e软件开发的过程，本质上也是人们认识和改造世界的一种活动，所以也可以借助抽象和组合来处理复杂的任务。\u003c/p\u003e\u003cp\u003e函数式编程是相对于命令式编程而言的。命令式编程依赖数据的变化来管理状态变化，而函数式编程为克服数据变化带来的状态管理的复杂性，限制数据为不可变的，其选择使用流式操作来进行状态管理。而流式操作以函数为基本的操作单元，通过对函数的抽象和组合来完成整个任务。下面对抽象和组合在函数式编程中的应用进行详细的讲解。\u003c/p\u003e\u003ch2 id=\"高阶函数的抽象\"\u003e高阶函数的抽象\u003c/h2\u003e\u003cp\u003e一种功能强大的语言，需要能为公共的模式命名，建立抽象，然后直接在抽象的层次上工作。\u003c/p\u003e\u003cp\u003e如果函数只能以数值或对象为参数，将会严重限制人们建立抽象的能力。经常会有一些同样的设计模式能用于若干不同的过程。为了将这种模式描述为相应的概念，就需要构造出这样的函数，使其以函数作为参数，或者将函数作为返回值。这类能操作函数的函数称为高阶函数。\u003c/p\u003e\u003cp\u003e在进行序列操作时，我们抽象出了三类基本操作：\u003ca href=\"http://ramdajs.com/docs/#map\"\u003emap\u003c/a\u003e、\u003ca href=\"http://ramdajs.com/docs/#filter\"\u003efilter\u003c/a\u003e 和 \u003ca href=\"http://ramdajs.com/docs/#reduce\"\u003ereduce\u003c/a\u003e 。可以通过向这三个抽象出来的高阶函数注入具体的函数，生成处理具体问题的函数；进一步，通过组合这些生成的具体的函数，几乎可以解决所有序列相关的问题。以 \u003ccode\u003emap\u003c/code\u003e 为例，其定义了一大类相似序列的操作：对序列中每个元素进行转换。至于如何转换，需要向 \u003ccode\u003emap\u003c/code\u003e 传入一个具体的转换函数进行具体化。这些抽象出来的高阶函数相当于具有某类功能的通用型机器，而传入的具体函数相当于特殊零件，通用机器配上具体零件就可以应用于属于该大类下的各种具体场景了。\u003c/p\u003e\u003cp\u003e\u003ccode\u003emap\u003c/code\u003e 的重要性不仅体现在它代表了一种公共的模式，还体现在它建立了一种处理序列的高层抽象。迭代操作将人们的注意力吸引到对于序列中逐个元素的处理上，引入 \u003ccode\u003emap\u003c/code\u003e 抑制了对这种细节层面上的关注，强调的是从源序列到目标序列的变换。这两种定义形式之间的差异，并不在于计算机会执行不同的计算过程，而在于我们对同一种操作的不同思考方式。从作用上看，\u003ccode\u003emap\u003c/code\u003e 帮我们建立了一层抽象屏障，将序列转换的函数实现，与如何提取序列中元素以及组合结果的细节隔离开。这种抽象也提供了新的灵活性，使我们有可能在保持从序列到序列的变换操作框架的同时，改变序列实现的底层细节。\u003c/p\u003e\u003cp\u003e例如，我们有一个序列：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst list = [9, 5, 2, 7]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e若对序列中的每个元素加 1：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003emap(a =\u0026gt; a + 1, list) //=\u0026gt; [10, 6, 3, 8]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e若对序列中的每个元素平方：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003emap(a =\u0026gt; a * a, list) //=\u0026gt; [81, 25, 4, 49]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们只需向 \u003ccode\u003emap\u003c/code\u003e 传入具体的转换函数，\u003ccode\u003emap\u003c/code\u003e 便会自动将函数映射到序列的的每个元素。\u003c/p\u003e\u003ch2 id=\"高阶函数的组合\"\u003e高阶函数的组合\u003c/h2\u003e\u003cp\u003e高阶函数使我们可以显式地使用程序设计元素描述过程（函数）的抽象，并能像操作其它元素一样去操作它们。这让我们可以对函数进行组合，将多个简单子函数组合成一个处理复杂任务的函数。下面对高阶函数的组合进行举例说明。\u003c/p\u003e\u003cp\u003e现有一份某公司雇员某月的考核表，我们想统计所有到店餐饮部开发人员该月完成的任务总数，假设员工七月绩效结构如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e[{\n  name: \u0026#39;Pony\u0026#39;,\n  level: \u0026#39;p2.1\u0026#39;,\n  segment: \u0026#39;到餐\u0026#39;\n  tasks: 16,\n  month: \u0026#39;201707\u0026#39;,\n  type: \u0026#39;RD\u0026#39;,\n  ...\n}, {\n  name: \u0026#39;Jack\u0026#39;,\n  level: \u0026#39;p2.2\u0026#39;,\n  segment: \u0026#39;外卖\u0026#39;\n  tasks: 29,\n  month: \u0026#39;201707\u0026#39;,\n  type: \u0026#39;QA\u0026#39;,\n  ...\n}\n...\n]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们可以这样做：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst totalTaskCount = compose(\n  reduce(sum, 0),                              // 4. 计算所有 RD 任务总和\n  map(person =\u0026gt; person.tasks),                 // 3. 提取每个 RD 的任务数\n  filter(person =\u0026gt; person.type === \u0026#39;RD\u0026#39;),      // 2. 筛选出到餐部门中的RD\n  filter(person =\u0026gt; person.segment === \u0026#39;到餐\u0026#39;)  // 1. 筛选出到餐部门的员工\n)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述代码中，\u003ca href=\"http://ramdajs.com/docs/#compose\"\u003e\u003ccode\u003ecompose\u003c/code\u003e\u003c/a\u003e 是用来做函数组合的，上一个函数的输出作为下一个函数的输入。类似于流水线及组成流水线的工作台。每个被组合的函数相当于流水线上的工作台，每个工作台对传过来的工件进行加工、筛选等操作，然后输出给下一个工作台进行处理。\u003c/p\u003e\u003cp\u003e\u003ccode\u003ecompose\u003c/code\u003e 调用顺序为从右向左（自下而上），\u003ca href=\"http://ramda.cn/\"\u003eRamda\u003c/a\u003e 提供了另一个与之对应的API：\u003ca href=\"http://ramdajs.com/docs/#pipe\"\u003e\u003ccode\u003epipe\u003c/code\u003e\u003c/a\u003e，其调用顺序为从左向右。compose意为组合，pipe意为管道、流，其实流是一种纵向的函数组合。\u003c/p\u003e\u003cp\u003e计算到餐RD完成任务总数示意图如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/b80f8538.png\" alt=\"compose\"/\u003e\u003c/p\u003e\u003cp\u003e通过上节\u003ccode\u003emap\u003c/code\u003e示例和本节的计算到餐RD完成任务总数的示例，我们可以看到利用高阶函数进行抽象和组合的强大和简洁之处。这种通用模式（模块）+ “具体函数”组合的模式，显示了通用模块的普适性和处理具体问题时的灵活性。\u003c/p\u003e\u003cp\u003e上面讲了很多高阶函数的优势和实践，然而一门语言如何才能支持高阶函数呢？\u003c/p\u003e\u003cp\u003e通常，程序设计语言总会对基本元素的可能使用方式进行限制。带有最少限制的元素被称为一等公民，包括的 “权利或者特权” 如下所示：\u003c/p\u003e\u003cul\u003e\u003cli\u003e可以使用变量命名；\u003c/li\u003e\u003cli\u003e可以提供给函数作为参数；\u003c/li\u003e\u003cli\u003e可以由函数作为结果返回；\u003c/li\u003e\u003cli\u003e可以包含在数据结构中；\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e幸运的是在JavaScript中，函数被看作是一等公民，也即我们可以在JavaScript中像使用普通对象一样使用高阶函数进行编程。\u003c/p\u003e\u003ch2 id=\"流式操作\"\u003e流式操作\u003c/h2\u003e\u003cp\u003e由上述过程我们得到了一种新的模式——数据流。信号处理工程师可以很自然地用流过一些级联的处理模块信号的方式来描述这一过程。例如我们输入公司全员月度考核信息作为信号，首先会流过两个过滤器，将所有不符合要求的数据过滤掉，这样得到的信号又通过一个映射，这是一个 “转换装置”，它将完整的员工对象转换为对应的任务信息。这一映射的输出被馈入一个累加器，该装置用 \u003ccode\u003esum\u003c/code\u003e 将所有的元素组合起来，以初始的0开始。\u003c/p\u003e\u003cp\u003e要组织好这些过程，最关键的是将注意力集中在处理过程中从一个步骤流向下一个步骤的”信号”。如果我们用序列来表示这些信号，就可以利用序列操作实现每步处理。\u003c/p\u003e\u003cp\u003e或许因为序列操作模式非常具有一般化的性质，于是人们发明了一门专门处理序列的语言Lisp（LISt Processor)……\u003c/p\u003e\u003cp\u003e将程序表示为针对序列的操作，这样做的价值就在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段的组合构成的设计。通过提供一个标准部件的库，并使这些部件都有着一些能以各种灵活方式相互连接的约定接口，将能进一步推动人们去做模块化的设计。\u003c/p\u003e\u003ch2 id=\"用流式操作进行状态管理\"\u003e用流式操作进行状态管理\u003c/h2\u003e\u003cp\u003e在前面，我们已经看到了组合和抽象在克服大型系统复杂性方面所起的作用。但还需要一些能够在整体架构层面帮助我们构造起模块化的大型系统的策略。\u003c/p\u003e\u003cp\u003e目前有两种比较流行的组织策略：面向对象和流式操作。\u003c/p\u003e\u003cp\u003e面向对象组织策略将注意力集中在对象上，将一个大型系统看成一大批对象，它们的状态和行为可能随着时间的进展而不断变化。流式操作组织策略将注意力集中在流过系统的信息流上，很像电子工程师观察一个信号处理系统。\u003c/p\u003e\u003cp\u003e在利用面向对象模式模拟真实世界中的现象时，我们用具有局部状态的计算对象去模拟真实世界里具有局部状态的对象；用计算机里面随着时间的变化去表示真实世界里随着时间的变化；在计算机里，被模拟对象随着时间的变化是通过对那些模拟对象中局部变量的赋值实现的。\u003c/p\u003e\u003cp\u003e我们必须让相应的模型随着时间变化，以便去模拟真实世界中的现象吗？答案是否定的。如果以数学函数的方式考虑这些问题，我们可以将一个量 \u003ccode\u003ex\u003c/code\u003e 随时间而变化的行为，描述为一个时间的函数 \u003ccode\u003ex(t)\u003c/code\u003e。如果我们集中关注的是一个个时刻的 \u003ccode\u003ex\u003c/code\u003e，可以将它看做一个变化着的量。如果关注的是这些值的整个时间史，那么就不需要强调其中的变化——这一函数本身并没有变化。\u003c/p\u003e\u003cp\u003e如果用离散的步长去度量时间，就可以用一个（可能无穷的）序列来模拟变化，以这种序列表示被模拟系统随着时间变化的历史。为此，我们需要引进一种称为流的新数据结构。从抽象的角度看，一个流也是一个序列（无穷序列）。\u003c/p\u003e\u003cp\u003e流处理使我们可以模拟一些包含状态的系统，但却不需要赋值或者变动数据，能避免由于引进了赋值而带来的内在缺陷。\u003c/p\u003e\u003cp\u003e例如在前端开发中，一般会用对象模型（DOM）来模拟和直接操控网页，随着与用户不断交互，网页的局部状态不断被修改，其中的行为也会随时间不断变化。随着时间的累积，我们页面状态管理变得愈加复杂，以致于最终我们可能自己也不知道网页当前的状态和行为。\u003c/p\u003e\u003cp\u003e为了克服对象模型随时间变化带来的状态管理困境，我们引入了 Redux，也就是上面提到的流处理模式，将页面状态 \u003ccode\u003estate\u003c/code\u003e 看作时间的函数 \u003ccode\u003estate = state(t) -\u0026gt; state = stateF(t)\u003c/code\u003e，因为状态的变化是离散的，所以我们也可以写成 \u003ccode\u003estateF(n)\u003c/code\u003e 。通过提取 \u003ccode\u003estate\u003c/code\u003e 并显式地增加时间维度，我们将网页的对象模型转变为流处理模型，用 \u003ccode\u003e[state]\u003c/code\u003e 序列表示网页随着时间变化的状态。\u003c/p\u003e\u003cp\u003e由于 \u003ccode\u003estate\u003c/code\u003e 可以看做整个时间轴上的无穷（具有延时）序列，并且我们在之前已经构造起了对序列进行操作的功能强大的抽象机制，所以可以利用这些序列操作函数处理 \u003ccode\u003estate\u003c/code\u003e ，这里我们用到的是 \u003ccode\u003ereduce\u003c/code\u003e 。\u003c/p\u003e\u003ch2 id=\"从reduce到redux\"\u003e从reduce到Redux\u003c/h2\u003e\u003ch3 id=\"reduce\"\u003ereduce\u003c/h3\u003e\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 是对列表的迭代操作的抽象，\u003ccode\u003emap\u003c/code\u003e 和 \u003ccode\u003efilter\u003c/code\u003e 都可以基于 \u003ccode\u003ereduce\u003c/code\u003e 进行实现。Redux借鉴了 \u003ccode\u003ereduce\u003c/code\u003e 的思想，是 \u003ccode\u003ereduce\u003c/code\u003e 在时间流处理上的一种特殊应用。接下来我们展示Redux是怎样由 \u003ccode\u003ereduce\u003c/code\u003e 一步步推导出来的。\u003c/p\u003e\u003cp\u003e首先看一下 \u003ccode\u003ereduce\u003c/code\u003e 的\u003ca href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html\"\u003e类型签名\u003c/a\u003e：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003ereduce :: ((a, b) -\u0026gt; a) -\u0026gt; a -\u0026gt; [b] -\u0026gt; a\n\nreduce :: (reducer, initialValue, list) -\u0026gt; result\nreducer :: (a, b) -\u0026gt; a\ninitialValue :: a\nlist :: [b]\nresult :: a\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述类型签名采用的是\u003ca href=\"https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system\"\u003eHindley-Milner\u003c/a\u003e 类型系统，接触过Haskell的的同学对此会比较熟悉。其中 \u003ccode\u003e::\u003c/code\u003e 左侧部分为函数或参数名称，右侧为该函数或参数的类型。\u003c/p\u003e\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 接受三个参数：累积器 \u003ccode\u003ereducer\u003c/code\u003e ，累积初始值 \u003ccode\u003einitialValue\u003c/code\u003e，待累积列表 \u003ccode\u003elist\u003c/code\u003e 。我们迭代遍历列表的元素，利用累积器\u003ccode\u003ereducer\u003c/code\u003e 对累积值和列表当前元素进行累积操作，\u003ccode\u003ereducer\u003c/code\u003e 输出新累积值作为下次累积操作的输入。依次循环迭代，直到遍历结束，将此时的累积值作为 \u003ccode\u003ereduce\u003c/code\u003e 最终累积结果输出。\u003c/p\u003e\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 在某些编程语言中也被称为 \u003ccode\u003efoldl\u003c/code\u003e。中文翻译有时也被称为折叠、归约等。如果将列表看做是一把展开的扇子，列表中的每个元素看做每根扇骨，则 \u003ccode\u003ereduce\u003c/code\u003e 的过程也即扇子从左到右不断折叠（归约、累积）的过程。当扇子完全合上，一次折叠也即完成。当然，折叠顺序也可以从右向左进行，即为 \u003ccode\u003ereduceRight\u003c/code\u003e 或 \u003ccode\u003efoldr\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/39ca6d4d.jpg\" alt=\"fan\"/\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003ereduce\u003c/code\u003e 代码实现如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst reduce = (reducer, initialValue, list) =\u0026gt; {\n  let acc = initialValue;\n  let val;\n  for(let i = 0; i \u0026lt; list.length; i++) {\n    val = list[i];\n    acc = reducer(acc, val);\n  }\n  return acc;\n};\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e例如，我们想对一个数字列表 \u003ccode\u003e[2, 3, 4]\u003c/code\u003e 进行累加操作（初始值为 1 )，可以表示为:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003ereduce((a, b) =\u0026gt; a + b, 1, [2, 3, 4])\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e示意图如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a9351ce2.png\" alt=\"reduce\"/\u003e\u003c/p\u003e\u003cp\u003e介绍完 \u003ccode\u003ereduce\u003c/code\u003e 的基本概念，接下来展示如何由 \u003ccode\u003ereduce\u003c/code\u003e 一步步推导出 Redux，以及 Redux 各部分与 \u003ccode\u003ereduce\u003c/code\u003e 的对应关系。\u003c/p\u003e\u003ch3 id=\"redux\"\u003eRedux\u003c/h3\u003e\u003cp\u003e首先定义 Redux 的类型签名：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eredux :: ((state, action) -\u0026gt; state) -\u0026gt; initialState -\u0026gt; [action] -\u0026gt; state\nredux :: (reducer, initialState, stream) -\u0026gt; result\n\nreducer :: (state, action) -\u0026gt; state\ninitialState :: state\nlist :: [action]\nresult :: state\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将 \u003ccode\u003ereduce\u003c/code\u003e 参数的名称变换一下，便得到Redux的类型签名。从类型签名看，Redux参数包含 \u003ccode\u003ereducer\u003c/code\u003e 函数，state初始值 \u003ccode\u003einitialState\u003c/code\u003e ，和一个以 \u003ccode\u003eaction\u003c/code\u003e 为元素的时间流列表 \u003ccode\u003estream :: [action]\u003c/code\u003e；返回值为最终的状态 \u003ccode\u003estate\u003c/code\u003e。\u003c/p\u003e\u003ch4 id=\"redux初步实现\"\u003eRedux初步实现\u003c/h4\u003e\u003cp\u003e下面看一下Redux的初步实现：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst redux = (reducer, initialState, stream) =\u0026gt; {\n  let state = initialState;\n  let action;\n  for(let i = 0; i \u0026lt; stream.length; i++) {\n    action = stream[i];\n    state = reducer(state, action);\n  }\n  return state;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e首先设置Redux \u003ccode\u003estate\u003c/code\u003e 的初始值 \u003ccode\u003einitialState\u003c/code\u003e，\u003ccode\u003estream\u003c/code\u003e 代表基于时间的事件流列表，\u003ccode\u003eaction = stream[i]\u003c/code\u003e 代表事件流上某个时间点发生的一次 \u003ccode\u003eaction\u003c/code\u003e。每次 \u003ccode\u003efor\u003c/code\u003e 循环，我们将当前的状态 \u003ccode\u003estate\u003c/code\u003e 和 \u003ccode\u003eaction\u003c/code\u003e 传给 \u003ccode\u003ereducer\u003c/code\u003e 函数，根据本次 \u003ccode\u003eaction\u003c/code\u003e 对当前 \u003ccode\u003estate\u003c/code\u003e 进行更新，产生新的 \u003ccode\u003estate\u003c/code\u003e。新的 \u003ccode\u003estate\u003c/code\u003e 作为下次 action 发生时的 \u003ccode\u003estate\u003c/code\u003e 参与状态更新。\u003c/p\u003e\u003cp\u003eRedux基本原理其实已经讲完了，Redux的各个概念如：\u003ccode\u003ereducer\u003c/code\u003e 函数、\u003ccode\u003estate\u003c/code\u003e、 \u003ccode\u003estream :: [action]\u003c/code\u003e 也是和 \u003ccode\u003ereduce\u003c/code\u003e 一一对应的。不同之处在于，redux 中的列表 \u003ccode\u003estream\u003c/code\u003e，是一个随时间不断生成的无限长的 \u003ccode\u003eaction\u003c/code\u003e 动作列表，而 \u003ccode\u003ereduce\u003c/code\u003e 中的列表是一个普通的 \u003ccode\u003elist\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e等一下，上述Redux实现貌似缺了些什么……\u003c/p\u003e\u003cp\u003e是的，在Redux中，状态的改变和获取是通过两个函数来操作的：\u003ccode\u003edispatch\u003c/code\u003e、\u003ccode\u003egetState\u003c/code\u003e，接下来我们将这两个函数添加进去。\u003c/p\u003e\u003ch4 id=\"redux优化实现\"\u003eRedux优化实现\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst redux = (reducer, initialState, stream) =\u0026gt; {\n  let currentState = initialState;\n  let action;\n\n  const dispatch = action =\u0026gt; {\n    currentState = reducer(currentState, action);\n  };\n  const getState = () =\u0026gt; currentState;\n\n  for(i = 0; i \u0026lt; stream.length; i++) {\n    action = stream[i];\n    dispatch(action);\n  }\n  return state; // the end of the world :)\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这样我们就可以通过 \u003ccode\u003edispatch(action)\u003c/code\u003e 来更新当前的状态，通过 \u003ccode\u003egetState\u003c/code\u003e 也可以拿到当前的状态。\u003c/p\u003e\u003cp\u003e但是还是感觉不太对？\u003c/p\u003e\u003cp\u003e在上述实现中，\u003ccode\u003estream\u003c/code\u003e 并不是现实中的事件流，只是普通的列表而已，\u003ccode\u003edispatch\u003c/code\u003e 和 \u003ccode\u003egetState\u003c/code\u003e 接口也并没有暴露给外部，同时在Redux最后还有一个 \u003ccode\u003ereturn state\u003c/code\u003e ，既然说过 \u003ccode\u003estream\u003c/code\u003e 是一个无限长的列表，那 \u003ccode\u003ereturn state\u003c/code\u003e 貌似没有什么意义。\u003c/p\u003e\u003cp\u003e好吧，上述两次Redux代码实现，其实都是对Redux原理的说明，下面我们来真正实现一个现实中可运行的最小Redux代码片段。\u003c/p\u003e\u003ch4 id=\"redux可用的最小实现\"\u003eRedux可用的最小实现\u003c/h4\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst redux = (reducer, initialState) =\u0026gt; {\n  let currentState = initialState;\n\n  const dispatch = action =\u0026gt; {\n    currentState = reducer(currentState, action);\n  };\n  const getState = () =\u0026gt; currentState;\n\n  return ({\n    dispatch,\n    getState,\n  });\n};\n\nconst store = redux(reducer, initialState);\nconst action = { type, payload };\nstore.dispatch(action);\nstore.getState();\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eYes! 我们将 \u003ccode\u003estream\u003c/code\u003e 从Redux函数中抽离出来，或者说是从电脑屏幕上抽取到现实世界中了。\u003c/p\u003e\u003cp\u003e我们首先使用 \u003ccode\u003ereducer\u003c/code\u003e 和 \u003ccode\u003einitialState\u003c/code\u003e 初始化 redux 为 \u003ccode\u003estore\u003c/code\u003e；然后现实中每次事件发生时，我们通过 \u003ccode\u003estore.dispatch(action)\u003c/code\u003e 更新store中状态；同时通过 \u003ccode\u003estore.getState()\u003c/code\u003e 来获取 \u003ccode\u003estore\u003c/code\u003e 的当前状态。\u003c/p\u003e\u003cp\u003e等等，这怎么听着像是面向对象的编程方式，对象中包含私有变量：\u003ccode\u003ecurrentState\u003c/code\u003e 和操作私有变量的方法：\u003ccode\u003edispatch\u003c/code\u003e 和 \u003ccode\u003egetState\u003c/code\u003e，伪代码如下所示：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003econst store = {\n  private currentState: initialState,\n  public dispatch: (action) =\u0026gt; { currentState = reducer(currentState, action)},\n  public getState: () =\u0026gt; currentState,\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e是的，从这个角度讲，我们确实是用了函数式的过程实现了一个面向对象的概念。\u003c/p\u003e\u003cp\u003e如果你再仔细看的话，我们用闭包（编程领域的闭包，与集合意义上的闭包不同）实现的这个对象，虽然最后的Redux实现返回的是形式为 \u003ccode\u003e{ dispatch, getState }\u003c/code\u003e \u003ccode\u003estore\u003c/code\u003e 对象，但 \u003ccode\u003edispatch\u003c/code\u003e 和 \u003ccode\u003egetState\u003c/code\u003e 捕获了Redux内部创建的 \u003ccode\u003ecurrentState\u003c/code\u003e，因此形成了闭包。\u003c/p\u003e\u003cp\u003eRedux的运作过程如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/a0c69002.png\" alt=\"redux\"/\u003e\u003c/p\u003e\u003ch4 id=\"redux-和-reduce-的联系与区别\"\u003eRedux 和 reduce 的联系与区别\u003c/h4\u003e\u003cp\u003e我们来总结一下 Redux 和 \u003ccode\u003ereduce\u003c/code\u003e 的联系与区别。\u003c/p\u003e\u003cp\u003e相同点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003ereduce和Redux都是对数据流进行fold（折叠、归约）；\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e两者都包含一个累积器（reducer)（(a, b) -\u0026gt; a VS (state, action) -\u0026gt; state ）和初始值（initialValue VS initialState ），两者都接受一个抽象意义上的列表（list VS stream ）。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e不同点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003ereduce：接收一个有限长度的普通列表作为参数，对列表中的元素从前往后依次累积，并输出最终的累积结果。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eRedux：由于基于时间的事件流是一个无限长的抽象列表，我们无法显式地将事件流作为参数传给Redux，也无法返回最终的累积结果（事件流无限长）。所以我们将事件流抽离出来，通过 \u003ccode\u003edispatch\u003c/code\u003e 主动地向 \u003ccode\u003ereducer\u003c/code\u003e 累积器 push \u003ccode\u003eaction\u003c/code\u003e，通过 \u003ccode\u003egetState\u003c/code\u003e 观察当前的累积值（中间的累积过程）。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e从冷、热信号的角度看，\u003ccode\u003ereduce\u003c/code\u003e 的输入相当于冷信号，累积器需要主动拉取（pull）输入列表中的元素进行累积；而Redux的输入（事件流）相当于热信号，需要外部主动调用 \u003ccode\u003edispatch(action)\u003c/code\u003e 将当前元素push给累积器。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e由上可知，Redux将所有的事件都抽象为 \u003ccode\u003eaction\u003c/code\u003e，无论是用户点击、Ajax请求还是页面刷新，只要有新的事件发生，我们就会 \u003ccode\u003edispatch\u003c/code\u003e 一个 \u003ccode\u003eaction\u003c/code\u003e 给 \u003ccode\u003ereducer\u003c/code\u003e，并结合上一次的状态计算出本次状态。抽象出来的统一的事件接口，简化了处理事件的复杂度。\u003c/p\u003e\u003cp\u003eRedux还规范了事件流——单向事件流，事件 \u003ccode\u003eaction\u003c/code\u003e 只能由 \u003ccode\u003edispatch\u003c/code\u003e 函数派发，并且只能通过 \u003ccode\u003ereducer\u003c/code\u003e 更新系统（网页）的状态 \u003ccode\u003estate\u003c/code\u003e，然后等待下一次事件。这种单向事件流机制能够进一步简化事件管理的复杂度，并且有较好的扩展性，可以在事件流动过程中插入 middleware，比如日志记录、thunk、异步处理等，进而大大增强事件处理的灵活性。\u003c/p\u003e\u003ch3 id=\"redux-的增强-transduce与redux-middleware\"\u003eRedux 的增强：Transduce与Redux Middleware\u003c/h3\u003e\u003cp\u003e\u003ccode\u003etransduce\u003c/code\u003e 作为增强版的 \u003ccode\u003ereduce\u003c/code\u003e，是在 \u003ca href=\"https://clojure.org/reference/transducers\"\u003eClojure\u003c/a\u003e 中首次引入的。\u003ccode\u003etransduce\u003c/code\u003e 相当于 \u003ccode\u003ecompose\u003c/code\u003e 和 \u003ccode\u003ereduce\u003c/code\u003e 的组合，相对于 \u003ccode\u003ereduce\u003c/code\u003e 改进之处为：列表中的每个元素在放入累积器之前，先对其进行一系列的处理。这样做的好处是能同时降低代码的时间复杂度和空间复杂度。\u003c/p\u003e\u003cp\u003e假设有一个长度为n的列表，传统列表处理的做法是先用 \u003ccode\u003ecompose\u003c/code\u003e 组合一系列列表处理函数对列表进行转换处理，最后对处理好的列表进行归约（\u003ccode\u003ereduce\u003c/code\u003e）。假设我们组合了 m 个列表处理函数，加上最后一次 \u003ccode\u003ereduce\u003c/code\u003e，时间复杂度为 n * (m + 1)；而使用 \u003ccode\u003etransduce\u003c/code\u003e 只需要一次循环，所以时间复杂度为 n 。由于 \u003ccode\u003ecompose\u003c/code\u003e 的每个处理函数都会产生中间结果，且这些中间结果有时会占用很大的内存，而 \u003ccode\u003etransduce\u003c/code\u003e 边转换边累积，没有中间结果产生，所以空间复杂度也得到了有效的控制。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/5133579d.png\" alt=\"transduce\"/\u003e\u003c/p\u003e\u003cp\u003e我们也可以对Redux进行类似地增强优化，每次 \u003ccode\u003edispatch(action)\u003c/code\u003e 时，我们先根据 \u003ccode\u003eaction\u003c/code\u003e 进行一系列操作，最后传给 \u003ccode\u003ereducer\u003c/code\u003e 函数进行真正的状态更新。这就是上文提到的Redux middleware。Redux是一个功能和扩展性非常强的状态管理库，而围绕Redux产生的一系列优秀的middlewares让Redux/React 形成了一个强大的前端生态系统。个人认为Redux/React自身良好的架构、先进的理念，加上一系列优秀的第三方插件的支持，是React/Redux成功的关键所在。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/2bd786aa.png\" alt=\"enhance_redux\"/\u003e\u003c/p\u003e\u003ch2 id=\"纯函数在react中的应用\"\u003e纯函数在React中的应用\u003c/h2\u003e\u003cp\u003eRedux可以用作React的数据管理（数据源），React接受Redux输出的state，然后将其转换为浏览器中的具体页面展示出来：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eview = React(state)\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/15f65e33.png\" alt=\"react_redux\"/\u003e\u003c/p\u003e\u003cp\u003e由上可知，我们可以将React看作输入为state，输出为view的“纯”函数。下面讲解纯函数的概念、优点，及其在React中的应用。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e纯函数的定义：相同的输入，永远会得到相同的输出，并且没有副作用。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e纯函数的运算既不受外部环境和内部不确定性因素的影响，也不会影响外部环境。输出只与输入有关。\u003c/p\u003e\u003cp\u003e由此可得纯函数的一些优点：可缓存、引用透明、可等式推导、可预测、单测友好、易于并发操作等。\u003c/p\u003e\u003cp\u003e其实函数式编程中的纯函数指的是数学意义上的函数，数学中函数定义为：\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e从集合的角度讲，函数分为三部分：定义域和值域，以及定义域到值域的映射。函数调用（运算）的过程即定义域到值域映射的过程。\u003c/p\u003e\u003cp\u003e如果忽略中间的计算过程，从对象的角度看，函数可以看做是键值对映射，输入参数为键，输出参数为键对应的值。如果一段代码可以替换为其执行结果，而且是在不改变整个程序行为的前提下替换的，我们就说这段代码是引用透明的。\u003c/p\u003e\u003cp\u003e由于纯函数相同的输入总是返回相同的输出，我们认为纯函数是引用透明的。\u003c/p\u003e\u003cp\u003e纯函数的缓存便是引用透明的一个典型应用，我们将被调用过的参数及其输出结果作为键值对缓存起来，当下次调用该函数时，先查看该参数是否被缓存过，如果是，则直接取出缓存中该键对应的值作为调用结果返回。\u003c/p\u003e\u003cp\u003e缓存技术在做耗时较长的函数调用时比较有用，比如GPU在做大型3D游戏画面渲染时，会对计算时间较长的渲染做缓存，从而增强画面的流畅度。网页中的DOM操作也是非常耗时的，而React组件本身也是纯函数，所以React对 \u003ccode\u003estate\u003c/code\u003e 可以进行缓存，如果\u003ccode\u003estate\u003c/code\u003e没有变化，就还用之前的网页，页面不需要重新渲染。\u003c/p\u003e\u003cp\u003e带有缓存的最终 React-Redux 框架如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/69e5a26e.png\" alt=\"redux_middleware_memoize_react\"/\u003e\u003c/p\u003e\u003cp\u003e我们从产生软件复杂度的原因出发，从方法层面上讲了控制代码复杂度的两种基本方式：抽象和组合，利用处理列表的高阶函数(\u003ccode\u003emap\u003c/code\u003e、\u003ccode\u003efilter\u003c/code\u003e、\u003ccode\u003ereduce\u003c/code\u003e、\u003ccode\u003ecompose\u003c/code\u003e)对抽象和组合进行了举例解释。\u003c/p\u003e\u003cp\u003e然后从整体架构层面上讲了应对复杂度的策略：面向对象和流式处理，分析了两者的基本理念，以及流式处理在状态管理方面的优势，引申出基于时间的抽象事件流。\u003c/p\u003e\u003cp\u003e然后我们展示了如何从列表处理方法 \u003ccode\u003ereduce\u003c/code\u003e 推导出可用的事件流处理框架Redux，并将 \u003ccode\u003ereduce\u003c/code\u003e 的加强版 \u003ccode\u003etransduce\u003c/code\u003e 与Redux的 middleware 做了类比。\u003c/p\u003e\u003cp\u003e最后讲了纯函数在 react/redux 框架中的应用：将页面渲染抽象为纯函数，利用纯函数进行缓存等。\u003c/p\u003e\u003cp\u003e贯穿文章始终的是抽象、组合、函数式编程以及流式处理。希望通过本文让大家对软件开发的一些基本理念及其应用有所了解。从 \u003ccode\u003ereduce\u003c/code\u003e 推导出Redux的过程非常有趣，感兴趣的同学可以多看一下。\u003c/p\u003e\u003cul\u003e\u003cli\u003eHarold A, Gerald J S, Julie S. \u003cem\u003eStructure and Interpretation of Computer Programs\u003c/em\u003e. MIT Press. 1996.\u003c/li\u003e\u003cli\u003eNeal Ford. 函数式编程思维. 郭晓刚 译. 人民邮电出版社, 2015.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/\"\u003eCategory Theory for Programmers\u003c/a\u003e.\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://www.gitbook.com/book/llh911001/mostly-adequate-guide-chinese/details\"\u003eMostly Adequate Guide to Functional Programming(中文版)\u003c/a\u003e.\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e增迪，美团点评前端工程师，熟悉函数式编程、Haskell等，有较为丰富的函数式编程前端实践经验。参与 \u003ca href=\"http://ramdajs.com\"\u003eRamda\u003c/a\u003e 函数式编程库及其\u003ca href=\"http://ramda.cn\"\u003e中文网站\u003c/a\u003e的开发与维护。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e美团点评餐饮平台长期诚聘高级前端工程师/前端技术专家，欢迎发送简历至：wangzengdi@meituan.com。\u003c/strong\u003e\n\u003cstrong\u003ePS：如果您对函数式编程、Haskell、Lisp、Emacs、React、Redux、Ramda 等技术感兴趣，热烈欢迎加入我们。\u003c/strong\u003e\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-10-12T00:00:00Z",
  "Author": "soulteary@gmail.com"
}