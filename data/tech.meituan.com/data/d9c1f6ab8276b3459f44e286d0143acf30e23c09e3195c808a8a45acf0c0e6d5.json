{
  "Source": "tech.meituan.com",
  "Title": "React Native工程中TSLint静态检查工具的探索之路",
  "Link": "https://tech.meituan.com/2019/01/17/exploring-the-tslint-static-checking-tool-on-the-react-native-project.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？\u003c/p\u003e\u003cp\u003e通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？\u003c/p\u003e\u003cp\u003e某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？\u003c/p\u003e\u003cp\u003e以上这些问题，可以通过静态检查有效地缓解！\u003c/p\u003e\u003cp\u003e静态检查（Static Program Analysis）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（Dynamic Program Analysis），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（根据需要）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。\u003c/p\u003e\u003cp\u003e在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。\u003c/p\u003e\u003ch2 id=\"一-使用tslint的原因\"\u003e一、使用TSLint的原因\u003c/h2\u003e\u003cp\u003e在客户端团队进入React Native项目的开发过程中，面临着如下问题：\u003c/p\u003e\u003col\u003e\u003cli\u003e由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误；\u003c/li\u003e\u003cli\u003e开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一；\u003c/li\u003e\u003cli\u003e客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具：\u003c/p\u003e\u003col\u003e\u003cli\u003e可检测代码低级语法错误；\u003c/li\u003e\u003cli\u003e规范项目代码风格；\u003c/li\u003e\u003cli\u003e根据需要可自定义检查代码的逻辑；\u003c/li\u003e\u003cli\u003e工具使用者可以“傻瓜式”的接入部署到开发IDE环境；\u003c/li\u003e\u003cli\u003e可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中；\u003c/li\u003e\u003cli\u003e对于检查出的问题可以快速定位。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。\u003c/p\u003e\u003ch2 id=\"二-tslint介绍\"\u003e二、TSLint介绍\u003c/h2\u003e\u003cp\u003eTSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（Editors）和构建系统（Build Systems）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。\u003c/p\u003e\u003cp\u003e当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档\u003ca href=\"https://palantir.github.io/tslint/\"\u003ehttps://palantir.github.io/tslint/\u003c/a\u003e。\u003c/p\u003e\u003ch3 id=\"2-1-tslint常见规则\"\u003e2.1 TSLint常见规则\u003c/h3\u003e\u003cp\u003e以下规则主要来源于TSLint规则，是某些规则的简单介绍。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/ea43c1b8068dbe0a376a1219fd50a333332751.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003ch3 id=\"2-2-常用tslint规则包\"\u003e2.2 常用TSLint规则包\u003c/h3\u003e\u003cp\u003e上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/0a9eb22cf23502b221dabb2d2d575e69191366.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003cp\u003e我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。\u003c/p\u003e\u003ch2 id=\"三-如何进行tslint规则配置与检查\"\u003e三、如何进行TSLint规则配置与检查\u003c/h2\u003e\u003cp\u003e首先，在工程package.json文件中配置TSLint包：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/ab9434137254ae5220c0e66db4f7e63049159.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003cp\u003e在根目录中的tslint.json文件中可以根据需要配置已有规则，例如：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/7f3ff9903de57120638a26b8d25b0bf773079.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003cp\u003e其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。\u003c/p\u003e\u003cp\u003eTSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。\u003c/p\u003e\u003cp\u003e有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* tslint:disable */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* tslint:enable */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* tslint:disable:rule1 rule2 rule3... */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3…的检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e/* tslint:enable:rule1 rule2 rule3... */\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3…的检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// tslint:disable-next-line\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示此注释所在行的下一行关闭TSLint规则检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003esomeCode(); // tslint:disable-line\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示此注释所在行关闭TSLint规则检查。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// tslint:disable-next-line:rule1 rule2 rule3...\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3…的检查检查。\u003c/p\u003e\u003cp\u003e以上配置信息，这里具体参考了\u003ca href=\"https://palantir.github.io/tslint/usage/rule-flags/\"\u003ehttps://palantir.github.io/tslint/usage/rule-flags/\u003c/a\u003e。\u003c/p\u003e\u003ch3 id=\"3-1-本地检查\"\u003e3.1 本地检查\u003c/h3\u003e\u003cp\u003e在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用\u003ccode\u003enpm install\u003c/code\u003e命令完成下载依赖包。\u003c/p\u003e\u003ch4 id=\"ide环境提示\"\u003eIDE环境提示\u003c/h4\u003e\u003cp\u003e在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/5de6c9d705648b935b5556f62612c54856863.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003ch4 id=\"本地命令检查\"\u003e本地命令检查\u003c/h4\u003e\u003cp\u003eVSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etslint --project tsconfig.json --config tslint.json\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e（此命令如果不正确运行，可在之前加入./node_modules/.bin/）即为：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e./node_modules/.bin/tslint --project tsconfig.json --config tslint.json\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从而会提示出类似以下错误的信息：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-javascript\"\u003esrc/Components/test.ts[1, 7]: Class name must be in pascal case\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"3-2-在线ci检查\"\u003e3.2 在线CI检查\u003c/h3\u003e\u003cp\u003e本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/e7b11dba4f52357e0248483f556a899a41142.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003ch3 id=\"3-3-其他方式\"\u003e3.3 其他方式\u003c/h3\u003e\u003cp\u003e代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。\u003c/p\u003e\u003cul\u003e\u003cli\u003e代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。\u003c/li\u003e\u003cli\u003e代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。\u003c/li\u003e\u003cli\u003e代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"四-自定义编写tslint规则\"\u003e四、自定义编写TSLint规则\u003c/h2\u003e\u003ch3 id=\"4-1-为什么要自定义tslint规则\"\u003e4.1 为什么要自定义TSLint规则\u003c/h3\u003e\u003cp\u003e当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的：\u003c/p\u003e\u003col\u003e\u003cli\u003e团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。\u003c/li\u003e\u003cli\u003e官方规则的开启与配置不符合当前团队情况。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。\u003c/p\u003e\u003ch3 id=\"4-2-自定义规则步骤\"\u003e4.2 自定义规则步骤\u003c/h3\u003e\u003cp\u003e那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/f4c78dbfc3c328694a3a273cce5a6f7c194067.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003cp\u003e自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则”class-name”。\u003c/p\u003e\u003cp\u003e“class-name”规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而”class-name”规则可以有效解决这个问题。我们可以看下具体的源码文件：\u003ca href=\"https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts\"\u003ehttps://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts\u003c/a\u003e。\u003c/p\u003e\u003cp\u003e然后将分步对此自定义规则进行讲解。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/6ebc95659d5f51bf0d273074e9d35889384034.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003ch4 id=\"第一步-文件命名\"\u003e第一步，文件命名\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/88f3fc69526c0f400a835cfa57f94b0866778.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003cp\u003e规则命名必须是符合以下2个规则：\u003c/p\u003e\u003col\u003e\u003cli\u003e驼峰命名。\u003c/li\u003e\u003cli\u003e以’Rule’为后缀。\u003c/li\u003e\u003c/ol\u003e\u003ch4 id=\"第二步-类命名\"\u003e第二步，类命名\u003c/h4\u003e\u003cp\u003e规则的类名是\u003ccode\u003eRule\u003c/code\u003e，并且要继承\u003ccode\u003eLint.Rules.AbstractRule\u003c/code\u003e这个类型，当然也可能有继承\u003ccode\u003eTypedRule\u003c/code\u003e这个类的时候，但是我们通过阅读源码发现，其实它也是继承自\u003ccode\u003eLint.Rules.AbstractRule\u003c/code\u003e这个类。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/1535c3d3d0a80013c97af4cdeeac2b9b128919.png\" alt=\"TSLint规则示例\"/\u003e\u003c/p\u003e\u003ch4 id=\"第三步-填写metadata信息\"\u003e第三步，填写metadata信息\u003c/h4\u003e\u003cp\u003emetadata包含了配置参数，定义了规则的信息以及配置规则的定义。\u003c/p\u003e\u003cul\u003e\u003cli\u003eruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。\u003c/li\u003e\u003cli\u003edescription 一个简短的规则说明。\u003c/li\u003e\u003cli\u003edescriptionDetails 详细的规则说明。\u003c/li\u003e\u003cli\u003erationale 理论基础。\u003c/li\u003e\u003cli\u003eoptions 配置参数形式，如果没有可以配置为null。\u003c/li\u003e\u003cli\u003eoptionExamples 参数范例 ，如没有参数无需配置。\u003c/li\u003e\u003cli\u003etypescriptOnly true/false 是否只适用于TypeScript。\u003c/li\u003e\u003cli\u003ehasFix true/false 是否带有修复方式。\u003c/li\u003e\u003cli\u003erequiresTypeInfo 是否需要类型信息。\u003c/li\u003e\u003cli\u003eoptionsDescrition options的介绍。\u003c/li\u003e\u003cli\u003etype 规则的类型。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e规则类型有四种，分别为：”functionality”、”maintainability”、”style”、”typescript”。\u003c/p\u003e\u003cul\u003e\u003cli\u003efunctionality ： 针对于语句问题以及功能问题。\u003c/li\u003e\u003cli\u003emaintainability：主要以代码简洁、可读、可维护为目标的规则。\u003c/li\u003e\u003cli\u003estyle：以维护代码风格基本统一的规则。\u003c/li\u003e\u003cli\u003etypescript：针对于TypeScript进行提示。\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"第四步-定义错误提示信息\"\u003e第四步，定义错误提示信息\u003c/h4\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/c11774c8392ba92da13e6af4b6e9b47f21111.png\" alt=\"TSLint错误信息\"/\u003e\u003c/p\u003e\u003cp\u003e这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。\u003c/p\u003e\u003ch4 id=\"第五步-实现apply方法\"\u003e第五步，实现apply方法\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eapply\u003c/code\u003e主要是进行静态检查的核心方法，通过返回\u003ccode\u003eapplyWithFunction\u003c/code\u003e方法或者返回\u003ccode\u003eapplyWithWalker\u003c/code\u003e来进行代码检查，其实\u003ccode\u003eapplyWithFunction\u003c/code\u003e方法与\u003ccode\u003eapplyWithWalker\u003c/code\u003e方法的主要区别在于\u003ccode\u003eapplyWithWalker\u003c/code\u003e可以通过\u003ccode\u003eIWalker\u003c/code\u003e实现一个自定义的\u003ccode\u003eIWalker\u003c/code\u003e类，区别如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/5a8d2b0d64a56358307ce9fd828d83be295075.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e其中实现\u003ccode\u003eIWalker\u003c/code\u003e的抽象类\u003ccode\u003eAbstractWalker\u003c/code\u003e里面也继承了\u003ccode\u003eWalkContext\u003c/code\u003e，\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/b9ea64e601b05ba27588378f99769ff0165631.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e而这个\u003ccode\u003eWalkContext\u003c/code\u003e就是上面提到的\u003ccode\u003eapplyWithFunction\u003c/code\u003e的内部实现类。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/ffd88f3cdb8a828b53dd61081394b2ab223585.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003ch4 id=\"第六步-语法树解析\"\u003e第六步，语法树解析\u003c/h4\u003e\u003cp\u003e无论是\u003ccode\u003eapplyWithFunction\u003c/code\u003e方法还是\u003ccode\u003eapplyWithWalker\u003c/code\u003e方法中的\u003ccode\u003eIWalker\u003c/code\u003e实现都传入了\u003ccode\u003esourceFile\u003c/code\u003e这个参数，这个相当于文件的根节点，然后通过\u003ccode\u003ets.forEachChild\u003c/code\u003e方法遍历整个语法树节点。\u003c/p\u003e\u003cp\u003e这里有两个查看AST语法树的工具：\u003c/p\u003e\u003cul\u003e\u003cli\u003eAST Explorer：\n\u003ca href=\"https://astexplorer.net/\"\u003ehttps://astexplorer.net/\u003c/a\u003e\u003cbr/\u003e对应源码：\n\u003ca href=\"https://github.com/fkling/astexplorer\"\u003ehttps://github.com/fkling/astexplorer\u003c/a\u003e\u003c/li\u003e\u003cli\u003eTypeScript AST Viewer：\n\u003ca href=\"https://ts-ast-viewer.com/\"\u003ehttps://ts-ast-viewer.com/\u003c/a\u003e\u003cbr/\u003e对应源码：\n\u003ca href=\"https://github.com/dsherret/ts-ast-viewer\"\u003ehttps://github.com/dsherret/ts-ast-viewer\u003c/a\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eAST Explorer\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e优点：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e缺点：\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e不能选择对应版本的解析器，导致显示的语法树代码版本固定。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/7b82eb62ccd416aeee38f155cf8bcde814584.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e语法树显示的信息相对较少。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/ef0e59385faeefaae9b7bc89f49d6f4b83684.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eTypeScript AST Viewer\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e优点：\u003c/strong\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e解析器对应版本可以动态选择：\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/bafeb3d5acb938137ba42288e302ce9d130408.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息：\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/d2f41a66d05da505d032458f9cdff899180450.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/e10b9f30605db060cc9938e6146af94b195559.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e从而这个工具可以避免频繁根据其数值查找对应信息。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e缺点：\u003c/strong\u003e 不能高亮显示代码对应的AST语法树区域，定位效率较低。\u003c/p\u003e\u003cp\u003e综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。\u003c/p\u003e\u003ch4 id=\"第七步-检查规则代码编写\"\u003e第七步，检查规则代码编写\u003c/h4\u003e\u003cp\u003e通过\u003ccode\u003ets.forEachChild\u003c/code\u003e方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为\u003ccode\u003ets.Node\u003c/code\u003e：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/6433b13ca1d0774faa04c32ce45319f156833.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e其中kind为当前节点的类型，当然\u003ccode\u003eNode\u003c/code\u003e是所有节点的基类，它的实现还包括\u003ccode\u003eStatement\u003c/code\u003e、\u003ccode\u003eExpression\u003c/code\u003e、\u003ccode\u003eDeclaration\u003c/code\u003e等，回到开头这个”class-name”规则，我们的所有声明类主要是class与interface关键字，分别对应\u003ccode\u003eClassExpression\u003c/code\u003e、\u003ccode\u003eClassDeclaration\u003c/code\u003e、\u003ccode\u003eInterfaceDeclaration\u003c/code\u003e，\n我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/23af8a4ca51439aef2b4ae917aefac59127780.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e在规则代码中主要通过\u003ccode\u003eisClassLikeDeclaration\u003c/code\u003e、\u003ccode\u003eisInterfaceDeclaration\u003c/code\u003e这两个方法进行判断的。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/3d7b45f882a358b5bc0a5c3354dcd282105676.jpg\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e其中\u003ccode\u003eisClassLikeDeclaration\u003c/code\u003e、\u003ccode\u003eisInterfaceDeclaration\u003c/code\u003e对应的方法我们可以在node.js文件中找到：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/255a52e6b1ce736f08564b8bad2840b158907.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/b331d925a06c6be281d4bf234c4366a646519.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e判断是对应的类型时，调用\u003ccode\u003eaddFailureAtNode\u003c/code\u003e方法把错误信息和节点传入，当然还可以调用\u003ccode\u003eaddFailureAt\u003c/code\u003e、\u003ccode\u003eaddFailure\u003c/code\u003e方法。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/98fd96f1262115eed2b796ef24d312fa233035.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。\u003c/p\u003e\u003ch4 id=\"第八步-规则配置使用\"\u003e第八步，规则配置使用\u003c/h4\u003e\u003cp\u003e完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etsc ./src/*.ts --outDir dist\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将ts规则生成到dist文件夹（这个文件夹命名用户自定），然后在tslint.json文件中配置生成的规则文件即可。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/a4444307fc34d76799f54b9ce58d544b36027.png\" alt=\"TSLint\"/\u003e\u003c/p\u003e\u003cp\u003e之后在项目的根目录里面，使用以下命令既可进行检查：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etslint --project tsconfig.json --config tslint.json\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003ch3 id=\"tslint的优点\"\u003eTSLint的优点：\u003c/h3\u003e\u003col\u003e\u003cli\u003e速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成；\u003c/li\u003e\u003cli\u003e灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug；\u003c/li\u003e\u003cli\u003e易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"tslint缺点\"\u003eTSLint缺点：\u003c/h3\u003e\u003col\u003e\u003cli\u003e规则的结果只有对与错两种等级结果，没有警告等级的的提示结果；\u003c/li\u003e\u003cli\u003e无法直接报告规则报错数量，只能依赖其他手段统计；\u003c/li\u003e\u003cli\u003eTSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"使用结果及分析\"\u003e使用结果及分析\u003c/h3\u003e\u003cp\u003e在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。\u003c/p\u003e\u003cp\u003e通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。\u003c/p\u003e\u003cp\u003e同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cp\u003e家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-01-17T00:00:00Z",
  "Author": "soulteary@gmail.com"
}