{
  "Source": "tech.meituan.com",
  "Title": "美团服务体验平台对接业务数据的最佳实践-海盗中间件",
  "Link": "https://tech.meituan.com/2018/07/26/sep-service-arrange.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e移动互联网时代，用户体验为王。美团服务体验平台希望能够帮助客户解决在选、购、用美团产品过程中遇到的各种问题，真正做到“以客户为中心”，为客户排忧解难。但服务体验平台内部只维护客户的客诉数据，为了精准地预判和更好地解决客户遇到的问题，系统必须依赖业务部门提供的一些业务数据，包括但不限于订单数据、退款数据、产品数据等等。\n本文会着重讲一下在整个系统交互过程中遇到的一些问题，然后分享一下在实践中探索出来的经验和方法论，希望能够给大家带来一些启发。\u003c/p\u003e\u003ch2 id=\"问题\"\u003e问题\u003c/h2\u003e\u003ch3 id=\"对接场景广而杂\"\u003e对接场景广而杂\u003c/h3\u003e\u003cp\u003e首先，需要接入服务体验平台服务（包括直接面向用户的C端服务、面向客服的工单服务等等）的业务方非常多且杂，而且在不断拓展。美团有非常多的业务线，比如外卖、酒店、旅游、打车、交通、到店餐饮、到店综合、猫眼等等。其中部分业务又延展出多条子业务线，比如大交通部门包含火车票、汽车票、国内机票、国际机票、船票等等。具体到每一条子业务线的每一个业务场景，客户都有可能会遇到问题。对于这些场景，服务体验平台服务都需要调用对应的业务数据接口，来帮助用户自助或者客服协助解决这些问题。就美团现有的业务而言，这样的场景数量会达到万级。而且业务形态在不断迭代，还会有更多的场景被挖掘出来，这些都需要持续对接更多的业务数据来进行支撑。\u003c/p\u003e\u003ch3 id=\"接入场景定制化要求高\"\u003e接入场景定制化要求高\u003c/h3\u003e\u003cp\u003e其次，接入服务体验平台服务的业务方定制化要求很高。因为业务场景的差异化非常大，不同的接入方都希望能够定制特殊复杂逻辑，需要服务体验平台提供的服务解决方案与业务深度耦合。这就需要服务体验平台侧对接入方业务逻辑和数据接口深入了解，并对这些业务数据进行组装，针对每个场景进行定制开发。\u003c/p\u003e\u003ch2 id=\"方案\"\u003e方案\u003c/h2\u003e\u003ch3 id=\"早期方案\"\u003e早期方案\u003c/h3\u003e\u003cp\u003e为了解决上述问题，初期在做系统设计时候，考虑业务方多是既有系统，所以服务体验平台服务趋向平台化设计，并引入了适配层。服务体验平台内部对所有的业务数据和逻辑进行统一抽象，对内标准化接口，屏蔽掉业务逻辑和接口的差异。所有的定制化逻辑都在适配层中封装。但这需要客服侧RD对所有的场景去编写适配器代码，将从一个或者多个业务部门接口中拿到的业务数据，转成内部实际场景需要的数据。\u003c/p\u003e\u003cp\u003e其系统交互如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7a4cc44a.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e缺点\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e虽然上述系统设计能满足业务上的要求，但是存在两个比较明显的缺点。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e编码工作量繁重\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e如上图所示，每个业务场景都需要编写适配器来满足需求，如果依赖的外部接口比较少，场景也比较单一，按照上述方案实施还可以接受。但业务接入非常多且杂，给客服侧RD带来了非常繁重的工作量，包括适配器编写以及后续维护过程中对下游业务接口的持续跟踪和监控。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e客服侧RD需要深入了解业务方逻辑\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e另外，由于客服侧RD对于业务模型的不熟悉，解析业务模型然后组装最终展示给客户的数据，需要比业务方RD花更多的时间来梳理和实现，并且花费更多的时间来验证正确性。比如下面是一个真实的组装业务接口并对业务数据进行处理的案例：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003epublic class TicketAdapterServiceImpl implements OrderAdapterService {\n\n    @Resource(name = \u0026#34;tradeQueryClient\u0026#34;)\n    private TradeTicketQueryClient tradeTicketQueryClient;\n    @Resource\n    private ColumbusTicketService columbusTicketService;\n\n    /** \n    * 根据订单ID获取门票相关的订单数据、门票数据、退款数据等\n    **/\n    @Override\n    public OrderInfoDTO handle(OrderRequestDTO orderRequestDTO) {\n        List\u0026lt;ITradeTicketQueryService.TradeDetailField\u0026gt; tradeDetailFieldList = new ArrayList\u0026lt;ITradeTicketQueryService.TradeDetailField\u0026gt;();\n        tradeDetailFieldList.add(ITradeTicketQueryService.TradeDetailField.ORDER);\n        tradeDetailFieldList.add(ITradeTicketQueryService.TradeDetailField.TICKET);\n        tradeDetailFieldList.add(ITradeTicketQueryService.TradeDetailField.REFUND_REQUEST);\n        try {\n            //通过接口A得到部分订单数据、门票数据和退款数据\n            RichOrderDetail richOrderDetail = tradeTicketQueryClient.getRichOrderDetailById(orderRequestDTO.getOrderId(), tradeDetailFieldList);\n            if (richOrderDetail == null) {\n                return null;\n            }\n            if (richOrderDetail.getOrderDetail() == null) {\n                return null;\n            }\n            OrderDetail orderDetail = richOrderDetail.getOrderDetail();\n            RefundDetail refundDetail = richOrderDetail.getRefundDetail();\n            OrderInfoDTO orderInfoDTO = new OrderInfoDTO(); \n\n            //解析和处理接口A返回的字段，得到客服侧场景真正需要的数据\n            orderInfoDTO.put(\u0026#34;dealId\u0026#34;, orderDetail.getMtDealId());\n            orderInfoDTO.put(DomesticTicketField.VOUCHER_CODE.getValue(), getVoucherCode(richOrderDetail));\n            orderInfoDTO.put(DomesticTicketField.REFUND_CHECK_DUE.getValue(), getRefundCheckDueDate(richOrderDetail));\n            orderInfoDTO.put(DomesticTicketField.REFUND_RECEIVED_DUE.getValue(), getRefundReceivedDueDate(richOrderDetail));\n    \n            //根据接口B获取另外一些订单数据、门票详情数据、退款数据\n            ColumbusTicketDTO columbusTicketDTO = columbusTicketService.getByDealId((int) richOrderDetail.getOrderDetail().getMtDealId());\n            if (columbusTicketDTO == null) {\n                return orderInfoDTO;\n            }\n            //解析和处理接口B返回的字段，得到客服侧场景真正需要的数据\n            orderInfoDTO.put(DomesticTicketField.REFUND_INFO.getValue(), columbusTicketDTO.getRefundInfo());\n            orderInfoDTO.put(DomesticTicketField.USE_METHODS.getValue(), columbusTicketDTO.getUseMethods());\n            orderInfoDTO.put(DomesticTicketField.BOOK_INFO.getValue(), columbusTicketDTO.getBookInfo());\n            orderInfoDTO.put(DomesticTicketField.INTO_METHOD.getValue(), columbusTicketDTO.getIntoMethod());\n      \n            return orderInfoDTO;\n        } catch (TException e) {\n            Cat.logError(\u0026#34;查询不到对应的订单详情\u0026#34;, e);\n            return null;\n        }\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"探索\"\u003e探索\u003c/h3\u003e\u003ch4 id=\"将适配层交由业务方实现\"\u003e将适配层交由业务方实现\u003c/h4\u003e\u003cp\u003e为了克服早期方案的两个缺点，最初，我们希望能够把场景数据的准备和业务模型的解析工作，都交给对业务比较熟悉的团队来处理，即将适配层交由业务方来实现。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/a73cd802.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e这样做的话优势和劣势也比较明显。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e优势\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e客服这边关注自己的领域服务就好，做好平台化，数据提供都交给业务团队，解放了客服侧RD。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e劣势\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e但对业务方来说带来了比较大的工作量，业务方既有服务的复用性很低，对客服侧每一个需要数据的场景，都要重新封装新的服务。\u003c/p\u003e\u003ch3 id=\"更好的解决方案\"\u003e更好的解决方案？\u003c/h3\u003e\u003cp\u003e这个时候我们思考：是否可以既能让业务方解析自己的业务数据，又能够尽量利用既有服务呢？我们考虑把既有服务的组装过程以及模型的转换都让一个服务编排的中间件来实现。但是使用这个中间件有一个前提，就是业务方提供出来的既有服务必须支持泛化调用，避免调用方直接依赖服务方客户端（文章下一个小节也会补充下对于泛化调用的解释）。其交互模型如下图所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6cca8493.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"结果-海盗中间件\"\u003e结果-海盗中间件\u003c/h2\u003e\u003ch3 id=\"简介\"\u003e简介\u003c/h3\u003e\u003ch4 id=\"什么是海盗\"\u003e什么是海盗?\u003c/h4\u003e\u003cp\u003e海盗就是一个用来对支持泛化调用（上述所说）的服务进行编排，然后获取预期结果的一个中间件。使用该中间件调用方可以根据场景来对目标服务进行编排，按需调用。\u003c/p\u003e\u003ch4 id=\"何为泛化调用\"\u003e何为泛化调用？\u003c/h4\u003e\u003cp\u003e通常服务提供方提供的服务都会有自己的接口协议，比如一个获取订单数据的服务：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    package com.dianping.demo;\n    public interface DemoService{\n          OrderDTO  getById(String orderId);\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e而调用方调用该服务需要引入该接口协议，即依赖该服务提供的JAR包。如果调用方需要集成多方数据，那就需要依赖非常多的API，同时服务方接口升级客户端也需要随之进行升级。而泛化调用就可以解决这个问题，通过泛化调用客户端可以在服务方没有提供接口协议和不依赖服务方API的情况下对服务进行调用，通过类似\u003ccode\u003eGenericService\u003c/code\u003e这样一个接口来处理所有的服务请求。\u003c/p\u003e\u003cp\u003e如下是一个泛化调用的Demo：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    public class DemoInvoke{\n        public void genericInvoke(){\n             /** 调用方配置  **/ \n             InvokerConfig\u0026lt;GenericService\u0026gt; invokerConfig = new InvokerConfig(\u0026#34;com.dianping.demo.DemoService\u0026#34;, com.dianping.pigeon.remoting.common.service.GenericService.class);\n             invokerConfig.setTimeout(1000);\n             invokerConfig.setGeneric(GenericType.JSON.getName());\n             invokerConfig.setCallType(\u0026#34;sync\u0026#34;);  \n                 \n             /** 泛化调用 **/\n             final GenericService genericService = ServiceFactory.getService(invokerConfig);\n             List\u0026lt;String\u0026gt; paramTypes = new ArrayList\u0026lt;String\u0026gt;();\n             paramTypes.add(\u0026#34;java.lang.String\u0026#34;);\n             List\u0026lt;String\u0026gt; paramValues = new ArrayList\u0026lt;String\u0026gt;();\n             paramValues.add(\u0026#34;0000000001\u0026#34;);\n             String result = genericService.$invoke(\u0026#34;getById\u0026#34;, paramTypes, paramValues);\n        }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e有了这个泛化调用的前提，我们就可以重点去思考如何对服务进行编排，然后对取得的结果进行处理了。\u003c/p\u003e\u003ch3 id=\"dsl设计\"\u003eDSL设计\u003c/h3\u003e\u003cp\u003e首先重新梳理一下海盗的设计目标：\u003c/p\u003e\u003cblockquote\u003e\u003cul\u003e\u003cli\u003e对既有服务进行编排调用\u003c/li\u003e\u003cli\u003e对获取的数据进行处理\u003c/li\u003e\u003c/ul\u003e\u003c/blockquote\u003e\u003cp\u003e而为了实现服务编排，需要定义一个数据结构来描述服务之间的依赖关系、调用顺序、调用服务的入参和出参等等。之后对获取的结果进行处理，也需要在这个数据结构中具体描述对什么样的数据进行怎么样的处理等等。\u003c/p\u003e\u003cp\u003e所以我们需要定义一套DSL（领域特定语言）来描述整个服务编排的蓝图，其语法如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n    //定义好需要调用的接口以及接口之间的依赖关系，一个接口调用即为一个task\n    \u0026#34;tasks\u0026#34;: [   \n        //第一个task\n        {      \n            \u0026#34;url\u0026#34;: \u0026#34;http://helloWorld.test.hello\u0026#34;,     //url 为pigeon发布的远程服务地址：\n            \u0026#34;alias\u0026#34;: \u0026#34;d1\u0026#34;,   //别名，结果取值的时候可以通过别名引用\n            \u0026#34;taskType\u0026#34;: \u0026#34;PigeonGeneric\u0026#34;,  //task的类别一般可以设置为PigeonGeneric，默认是pigeonAgent方式。\n            \u0026#34;method\u0026#34;: \u0026#34;getByDoubleRequest\u0026#34;, //要调用的pigeon接口的方法名\n            \u0026#34;timeout\u0026#34;: 3000,  //task的超时时间\n            \u0026#34;inputs\u0026#34;: {      //入参情况，多个入参通过key:value的结构书写，key的类别通过下面的inputsExtra定义。\n                \u0026#34;helloWorld\u0026#34;: {\n                    \u0026#34;name\u0026#34;: \u0026#34;csophys\u0026#34;,    //可以通过#orderId，从上下文中获取值，可以通过$d1.orderId的形式从其他的task中获取值\n                    \u0026#34;sex\u0026#34;: \u0026#34;boy\u0026#34;\n                },\n                \u0026#34;name\u0026#34;: \u0026#34;winnie\u0026#34;\n            },\n           \u0026#34;inputsExtra\u0026#34;: {     //入参key的类别定义\n                \u0026#34;helloWorld\u0026#34;: \u0026#34;com.dianping.csc.pirate.remoting.pigeon.pigeon_generic_demo_service.HelloWorld\u0026#34;,\n                \u0026#34;name\u0026#34;: \u0026#34;java.lang.String\u0026#34;\n            }          \n        },\n        //另一个task\n        {    \n            \u0026#34;url\u0026#34;: \u0026#34;http://helloWorld.test.hello\u0026#34;,\n            \u0026#34;alias\u0026#34;: \u0026#34;d2\u0026#34;,\n            \u0026#34;taskType\u0026#34;: \u0026#34;PigeonGeneric\u0026#34;,\n            \u0026#34;method\u0026#34;: \u0026#34;getByDoubleRequest\u0026#34;,\n            \u0026#34;inputsExtra\u0026#34;: {\n                \u0026#34;helloWorld\u0026#34;: \u0026#34;com.dianping.csc.pirate.remoting.pigeon.pigeon_generic_demo_service.HelloWorld\u0026#34;,\n                \u0026#34;name\u0026#34;: \u0026#34;java.lang.String\u0026#34;\n            },\n            \u0026#34;timeout\u0026#34;: 3000,\n            \u0026#34;inputs\u0026#34;: {\n                \u0026#34;helloWorld\u0026#34;: {\n                    \u0026#34;name\u0026#34;: \u0026#34;csophys\u0026#34;,\n                    \u0026#34;sex\u0026#34;: \u0026#34;boy\u0026#34;\n                },\n                \u0026#34;name\u0026#34;: \u0026#34;winnie\u0026#34;\n            }\n        }\n    ],\n    \u0026#34;name\u0026#34;: \u0026#34;pigeonGenericUnitDemo\u0026#34;,  //DSL的名称定义，暂时没有特别含义\n    \u0026#34;description\u0026#34;: \u0026#34;pigeon泛型调用测试\u0026#34;,  //DSL的描述\n    \u0026#34;outputs\u0026#34;: {            //定义好最后输出的数据模型\n        \u0026#34;d1name\u0026#34;: \u0026#34;$d1.name\u0026#34;,\n        \u0026#34;languages\u0026#34;: \u0026#34;$d2.languages\u0026#34;,\n        \u0026#34;language1\u0026#34;: \u0026#34;$d2.languages[0]\u0026#34;,\n        \u0026#34;name\u0026#34;: \u0026#34;csophys\u0026#34;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"架构设计\"\u003e架构设计\u003c/h3\u003e\u003cp\u003e有了DSL来描述整个编排蓝图之后，海盗自然要对该DSL进行解析，然后对服务进行具体调用。其整体架构如下所示：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/ac3c196f.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e其中涉及到几个重点概念：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eFacade：对外提供统一接口，供客户端调用。\u003c/li\u003e\u003cli\u003eParser：对于输入的DSL进行解析，解析成内部流转的数据结构，同时得到所有的task，并且构建task调用逻辑树。\u003c/li\u003e\u003cli\u003eExecutor：真实发起调用的模块，目前支持平台内部的Pigeon和MTThrift调用方式，同时对HTTP等其他协议有良好的扩展性。\u003c/li\u003e\u003cli\u003eDataProcessor：数据后处理。这边会把所有接口拿到的数据转换层客服场景这边需要的数据，并且通过设计的一些内部函数，可以支持一些如数据半脱敏等功能。\u003c/li\u003e\u003cli\u003e组件插件化：对日志等功能实现可插拔，调用方可以自定义这些组件，即插即用。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"主要feature\"\u003e主要Feature\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e海盗具有如下主要特点：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e采用去中心化的设计思路，引擎集成在SDK中。方案通用化，每一个需要业务数据的场景都可以通过海盗直接调用数据提供方。\u003c/li\u003e\u003cli\u003e服务编排支持并行和串行调用，使用方可以根据实际场景自己构造服务调用树。通过DSL的方式把之前硬编码组装的逻辑实现了配置化，然后通过海盗引擎把能并行调用的服务都执行了并行调用，数据使用方不用再自己处理性能优化。\u003c/li\u003e\u003cli\u003e使用JSON DSL 描述整个工作蓝图，简单易学。\u003c/li\u003e\u003cli\u003e支持JSONPath语法对服务返回的结果进行取值。\u003c/li\u003e\u003cli\u003e支持内置函数和自定义指令（语法参考ftl）对取到的元数据进行处理，得到需要的最终结果。\u003c/li\u003e\u003cli\u003e编排服务树可视化。\u003c/li\u003e\u003cli\u003e目前集团内部RPC中间件包括Pigeon、MTThrift，已进行了泛化调用支持，可以通过海盗实现Pigeon服务和MTThrift的服务编排。不需要限制业务团队的服务提供方式，但需要升级中间件版本。这里特别感谢服务治理团队的大力支持。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"tutorial\"\u003eTutorial\u003c/h3\u003e\u003cp\u003e场景：需要根据订单ID查询订单状态和支付状态，但目前没有现成的接口支持该功能，但有两个既有接口分别是：\u003c/p\u003e\u003cul\u003e\u003cli\u003e接口1：根据订单ID，获取到订单状态和支付流水号\u003c/li\u003e\u003cli\u003e接口2：根据支付流水号获取支付状态\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e那我们可以对这两个接口进行编排，编写DSL如下：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n  \u0026#34;tasks\u0026#34;: [\n    {\n      \u0026#34;url\u0026#34;: \u0026#34;http://test.service\u0026#34;,\n      \u0026#34;alias\u0026#34;: \u0026#34;d1\u0026#34;,\n      \u0026#34;taskType\u0026#34;: \u0026#34;PigeonGeneric\u0026#34;,\n      \u0026#34;method\u0026#34;: \u0026#34;getByOrderId\u0026#34;,\n      \u0026#34;timeout\u0026#34;: 3000,\n      \u0026#34;inputs\u0026#34;: {\n        \u0026#34;orderId\u0026#34;: \u0026#34;#orderId\u0026#34;\n      },\n      \u0026#34;inputsExtra\u0026#34;: {\n        \u0026#34;name\u0026#34;: \u0026#34;java.lang.String\u0026#34;\n      }\n    },\n    {\n      \u0026#34;url\u0026#34;: \u0026#34;http://test.service\u0026#34;,\n      \u0026#34;alias\u0026#34;: \u0026#34;d2\u0026#34;,\n      \u0026#34;taskType\u0026#34;: \u0026#34;PigeonGeneric\u0026#34;,\n      \u0026#34;method\u0026#34;: \u0026#34;getPayStatus\u0026#34;,\n      \u0026#34;timeout\u0026#34;: 3000,\n      \u0026#34;inputs\u0026#34;: {\n        \u0026#34;paySerialNo\u0026#34;: \u0026#34;$d1.paySerialNo\u0026#34;\n      },\n      \u0026#34;inputsExtra\u0026#34;: {\n        \u0026#34;time\u0026#34;: \u0026#34;java.lang.String\u0026#34;\n      }\n    }\n  ],\n  \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;,\n  \u0026#34;description\u0026#34;: \u0026#34;组装上述接口获取订单状态和支付状态\u0026#34;,\n  \u0026#34;outputs\u0026#34;: {\n    \u0026#34;orderStatus\u0026#34;: \u0026#34;$d1.orderStatus\u0026#34;,\n    \u0026#34;payStatus\u0026#34;: \u0026#34;$d2.payStatus\u0026#34;\n  }\n}\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后客户端进行调用：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e    String DSL = \u0026#34;上述DSL文件\u0026#34;;\n    String params  = \u0026#34;{\\\u0026#34;orderId\\\u0026#34;:\\\u0026#34;000000001\\\u0026#34;}\u0026#34;;\n    Response resp = PirateEngine.invoke(DSL, params);\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e最后得到的数据即为调用场景真正需要的数据：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e{\n   \u0026#34;orderStatus\u0026#34;:1,\n   \u0026#34;payStatus\u0026#34;:2\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"开发流程变化\"\u003e开发流程变化\u003c/h3\u003e\u003cp\u003e因为获取数据的架构产生了变化，开发流程也随之发生改变。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/948e240e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e如图所示，因为减少了客服侧RD不断去向业务方RD确认返回的数据含义和逻辑，双方RD各自专注各自熟悉的领域，开发效率和最终结果准确性都有显著提升。\u003c/p\u003e\u003ch2 id=\"总结和展望\"\u003e总结和展望\u003c/h2\u003e\u003ch3 id=\"最后总结一下使用海盗之后的优势\"\u003e最后总结一下使用海盗之后的优势\u003c/h3\u003e\u003cul\u003e\u003cli\u003e去中心化的设计，可用性得到保证。\u003c/li\u003e\u003cli\u003e服务复用性高，领域划分更加清晰，让RD专注在自己熟悉的领域，降低研发成本。\u003c/li\u003e\u003cli\u003e因为流程变化后，业务方可以提前验证提供的数据，高质量交付。\u003c/li\u003e\u003cli\u003e客服侧对数据获取进行统一收口，可以对所有调用服务统一监控并对数据统一处理。\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"展望\"\u003e展望\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003e海盗的技术规划：\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e丰富内部函数和运算表达式\u003c/strong\u003e：目前海盗提供了一部分简单的内部函数用来对取到的值进行简单处理，同时正在实现支持调用方自定义运算表达式来支持复杂场景的数据处理，这部分需要持续完善。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e屏蔽远程调用协议异构性\u003c/strong\u003e：目前海盗只支持对美团Pigeon和MTThrift服务进行编排，这里要对协议进行扩展，支持类似HTTP等通用协议，同时支持调用方自定义协议和调用实现。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e运营工具完善\u003c/strong\u003e：提供一个比较完整的运营工具，调用方可以自行配置DSL并进行校验，然后一键调用查询最终结果。同时调用方可以通过该工具进行日志、报表等相关数据查询。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e自动生成单元测试\u003c/strong\u003e：能够把经过验证的DSL生成相应的单元测试用例给到数据提供方，持续保障提供的DSL的可用性和正确性。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e王彬，美团资深研发工程师，毕业于南京大学，2017年2月加入美团。目前主要专注于智能客服领域，从事后端工作。\u003c/li\u003e\u003cli\u003e陈胜，海盗项目负责人，智能客服技术负责人，2013年加入大众点评。在未来智能客服组会持续在平台化和垂直领域方向深入下去，为消费者、商家、企业提供更加智能的客户服务体验。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘广告\"\u003e招聘广告\u003c/h2\u003e\u003cp\u003e服务体验平台可以深入接触到公司的所有业务，推进业务改善产品。提升客户的服务体验。打造一个客户贴身的智能服务助手。通过技术的手段更快地解决客户的问题，并且最大程度地节省客服的人力成本。欢迎有意向的同学加入服务体验平台，上海、北京都有需求。简历请投递至：sheng.chen#dianping.com\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-07-26T00:00:00Z",
  "Author": "soulteary@gmail.com"
}