{
  "Source": "tech.meituan.com",
  "Title": "Spring Data REST 远程代码执行漏洞（CVE-2017-8046）分析与复现",
  "Link": "https://tech.meituan.com/2017/09/29/spring-data-rest-cve.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003e2009年9月Spring 3.0 RC1发布后，Spring就引入了SpEL（Spring Expression Language）。对于开发者而言，引入新的工具显然是令人兴奋的，但是对于运维人员，也许是噩耗的开始。类比Struts 2框架，会发现绝大部分的安全漏洞都和ognl脱不了干系。尤其是远程命令执行漏洞，占据了多少甲方乙方工程师的夜晚/周末，这导致Struts 2越来越不受待见。\u003c/p\u003e\u003cp\u003e因此，我们有理由相信Spring引入SpEL必然增加安全风险。事实上，过去多个Spring CVE都与其相关，如\u003ca href=\"https://pivotal.io/security/cve-2017-8039\"\u003eCVE-2017-8039\u003c/a\u003e、\u003ca href=\"https://pivotal.io/security/cve-2017-4971\"\u003eCVE-2017-4971\u003c/a\u003e、\u003ca href=\"https://pivotal.io/security/cve-2016-5007\"\u003eCVE-2016-5007\u003c/a\u003e、\u003ca href=\"https://pivotal.io/security/cve-2016-4977\"\u003eCVE-2016-4977\u003c/a\u003e等。\u003c/p\u003e\u003cp\u003e本文分析的CVE-2017-8046同样也与SpEL有关。如果急于查看自己的应用是否受影响和修复建议，请查看\u003ca href=\"https://pivotal.io/security/cve-2017-8046\"\u003e官方公告\u003c/a\u003e，或者跳至0x07漏洞修复。\u003c/p\u003e\u003ch2 id=\"spring-data-rest简介\"\u003eSpring Data REST简介\u003c/h2\u003e\u003cp\u003eSpring Data REST是Spring Data的一个子项目。关于Spring Data，引用官方介绍如下：\n\u0026gt; Spring Data’s mission is to provide a familiar and consistent, Spring-based programming model for data access while still retaining the special traits of the underlying data store.\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eIt makes it easy to use data access technologies, relational and non-relational databases, map-reduce frameworks, and cloud-based data services. This is an umbrella project which contains many subprojects that are specific to a given database. The projects are developed by working together with many of the companies and developers that are behind these exciting technologies.\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e\u003cstrong\u003e一句话概括\u003c/strong\u003e：Spring Data是对数据访问的更高抽象。通过它，开发者进一步从数据层解放出来，更专注于业务逻辑。不管是关系型数据还是非关系型数据，利用相应接口，开发者可以使用非常简单的代码构建对数据的访问（当然，Spring Data还有很多特性和功能，感兴趣的可参考官方文档）。\u003c/p\u003e\u003cp\u003e回过头看Spring Data REST，它是一个构建在Spring Data之上，为了帮助开发者更加容易地开发REST风格的Web服务，官方声称完成demo只需15分钟。\u003c/p\u003e\u003ch2 id=\"官方提供的demo\"\u003e官方提供的Demo\u003c/h2\u003e\u003cp\u003e参照官方文档，笔者使用Maven构建Spring-boot应用，数据库为H2 Database。\u003c/p\u003e\u003cp\u003e1) 添加依赖，pom.xml内容来自官方示例文档。\n2) 编写实体类Person。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//import 省略\n \n@Entity\npublic class Person {\n    @Id\n    @GeneratedValue(strategy = GenerationType.AUTO)\n    private long id;          //自增主健\n    private String firstName;\n    private String lastName;\n//getter setter省略\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e3) 编写接口。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//import 省略\n \n//在/people处创建RESTful入口点\n@RepositoryRestResource(collectionResourceRel = \u0026#34;people\u0026#34;, path = \u0026#34;people\u0026#34;)\npublic interface PersonRepository extends PagingAndSortingRepository\u0026lt;Person, Long\u0026gt; {\n//接口继承了PagingAndSortingRepository，此接口封装了对Person实体类的CURD，并且具备分页和排序\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e4) Spring Boot执行入口。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//import 省略\n  \n@SpringBootApplication\npublic class Application {\n \n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e5) 编译运行。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/631dd519.png\" alt=\"编译运行\"/\u003e\u003c/p\u003e\u003ch2 id=\"数据操作测试\"\u003e数据操作测试\u003c/h2\u003e\u003cp\u003e1）测试是否成功\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/eb8667d1.png\" alt=\"数据操作测试\"/\u003e\u003c/p\u003e\u003cp\u003e2）使用POST方法添加一个数据\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/f67fcf32.png\" alt=\"数据操作测试\"/\u003e\u003c/p\u003e\u003cp\u003e3）查看新加入的数据\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/f4f80bb4.png\" alt=\"数据操作测试\"/\u003e\u003c/p\u003e\u003cp\u003e4）使用PATCH请求方法更新数据\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/e13a7b8a.png\" alt=\"数据操作测试\"/\u003e\u003c/p\u003e\u003cp\u003e对于JSON Patch请求方法IETF制定了标准\u003ca href=\"https://tools.ietf.org/html/rfc6902\"\u003eRFC6902\u003c/a\u003e。JSON Patch方法提交的数据必须包含一个path成员，用于定位数据，同时还必须包含op成员，可选值如下：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth align=\"left\"\u003eop\u003c/th\u003e\u003cth align=\"left\"\u003e含义\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eadd\u003c/td\u003e\u003ctd align=\"left\"\u003e添加数据\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003eremove\u003c/td\u003e\u003ctd align=\"left\"\u003e删除数据\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003ereplace\u003c/td\u003e\u003ctd align=\"left\"\u003e修改数据\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003emove\u003c/td\u003e\u003ctd align=\"left\"\u003e移动数据\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003ecopy\u003c/td\u003e\u003ctd align=\"left\"\u003e拷贝数据\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd align=\"left\"\u003etest\u003c/td\u003e\u003ctd align=\"left\"\u003e测试给定数据与指定位置数据是否相等\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e比如对于上面添加的Person数据，修改其lastName属性，请求数据如下：\n\u0026gt; [{ “op”: “replace”, “path”: “/lastName”, “value”: “Zhang” }]\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e有两点需要注意：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e① 必须将Content-Type指定为application/json-patch+json。\n② 请求数据必须是json数组。\u003c/p\u003e\u003ch2 id=\"漏洞分析\"\u003e漏洞分析\u003c/h2\u003e\u003cblockquote\u003e\u003cp\u003e漏洞分析涉及的源码比较多，为了减少歧义和减小篇幅，约定两点：\n① 代码以片段[a-z]标识；\n② 提到某个方法不会包含完整的方法签名，仅提供方法名，需联系上下文识别。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e1）根据官方公告，结合GitHub 的\u003ca href=\"https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45\"\u003ecommit\u003c/a\u003e，猜测漏洞出在path参数值的处理上。尝试提交非法的path参数值，查看异常堆栈信息：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003eat org.springframework.expression.spel.ast.MethodReference$MethodValueRef.setValue(MethodReference.java:355) ~[spring-expression-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.expression.spel.ast.CompoundExpression.setValue(CompoundExpression.java:95) ~[spring-expression-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.expression.spel.standard.SpelExpression.setValue(SpelExpression.java:438) ~[spring-expression-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.data.rest.webmvc.json.patch.PatchOperation.setValueOnTarget(PatchOperation.java:167) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.json.patch.ReplaceOperation.perform(ReplaceOperation.java:41) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.json.patch.Patch.apply(Patch.java:64) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.config.JsonPatchHandler.applyPatch(JsonPatchHandler.java:91) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.config.JsonPatchHandler.apply(JsonPatchHandler.java:83) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.readPatch(PersistentEntityResourceHandlerMethodArgumentResolver.java:206) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.read(PersistentEntityResourceHandlerMethodArgumentResolver.java:184) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.data.rest.webmvc.config.PersistentEntityResourceHandlerMethodArgumentResolver.resolveArgument(PersistentEntityResourceHandlerMethodArgumentResolver.java:141) ~[spring-data-rest-webmvc-2.6.6.RELEASE.jar:na]\n    at org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:158) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:128) ~[spring-web-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967) ~[spring-webmvc-4.3.10.RELEASE.jar:4.3.10.RELEASE]\n    //省略部分堆栈信息\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e2）既然是Patch请求方法，我们从org.springframework.data.rest.webmvc.config.JsonPatchHandler.apply(JsonPatchHandler.java:83)入手分析。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段a:\n   public \u0026lt;T\u0026gt; T apply(IncomingRequest request, T target) throws Exception {\n       Assert.notNull(request, \u0026#34;Request must not be null!\u0026#34;);\n       Assert.isTrue(request.isPatchRequest(), \u0026#34;Cannot handle non-PATCH request!\u0026#34;);\n       Assert.notNull(target, \u0026#34;Target must not be null!\u0026#34;);\n       if (request.isJsonPatchRequest()) {//\n           return applyPatch(request.getBody(), target);\n       } else {\n           return applyMergePatch(request.getBody(), target);\n       }\n   }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e片段a中的if判断决定了请求Content-Type须指定application/json-patch+json。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段b:\npublic boolean isJsonPatchRequest() {\n        return isPatchRequest() //是否是PATCH请求方法\n                                //Content-Type是否与application/json-patch+json兼容\n        \u0026amp;\u0026amp; RestMediaTypes.JSON_PATCH_JSON.isCompatibleWith(contentType);\n                             \n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e片段a中的if判断为true的话，进入applyPatch方法：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段c:\n@SuppressWarnings(\u0026#34;unchecked\u0026#34;)\n\u0026lt;T\u0026gt; T applyPatch(InputStream source, T target) throws Exception {\n    return getPatchOperations(source).apply(target, (Class\u0026lt;T\u0026gt;) target.getClass());\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e跟进getPatchOperations方法：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段d:\nprivate Patch getPatchOperations(InputStream source) {\n    try {\n        return new JsonPatchPatchConverter(mapper).convert(mapper.readTree(source));//通过Jackson 生成对应的对象实例\n    } catch (Exception o_O) {\n        throw new HttpMessageNotReadableException(\n                String.format(\u0026#34;Could not read PATCH operations! Expected %s!\u0026#34;, RestMediaTypes.JSON_PATCH_JSON), o_O);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e片段d通过Jackson实例化对象，我们看看相关构造函数:\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段e:\npublic Patch(List\u0026lt;PatchOperation\u0026gt; operations) {\n    this.operations = operations;\n}\n//片段f:\npublic PatchOperation(String op, String path, Object value) {\n    this.op = op;\n    this.path = path;\n    this.value = value;\n    this.spelExpression = pathToExpression(path);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对于PatchOperation对象，成员spelExpression根据path转化而来，这一点对于PoC构造非常重要，笔者一开始就坑在这里。\npathToExpression完整的调用链比较长，影响PoC的构造关键在于下面两个方法。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段g:\nprivate static String pathToSpEL(String path) {\n    return pathNodesToSpEL(path.split(\u0026#34;\\\\/\u0026#34;));//跟据斜杠分割成字符数组\n}\n//片段h:\nprivate static String pathNodesToSpEL(String[] pathNodes) {\n    StringBuilder spelBuilder = new StringBuilder();\n \n    for (int i = 0; i \u0026lt; pathNodes.length; i++) {\n        String pathNode = pathNodes[i];\n        if (pathNode.length() == 0) {\n            continue;\n        }\n        if (APPEND_CHARACTERS.contains(pathNode)) {\n            if (spelBuilder.length() \u0026gt; 0) {\n                spelBuilder.append(\u0026#34;.\u0026#34;);\n            }\n            spelBuilder.append(\u0026#34;$[true]\u0026#34;);\n            continue;\n        }\n        try {\n            int index = Integer.parseInt(pathNode);\n            spelBuilder.append(\u0026#39;[\u0026#39;).append(index).append(\u0026#39;]\u0026#39;);\n        } catch (NumberFormatException e) {\n            if (spelBuilder.length() \u0026gt; 0) {//使用.拼接字符数组\n                                          //如笔者尝试执行touch /tmp/file，\n                spelBuilder.append(\u0026#39;.\u0026#39;);  //并未在/tmp中发现file文件，后来发现应用目录中多了隐藏文件，\n            }                             //原因就在此处\n            spelBuilder.append(pathNode);\n        }\n    }\n    String spel = spelBuilder.toString();\n    if (spel.length() == 0) {\n        spel = \u0026#34;#this\u0026#34;;\n    }\n    return spel;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e回到片段C，继续看apply：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段i:\npublic \u0026lt;T\u0026gt; T apply(T in, Class\u0026lt;T\u0026gt; type) throws PatchException {\n    for (PatchOperation operation : operations) {\n        operation.perform(in, type);\n    }\n    return in;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在RFC6902的标准中，一次PATCH请求允许多个操作，比如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-json\"\u003e[\n { \u0026#34;op\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/a/b/c\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;foo\u0026#34; },\n { \u0026#34;op\u0026#34;: \u0026#34;remove\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/a/b/c\u0026#34; },\n { \u0026#34;op\u0026#34;: \u0026#34;add\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;/a/b/c\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] }\n]\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e对于上面的请求数据，将会顺序执行test、remove、add操作（当前操作的”文档”为上一次操作更新后的”文档”）。\u003c/p\u003e\u003cp\u003e因此，在代码片段i中循环每一个”操作”。假设我们提交了一个PATCH请求op为replace，我们接着看PatchOperation子类ReplaceOperation的perform方法：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段j:\n\u0026lt;T\u0026gt; void perform(Object target, Class\u0026lt;T\u0026gt; type) {\n    setValueOnTarget(target, evaluateValueFromTarget(target, type));\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e调用父类PatchOperation的evaluateValueFromTarget方法：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段k:\nprotected \u0026lt;T\u0026gt; Object evaluateValueFromTarget(Object targetObject, Class\u0026lt;T\u0026gt; entityType) {\n \n    return value instanceof LateObjectEvaluator\n            ? ((LateObjectEvaluator) value).evaluate(spelExpression.getValueType(targetObject)) : value;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e官方在evaluateValueFromTarget方法中打了补丁，补丁的修复逻辑是检查路径是否合法，如果不合法则会抛出PatchException。完整的补丁信息可以从GitHub看对应\u003ca href=\"https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45\"\u003ecommit\u003c/a\u003e。\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-java\"\u003e//片段l:\n    protected \u0026lt;T\u0026gt; Object evaluateValueFromTarget(Object targetObject, Class\u0026lt;T\u0026gt; entityType) {\n-       return value instanceof LateObjectEvaluator\n-               ? ((LateObjectEvaluator) value).evaluate(spelExpression.getValueType(targetObject)) : value;\n+       verifyPath(entityType);\n+\n+       return evaluate(spelExpression.getValueType(targetObject));\n+   }\n \n+\n \n+   protected final \u0026lt;T\u0026gt; Object evaluate(Class\u0026lt;T\u0026gt; type) {\n+       return value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(type) : value;\n+   }\n \n+\n \n+   /**\n+    * Verifies that the current path is available on the given type.\n+    * \n+    * @param type must not be {@literal null}.\n+    * @return the {@link PropertyPath} representing the path. Empty if the path only consists of index lookups or append\n+    *         characters.\n+    */\n \n+   protected final Optional\u0026lt;PropertyPath\u0026gt; verifyPath(Class\u0026lt;?\u0026gt; type) {\n+\n+       String pathSource = Arrays.stream(path.split(\u0026#34;/\u0026#34;))//\n+               .filter(it -\u0026gt; !it.matches(\u0026#34;\\\\d\u0026#34;)) // no digits\n+               .filter(it -\u0026gt; !it.equals(\u0026#34;-\u0026#34;)) // no \u0026#34;last element\u0026#34;s\n+               .filter(it -\u0026gt; !it.isEmpty()) //\n+               .collect(Collectors.joining(\u0026#34;.\u0026#34;));\n+\n+       if (pathSource.isEmpty()) {\n+           return Optional.empty();\n+       }\n+\n+       try {\n+           return Optional.of(PropertyPath.from(pathSource, type)); //根据对象和路径获取PropertyPath\n+       } catch (PropertyReferenceException o_O) {\n+           throw new PatchException(String.format(INVALID_PATH_REFERENCE, pathSource, type, path), o_O);\n+       }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e回过头看代码片段j，setValueOnTarget再往后走就是SpEL解析了。由于SpEL非该漏洞核心，本文不再深入。\u003c/p\u003e\u003ch2 id=\"漏洞复现\"\u003e漏洞复现\u003c/h2\u003e\u003cp\u003e明白了漏洞原理之后，复现就非常简单了。注入表达式没有太多限制。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/cda3a13f.jpg\" alt=\"漏洞复现\"/\u003e\u003c/p\u003e\u003ch2 id=\"漏洞修复\"\u003e漏洞修复\u003c/h2\u003e\u003cp\u003e漏洞在9月21日披露，虽然定位为严重。但是笔者持续跟踪，并未发现国内哪些站点在跟进，不排除攻击者利用此漏洞攻击未打补丁的受影响应用。\u003c/p\u003e\u003cp\u003e漏洞信息来源于\u003ca href=\"https://pivotal.io/security/cve-2017-8046\"\u003e官方公告\u003c/a\u003e。\n\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/b3ec82e6.png\" alt=\"漏洞修复\"/\u003e\u003c/p\u003e\u003cp\u003e值得注意的是，本次漏洞问题出现在 spring-data-rest-webmvc中。由于Spring 提供内建的依赖解决，因此可能并不会在依赖配置文件（如Maven的pom.xml）显式看到 spring-data-rest-webmv的依赖配置，这就是为什么官方公告还提及Spring Boot和Spring Data的缘故。\u003c/p\u003e\u003cp\u003e漏洞触发条件：网站使用Spring Data REST提供REST Web服务，版本在受影响范围内。\u003c/p\u003e\u003cp\u003e修复建议：及时升级。\u003c/p\u003e\u003ch2 id=\"参考链接\"\u003e参考链接\u003c/h2\u003e\u003col\u003e\u003cli\u003e\u003ca href=\"https://pivotal.io/security/cve-2017-8046\"\u003ehttps://pivotal.io/security/cve-2017-8046\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45\"\u003ehttps://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"http://projects.spring.io/spring-data-rest/\"\u003ehttp://projects.spring.io/spring-data-rest/\u003c/a\u003e\u003c/li\u003e\u003cli\u003e\u003ca href=\"https://tools.ietf.org/html/rfc6902\"\u003ehttps://tools.ietf.org/html/rfc6902\u003c/a\u003e\u003c/li\u003e\u003c/ol\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2017-09-29T00:00:00Z",
  "Author": "soulteary@gmail.com"
}