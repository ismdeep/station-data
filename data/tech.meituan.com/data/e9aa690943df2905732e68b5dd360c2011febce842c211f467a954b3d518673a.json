{
  "Source": "tech.meituan.com",
  "Title": "RestQL：现代化的 API 开发方式",
  "Link": "https://tech.meituan.com/2016/08/12/koa-restql.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003cblockquote\u003e\u003cp\u003ekoa-restql 已经在 \u003ca href=\"https://github.com/Meituan-Dianping/koa-restql\"\u003egithub\u003c/a\u003e 开源并在 \u003ca href=\"https://www.npmjs.com/package/koa-restql\"\u003enpm\u003c/a\u003e 发布。感兴趣的同学可以前往围观一下。欢迎 Pull Request，同时热烈欢迎 Star。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e在现代的业务系统中，后端开发工作基本上可以被拆分为三项：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003e接口鉴权\u003c/strong\u003e。例如判断是不是当前系统的用户，以及该用户是否有权限访问接口。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e与其他系统的交互\u003c/strong\u003e。例如调用第三方的服务，或内部搭建的其他服务。\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e数据操作\u003c/strong\u003e。基本上所有需要持久化存储的系统都会在这项工作上耗费大量时间。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e本文将介绍如何利用 RestQL 来非常有效地减少「数据操作」相关的工作量。\u003c/p\u003e\u003ch2 id=\"现状与挑战\"\u003e现状与挑战\u003c/h2\u003e\u003cp\u003e我们先来做个假设。\u003c/p\u003e\u003cul\u003e\u003cli\u003e假设系统中有 60 张表，每张表对应的接口都要有四种 CRUD 的 API。那么就需要后端工程师写\u003ccode\u003e60 * 4 = 240\u003c/code\u003e个API。\u003c/li\u003e\u003cli\u003e假设上述 60 张表中，40 张表存的是资源类的数据，其余 20 张表为关系类的数据，也就是说每张表和 20 张表都要进行关联，每个关联也需要四种 CRUD 操作，那么又要增加\u003ccode\u003e40 * 20 * 4 = 3200\u003c/code\u003e个API。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e所以在上述假设场景中，后端工程师要编写 3200 + 240 = 3440 个 API。而且这还不是全部，假如后端代码需要 100% 的测试覆盖，那么工程师们就要写至少 3440 个测试！\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e60 张表 = 3440 个 API + 3440 个单元测试\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e众所周知，数据操作 API 的实现过程基本上是重复的，有的同学甚至认为这是低端的，体现不出工程师价值的工作，纯粹的「体力活」。但是却没有一个能真正解放生产力的方案。\u003c/p\u003e\u003ch2 id=\"解决思路\"\u003e解决思路\u003c/h2\u003e\u003cp\u003e尽管我们把数据库抽象成了「关系型」数据库，把操作数据的命令抽象成了 SQL ，同时我们也有了 MySQL 客户端，甚至是 sequelize 这种非常方便的库，也有「RESTful」API 命名规则，但是接口的实现从来都是需要工程师们自己用手敲出来的。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e如果说我看得比别人远，那是因为我站在巨人的肩膀上。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e所以我们在现有的技术基础上再抽象，把已有的东西重新组合起来，拼装成一个新的工具，帮助工程师从「体力活」中解脱出来，解放生产力。\u003c/p\u003e\u003ch3 id=\"什么样的工具\"\u003e什么样的工具\u003c/h3\u003e\u003cp\u003e最开始的时候，我们最先需要明确的问题就是：「我们需要什么样的工具？」或者说「这种工具要帮我们解决什么问题？」。\u003c/p\u003e\u003cp\u003e实际上我们从刚才的假设中，已经可以得出结论：我们希望有一个工具可以让工程师免于编写数据操作 API，\u003cstrong\u003e\u003cem\u003e把数据库操作直接映射到 HTTP RESTful API 上\u003c/em\u003e\u003c/strong\u003e。\u003c/p\u003e\u003ch2 id=\"调用方式\"\u003e调用方式\u003c/h2\u003e\u003ch3 id=\"如何请求\"\u003e如何请求\u003c/h3\u003e\u003cp\u003e为了解释「如何请求」，我们先从一些公认的规则出发，举一个例子，然后再从例子中抽象出一些规则。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e：为了更便于理解，我们把所有的命名从客户端一直穿透到数据库，所以请不要纠结于我们在定义一个 API 时名词单复数的问题。\u003c/p\u003e\u003ch4 id=\"基本用例\"\u003e基本用例\u003c/h4\u003e\u003cp\u003e几乎所有的系统都会有一个用户表（user）。根据 RESTful 规则的约定，我们应该把访问 user 表的 API 路径定义为 \u003ccode\u003e/user\u003c/code\u003e，并把 CRUD 的访问方法映射到 HTTP 协议中的四种方法：\u003ccode\u003eGET\u003c/code\u003e、\u003ccode\u003ePOST\u003c/code\u003e、\u003ccode\u003ePUT\u003c/code\u003e、\u003ccode\u003eDELETE\u003c/code\u003e。\u003c/p\u003e\u003cp\u003e比如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eGET /user\u003c/code\u003e：获取用户列表，应该返回一个数组。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eGET /user/:id\u003c/code\u003e：获取指定的用户，应该返回一个对象。\u003c/li\u003e\u003cli\u003e\u003ccode\u003ePOST /user\u003c/code\u003e：创建一个用户，应该返回被存储的对象，状态码应该为 201(Created)。\u003c/li\u003e\u003cli\u003e\u003ccode\u003ePUT /user\u003c/code\u003e：修改一个用户的信息，应该返回修改后的对象。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eDELETE /user/:id\u003c/code\u003e：删除一个用户，状态码应该为 204(No Content)。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e如果 user 表有一个关系表 feed，那么我们的路径就会再复杂一点：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eGET /user/:id/feed\u003c/code\u003e 或 \u003ccode\u003eGET /feed?user_id=:id\u003c/code\u003e：获取某个用户的帖子，应该返回一个数组。\u003c/li\u003e\u003cli\u003e\u003ccode\u003eGET /user/:id/feed/:feed_id\u003c/code\u003e 或 \u003ccode\u003eGET /feed/:id\u003c/code\u003e：获取指定的帖子，应该返回一个对象。\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e上述的例子中还会衍生出其他的数据操作，不仅仅只有 \u003ccode\u003eGET\u003c/code\u003e，这里不一一列举了。\u003c/p\u003e\u003ch4 id=\"抽象出规则\"\u003e抽象出规则\u003c/h4\u003e\u003cp\u003e上一节中，列举了要提供一个表的数据访问 API，大概要实现哪些路由。从这些枚举中，可以找出其中的规律，总结出一套规则。最终我们在「\u003cstrong\u003e把能实现的路由，全部实现\u003c/strong\u003e」的原则基础上，开发了 RestQL 的 koa 版本。\u003c/p\u003e\u003cp\u003e支持的 HTTP 方法：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eHTTP verb\u003c/th\u003e\u003cth\u003eCRUD\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eGET\u003c/td\u003e\u003ctd\u003eRead\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePOST\u003c/td\u003e\u003ctd\u003eCreate\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePUT\u003c/td\u003e\u003ctd\u003eCreate/Update\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eDELETE\u003c/td\u003e\u003ctd\u003eDelete\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e支持的带有 body 的 HTTP 方法：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003eHTTP verb\u003c/th\u003e\u003cth\u003eList\u003c/th\u003e\u003cth\u003eSingle\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ePOST\u003c/td\u003e\u003ctd\u003eArray/Object\u003c/td\u003e\u003ctd\u003e×\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePUT\u003c/td\u003e\u003ctd\u003eArray/Object\u003c/td\u003e\u003ctd\u003eObject\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e\u003cstrong\u003e说明\u003c/strong\u003e：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eList\u003c/code\u003e 路径为返回值为数组的路径，包括：\u003cul\u003e\u003cli\u003e\u003ccode\u003e/resource\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003e/resource/:id/association\u003c/code\u003e, association 为 \u003ccode\u003e1:n\u003c/code\u003e 关系\u003c/li\u003e\u003cli\u003e\u003ccode\u003e/resource/:id/association\u003c/code\u003e, association 为 \u003ccode\u003en:m\u003c/code\u003e 关系\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003eSingle\u003c/code\u003e 路径为返回值为单个对象的路径，包括：\u003cul\u003e\u003cli\u003e\u003ccode\u003e/resource/:id\u003c/code\u003e\u003c/li\u003e\u003cli\u003e\u003ccode\u003e/resource/:id/association\u003c/code\u003e, association 为 \u003ccode\u003e1:1\u003c/code\u003e 关系\u003c/li\u003e\u003cli\u003e\u003ccode\u003e/resource/:id/association/:id\u003c/code\u003e, association 为 \u003ccode\u003e1:n\u003c/code\u003e 关系\u003c/li\u003e\u003cli\u003e\u003ccode\u003e/resource/:id/association/:id\u003c/code\u003e, association 为 \u003ccode\u003en:m\u003c/code\u003e 关系\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"如何使用\"\u003e如何使用\u003c/h3\u003e\u003cp\u003e我们已经开源了 koa-restql，koa 应用开发者可以通过 npm 安装它：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-sh\"\u003enpm install koa-restql\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e然后在 koa 应用的代码中引用 RestQL：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003econst koa       = require(\u0026#39;koa\u0026#39;)\nconst RestQL    = require(\u0026#39;koa-restql\u0026#39;)\n\nlet app = koa()\n// Build APIs from `sequelize.models`\nlet restql = new RestQL(sequelize.models)\napp.use(restql.routes())\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"常见问题\"\u003e常见问题\u003c/h2\u003e\u003ch3 id=\"修改参数\"\u003e修改参数\u003c/h3\u003e\u003cp\u003e用户可以通过\u003ccode\u003equerystring\u003c/code\u003e来修改参数。强烈建议使用\u003ccode\u003eqs\u003c/code\u003e对 querystring 进行解析，例如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eqs.stringify({a: 1, b:2}) // =\u0026gt; a=1\u0026amp;b=2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eRestQL 中的\u003ccode\u003equerystring\u003c/code\u003e仅有 3 条规则：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e所有不以\u003ccode\u003e_\u003c/code\u003e开头的键，都会被放进\u003ccode\u003esequelize#query()\u003c/code\u003e的\u003ccode\u003ewhere\u003c/code\u003e参数中。例如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// query\n{\n  name: \u0026#34;Li Xin\u0026#34;\n}\n// option for sequelize\n{\n  where: {\n    name: \u0026#34;Li Xin\u0026#34;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e所有以\u003ccode\u003e_\u003c/code\u003e开头的键，都会被放进\u003ccode\u003esequelize#query()\u003c/code\u003e的参数中，和\u003ccode\u003ewhere\u003c/code\u003e保持平级。例如：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// query\n{\n  _limit: 10\n}\n// option for sequelize\n{\n  limit: 10\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e当需要使用关系时，可以用关系名称的字符串代替关系对象传入。例如需要使用\u003ccode\u003einclude\u003c/code\u003e时：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003e// query\n{\n  _include: [\u0026#39;friends\u0026#39;]\n}\n// option for sequelize\n{\n  include: [\n    models.user.association.friends\n  ]\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"访问控制\"\u003e访问控制\u003c/h3\u003e\u003cp\u003e通常来说，我们有两种方法实现访问控制：\u003c/p\u003e\u003ch4 id=\"通过中间件\"\u003e通过中间件\u003c/h4\u003e\u003cp\u003e在 koa 应用挂载 RestQL 的 router 之前，可以实现一个鉴权中间件，控制用户的访问权限：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003eapp.use(authorizeMiddleware)\napp.use(restql.routes())\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8ee4a4df.jpeg\" alt=\"Authorize Middleware\"/\u003e\u003c/p\u003e\u003ch4 id=\"通过-restql-参数\"\u003e通过 restql 参数\u003c/h4\u003e\u003cp\u003e在使用\u003ccode\u003esequelize\u003c/code\u003e定义关联时，我们可以设定\u003ccode\u003erestql\u003c/code\u003e参数，实现访问控制。例如：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e禁止通过\u003ccode\u003erestql\u003c/code\u003e访问关联：\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003emodels.user.hasOne(\n  models.privacy,\n  {\n    restql: {\n      ignore: true\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e禁止通过\u003ccode\u003erestql\u003c/code\u003e使用指定的 HTTP 方法访问关联\u003c/p\u003e\u003cpre\u003e\u003ccode class=\"language-js\"\u003emodels.user.hasOne(\n  models.privacy,\n  {\n    restql: {\n      ignore: [\u0026#39;get\u0026#39;]\n    }\n  }\n)\n\u003c/code\u003e\u003c/pre\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch4 id=\"其他语言-框架\"\u003e其他语言/框架\u003c/h4\u003e\u003cp\u003e目前我们仅实现了基于\u003ccode\u003enode\u003c/code\u003e和\u003ccode\u003ekoa\u003c/code\u003e的版本，还没有其他语言/框架的实现版本。欢迎开发者提交其他语言/框架的实现到 \u003ca href=\"https://github.com/RestQL\"\u003eRestQL 组\u003c/a\u003e。\u003c/p\u003e\u003ch2 id=\"参考链接\"\u003e参考链接\u003c/h2\u003e\u003cul\u003e\u003cli\u003eGitHub, \u003ca href=\"https://github.com/koajs/koa\"\u003ehttps://github.com/koajs/koa\u003c/a\u003e\u003c/li\u003e\u003cli\u003eGitHub, \u003ca href=\"https://github.com/sequelize/sequelize\"\u003ehttps://github.com/sequelize/sequelize\u003c/a\u003e\u003c/li\u003e\u003cli\u003eGitHub, [meituan-dianping/koa-restql][\u003ca href=\"https://github.com/Meituan-Dianping/koa-restql\"\u003ehttps://github.com/Meituan-Dianping/koa-restql\u003c/a\u003e]\u003c/li\u003e\u003c/ul\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2016-08-12T00:00:00Z",
  "Author": "soulteary@gmail.com"
}