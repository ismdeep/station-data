{
  "Source": "tech.meituan.com",
  "Title": "Android Hook技术防范漫谈",
  "Link": "https://tech.meituan.com/2018/02/02/android-anti-hooking.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"背景\"\u003e背景\u003c/h2\u003e\u003cp\u003e当下，数据就像水、电、空气一样无处不在，说它是“21世纪的生产资料”一点都不夸张，由此带来的是，各行业对于数据的争夺热火朝天。随着互联网和数据的思维深入人心，一些灰色产业悄然兴起，数据贩子、爬虫、外挂软件等等也接踵而来，互联网行业中各公司竞争对手之间不仅业务竞争十分激烈，黑科技的比拼也越发重要。随着移动互联网的兴起，爬虫和外挂也从单一的网页转向了App，其中利用Android平台下Dalvik模式中的\u003ccode\u003eXposed Installer\u003c/code\u003e和\u003ccode\u003eCydia Substrate\u003c/code\u003e框架对App的函数进行Hook这一招，堪称老牌经典。\u003c/p\u003e\u003cp\u003e接下来，本文将分别介绍针对这两种框架的防护技术。\u003c/p\u003e\u003ch2 id=\"xposed-installer\"\u003eXposed Installer\u003c/h2\u003e\u003ch3 id=\"原理\"\u003e原理\u003c/h3\u003e\u003ch4 id=\"zygote\"\u003eZygote\u003c/h4\u003e\u003cp\u003e在Android系统中App进程都是由Zygote进程“孵化”出来的。Zygote进程在启动时会创建一个虚拟机实例，每当它“孵化”一个新的应用程序进程时，都会将这个Dalvik虚拟机实例复制到新的App进程里面去，从而使每个App进程都有一个独立的Dalvik虚拟机实例。\u003c/p\u003e\u003cp\u003eZygote进程在启动的过程中，除了会创建一个虚拟机实例之外还会将\u003ccode\u003eJava Rumtime\u003c/code\u003e加载到进程中并注册一些Android核心类的JNI（Java Native Interface，Java本地接口）方法。一个App进程被Zygote进程孵化出来的时候，不仅会获得Zygote进程中的虚拟机实例拷贝，还会与Zygote进程一起共享\u003ccode\u003eJava Rumtime\u003c/code\u003e，也就是可以将\u003ccode\u003eXposedBridge.jar\u003c/code\u003e这个Jar包加载到每一个Android App进程中去。安装\u003ccode\u003eXposed Installer\u003c/code\u003e之后，系统\u003ccode\u003eapp_process\u003c/code\u003e将被替换，然后利用Java的\u003ccode\u003eReflection\u003c/code\u003e机制覆写内置方法，实现功能劫持。下面我们来看一下细节。\u003c/p\u003e\u003ch4 id=\"hook和replace\"\u003eHook和Replace\u003c/h4\u003e\u003cp\u003e\u003ccode\u003eXposed Installer\u003c/code\u003e框架中真正起作用的是对方法的Hook和Replace。在Android系统启动的时候，Zygote进程加载\u003ccode\u003eXposedBridge.jar\u003c/code\u003e，将所有需要替换的Method通过\u003ccode\u003eJNI\u003c/code\u003e方法\u003ccode\u003ehookMethodNative\u003c/code\u003e指向Native方法\u003ccode\u003exposedCallHandler\u003c/code\u003e，这个方法再通过调用\u003ccode\u003ehandleHookedMethod\u003c/code\u003e这个Java方法来调用被劫持的方法转入Hook逻辑。\u003c/p\u003e\u003cp\u003e上面提到的\u003ccode\u003ehookMethodNative\u003c/code\u003e是\u003ccode\u003eXposedBridge.jar\u003c/code\u003e中的私有的本地方法，它将一个方法对象作为传入参数并修改Dalvik虚拟机中对于该方法的定义，把该方法的类型改变为Native并将其实现指向另外一个B方法。\u003c/p\u003e\u003cp\u003e换言之，当调用那个被Hook的A方法时，其实调用的是B方法，调用者是不知道的。在hookMethodNative的实现中，会调用\u003ccode\u003eXposedBridge.jar\u003c/code\u003e中的\u003ccode\u003ehandleHookedMethod\u003c/code\u003e这个方法来传递参数。\u003ccode\u003ehandleHookedMethod\u003c/code\u003e这个方法类似于一个统一调度的Dispatch例程，其对应的底层的C++函数是\u003ccode\u003exposedCallHandler\u003c/code\u003e。而\u003ccode\u003ehandleHookedMethod\u003c/code\u003e实现里面会根据一个全局结构\u003ccode\u003ehookedMethodCallbacks\u003c/code\u003e来选择相应的Hook函数并调用他们的\u003ccode\u003ebefore\u003c/code\u003e和\u003ccode\u003eafter\u003c/code\u003e函数，当多模块同时Hook一个方法的时候\u003ccode\u003eXposed\u003c/code\u003e会自动根据\u003ccode\u003eModule\u003c/code\u003e的优先级来排序。\u003c/p\u003e\u003cp\u003e调用顺序如下：A.before -\u0026gt; B.before -\u0026gt; original method -\u0026gt; B.after -\u0026gt; A.after。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/73b15237.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"检测\"\u003e检测\u003c/h3\u003e\u003cp\u003e在做Android App的安全防御中检测点众多，\u003ccode\u003eXposed Installer\u003c/code\u003e检测是必不可少的一环。对于Xposed框架的防御总体上分为两层：Java层和Native层。\u003c/p\u003e\u003ch4 id=\"java层检测\"\u003eJava层检测\u003c/h4\u003e\u003cp\u003e需要说明的是，Java层的检测基本只能检测出基础的\u003ccode\u003eXposed Installer\u003c/code\u003e框架，而不能防护其对App内方法的Hook，如果框架中带有反检测则Java层检测大多不起作用。\u003c/p\u003e\u003cp\u003e下面列出Java层的检测点，仅供参考。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e① 通过PackageManager查看安装列表\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e最简单的检测，我们调用Android提供的\u003ccode\u003ePackageManager\u003c/code\u003e的API来遍历系统中App的安装情况来辨别是否有安装\u003ccode\u003eXposed Installer\u003c/code\u003e相关的软件包。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ePackageManager packageManager = context.getPackageManager();\nList applicationInfoList = packageManager.getInstalledApplications(PackageManager.GET_META_DATA);\nfor (ApplicationInfo applicationInfo: applicationInfoList) {\n    if (applicationInfo.packageName.equals(\u0026#34;de.robv.android.xposed.installer\u0026#34;)) {\n        // is Xposed TODO... }\n    }\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通常情况下使用\u003ccode\u003eXposed Installer\u003c/code\u003e框架都会屏蔽对其的检测，即Hook掉\u003ccode\u003ePackageManager的getInstalledApplications\u003c/code\u003e方法的返回值，以便过滤掉\u003ccode\u003ede.robv.android.xposed.installer\u003c/code\u003e来躲避这种检测。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e② 自造异常读取栈\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e\u003ccode\u003eXposed Installer\u003c/code\u003e框架对每个由Zygote孵化的App进程都会介入，因此在程序方法异常栈中就会出现\u003ccode\u003eXposed\u003c/code\u003e相关的“身影”，我们可以通过自造异常\u003ccode\u003eCatch\u003c/code\u003e来读取异常堆栈的形式，用以检查其中是否存在\u003ccode\u003eXposed\u003c/code\u003e的调用方法。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003etry {\n    throw new Exception(\u0026#34;blah\u0026#34;);\n} catch(Exception e) {\n    for (StackTraceElement stackTraceElement: e.getStackTrace()) {\n        // stackTraceElement.getClassName() stackTraceElement.getMethodName() 是否存 在Xposed\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cpre\u003e\u003ccode\u003eE/GEnvironment: no such table: preference (code 1): while compiling: SELECT keyguard_show_livewallpaper FROM preference\n...\nat com.meituan.test.extpackage.ExtPackageManager.checkUpdate(ExtPackageManager.java:127)\nat com.meituan.test.MiFGService$1.run(MiFGService.java:41)\nat android.os.Looper.loop(Looper.java:136)\nat android.app.ActivityThread.main(ActivityThread.java:5072)\nat java.lang.reflect.Method.invokeNative(Native Method)\nat java.lang.reflect.Method.invoke(Method.java:515)\n...\nat com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:793)\nat com.android.internal.os.ZygoteInit.main(ZygoteInit.java:609)\nat de.robv.android.xposed.XposedBridge.main(XposedBridge.java:132) //发现Xposed模块\nat dalvik.system.NativeStart.main(Native Method)\n\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cstrong\u003e③ 检查关键Java方法被变为Native JNI方法\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e当一个Android App中的\u003ccode\u003eJava\u003c/code\u003e方法被莫名其妙地变成了\u003ccode\u003eNative JNI\u003c/code\u003e方法，则非常有可能被\u003ccode\u003eXposed Hook\u003c/code\u003e了。由此可得，检查关键方法是不是变成\u003ccode\u003eNative JNI\u003c/code\u003e方法，也可以检测是否被Hook。\u003c/p\u003e\u003cp\u003e通过反射调用\u003ccode\u003eModifier.isNative(method.getModifiers())\u003c/code\u003e方法可以校验方法是不是\u003ccode\u003eNative JNI\u003c/code\u003e方法，Xposed同样可以篡改\u003ccode\u003eisNative\u003c/code\u003e这个方法的返回值。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e④ 反射读取XposedHelper类字段\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e通过反射遍历\u003ccode\u003eXposedHelper\u003c/code\u003e类中的\u003ccode\u003efieldCache\u003c/code\u003e、\u003ccode\u003emethodCache\u003c/code\u003e、\u003ccode\u003econstructorCache\u003c/code\u003e变量，读取HashMap缓存字段，如字段项的key中包含App中唯一或敏感方法等，即可认为有\u003ccode\u003eXposed\u003c/code\u003e注入。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/aad203b3.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003eboolean methodCache = CheckHook(clsXposedHelper, \u0026#34;methodCache\u0026#34;, keyWord);\n\nprivate static boolean CheckHook(Object cls, String filedName, String str) {\n    boolean result = false;\n    String interName;\n    Set keySet;\n    try {\n        Field filed = cls.getClass().getDeclaredField(filedName);\n        filed.setAccessible(true);\n        keySet = filed.get(cls)).keySet();\n        if (!keySet.isEmpty()) {\n            for (Object aKeySet: keySet) {\n                interName = aKeySet.toString().toLowerCase();\n                if (interName.contains(\u0026#34;meituan\u0026#34;) || interName.contains(\u0026#34;dianping\u0026#34;) ) {\n                    result = true;\n                    break;\n                \t} \n                }\n            }\n\t\t...\n    return result;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"native层检测\"\u003eNative层检测\u003c/h4\u003e\u003cp\u003e由上文可知，无论在Java层做何种检测，Xposed都可以通过Hook相关的API并返回指定的结果来绕过检测，只要有方法就可以被Hook。如果仅在Java层检测就显得很徒劳，为了有效提搞检测准确率，就须做到Java和Native层同时检测。每个App在系统中都有对应的加载库列表，这些加载库列表在\u003ccode\u003e/proc/\u003c/code\u003e下对应的\u003ccode\u003epid/maps\u003c/code\u003e文件中描述，在Native层读取\u003ccode\u003e/proc/self/maps\u003c/code\u003e文件不失为检测Xposed Installer的有效办法之一。由于\u003ccode\u003eXposed Installer\u003c/code\u003e通常只能Hook Java层，因此在Native层使用C来解析\u003ccode\u003e/proc/self/maps\u003c/code\u003e文件，搜检App自身加载的库中是否存在\u003ccode\u003eXposedBridge.jar\u003c/code\u003e、相关的Dex、Jar和So库等文件。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003ebool is_xposed()\n{\n   bool rel = false;\n   FILE *fp = NULL;\n   char* filepath = \u0026#34;/proc/self/maps\u0026#34;;\n   ...\n   string xp_name = \u0026#34;XposedBridge.jar\u0026#34;;\n   fp = fopen(filepath,\u0026#34;r\u0026#34;)) \n   while (!feof(fp))                                 \n   {\n       fgets(strLine,BUFFER_SIZE,fp);                    \n       origin_str = strLine;\n       str = trim(origin_str);\n       if (contain(str,xp_name))\n       {\n           rel = true; //检测到Xposed模块\n           break;\n       }\n   }\n\t...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"cydia-substrate\"\u003eCydia Substrate\u003c/h2\u003e\u003ch3 id=\"原理-1\"\u003e原理\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eCydia Substrate\u003c/code\u003e注入Hook的一个典型流程如下图所示，在Java层配置注入的关键So库\u003ccode\u003elibsubstrate.so\u003c/code\u003e和\u003ccode\u003elibsubstratedvm.so\u003c/code\u003e。考虑到Java层检测强度太低，Substrate的检测主要在Native层来实现。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/f95f9fb3.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"检测-1\"\u003e检测\u003c/h3\u003e\u003ch4 id=\"动态加载式检测\"\u003e动态加载式检测\u003c/h4\u003e\u003cp\u003e读取\u003ccode\u003e/proc/self/maps\u003c/code\u003e，列出了App中所有加载的文件。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/0f11bb96.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e上图为\u003ccode\u003eCydia Substrate\u003c/code\u003e在Android 4.4上注入后的进程maps表，其中\u003ccode\u003elibsubstrate.so\u003c/code\u003e和\u003ccode\u003elibsubstrate-dvm.so\u003c/code\u003e两个文件为Substrate必载入文件。通过\u003ccode\u003eIDA Pro\u003c/code\u003e分析对其分析。\u003c/p\u003e\u003cp\u003e先来看\u003ccode\u003elibsubstrate-dvm.so\u003c/code\u003e的导出表，共有9个函数导出。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/b316c7be.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当进程maps表中出现\u003ccode\u003elibsubstrate-dvm.so\u003c/code\u003e，可以尝试去load该so文件并调用\u003ccode\u003eMSJavaHookMethod\u003c/code\u003e方法，它会返回该方法的地址即判定为恶意模块（第三方程序）。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/386774e9.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003evoid* lookup_symbol(char* libraryname,char* symbolname)  \n{\n    void *imagehandle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW);\n    if (imagehandle != NULL){\n        void * sym = dlsym(imagehandle, symbolname);\n        if (sym != NULL){\n            return sym; //发现Cydia Substrate相关模块\n            }\n      ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该方式基于载入库文件的文件名或文件路径和导出函数来判断是否为恶意模块，如果完全依赖此方式来判断可能会误判，但也不失为检测方式的一个点。\u003c/p\u003e\u003ch4 id=\"基于方法特征码检测\"\u003e基于方法特征码检测\u003c/h4\u003e\u003cp\u003e特征码即用来判断某段数据属于哪个计算机字段。在非Root环境下一般一个正常App在启动时候，系统会调度相关大小的内存、空间给App使用，此时App的运行环境内产生的数据、内存、存储等是独立于其它App的（即独立运行在沙箱中）。因为处于运行沙箱环境中的进程对沙箱的内存有最高读写权限，当我们的App进程被恶意模块附加或注入时，就可以通过对当前进程的PID所对应的maps中加载的模块进行合法校验。这里的模块校验我们可以采取对单个模块内容取样来判断是否为恶意模块，这种方式被定义为“基于方法的特征码检测”。\u003c/p\u003e\u003cp\u003e下面对一段程序段中\u003ccode\u003eOpcodeSample\u003c/code\u003e方法来提取特征码。\u003c/p\u003e\u003cp\u003e方法原型：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e#define  LOGD(fmt, args...)  __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG, fmt, ##args)    \nvoid OpcodeSample(int a ,int b){  \n    int c,d,e;\n    c = a + b;\n    d = a * b;\n    e = a / b;\n    LOGD(\u0026#34;Hello It\u0026#39;s c !%s\\n\u0026#34;, c);  \n    LOGD(\u0026#34;Hello It\u0026#39;s d !%s\\n\u0026#34;, d);  \n    LOGD(\u0026#34;Hello It\u0026#39;s e !%s\\n\u0026#34;, e);  \n    return;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过\u003ccode\u003eIDA Pro\u003c/code\u003e对其分析。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/de414efd.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e左侧红色方框代表为\u003ccode\u003eOpcodeSample\u003c/code\u003e方法的操作码，右边为操作码对应ARM平台的指令集。我们要在左侧的操作码中取出一段作为\u003ccode\u003eOpcodeSample\u003c/code\u003e的定位特征码，选用\u003ccode\u003e__android_log_print\u003c/code\u003e方法调用指令集上下文，来确定特征码。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e第一次取样：\u0026#34;03 20 31 46 42 46 FF F7 ?? EA\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/7e5b131d.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/cfcd8880.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过第一次取样，查找结果有三处相似，再进一步分析。这次我们加入一个常量取样：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e第二次取样：\u0026#34;7E 44 ?? ?? F8 44 03 20 31 46 42 46 FF F7 ?? EA\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/e2acf820.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e继而得出唯一特征码，到此，我们对特征码方法取样有了初步的了解。下面来把它转为实用的技能——动态加载式检测+特征码结合。\u003c/p\u003e\u003cp\u003e我们对\u003ccode\u003elibsubstrate-dvm.so\u003c/code\u003e中导出函数\u003ccode\u003eMSJavaHookMethod\u003c/code\u003e来精准定位。\u003c/p\u003e\u003cp\u003e\u003ccode\u003eIDA PRO\u003c/code\u003e导出函数表如图：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/acda9a8e.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/1e1f4e26.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/50f8e492.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e第三次取样：\u0026#34;55 57 56 53 E8 CC 14 ?? ?? 81 C3 DB ?? ?? ?? 8D 64 ?? ?? 8B 83 F4 ?? ?? ??\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e\u003cimg src=\"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/d38f4f7b.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e以上即为对\u003ccode\u003eCydia Substrate\u003c/code\u003e的注入检测识别，通过检测\u003ccode\u003e/proc/self/maps\u003c/code\u003e下的加载\u003ccode\u003eso\u003c/code\u003e库列表得到各个库文件绝度路径，通过\u003ccode\u003efopen\u003c/code\u003e函数将\u003ccode\u003eso\u003c/code\u003e库的内容以16进制读进来放在内存里面进行规则比对，采用字符串模糊查找来检测是否命中黑名单中的方法特征码。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e在安全对抗领域，相比攻击方，防守方历来处于弱势的一方。上文所提到的\u003ccode\u003eXposed Installer\u003c/code\u003e和\u003ccode\u003eCydia Substrate\u003c/code\u003e的检测也仅仅是保障App安全的手段之一。App安全的防御不应仅仅依赖于此，应该构建起整体的安全防御闭环，尽可能在所有已知的可能攻击点都追加检测，再配合代码加固，将防御代码隐藏。遗憾的是App防御代码隐藏再深也终究会被破解，仅仅依赖于客户端的防御显然是不足的。移动互联网领域的整体安全防御应该是走端云结合协作之道，共同防御，方能在攻防对抗中占据优势地位。\u003c/p\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cul\u003e\u003cli\u003e礼赞，美团安全工程师，2016年11月加入美团。专注于二进制、移动端攻防相关工作，现负责美团Android移动安全组件的建设工作。\u003c/li\u003e\u003cli\u003e毅然，美团技术专家，2016年初加入美团。致力于美团配送App组的Android App crash解决工作、Android App性能优化、Android App反外挂、反爬虫。目前主导负责美团配送Android App移动安全相关建设。\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团集团安全部正在招募Web\u0026amp;二进制攻防、后台\u0026amp;系统开发、机器学习\u0026amp;算法等各路小伙伴。\u003c/p\u003e\u003cp\u003e\u003cstrong\u003e我们想做的事情：\u003c/strong\u003e\u003c/p\u003e\u003cp\u003e构建一套基于海量IDC环境下，横跨网络层、虚拟化层、Server 软件层（内核态/用户态）、语言执行虚拟机层(JVM/Zend/JavaScript V8)、Web应用层、数据访问层(DAL)的，基于大数据+机器学习的全自动人机识别与安全事件感知系统。规模上对应美团全线业务的服务器，技术栈覆盖了几乎大多数云环境下的互联网应用，数据规模也将是很大的挑战。\u003c/p\u003e\u003cp\u003e此外我们还关注全球互联网领域在企业安全建设方面的最佳实践，努力构建类似于Google的内置式安全架构和纵深防御体系，对在安全和工程技术领域有所追求的同学来说应该是一个很好的机会。\u003c/p\u003e\u003cp\u003e如果你想加入我们，欢迎将简历发至邮箱zhaoyan17#meituan.com，具体职位信息点击“\u003ca href=\"http://company.freebuf.com/company/美团点评安全应急响应中心/#job\"\u003e岗位招聘\u003c/a\u003e”查看。\u003c/p\u003e\u003cp\u003e另外友情打个招聘：美团配送App团队，负责美团骑手、美团众包、美团跑腿等配送相关App的研发，涉及技术领域包括但不限于App的稳定性建设、App性能监控和优化、App动态化。对上述领域感兴趣的请联系 yulei10#meituan.com 。\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2018-02-02T00:00:00Z",
  "Author": "soulteary@gmail.com"
}