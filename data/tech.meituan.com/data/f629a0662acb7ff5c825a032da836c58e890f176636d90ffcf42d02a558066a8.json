{
  "Source": "tech.meituan.com",
  "Title": "从ReentrantLock的实现看AQS的原理及应用",
  "Link": "https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html",
  "Content": "\u003cdiv class=\"post-content\"\u003e\u003cdiv class=\"content\"\u003e\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\u003cp\u003eJava中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架。本文会从应用层逐渐深入到原理层，并通过ReentrantLock的基本特性和ReentrantLock与AQS的关联，来深入解读AQS相关独占锁的知识点，同时采取问答的模式来帮助大家理解AQS。由于篇幅原因，本篇文章主要阐述AQS中独占锁的逻辑和Sync Queue，不讲述包含共享锁和Condition Queue的部分（本篇文章核心为AQS原理剖析，只是简单介绍了ReentrantLock，感兴趣同学可以阅读一下ReentrantLock的源码）。\u003c/p\u003e\u003cp\u003e下面列出本篇文章的大纲和思路，以便于大家更好地理解：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/9d182d944e0889c304ef529ba50a4fcd205214.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"1-reentrantlock\"\u003e1 ReentrantLock\u003c/h2\u003e\u003ch3 id=\"1-1-reentrantlock特性概览\"\u003e1.1 ReentrantLock特性概览\u003c/h3\u003e\u003cp\u003eReentrantLock意思为可重入锁，指的是一个线程能够对一个临界资源重复加锁。为了帮助大家更好地理解ReentrantLock的特性，我们先将ReentrantLock跟常用的Synchronized进行比较，其特性如下（蓝色部分为本篇文章主要剖析的点）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/412d294ff5535bbcddc0d979b2a339e6102264.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e下面通过伪代码，进行更加直观的比较：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// **************************Synchronized的使用方式**************************\n// 1.用于代码块\nsynchronized (this) {}\n// 2.用于对象\nsynchronized (object) {}\n// 3.用于方法\npublic synchronized void test () {}\n// 4.可重入\nfor (int i = 0; i \u0026lt; 100; i++) {\n\tsynchronized (this) {}\n}\n// **************************ReentrantLock的使用方式**************************\npublic void test () throw Exception {\n\t// 1.初始化选择公平锁、非公平锁\n\tReentrantLock lock = new ReentrantLock(true);\n\t// 2.可用于代码块\n\tlock.lock();\n\ttry {\n\t\ttry {\n\t\t\t// 3.支持多种加锁方式，比较灵活; 具有可重入特性\n\t\t\tif(lock.tryLock(100, TimeUnit.MILLISECONDS)){ }\n\t\t} finally {\n\t\t\t// 4.手动释放锁\n\t\t\tlock.unlock()\n\t\t}\n\t} finally {\n\t\tlock.unlock();\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003ch3 id=\"1-2-reentrantlock与aqs的关联\"\u003e1.2 ReentrantLock与AQS的关联\u003c/h3\u003e\u003cp\u003e通过上文我们已经了解，ReentrantLock支持公平锁和非公平锁（关于公平锁和非公平锁的原理分析，可参考《\u003ca href=\"https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==\u0026amp;mid=2651749434\u0026amp;idx=3\u0026amp;sn=5ffa63ad47fe166f2f1a9f604ed10091\u0026amp;chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8\u0026amp;scene=38#wechat_redirect\"\u003e不可不说的Java“锁”事\u003c/a\u003e》），并且ReentrantLock的底层就是由AQS来实现的。那么ReentrantLock是如何通过公平锁和非公平锁与AQS关联起来呢？ 我们着重从这两者的加锁过程来理解一下它们与AQS之间的关系（加锁过程中与AQS的关联比较明显，解锁流程后续会介绍）。\u003c/p\u003e\u003cp\u003e非公平锁源码中的加锁流程如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock#NonfairSync\n\n// 非公平锁\nstatic final class NonfairSync extends Sync {\n\t...\n\tfinal void lock() {\n\t\tif (compareAndSetState(0, 1))\n\t\t\tsetExclusiveOwnerThread(Thread.currentThread());\n\t\telse\n\t\t\tacquire(1);\n\t\t}\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这块代码的含义为：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e若通过CAS设置变量State（同步状态）成功，也就是获取锁成功，则将当前线程设置为独占线程。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e若通过CAS设置变量State（同步状态）失败，也就是获取锁失败，则进入Acquire方法进行后续处理。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e第一步很好理解，但第二步获取锁失败后，后续的处理策略是怎么样的呢？这块可能会有以下思考：\u003c/p\u003e\u003cul\u003e\u003cli\u003e某个线程获取锁失败的后续流程是什么呢？有以下两种可能：\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e(1) 将当前线程获锁结果设置为失败，获取锁流程结束。这种设计会极大降低系统的并发度，并不满足我们实际的需求。所以就需要下面这种流程，也就是AQS框架的处理流程。\u003c/p\u003e\u003cp\u003e(2) 存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e对于问题1的第二种情况，既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e如果处于排队等候机制中的线程一直无法获取锁，还是需要一直等待吗，还是有别的策略来解决这一问题？\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e带着非公平锁的这些问题，再看下公平锁源码中获锁的方式：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock#FairSync\n\nstatic final class FairSync extends Sync {\n  ...  \n\tfinal void lock() {\n\t\tacquire(1);\n\t}\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看到这块代码，我们可能会存在这种疑问：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？\u003c/p\u003e\u003cp\u003e结合公平锁和非公平锁的加锁流程，虽然流程上有一定的不同，但是都调用了Acquire方法，而Acquire方法是FairSync和UnfairSync的父类AQS中的核心方法。\u003c/p\u003e\u003cp\u003e对于上边提到的问题，其实在ReentrantLock类源码中都无法解答，而这些问题的答案，都是位于Acquire方法所在的类AbstractQueuedSynchronizer中，也就是本文的核心——AQS。下面我们会对AQS以及ReentrantLock和AQS的关联做详细介绍（相关问题答案会在2.3.5小节中解答）。\u003c/p\u003e\u003ch2 id=\"2-aqs\"\u003e2 AQS\u003c/h2\u003e\u003cp\u003e首先，我们通过下面的架构图来整体了解一下AQS框架：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/82077ccf14127a87b77cefd1ccf562d3253591.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e上图中有颜色的为Method，无颜色的为Attribution。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e下面我们会从整体到细节，从流程到方法逐一剖析AQS框架，主要分析过程如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/d2f7f7fffdc30d85d17b44266c3ab05323338.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch3 id=\"2-1-原理概览\"\u003e2.1 原理概览\u003c/h3\u003e\u003cp\u003eAQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。\u003c/p\u003e\u003cp\u003eCLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。\u003c/p\u003e\u003cp\u003e主要原理图如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/7132e4cef44c26f62835b197b239147b18062.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003eAQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。\u003c/p\u003e\u003ch4 id=\"2-1-1-aqs数据结构\"\u003e2.1.1 AQS数据结构\u003c/h4\u003e\u003cp\u003e先来看下AQS中最基本的数据结构——Node，Node即为上面CLH变体队列中的节点。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/960271cf2b5c8a185eed23e98b72c75538637.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e解释一下几个方法和属性值的含义：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e方法和属性值\u003c/th\u003e\u003cth\u003e含义\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003ewaitStatus\u003c/td\u003e\u003ctd\u003e当前节点在队列中的状态\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ethread\u003c/td\u003e\u003ctd\u003e表示处于该节点的线程\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprev\u003c/td\u003e\u003ctd\u003e前驱指针\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003epredecessor\u003c/td\u003e\u003ctd\u003e返回前驱节点，没有的话抛出npe\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003enextWaiter\u003c/td\u003e\u003ctd\u003e指向下一个处于CONDITION状态的节点（由于本篇文章不讲述Condition Queue队列，这个指针不多介绍）\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003enext\u003c/td\u003e\u003ctd\u003e后继指针\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e线程两种锁的模式：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e模式\u003c/th\u003e\u003cth\u003e含义\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eSHARED\u003c/td\u003e\u003ctd\u003e表示线程以共享的模式等待锁\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eEXCLUSIVE\u003c/td\u003e\u003ctd\u003e表示线程正在以独占的方式等待锁\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003ewaitStatus有下面几个枚举值：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e枚举\u003c/th\u003e\u003cth\u003e含义\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003e0\u003c/td\u003e\u003ctd\u003e当一个Node被初始化的时候的默认值\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCANCELLED\u003c/td\u003e\u003ctd\u003e为1，表示线程获取锁的请求已经取消了\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCONDITION\u003c/td\u003e\u003ctd\u003e为-2，表示节点在等待队列中，节点线程等待唤醒\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003ePROPAGATE\u003c/td\u003e\u003ctd\u003e为-3，当前线程处在SHARED情况下，该字段才会使用\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSIGNAL\u003c/td\u003e\u003ctd\u003e为-1，表示线程已经准备好了，就等资源释放了\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch4 id=\"2-1-2-同步状态state\"\u003e2.1.2 同步状态State\u003c/h4\u003e\u003cp\u003e在了解数据结构后，接下来了解一下AQS的同步状态——State。AQS中维护了一个名为state的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate volatile int state;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e下面提供了几个访问这个字段的方法：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e方法名\u003c/th\u003e\u003cth\u003e描述\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eprotected final int getState()\u003c/td\u003e\u003ctd\u003e获取State的值\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected final void setState(int newState)\u003c/td\u003e\u003ctd\u003e设置State的值\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected final boolean compareAndSetState(int expect, int update)\u003c/td\u003e\u003ctd\u003e使用CAS方式更新State\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e这几个方法都是Final修饰的，说明子类中无法重写它们。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/27605d483e8935da683a93be015713f331378.png\" alt=\"\"/\u003e\n\u003cimg src=\"https://p0.meituan.net/travelcube/3f1e1a44f5b7d77000ba4f9476189b2e32806.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e对于我们自定义的同步工具，需要自定义获取同步状态和释放状态的方式，也就是AQS架构图中的第一层：API层。\u003c/p\u003e\u003ch2 id=\"2-2-aqs重要方法与reentrantlock的关联\"\u003e2.2 AQS重要方法与ReentrantLock的关联\u003c/h2\u003e\u003cp\u003e从架构图中可以得知，AQS提供了大量用于自定义同步器实现的Protected方法。自定义同步器实现的相关方法也只是为了通过修改State字段来实现多线程的独占模式或者共享模式。自定义同步器需要实现以下方法（ReentrantLock需要实现的方法如下，并不是全部）：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e方法名\u003c/th\u003e\u003cth\u003e描述\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eprotected boolean isHeldExclusively()\u003c/td\u003e\u003ctd\u003e该线程是否正在独占资源。只有用到Condition才需要去实现它。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected boolean tryAcquire(int arg)\u003c/td\u003e\u003ctd\u003e独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected boolean tryRelease(int arg)\u003c/td\u003e\u003ctd\u003e独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected int tryAcquireShared(int arg)\u003c/td\u003e\u003ctd\u003e共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eprotected boolean tryReleaseShared(int arg)\u003c/td\u003e\u003ctd\u003e共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003cp\u003e一般来说，自定义同步器要么是独占方式，要么是共享方式，它们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。ReentrantLock是独占锁，所以实现了tryAcquire-tryRelease。\u003c/p\u003e\u003cp\u003e以非公平锁为例，这里主要阐述一下非公平锁与AQS之间方法的关联之处，具体每一处核心方法的作用会在文章后面详细进行阐述。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/b8b53a70984668bc68653efe9531573e78636.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e为了帮助大家理解ReentrantLock和AQS之间方法的交互过程，以非公平锁为例，我们将加锁和解锁的交互流程单独拎出来强调一下，以便于对后续内容的理解。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/7aadb272069d871bdee8bf3a218eed8136919.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e加锁：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e通过ReentrantLock的加锁方法Lock进行加锁操作。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁，执行相关内部类的Lock方法，本质上都会执行AQS的Acquire方法。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eAQS的Acquire方法会执行tryAcquire方法，但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法，由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法，因此会根据锁类型不同，执行不同的tryAcquire。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003etryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e解锁：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e通过ReentrantLock的解锁方法Unlock进行解锁。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eUnlock会调用内部类Sync的Release方法，该方法继承于AQS。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003eRelease中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e释放成功后，所有处理由AQS框架完成，与自定义同步器无关。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e通过上面的描述，大概可以总结出ReentrantLock加锁解锁时API层核心方法的映射关系。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/f30c631c8ebbf820d3e8fcb6eee3c0ef18748.png\" alt=\"\"/\u003e\u003c/p\u003e\u003ch2 id=\"2-3-通过reentrantlock理解aqs\"\u003e2.3 通过ReentrantLock理解AQS\u003c/h2\u003e\u003cp\u003eReentrantLock中公平锁和非公平锁在底层是相同的，这里以非公平锁为例进行分析。\u003c/p\u003e\u003cp\u003e在非公平锁中，有一段这样的代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock\n\nstatic final class NonfairSync extends Sync {\n\t...\n\tfinal void lock() {\n\t\tif (compareAndSetState(0, 1))\n\t\t\tsetExclusiveOwnerThread(Thread.currentThread());\n\t\telse\n\t\t\tacquire(1);\n\t}\n  ...\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看一下这个Acquire是怎么写的：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final void acquire(int arg) {\n\tif (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n\t\tselfInterrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e再看一下tryAcquire方法：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprotected boolean tryAcquire(int arg) {\n\tthrow new UnsupportedOperationException();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看出，这里只是AQS的简单实现，具体获取锁的实现方法是由各自的公平锁和非公平锁单独实现的（以ReentrantLock为例）。如果该方法返回了True，则说明当前线程获取锁成功，就不用往后执行了；如果获取失败，就需要加入到等待队列中。下面会详细解释线程是何时以及怎样被加入进等待队列中的。\u003c/p\u003e\u003ch3 id=\"2-3-1-线程加入等待队列\"\u003e2.3.1 线程加入等待队列\u003c/h3\u003e\u003ch4 id=\"2-3-1-1-加入队列的时机\"\u003e2.3.1.1 加入队列的时机\u003c/h4\u003e\u003cp\u003e当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。\u003c/p\u003e\u003ch4 id=\"2-3-1-2-如何加入队列\"\u003e2.3.1.2 如何加入队列\u003c/h4\u003e\u003cp\u003e获取锁失败后，会执行addWaiter(Node.EXCLUSIVE)加入等待队列，具体实现方法如下：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node addWaiter(Node mode) {\n\tNode node = new Node(Thread.currentThread(), mode);\n\t// Try the fast path of enq; backup to full enq on failure\n\tNode pred = tail;\n\tif (pred != null) {\n\t\tnode.prev = pred;\n\t\tif (compareAndSetTail(pred, node)) {\n\t\t\tpred.next = node;\n\t\t\treturn node;\n\t\t}\n\t}\n\tenq(node);\n\treturn node;\n}\nprivate final boolean compareAndSetTail(Node expect, Node update) {\n\treturn unsafe.compareAndSwapObject(this, tailOffset, expect, update);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e主要的流程如下：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e通过当前的线程和锁模式新建一个节点。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003ePred指针指向尾节点Tail。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e将New中Node的Prev指针指向Pred。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e通过compareAndSetTail方法，完成尾节点的设置。这个方法主要是对tailOffset和Expect进行比较，如果tailOffset的Node和Expect的Node地址是相同的，那么设置Tail的值为Update的值。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nstatic {\n\ttry {\n\t\tstateOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\u0026#34;state\u0026#34;));\n\t\theadOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\u0026#34;head\u0026#34;));\n\t\ttailOffset = unsafe.objectFieldOffset(AbstractQueuedSynchronizer.class.getDeclaredField(\u0026#34;tail\u0026#34;));\n\t\twaitStatusOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\u0026#34;waitStatus\u0026#34;));\n\t\tnextOffset = unsafe.objectFieldOffset(Node.class.getDeclaredField(\u0026#34;next\u0026#34;));\n\t} catch (Exception ex) { \n    throw new Error(ex); \n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从AQS的静态代码块可以看出，都是获取一个对象的属性相对于该对象在内存当中的偏移量，这样我们就可以根据这个偏移量在对象内存当中找到这个属性。tailOffset指的是tail对应的偏移量，所以这个时候会将new出来的Node置为当前队列的尾节点。同时，由于是双向链表，也需要将前一个节点指向尾节点。\u003c/p\u003e\u003cul\u003e\u003cli\u003e如果Pred指针是Null（说明等待队列中没有元素），或者当前Pred指针和Tail指向的位置不同（说明被别的线程已经修改），就需要看一下Enq的方法。\u003c/li\u003e\u003c/ul\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node enq(final Node node) {\n\tfor (;;) {\n\t\tNode t = tail;\n\t\tif (t == null) { // Must initialize\n\t\t\tif (compareAndSetHead(new Node()))\n\t\t\t\ttail = head;\n\t\t} else {\n\t\t\tnode.prev = t;\n\t\t\tif (compareAndSetTail(t, node)) {\n\t\t\t\tt.next = node;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果没有被初始化，需要进行初始化一个头结点出来。但请注意，初始化的头结点并不是当前线程节点，而是调用了无参构造函数的节点。如果经历了初始化或者并发导致队列中有元素，则与之前的方法相同。其实，addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。\u003c/p\u003e\u003cp\u003e总结一下，线程获取锁的时候，过程大体如下：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e当没有线程获取到锁时，线程1获取锁成功。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e线程2申请锁，但是锁被线程1占有。\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/e9e385c3c68f62c67c8d62ab0adb613921117.png\" alt=\"\"/\u003e\u003c/p\u003e\u003col\u003e\u003cli\u003e如果再有线程要获取锁，依次在队列中往后排队即可。\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e回到上边的代码，hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock\n\npublic final boolean hasQueuedPredecessors() {\n\t// The correctness of this depends on head being initialized\n\t// before tail and on head.next being accurate if the current\n\t// thread is first in queue.\n\tNode t = tail; // Read fields in reverse initialization order\n\tNode h = head;\n\tNode s;\n\treturn h != t \u0026amp;\u0026amp; ((s = h.next) == null || s.thread != Thread.currentThread());\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e看到这里，我们理解一下h != t \u0026amp;\u0026amp; ((s = h.next) == null || s.thread != Thread.currentThread());为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e双向链表中，第一个节点为虚节点，其实并不存储任何信息，只是占位。真正的第一个有数据的节点，是在第二个节点开始的。当h != t时：\n如果(s = h.next) == null，等待队列正在有线程进行初始化，但只是进行到了Tail指向Head，没有将Head指向Tail，此时队列中有元素，需要返回True（这块具体见下边代码分析）。\n如果(s = h.next) != null，说明此时队列中至少有一个有效节点。如果此时s.thread == Thread.currentThread()，说明等待队列的第一个有效节点中的线程与当前线程相同，那么当前线程是可以获取资源的；如果s.thread != Thread.currentThread()，说明等待队列的第一个有效节点线程与当前线程不同，当前线程必须加入进等待队列。\u003c/p\u003e\u003c/blockquote\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer#enq\n\nif (t == null) { // Must initialize\n\tif (compareAndSetHead(new Node()))\n\t\ttail = head;\n} else {\n\tnode.prev = t;\n\tif (compareAndSetTail(t, node)) {\n\t\tt.next = node;\n\t\treturn t;\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e节点入队不是原子操作，所以会出现短暂的head != tail，此时Tail指向最后一个节点，而且Tail指向Head。如果Head没有指向Tail（可见5、6、7行），这种情况下也需要将相关线程加入队列中。所以这块代码是为了解决极端情况下的并发问题。\u003c/p\u003e\u003ch4 id=\"2-3-1-3-等待队列中线程出队列时机\"\u003e2.3.1.3 等待队列中线程出队列时机\u003c/h4\u003e\u003cp\u003e回到最初的源码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final void acquire(int arg) {\n\tif (!tryAcquire(arg) \u0026amp;\u0026amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n\t\tselfInterrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。\u003c/p\u003e\u003cp\u003e总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功或者不再需要获取（中断）。\u003c/p\u003e\u003cp\u003e下面我们从“何时出队列？”和“如何出队列？”两个方向来分析一下acquireQueued源码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n\t// 标记是否成功拿到资源\n\tboolean failed = true;\n\ttry {\n\t\t// 标记等待过程中是否中断过\n\t\tboolean interrupted = false;\n\t\t// 开始自旋，要么获取锁，要么中断\n\t\tfor (;;) {\n\t\t\t// 获取当前节点的前驱节点\n\t\t\tfinal Node p = node.predecessor();\n\t\t\t// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）\n\t\t\tif (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {\n\t\t\t\t// 获取锁成功，头指针移动到当前node\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; // help GC\n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\t\t\t// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，这个时候就要判断当前node是否要被阻塞（被阻塞条件：前驱节点的waitStatus为-1），防止无限循环浪费资源。具体两个方法下面细细分析\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt())\n\t\t\t\tinterrupted = true;\n\t\t}\n\t} finally {\n\t\tif (failed)\n\t\t\tcancelAcquire(node);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e注：setHead方法是把当前节点置为虚节点，但并没有修改waitStatus，因为它是一直需要用的数据。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void setHead(Node node) {\n\thead = node;\n\tnode.thread = null;\n\tnode.prev = null;\n}\n\n// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\n// 靠前驱节点判断当前线程是否应该被阻塞\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n\t// 获取头结点的节点状态\n\tint ws = pred.waitStatus;\n\t// 说明头结点处于唤醒状态\n\tif (ws == Node.SIGNAL)\n\t\treturn true; \n\t// 通过枚举值我们知道waitStatus\u0026gt;0是取消状态\n\tif (ws \u0026gt; 0) {\n\t\tdo {\n\t\t\t// 循环向前查找取消节点，把取消节点从队列中剔除\n\t\t\tnode.prev = pred = pred.prev;\n\t\t} while (pred.waitStatus \u0026gt; 0);\n\t\tpred.next = node;\n\t} else {\n\t\t// 设置前任节点等待状态为SIGNAL\n\t\tcompareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n\t}\n\treturn false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003eparkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述方法的流程图如下：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/c124b76dcbefb9bdc778458064703d1135485.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从上图可以看出，跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起，具体挂起流程用流程图表示如下（shouldParkAfterFailedAcquire流程）：\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/9af16e2481ad85f38ca322a225ae737535740.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e从队列中释放节点的疑虑打消了，那么又有新问题了：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eshouldParkAfterFailedAcquire中取消节点是怎么生成的呢？什么时候会把一个节点的waitStatus设置为-1？\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e是在什么时间释放节点通知到被挂起的线程呢？\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch3 id=\"2-3-2-cancelled状态节点生成\"\u003e2.3.2 CANCELLED状态节点生成\u003c/h3\u003e\u003cp\u003eacquireQueued方法中的Finally代码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n\tboolean failed = true;\n\ttry {\n    ...\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {\n\t\t\t\t...\n\t\t\t\tfailed = false;\n        ...\n\t\t\t}\n\t\t\t...\n\t} finally {\n\t\tif (failed)\n\t\t\tcancelAcquire(node);\n\t\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过cancelAcquire方法，将Node的状态标记为CANCELLED。接下来，我们逐行来分析这个方法的原理：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void cancelAcquire(Node node) {\n  // 将无效节点过滤\n\tif (node == null)\n\t\treturn;\n  // 设置该节点不关联任何线程，也就是虚节点\n\tnode.thread = null;\n\tNode pred = node.prev;\n  // 通过前驱节点，跳过取消状态的node\n\twhile (pred.waitStatus \u0026gt; 0)\n\t\tnode.prev = pred = pred.prev;\n  // 获取过滤后的前驱节点的后继节点\n\tNode predNext = pred.next;\n  // 把当前node的状态设置为CANCELLED\n\tnode.waitStatus = Node.CANCELLED;\n  // 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点\n  // 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null\n\tif (node == tail \u0026amp;\u0026amp; compareAndSetTail(node, pred)) {\n\t\tcompareAndSetNext(pred, predNext, null);\n\t} else {\n\t\tint ws;\n    // 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功\n    // 如果1和2中有一个为true，再判断当前节点的线程是否为null\n    // 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点\n\t\tif (pred != head \u0026amp;\u0026amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws \u0026lt;= 0 \u0026amp;\u0026amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) \u0026amp;\u0026amp; pred.thread != null) {\n\t\t\tNode next = node.next;\n\t\t\tif (next != null \u0026amp;\u0026amp; next.waitStatus \u0026lt;= 0)\n\t\t\t\tcompareAndSetNext(pred, predNext, next);\n\t\t} else {\n      // 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点\n\t\t\tunparkSuccessor(node);\n\t\t}\n\t\tnode.next = node; // help GC\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e当前的流程：\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus \u0026lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e根据当前节点的位置，考虑以下三种情况：\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e(1) 当前节点是尾节点。\u003c/p\u003e\u003cp\u003e(2) 当前节点是Head的后继节点。\u003c/p\u003e\u003cp\u003e(3) 当前节点不是Head的后继节点，也不是尾节点。\u003c/p\u003e\u003cp\u003e根据上述第二条，我们来分析每一种情况的流程。\u003c/p\u003e\u003cp\u003e当前节点是尾节点。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/b845211ced57561c24f79d56194949e822049.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当前节点是Head的后继节点。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p1.meituan.net/travelcube/ab89bfec875846e5028a4f8fead32b7117975.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e当前节点不是Head的后继节点，也不是尾节点。\u003c/p\u003e\u003cp\u003e\u003cimg src=\"https://p0.meituan.net/travelcube/45d0d9e4a6897eddadc4397cf53d6cd522452.png\" alt=\"\"/\u003e\u003c/p\u003e\u003cp\u003e通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003e执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。\nshouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003edo {\n\tnode.prev = pred = pred.prev;\n} while (pred.waitStatus \u0026gt; 0);\n\u003c/code\u003e\u003c/pre\u003e\u003c/blockquote\u003e\u003ch3 id=\"2-3-3-如何解锁\"\u003e2.3.3 如何解锁\u003c/h3\u003e\u003cp\u003e我们已经剖析了加锁过程中的基本流程，接下来再对解锁的基本流程进行分析。由于ReentrantLock在解锁的时候，并不区分公平锁和非公平锁，所以我们直接看解锁的源码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock\n\npublic void unlock() {\n\tsync.release(1);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看到，本质释放锁的地方，是通过框架来完成的。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final boolean release(int arg) {\n\tif (tryRelease(arg)) {\n\t\tNode h = head;\n\t\tif (h != null \u0026amp;\u0026amp; h.waitStatus != 0)\n\t\t\tunparkSuccessor(h);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e在ReentrantLock里面的公平锁和非公平锁的父类Sync定义了可重入锁的释放锁机制。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock.Sync\n\n// 方法返回当前锁是不是没有被线程持有\nprotected final boolean tryRelease(int releases) {\n\t// 减少可重入次数\n\tint c = getState() - releases;\n\t// 当前线程不是持有锁的线程，抛出异常\n\tif (Thread.currentThread() != getExclusiveOwnerThread())\n\t\tthrow new IllegalMonitorStateException();\n\tboolean free = false;\n\t// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state\n\tif (c == 0) {\n\t\tfree = true;\n\t\tsetExclusiveOwnerThread(null);\n\t}\n\tsetState(c);\n\treturn free;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们来解释下述源码：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\npublic final boolean release(int arg) {\n\t// 上边自定义的tryRelease如果返回true，说明该锁没有被任何线程持有\n\tif (tryRelease(arg)) {\n\t\t// 获取头结点\n\t\tNode h = head;\n\t\t// 头结点不为空并且头结点的waitStatus不是初始化节点情况，解除线程挂起状态\n\t\tif (h != null \u0026amp;\u0026amp; h.waitStatus != 0)\n\t\t\tunparkSuccessor(h);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e这里的判断条件为什么是h != null \u0026amp;\u0026amp; h.waitStatus != 0？\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eh == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。\u003c/p\u003e\u003cp\u003eh != null \u0026amp;\u0026amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。\u003c/p\u003e\u003cp\u003eh != null \u0026amp;\u0026amp; waitStatus \u0026lt; 0 表明后继节点可能被阻塞了，需要唤醒。\u003c/p\u003e\u003c/blockquote\u003e\u003cp\u003e再看一下unparkSuccessor方法：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate void unparkSuccessor(Node node) {\n\t// 获取头结点waitStatus\n\tint ws = node.waitStatus;\n\tif (ws \u0026lt; 0)\n\t\tcompareAndSetWaitStatus(node, ws, 0);\n\t// 获取当前节点的下一个节点\n\tNode s = node.next;\n\t// 如果下个节点是null或者下个节点被cancelled，就找到队列最开始的非cancelled的节点\n\tif (s == null || s.waitStatus \u0026gt; 0) {\n\t\ts = null;\n\t\t// 就从尾部节点开始找，到队首，找到队列第一个waitStatus\u0026lt;0的节点。\n\t\tfor (Node t = tail; t != null \u0026amp;\u0026amp; t != node; t = t.prev)\n\t\t\tif (t.waitStatus \u0026lt;= 0)\n\t\t\t\ts = t;\n\t}\n\t// 如果当前节点的下个节点不为空，而且状态\u0026lt;=0，就把当前节点unpark\n\tif (s != null)\n\t\tLockSupport.unpark(s.thread);\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e为什么要从后往前找第一个非Cancelled的节点呢？原因如下。\u003c/p\u003e\u003cp\u003e之前的addWaiter方法：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate Node addWaiter(Node mode) {\n\tNode node = new Node(Thread.currentThread(), mode);\n\t// Try the fast path of enq; backup to full enq on failure\n\tNode pred = tail;\n\tif (pred != null) {\n\t\tnode.prev = pred;\n\t\tif (compareAndSetTail(pred, node)) {\n\t\t\tpred.next = node;\n\t\t\treturn node;\n\t\t}\n\t}\n\tenq(node);\n\treturn node;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e我们从这里可以看到，节点入队并不是原子操作，也就是说，node.prev = pred; compareAndSetTail(pred, node) 这两个地方可以看作Tail入队的原子操作，但是此时pred.next = node;还没执行，如果这个时候执行了unparkSuccessor方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。\u003c/p\u003e\u003cp\u003e综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？\u003c/p\u003e\u003ch3 id=\"2-3-4-中断恢复后的执行流程\"\u003e2.3.4 中断恢复后的执行流程\u003c/h3\u003e\u003cp\u003e唤醒后，会执行return Thread.interrupted();，这个函数返回的是当前执行线程的中断状态，并清除。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate final boolean parkAndCheckInterrupt() {\n\tLockSupport.park(this);\n\treturn Thread.interrupted();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e再回到acquireQueued代码，当parkAndCheckInterrupt返回True或者False的时候，interrupted的值不同，但都会执行下次循环。如果这个时候获取锁成功，就会把当前interrupted返回。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nfinal boolean acquireQueued(final Node node, int arg) {\n\tboolean failed = true;\n\ttry {\n\t\tboolean interrupted = false;\n\t\tfor (;;) {\n\t\t\tfinal Node p = node.predecessor();\n\t\t\tif (p == head \u0026amp;\u0026amp; tryAcquire(arg)) {\n\t\t\t\tsetHead(node);\n\t\t\t\tp.next = null; // help GC\n\t\t\t\tfailed = false;\n\t\t\t\treturn interrupted;\n\t\t\t}\n\t\t\tif (shouldParkAfterFailedAcquire(p, node) \u0026amp;\u0026amp; parkAndCheckInterrupt())\n\t\t\t\tinterrupted = true;\n\t\t\t}\n\t} finally {\n\t\tif (failed)\n\t\t\tcancelAcquire(node);\n\t}\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e如果acquireQueued为True，就会执行selfInterrupt方法。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nstatic void selfInterrupt() {\n\tThread.currentThread().interrupt();\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e该方法其实是为了中断线程。但为什么获取了锁以后还要中断线程呢？这部分属于Java提供的协作式中断知识内容，感兴趣同学可以查阅一下。这里简单介绍一下：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e当中断线程被唤醒时，并不知道被唤醒的原因，可能是当前线程在等待中被中断，也可能是释放了锁以后被唤醒。因此我们通过Thread.interrupted()方法检查中断标记（该方法返回了当前线程的中断状态，并将当前线程的中断标识设置为False），并记录下来，如果发现该线程被中断过，就再中断一次。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e线程在等待资源的过程中被唤醒，唤醒后还是会不断地去尝试获取锁，直到抢到锁为止。也就是说，在整个流程中，并不响应中断，只是记录中断记录。最后抢到锁返回了，那么如果被中断过的话，就需要补充一次中断。\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003e这里的处理方式主要是运用线程池中基本运作单元Worder中的runWorker，通过Thread.interrupted()进行额外的判断处理，感兴趣的同学可以看下ThreadPoolExecutor源码。\u003c/p\u003e\u003ch3 id=\"2-3-5-小结\"\u003e2.3.5 小结\u003c/h3\u003e\u003cp\u003e我们在1.3小节中提出了一些问题，现在来回答一下。\u003c/p\u003e\u003cblockquote\u003e\u003cp\u003eQ：某个线程获取锁失败的后续流程是什么呢？\u003c/p\u003e\u003cp\u003eA：存在某种排队等候机制，线程继续等待，仍然保留获取锁的可能，获取锁流程仍在继续。\u003c/p\u003e\u003cp\u003eQ：既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\u003c/p\u003e\u003cp\u003eA：是CLH变体的FIFO双端队列。\u003c/p\u003e\u003cp\u003eQ：处于排队等候机制中的线程，什么时候可以有机会获取锁呢？\u003c/p\u003e\u003cp\u003eA：可以详细看下2.3.1.3小节。\u003c/p\u003e\u003cp\u003eQ：如果处于排队等候机制中的线程一直无法获取锁，需要一直等待么？还是有别的策略来解决这一问题？\u003c/p\u003e\u003cp\u003eA：线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放，具体可见2.3.2小节。\u003c/p\u003e\u003cp\u003eQ：Lock函数通过Acquire方法进行加锁，但是具体是如何加锁的呢？\u003c/p\u003e\u003cp\u003eA：AQS的Acquire会调用tryAcquire方法，tryAcquire由各个自定义同步器实现，通过tryAcquire完成加锁过程。\u003c/p\u003e\u003c/blockquote\u003e\u003ch2 id=\"3-aqs应用\"\u003e3 AQS应用\u003c/h2\u003e\u003ch3 id=\"3-1-reentrantlock的可重入应用\"\u003e3.1 ReentrantLock的可重入应用\u003c/h3\u003e\u003cp\u003eReentrantLock的可重入性是AQS很好的应用之一，在了解完上述知识点以后，我们很容易得知ReentrantLock实现可重入的方法。在ReentrantLock里面，不管是公平锁还是非公平锁，都有一段逻辑。\u003c/p\u003e\u003cp\u003e公平锁：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock.FairSync#tryAcquire\n\nif (c == 0) {\n\tif (!hasQueuedPredecessors() \u0026amp;\u0026amp; compareAndSetState(0, acquires)) {\n\t\tsetExclusiveOwnerThread(current);\n\t\treturn true;\n\t}\n}\nelse if (current == getExclusiveOwnerThread()) {\n\tint nextc = c + acquires;\n\tif (nextc \u0026lt; 0)\n\t\tthrow new Error(\u0026#34;Maximum lock count exceeded\u0026#34;);\n\tsetState(nextc);\n\treturn true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e非公平锁：\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.ReentrantLock.Sync#nonfairTryAcquire\n\nif (c == 0) {\n\tif (compareAndSetState(0, acquires)){\n\t\tsetExclusiveOwnerThread(current);\n\t\treturn true;\n\t}\n}\nelse if (current == getExclusiveOwnerThread()) {\n\tint nextc = c + acquires;\n\tif (nextc \u0026lt; 0) // overflow\n\t\tthrow new Error(\u0026#34;Maximum lock count exceeded\u0026#34;);\n\tsetState(nextc);\n\treturn true;\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e从上面这两段都可以看到，有一个同步状态State来控制整体可重入的情况。State是Volatile修饰的，用于保证一定的可见性和有序性。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003e// java.util.concurrent.locks.AbstractQueuedSynchronizer\n\nprivate volatile int state;\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e接下来看State这个字段主要的过程：\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003eState初始化的时候为0，表示没有任何线程持有锁。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e当有线程持有该锁时，值就会在原来的基础上+1，同一个线程多次获得锁是，就会多次+1，这里就是可重入的概念。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e解锁也是对这个字段-1，一直到0，此线程对锁释放。\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3 id=\"3-2-juc中的应用场景\"\u003e3.2 JUC中的应用场景\u003c/h3\u003e\u003cp\u003e除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：\u003c/p\u003e\u003ctable\u003e\u003cthead\u003e\u003ctr\u003e\u003cth\u003e同步工具\u003c/th\u003e\u003cth\u003e同步工具与AQS的关联\u003c/th\u003e\u003c/tr\u003e\u003c/thead\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd\u003eReentrantLock\u003c/td\u003e\u003ctd\u003e使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eSemaphore\u003c/td\u003e\u003ctd\u003e使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eCountDownLatch\u003c/td\u003e\u003ctd\u003e使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eReentrantReadWriteLock\u003c/td\u003e\u003ctd\u003e使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。\u003c/td\u003e\u003c/tr\u003e\u003ctr\u003e\u003ctd\u003eThreadPoolExecutor\u003c/td\u003e\u003ctd\u003eWorker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003ch3 id=\"3-3-自定义同步工具\"\u003e3.3 自定义同步工具\u003c/h3\u003e\u003cp\u003e了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class LeeLock  {\n\n    private static class Sync extends AbstractQueuedSynchronizer {\n        @Override\n        protected boolean tryAcquire (int arg) {\n            return compareAndSetState(0, 1);\n        }\n\n        @Override\n        protected boolean tryRelease (int arg) {\n            setState(0);\n            return true;\n        }\n\n        @Override\n        protected boolean isHeldExclusively () {\n            return getState() == 1;\n        }\n    }\n    \n    private Sync sync = new Sync();\n    \n    public void lock () {\n        sync.acquire(1);\n    }\n    \n    public void unlock () {\n        sync.release(1);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e通过我们自己定义的Lock完成一定的同步功能。\u003c/p\u003e\u003cpre\u003e\u003ccode\u003epublic class LeeMain {\n\n    static int count = 0;\n    static LeeLock leeLock = new LeeLock();\n\n    public static void main (String[] args) throws InterruptedException {\n\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run () {\n                try {\n                    leeLock.lock();\n                    for (int i = 0; i \u0026lt; 10000; i++) {\n                        count++;\n                    }\n                } catch (Exception e) {\n                    e.printStackTrace();\n                } finally {\n                    leeLock.unlock();\n                }\n\n            }\n        };\n        Thread thread1 = new Thread(runnable);\n        Thread thread2 = new Thread(runnable);\n        thread1.start();\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        System.out.println(count);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。\u003c/p\u003e\u003ch2 id=\"总结\"\u003e总结\u003c/h2\u003e\u003cp\u003e我们日常开发中使用并发的场景太多，但是对并发内部的基本框架原理了解的人却不多。由于篇幅原因，本文仅介绍了可重入锁ReentrantLock的原理和AQS原理，希望能够成为大家了解AQS和ReentrantLock等同步器的“敲门砖”。\u003c/p\u003e\u003ch2 id=\"参考资料\"\u003e参考资料\u003c/h2\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003eLea D. The java. util. concurrent synchronizer framework[J]. Science of Computer Programming, 2005, 58(3): 293-309.\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e《Java并发编程实战》\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003ca href=\"https://tech.meituan.com/2018/11/15/java-lock.html\"\u003e不可不说的Java“锁”事\u003c/a\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003ch2 id=\"作者简介\"\u003e作者简介\u003c/h2\u003e\u003cp\u003e李卓，美团点评住宿度假研发中心Java研发工程师，2018年加入美团点评。\u003c/p\u003e\u003ch2 id=\"招聘信息\"\u003e招聘信息\u003c/h2\u003e\u003cp\u003e美团到店住宿门票业务研发团队负责美团酒店和门票核心业务系统建设。\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cp\u003e美团酒店屡次刷新行业记录，最近12个月酒店预订间夜量达到3个亿，单日入住间夜量峰值突破300万，单季度间夜突破1亿间。\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e美团门票2018年出票量达到一亿张，成为国内门票预订规模顶尖的平台。技术团队的愿景是：建设打造旅游住宿行业一流的技术架构，从质量、安全、效率、性能多角度保障系统高速发展。\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e美团到店住宿门票业务研发团队期待优秀的技术伙伴加入，欢迎投简历至：tech@meituan.com（邮件标题注明：美团到店住宿门票业务研发团队）\u003c/p\u003e\u003c/div\u003e\u003c/div\u003e",
  "Date": "2019-12-05T00:00:00Z",
  "Author": "soulteary@gmail.com"
}