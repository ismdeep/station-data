{
  "Source": "www.evilsocket.net",
  "Title": "Fuzzing With AFL-Fuzz, a Practical Example ( AFL vs Binutils )",
  "Link": "https://www.evilsocket.net/2015/04/30/Fuzzing-with-AFL-Fuzz-a-Practical-Example-AFL-vs-binutils/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eIt’s been a few weeks I’ve been playing with \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://lcamtuf.coredump.cx/afl/\"\u003eafl-fuzz\u003c/a\u003e ( \u003cem\u003eamerican fuzzy lop\u003c/em\u003e ), a great tool from \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://lcamtuf.coredump.cx/\"\u003elcamtuf\u003c/a\u003e which uses binary instrumentation to create edge-cases for a given software, the description on the website is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eAmerican fuzzy lop is a security-oriented fuzzer that employs a novel type of compile-time\ninstrumentation and genetic algorithms to automatically discover clean, interesting test cases\nthat trigger new internal states in the targeted binary.\nThis substantially improves the functional coverage for the fuzzed code. The compact synthesized\ncorpora produced by the tool are also useful for seeding other, more labor- or resource-intensive\ntesting regimes down the road.\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOk nice … but what does this actually mean?\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003ch1 id=\"Binary-Instrumentation\"\u003e\u003ca href=\"#Binary-Instrumentation\" class=\"headerlink\" title=\"Binary Instrumentation\"\u003e\u003c/a\u003eBinary Instrumentation\u003c/h1\u003e\u003cp\u003eThe first component of AFL is a wrapper for GCC/CLang compilers that will inject during compilation its own assembly code into the target software.\u003cbr/\u003eThe fuzzer will use this code to trace execution paths while feeding the system with new inputs and to determine if a new mutation of the input is able to trigger known or unkown ( new ) execution paths.\u003c/p\u003e\n\u003cp\u003eIf you can’t/don’t want to recompile the source code of the target program, AFL also supports a QEMU mode, an extension that leverages the QEMU “user emulation” mode and allows callers to obtain instrumentation output for black-box, closed-source binaries. This mechanism can be then used by afl-fuzz to stress-test targets that couldn’t be built with afl-gcc.\u003c/p\u003e\n\u003ch1 id=\"Installation\"\u003e\u003ca href=\"#Installation\" class=\"headerlink\" title=\"Installation\"\u003e\u003c/a\u003eInstallation\u003c/h1\u003e\u003cp\u003eThe installation of AFL is trivial, just download the \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz\"\u003elatest version\u003c/a\u003e of the source code, extract it and do the usual:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003emake\nsudo make install\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"A-practical-example\"\u003e\u003ca href=\"#A-practical-example\" class=\"headerlink\" title=\"A practical example\"\u003e\u003c/a\u003eA practical example\u003c/h1\u003e\u003cp\u003eBeing AFL particularly well suited for programs that accept a file as input, I thought about trying it against the \u003cstrong\u003ebinutils\u003c/strong\u003e and specifically against the \u003cstrong\u003ereadelf\u003c/strong\u003e binary … AFL found eight distinct crashes cases ( potentially exploitable ) in the first five minutes of elaboration, and more than 30 after less than one hour!\u003c/p\u003e\n\u003cp\u003eFirst of all, you need to download a copy of the target program source code and extract it, once you’re inside the extracted folder, you will need to override the \u003cstrong\u003eCC\u003c/strong\u003e ( or \u003cstrong\u003eCXX\u003c/strong\u003e if it’s a C++ software being compiled with g++ instead of gcc ) environment variable before triggering the \u003cstrong\u003econfigure\u003c/strong\u003e script and finally proceed with the compilation as usual.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/binutils-2.25\nCC=afl-gcc ./configure\nmake\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e: If you want to use clang instead of gcc, you need to set CC to \u003cstrong\u003eafl-clang\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eDuring the compilation, you will notice a few messages from AFL informing you that it’s correctly injecting its instrumentations.\u003c/p\u003e\n\u003cp\u003eOnce finished, you want to tune up your configuration, the following command will instruct the system to output coredumps as files instead of sending them to a specific crash handler app.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e# echo core \u0026gt; /proc/sys/kernel/core_pattern\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we need to create an \u003cstrong\u003einput\u003c/strong\u003e folder where we will put our legit ELF file, in our case the \u003cstrong\u003e/bin/ps\u003c/strong\u003e command, ( AFL will use it as a base template ) and an \u003cstrong\u003eoutput\u003c/strong\u003e folder where the fuzzer will store its state but more important all the generated samples that make the application crash or hang.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/binutils-2.25\nmkdir afl_in afl_out\ncp /bin/ps afl_in/\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAnd finally, let’s run the fuzzer:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ecd ~/binutils-2.25\nafl-fuzz -i afl_in -o afl_out ./binutils/readelf -a @@\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eEventually, we will start to see something like the following:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2015/04/lop.png\" alt=\"lop\"/\u003e\u003c/p\u003e\n\u003cp\u003eAs you can see, the red number \u003cstrong\u003e8\u003c/strong\u003e on the top right is the total number of \u003cstrong\u003eunique\u003c/strong\u003e crashes the system was able to trigger so far.\u003cbr/\u003eIn the \u003cstrong\u003eafl_out/crashes\u003c/strong\u003e folder you will find the files that made readelf crash, for instance if I try to execute readelf against the first crashing sample ( inside GDB ), I get the following:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e*** buffer overflow detected ***: /home/evilsocket/binutils-2.25/binutils/readelf terminated\n======= Backtrace: =========\n/lib/x86_64-linux-gnu/libc.so.6(+0x78c4e)[0x7ffff786cc4e]\n/lib/x86_64-linux-gnu/libc.so.6(__fortify_fail+0x5c)[0x7ffff790ce8c]\n/lib/x86_64-linux-gnu/libc.so.6(+0x116e80)[0x7ffff790ae80]\n/lib/x86_64-linux-gnu/libc.so.6(__strcat_chk+0x5d)[0x7ffff790a05d]\n/home/evilsocket/binutils-2.25/binutils/readelf[0x41349b]\n/home/evilsocket/binutils-2.25/binutils/readelf[0x490b67]\n/home/evilsocket/binutils-2.25/binutils/readelf[0x4c0b44]\n/home/evilsocket/binutils-2.25/binutils/readelf[0x403b0d]\n/lib/x86_64-linux-gnu/libc.so.6(__libc_start_main+0xf0)[0x7ffff7814a40]\n/home/evilsocket/binutils-2.25/binutils/readelf[0x404169]\n======= Memory map: ========\n00400000-0058b000 r-xp 00000000 08:05 6179323                            /home/evilsocket/binutils-2.25/binutils/readelf\n0078a000-0078b000 r--p 0018a000 08:05 6179323                            /home/evilsocket/binutils-2.25/binutils/readelf\n0078b000-0078d000 rw-p 0018b000 08:05 6179323                            /home/evilsocket/binutils-2.25/binutils/readelf\n0078d000-007b1000 rw-p 00000000 00:00 0                                  [heap]\n7ffff7313000-7ffff7329000 r-xp 00000000 08:05 262358                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n7ffff7329000-7ffff7528000 ---p 00016000 08:05 262358                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n7ffff7528000-7ffff7529000 rw-p 00015000 08:05 262358                     /lib/x86_64-linux-gnu/libgcc_s.so.1\n7ffff7529000-7ffff77f4000 r--p 00000000 08:05 6553617                    /usr/lib/locale/locale-archive\n7ffff77f4000-7ffff79b4000 r-xp 00000000 08:05 262349                     /lib/x86_64-linux-gnu/libc-2.21.so\n7ffff79b4000-7ffff7bb4000 ---p 001c0000 08:05 262349                     /lib/x86_64-linux-gnu/libc-2.21.so\n7ffff7bb4000-7ffff7bb8000 r--p 001c0000 08:05 262349                     /lib/x86_64-linux-gnu/libc-2.21.so\n7ffff7bb8000-7ffff7bba000 rw-p 001c4000 08:05 262349                     /lib/x86_64-linux-gnu/libc-2.21.so\n7ffff7bba000-7ffff7bbe000 rw-p 00000000 00:00 0\n7ffff7bbe000-7ffff7bd7000 r-xp 00000000 08:05 262234                     /lib/x86_64-linux-gnu/libz.so.1.2.8\n7ffff7bd7000-7ffff7dd7000 ---p 00019000 08:05 262234                     /lib/x86_64-linux-gnu/libz.so.1.2.8\n7ffff7dd7000-7ffff7dd8000 r--p 00019000 08:05 262234                     /lib/x86_64-linux-gnu/libz.so.1.2.8\n7ffff7dd8000-7ffff7dd9000 rw-p 0001a000 08:05 262234                     /lib/x86_64-linux-gnu/libz.so.1.2.8\n7ffff7dd9000-7ffff7dfd000 r-xp 00000000 08:05 262335                     /lib/x86_64-linux-gnu/ld-2.21.so\n7ffff7fa7000-7ffff7fce000 r--p 00000000 08:05 7605558                    /usr/share/locale-langpack/it/LC_MESSAGES/binutils.mo\n7ffff7fce000-7ffff7fd1000 rw-p 00000000 00:00 0\n7ffff7fec000-7ffff7fee000 rw-p 00000000 00:00 0\n7ffff7fee000-7ffff7ff5000 r--s 00000000 08:05 6824223                    /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache\n7ffff7ff5000-7ffff7ff8000 rw-p 00000000 00:00 0\n7ffff7ff8000-7ffff7ffa000 r--p 00000000 00:00 0                          [vvar]\n7ffff7ffa000-7ffff7ffc000 r-xp 00000000 00:00 0                          [vdso]\n7ffff7ffc000-7ffff7ffd000 r--p 00023000 08:05 262335                     /lib/x86_64-linux-gnu/ld-2.21.so\n7ffff7ffd000-7ffff7ffe000 rw-p 00024000 08:05 262335                     /lib/x86_64-linux-gnu/ld-2.21.so\n7ffff7ffe000-7ffff7fff000 rw-p 00000000 00:00 0\n7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]\nffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]\n  0x0010:   nome: GCC_3.0\nProgram received signal SIGABRT, Aborted.\n0x00007ffff7829267 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:55\n55    ../sysdeps/unix/sysv/linux/raise.c: File o directory non esistente.\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet AFL run for a while and it will find all sort of edge cases and potentially exploitable vulnerabilities :)\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2015-04-30T16:51:04Z",
  "Author": "Simone Margaritelli"
}