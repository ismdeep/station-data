{
  "Source": "www.evilsocket.net",
  "Title": "Using ARM Inline Assembly and Naked Functions to Fool Disassemblers",
  "Link": "https://www.evilsocket.net/2015/05/02/Using-ARM-Inline-Assembly-and-Naked-Functions-to-fool-Disassemblers/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eOn this post I want to share a simple trick I learned a while ago, it’s nothing special but if you think about it, it’s quite nice :)\u003c/p\u003e\n\u003cp\u003eSometimes we want to obfuscate/hide strings in our program to make reversing more difficult and the more common approach is to encrypt them somehow and put them inside binary buffers instead of plain ASCII strings.\u003cbr/\u003eOne downside of this naive approach is of course, once decompiled, the access to these binary buffers will easily be noticed by a seasoned reverser, he would assume some sort of obfuscation/encryption/whatever and start reversing the algorithm to unobfuscate the strings in a matter of minutes.\u003c/p\u003e\n\u003cp\u003eOne thing you can do to make his/her life harder ( but not impossible ) is embedding your encrypted data as code … how?\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003ch1 id=\"UPDATE-NOTE-10-May-2015\"\u003e\u003ca href=\"#UPDATE-NOTE-10-May-2015\" class=\"headerlink\" title=\"UPDATE/NOTE (10 May 2015)\"\u003e\u003c/a\u003eUPDATE/NOTE (10 May 2015)\u003c/h1\u003e\u003cp\u003eAfter a few critics I feel the need to do some clarifications.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cp\u003eThis is not intended to be the definitive obfuscation method, it’s just a \u003cstrong\u003esimple\u003c/strong\u003e and \u003cstrong\u003esmall\u003c/strong\u003e example of out-of-the-box thinking while coding in C.\u003cbr/\u003eIndeed it’s a simple and naive trick that wouldn’t create much problems to good reversers and a properly implemented recursive disassembler.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003ePlease don’t comment with things such as “The hello world string would be visible anyway” … of course it will be! That’s just an example, ideally the data stored in the function would be encrypted, thus binary.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eIt is possible to fool even a recursive disasm, just make a call to the fake function, catch the signal and go on … the disasm will see the call and consider it as a legit function.\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cp\u003eNice things happen when you start declaring odd sized constants on ARM, since the opcode align is of 4 bytes, that could screw in some cases the analysis of the next code portions.\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"Naked-Functions\"\u003e\u003ca href=\"#Naked-Functions\" class=\"headerlink\" title=\"Naked Functions\"\u003e\u003c/a\u003eNaked Functions\u003c/h1\u003e\u003cp\u003eLet’s start with the definition of what a \u003cstrong\u003enaked\u003c/strong\u003e function is. Basically whenever you declare a C/C++ function inside your code, the compiler will add some extra assembly code to the beginning and to the end of it, this code is responsible for cleaning the stack, popping arguments of the function and so forth.\u003cbr/\u003eIf you try to compile the following function:\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003esum\u003c/span\u003e\u003cspan class=\"params\"\u003e( \u003cspan class=\"keyword\"\u003eint\u003c/span\u003e a, \u003cspan class=\"keyword\"\u003eint\u003c/span\u003e b )\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e a + b;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThe resulting ( ARM ) assembly will be:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003epush\t{fp}\t\t; (str fp, [sp, #-4]!)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eadd\tfp, sp, #0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esub\tsp, sp, #12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estr\tr0, [fp, #-8]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003estr\tr1, [fp, #-12]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eldr\tr2, [fp, #-8]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eldr\tr3, [fp, #-12]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eadd\tr3, r2, r3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emov\tr0, r3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003esub\tsp, fp, #0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003epop\t{fp}\t\t; (ldr fp, [sp], #4)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ebx\tlr\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eAs you can see, there’s a lot of extra stuff rather than just the expected \u003cstrong\u003eadd\u003c/strong\u003e operator.\u003cbr/\u003eThe first instructions basically save the current frame pointer and load the function arguments into the appropriate registers, then the \u003cstrong\u003eadd r3, r2, r3\u003c/strong\u003e itself is performed ( this is the original purpose of our sum function ), the result is moved inside \u003cstrong\u003eR0\u003c/strong\u003e ( which by convention is the register that stores the return value of the function ), the original stack is restored and eventually there’s a branch to \u003cstrong\u003eLR\u003c/strong\u003e, namely a jump back to the previous address ( the one that called \u003cstrong\u003esum\u003c/strong\u003e ).\u003c/p\u003e\n\u003cp\u003eIn order to “avoid” those extra operators ( and generally speaking it’s not a good idea to avoid them unless you really know what you’re doing ), we can use the \u003cstrong\u003enaked\u003c/strong\u003e GCC attribute, its definition on the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html\"\u003edocs\u003c/a\u003e is:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eUse this attribute on the ARM, AVR, IP2K, RX and SPU ports to indicate that the specified\nfunction does not need prologue/epilogue sequences generated by the compiler.\nIt is up to the programmer to provide these sequences. The only statements that can be safely\nincluded in naked functions are asm statements that do not have operands. All other statements,\nincluding declarations of local variables, if statements, and so forth, should be avoided.\nNaked functions should be used to implement the body of an assembly function, while allowing\nthe compiler to construct the requisite function declaration for the assembler.\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, let’s try to use this attribute with the same sum function:\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e__attribute__ ((naked)) \u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003eint\u003c/span\u003e \u003cspan class=\"title\"\u003esum\u003c/span\u003e\u003cspan class=\"params\"\u003e( \u003cspan class=\"keyword\"\u003eint\u003c/span\u003e a, \u003cspan class=\"keyword\"\u003eint\u003c/span\u003e b )\u003c/span\u003e \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e a + b;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThe resulting assembly code will be just:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003emov\tr2, r0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emov\tr3, r1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eadd\tr3, r2, r3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003emov\tr0, r3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eAs you can see, only the add and return operations have been compiled this time, with no prologue and epilogue whatsoever.\u003cbr/\u003eObviously if you try to call the naked sum function, the program will crash with a \u003cstrong\u003eSegmentation Fault\u003c/strong\u003e message, due to the stack not being properly prepared and cleaned as we saw in the previous example.\u003c/p\u003e\n\u003cp\u003eSo how can we use the naked attribute?\u003c/p\u003e\n\u003ch1 id=\"Inline-ASM\"\u003e\u003ca href=\"#Inline-ASM\" class=\"headerlink\" title=\"Inline ASM\"\u003e\u003c/a\u003eInline ASM\u003c/h1\u003e\u003cp\u003eIf you’re a C/C++ developer you probably already know ( or at least you should! ) that you can use raw assembly inside your C/C++ code using the \u003cstrong\u003easm\u003c/strong\u003e gcc directive, if you don’t you definitely need to read the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://gcc.gnu.org/onlinedocs/gcc/Basic-Asm.html#Basic-Asm\"\u003eGCC documentation\u003c/a\u003e about that ( and shame on you! :D ).\u003cbr/\u003eAn interesting ASM directive we can exploit for our purpose is \u003cstrong\u003e.long\u003c/strong\u003e ( you can find it \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.coranac.com/files/gba/re-ejected-gasref.pdf\"\u003ehere\u003c/a\u003e inside the “Constannt Definition Directives” section ), which basically allows you to directly define a constant value inside your assembly code.\u003cbr/\u003eYou would normally use that to define a numeric constant to use in your code, but what happens if we embed it in a naked function?\u003c/p\u003e\n\u003cp\u003eLet’s take the following example:\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e__attribute__ ((naked)) \u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003emy_mum_said_im_special\u003c/span\u003e\u003cspan class=\"params\"\u003e()\u003c/span\u003e\u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003easm\u003c/span\u003e ( \u003cspan class=\"string\"\u003e\u0026#34;.long 0x6C6C6548\u0026#34;\u003c/span\u003e );\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003easm\u003c/span\u003e ( \u003cspan class=\"string\"\u003e\u0026#34;.long 0x6f57206f\u0026#34;\u003c/span\u003e );\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003easm\u003c/span\u003e ( \u003cspan class=\"string\"\u003e\u0026#34;.long 0x00646c72\u0026#34;\u003c/span\u003e );\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eWhat you see there is the definition of four constants of four bytes each, 16 bytes in total, which are the string\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e\u0026#34;\\0dlroW olleH\u0026#34;\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eSeems familiar? No? Well … try to reverse it and you’ll get the famous “Hello World” constant string with his null byte, since it’s represented as numbers the ARM endianess requires them to be in reverse order.\u003c/p\u003e\n\u003cp\u003eNow some magic with pointers, let’s try to take the address of this function, cast it to a *\u003cem\u003econst char **\u003c/em\u003e and printf it.\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003echar\u003c/span\u003e *s = (\u003cspan class=\"keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"keyword\"\u003echar\u003c/span\u003e *)\u0026amp;my_mum_said_im_special;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"built_in\"\u003eprintf\u003c/span\u003e( \u003cspan class=\"string\"\u003e\u0026#34;%s\\n\u0026#34;\u003c/span\u003e, s );\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThe output will be, as expected, an “Hello World” :D\u003c/p\u003e\n\u003cp\u003eBut how does the decompiler sees this function? Is it able to determine it’s actually just data and not code? The answer of course it’s \u003cstrong\u003eNO\u003c/strong\u003e:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e00000338 \u0026lt;my_mum_said_im_special\u0026gt;:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  cfstr64vs\tmvdx6, [ip], #-288\t; 0xfffffee0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  svcvs\t0x0057206f\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  rsbeq\tr6, r4, r2, ror ip\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThe \u003cstrong\u003eobjdump\u003c/strong\u003e utility simply took those bytes and tried to interpret them as ARM opcodes, miserably failing to detect them as data instead of code.\u003cbr/\u003eWhat about more sophisticated disassemblers?\u003c/p\u003e\n\u003cp\u003eThe following is a screenshot of the \u003cstrong\u003eHopper\u003c/strong\u003e disassembler:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2015/05/hopper.png\" alt=\"Hopper\"/\u003e\u003c/p\u003e\n\u003cp\u003eIn this case we even get a totally different code … what about \u003cstrong\u003eIDA\u003c/strong\u003e, the state of the art disassembler?\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2015/05/ida.jpg\" alt=\"ida\"/\u003e\u003c/p\u003e\n\u003cp\u003eAgain different code :D\u003c/p\u003e\n\u003cp\u003eNow try to imagine, instead of a simple “Hello World”, to put some strongly encrypted data or even strongly encrypted code that you can decrypt and execute at runtime.\u003cbr/\u003eIn my experiments, this trick not only is able to fool every decompiler I tried, but in some cases it’s even able to screw all the code that follows the naked function and/or make the decompiler crash!\u003c/p\u003e\n\u003cp\u003eEnjoy :)\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2015-05-02T14:37:19Z",
  "Author": "Simone Margaritelli"
}