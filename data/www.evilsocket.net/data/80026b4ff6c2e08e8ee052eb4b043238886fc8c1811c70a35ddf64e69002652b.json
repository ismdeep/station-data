{
  "Source": "www.evilsocket.net",
  "Title": "Reverse Engineering the Apple MultiPeer Connectivity Framework",
  "Link": "https://www.evilsocket.net/2022/10/20/Reverse-Engineering-the-Apple-MultiPeer-Connectivity-Framework/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eSome time ago I was using \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.apple.com/it/logic-pro/\"\u003eLogic Pro\u003c/a\u003e to record some of my music and I needed a way to start and stop the recording from an iPhone, so I found about \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://apps.apple.com/it/app/logic-remote/id638394624\"\u003eLogic Remote\u003c/a\u003e and was quite happy with it.\u003cbr/\u003eAfter the session, the hacker in me became curious about how the tools were communicating with each other, so I quickly started Wireshark while establishing a connection and saw something that tickled my curiosity even more: some of the data, such as the client and server names, were transmitted in cleartext on what it seemed a custom (and as typical of Apple, undocumented) TCP protocol (\u003cstrong\u003e“stevie”\u003c/strong\u003e being the hostname of my Mac):\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/cleartext.png\" alt=\"cleartext packets\"/\u003e\u003c/p\u003e\n\u003cp\u003eUsing \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://ss64.com/osx/lsof.html\"\u003elsof\u003c/a\u003e confirmed that this was indeed the communication between the client phone and Logic listening on port 56076:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/lsof.png\" alt=\"lsof\"/\u003e\u003c/p\u003e\n\u003cp\u003eInitially I tought this was just some Logic Pro specific protocol and very lazily started looking into it, without much success mostly due to lack of motivation given the very limited scope of the research. After a while I \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/evilsocket/status/1568310905640722433\"\u003etweeted\u003c/a\u003e asking if anyone had ever seen anything like it. \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/isComputerOn/status/1568344165175508992\"\u003e@isComputerOn pointed out\u003c/a\u003e that this looked a lot like a protocol that has been partially reversed and presented by \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/nabla_c0d3\"\u003eAlban Diquet\u003c/a\u003e back in 2014. Unfortunately, however brilliant, this research covers the protocol at a very high level and doesn’t really document the packets, their fields and how to establish a connection from anything but a client using the Apple framework. However, this helped me a lot in two ways: first it helped me realize this was not just Logic Pro specific, but that it was part of the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.apple.com/documentation/multipeerconnectivity\"\u003eMultipeer Connectivity Framework\u003c/a\u003e, and gave me a few hints about the general logic of the protocol itself.\u003c/p\u003e\n\u003cp\u003eWith renewed curiosity and motivation then I jumped into this rabbit hole and managed to reverse engineer all network packets. This allowed me to write a \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw\"\u003ePython proof of concept client\u003c/a\u003e that automatically discovers any MPC servers, initializes the connection and succesfully exchanges application specific data packets.\u003c/p\u003e\n\u003cp\u003eMoreover, while sending crafted packets and attempting all sorts of things, \u003cstrong\u003eI’ve discovered several vulnerabilities in the Apple custom made parsers\u003c/strong\u003e. I will \u003cstrong\u003enot\u003c/strong\u003e discuss them here (exception made for the session spoofing) but at the same time I’m not interested in reporting them to Apple, I’ve heard way too many negative stories about their disclosure program and in general how they mistreat researchers.\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/crash.png\" alt=\"crash\"/\u003e\u003c/p\u003e\n\u003cp\u003eLet’s see how this whole thing works! :)\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003ch3 id=\"MultipeerConnectivity-Framework\"\u003e\u003ca href=\"#MultipeerConnectivity-Framework\" class=\"headerlink\" title=\"MultipeerConnectivity Framework\"\u003e\u003c/a\u003eMultipeerConnectivity Framework\u003c/h3\u003e\u003cp\u003eApple’s \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.apple.com/documentation/multipeerconnectivity\"\u003edocumentation\u003c/a\u003e describes the framework like so:\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe Multipeer Connectivity framework supports the discovery of services provided by nearby devices and supports communicating with those services through message-based data, streaming data, and resources (such as files). In iOS, the framework uses infrastructure Wi-Fi networks, peer-to-peer Wi-Fi, and Bluetooth personal area networks for the underlying transport. In macOS and tvOS, it uses infrastructure Wi-Fi, peer-to-peer Wi-Fi, and Ethernet.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eThe document mostly describes how they abstracted the protocol in several classes while being extremely vague about how the thing actually works at the packet level. In reality they mostly reused existing protocols such as MDNS and a customized STUN implementation (in Logic Pro specific case, this doesn’t always apply to apps using this framework), plus a custom TCP based protocol for which they heavily relied on custom (and extremely badly) written parsers.\u003c/p\u003e\n\u003ch3 id=\"Discovery-Phase-Multicast-DNS\"\u003e\u003ca href=\"#Discovery-Phase-Multicast-DNS\" class=\"headerlink\" title=\"Discovery Phase: Multicast DNS\"\u003e\u003c/a\u003eDiscovery Phase: Multicast DNS\u003c/h3\u003e\u003cp\u003eThe very first thing that I’ve noticed was that, despite the server port being randomized at each application startup, the client application never asked me for the server ip address nor tcp port. This was a strong indicator that something else was happening on the network before the TCP session was being established, as if the server (and possibly the client as well) broadcasted this information in such a way to be automatically discoverable, as also hinted by the wording used in the documentation. \u003c/p\u003e\n\u003cp\u003eMy informed guess was \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Multicast_DNS\"\u003emulticast DNS\u003c/a\u003e as I’ve seen this protocol being (ab)used a lot from Apple (\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.apple.com/bonjour/\"\u003eBonjour\u003c/a\u003e for instance), and Wireshark confirmed my guess. Both the server and the client are broadcasting their hostnames and peer identifiers (more on this later) on the network so that they can find each other without user interaction.\u003c/p\u003e\n\u003cp\u003eHere’s how the server advertisement looks like on \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/spycast\"\u003eSpycast\u003c/a\u003e:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/mdns_server.png\" alt=\"mdns server\"/\u003e\u003c/p\u003e\n\u003cp\u003eWe can see which TCP port is being used (57219), some application specific information in the text record and a weird string “1tvdkfvihbru6”, the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid\"\u003ePeerID\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eAt the same time, the client is broadcasting some information such as its hostname:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/mdns_client.png\" alt=\"mdns client\"/\u003e\u003c/p\u003e\n\u003cp\u003eKeep in mind that all this data is visible by \u003cstrong\u003eanyone\u003c/strong\u003e on the same network, this is an important detail as we’ll see shortly when I’ll describe how the spoofing works.\u003c/p\u003e\n\u003ch3 id=\"How-a-PeerID-is-made\"\u003e\u003ca href=\"#How-a-PeerID-is-made\" class=\"headerlink\" title=\"How a PeerID is made\"\u003e\u003c/a\u003eHow a PeerID is made\u003c/h3\u003e\u003cp\u003eBefore proceeding to the next part, let’s stop for a moment to see how a peer is identified in this protocol and what that “1tvdkfvihbru6” string is.\u003c/p\u003e\n\u003cp\u003eUpon startup, each peer is represented by a \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid\"\u003eMCPeerID\u003c/a\u003e object. Long story short, a random 64bit integer is generated and converted to base36. \u003c/p\u003e\n\u003cp\u003eSo that 1tvdkfvihbru6 in base36 is 8670129607084362000 in base 10. This number is used to uniquely identify the host during the session, regardless of the hostname itself and it’s present in various forms in most of the packets we’re about to see.\u003c/p\u003e\n\u003ch3 id=\"Handshake-Phase-Hellos-and-Acks\"\u003e\u003ca href=\"#Handshake-Phase-Hellos-and-Acks\" class=\"headerlink\" title=\"Handshake Phase: Hellos and Acks\"\u003e\u003c/a\u003eHandshake Phase: Hellos and Acks\u003c/h3\u003e\u003cp\u003eAfter the client discovers the server peer via MDNS the connection is initiated to the TCP port indicated in the advertisement. This is when things started being complicated as the protocol is entirely custom and undocumented. \u003c/p\u003e\n\u003cp\u003eI needed to work my way from something like this:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/hexdata.png\" alt=\"hex data\"/\u003e\u003c/p\u003e\n\u003cp\u003eTo something \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py\"\u003elike this\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eFor this task I’ve performed dozens of tests such as:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSee if similar packets all started with the same signature bytes (they did).\u003c/li\u003e\n\u003cli\u003eSee if by changing the hostname of the client, some other fields (possibly string length fields) changed reflecting the new length (they did).\u003c/li\u003e\n\u003cli\u003eSee if there was any checksum going on by looking at 2 bytes and 4 bytes words that changed depending on the contents (there are).\u003c/li\u003e\n\u003cli\u003eSee if packets were encapsulated with a common header plus a packet-specific payload, which length should be indicated in the header (it is).\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAfter a few days of testing I’ve managed to understand that all the packets started with a header that looks like this:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe first 2 bytes are the packet signature and determine the packet type (Hello, Ack, Invite, …).\u003c/li\u003e\n\u003cli\u003eThe next 4 bytes are a sequence number plus flags that are used only for some specific payloads.\u003c/li\u003e\n\u003cli\u003eWe then have 2 bytes indicating the payload size after the header.\u003c/li\u003e\n\u003cli\u003eFollowing 4 bytes are the CRC32 of the whole packet (i wasn’t sure which checksum was, so \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/utils.py#L13\"\u003eI bruteforced it\u003c/a\u003e :D)\u003c/li\u003e\n\u003cli\u003eThe last 4 bytes of the header are unknown to me but they always seem to contain the same value.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWith this new knowledge I started looking into the payload of the first packets and identified how the connection handshake works:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe client sends an \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L172\"\u003eHello packet\u003c/a\u003e made of the header and its \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L66\"\u003ePeerID\u003c/a\u003e.\u003c/li\u003e\n\u003cli\u003eThe server responds with an \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L235\"\u003eAck packet\u003c/a\u003e, made of just the header and no payload.\u003c/li\u003e\n\u003cli\u003eThe server then sends its own Hello packet containing its PeerID (which seems redundant given its already broadcasted via MDNS, but whatever …).\u003c/li\u003e\n\u003cli\u003eThe client sends an Ack to the server Hello.\u003c/li\u003e\n\u003cli\u003eFinally the client sends an \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L276\"\u003eAccept packet\u003c/a\u003e also only made of the header and no payload, indicating that the first part of the handshake is complete. The reason why the client is responsible for this and not the server will always remain a mystery to me :D\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eYou can find the implementation of this handshake process \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L29\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP\"\u003e\u003ca href=\"#Authorization-Phase-Spoofable-Invites-and-BPlist-inside-BPlist-inside-TCP\" class=\"headerlink\" title=\"Authorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP\"\u003e\u003c/a\u003eAuthorization Phase: Spoofable Invites and BPlist inside BPlist inside TCP\u003c/h3\u003e\u003cp\u003eAfter this mutual introduction, the client will send an \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L351\"\u003eInvitation packet\u003c/a\u003e and this is where things start getting covoluted (a la Apple): as we can see from the next picture, the Invite packet is made of the header plus a \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://medium.com/@karaiskc/understanding-apples-binary-property-list-format-281e6da00dbd\"\u003eBinary Property List\u003c/a\u003e as indicated by the “bplist00” signature visible in cleartext in the packet:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/client_invite.png\" alt=\"client invite\"/\u003e\u003c/p\u003e\n\u003cp\u003eA BPlist is basically a binary encoded XML document, in this case containing the following fields:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMCNearbyServiceInviteContextKey: a bplist encoded (yes it’s a bplist inside a bplist …) integer, always 0x2.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceInviteIDKey: an integer always set to 0x0.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceMessageIDKey: an integer message identifier, always 0x1 for invites.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceRecipientPeerIDKey: the message recipient (the server in this case) PeerID, encoded as described next.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceSenderPeerIDKey: the message sender (the client) PeerID.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn the last two fields, the peer identifiers \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L126\"\u003eare encoded as\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e8 bytes containing the numeric peer identifier, big endian.\u003c/li\u003e\n\u003cli\u003e1 byte containing the peer hostname length.\u003c/li\u003e\n\u003cli\u003eN bytes containing the unicode peer hostname.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe server responds with an Ack and at this point two things can happen: if the client is unknown to the server, a prompt will be shown in order to let the user decide wether to authorize it or not:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/server_prompt.png\" alt=\"server prompt\"/\u003e\u003c/p\u003e\n\u003cp\u003eHowever, if the client has been previously authorized, no prompt will be shown and the communication will silently continue to the next data exchange step.\u003c/p\u003e\n\u003cp\u003eAt this point you might ask, how does the server store this authorization information? Is it some sort of session cookie? A more advanced cryptographic challenge mechanism? Black magic? Well my friends, often reality is way duller and dumber than what you might imagine :D\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThey just don’t give a damn and keep a “string peer_hostname -\u0026gt; bool authorized” association … yes, you read that right, client authorization only relies on the (spoofable) client hostname, they don’t even care about the peer identifier number.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eRemember how all this information (and more) is being broadcasted in cleartext via MDNS for everyone to enjoy? Yep that’s right, an attacker can wait for a legit client to be authorized and then use its hostname (not on the network, just in the MCNearbyServiceSenderPeerIDKey field) in order to either hijack the legit session, or just create a new one of its own and completely bypass the authorization prompt 🎉🎉🎉\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2015/Jan/major-facepalm.jpg\" alt=\"facepalm\"/\u003e\u003c/p\u003e\n\u003cp\u003eAnyways … if authorized, the server will conclude this phase by sending an \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L673\"\u003eInviteResponse\u003c/a\u003e, which is identical to the client Invite packet, back to the client. You can find the client invite logic \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L64\"\u003ehere\u003c/a\u003e and the wait loop for the server response \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/protocol.py#L79\"\u003ehere\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eLet’s continue.\u003c/p\u003e\n\u003ch3 id=\"Data-Exchange-Phase\"\u003e\u003ca href=\"#Data-Exchange-Phase\" class=\"headerlink\" title=\"Data Exchange Phase\"\u003e\u003c/a\u003eData Exchange Phase\u003c/h3\u003e\u003cp\u003eAfter the server accepted the invite, the client will proceed by sending a \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L780\"\u003eClientData packet\u003c/a\u003e, another bplist encoded payload containing the following fields:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eMCNearbyServiceInviteIDKey: the invite key received with the server InviteResponse.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceMessageIDKey: an incremental integer being InviteResponse.MCNearbyServiceMessageIDKey + 1.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceRecipientPeerIDKey: client peer id encoded as previously described.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceSenderPeerIDKey: server peer id encoded as previously described.\u003c/li\u003e\n\u003cli\u003eMCNearbyServiceConnectionDataKey: connection data as bplist (again, a bplist inside a bplist …), described next.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe interesting part here is the MCNearbyServiceConnectionDataKey field, which contains a bplist encoded \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L550\"\u003ebinary payload\u003c/a\u003e made of:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L383\"\u003eA header\u003c/a\u003e composed of:\u003cul\u003e\n\u003cli\u003e1 signature byte (0x80).\u003c/li\u003e\n\u003cli\u003e1 byte bitmask of security flags indicating if encryption is enabled (not in this case, LOL).\u003c/li\u003e\n\u003cli\u003e2 bytes indicating the total size of the payload.\u003c/li\u003e\n\u003cli\u003e1 byte indicating the number of segments / entries in the payload.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eA list of IPv4 and IPv6 addresses, one for each network interface of both peers.\u003c/li\u003e\n\u003cli\u003eA variable number of \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/tcp/messages.py#L474\"\u003esegments describing each network interface of both peers\u003c/a\u003e, made of:\u003cul\u003e\n\u003cli\u003e1 signature byte (0x61).\u003c/li\u003e\n\u003cli\u003e4 bytes of the numeric peer id (either the client or the server one) trimmed down to 32bits.\u003c/li\u003e\n\u003cli\u003e4 bytes of a random identifier, my guess is that this creates a new unique identifier together with the previous field.\u003c/li\u003e\n\u003cli\u003e1 byte indicating the interface type ( ipv4=0x5A ipv6=0x0A ).\u003c/li\u003e\n\u003cli\u003e3 bytes of padding.\u003c/li\u003e\n\u003cli\u003e1 byte containing the interface IP index bit-masked with its type.\u003c/li\u003e\n\u003cli\u003e2 bytes containing an UDP port.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eSince the application specific part of the protocol works on UDP, by exchanging this data both endpoints become aware of on which possible IP and UDP ports the next part of the communication can happen. \u003c/p\u003e\n\u003ch3 id=\"STUN-a-la-Facetime\"\u003e\u003ca href=\"#STUN-a-la-Facetime\" class=\"headerlink\" title=\"STUN a la Facetime\"\u003e\u003c/a\u003eSTUN a la Facetime\u003c/h3\u003e\u003cp\u003eAfter the previous step, an Apple custom implementation of \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/STUN\"\u003eSTUN\u003c/a\u003e is used to determine NAT type and which IP:PORT pair is best suited for the communication. Interestingly, while digging hard into this rabbit hole and reversing other frameworks that were referenced here and there, I found out this is the same exact mechanism that Apple Facetime also uses.\u003c/p\u003e\n\u003cp\u003eI’ve implemented a very basic \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/stun/server.py#L13\"\u003eSTUN processor here\u003c/a\u003e, what happens is:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eThe server will pick one of the IP:UDP_PORT pairs sent in the ClientData and sends a STUN \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/stun/messages.py#L250\"\u003eBinding Request\u003c/a\u003e containing these STUN attributes:\u003cul\u003e\n\u003cli\u003eUSERNAME: containing the server and client integer peer identifiers.\u003c/li\u003e\n\u003cli\u003eADDRESS_ERROR_CODE: always 0x6.\u003c/li\u003e\n\u003cli\u003eALTERNATE_DOMAIN: always 0x03f2.\u003c/li\u003e\n\u003cli\u003eAPPLE_NTP_DELAY: you would see this labled as ICMP by Wireshark, however Apple is using this specific attribute identifier to indicate the NTP delay, as I found out by Ghidra-ing the s*it out of it :D\u003c/li\u003e\n\u003cli\u003eICE_CONTROLLING: randomly generate STUN tie breaker / session id.\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eThe client will respond with its own Binding Request, replacing ICE_CONTROLLING with ICE_CONTROLLED and its tie breaker.\u003c/li\u003e\n\u003cli\u003eThe server will send a Binding Response with a MAPPED-ADDRESS attribute indicating the final IP:UDP_PORT pair for the communication.\u003c/li\u003e\n\u003cli\u003eThe client will send its own Binding Response with its UDP MAPPED-ADDRESS.\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eFrom this point on, an UDP connection is established between the two MAPPED-ADDRESSes and application specific data is exchanged.\u003c/p\u003e\n\u003ch3 id=\"Brief-note-on-OSPF\"\u003e\u003ca href=\"#Brief-note-on-OSPF\" class=\"headerlink\" title=\"Brief note on OSPF\"\u003e\u003c/a\u003eBrief note on OSPF\u003c/h3\u003e\u003cp\u003eDespite the Logic Pro specific protocol happening after all these steps is out of the scope of this post, I want to briefly mention how it works.\u003c/p\u003e\n\u003cp\u003eInterestingly, this protocol is referenced as OSPF from the framework:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2022/ospf.png\" alt=\"ospf?\"/\u003e\u003c/p\u003e\n\u003cp\u003eHowver it has almost nothing in common with the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Open_Shortest_Path_First\"\u003eOpen Shortest Path First\u003c/a\u003e protocol. Despite some of these function names reference valid OSPF messages such as LSA, LSAACK and so on, the Apple implementation is entirely different.\u003c/p\u003e\n\u003cp\u003eYou can find a partial \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/session.py\"\u003epython implementation here\u003c/a\u003e that will be used after the previous step in order to correctly start the “OSPF” session and start receiving data from the server. \u003c/p\u003e\n\u003cp\u003eIn this case, each packet is made of \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/messages.py#L11\"\u003ethis header\u003c/a\u003e:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e1 byte of protocol type signature (0xc1).\u003c/li\u003e\n\u003cli\u003e1 byte of packet type signature.\u003c/li\u003e\n\u003cli\u003e2 bytes of packet size.\u003c/li\u003e\n\u003cli\u003e2 bytes indicating OSPF channel, mostly unused.\u003c/li\u003e\n\u003cli\u003e2 bytes with the packet CRC16/ARC checksum (again, \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/utils.py#L10\"\u003ebruteforcing\u003c/a\u003e the type of checksum helped a lot).\u003c/li\u003e\n\u003cli\u003e4 bytes of the sender peer id.\u003c/li\u003e\n\u003cli\u003e4 bytes of the receiver peer id.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFollowing, the packet specific payload. \u003c/p\u003e\n\u003cp\u003eYou can find the definitions of some of \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/messages.py\"\u003ethe Logic Pro packets here\u003c/a\u003e and the OSPF server code that will initialize the session and start \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw/blob/main/mpc/ospf/session.py\"\u003egetting server updates here\u003c/a\u003e.\u003c/p\u003e\n\u003ch3 id=\"Conclusion\"\u003e\u003ca href=\"#Conclusion\" class=\"headerlink\" title=\"Conclusion\"\u003e\u003c/a\u003eConclusion\u003c/h3\u003e\u003cp\u003eThis has definitely been a fun ride during which I’ve learned a lot of new stuff about how Apple frameworks handle network communications. I want to reiterate my gratitude to \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/nabla_c0d3\"\u003eAlban Diquet\u003c/a\u003e for his research and to \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/isComputerOn\"\u003e@isComputerOn\u003c/a\u003e for pointing me to the right direction when I was about to give up on what it seemed something entirely irrelevant, thanks you so much guys! \u0026lt;3\u003c/p\u003e\n\u003cp\u003eI also want to comment on something i’ve heard during a talk presented at the last \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/0x41con\"\u003e0x41 conference\u003c/a\u003e.\u003cbr/\u003eThe researcher who was presenting and who specialized in fuzzing Apple products, mentioned how at the beginning of his path, someone who’s highly respected and recognized in the infosec community and industry, told him that “fuzzing Apple’s network protocols was a dumb idea”, which unfortunately convinced the researcher to look elsewhere. \u003c/p\u003e\n\u003cp\u003eWell, my highly respected and recognized dude, I can tell you it is \u003cstrong\u003enot\u003c/strong\u003e a dumb idea, \u003cstrong\u003eat all\u003c/strong\u003e, there’s \u003cstrong\u003ea lot\u003c/strong\u003e of unexplored attack surface there. What was dumb, very close-minded and ignorant, is your take about it.\u003c/p\u003e\n\u003cp\u003eAnyways … \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/mpcfw\"\u003eyou can find the project on my github\u003c/a\u003e as usual, enjoy!\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2022-10-20T11:05:13Z",
  "Author": "Simone Margaritelli"
}