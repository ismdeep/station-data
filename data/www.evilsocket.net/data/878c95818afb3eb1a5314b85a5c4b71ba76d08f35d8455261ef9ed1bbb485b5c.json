{
  "Source": "www.evilsocket.net",
  "Title": "Programmatically Identifying and Isolating Functions Inside Executables Like IDA Does.",
  "Link": "https://www.evilsocket.net/2014/03/11/Programmatically-identifying-and-isolating-functions-inside-executables-like-IDA-does/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eEven though it’s one of the tools I use on a daily basis, Hex-Rays \u003cstrong\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.hex-rays.com/products/ida/\"\u003eIDA\u003c/a\u003e\u003c/strong\u003e always fascinates me for its completeness and the huge amount of informations it is able to extract using just a “simple” static analysis approach and being myself a \u003cem\u003e“make yourself the tools you need”\u003c/em\u003e guy a couple of weeks ago I’ve started to study it, trying to understand its internal mechanisms, algorithms and tricks.\u003c/p\u003e\n\u003cp\u003eI’ve focused on the identification and isolation of subroutines inside an executable due to the fact that this seemed to me the simplest thing to start with \u003cstrong\u003eand\u003c/strong\u003e because I came accross \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://blog.clamav.net/2014/02/generating-clamav-signatures-with.html\"\u003ethis blog post\u003c/a\u003e that shows how great IDA python libraries are.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003cfigure class=\"highlight python\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e# for all function offsets\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003efor\u003c/span\u003e fn_ea \u003cspan class=\"keyword\"\u003ein\u003c/span\u003e Functions():\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e fn_ea == \u003cspan class=\"literal\"\u003eNone\u003c/span\u003e:\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003econtinue\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"comment\"\u003e# get function from offset\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  f = idaapi.get_func(fn_ea)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"comment\"\u003e# get function bytes\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  start = f.startEA\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  size = f.endEA - start\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"built_in\"\u003ebytes\u003c/span\u003e = GetManyBytes(start, size)\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eWouldn’t be cool to have such features without the whole Python and IDA SDK distribution ? :)\u003c/p\u003e\n\u003cp\u003eActually this showed to be way much a simpler task than I’ve initially imagined, you only need a \u003ca href=\"/2014/02/21/libpe-a-fast-pe32pe32-parsing-library/\"\u003egood portable executable parsing library\u003c/a\u003e and a fast disassembler library, for this purpose I’ve used \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://code.google.com/p/distorm/\"\u003eDistorm\u003c/a\u003e which is fast and easy to integrate.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eNOTE\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eA few smart people \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.reddit.com/r/ReverseEngineering/comments/206gs5/programmatically_identifying_and_isolating/\"\u003epointed out\u003c/a\u003e that the following system is prone to false positives. \u003cstrong\u003eThis is totally true\u003c/strong\u003e, I never claimed it to be a perfect approach, but just a proof of concept of what can be achieved using a couple of well written libraries and a few lines of C code.\u003c/p\u003e\n\u003cp\u003eThe main algorithm is very simple.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eSearch for every code/executable section in the PE.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003ePE_FOREACH_SECTION( \u0026amp;pe, pSection )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// skip empty sections\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e( pSection-\u0026gt;SizeOfRawData == \u003cspan class=\"number\"\u003e0\u003c/span\u003e )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003econtinue\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"comment\"\u003e// skip non executable or non code sections\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e( !( pSection-\u0026gt;Characteristics \u0026amp; IMAGE_SCN_CNT_CODE ) \u0026amp;\u0026amp; !( pSection-\u0026gt;Characteristics \u0026amp; IMAGE_SCN_MEM_EXECUTE ) )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e        \u003cspan class=\"keyword\"\u003econtinue\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cul\u003e\n\u003cli\u003eAnalyze each section and search for \u003cstrong\u003eCALL\u003c/strong\u003e branch instructions to a relative address, save that address as a function start.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// Is this instruction a suitable call ?\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e( ( inst-\u0026gt;opcode == I_CALL || inst-\u0026gt;opcode == I_CALL_FAR ) \u0026amp;\u0026amp; inst-\u0026gt;ops[\u003cspan class=\"number\"\u003e0\u003c/span\u003e].type == O_PC )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003euint32_t\u003c/span\u003e dwFunctionAddress = inst-\u0026gt;addr + inst-\u0026gt;imm.sdword + inst-\u0026gt;size;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    ...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cul\u003e\n\u003cli\u003eAnalyze the function start searching for the first \u003cstrong\u003eRET\u003c/strong\u003e instruction, that will be the function end.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003eif\u003c/span\u003e( inst-\u0026gt;opcode == I_RET || inst-\u0026gt;opcode == I_RETF )\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    pFunction-\u0026gt;Address.Size = inst-\u0026gt;addr - pFunction-\u0026gt;Address.VA;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"literal\"\u003efalse\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eEasy isn’t it ? ^_^\u003c/p\u003e\n\u003cp\u003eI’ve implemented this algorithm as the new \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/libpe/tree/master/pefunctions\"\u003epefunctions\u003c/a\u003e project sample inside \u003cstrong\u003elibpe\u003c/strong\u003e repository, enjoy :)\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2014-03-11T22:50:48Z",
  "Author": "Simone Margaritelli"
}