{
  "Source": "www.evilsocket.net",
  "Title": "TLS, Server Name Indication and Why We Need to Encrypt It",
  "Link": "https://www.evilsocket.net/2017/06/30/BetterCap-1-6-1-TLS-Server-Name-Indication-and-Why-We-Need-to-Encrypt-It/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eYesterday I released version 1.6.1 of \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://bettercap.org/\"\u003ebettercap\u003c/a\u003e and among other things, you can read in the changelog:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e* Huge improvement on HTTPS parser, now it parses TLS Client Hello messages with SNI extension in order to extract the real hostname.\n...\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eBut what does this actually mean? And how can we protect ourselves from it? (Hint: \u003cstrong\u003ewe can’t, yet\u003c/strong\u003e)\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2017/07/sni.png\" alt=\"sni\"/\u003e\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003ch1 id=\"Server-Name-Indication\"\u003e\u003ca href=\"#Server-Name-Indication\" class=\"headerlink\" title=\"Server Name Indication\"\u003e\u003c/a\u003eServer Name Indication\u003c/h1\u003e\u003cp\u003eLet’s take a simple HTTP request to explain the concept, this is a GET request to the index of somesite.com:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGET / HTTP/1.1\nHost: somesite.com\nConnection: close\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eAs we all know, once it gets this request the server is able to “understand” what virtual host it’s supposed to serve by reading the \u003ccode\u003eHost\u003c/code\u003e header, but what happens when the request is HTTPS and therefore the server can not read the Host header before providing the certificate?\u003cbr/\u003eWhat if server X is hosting multiple domains behind HTTPS? What’s the certificate it should send to the client? Here it comes \u003cstrong\u003eServer Name Indication\u003c/strong\u003e ( \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://en.wikipedia.org/wiki/Server_Name_Indication\"\u003eSNI\u003c/a\u003e ) for the rescue!\u003c/p\u003e\n\u003cp\u003eSNI is a mechanism which has been introduced in TLS as an extension to solve this problem, long story short, during the TLS handshake the client will send the name of the host it wants to connect to ( pretty much like the Host header on HTTP ), this piece of information is going to be transmitted \u003cstrong\u003eunencrypted\u003c/strong\u003e ( it has to! ), therefore we can intercept it.\u003c/p\u003e\n\u003cp\u003eAs you can see in the image, by parsing such handshakes, bettercap is now able to tell you \u003cstrong\u003eexactly\u003c/strong\u003e what websites the target is browsing even if they’re on HTTPS, while the version before only “assumed” which was the domain by resolving it from the IP (and most of the times, failing miserably to give any useful result).\u003c/p\u003e\n\u003ch1 id=\"How\"\u003e\u003ca href=\"#How\" class=\"headerlink\" title=\"How\"\u003e\u003c/a\u003eHow\u003c/h1\u003e\u003cp\u003eVery simple, with just a \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/bettercap/blob/master/lib/bettercap/sniffer/parsers/https.rb\"\u003efew lines\u003c/a\u003e of (bad) code of course!\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e# poor man\u0026#39;s TLS Client Hello with SNI extension parser :P\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif pkt.respond_to?(:tcp_dst) and \\\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e pkt.payload[0] == \u0026#34;\\x16\u0026#34; and \\\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e pkt.payload[1] == \u0026#34;\\x03\u0026#34; and \\\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e pkt.payload =~ /\\x00\\x00.{4}\\x00.{2}([a-z0-9]+([\\-\\.]{1}[a-z0-9]+)*\\.[a-z]{2,6})\\x00/\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003ehostname = $1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eif pkt.tcp_dst != 443\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  hostname += \u0026#34;:#{pkt.tcp_dst}\u0026#34;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eend\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e...\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003ch1 id=\"What-can-we-do-about-it\"\u003e\u003ca href=\"#What-can-we-do-about-it\" class=\"headerlink\" title=\"What can we do about it?\"\u003e\u003c/a\u003eWhat can we do about it?\u003c/h1\u003e\u003cp\u003e\u003cimg src=\"/images/2017/07/encrypt.png\" alt=\"encrypt all the things\"/\u003e\u003c/p\u003e\n\u003cp\u003eSeriously, there’s not much we can do about it right now, which means \u003cstrong\u003eeven if you’re using HTTPS only, the domains you’re browsing are leaked on the network anyway … adios privacy!\u003c/strong\u003e The only logical thing would be to \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://www.ietf.org/proceedings/94/slides/slides-94-tls-8.pdf\"\u003eencrypt the SNI payload\u003c/a\u003e as suggested in this document ( tnx to \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://twitter.com/fpietrosanti\"\u003eFabio\u003c/a\u003e for the link! ), but I guess we’ll have to wait some time :)\u003c/p\u003e\n\u003ch1 id=\"One-more-thing\"\u003e\u003ca href=\"#One-more-thing\" class=\"headerlink\" title=\"One more thing\"\u003e\u003c/a\u003eOne more thing\u003c/h1\u003e\u003cp\u003e\u003cstrong\u003eUSE A VPN, ESPECIALLY ON PUBLIC NETWORKS FOR F°°°’S SAKE!!!\u003c/strong\u003e\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2017-06-30T10:28:18Z",
  "Author": "Simone Margaritelli"
}