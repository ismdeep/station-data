{
  "Source": "www.evilsocket.net",
  "Title": "How to Hook Win32 API With Kernel Patching",
  "Link": "https://www.evilsocket.net/2014/02/01/How-to-hook-Win32-API-with-kernel-patching/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eThis post is about \u003cstrong\u003eSSDT\u003c/strong\u003e patching to perform API hooking within the kernel instead of the classic user mode hooking using remote threads and things like that.\u003cbr/\u003eSSDT hooking is as far as I know the lowest level technique to replace/hook/intercept/whatever API and for this reason has been used for years both by malwares writers and AV vendors.\u003cbr/\u003eI’m using the past tence due to the fact that on 2005 Microsoft introduced a Kernel Patching Protection ( also known as “PatchGuard” ) for 64 bit systems, making this technique uneffective in the worst case or quite harder to perform in the average case.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003cp\u003eIf you open the file \u003cstrong\u003entoskrnl.exe\u003c/strong\u003e ( located in the System32/SysWOW64 folder ) with your preferred disassembler, you will noticed a \u003cstrong\u003eKeServiceDescriptorTable\u003c/strong\u003e symbol being exported:\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/images/2014/Feb/KeServiceDescriptorTable_export.png\" alt=\"KeServiceDescriptorTable\"/\u003e\u003c/p\u003e\n\u003cp\u003eIt’s a pointer to a kernel structure defined as\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003etypedef\u003c/span\u003e \u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"title\"\u003eSystemServiceDescriptorTable\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e{\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  PULONG ServiceTableBase;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  PULONG ServiceCounterTableBase;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  ULONG NumberOfServices;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  PUCHAR ParamTableBase;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}SSDT,*PSSDT;\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eIt works as a big lookup table of Windows Native System Services, a list of kernel API such as NtTerminateProcess, NtLoadDriver, etc.\u003c/p\u003e\n\u003cp\u003eAs you might correctly guess, if it’s exported it can be read and afterwards modified by a kernel driver with some hacks to temporary disable writing protection.\u003c/p\u003e\n\u003cp\u003eStarting from the address \u003cstrong\u003eServiceTableBase\u003c/strong\u003e, each routine can be translated to its service index by the following formula:\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e(*(PULONG)((PUCHAR)Api+\u003cspan class=\"number\"\u003e1\u003c/span\u003e))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eFor instance, if we wanted to obtain the service index for \u003cstrong\u003eZwTerminateProcess\u003c/strong\u003e, we would do:\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eULONG ulZwTerminateProcessNumber = (*(PULONG)((PUCHAR)ZwTerminateProcess+\u003cspan class=\"number\"\u003e1\u003c/span\u003e))\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003e( This would suggest that every kernel service routine has its own service number stored in 4 bytes after the first byte of its opcodes )\u003c/p\u003e\n\u003cp\u003eOnce we have the correct service number for the API we want to hook, we can replace it in the descriptor table disabling write protection with the CR0 cpu register, setting the new routine address and then restoring CR0 protection.\u003c/p\u003e\n\u003cfigure class=\"highlight c\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e10\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e11\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e12\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e13\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e14\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e15\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e16\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e17\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e18\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e19\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e21\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e22\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e23\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e24\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e25\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003etypedef\u003c/span\u003e \u003cspan class=\"title\"\u003eNTSTATUS\u003c/span\u003e \u003cspan class=\"params\"\u003e(*NtTerminateProcess_T)\u003c/span\u003e\u003cspan class=\"params\"\u003e(HANDLE,NTSTATUS)\u003c/span\u003e\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eULONG ulZwTerminateProcessNumber = (*(PULONG)((PUCHAR)ZwTerminateProcess+\u003cspan class=\"number\"\u003e1\u003c/span\u003e))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// disable write protection\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e__asm\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  mov eax,cr0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eand\u003c/span\u003e eax,\u003cspan class=\"keyword\"\u003enot\u003c/span\u003e \u003cspan class=\"number\"\u003e0x10000\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  mov cr0,eax\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// store the original address to restore it on driver unloading\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eNtTerminateProcess_T fnOriginalNtTerminateProcess = (NtTerminateProcess_T)*(PULONG)(ULONG)KeServiceDescriptorTable-\u0026gt;ServiceTableBase + ulZwTerminateProcessNumber * \u003cspan class=\"number\"\u003e4\u003c/span\u003e;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// finally patch the table with our own function\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e*((PULONG)ulZwTerminateProcessNumber) = (ULONG)OurNtTerminateProcessHook;\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"comment\"\u003e// restore write protection\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e__asm\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  mov eax,cr0\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"keyword\"\u003eor\u003c/span\u003e eax,\u003cspan class=\"number\"\u003e0x10000\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  mov cr0,eax\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eAs you can see we store the original function pointer, this is important since once the driver will start the unloading process, we need it to restore the original API address before closing. Forgetting about this step would lead to unpredictable behaviour ( almost surely a BSOD ) since the kernel would call an address that it’s not mapped anymore or that it’s being used by something else.\u003c/p\u003e\n\u003cp\u003eThis is a short overview of this old but effective technique, which was used to protect processes from being killed hooking \u003cstrong\u003eNtTerminateProcess\u003c/strong\u003e for instance and filtering by PID.\u003cbr/\u003eSince PatchGuard has been introduced, SSDT hooking became hard to perform therefore Microsoft released a whole new set of \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://msdn.microsoft.com/en-us/library/windows/hardware/ff558692(v=vs.85).aspx\"\u003ekernel callbacks\u003c/a\u003e for newer systems, I will talk about this on another post.\u003c/p\u003e\n\u003cp\u003eThe full source code for SSDT patching can be found \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.emoticode.net/c/ssdt-hook-driver-with-process-protection.html\"\u003ehere\u003c/a\u003e, tnx to \u003cstrong\u003ezwclose7\u003c/strong\u003e from rohitab for the source code.\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2014-02-01T18:59:55Z",
  "Author": "Simone Margaritelli"
}