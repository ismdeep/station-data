{
  "Source": "www.evilsocket.net",
  "Title": "How to Use Old GSM Protocols/encodings to Know if a User Is Online on the GSM Network AKA PingSMS 2.0",
  "Link": "https://www.evilsocket.net/2015/07/27/How-to-use-old-GSM-protocols-encodings-to-know-if-a-user-is-Online-on-the-GSM-Network-AKA-PingSMS-2-0/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eIn the last few months I’ve been playing with Android’s low level GSM API, a few years ago the (in)famous \u003cstrong\u003esendRawPdu\u003c/strong\u003e API was available, allowing a developer to manually encode a SMS message at a very low level before sending it to the GSM baseband itself and quite a few applications sending all kind of weird SMS ( flash sms, silent sms, etc ) were born ( for a brief overview of PDU encoding refer to \u003ca target=\"_blank\" rel=\"noopener\" href=\"http://www.smartposition.nl/resources/sms_pdu.html\"\u003ethis page\u003c/a\u003e ).\u003c/p\u003e\n\u003cp\u003e(Un)fortunately Google decided to remove that API, it’s still not sure if they did it for security related purposes or during some refactoring of their IPC IBinder mechanism, but nowadays it’s no more available unless you use some very old phones/firmwares ( on most devices they removed the ttyUSB serial interfaces to send AT commands to the GSM modem as well ).\u003c/p\u003e\n\u003cp\u003eUntil a couple of months ago, when I found the \u003cstrong\u003eSmsManager.sendDataMessage\u003c/strong\u003e API which, apparently, it’s not used anywhere ( if you search for it you’ll find only a few examples, but nothing regarding how to use it with manually encoded PDUs ).\u003cbr/\u003eUsing this API we’re able to manually encode our SMS, moreover we can specific a “port” as one of its arguments which will identify what kind of sms we’re gonna send, in this post I’ll talk about port 2948, namely the port used to send \u003cstrong\u003eWAP PUSH notifications\u003c/strong\u003e.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003cp\u003eWAP PUSH messages were an old mechanism to basically force a remote device to visit a URL encoded in the SMS payload itself ( I know, security wise it was very dumb, but we’re talking about the 90s ), this specific request is called a “\u003cstrong\u003eService Load\u003c/strong\u003e” (SL) request, where an XML payload like the following was encoded in a binary form and sent along the PDU to the device.\u003c/p\u003e\n\u003cfigure class=\"highlight xml\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e\u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e\u0026lt;!DOCTYPE \u003cspan class=\"meta-keyword\"\u003esl\u003c/span\u003e \u003cspan class=\"meta-keyword\"\u003ePUBLIC\u003c/span\u003e \u003cspan class=\"meta-string\"\u003e\u0026#34;-//WAPFORUM//DTD SL 1.0//EN\u0026#34;\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"meta\"\u003e                    \u003cspan class=\"meta-string\"\u003e\u0026#34;www.wapforum.org/DTD/sl.dtd\u0026#34;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"tag\"\u003e\u0026lt;\u003cspan class=\"name\"\u003esl\u003c/span\u003e \u003cspan class=\"attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"string\"\u003e\u0026#34;http://some-evil-site.com/evil-content.html\u0026#34;\u003c/span\u003e/\u0026gt;\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eNowadays this protocol is no more handled for obvious reasons … I said \u003cstrong\u003ehandled\u003c/strong\u003e and not \u003cstrong\u003esupported\u003c/strong\u003e because the GSM basebands software is actually still able to receive it, but the higher level software ( the OS and its components ) will simply ignore it.\u003cbr/\u003eFor instance, on Android 5.0 you can see the following logs ( \u003ccode\u003elogcat -b radio\u003c/code\u003e ) when the device receives such payload:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e9\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eD/WAP PUSH( 1287): Rx: 0a0603...\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eD/RILC    (  185): SOCKET RIL_SOCKET_1 REQUEST: SMS_ACKNOWLEDGE length:20\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eD/RILC    (  185): RequestComplete, RIL_SOCKET_1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eE/RILC    (  185): Send Response to RIL_SOCKET_1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eD/RILJ    ( 1287): [9277]\u0026lt; SMS_ACKNOWLEDGE  [SUB0]\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eV/WAP PUSH( 1287): appid found: 2:application/vnd.wap.slc\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eW/WAP PUSH( 1287): wap push manager not found!\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eV/WAP PUSH( 1287): fall back to existing handler\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003eV/WAP PUSH( 1287): Delivering MMS to: com.google.android.talk com.google.android.apps.hangouts.sms.MmsWapPushDeliverReceiver\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eSo the event is delivered to the Google Hangouts application ( the default SMS/MMS handler on my phone ) which simply \u003cstrong\u003ewill ignore this kind of payloads\u003c/strong\u003e unless they are simple MMS instead of anything else ( WAP PUSHes in our case ):\u003c/p\u003e\n\u003cfigure class=\"highlight java\"\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e6\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e7\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e8\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"class\"\u003e\u003cspan class=\"keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"title\"\u003eMmsWapPushDeliverReceiver\u003c/span\u003e \u003cspan class=\"keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"title\"\u003eBroadcastReceiver\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"class\"\u003e\u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  \u003cspan class=\"function\"\u003e\u003cspan class=\"keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"title\"\u003eonReceive\u003c/span\u003e\u003cspan class=\"params\"\u003e(Context paramContext, Intent paramIntent)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"function\"\u003e  \u003c/span\u003e{\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    \u003cspan class=\"keyword\"\u003eif\u003c/span\u003e ((\u003cspan class=\"string\"\u003e\u0026#34;android.provider.Telephony.WAP_PUSH_DELIVER\u0026#34;\u003c/span\u003e.equals(paramIntent.getAction())) \u0026amp;\u0026amp; (\u003cspan class=\"string\"\u003e\u0026#34;application/vnd.wap.mms-message\u0026#34;\u003c/span\u003e.equals(paramIntent.getType())))\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e      RealTimeChatService.a(paramIntent.getByteArrayExtra(\u003cspan class=\"string\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e));\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e  }\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThis means that, although the device will receive the data, \u003cstrong\u003eno kind of notification will be shown to the user\u003c/strong\u003e and the data itself won’t be saved anywhere in the system, but simply discarded.\u003c/p\u003e\n\u003cp\u003eHaving said that, there’s a tiny detail that’s very handy for us … after delivering the WAP PUSH message, the destination \u003cstrong\u003eoperator BTS will reply to us with a delivery report\u003c/strong\u003e. This report will be sent only if the device is turned on and completely able to receive the message ( turned on and with enough GSM network coverage ).\u003cbr/\u003eIn fact, the sendDataMessage API accepts as its last argument a delivery PendingIntent, in other words our application will be informed as soon as the delivery report will be sent back.\u003c/p\u003e\n\u003cp\u003eWe can take advantage of this to do the following:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eCraft a WAP PUSH message encoding it manually.\u003c/li\u003e\n\u003cli\u003ePass it to the sendDataMessage API and register a delivery intent.\u003c/li\u003e\n\u003cli\u003eThe WAP PUSH will be sent to the target mobile phone and we’ll receive the delivery notification if the phone is turned on, if it’s not we’ll receive it as soon as it will be turned on.\u003c/li\u003e\n\u003cli\u003eThe target user won’t notice absolutely anything.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eSo, we can basically track a target user GSM network activity invisibly, knowing exactly when the target’s device is turned on without him having a single chance to notice anything.\u003c/p\u003e\n\u003cp\u003e\u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/pdusms\"\u003eHere\u003c/a\u003e‘s a very simple PoC application I’ve made to show how to use such API, the same kind of PDU can be sent using a normal GSM serial dongle and some software like Gnokii.\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2015-07-27T19:47:03Z",
  "Author": "Simone Margaritelli"
}