{
  "Source": "www.evilsocket.net",
  "Title": "Android Native API Hooking With Library Injection and ELF Introspection.",
  "Link": "https://www.evilsocket.net/2015/05/04/Android-Native-API-Hooking-with-Library-Injection-and-ELF-Introspection/",
  "Content": "\u003cdiv class=\"content\" itemprop=\"articleBody\"\u003e\n\u003cp\u003eThis post can be considered both the part 2 of the previous “\u003ca href=\"https://www.evilsocket.net/2015/05/01/dynamically-inject-a-shared-library-into-a-running-process-on-androidarm/\"\u003eDynamically inject a shared library into a running process on Android/ARM\u003c/a\u003e“ and a proof of concept of the same, namely what can be done with library injection on Android.\u003c/p\u003e\n\u003cspan id=\"more\"\u003e\u003c/span\u003e\n\u003ch1 id=\"TL-DR\"\u003e\u003ca href=\"#TL-DR\" class=\"headerlink\" title=\"TL;DR\"\u003e\u003c/a\u003eTL;DR\u003c/h1\u003e\u003cp\u003eI’ve updated the source code of the \u003ca target=\"_blank\" rel=\"noopener\" href=\"https://github.com/evilsocket/arminject\"\u003earminject\u003c/a\u003e project on github adding a library that once injected into a process will hook its \u003cstrong\u003eopen\u003c/strong\u003e API and print some logs to the logcat, the \u003cstrong\u003emake test\u003c/strong\u003e command will basically start a new \u003cstrong\u003eChrome\u003c/strong\u003e browser process, use the \u003cstrong\u003einjector\u003c/strong\u003e discussed in the previous post to inject \u003cstrong\u003elibhook.so\u003c/strong\u003e into it and wait for its logs to appear, an example output could be like:\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e@ Attaching to process com.android.chrome ...\n@ Injecting library /data/local/tmp/libhook.so into process 8511.\n@ Calling dlopen in target process ...\n@ dlopen returned 0xb5202dc4\n\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/data/data/com.android.chrome/app_chrome/.com.google.Chrome.gJY5h4\u0026#39;, 194)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/data/data/com.android.chrome/shared_prefs/com.android.chrome_preferences.xml\u0026#39;, 577)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/data/data/com.android.chrome/files/android_ticl_service_state.bin\u0026#39;, 0)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/data/data/com.android.chrome/files/ticl_storage.bin\u0026#39;, 0)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/data/data/com.android.chrome/files/android_ticl_service_state.bin\u0026#39;, 577)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\nI/LIBHOOK ( 8511): [8511] open(\u0026#39;/dev/ashmem\u0026#39;, 2)\n...\n...\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"Hooking-System-Functions\"\u003e\u003ca href=\"#Hooking-System-Functions\" class=\"headerlink\" title=\"Hooking System Functions\"\u003e\u003c/a\u003eHooking System Functions\u003c/h1\u003e\u003cp\u003eAs I basically wrote everywhere in the source to avoid any kind of misunderstanding, the libhook.so code is almost totally based on \u003cstrong\u003eAndrey Petrov\u003c/strong\u003e‘s blog post “\u003ca target=\"_blank\" rel=\"noopener\" href=\"http://shadowwhowalks.blogspot.it/2013/01/android-hacking-hooking-system.html\"\u003eAndroid hacking: hooking system functions used by Dalvik\u003c/a\u003e“, although I had to modify and fix its original version since it didn’t work ( page align errors, memory protection faults and so forth ).\u003c/p\u003e\n\u003cp\u003eThe main concept is quite simple yet neat, once the library is injected inside the target process, its \u003cstrong\u003econstructor\u003c/strong\u003e will be executed.\u003cbr/\u003eA constructor function is declared like this:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003cfigcaption\u003e\u003cspan\u003elang-c\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e__attribute__((constructor)) somefunction() {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    // something\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eThis means that “somefunction” will be executed as soon as the library is loaded.\u003c/p\u003e\n\u003cp\u003eThis allowed me to exploit Petrov’s code at runtime and patch the process relocation table, an \u003cstrong\u003eELF\u003c/strong\u003e structure that holds the addressess of system functions used by the program.\u003cbr/\u003eThe logic steps to do this are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGet the base pointer of the module using \u003cstrong\u003edlopen\u003c/strong\u003e.\u003c/li\u003e\n\u003cli\u003eGiven its pointer, lookup the symbol ( \u003cstrong\u003eopen\u003c/strong\u003e in our case ) inside its (sym|str)tab.\u003c/li\u003e\n\u003cli\u003eSearch the symbol inside the \u003cstrong\u003ereloc\u003c/strong\u003e table by index.\u003c/li\u003e\n\u003cli\u003eBackup its original address and finally patch it with our own hook function address.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOnce the hook function is called, it will log its parameters and then call the original function we previously backupped:\u003c/p\u003e\n\u003cfigure class=\"highlight plain\"\u003e\u003cfigcaption\u003e\u003cspan\u003elang-c\u003c/span\u003e\u003c/figcaption\u003e\u003ctable\u003e\u003ctbody\u003e\u003ctr\u003e\u003ctd class=\"gutter\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003e1\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e2\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e3\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e4\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e5\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003ctd class=\"code\"\u003e\u003cpre\u003e\u003cspan class=\"line\"\u003eint hook_open(const char *pathname, int flags) {\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    HOOKLOG( \u0026#34;[%d] open(\u0026#39;%s\u0026#39;, %d)\u0026#34;, getpid(), pathname, flags );\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e    return __open( pathname, flags );\u003c/span\u003e\u003cbr/\u003e\u003cspan class=\"line\"\u003e}\u003c/span\u003e\u003cbr/\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/tbody\u003e\u003c/table\u003e\u003c/figure\u003e\n\u003cp\u003eObviously this method can be applied to any kind of function, even Dalvik high level native API.\u003c/p\u003e\n\u003cp\u003eEnjoy :)\u003c/p\u003e\n\u003c/div\u003e",
  "Date": "2015-05-04T17:15:24Z",
  "Author": "Simone Margaritelli"
}